;;-*-Lisp-*-
(in-package goal)

;; name: generic-obs.gc
;; name in dgo: generic-obs
;; dgos: ENGINE, GAME

(define-extern ja-post (function none :behavior process-drawable))
(define-extern merc-blend-shape (function process-drawable object))
(define-extern merc-eye-anim (function process-drawable none))
(define-extern process-release? (function process symbol :behavior process))

;; NOTE - for guard-projectile
(define-extern explosion-spawn (function process-drawable type explosion-init-params none))

;; DECOMP BEGINS

(defskelgroup skel-spotlight spotlight spotlight-lod0-jg -1
              ((spotlight-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 10)
              :origin-joint-index 5
              )

;; WARN: Return type mismatch object vs (pointer sparticle-launch-group).
(defun entity-lookup-part-group ((arg0 entity-actor) (arg1 (pointer string)) (arg2 symbol))
  (local-vars (sv-16 res-tag))
  (let ((gp-0 (the-as object #f)))
    (set! sv-16 (new 'static 'res-tag))
    (let ((s4-0 (res-lump-data arg0 arg2 pointer :tag-ptr (& sv-16))))
      (if (not s4-0)
          (go process-drawable-art-error (the-as string #f))
          )
      (let ((s3-0 (the-as object (-> (the-as (pointer uint32) s4-0)))))
        (cond
          ((part-group-pointer? (the-as pointer s3-0))
           (set! gp-0 (-> (the-as (pointer uint32) s4-0)))
           )
          ((= (-> (the-as basic s3-0) type) string)
           (if arg1
               (set! (-> arg1 0) (the-as string s3-0))
               )
           (set! gp-0 (lookup-part-group-pointer-by-name (the-as string s3-0)))
           (if (the-as (pointer object) gp-0)
               ;; TODO - manual fix here
               (set! (-> (the-as (pointer int32) s4-0)) (the-as int gp-0))
               )
           )
          (else
            (go process-drawable-art-error (the-as string s3-0))
            )
          )
        )
      )
    (the-as (pointer sparticle-launch-group) gp-0)
    )
  )

(defbehavior clone-anim-once process-drawable ((arg0 handle) (arg1 symbol) (arg2 string))
  (logclear! (-> self skel status) (joint-control-status valid-spooled-frame))
  (let ((gp-0 (handle->process arg0)))
    (if gp-0
        (joint-control-copy! (-> self skel) (-> (the-as process-drawable gp-0) skel))
        )
    (cond
      ((and (the-as process-drawable gp-0) (joint-control-remap!
                                             (-> self skel)
                                             (-> self draw art-group)
                                             (-> (the-as process-drawable gp-0) draw art-group)
                                             '()
                                             0
                                             arg2
                                             )
            )
       (when arg1
         (let* ((s5-1 (-> self root))
                (a0-7 (if (type? s5-1 collide-shape)
                          (the-as collide-shape s5-1)
                          )
                      )
                )
           (if a0-7
               (move-to-point! a0-7 (-> (the-as process-drawable gp-0) root trans))
               (set! (-> self root trans quad) (-> (the-as process-drawable gp-0) root trans quad))
               )
           )
         (quaternion-copy! (-> self root quat) (-> (the-as process-drawable gp-0) root quat))
         )
       (if (logtest? (-> (the-as process-drawable gp-0) skel status) (joint-control-status valid-spooled-frame))
           (logior! (-> self skel status) (joint-control-status valid-spooled-frame))
           )
       (logclear! (-> self draw status) (draw-control-status no-draw no-draw-temp uninited))
       (if (or (zero? (-> self skel active-channels)) (not (-> self skel root-channel 0 frame-group)))
           (logior! (-> self draw status) (draw-control-status no-draw-temp))
           )
       (let* ((gp-1 self)
              (v1-38 (if (type? gp-1 manipy)
                         gp-1
                         )
                     )
              )
         (if (and v1-38 (not (-> (the-as manipy v1-38) draw?)))
             (logior! (-> self draw status) (draw-control-status no-draw-temp))
             )
         )
       (update-anim-data (-> self skel))
       (do-joint-math (-> self draw) (-> self node-list) (-> self skel))
       (let ((a0-22 (-> self skel effect)))
         (if a0-22
             (update-effects a0-22)
             )
         )
       (if (logtest? (-> self skel status) (joint-control-status blend-shape blend-shape-valid))
           (merc-blend-shape self)
           )
       (if (logtest? (-> self skel status) (joint-control-status eye-anim-valid eye-anim))
           (merc-eye-anim self)
           )
       )
      (else
        (set! (-> self skel active-channels) (the-as uint 0))
        (logior! (-> self draw status) (draw-control-status no-draw))
        (ja-post)
        )
      )
    )
  0
  (none)
  )

(defbehavior clone-anim process-drawable ((arg0 handle) (arg1 symbol) (arg2 string))
  (ja-post)
  (while (handle->process arg0)
    (clone-anim-once arg0 #t arg2)
    (suspend)
    )
  (logclear! (-> self skel status) (joint-control-status valid-spooled-frame))
  0
  (none)
  )

(defmethod move-along-path swingpole ((obj swingpole))
  (with-pp
    (if (nonzero? (-> obj draw))
        (ja-post)
        )
    (cond
      ((nonzero? (-> obj path))
       (set! (-> obj path-pos) (get-norm! (-> obj sync) 0))
       (let ((s5-0 (new 'stack-no-clear 'vector)))
         (get-point-at-percent-along-path! (-> obj path) s5-0 (-> obj path-pos) 'interp)
         (set! (-> obj speed)
               (* (vector-vector-distance s5-0 (-> obj root-override trans)) (-> pp clock frames-per-second))
               )
         (move-to-point! (-> obj root-override) s5-0)
         )
       )
      ((>= (-> obj joint-track) 0)
       (let ((v1-15 (ppointer->process (-> obj parent)))
             (s5-1 (new 'stack-no-clear 'vector))
             )
         (let ((s4-0 (-> (the-as process-drawable v1-15) node-list data (-> obj joint-track))))
           (vector<-cspace! s5-1 s4-0)
           (vector-normalize-copy! (-> obj dir) (the-as vector (-> s4-0 bone transform)) 1.0)
           )
         (move-to-point! (-> obj root-override) s5-1)
         )
       )
      )
    (when (nonzero? (-> obj sound))
      (set! (-> obj sound trans quad) (-> obj root-override trans quad))
      (let ((f30-0 (lerp-scale -0.1 -0.05 (-> obj speed) 8192.0 20480.0))
            (f0-6 (lerp-scale 0.7 1.0 (-> obj speed) 8192.0 20480.0))
            )
        (set! (-> obj sound pitch) (the int (* 1524.0 f30-0)))
        (set! (-> obj sound volume) (the int (* 1024.0 f0-6)))
        )
      (update! (-> obj sound))
      )
    0
    (none)
    )
  )

(defstate idle (swingpole)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('touch 'attack)
                      (if (send-event proc 'pole-grab (-> event param 0))
                          (go-virtual active (process->handle proc))
                          )
                      #f
                      )
                     )
            )
    )
  :code (behavior ()
    (if (nonzero? (-> self draw))
        (ja-post)
        )
    (update-transforms (-> self root-override))
    (cond
      ((or (nonzero? (-> self path)) (>= (-> self joint-track) 0))
       (until #f
         (move-along-path self)
         (suspend)
         )
       #f
       )
      (else
        (logior! (-> self mask) (process-mask sleep))
        (suspend)
        0
        )
      )
    (none)
    )
  )

(defstate active (swingpole)
  :virtual #t
  :code (behavior ((arg0 handle))
    (move-along-path self)
    (suspend)
    (while (let* ((s5-0 (handle->process arg0))
                  (a0-7 (if (type? s5-0 process-focusable)
                            s5-0
                            )
                        )
                  )
             (and a0-7 (focus-test? (the-as process-focusable a0-7) pole))
             )
      (move-along-path self)
      (suspend)
      )
    (let ((gp-1 (current-time)))
      (until (>= (- (current-time) gp-1) (seconds 0.5))
        (move-along-path self)
        (suspend)
        )
      )
    (go-virtual idle)
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! swingpole ((obj swingpole) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  "Copy defaults from the entity."
  (stack-size-set! (-> obj main-thread) 128)
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((v1-5 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-5 prim-core collide-as) (collide-spec collectable))
      (set! (-> v1-5 prim-core collide-with) (collide-spec jak player-list tobot))
      (set-vector! (-> v1-5 local-sphere) 0.0 0.0 0.0 12288.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-5)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-8 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-8 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-8 prim-core collide-with))
      )
    (set! (-> obj root-override) s4-0)
    )
  (set! (-> obj root-override trans quad) (-> arg0 extra trans quad))
  (quaternion-copy! (-> obj root-override quat) (-> arg0 quat))
  (vector-identity! (-> obj root-override scale))
  (vector-y-quaternion! (-> obj dir) (-> obj root-override quat))
  (set! (-> obj joint-track) -1)
  (let ((a1-8 (res-lump-struct (-> obj entity) 'art-name structure)))
    (if a1-8
        (initialize-skeleton-by-name obj (the-as string a1-8))
        )
    )
  (set! (-> obj dir y) 0.0)
  (vector-normalize! (-> obj dir) 1.0)
  (set! (-> obj edge-length) 8192.0)
  (let ((s4-1 (new 'stack-no-clear 'sync-info-params)))
    (let ((a0-19 (res-lump-value arg0 'options uint128 :time -1000000000.0))
          (v1-22 0)
          )
      (if (not (logtest? (the-as int a0-19) 8))
          (set! v1-22 (logior v1-22 1))
          )
      (set! (-> s4-1 sync-type) 'sync-eased)
      (set! (-> s4-1 sync-flags) (the-as sync-flags v1-22))
      )
    (set! (-> s4-1 period) (the-as uint 0))
    (set! (-> s4-1 entity) arg0)
    (set! (-> s4-1 percent) 0.0)
    (set! (-> s4-1 ease-in) 0.2)
    (set! (-> s4-1 ease-out) 0.2)
    (set! (-> s4-1 pause-in) 0.0)
    (set! (-> s4-1 pause-out) 0.0)
    (initialize! (-> obj sync) s4-1)
    )
  (when (nonzero? (-> obj sync period))
    (set! (-> obj path) (new 'process 'curve-control obj 'path -1000000000.0))
    (logior! (-> obj path flags) (path-control-flag display draw-line draw-point draw-text))
    )
  (set! (-> obj sound) (new 'process 'ambient-sound (-> obj entity) (-> obj root-override trans)))
  (go (method-of-object obj idle))
  (none)
  )

(defbehavior swingpole-init swingpole ((arg0 int))
  (stack-size-set! (-> self main-thread) 128)
  (let ((s5-0 (new 'process 'collide-shape self (collide-list-enum hit-by-player))))
    (let ((v1-4 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-4 prim-core collide-as) (collide-spec collectable))
      (set! (-> v1-4 prim-core collide-with) (collide-spec jak player-list tobot))
      (set-vector! (-> v1-4 local-sphere) 0.0 0.0 0.0 12288.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-4)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-7 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-7 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-7 prim-core collide-with))
      )
    (set! (-> self root-override) s5-0)
    )
  (set! (-> self root-override trans quad) (-> (the-as swingpole (-> self parent 0)) root-override trans quad))
  (quaternion-identity! (-> self root-override quat))
  (vector-identity! (-> self root-override scale))
  (set! (-> self joint-track) arg0)
  (set-vector! (-> self dir) 0.0 0.0 1.0 1.0)
  (set! (-> self edge-length) 8192.0)
  (go-virtual idle)
  )

(defstate die (process-hidden)
  :virtual #t
  :code (the-as (function none :behavior process-hidden) nothing)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! process-hidden ((obj process-hidden) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  "Copy defaults from the entity."
  (process-entity-status! obj (entity-perm-status dead) #t)
  (go (method-of-object obj die))
  (none)
  )

(deftype target-start (process-hidden)
  ()
  :method-count-assert 15
  :size-assert         #x80
  :flag-assert         #xf00000080
  )


(deftype camera-start (process-hidden)
  ()
  :method-count-assert 15
  :size-assert         #x80
  :flag-assert         #xf00000080
  )


(defbehavior manipy-post manipy ()
  ((-> self cur-post-hook))
  (when (and (>= (-> self shadow-volume-joint) 0) (-> self draw shadow-ctrl))
    (let ((a2-0 (-> self node-list data (-> self shadow-volume-joint)))
          (a3-0 (-> self draw shadow-ctrl))
          )
      (format *stdcon* "shadow-volume for ~A ~A~%" a2-0 a3-0)
      )
    )
  0
  (none)
  )

(defstate idle (manipy)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (local-vars (s4-0 object))
    (let ((v1-0 event-type))
      (the-as
        object
        (cond
          ((= v1-0 'attackable)
           (cond
             ((-> event param 0)
              (set! s4-0 (logior (process-mask collectable) (-> self mask)))
              (set! (-> self mask) (the-as process-mask s4-0))
              )
             (else
               (set! s4-0 (logclear (-> self mask) (process-mask collectable)))
               (set! (-> self mask) (the-as process-mask s4-0))
               )
             )
           s4-0
           )
          ((= v1-0 'blend-shape)
           (when (nonzero? (-> self skel))
             (cond
               ((-> event param 0)
                (set! s4-0 (logior (-> self skel status) (joint-control-status blend-shape eye-anim)))
                (set! (-> self skel status) (the-as joint-control-status s4-0))
                )
               (else
                 (set! s4-0 (logclear (-> self skel status) (joint-control-status blend-shape eye-anim)))
                 (set! (-> self skel status) (the-as joint-control-status s4-0))
                 )
               )
             s4-0
             )
           )
          ((= v1-0 'shadow)
           (when (nonzero? (-> self draw))
             (cond
               ((-> event param 0)
                (set! s4-0 (-> self shadow-backup))
                (set! (-> self draw shadow) (the-as shadow-geo s4-0))
                s4-0
                )
               (else
                 (set! (-> self draw shadow) #f)
                 #f
                 )
               )
             )
           )
          ((= v1-0 'shadow-volume)
           (let ((v1-17 (get-art-by-name-method (-> self draw jgeo) (the-as string (-> event param 0)) (the-as type #f))))
             (if v1-17
                 (set! (-> self shadow-volume-joint) (+ (-> (the-as joint v1-17) number) 1))
                 )
             )
           (when (and (-> self draw shadow-ctrl) (< 1 arg1) (>= (the-as int (-> event param 1)) 0))
             (let ((v0-1 (command-get-int (-> event param 1) 0)))
               (set! (-> self draw shadow-ctrl settings flags) (the-as shadow-flags v0-1))
               v0-1
               )
             )
           )
          ((= v1-0 'shadow-type)
           (if (and (-> self draw shadow-ctrl) (> arg1 0))
               (set! (-> self draw shadow-ctrl settings shadow-type) (command-get-int (-> event param 0) 0))
               )
           )
          ((= v1-0 'shadow-dir)
           (when (and (-> self draw shadow-ctrl) (> arg1 0))
             (set! s4-0 (-> self draw shadow-ctrl settings shadow-dir))
             (set! (-> (the-as vector s4-0) x) (command-get-float (-> event param 0) 0.0))
             (set! (-> (the-as vector s4-0) y) (command-get-float (-> event param 1) 0.0))
             (set! (-> (the-as vector s4-0) z) (command-get-float (-> event param 2) 0.0))
             (set! (-> (the-as vector s4-0) w) (if (< 3 arg1)
                                                   (command-get-float (-> event param 3) 0.0)
                                                   409600.0
                                                   )
                   )
             s4-0
             )
           )
          ((= v1-0 'shadow-top-plane)
           (when (and (-> self draw shadow-ctrl) (>= arg1 4))
             (set! s4-0 (-> self draw shadow-ctrl settings top-plane))
             (set! (-> (the-as plane s4-0) x) (command-get-float (-> event param 0) 0.0))
             (set! (-> (the-as plane s4-0) y) (command-get-float (-> event param 1) 0.0))
             (set! (-> (the-as plane s4-0) z) (command-get-float (-> event param 2) 0.0))
             (set! (-> (the-as plane s4-0) w) (command-get-float (-> event param 3) 0.0))
             s4-0
             )
           )
          ((= v1-0 'shadow-bot-plane)
           (when (and (-> self draw shadow-ctrl) (>= arg1 4))
             (set! s4-0 (-> self draw shadow-ctrl settings bot-plane))
             (set! (-> (the-as plane s4-0) x) (command-get-float (-> event param 0) 0.0))
             (set! (-> (the-as plane s4-0) y) (command-get-float (-> event param 1) 0.0))
             (set! (-> (the-as plane s4-0) z) (command-get-float (-> event param 2) 0.0))
             (set! (-> (the-as plane s4-0) w) (command-get-float (-> event param 3) 0.0))
             s4-0
             )
           )
          ((= v1-0 'no-fog)
           (set! s4-0 (logior (-> self draw status) (draw-control-status disable-fog)))
           (set! (-> self draw status) (the-as draw-control-status s4-0))
           s4-0
           )
          ((= v1-0 'setup-spotlight-shadow)
           (when (-> self draw shadow-ctrl)
             (let ((v1-53 (command-get-process "spotlight" *target*)))
               (when v1-53
                 (let ((s5-1 (-> (the-as process-drawable v1-53) node-list data 3)))
                   (vector<-cspace! (new 'stack-no-clear 'vector) s5-1)
                   (let ((s5-2 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> s5-1 bone transform vector 2) -1.0))
                         (s4-1
                           (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data (-> self draw shadow-joint-index)))
                           )
                         (f30-0 1638400.0)
                         (s3-0 (new 'stack-no-clear 'collide-query))
                         (f28-0 122880.0)
                         )
                     (set! (-> s3-0 start-pos quad) (-> s4-1 quad))
                     (vector-normalize-copy! (-> s3-0 move-dist) s5-2 f28-0)
                     (let ((v1-64 s3-0))
                       (set! (-> v1-64 radius) 1638.4)
                       (set! (-> v1-64 collide-with) (collide-spec obstacle hit-by-others-list))
                       (set! (-> v1-64 ignore-process0) self)
                       (set! (-> v1-64 ignore-process1) #f)
                       (set! (-> v1-64 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
                       (set! (-> v1-64 action-mask) (collide-action solid))
                       )
                     (let* ((f0-13 (fill-and-probe-using-line-sphere *collide-cache* s3-0))
                            (f28-1 (if (< 0.0 f0-13)
                                       (* f0-13 f28-0)
                                       122880.0
                                       )
                                   )
                            )
                       (the-as object (shadow-control-method-14
                                        (-> self draw shadow-ctrl)
                                        s4-1
                                        s5-2
                                        f30-0
                                        (- f28-1 (command-get-float (-> event param 0) 0.0))
                                        (+ f28-1 (command-get-float (-> event param 1) 0.0))
                                        )
                               )
                       )
                     )
                   )
                 )
               )
             )
           )
          ((= v1-0 'color-mult)
           (when (>= arg1 4)
             (set! s4-0 (-> self draw color-mult))
             (set! (-> (the-as rgbaf s4-0) x) (command-get-float (-> event param 0) 0.0))
             (set! (-> (the-as rgbaf s4-0) y) (command-get-float (-> event param 1) 0.0))
             (set! (-> (the-as rgbaf s4-0) z) (command-get-float (-> event param 2) 0.0))
             (set! (-> (the-as rgbaf s4-0) w) (command-get-float (-> event param 3) 0.0))
             s4-0
             )
           )
          ((= v1-0 'color-mult-vector)
           (set! s4-0 (-> self draw color-mult))
           (set! (-> (the-as rgbaf s4-0) quad) (-> (the-as vector (-> event param 0)) quad))
           s4-0
           )
          ((= v1-0 'color-emissive-vector)
           (set! s4-0 (-> self draw color-emissive))
           (set! (-> (the-as rgbaf s4-0) quad) (-> (the-as vector (-> event param 0)) quad))
           s4-0
           )
          ((= v1-0 'segment)
           (let ((a1-44 (/ (the-as int (-> event param 0)) 8))
                 (a2-5 (/ (the-as int (-> event param 1)) 8))
                 )
             (the-as object (setup-masks (-> self draw) (the-as int a1-44) (the-as int a2-5)))
             )
           )
          ((= v1-0 'trans-hook)
           (set! s4-0 (-> event param 0))
           (set! (-> self new-trans-hook) (the-as (function none) s4-0))
           s4-0
           )
          ((= v1-0 'post-hook)
           (set! s4-0 (-> event param 0))
           (set! (-> self new-post-hook) (the-as (function none) s4-0))
           s4-0
           )
          ((= v1-0 'user-data)
           (set! s4-0 (-> event param 0))
           (set! (-> self userdata) (the-as uint s4-0))
           s4-0
           )
          ((= v1-0 'eval)
           ((the-as (function manipy object) (-> event param 0)) self)
           )
          ((= v1-0 'speed)
           (set! (-> self speed) (the-as float (-> event param 0)))
           )
          ((= v1-0 'event-hook)
           (set! s4-0 (-> event param 0))
           (set! (-> self cur-event-hook) (the-as (function none) s4-0))
           s4-0
           )
          ((= v1-0 'art-joint-anim)
           (set! (-> self new-joint-anim)
                 (get-art-by-name (-> self draw art-group) (the-as string (-> event param 0)) art-joint-anim)
                 )
           (set! s4-0 (-> event param 1))
           (set! (-> self new-joint-anim-blend) (the-as uint s4-0))
           s4-0
           )
          ((= v1-0 'anim-mode)
           (when (nonzero? (-> self skel))
             (set! (-> self anim-mode) (the-as symbol (-> event param 0)))
             (if (= (-> self anim-mode) 'clone-anim)
                 (ja-post)
                 )
             (-> self anim-mode)
             )
           )
          ((or (= v1-0 'origin-joint-index) (= v1-0 'center-joint))
           (set! (-> self draw origin-joint-index) (-> event param 0))
           (set! s4-0 (-> event param 0))
           (set! (-> self draw shadow-joint-index) (the-as uint s4-0))
           s4-0
           )
          ((= v1-0 'max-vis-dist)
           (set! (-> self draw lod-set lod (-> self draw lod-set max-lod) dist) (the-as float (-> event param 0)))
           )
          ((= v1-0 'grab)
           (set! (-> self cur-grab-handle) (process->handle (the-as process (-> event param 0))))
           (let ((v1-98 (handle->process (-> self cur-grab-handle))))
             (when v1-98
               (set! s4-0 (-> self old-grab-pos))
               (set! (-> (the-as vector s4-0) quad) (-> (the-as process-drawable v1-98) root trans quad))
               s4-0
               )
             )
           )
          ((= v1-0 'target)
           (set! s4-0 (process->handle (the-as process (-> event param 0))))
           (set! (-> self cur-target-handle) (the-as handle s4-0))
           s4-0
           )
          ((= v1-0 'trans)
           (cond
             ((type? (-> self root-override) collide-shape)
              (the-as object (move-to-point! (-> self root-override) (the-as vector (-> event param 0))))
              )
             (else
               (set! s4-0 (-> self root-override trans))
               (set! (-> (the-as vector s4-0) quad) (-> (the-as vector (-> event param 0)) quad))
               s4-0
               )
             )
           )
          ((= v1-0 'rot)
           (let ((s5-3 (new 'stack-no-clear 'matrix)))
             (matrix-rotate-y! s5-3 (the-as float (-> event param 0)))
             (matrix->quaternion (-> self root-override quat) s5-3)
             )
           )
          ((= v1-0 'rot-quat)
           (quaternion-copy! (-> self root-override quat) (the-as quaternion (-> event param 0)))
           )
          ((= v1-0 'clone-copy-trans)
           (set! s4-0 (-> event param 0))
           (set! (-> self clone-copy-trans) (the-as symbol s4-0))
           s4-0
           )
          ((= v1-0 'release)
           (set! (-> self cur-grab-handle) (the-as handle #f))
           #f
           )
          ((= v1-0 'draw)
           (set! (-> self draw?) (the-as symbol (-> event param 0)))
           (cond
             ((-> event param 0)
              (let ((v1-114 (logtest? (-> self draw status) (draw-control-status no-draw))))
                (logclear! (-> self draw status) (draw-control-status no-draw))
                (when v1-114
                  (cond
                    ((nonzero? (-> self skel))
                     (let ((gp-1 (-> self skel status)))
                       (logior! (-> self skel status) (joint-control-status sync-math))
                       (set! s4-0 (the-as object (ja-post)))
                       (set! (-> self skel status) gp-1)
                       )
                     s4-0
                     )
                    (else
                      (the-as object (ja-post))
                      )
                    )
                  )
                )
              )
             (else
               (set! s4-0 (logior (-> self draw status) (draw-control-status no-draw)))
               (set! (-> self draw status) (the-as draw-control-status s4-0))
               s4-0
               )
             )
           )
          ((= v1-0 'sync)
           (when (nonzero? (-> self skel))
             (cond
               ((-> event param 0)
                (set! s4-0 (logior (-> self skel status) (joint-control-status sync-math)))
                (set! (-> self skel status) (the-as joint-control-status s4-0))
                )
               (else
                 (set! s4-0 (logclear (-> self skel status) (joint-control-status sync-math)))
                 (set! (-> self skel status) (the-as joint-control-status s4-0))
                 )
               )
             s4-0
             )
           )
          ((= v1-0 'query)
           (case (-> event param 0)
             (('grab)
              (handle->process (-> self cur-grab-handle))
              )
             (('done)
              (case (-> self anim-mode)
                (('play1 'play)
                 (>= (ja-frame-num 0) (the float (+ (-> (ja-group) frames num-frames) -2)))
                 )
                )
              )
             )
           )
          ((= v1-0 'set-frame-num)
           (let ((v1-147 (-> self skel root-channel 0)))
             (set! (-> v1-147 num-func) num-func-identity)
             (set! (-> v1-147 frame-num) (the-as float (-> event param 0)))
             )
           )
          ((= v1-0 'prefix)
           (set! s4-0 (-> event param 0))
           (set! (-> self prefix) (the-as basic s4-0))
           s4-0
           )
          ((= v1-0 'light-index)
           (let ((v0-40 (command-get-int (-> event param 0) 0)))
             (set! (-> self draw light-index) (the-as uint v0-40))
             v0-40
             )
           )
          ((= v1-0 'eye-slot)
           (set! (-> self draw mgeo header eye-ctrl eye-slot) (command-get-int (-> event param 0) 0))
           )
          ((= v1-0 'shadow-mask)
           (let ((v0-42 (command-get-int (-> event param 0) 0)))
             (set! (-> self draw shadow-mask) (the-as uint v0-42))
             v0-42
             )
           )
          ((= v1-0 'shadow-values)
           (let ((v0-43 (command-get-int (-> event param 0) 0)))
             (set! (-> self draw shadow-values) (the-as uint v0-43))
             v0-43
             )
           )
          ((= v1-0 'mirror)
           (cond
             ((-> event param 0)
              (set! s4-0 (-> self node-list data 2))
              (set! (-> (the-as cspace s4-0) param0)
                    (the-as (function cspace transformq none) cspace<-parented-matrix-mirror!)
                    )
              (set! (-> (the-as cspace s4-0) param1) (the-as basic (-> *math-camera* mirror-trans)))
              (set! (-> (the-as cspace s4-0) param2) (the-as basic (-> *math-camera* mirror-normal)))
              )
             (else
               (set! s4-0 (-> self node-list data 2))
               (set! (-> (the-as cspace s4-0) param0) #f)
               )
             )
           s4-0
           )
          ((= v1-0 'draw-mirror)
           (send-event (ppointer->process (-> self child)) 'draw (-> event param 0))
           )
          ((= v1-0 'user)
           (set! s4-0 (-> event param 1))
           (set! (-> self user-uint64 (/ (the-as int (-> event param 0)) 8)) (the-as uint s4-0))
           s4-0
           )
          ((= v1-0 'die)
           (the-as object (deactivate self))
           )
          ((= v1-0 'do-effect)
           (if (and (nonzero? (-> self skel)) (-> self skel effect))
               (the-as
                 object
                 (do-effect (-> self skel effect) (the-as symbol (-> event param 0)) (the-as float (-> event param 1)) -1)
                 )
               )
           )
          (else
            (if (-> self cur-event-hook)
                (the-as object ((-> self cur-event-hook)))
                )
            )
          )
        )
      )
    )
  :trans (behavior ()
    (if (!= (-> self cur-trans-hook) (-> self new-trans-hook))
        (set! (-> self cur-trans-hook) (-> self new-trans-hook))
        )
    (if (!= (-> self cur-post-hook) (-> self new-post-hook))
        (set! (-> self cur-post-hook) (-> self new-post-hook))
        )
    (when (and (-> self new-joint-anim)
               (nonzero? (-> self skel))
               (and (!= (ja-group) (-> self new-joint-anim)) (!= (-> self anim-mode) 'clone-anim))
               )
      (ja-channel-push! 1 (the-as time-frame (-> self new-joint-anim-blend)))
      (ja :group! (-> self new-joint-anim) :num! min)
      )
    (let ((v1-20 (handle->process (-> self cur-grab-handle))))
      (when v1-20
        (let ((gp-1 (-> (the-as process-drawable v1-20) root trans)))
          (if (type? (-> self root-override) collide-shape)
              (move-by-vector!
                (the-as collide-shape (-> self root-override))
                (vector-! (new 'stack-no-clear 'vector) gp-1 (-> self old-grab-pos))
                )
              (vector+!
                (-> self root-override trans)
                (-> self root-override trans)
                (vector-! (new 'stack-no-clear 'vector) gp-1 (-> self old-grab-pos))
                )
              )
          (set! (-> self old-grab-pos quad) (-> gp-1 quad))
          )
        )
      )
    ((-> self cur-trans-hook))
    (none)
    )
  :code (behavior ()
    (logclear! (-> self mask) (process-mask heap-shrunk))
    (until #f
      (case (-> self anim-mode)
        (('loop)
         (ja-post)
         (manipy-post)
         (suspend)
         (ja :num! (loop!))
         )
        (('play)
         (ja-post)
         (manipy-post)
         (suspend)
         (ja :num! (seek!))
         )
        (('copy-parent)
         (let ((v1-17 (-> self skel root-channel 0)))
           (set! (-> v1-17 num-func) num-func-identity)
           (let ((a0-10 (-> self parent)))
             (set! (-> v1-17 frame-num) (-> (the-as process-drawable (if a0-10
                                                                         (the-as process-drawable (-> a0-10 0 self))
                                                                         )
                                                    )
                                            skel
                                            root-channel
                                            0
                                            frame-num
                                            )
                   )
             )
           )
         (ja-post)
         (manipy-post)
         (suspend)
         0
         )
        (('clone-parent)
         (let ((gp-0 (ppointer->process (-> self parent))))
           (set! (-> self post-hook) #f)
           (joint-control-copy! (-> self skel) (-> (the-as process-drawable gp-0) skel))
           (joint-control-remap!
             (-> self skel)
             (-> self draw art-group)
             (-> (the-as process-drawable gp-0) draw art-group)
             '()
             0
             ""
             )
           )
         (update-anim-data (-> self skel))
         (do-joint-math (-> self draw) (-> self node-list) (-> self skel))
         (manipy-post)
         (suspend)
         0
         )
        (('clone-anim)
         (clone-anim-once
           (if (handle->process (-> self cur-target-handle))
               (the-as handle (-> self cur-target-handle))
               (ppointer->handle (-> self parent))
               )
           (-> self clone-copy-trans)
           (the-as string (-> self prefix))
           )
         (manipy-post)
         (suspend)
         0
         )
        (('mirror)
         (let ((gp-1 (if (handle->process (-> self cur-target-handle))
                         (-> self cur-target-handle)
                         (ppointer->handle (-> self parent))
                         )
                     )
               )
           (clone-anim-once gp-1 (-> self clone-copy-trans) (the-as string (-> self prefix)))
           (logior! (-> self draw global-effect) (draw-control-global-effect disable-envmap))
           (set! (-> self draw light-index) (the-as uint 5))
           (if (logtest? (-> (the-as process-drawable (handle->process gp-1)) draw status)
                         (draw-control-status no-draw no-draw-temp no-draw-bounds)
                         )
               (logior! (-> self draw status) (draw-control-status no-draw-temp))
               )
           )
         (manipy-post)
         (suspend)
         0
         )
        (('still)
         (ja-post)
         (manipy-post)
         (suspend)
         0
         )
        (('play1)
         (ja-post)
         (manipy-post)
         (suspend)
         (ja :num! (seek! max (-> self speed)))
         (if (ja-done? 0)
             (deactivate self)
             )
         )
        )
      )
    #f
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior manipy-init manipy ((arg0 vector) (arg1 entity-actor) (arg2 skeleton-group) (arg3 vector) (arg4 object))
  (stack-size-set! (-> self main-thread) 128)
  (logior! (-> self mask) (process-mask heap-shrunk))
  (process-entity-set! self arg1)
  (cond
    ((= arg3 'collide-shape-moving)
     (let ((s3-1 (new 'process 'collide-shape-moving self (collide-list-enum hit-by-player))))
       (set! (-> s3-1 dynam) (copy *standard-dynamics* 'process))
       (set! (-> s3-1 reaction) cshape-reaction-default)
       (set! (-> s3-1 no-reaction)
             (the-as (function collide-shape-moving collide-query vector vector object) nothing)
             )
       (let ((v1-11 (new 'process 'collide-shape-prim-sphere s3-1 (the-as uint 0))))
         (set-vector! (-> v1-11 local-sphere) 0.0 0.0 0.0 4096.0)
         (set! (-> s3-1 total-prims) (the-as uint 1))
         (set! (-> s3-1 root-prim) v1-11)
         )
       (set! (-> s3-1 nav-radius) (* 0.75 (-> s3-1 root-prim local-sphere w)))
       (let ((v1-14 (-> s3-1 root-prim)))
         (set! (-> s3-1 backup-collide-as) (-> v1-14 prim-core collide-as))
         (set! (-> s3-1 backup-collide-with) (-> v1-14 prim-core collide-with))
         )
       (set! (-> self root-override) s3-1)
       )
     )
    (arg3
      (let ((s3-2 (new 'process 'collide-shape self (collide-list-enum hit-by-player))))
        (let ((v1-18 (new 'process 'collide-shape-prim-sphere s3-2 (the-as uint 0))))
          (set! (-> v1-18 prim-core collide-as) (collide-spec collectable notice-blue-eco-powerup))
          (set! (-> v1-18 prim-core collide-with) (collide-spec jak player-list))
          (set-vector! (-> v1-18 local-sphere) (-> arg3 x) (-> arg3 y) (-> arg3 z) (-> arg3 w))
          (set! (-> s3-2 total-prims) (the-as uint 1))
          (set! (-> s3-2 root-prim) v1-18)
          )
        (set! (-> s3-2 nav-radius) (* 0.75 (-> s3-2 root-prim local-sphere w)))
        (let ((v1-21 (-> s3-2 root-prim)))
          (set! (-> s3-2 backup-collide-as) (-> v1-21 prim-core collide-as))
          (set! (-> s3-2 backup-collide-with) (-> v1-21 prim-core collide-with))
          )
        (set! (-> self root-override) s3-2)
        )
      )
    (else
      (set! (-> self root-override) (the-as collide-shape (new 'process 'trsqv)))
      )
    )
  (set! (-> self root-override trans quad) (-> arg0 quad))
  (initialize-skeleton self arg2 (the-as pair 0))
  (if (type? (-> self root-override) collide-shape)
      (update-transforms (the-as collide-shape (-> self root-override)))
      )
  (set! (-> self shadow-backup) (-> self draw shadow))
  (set! (-> self shadow-volume-joint) -1)
  (set! (-> self options) (the-as manipy-options arg4))
  (when (-> self draw shadow)
    (set! (-> self draw shadow-ctrl)
          (new 'process 'shadow-control 0.0 0.0 614400.0 (shadow-flags shdf02 shdf03 shdf04 disable-draw) 245760.0)
          )
    (quad-copy! (the-as pointer (-> self draw shadow-ctrl settings)) (the-as pointer *default-shadow-settings*) 5)
    )
  (set! (-> self new-trans-hook) nothing)
  (set! (-> self cur-trans-hook) nothing)
  (set! (-> self new-post-hook) nothing)
  (set! (-> self cur-post-hook) nothing)
  (set! (-> self cur-event-hook) #f)
  (set! (-> self cur-grab-handle) (the-as handle #f))
  (set! (-> self cur-target-handle) (the-as handle #f))
  (set! (-> self clone-copy-trans) #t)
  (set! (-> self draw?) #t)
  (set! (-> self prefix) "")
  (set! (-> self speed) 1.0)
  (when (logtest? (-> self options) (manipy-options mo-0))
    (let ((v1-56 (get-art-by-name-method (-> self draw jgeo) "neckA" (the-as type #f))))
      (when v1-56
        (set! (-> self joint 0)
              (new 'process 'joint-mod (joint-mod-mode flex-blend) self (+ (-> (the-as joint v1-56) number) 1))
              )
        (set! (-> self joint 0 parented-scale?) #t)
        )
      )
    )
  (cond
    ((nonzero? (-> self skel))
     (set! (-> self new-joint-anim) (ja-group))
     (set! (-> self anim-mode) 'loop)
     )
    (else
      (set! (-> self anim-mode) 'still)
      )
    )
  (set! (-> self event-hook) (-> (method-of-object self idle) event))
  (go-virtual idle)
  (none)
  )

(defmethod deactivate part-tracker ((obj part-tracker))
  (if (nonzero? (-> obj part))
      (kill-and-free-particles (-> obj part))
      )
  ((method-of-type process deactivate) obj)
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod notify-parent-of-death part-tracker ((obj part-tracker))
  (with-pp
    (let ((gp-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> gp-0 from) (process->ppointer pp))
      (set! (-> gp-0 num-params) 1)
      (set! (-> gp-0 message) 'notify)
      (set! (-> gp-0 param 0) (the-as uint 'die))
      (let ((s5-0 send-event-function)
            (s4-0 (ppointer->process (-> obj parent)))
            )
        (s5-0
          (if (type? s4-0 process)
              s4-0
              )
          gp-0
          )
        )
      )
    (none)
    )
  )

(defstate active (part-tracker)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('die)
                      (the-as symbol (deactivate self))
                      )
                     )
            )
    )
  :code (behavior ()
    (set! (-> self start-time) (current-time))
    (while (or (zero? (-> self duration))
               (< (- (current-time) (-> self start-time)) (the-as time-frame (-> self duration)))
               )
      (if (-> self callback)
          ((-> self callback) self)
          )
      (let* ((gp-0 (handle->process (-> self target)))
             (v1-8 (if (type? gp-0 process-drawable)
                       gp-0
                       )
                   )
             )
        (cond
          ((and v1-8
                (nonzero? (-> (the-as process-drawable v1-8) root))
                (nonzero? (-> (the-as process-drawable v1-8) node-list))
                )
           (spawn-with-cspace (-> self part) (-> (the-as process-drawable v1-8) node-list data (-> self target-joint)))
           (set! (-> self root trans quad) (-> self part origin trans quad))
           )
          (else
            (let ((a0-12 (-> self root trans)))
              (set! (-> self mat trans quad) (-> a0-12 quad))
              )
            (spawn-with-matrix (-> self part) (-> self mat))
            )
          )
        )
      (suspend)
      )
    (let ((gp-1 (current-time)))
      (until (>= (- (current-time) gp-1) (the-as time-frame (-> self linger-duration)))
        (if (-> self linger-callback)
            ((-> self linger-callback) self)
            )
        (let* ((s5-0 (handle->process (-> self target)))
               (v1-30 (if (type? s5-0 process-drawable)
                          s5-0
                          )
                      )
               )
          (if (and v1-30
                   (nonzero? (-> (the-as process-drawable v1-30) root))
                   (nonzero? (-> (the-as process-drawable v1-30) node-list))
                   )
              (vector<-cspace!
                (-> self root trans)
                (-> (the-as process-drawable v1-30) node-list data (-> self target-joint))
                )
              )
          )
        (suspend)
        )
      )
    (if (-> self linger-callback)
        ((-> self linger-callback) self)
        )
    (notify-parent-of-death self)
    (suspend)
    0
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior part-tracker-init part-tracker ((arg0 sparticle-launch-group)
                                   (arg1 time-frame)
                                   (arg2 (function part-tracker none))
                                   (arg3 (pointer process-drawable))
                                   (arg4 process)
                                   (arg5 matrix)
                                   )
  (stack-size-set! (-> self main-thread) 128)
  (if (= pointer process-tree)
      (set! (-> self clock) (-> *display* part-clock))
      )
  (set! (-> self target) (process->handle arg4))
  (cond
    (arg4
      (set! (-> self target-joint) (the-as int arg5))
      )
    ((logtest? (-> arg0 flags) (sp-group-flag unk-5))
     (let* ((s1-1 (-> self mat))
            (a2-1 (math-camera-matrix))
            (v1-11 (-> a2-1 quad 0))
            (a0-7 (-> a2-1 quad 1))
            (a1-2 (-> a2-1 quad 2))
            (a2-2 (-> a2-1 trans quad))
            )
       (set! (-> s1-1 quad 0) v1-11)
       (set! (-> s1-1 quad 1) a0-7)
       (set! (-> s1-1 quad 2) a1-2)
       (set! (-> s1-1 trans quad) a2-2)
       )
     (set! (-> self mat trans quad) (-> arg5 trans quad))
     (set! (-> self offset quad) (-> self mat trans quad))
     )
    (else
      (let* ((v1-14 (-> self mat))
             (a3-1 arg5)
             (a0-12 (-> a3-1 quad 0))
             (a1-3 (-> a3-1 quad 1))
             (a2-3 (-> a3-1 quad 2))
             (a3-2 (-> a3-1 trans quad))
             )
        (set! (-> v1-14 quad 0) a0-12)
        (set! (-> v1-14 quad 1) a1-3)
        (set! (-> v1-14 quad 2) a2-3)
        (set! (-> v1-14 trans quad) a3-2)
        )
      (set! (-> self offset quad) (-> self mat trans quad))
      )
    )
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> self mat trans quad))
  (if (zero? arg0)
      (go process-drawable-art-error "null group")
      )
  (set! (-> self callback) (the-as (function part-tracker vector) arg2))
  (set! (-> self linger-callback) #f)
  (set! (-> self userdata) (the-as uint arg3))
  (set! arg1 (cond
               ((> arg1 0)
                (empty)
                arg1
                )
               ((= arg1 -1)
                0
                )
               (else
                 (the-as time-frame (-> arg0 duration))
                 )
               )
        )
  (set! (-> self duration) (the-as uint arg1))
  (set! (-> self linger-duration) (-> arg0 linger-duration))
  (set! (-> self part) (create-launch-control arg0 self))
  (go-virtual active)
  (none)
  )

(defun part-tracker-track-root ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 vector))
  (let ((v1-3 (-> arg1 key proc root trans)))
    (set! (-> arg2 x) (-> v1-3 x))
    (set! (-> arg2 y) (-> v1-3 y))
    (set! (-> arg2 z) (-> v1-3 z))
    )
  0
  (none)
  )

(defun part-tracker-move-to-target ((arg0 part-tracker))
  (let* ((a0-1 *target*)
         (a2-0 (if (not a0-1)
                   (-> arg0 root trans)
                   (get-trans a0-1 3)
                   )
               )
         )
    (vector-lerp!
      (-> arg0 root trans)
      (-> arg0 offset)
      a2-0
      (* 0.006666667 (the float (- (current-time) (-> arg0 start-time))))
      )
    )
  )

(defun part-tracker-track-target ((arg0 part-tracker))
  (set! (-> arg0 linger-callback) (-> arg0 callback))
  (let* ((a0-1 *target*)
         (v1-2 (if (not a0-1)
                   (-> arg0 root trans)
                   (get-trans a0-1 3)
                   )
               )
         (v0-1 (-> arg0 root trans))
         )
    (set! (-> v0-1 quad) (-> v1-2 quad))
    v0-1
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod notify-parent-of-death lightning-tracker ((obj lightning-tracker))
  (with-pp
    (let ((gp-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> gp-0 from) (process->ppointer pp))
      (set! (-> gp-0 num-params) 1)
      (set! (-> gp-0 message) 'notify)
      (set! (-> gp-0 param 0) (the-as uint 'die))
      (let ((s5-0 send-event-function)
            (s4-0 (ppointer->process (-> obj parent)))
            )
        (s5-0
          (if (type? s4-0 process)
              s4-0
              )
          gp-0
          )
        )
      )
    (none)
    )
  )

(defmethod update lightning-tracker ((obj lightning-tracker))
  (if (-> obj callback)
      ((-> obj callback) obj)
      )
  (let ((a0-6 (cond
                ((>= (-> obj target-joint0) 0)
                 (let ((s5-0 (handle->process (-> obj target0))))
                   (if (type? s5-0 process-drawable)
                       s5-0
                       )
                   )
                 )
                (else
                  (the-as process #f)
                  )
                )
              )
        )
    (cond
      ((< (-> obj target-joint0) 0)
       (when (and (!= (-> obj lightning spec rand-func) 3) (!= (-> obj lightning spec rand-func) 2))
         (let ((v1-17 (-> obj lightning))
               (a0-9 (-> obj offset0))
               )
           (set! (-> v1-17 state meet data 0 quad) (-> a0-9 quad))
           )
         )
       )
      ((or (not a0-6) (zero? (-> (the-as process-focusable a0-6) root-override)))
       (deactivate obj)
       )
      ((= (-> obj target-joint0) 256)
       (let ((s5-1 (-> obj lightning))
             (a0-12 (get-trans (the-as process-focusable a0-6) 3))
             )
         (set! (-> s5-1 state meet data 0 quad) (-> a0-12 quad))
         )
       )
      (else
        (let ((s5-2 (-> obj lightning))
              (a0-16 (vector<-cspace!
                       (new 'stack-no-clear 'vector)
                       (-> (the-as process-focusable a0-6) node-list data (-> obj target-joint0))
                       )
                     )
              )
          (set! (-> s5-2 state meet data 0 quad) (-> a0-16 quad))
          )
        )
      )
    )
  (let ((a0-22 (cond
                 ((>= (-> obj target-joint1) 0)
                  (let ((s5-3 (handle->process (-> obj target1))))
                    (if (type? s5-3 process-drawable)
                        s5-3
                        )
                    )
                  )
                 (else
                   (the-as process #f)
                   )
                 )
               )
        )
    (cond
      ((< (-> obj target-joint1) 0)
       (when (and (!= (-> obj lightning spec rand-func) 3) (!= (-> obj lightning spec rand-func) 2))
         (let ((a0-26 (-> obj lightning))
               (v1-44 (-> obj offset1))
               )
           (set! (-> a0-26 state meet data (+ (-> a0-26 state points-to-draw) -1) quad) (-> v1-44 quad))
           )
         )
       )
      ((or (not a0-22) (zero? (-> (the-as process-focusable a0-22) root-override)))
       (deactivate obj)
       )
      ((= (-> obj target-joint1) 256)
       (let ((gp-1 (-> obj lightning))
             (v1-51 (get-trans (the-as process-focusable a0-22) 3))
             )
         (set! (-> gp-1 state meet data (+ (-> gp-1 state points-to-draw) -1) quad) (-> v1-51 quad))
         )
       )
      (else
        (let ((s5-4 (-> obj lightning))
              (v1-54 (vector<-cspace!
                       (new 'stack-no-clear 'vector)
                       (-> (the-as process-drawable a0-22) node-list data (-> obj target-joint1))
                       )
                     )
              )
          (set! (-> s5-4 state meet data (+ (-> s5-4 state points-to-draw) -1) quad) (-> v1-54 quad))
          )
        )
      )
    )
  0
  (none)
  )

(defstate active (lightning-tracker)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('die)
                      (the-as symbol (deactivate self))
                      )
                     )
            )
    )
  :exit (behavior ()
    (when (nonzero? (-> self sound))
      (let ((v1-1 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> v1-1 command) (sound-command set-param))
        (set! (-> v1-1 id) (-> self sound))
        (set! (-> v1-1 params volume) -4)
        (set! (-> v1-1 auto-time) 240)
        (set! (-> v1-1 auto-from) 2)
        (set! (-> v1-1 params mask) (the-as uint 17))
        (-> v1-1 id)
        )
      )
    (none)
    )
  :code (behavior ()
    (set! (-> self sound) (new 'static 'sound-id))
    (when (!= (+ (-> self lightning spec delay) (-> self lightning spec delay-rand)) 0.0)
      (let ((gp-0 (current-time))
            (s5-0 (the int (rand-vu-float-range
                             (-> self lightning spec delay)
                             (+ (-> self lightning spec delay) (-> self lightning spec delay-rand))
                             )
                       )
                  )
            )
        (while (< (- (current-time) gp-0) s5-0)
          (suspend)
          )
        )
      )
    (let ((gp-1 (-> self lightning spec sound)))
      (when gp-1
        (let ((s5-1 (new 'stack-no-clear 'vector)))
          (set! (-> s5-1 quad) (-> self offset1 quad))
          (when (and (>= (-> self target-joint1) 0) (< (-> self target-joint1) 256))
            (let* ((s4-0 (handle->process (-> self target1)))
                   (v1-28 (if (type? s4-0 process-drawable)
                              s4-0
                              )
                          )
                   )
              (if (and v1-28 (nonzero? (-> (the-as process-drawable v1-28) root)))
                  (set! (-> s5-1 quad) (-> (vector<-cspace!
                                             (new 'stack-no-clear 'vector)
                                             (-> (the-as process-drawable v1-28) node-list data (-> self target-joint1))
                                             )
                                           quad
                                           )
                        )
                  )
              )
            )
          (set! (-> self sound) (sound-play-by-spec (the-as sound-spec gp-1) (new-sound-id) s5-1))
          )
        )
      )
    (let ((v1-33 (-> self lightning))
          (a0-10 1)
          )
      (let ((a1-10 (!= a0-10 (-> v1-33 state mode))))
        (case a0-10
          ((3)
           (if a1-10
               (set! (-> v1-33 state counter) 0.0)
               )
           )
          ((1)
           (set! (-> v1-33 state start-color) (-> v1-33 spec start-color))
           (set! (-> v1-33 state end-color) (-> v1-33 spec end-color))
           )
          )
        )
      (set! (-> v1-33 state mode) (the-as lightning-mode a0-10))
      )
    (set! (-> self start-time) (current-time))
    (while (or (zero? (-> self duration))
               (< (- (current-time) (-> self start-time)) (the-as time-frame (-> self duration)))
               )
      (update self)
      (suspend)
      )
    (let ((f30-0 (-> self lightning spec fade-time)))
      (when (< 0.0 f30-0)
        (let ((v1-47 (-> self lightning))
              (a0-14 3)
              )
          (let ((a1-20 (!= a0-14 (-> v1-47 state mode))))
            (case a0-14
              ((3)
               (if a1-20
                   (set! (-> v1-47 state counter) 0.0)
                   )
               )
              ((1)
               (set! (-> v1-47 state start-color) (-> v1-47 spec start-color))
               (set! (-> v1-47 state end-color) (-> v1-47 spec end-color))
               )
              )
            )
          (set! (-> v1-47 state mode) (the-as lightning-mode a0-14))
          )
        (set! (-> self start-time) (current-time))
        (while (< (- (current-time) (-> self start-time)) (the int f30-0))
          (suspend)
          )
        )
      )
    (let ((v1-54 (-> self lightning))
          (a0-17 0)
          )
      (let ((a1-30 (!= a0-17 (-> v1-54 state mode))))
        (case a0-17
          ((3)
           (if a1-30
               (set! (-> v1-54 state counter) 0.0)
               )
           )
          ((1)
           (set! (-> v1-54 state start-color) (-> v1-54 spec start-color))
           (set! (-> v1-54 state end-color) (-> v1-54 spec end-color))
           )
          )
        )
      (set! (-> v1-54 state mode) (the-as lightning-mode a0-17))
      )
    (notify-parent-of-death self)
    (suspend)
    0
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior lightning-tracker-init lightning-tracker ((arg0 lightning-spec) (arg1 time-frame) (arg2 symbol) (arg3 process-drawable) (arg4 vector) (arg5 vector))
  (stack-size-set! (-> self main-thread) 128)
  (set! (-> self target0) (process->handle arg3))
  (let ((s1-1 (ppointer->process (-> self parent))))
    (set! (-> self target1) (process->handle (the-as process (if (type? s1-1 process-drawable)
                                                                 s1-1
                                                                 )
                                                     )
                                             )
          )
    )
  ;; Note: there's some changes here to skip setting things if arg4 is #f.
  ;; the address of #f is misaligned, but on ps2 the lq instruction will silently mask.
  ;; Loading from #f doesn't really make sense, so this was likely just a mistake in the
  ;; original game.
  ;; the OpenGOAL compiler uses vmovaps, which will crash on a misaligned load because
  ;; this has been useful for finding errors. So to prevent this crash, we skip the load
  ;; if the argument is #f. (some callers of this directly pass #f, so it's not a bug higher up).
  (cond
    ((>= 256 (the-as int arg4))
     (set! (-> self target-joint0) (the-as int arg4))
     (vector-identity! (-> self offset0))
     )
    (else
      (set! (-> self target-joint0) -1)
      ;; hack, fixed bug in original game
      (when arg4
        (set! (-> self offset0 quad) (-> arg4 quad))
        )
      )
    )
  (cond
    ((>= 256 (the-as int arg5))
     (set! (-> self target-joint1) (the-as int arg5))
     (vector-identity! (-> self offset1))
     )
    (else
      (set! (-> self target-joint1) -1)
      ;; hack, fixed bug in original game
      (when arg5
        (set! (-> self offset1 quad) (-> arg5 quad))
        )
      )
    )
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self callback) (the-as (function lightning-tracker none) arg2))
  (set! arg1
        (cond
          ((> arg1 0)
           (empty)
           arg1
           )
          ((= arg1 -1)
           0
           )
          (else
            (the-as
              time-frame
              (the int (rand-vu-float-range (-> arg0 duration) (+ (-> arg0 duration) (-> arg0 duration-rand))))
              )
            )
          )
        )
  (set! (-> self duration) (the-as uint arg1))
  (set! (-> self lightning) (new 'process 'lightning-control arg0 self 0.0))
  (let ((v1-21 (-> self lightning))
        (a0-17 0)
        )
    (let ((a1-7 (!= a0-17 (-> v1-21 state mode))))
      (case a0-17
        ((3)
         (if a1-7
             (set! (-> v1-21 state counter) 0.0)
             )
         )
        ((1)
         (set! (-> v1-21 state start-color) (-> v1-21 spec start-color))
         (set! (-> v1-21 state end-color) (-> v1-21 spec end-color))
         )
        )
      )
    (set! (-> v1-21 state mode) (the-as lightning-mode a0-17))
    )
  (go-virtual active)
  (none)
  )

;; WARN: Return type mismatch object vs symbol.
(defbehavior process-grab? process ((arg0 process) (arg1 symbol))
  (let ((a0-1 (command-get-process arg0 *target*)))
    (the-as symbol (if a0-1
                       (send-event a0-1 'change-mode 'grab (cond
                                                             ((= arg1 #t)
                                                              #f
                                                              )
                                                             ((= arg1 'dead)
                                                              'dead
                                                              )
                                                             (else
                                                               #t
                                                               )
                                                             )
                                   )
                       )
            )
    )
  )

;; WARN: Return type mismatch object vs symbol.
(defbehavior process-release? process ((arg0 process))
  (let* ((gp-0 (command-get-process arg0 *target*))
         (a0-2 (if (type? gp-0 process-focusable)
                   (the-as process-focusable gp-0)
                   )
               )
         )
    (the-as symbol (if (and a0-2 (focus-test? a0-2 grabbed))
                       (send-event a0-2 'end-mode)
                       #t
                       )
            )
    )
  )

(defun camera-look-at ((arg0 pair) (arg1 uint))
  (let ((gp-0 (command-get-process arg0 *target*)))
    (if gp-0
        (send-event *camera* 'change-target gp-0 arg1)
        )
    gp-0
    )
  )

;; WARN: Return type mismatch object vs symbol.
(defun ja-anim-done? ((arg0 process))
  (with-pp
    (let ((gp-0 (command-get-process arg0 *target*)))
      (the-as
        symbol
        (when gp-0
          (cond
            ((type? gp-0 manipy)
             (send-event gp-0 'query 'done)
             )
            ((type? gp-0 process-drawable)
             (when (not (logtest? (-> (the-as process-drawable gp-0) skel status) (joint-control-status spooling-not-last-block))
                        )
               (let ((s5-0 pp))
                 (set! pp gp-0)
                 (let ((v0-1 (the-as object (ja-done? 0))))
                   (set! pp s5-0)
                   v0-1
                   )
                 )
               )
             )
            )
          )
        )
      )
    )
  )

;; WARN: Return type mismatch target vs process.
(defun camera-pov-from ((arg0 pair) (arg1 uint))
  (let ((gp-0 (the-as target (command-get-process arg0 *target*))))
    (when gp-0
      (when (= arg1 -10)
        (set! arg1 (the-as uint 0))
        (when (> (-> gp-0 skel active-channels) 0)
          (let ((v1-7 (get-art-by-name-method (-> gp-0 draw jgeo) "camera" (the-as type #f))))
            (if v1-7
                (set! arg1 (the-as uint (+ (-> (the-as joint v1-7) number) 1)))
                )
            )
          )
        )
      (let ((v1-9 (process->ppointer gp-0)))
        (set-setting! 'pov-handle (the-as joint v1-9) (the float arg1) (-> (the-as (pointer process) v1-9) 0 pid))
        )
      )
    (the-as process gp-0)
    )
  )

(deftype med-res-level (process-drawable)
  ((level-name basic  :offset-assert 200)
   (part-mode  basic  :offset-assert 204)
   (index      int32  :offset-assert 208)
   )
  :heap-base #x60
  :method-count-assert 21
  :size-assert         #xd4
  :flag-assert         #x15006000d4
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defstate idle (med-res-level)
  :virtual #t
  :code (behavior ()
    (until #f
      (let ((v1-1 (level-get *level* (the-as symbol (-> self level-name)))))
        (cond
          ((and v1-1 (= (-> v1-1 display?) 'special))
           (logclear! (-> self draw status) (draw-control-status no-draw))
           (if (nonzero? (-> self skel))
               (ja :num! (loop!))
               )
           )
          ((and v1-1 (= (-> v1-1 status) 'active))
           (logior! (-> self draw status) (draw-control-status no-draw))
           )
          (else
            (logclear! (-> self draw status) (draw-control-status no-draw))
            (if (nonzero? (-> self skel))
                (ja :num! (loop!))
                )
            )
          )
        )
      (suspend)
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior med-res-level) ja-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! med-res-level ((obj med-res-level) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (stack-size-set! (-> obj main-thread) 128)
  (let ((s4-0 (res-lump-struct arg0 'art-name structure))
        (s3-0 (res-lump-struct (-> obj entity) 'level structure))
        (v1-5 (res-lump-value (-> obj entity) 'index uint128 :time -1000000000.0))
        )
    (when s3-0
      (set! (-> obj level-name) (the-as basic s3-0))
      (set! (-> obj index) (the-as int v1-5))
      (set! (-> obj root) (new 'process 'trsqv))
      (process-drawable-from-entity! obj arg0)
      (logclear! (-> obj mask) (process-mask actor-pause))
      (initialize-skeleton-by-name obj (the-as string s4-0))
      (logior! (-> obj draw status) (draw-control-status no-closest-distance))
      (if (nonzero? (-> obj draw))
          (go (method-of-object obj idle))
          )
      )
    )
  (none)
  )

(defmethod deactivate part-spawner ((obj part-spawner))
  (if (nonzero? (-> obj part))
      (kill-and-free-particles (-> obj part))
      )
  (if (nonzero? (-> obj sound))
      (stop! (-> obj sound))
      )
  ((method-of-type process deactivate) obj)
  (none)
  )

(defmethod is-in-view? part-spawner ((obj part-spawner))
  (sphere<-vector+r! (-> obj world-sphere) (-> obj root trans) (-> obj radius))
  (sphere-in-view-frustum? (-> obj world-sphere))
  )

(defstate active (part-spawner)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('stop)
       (process-entity-status! self (entity-perm-status subtask-complete) #t)
       (set! (-> self enable) #f)
       #t
       )
      (('start)
       (process-entity-status! self (entity-perm-status subtask-complete) #f)
       (set! (-> self enable) #t)
       #t
       )
      (('trans)
       (let ((v0-1 (the-as object (-> (the-as vector (-> event param 0)) quad))))
         (set! (-> self root trans quad) (the-as uint128 v0-1))
         v0-1
         )
       )
      )
    )
  :code (behavior ()
    (until #f
      (when (-> self enable)
        (spawn (-> self part) (-> self root trans))
        (if (nonzero? (-> self sound))
            (update! (-> self sound))
            )
        )
      (suspend)
      )
    #f
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! part-spawner ((obj part-spawner) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (sv-16 string))
  (stack-size-set! (-> obj main-thread) 128)
  (set! (-> obj mask) (logior (process-mask ambient) (-> obj mask)))
  (set! (-> obj clock) (-> *display* part-clock))
  (set! (-> obj root) (new 'process 'trsqv))
  (set! (-> obj root trans quad) (-> arg0 extra trans quad))
  (quaternion-copy! (-> obj root quat) (-> arg0 quat))
  (vector-identity! (-> obj root scale))
  (set! (-> obj radius) 12288.0)
  (set! (-> obj enable)
        (not (and (-> obj entity) (logtest? (-> obj entity extra perm status) (entity-perm-status subtask-complete))))
        )
  (set! (-> obj sound) (new 'process 'ambient-sound (-> obj entity) (-> obj root trans)))
  (set! sv-16 "#f")
  (set! (-> obj mode) (entity-lookup-part-group arg0 (& sv-16) 'art-name))
  (when (-> obj mode)
    (let ((a0-15 (-> obj mode 0)))
      (when (and (nonzero? a0-15) (= (-> a0-15 type) sparticle-launch-group))
        (cond
          ((logtest? (-> a0-15 flags) (sp-group-flag unk-8))
           (countdown (v1-27 (-> a0-15 length))
             (let* ((a1-8 (-> a0-15 launcher v1-27))
                    (a3-2 (-> *part-id-table* (-> a1-8 launcher)))
                    )
               (when (nonzero? a3-2)
                 (let ((a2-7 (-> obj level part-engine)))
                   (when (and a2-7 (< (-> a2-7 length) (-> a2-7 allocated-length)))
                     (let ((t0-7 (-> a2-7 data (-> a2-7 length))))
                       (set! (-> t0-7 next1) (the-as connectable a3-2))
                       (set! (-> t0-7 prev1) (the-as connectable (-> a1-8 hour-mask)))
                       (set! (-> (the-as vector (&-> t0-7 param0)) quad) (-> obj root trans quad))
                       (set! (-> t0-7 param3) (the-as int (-> a1-8 fade-after)))
                       )
                     (+! (-> a2-7 length) 1)
                     )
                   )
                 )
               )
             )
           (process-entity-status! obj (entity-perm-status dead) #t)
           (deactivate obj)
           )
          (else
            (set! (-> obj part) (create-launch-control a0-15 obj))
            (go (method-of-object obj active))
            )
          )
        )
      )
    )
  (go process-drawable-art-error sv-16)
  (none)
  )

(deftype launcher (process-drawable)
  ((root-override   collide-shape         :offset        128)
   (spring-height   meters                :offset-assert 200)
   (camera          state                 :offset-assert 204)
   (active-distance float                 :offset-assert 208)
   (seek-time       time-frame            :offset-assert 216)
   (dest            vector        :inline :offset-assert 224)
   (sound-id        sound-id              :offset-assert 240)
   )
  :heap-base #x80
  :method-count-assert 23
  :size-assert         #xf4
  :flag-assert         #x17008000f4
  (:methods
    (idle () _type_ :state 20)
    (active () _type_ :state 21)
    (deactivated () _type_ :state 22)
    )
  )


(defpartgroup group-beach-launcher
  :id 6
  :bounds (static-bspherem 0 3 0 5)
  :parts ((sp-item 77 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 78 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 79 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 80 :fade-after (meters 50) :falloff-to (meters 80))
    (sp-item 81 :fade-after (meters 70) :falloff-to (meters 100))
    )
  )

(defpart 77
  :init-specs ((:num 1.5)
    (:x (meters 1.5))
    (:y (meters -0.5))
    (:rot-x 5)
    (:r 4096.0)
    (:g 2867.2)
    (:b 3276.8)
    (:vel-y (meters 0.026666667))
    (:timer (seconds 0.9))
    (:flags (distort))
    (:next-time (seconds 0.6))
    (:next-launcher 82)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 82
  :init-specs ((:fade-b -4.551111))
  )

(defpart 78
  :init-specs ((:texture (new 'static 'texture-id :index #xc9 :page #xc))
    (:num 1.0)
    (:x (meters 0) (meters 1.8))
    (:scale-x (meters 0.2))
    (:rot-x (degrees 90))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 2.5) (meters 2.5))
    (:r 0.0 1 128.0)
    (:g 64.0 196.0)
    (:b 128.0 128.0)
    (:a 128.0)
    (:scalevel-x (meters -0.0025))
    (:scalevel-y (meters 0.24414062) (meters 0.48828125))
    (:timer (seconds 0.27))
    (:flags (sp-cpuinfo-flag-3))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 79
  :init-specs ((:texture (new 'static 'texture-id :index #xc9 :page #xc))
    (:num 2.0)
    (:x (meters 1.8) (meters 1))
    (:scale-x (meters 0.2))
    (:rot-x (degrees 90))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.5) (meters 1))
    (:r 0.0 1 128.0)
    (:g 64.0 196.0)
    (:b 128.0 128.0)
    (:a 128.0)
    (:scalevel-x (meters -0.0025))
    (:scalevel-y (meters 0.048828125) (meters 0.09765625))
    (:timer (seconds 0.27))
    (:flags (sp-cpuinfo-flag-3))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 80
  :init-specs ((:texture (new 'static 'texture-id :index #x2f :page #xc))
    (:num 1.5)
    (:x (meters 2.9) (meters 2.5))
    (:y (meters -0.5))
    (:scale-x (meters 0.3) (meters 0.4))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.1) (meters 0.1))
    (:r 10.0 6.0)
    (:g 64.0 128.0)
    (:b 10.0 6.0)
    (:a 80.0)
    (:vel-x (meters -0.011666667) (meters -0.0033333334))
    (:vel-y (meters 0))
    (:rotvel-z (degrees -1.2) 1 (degrees 2.4))
    (:fade-a -0.2)
    (:accel-y (meters 0.0016666667))
    (:friction 0.996)
    (:timer (seconds 0.6) (seconds 0.397))
    (:flags (sp-cpuinfo-flag-2))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 81
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 0.5)
    (:x (meters 2.9) (meters 2.5))
    (:y (meters -0.5))
    (:scale-x (meters 2) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 32.0 32.0)
    (:g 32.0 32.0)
    (:b 10.0 5.0)
    (:a 0.0)
    (:vel-x (meters -0.011666667) (meters -0.0033333334))
    (:vel-y (meters 0))
    (:rotvel-z (degrees -1.2) 1 (degrees 2.4))
    (:fade-a 0.6)
    (:accel-y (meters 0.0016666667))
    (:friction 0.996)
    (:timer (seconds 0.9))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:next-time (seconds 0.15))
    (:next-launcher 83)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 83
  :init-specs ((:fade-a -0.18))
  )

(defpartgroup group-jungle-launcher
  :id 7
  :bounds (static-bspherem 0 3 0 5)
  :parts ((sp-item 77 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 84 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 85 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 86 :fade-after (meters 70) :falloff-to (meters 100))
    )
  )

(defpart 84
  :init-specs ((:texture (new 'static 'texture-id :index #xc9 :page #xc))
    (:num 1.0)
    (:x (meters 0) (meters 1.4))
    (:scale-x (meters 0.2))
    (:rot-x (degrees 90))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 2.5) (meters 2.5))
    (:r 0.0 1 128.0)
    (:g 64.0 196.0)
    (:b 128.0 128.0)
    (:a 128.0)
    (:scalevel-x (meters -0.0025))
    (:scalevel-y (meters 0.24414062) (meters 0.48828125))
    (:timer (seconds 0.27))
    (:flags (sp-cpuinfo-flag-3))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 85
  :init-specs ((:texture (new 'static 'texture-id :index #xc9 :page #xc))
    (:num 2.0)
    (:x (meters 1.4) (meters 0.9))
    (:scale-x (meters 0.2))
    (:rot-x (degrees 90))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.5) (meters 1))
    (:r 0.0 1 128.0)
    (:g 64.0 196.0)
    (:b 128.0 128.0)
    (:a 128.0)
    (:scalevel-x (meters -0.0025))
    (:scalevel-y (meters 0.048828125) (meters 0.09765625))
    (:timer (seconds 0.27))
    (:flags (sp-cpuinfo-flag-3))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 86
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 0.5)
    (:x (meters 2.9) (meters 2.5))
    (:y (meters -0.5))
    (:scale-x (meters 2) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 64.0 32.0)
    (:g 32.0 32.0)
    (:b 10.0 5.0)
    (:a 0.0)
    (:vel-x (meters -0.011666667) (meters -0.0033333334))
    (:vel-y (meters 0))
    (:rotvel-z (degrees -1.2) 1 (degrees 2.4))
    (:fade-a 0.6)
    (:accel-y (meters 0.0016666667))
    (:friction 0.996)
    (:timer (seconds 0.9))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:next-time (seconds 0.15))
    (:next-launcher 83)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpartgroup group-swamp-launcher
  :id 8
  :bounds (static-bspherem 0 3 0 5)
  :parts ((sp-item 77 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 78 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 79 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 87 :fade-after (meters 70) :falloff-to (meters 100))
    )
  )

(defpart 87
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 0.5)
    (:x (meters 2.9) (meters 2.5))
    (:y (meters -0.5))
    (:scale-x (meters 2) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 16.0 16.0)
    (:g 16.0 16.0)
    (:b 5.0 2.5)
    (:a 0.0)
    (:vel-x (meters -0.011666667) (meters -0.0033333334))
    (:vel-y (meters 0))
    (:rotvel-z (degrees -1.2) 1 (degrees 2.4))
    (:fade-a 0.6)
    (:accel-y (meters 0.0016666667))
    (:friction 0.996)
    (:timer (seconds 0.9))
    (:flags (sp-cpuinfo-flag-2))
    (:next-time (seconds 0.15))
    (:next-launcher 83)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defbehavior cam-launcher-joystick camera-slave ()
  (when (not (logtest? (-> *camera* settings master-options) (cam-master-options IGNORE_ANALOG)))
    (let ((s5-0 (new-stack-matrix0))
          (gp-0 (vector-reset! (new 'stack-no-clear 'vector)))
          )
      (let* ((f0-0 (analog-input (the-as int (+ (-> *cpad-list* cpads 0 rightx) -128)) 0.0 48.0 110.0 -1.0))
             (f0-1 (* -546.13336 f0-0))
             (f0-3 (fmin 546.13336 (fmax -546.13336 f0-1)))
             )
        (matrix-axis-angle! s5-0 (-> *camera* local-down) f0-3)
        )
      (vector-! gp-0 (-> self trans) (-> *camera* tpos-curr))
      (vector-matrix*! gp-0 gp-0 s5-0)
      (vector+! (-> self trans) gp-0 (-> *camera* tpos-curr))
      )
    )
  )

(defstate cam-launcher-shortfall (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v1-0 event-type))
      (the-as object (if (= v1-0 'teleport)
                         #f
                         (the-as symbol (cam-standard-event-handler proc arg1 event-type event))
                         )
              )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (let ((gp-0 (new 'stack-no-clear 'vector)))
        (vector--float*! (-> self trans) (-> *camera* tpos-curr) (-> *camera* local-down) 28672.0)
        (vector-flatten! gp-0 (-> self tracking inv-mat vector 2) (-> *camera* local-down))
        (vector-normalize! gp-0 1.0)
        (set! (-> self pivot-pt quad) (-> gp-0 quad))
        (vector+float*! gp-0 gp-0 (-> *camera* local-down) 1000.0)
        (vector-normalize-copy! (-> self tracking inv-mat vector 2) gp-0 1.0)
        )
      (vector-cross!
        (-> self tracking inv-mat vector 1)
        (-> self tracking inv-mat vector 2)
        (the-as vector (-> self tracking))
        )
      (set! (-> self blend-from-type) (the-as uint 0))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-0))
      0
      )
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) (cam-master-options-u32 HAVE_TARGET)))
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (current-time)))
      (until #f
        (when (not (paused?))
          (vector--float*! (-> self trans) (-> *camera* tpos-curr) (-> *camera* local-down) 28672.0)
          (send-event *camera* 'teleport)
          (if (and (-> *camera* on-ground) (>= (- (current-time) gp-0) (seconds 1)))
              (send-event *camera* 'change-state cam-string (seconds 0.5))
              )
          )
        (suspend)
        )
      )
    #f
    (none)
    )
  )

(defbehavior cam-launcher-long-joystick camera-slave ()
  (when (not (logtest? (-> *camera* settings master-options) (cam-master-options IGNORE_ANALOG)))
    (let ((gp-0 (new-stack-matrix0)))
      (let* ((f0-0 (analog-input (the-as int (+ (-> *cpad-list* cpads 0 rightx) -128)) 0.0 48.0 110.0 -1.0))
             (f0-1 (* -546.13336 f0-0))
             (f0-3 (fmin 546.13336 (fmax -546.13336 f0-1)))
             )
        (matrix-axis-angle! gp-0 (-> *camera* local-down) f0-3)
        )
      (vector-matrix*! (-> self view-flat) (-> self view-flat) gp-0)
      )
    (vector-normalize! (-> self view-flat) 4096.0)
    )
  )

(defstate cam-launcher-longfall (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v1-0 event-type))
      (the-as object (if (= v1-0 'teleport)
                         #f
                         (the-as symbol (cam-standard-event-handler proc arg1 event-type event))
                         )
              )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (new 'stack-no-clear 'vector)
      (vector-negate! (-> self view-flat) (-> self tracking inv-mat vector 2))
      (vector-normalize! (-> self view-flat) 4096.0)
      (vector--float*! (-> self trans) (-> *camera* tpos-curr) (-> *camera* local-down) 28672.0)
      (vector+! (-> self trans) (-> self trans) (-> self view-flat))
      (set! (-> self blend-from-type) (the-as uint 0))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-0))
      (cam-calc-follow! (-> self tracking) (-> self trans) #f)
      (slave-set-rotation! (-> self tracking) (-> self trans) (-> self options) (-> self fov) #f)
      )
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) (cam-master-options-u32 HAVE_TARGET)))
        (cam-slave-go cam-free-floating)
        )
    (cam-launcher-long-joystick)
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (current-time)))
      (until #f
        (when (not (paused?))
          (let ((s4-0 (new 'stack-no-clear 'vector))
                (s5-0 (new 'stack-no-clear 'vector))
                )
            0.0
            0.0
            0.0
            (send-event *camera* 'teleport)
            (let* ((f0-4 (vector-dot (-> self velocity) (-> *camera* local-down)))
                   (f30-0 (* 0.975 f0-4))
                   )
              (vector--float*! s4-0 (-> *camera* tpos-curr) (-> *camera* local-down) 28672.0)
              (vector-! s4-0 s4-0 (-> self trans))
              (let ((f28-0 (vector-dot s4-0 (-> *camera* local-down))))
                (vector--float*! s5-0 s4-0 (-> *camera* local-down) f28-0)
                (cond
                  ((< f28-0 f30-0)
                   (set! f30-0 f28-0)
                   )
                  ((< 20480.0 f28-0)
                   (let ((f28-1 (+ -20480.0 f28-0)))
                     (let ((f0-8 (lerp f30-0 f28-1 0.005)))
                       (if (< f30-0 f0-8)
                           (set! f30-0 f0-8)
                           )
                       )
                     (if (< (* 0.09 f28-1) f30-0)
                         (set! f30-0 (* 0.09 f28-1))
                         )
                     )
                   )
                  )
                )
              (vector+float*! (-> self velocity) s5-0 (-> *camera* local-down) f30-0)
              )
            )
          (vector+! (-> self trans) (-> self trans) (-> self velocity))
          (set! (-> self trans x) (-> *camera* tpos-curr x))
          (set! (-> self trans z) (-> *camera* tpos-curr z))
          (vector+! (-> self trans) (-> self trans) (-> self view-flat))
          (if (and (-> *camera* on-ground) (>= (- (current-time) gp-0) (seconds 1)))
              (send-event *camera* 'change-state cam-string (seconds 0.5))
              )
          )
        (vector-reset! (-> self tracking follow-off))
        (vector+! (-> self tracking follow-pt) (-> *camera* tpos-curr-adj) (-> self tracking follow-off))
        (vector--float*!
          (-> self tracking follow-pt)
          (-> self tracking follow-pt)
          (-> *camera* local-down)
          (-> *camera* settings target-height)
          )
        (slave-set-rotation! (-> self tracking) (-> self trans) (-> self options) (-> self fov) #f)
        (suspend)
        )
      )
    #f
    (none)
    )
  )

(defstate idle (launcher)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('instant-death)
                      (go-virtual deactivated)
                      )
                     (('trans)
                      (move-to-point! (-> self root-override) (the-as vector (-> event param 0)))
                      (the-as object (update-transforms (-> self root-override)))
                      )
                     )
            )
    )
  :trans (behavior ()
    (when (and *target* (and (>= (-> self active-distance)
                                 (vector-vector-distance (-> self root-override trans) (-> *target* control trans))
                                 )
                             (not (logtest? (focus-status teleporting) (-> *target* focus-status)))
                             )
               )
      (cond
        ((send-event *target* 'query 'powerup (pickup-type eco-blue))
         (go-virtual active)
         )
        (else
          (let ((gp-0 'target-launch))
            (if (= (send-event *target* 'query 'mode) gp-0)
                (send-event *target* 'end-mode)
                )
            )
          )
        )
      (if (and (and *target*
                    (and (>= 32768.0 (vector-vector-distance (-> self root-override trans) (-> *target* control trans)))
                         (not (logtest? (focus-status teleporting) (-> *target* focus-status)))
                         )
                    )
               (not (send-event *target* 'query 'powerup (pickup-type eco-blue)))
               )
          (talker-spawn-func (-> *talker-speech* 322) *entity-pool* (target-pos 0) (the-as region #f))
          )
      )
    (none)
    )
  :code (the-as (function none :behavior launcher) sleep-code)
  )

(defstate active (launcher)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (when (or (= event-type 'touch) (= event-type 'attack))
      (set! (-> self state-time) (current-time))
      (send-event proc 'launch (-> self spring-height) (-> self camera) (-> self dest) (-> self seek-time))
      )
    (the-as object (cond
                     ((= event-type 'instant-death)
                      (go-virtual deactivated)
                      )
                     ((= event-type 'trans)
                      (move-to-point! (-> self root-override) (the-as vector (-> event param 0)))
                      (the-as object (update-transforms (-> self root-override)))
                      )
                     )
            )
    )
  :exit (behavior ()
    (let ((v1-0 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-0 command) (sound-command set-param))
      (set! (-> v1-0 id) (-> self sound-id))
      (set! (-> v1-0 params volume) -4)
      (set! (-> v1-0 auto-time) 120)
      (set! (-> v1-0 auto-from) 2)
      (set! (-> v1-0 params mask) (the-as uint 17))
      (-> v1-0 id)
      )
    (none)
    )
  :trans (behavior ()
    (if (or (or (not *target*) (or (< (-> self active-distance)
                                      (vector-vector-distance (-> self root-override trans) (-> *target* control trans))
                                      )
                                   (focus-test? *target* teleporting)
                                   )
                )
            (not (send-event *target* 'query 'powerup (pickup-type eco-blue)))
            )
        (go-virtual idle)
        )
    (spawn (-> self part) (-> self root-override trans))
    (sound-play "launch-idle" :id (-> self sound-id))
    (if (and (and *target* (and (>= (+ 2867.2 (-> self root-override root-prim prim-core world-sphere w))
                                    (vector-vector-distance (-> self root-override trans) (-> *target* control trans))
                                    )
                                (not (logtest? (focus-status teleporting) (-> *target* focus-status)))
                                )
                  )
             (< (- (current-time) (-> self state-time)) (seconds 0.5))
             )
        (send-event *target* 'launch (-> self spring-height) (-> self camera) (-> self dest) (-> self seek-time))
        )
    (none)
    )
  :code (behavior ()
    (sound-play "launch-start")
    (sleep-code)
    (none)
    )
  )

(defstate deactivated (launcher)
  :virtual #t
  :code (the-as (function none :behavior launcher) sleep-code)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! launcher ((obj launcher) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (stack-size-set! (-> obj main-thread) 128)
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((v1-4 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-4 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-4 prim-core collide-with) (collide-spec jak player-list))
      (set-vector! (-> v1-4 local-sphere) 0.0 0.0 0.0 12288.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-4)
      )
    (set! (-> s4-0 nav-radius) 13926.4)
    (let ((v1-6 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-6 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-6 prim-core collide-with))
      )
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (update-transforms (-> obj root-override))
  (set! (-> obj active-distance) 409600.0)
  (set! (-> obj spring-height) (res-lump-float arg0 'spring-height :default 163840.0))
  (let ((s4-1 (res-lump-value arg0 'mode uint128 :time -1000000000.0)))
    (let ((v1-14 (-> obj level name)))
      (set! (-> obj part) (create-launch-control
                            (cond
                              ((= v1-14 'beach)
                               (-> *part-group-id-table* 6)
                               )
                              ((= v1-14 'swamp)
                               (-> *part-group-id-table* 8)
                               )
                              (else
                                (-> *part-group-id-table* 7)
                                )
                              )
                            obj
                            )
            )
      )
    (let ((v1-20 (logand (the-as int s4-1) 255)))
      (cond
        ((= (the-as uint v1-20) 1)
         (set! (-> obj camera) cam-launcher-longfall)
         )
        ((= (the-as uint v1-20) 2)
         (set! (-> obj camera) #f)
         )
        (else
          (set! (-> obj camera) cam-launcher-shortfall)
          )
        )
      )
    )
  (let ((v1-25 (res-lump-struct arg0 'alt-vector vector)))
    (when v1-25
      (set-vector! (-> obj dest) (-> v1-25 x) (-> v1-25 y) (-> v1-25 z) 1.0)
      (set! (-> obj seek-time) (the-as time-frame (the int (* 300.0 (-> v1-25 w)))))
      )
    )
  (set! (-> obj sound-id) (new-sound-id))
  (nav-mesh-connect-from-ent obj)
  (go (method-of-object obj idle))
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior launcher-init-by-other launcher ((arg0 vector) (arg1 float) (arg2 int) (arg3 float))
  (stack-size-set! (-> self main-thread) 128)
  (let ((s2-0 (new 'process 'collide-shape self (collide-list-enum hit-by-player))))
    (let ((v1-4 (new 'process 'collide-shape-prim-sphere s2-0 (the-as uint 0))))
      (set! (-> v1-4 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-4 prim-core collide-with) (collide-spec jak player-list))
      (set-vector! (-> v1-4 local-sphere) 0.0 0.0 0.0 12288.0)
      (set! (-> s2-0 total-prims) (the-as uint 1))
      (set! (-> s2-0 root-prim) v1-4)
      )
    (set! (-> s2-0 nav-radius) (* 0.75 (-> s2-0 root-prim local-sphere w)))
    (let ((v1-7 (-> s2-0 root-prim)))
      (set! (-> s2-0 backup-collide-as) (-> v1-7 prim-core collide-as))
      (set! (-> s2-0 backup-collide-with) (-> v1-7 prim-core collide-with))
      )
    (set! (-> self root-override) s2-0)
    )
  (set! (-> self root-override trans quad) (-> arg0 quad))
  (set-vector! (-> self root-override scale) 1.0 1.0 1.0 1.0)
  (set-vector! (-> self root-override quat) 0.0 0.0 0.0 1.0)
  (update-transforms (-> self root-override))
  (set! (-> self spring-height) arg1)
  (set! (-> self active-distance) arg3)
  (let ((v1-18 (-> self level name)))
    (set! (-> self part) (create-launch-control
                           (cond
                             ((= v1-18 'beach)
                              (-> *part-group-id-table* 6)
                              )
                             ((= v1-18 'swamp)
                              (-> *part-group-id-table* 8)
                              )
                             (else
                               (-> *part-group-id-table* 7)
                               )
                             )
                           self
                           )
          )
    )
  (case (logand arg2 255)
    ((1)
     (set! (-> self camera) cam-launcher-longfall)
     )
    ((2)
     (set! (-> self camera) #f)
     )
    (else
      (set! (-> self camera) cam-launcher-shortfall)
      )
    )
  (let ((v1-29 (res-lump-struct (-> self entity) 'alt-vector vector)))
    (when v1-29
      (set-vector! (-> self dest) (-> v1-29 x) (-> v1-29 y) (-> v1-29 z) 1.0)
      (set! (-> self seek-time) (the-as time-frame (the int (* 300.0 (-> v1-29 w)))))
      )
    )
  (set! (-> self sound-id) (new-sound-id))
  (go-virtual idle)
  (none)
  )

(defstate active (touch-tracker)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (local-vars (v0-0 object))
    (case event-type
      (('touched)
       (let ((v1-1 (ppointer->process (-> self parent))))
         (when (!= v1-1 proc)
           (cond
             ((= (-> self event) 'attack)
              (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
                (set! (-> a1-1 from) (process->ppointer v1-1))
                (set! (-> a1-1 num-params) 2)
                (set! (-> a1-1 message) (-> self event))
                (set! (-> a1-1 param 0) (the-as uint #f))
                (let ((v1-5 (new 'static 'attack-info :mask (attack-info-mask mode id))))
                  (set! (-> v1-5 mode) (the-as symbol (-> self event-mode)))
                  (let* ((a2-3 *game-info*)
                         (a3-2 (+ (-> a2-3 attack-id) 1))
                         )
                    (set! (-> a2-3 attack-id) a3-2)
                    (set! (-> v1-5 id) a3-2)
                    )
                  (set! (-> a1-1 param 1) (the-as uint v1-5))
                  )
                (send-event-function proc a1-1)
                )
              )
             ((-> self event)
              (send-event proc (-> self event) :from v1-1)
              )
             (else
               (let ((t0-5 (new 'stack-no-clear 'event-message-block)))
                 (set! (-> t0-5 from) (process->ppointer proc))
                 (set! (-> t0-5 num-params) arg1)
                 (set! (-> t0-5 message) event-type)
                 (set! (-> t0-5 param 0) (-> event param 0))
                 (set! (-> t0-5 param 1) (-> event param 1))
                 (set! (-> t0-5 param 2) (-> event param 2))
                 (set! (-> t0-5 param 3) (-> event param 3))
                 (set! (-> t0-5 param 4) (-> event param 4))
                 (set! (-> t0-5 param 5) (-> event param 5))
                 (send-event-function v1-1 t0-5)
                 )
               )
             )
           )
         )
       )
      (('target)
       (set! v0-0 (process->handle (the-as process (-> event param 0))))
       (set! (-> self target) (the-as handle v0-0))
       v0-0
       )
      (('event)
       (set! (-> self event) (the-as symbol (-> event param 0)))
       (set! v0-0 (-> event param 1))
       (set! (-> self event-mode) (the-as basic v0-0))
       v0-0
       )
      (('exit)
       (set! v0-0 (-> event param 0))
       (set! (-> self run-function) (the-as (function object) v0-0))
       v0-0
       )
      (('eval)
       ((the-as (function touch-tracker object) (-> event param 0)) self)
       )
      (('function)
       (set! v0-0 (-> event param 0))
       (set! (-> self callback) (the-as (function touch-tracker none) v0-0))
       v0-0
       )
      )
    )
  :code (behavior ()
    (set! (-> self state-time) (current-time))
    (while ((-> self run-function))
      (let* ((gp-0 (handle->process (-> self target)))
             (a0-4 (if (type? gp-0 process-drawable)
                       gp-0
                       )
                   )
             )
        (when a0-4
          (let* ((gp-1 (-> (the-as process-drawable a0-4) root))
                 (a0-6 (if (type? gp-1 collide-shape)
                           gp-1
                           )
                       )
                 )
            (if a0-6
                (set! (-> self root-override trans quad)
                      (-> (the-as collide-shape a0-6) root-prim prim-core world-sphere quad)
                      )
                )
            )
          )
        )
      (if (-> self callback)
          ((-> self callback) self)
          )
      (update-transforms (-> self root-override))
      (let ((a1-3 (new 'stack-no-clear 'overlaps-others-params)))
        (set! (-> a1-3 options) (overlaps-others-options oo1))
        (set! (-> a1-3 collide-with-filter) (the-as collide-spec -1))
        (set! (-> a1-3 tlist) *touching-list*)
        (find-overlapping-shapes (-> self root-override) a1-3)
        )
      (suspend)
      )
    (let ((v1-21 (-> self root-override root-prim)))
      (set! (-> v1-21 prim-core collide-as) (collide-spec))
      (set! (-> v1-21 prim-core collide-with) (collide-spec))
      )
    0
    (suspend)
    0
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior touch-tracker-init touch-tracker ((arg0 vector) (arg1 float) (arg2 time-frame))
  (let ((s4-0 (new 'process 'collide-shape-moving self (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec jak enemy))
      (set! (-> v1-6 prim-core collide-with)
            (collide-spec
              crate
              civilian
              enemy
              obstacle
              vehicle-sphere
              hit-by-player-list
              hit-by-others-list
              collectable
              pusher
              )
            )
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 arg1)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-6)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> s4-0 event-self) 'touched)
    (set! (-> self root-override) s4-0)
    )
  (set! (-> self root-override trans quad) (-> arg0 quad))
  (set! (-> self duration) arg2)
  (set! (-> self target) (the-as handle #f))
  (set! (-> self event) #f)
  (set! (-> self callback) #f)
  (set! (-> self run-function)
        (lambda :behavior touch-tracker () (< (- (current-time) (-> self state-time)) (-> self duration)))
        )
  (set! (-> self event-hook) (-> (method-of-object self active) event))
  (go-virtual active)
  (none)
  )

(defmethod setup-explosion-collision explosion ((obj explosion))
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (set! (-> s5-0 penetrate-using) (penetrate explode))
    (let ((v1-3 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-3 prim-core action) (collide-action solid))
      (set-vector! (-> v1-3 local-sphere) 0.0 0.0 0.0 0.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-3)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-6 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-6 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-6 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  (set! (-> obj root-override event-self) 'touched)
  0
  (none)
  )

(defmethod explosion-method-22 explosion ((obj explosion))
  0
  (none)
  )

(defbehavior explosion-init-by-other explosion ((arg0 explosion-init-params))
  (logclear! (-> self mask) (process-mask actor-pause movie))
  (setup-explosion-collision self)
  (set! (-> self root-override trans quad) (-> arg0 spawn-point quad))
  (quaternion-copy! (-> self root-override quat) (-> arg0 spawn-quat))
  (set! (-> self root-override penetrate-using) (-> arg0 penetrate-using))
  (let ((v1-9 (-> self root-override root-prim)))
    (set! (-> v1-9 local-sphere w) (-> arg0 radius))
    (set! (-> v1-9 prim-core world-sphere w) (-> arg0 radius))
    (set! (-> v1-9 prim-core collide-with) (-> arg0 collide-with))
    )
  (let* ((v1-10 *game-info*)
         (a0-9 (+ (-> v1-10 attack-id) 1))
         )
    (set! (-> v1-10 attack-id) a0-9)
    (set! (-> self attack-id) a0-9)
    )
  (let ((a0-10 (-> arg0 group)))
    (when a0-10
      (set! (-> self duration) (-> a0-10 duration))
      (set! (-> self linger-duration) (-> a0-10 linger-duration))
      (set! (-> self part) (create-launch-control a0-10 self))
      )
    )
  (let ((v1-16 (new 'stack-no-clear 'traffic-danger-info)))
    (set! (-> v1-16 sphere quad) (-> self root-override trans quad))
    (vector-reset! (-> v1-16 velocity))
    (set! (-> v1-16 sphere r) (* 2.0 (-> arg0 radius)))
    (set! (-> v1-16 notify-radius) 204800.0)
    (set! (-> v1-16 danger-level) 1.0)
    (set! (-> v1-16 decay-rate) 0.0)
    (set! (-> v1-16 flags) (traffic-danger-flags tdf0))
    (set! (-> v1-16 danger-type) (traffic-danger-type tdt5))
    (send-event *traffic-manager* 'add-danger-sphere v1-16)
    )
  (explosion-method-22 self)
  (go-virtual explode)
  )

;; WARN: Return type mismatch (pointer process) vs none.
(defun explosion-spawn ((arg0 process-drawable) (arg1 type) (arg2 explosion-init-params))
  (let ((s4-0 (get-process *default-dead-pool* arg1 #x4000)))
    (when s4-0
      (let ((t9-1 (method-of-type process activate)))
        (t9-1 s4-0 arg0 (symbol->string (-> arg1 symbol)) (the-as pointer #x70004000))
        )
      (run-now-in-process s4-0 explosion-init-by-other arg2)
      (-> s4-0 ppointer)
      )
    )
  (none)
  )

(defstate explode (explosion)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('touched)
       (let* ((s4-0 proc)
              (v1-1 (if (type? s4-0 process-drawable)
                        s4-0
                        )
                    )
              )
         (when v1-1
           (let ((a0-3 (-> (the-as process-drawable v1-1) root))
                 (a1-2 (new 'stack-no-clear 'collide-query))
                 )
             (let ((v1-4 (-> self root-override root-prim prim-core))
                   (a0-5 (-> (the-as collide-shape a0-3) root-prim prim-core))
                   )
               0.0
               (set! (-> a1-2 start-pos quad) (-> v1-4 world-sphere quad))
               (vector-! (-> a1-2 move-dist) (the-as vector a0-5) (the-as vector v1-4))
               )
             (let ((v1-5 a1-2))
               (set! (-> v1-5 radius) 40.96)
               (set! (-> v1-5 collide-with) (collide-spec backgnd))
               (set! (-> v1-5 ignore-process0) #f)
               (set! (-> v1-5 ignore-process1) #f)
               (set! (-> v1-5 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
               (set! (-> v1-5 action-mask) (collide-action solid))
               )
             (when (< (fill-and-probe-using-line-sphere *collide-cache* a1-2) 0.0)
               (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
                 (set! (-> a1-3 from) (process->ppointer self))
                 (set! (-> a1-3 num-params) 2)
                 (set! (-> a1-3 message) 'attack)
                 (set! (-> a1-3 param 0) (-> event param 0))
                 (let ((v1-12 (new 'static 'attack-info :mask (attack-info-mask mode id))))
                   (set! (-> v1-12 id) (-> self attack-id))
                   (set! (-> v1-12 mode) 'explode)
                   (set! (-> a1-3 param 1) (the-as uint v1-12))
                   )
                 (send-event-function proc a1-3)
                 )
               )
             )
           )
         )
       )
      )
    )
  :code (behavior ()
    (set! (-> self start-time) (current-time))
    (update-transforms (-> self root-override))
    (let ((a1-0 (new 'stack-no-clear 'overlaps-others-params)))
      (set! (-> a1-0 options) (overlaps-others-options))
      (set! (-> a1-0 collide-with-filter) (the-as collide-spec -1))
      (set! (-> a1-0 tlist) *touching-list*)
      (find-overlapping-shapes (-> self root-override) a1-0)
      )
    (let ((v1-9 (-> self root-override root-prim)))
      (set! (-> v1-9 prim-core collide-as) (collide-spec))
      (set! (-> v1-9 prim-core collide-with) (collide-spec))
      )
    0
    (while (< (- (current-time) (-> self start-time)) (the-as time-frame (-> self duration)))
      (let ((a1-1 (-> self root-override trans)))
        (spawn (-> self part) a1-1)
        )
      (suspend)
      )
    (set! (-> self start-time) (current-time))
    (while (< (- (current-time) (-> self start-time)) (the-as time-frame (-> self linger-duration)))
      (suspend)
      )
    (none)
    )
  )

(defun process-drawable-random-point! ((arg0 process-drawable) (arg1 vector))
  (let ((v1-1 (-> arg0 node-list length))
        (s4-0 (-> arg0 root))
        )
    (cond
      ((>= v1-1 7)
       (let ((v1-2 (rand-vu-int-range 3 (+ v1-1 -1))))
         (vector<-cspace! arg1 (-> arg0 node-list data v1-2))
         )
       )
      ((and (nonzero? s4-0) (type? s4-0 collide-shape))
       (vector+!
         arg1
         (the-as vector (-> (the-as collide-shape s4-0) root-prim prim-core))
         (rand-vu-sphere-point! arg1 (-> (the-as collide-shape s4-0) root-prim prim-core world-sphere w))
         )
       )
      (else
        (vector+! arg1 (-> arg0 root trans) (rand-vu-sphere-point! arg1 (-> arg0 draw bounds w)))
        )
      )
    )
  arg1
  )

(defun process-drawable-pair-random-point! ((arg0 process-drawable) (arg1 process-drawable) (arg2 vector) (arg3 float))
  (let ((s4-0 (new-stack-vector0))
        (s3-0 (new-stack-vector0))
        )
    (process-drawable-random-point! arg0 s4-0)
    (process-drawable-random-point! arg1 s3-0)
    (vector-lerp! arg2 s4-0 s3-0 arg3)
    )
  )
