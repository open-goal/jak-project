;;-*-Lisp-*-
(in-package goal)

;; name: racer-states-FIC-LAV-MIS-OGR-ROL.gc
;; name in dgo: racer-states
;; dgos: FIC, LAV, MIS, OGR, ROL

(define-extern *race-track-surface* surface)

;; DECOMP BEGINS

(defstate target-racing-start (target)
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (cond
      ((and (= arg2 'query) (= (-> arg3 param 0) 'mode))
       'racer
       )
      ((and (= arg2 'get-pickup) (= (-> arg3 param 0) 3))
       (if (>= (- (-> *display* base-frame-counter) (-> self racer boost-time)) (seconds 1))
           (send-event self 'boost (fmax 1.0 (fmin 2.0 (the-as float (-> arg3 param 1)))))
           )
       )
      (else
        (case arg2
          (('end-mode)
           (go target-racing-get-off (process->handle arg0))
           )
          (('touched)
           (send-event arg0 'attack (-> arg3 param 0) 'racer 0 0)
           (when (and (type-type? (-> arg0 type) babak) (< 40960.0 (-> self control unknown-float01)))
             (let ((f0-5 (lerp-scale 16384.0 32768.0 (-> self control unknown-float01) 40960.0 (-> self racer transv-max))))
               (go target-racing-jump f0-5 f0-5 #f)
               )
             )
           )
          (('attack 'attack-or-shove 'attack-invinc)
           (let ((v1-27 (the-as attack-info (-> arg3 param 1))))
             (if (not (and (logtest? (-> v1-27 mask) (attack-mask mode)) (or (= (-> v1-27 mode) 'burn) (= (-> v1-27 mode) 'burnup)))
                      )
                 (target-attacked
                   arg2
                   (the-as attack-info (-> arg3 param 1))
                   arg0
                   (the-as process (-> arg3 param 0))
                   (the-as (state symbol attack-info target) target-racing-hit)
                   )
                 )
             )
           )
          (('heat)
           (let ((f0-7 (fmax 0.0 (fmin (+ (-> self racer heat) (the-as float (-> arg3 param 0))) (-> *RACER-bank* heat-max))))
                 )
             (set! (-> self racer heat) f0-7)
             f0-7
             )
           )
          (('boost)
           (sound-play "get-blue-eco")
           (set! (-> self racer boost-sound-id) (sound-play "zoom-boost"))
           (set! (-> self racer boost-time) (-> *display* base-frame-counter))
           (let ((f0-12 (seek
                          (-> self racer boost-level)
                          (-> *RACER-bank* boost-level-max)
                          (* (-> *RACER-bank* boost-level-inc) (the-as float (-> arg3 param 0)))
                          )
                        )
                 )
             (set! (-> self racer boost-level) f0-12)
             f0-12
             )
           )
          (('smack)
           (go target-racing-smack (-> self control unknown-float01) #t)
           )
          (('jump)
           (go target-racing-jump (the-as float (-> arg3 param 0)) (the-as float (-> arg3 param 1)) #f)
           )
          (('change-mode)
           (case (-> arg3 param 0)
             (('grab)
              (go target-racing-grab)
              )
             )
           )
          (('clone-anim)
           (go target-racing-clone-anim (process->handle (the-as process (-> arg3 param 0))))
           )
          (else
            (target-generic-event-handler arg0 arg1 arg2 arg3)
            )
          )
        )
      )
    )
  :exit (behavior ()
    (when (not (or (= (-> self next-state name) 'target-racing)
                   (= (-> self next-state name) 'target-racing-jump)
                   (= (-> self next-state name) 'target-racing-bounce)
                   (= (-> self next-state name) 'target-racing-hit)
                   (= (-> self next-state name) 'target-racing-death)
                   (= (-> self next-state name) 'target-racing-smack)
                   (= (-> self next-state name) 'target-racing-falling)
                   (= (-> self next-state name) 'target-racing-get-on)
                   (= (-> self next-state name) 'target-racing-get-off)
                   (= (-> self next-state name) 'target-racing-get-off-jump)
                   (= (-> self next-state name) 'target-racing-grab)
                   (= (-> self next-state name) 'target-racing-clone-anim)
                   )
               )
      (let ((v1-25 (-> self manipy)))
        (when v1-25
          (deactivate (-> v1-25 0))
          (set! (-> self manipy) (the-as (pointer manipy) #f))
          )
        )
      (let ((v1-29 (-> *hud-parts* bike-speed)))
        (when v1-29
          (set! (-> v1-29 0 deactivate-when-hidden) #t)
          (send-event (ppointer->process v1-29) 'hide-quick)
          )
        )
      (let ((v1-32 (-> *hud-parts* bike-heat)))
        (when v1-32
          (set! (-> v1-32 0 deactivate-when-hidden) #t)
          (send-event (ppointer->process v1-32) 'hide-quick)
          )
        )
      (set! (-> *hud-parts* buzzers 0 next-y-offset) 0)
      (set! (-> *hud-parts* power 0 next-y-offset) 0)
      (set! (-> *hud-parts* buzzers 0 y-sgn) 1)
      (set! (-> *hud-parts* power 0 y-sgn) 1)
      (logclear! (-> self control root-prim prim-core action) (collide-action ca-9 ca-16))
      (set! (-> self control unknown-surface00) *walk-mods*)
      (logclear! (-> self state-flags) (state-flags use-alt-cam-pos))
      (send-event *camera* 'clear-slave-option #x6000)
      (set! (-> self control dynam gravity-max) (-> self control unknown-dynamics00 gravity-max))
      (set! (-> self control dynam gravity-length) (-> self control unknown-dynamics00 gravity-length))
      (let ((v1-60 (-> self node-list data)))
        (set! (-> v1-60 0 param0) cspace<-transformq+trans!)
        (set! (-> v1-60 0 param1) (the-as basic (-> self control trans)))
        (set! (-> v1-60 0 param2) (the-as basic (-> self control unknown-vector12)))
        )
      (target-collide-set! 'normal 0.0)
      (set! (-> self control reaction) target-collision-reaction)
      (sound-stop (-> self racer engine-sound-id))
      (set! (-> self racer engine-sound-id) (new 'static 'sound-id))
      (set! (-> self control unknown-vector12 quad) (the-as uint128 0))
      (remove-setting! 'sound-flava)
      (target-exit)
      )
    (none)
    )
  :code (behavior ((arg0 handle))
    (target-exit)
    (set! *display-profile* #f)
    (set! *display-entity-errors* #f)
    (set-setting! 'sound-flava #f 30.0 (music-flava racer))
    (if (zero? (-> self racer))
        (set! (-> self racer) (new 'process 'racer-info))
        )
    (set! (-> self racer turn-anim-targ) 0.0)
    (set! (-> self racer turn-anim-frame) 0.0)
    (set! (-> self racer turn-anim-vel) 0.0)
    (set! (-> self racer tail-anim-vel) 0.0)
    (set! (-> self racer tail-anim-frame) 0.0)
    (set! (-> self racer rudd-anim-vel) 0.0)
    (set! (-> self racer rudd-anim-frame) 0.0)
    (set! (-> self racer stick-lock) #f)
    (set! (-> self racer stick-off) #f)
    (set! (-> self racer heavy) #f)
    (set! (-> self racer unstuck-time) (-> *display* base-frame-counter))
    (set! (-> self racer stuck-count) 0)
    (set! (-> self racer cushion-base) 10240.0)
    (set! (-> self racer shock-offset) 0.0)
    (set! (-> self racer shock-offsetv) 0.0)
    (set! (-> self racer shock-rotx) 0.0)
    (set! (-> self racer engine-sound-id) (new 'static 'sound-id))
    (set! (-> self racer boost-sound-id) (new 'static 'sound-id))
    (set! (-> self racer scrape-sound-id) (new-sound-id))
    (set! (-> self racer entity) #f)
    (let ((v1-28 (handle->process arg0)))
      (if v1-28
          (set! (-> self racer entity) (-> v1-28 entity))
          )
      )
    (set! (-> self control surf) *race-track-surface*)
    (set! (-> self control reaction) racer-collision-reaction)
    (vector-reset! (-> self racer rot))
    (set! (-> self racer rot y) (y-angle (-> self control)))
    (target-collide-set! 'racer 0.0)
    (set! (-> self control transv quad) (the-as uint128 0))
    (set! (-> self control unknown-float01) 0.0)
    (logior! (-> self control root-prim prim-core action) (collide-action ca-9))
    (set! (-> self control unknown-surface00) *racer-mods*)
    (set! (-> self racer lean-rotx) 0.0)
    (vector-reset! (-> self racer rotv))
    (quaternion-identity! (the-as quaternion (-> self racer surface-quat)))
    (quaternion-identity! (the-as quaternion (-> self racer surface-quat-smooth)))
    (set! (-> self racer front-rot) (-> *RACER-bank* default-front-blade))
    (set! (-> self racer front-rotv) 0.0)
    (set! (-> self racer bottom-rot) 0.0)
    (let ((v1-56 (-> self node-list data)))
      (set! (-> v1-56 0 param0) cspace<-transformq+world-trans!)
      (set! (-> v1-56 0 param1) (the-as basic (-> self control trans)))
      (set! (-> v1-56 0 param2) (the-as basic (-> self control unknown-vector12)))
      )
    (set! (-> self control unknown-float81) 1.0)
    (set! (-> self racer hop?) #f)
    (set! (-> self racer bounce) 0)
    (set! (-> self racer bounce-hit) 0.0)
    (set! (-> self racer bob-period) 900.0)
    (set! (-> self racer bob-mult-rot) 0.0)
    (set! (-> self racer bob-mult-trans) 0.0)
    (set! (-> self racer bob-meta-timer) 0.0)
    (set! (-> self racer bob-meta-meta-timer) 0.0)
    (set! (-> self racer bob-hit-ground-time) 0)
    (set! (-> self racer cushion-bob) 0.0)
    (set! (-> self racer cushion-bob-old) 0.0)
    (set! (-> self racer hill-value) 0.0)
    (set! (-> self racer hill-ground-value) 0.0)
    (set! (-> self racer hill-offset) 0.0)
    (set! (-> self racer hill-boost) 0.0)
    (set! (-> self racer cur-rotx) 0.0)
    (set! (-> self racer targ-rotx) 0.0)
    (set! (-> self racer hill-rotx) 0.0)
    (set! (-> self racer mult-rotx) 0.0)
    (set! (-> self racer speed-rotx) 0.25)
    (set! (-> self racer boost-curve) 0.0)
    (set! (-> self racer boost-level) 0.0)
    (set! (-> self racer boost-target) 0.0)
    (set! (-> self racer boost-output) 0.0)
    (set! (-> self racer boost-time) 0)
    (set! (-> self racer boost-duration) (-> *RACER-bank* boost-duration))
    (set! (-> self racer heat) 0.0)
    (set! (-> self racer slide-mode) 0)
    (set! (-> self racer slide-amp) 0.0)
    (set! (-> self racer slide-down-time 0) 0)
    (set! (-> self racer slide-down-time 1) 0)
    (set! (-> self racer slide-interp) 0.0)
    (set! (-> self racer surface-y) (-> self control trans y))
    (let ((s5-0 (-> self entity)))
      (set! (-> self entity) (-> self racer entity))
      (set! (-> self manipy)
            (manipy-spawn (-> self control trans) (-> self entity) *racer-sg* #f :from *8k-dead-pool* :to self)
            )
      (set! (-> self entity) s5-0)
      )
    (when (-> self manipy)
      (send-event
        (ppointer->process (-> self manipy))
        'trans-hook
        (lambda :behavior manipy
          ()
          (let ((v1-0 (ppointer->process (-> self parent))))
            (set! (-> self root trans quad) (-> (the-as target v1-0) racer bike-trans quad))
            (let ((a0-4 (-> (the-as target v1-0) racer bike-quat quad)))
              (set! (-> self root quat vec quad) a0-4)
              )
            (set! (-> self root scale quad) (-> (the-as target v1-0) racer bike-scale quad))
            (set! (-> self draw light-index) (the-as uint 255))
            (let ((a0-9 (-> (the-as target v1-0) draw color-mult quad)))
              (set! (-> self draw color-mult quad) a0-9)
              )
            (let ((a0-11 (-> (the-as target v1-0) draw color-emissive quad)))
              (set! (-> self draw color-emissive quad) a0-11)
              )
            (let ((f0-0 (-> (the-as target v1-0) draw secondary-interp)))
              (set! (-> self draw secondary-interp) f0-0)
              f0-0
              )
            )
          )
        )
      (send-event (ppointer->process (-> self manipy)) 'anim-mode 'loop)
      (send-event (ppointer->process (-> self manipy)) 'art-joint-anim "racer-get-on" 0.0)
      (send-event
        (ppointer->process (-> self manipy))
        'eval
        (lambda :behavior manipy
          ()
          (set! (-> self clone-copy-trans) #f)
          (let ((v1-1 (-> *target-shadow-control* settings shadow-dir quad)))
            (set! (-> *racer-shadow-control* settings shadow-dir quad) v1-1)
            )
          (set! (-> self draw shadow-ctrl) *racer-shadow-control*)
          (let ((gp-0 (-> self parent)))
            (set! (-> (the-as target (-> gp-0 0)) racer front-blade)
                  (new 'process 'joint-mod (joint-mod-handler-mode rotate) self 4)
                  )
            (set! (-> (the-as target (-> gp-0 0)) racer bottom-blade)
                  (new 'process 'joint-mod (joint-mod-handler-mode rotate) self 10)
                  )
            (let ((v0-2 (new 'process 'joint-mod (joint-mod-handler-mode rotate) self 7)))
              (set! (-> (the-as target (-> gp-0 0)) racer tail) v0-2)
              v0-2
              )
            )
          )
        )
      )
    (set-twist! (-> self racer front-blade) (the-as float #f) (- (-> self racer front-rot)) (the-as float #f))
    (set-twist! (-> self racer bottom-blade) (the-as float #f) (the-as float #f) (- (-> self racer bottom-rot)))
    (remove-exit)
    (go target-racing-get-on arg0)
    (none)
    )
  :post target-post
  )

(defbehavior target-racing-smack-check target ()
  (if (and (< 20480.0 (-> self control unknown-float01))
           (and (logtest? (-> self control status) (cshape-moving-flags twall))
                (< (-> self control surface-angle) 0.5)
                (let ((gp-1 (vector-! (new 'stack-no-clear 'vector) (-> self control unknown-vector70) (-> self control trans)))
                      (s5-0 (new 'stack-no-clear 'vector))
                      )
                  (set! (-> s5-0 quad) (-> self control unknown-vector10 quad))
                  (set! (-> gp-1 y) 0.0)
                  (set! (-> s5-0 y) 0.0)
                  (vector-xz-normalize! gp-1 1.0)
                  (vector-xz-normalize! s5-0 1.0)
                  (< 0.87 (vector-dot gp-1 s5-0))
                  )
                )
           )
      (go target-racing-smack (-> self control unknown-float01) #t)
      )
  (none)
  )

(defstate target-racing (target)
  :event (-> target-racing-start event)
  :enter (behavior ()
    (set! (-> self control unknown-surface00) *racer-mods*)
    (none)
    )
  :exit (behavior ()
    (target-racing-center-anim)
    ((-> target-racing-start exit))
    (none)
    )
  :trans (behavior ()
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 2)
                               )
                       (pad-buttons l1 r1)
                       )
             (or (< (- (-> *display* base-frame-counter) (-> self control unknown-dword11)) (seconds 0.1))
                 (< (vector-dot
                      (-> self control dynam gravity-normal)
                      (vector-! (new 'stack-no-clear 'vector) (-> self control trans) (-> self control shadow-pos))
                      )
                    4096.0
                    )
                 )
             )
        (go target-racing-jump 2048.0 5324.8 #t)
        )
    (target-racing-smack-check)
    (let* ((f30-0 (target-height-above-ground))
           (v1-28 (time-to-ground
                    (vector-dot (-> self control dynam gravity-normal) (-> self control transv))
                    (-> self control dynam gravity-length)
                    f30-0
                    )
                  )
           )
      (if (and (zero? (logand (-> self control status) (cshape-moving-flags onsurf)))
               (or (>= (- (-> *display* base-frame-counter) (-> self control unknown-dword11))
                       (* (-> *TARGET-bank* ground-timeout) 2)
                       )
                   (< 75 v1-28)
                   )
               (< 30 v1-28)
               (< 4096.0 f30-0)
               )
          (go target-racing-falling)
          )
      )
    (set! (-> self racer turn-anim-targ) (* 20.0 (-> self racer mod-x)))
    (racer-buzz (+ 0.45 (* 1.7 (fabs (-> self racer slide-shift-x)))))
    (none)
    )
  :code (behavior ()
    (cond
      ((ja-group? (-> self draw art-group data 138))
       (ja-no-eval :num! (seek!))
       (while (not (ja-done? 0))
         (suspend)
         (ja-eval)
         )
       )
      ((let ((v1-16 (ja-group)))
         (or (or (= v1-16 (-> self draw art-group data 130)) (= v1-16 (-> self draw art-group data 131)))
             (> (-> self racer bounce) 0)
             )
         )
       (let ((s5-0 #f)
             (gp-0 #f)
             )
         (when (and (< (fabs (-> self racer bob-mult-trans)) 0.2)
                    (and (>= (- (-> *display* base-frame-counter) (-> self racer racing-time)) (seconds 0.15))
                         (< 16384.0 (-> self control ground-impact-vel))
                         )
                    )
           (when (>= (-> self control unknown-float01) 40960.0)
             (set! (-> *part-id-table* 2225 init-specs 1 initial-valuef) 100.0)
             (launch-particles (-> *part-id-table* 2225) (-> self control trans))
             )
           (target-land-effect)
           (when (and (>= (-> self control ground-impact-vel) 61440.0) (zero? (-> self racer bounce)))
             (set! (-> self racer bounce) 0)
             (set! (-> self racer bounce-hit) (-> self control ground-impact-vel))
             )
           (when (< (-> self racer bounce-hit) 73728.0)
             (set! (-> self racer bounce) 0)
             0
             )
           (set! (-> self racer bob-timer) 90.0)
           (let ((f0-14 (lerp-scale 2.0 3.0 (-> self control unknown-float01) 0.0 (-> self racer transv-max))))
             (set! (-> self racer bob-meta-meta-timer) f0-14)
             (set! (-> self racer bob-meta-timer) f0-14)
             )
           (set! (-> self racer bob-mult-trans) (lerp-scale 0.2 2.5 (-> self control ground-impact-vel) 20480.0 81920.0))
           (set! (-> self racer bob-hit-ground-time) (-> *display* base-frame-counter))
           (set! (-> self racer bob-meta-time) (-> *display* base-frame-counter))
           (cond
             ((or s5-0 (and (>= (-> self racer bounce) 1) (< (-> self racer bounce) 2)))
              (+! (-> self racer bounce) 1)
              (let* ((v1-73 (-> self racer bounce))
                     (a1-6 (cond
                             ((= v1-73 1)
                              (lerp-scale 4096.0 8192.0 (-> self racer bounce-hit) 61440.0 81920.0)
                              )
                             ((= v1-73 2)
                              2048.0
                              )
                             )
                           )
                     )
                (go target-racing-bounce a1-6 a1-6 gp-0)
                )
              )
             ((>= (-> self racer slide-mode) 0)
              )
             (else
               (target-racing-land-anim gp-0)
               )
             )
           )
         )
       )
      )
    (when (!= (-> self racer slide-shift-x) 0.0)
      (if (rand-vu-percent? 0.5)
          (sound-play "zoomer-rev1" :vol 80)
          (sound-play "zoomer-rev2" :vol 80)
          )
      )
    (set! (-> self racer bounce) 0)
    (loop
      (let ((gp-3 (-> *display* base-frame-counter)))
        (when (not (ja-group? (-> self draw art-group data 123)))
          (ja-channel-push! 4 (seconds 0.1))
          (ja :group! (-> self draw art-group data 123) :num! (identity (ja-aframe (-> self racer turn-anim-frame) 0)))
          (ja :chan 1 :group! (-> self draw art-group data 124) :num! (chan 0))
          (ja :chan 2 :group! (-> self draw art-group data 125) :num! (chan 0))
          (ja :chan 3 :group! (-> self draw art-group data 126) :num! (chan 0))
          )
        (while (< (- (-> *display* base-frame-counter) gp-3) (seconds 1))
          (if (or (!= (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) stick0-speed) 0.0)
                  (or (cpad-hold? (-> self control unknown-cpad-info00 number) l1 r1 x)
                      (>= (fabs (-> self racer turn-anim-frame)) 1.0)
                      )
                  )
              (set! gp-3 (-> *display* base-frame-counter))
              )
          (target-racing-turn-anim)
          (suspend)
          )
        )
      (when (not (ja-group? (-> self draw art-group data 133)))
        (ja-channel-push! 1 (seconds 0.4))
        (ja :group! (-> self draw art-group data 133) :num! min)
        )
      (while (not (or (!= (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) stick0-speed) 0.0)
                      (or (cpad-hold? (-> self control unknown-cpad-info00 number) l1 r1 x)
                          (>= (fabs (-> self racer turn-anim-frame)) 1.0)
                          )
                      )
                  )
        (suspend)
        (ja :num! (loop!))
        )
      )
    (none)
    )
  :post (behavior ()
    (if (= (-> self next-state name) 'target-racing)
        (set! (-> self racer racing-time) (-> *display* base-frame-counter))
        )
    (target-racing-post)
    (none)
    )
  )

(defstate target-racing-jump (target)
  :event (-> target-racing-start event)
  :enter (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    (set! (-> self racer shock-offsetv) 0.0)
    (sound-play "zoomer-jump")
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (when arg2
      (when (>= (-> self racer hill-ground-value) 0.11)
        (set! (-> self racer hill-boost) (* 40960.0 (-> self racer hill-ground-value)))
        (vector-normalize! (-> self control transv) (+ (-> self control unknown-float01) (-> self racer hill-boost)))
        )
      )
    (if (and (logtest? (-> self control status) (cshape-moving-flags onsurf)) (< 16384.0 (-> self control transv y)))
        (set! (-> self racer hop?) #f)
        (set! (-> self racer hop?) arg2)
        )
    (set! (-> self racer hop-start-y) (-> self control trans y))
    (racer-calc-gravity)
    (init-var-jump arg0 arg1 (the-as vector #t) (the-as vector #f) (-> self control transv))
    (logclear! (-> self control status) (cshape-moving-flags onsurf onground tsurf))
    (set! (-> self control unknown-surface00) *racer-air-mods*)
    (set! (-> self control unknown-float123)
          (fmax 0.0 (fmin 1.0 (* 0.00004359654 (+ -11468.8 (-> self control unknown-float01)))))
          )
    (if (< (-> self racer slide-mode) 0)
        (set! (-> self racer slide-down-time 0)
              (the-as time-frame (if (cpad-hold? (-> self control unknown-cpad-info00 number) l1 r1)
                                     (the-as int (-> *display* base-frame-counter))
                                     0
                                     )
                      )
              )
        )
    (none)
    )
  :exit (behavior ()
    (logclear! (-> self control root-prim prim-core action) (collide-action ca-15))
    (set! (-> self racer hop?) #f)
    ((-> target-racing-start exit))
    (none)
    )
  :trans (behavior ()
    (set! (-> self control unknown-float123)
          (fmax
            (-> self control unknown-float123)
            (* 0.003921569 (the float (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) abutton 6)))
            )
          )
    (cond
      ((cpad-pressed? (-> self control unknown-cpad-info00 number) l1 r1)
       (set! (-> self racer slide-down-time 0) (-> *display* base-frame-counter))
       )
      ((zero? (logand (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-abs 0) (pad-buttons l1 r1))
              )
       (set! (-> self racer slide-down-time 0) 0)
       0
       )
      ((and (>= (- (-> *display* base-frame-counter) (-> self racer slide-down-time 0))
                (the-as time-frame (-> *RACER-bank* slide-hold-time))
                )
            (< (-> self racer slide-mode) 0)
            (or (< (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) leftx) (the-as uint 64))
                (< (the-as uint 192) (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) leftx))
                )
            )
       (set! (-> self racer slide-mode)
             (if (< (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) leftx) (the-as uint 64))
                 0
                 1
                 )
             )
       (set! (-> self racer slide-enter-time) (-> *display* base-frame-counter))
       (set! (-> self racer slide-amp) 1.0)
       (set! (-> self racer slide-grip-mult) 0.0)
       )
      ((>= (-> self racer slide-mode) 0)
       (cond
         ((< (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) leftx) (the-as uint 64))
          (set! (-> self racer slide-mode) 0)
          0
          )
         ((< (the-as uint 192) (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) leftx))
          (set! (-> self racer slide-mode) 1)
          )
         )
       )
      )
    (if (and (logtest? (-> self control status) (cshape-moving-flags onsurf))
             (>= (- (-> *display* base-frame-counter) (-> self state-time)) (seconds 0.1))
             )
        (go target-racing)
        )
    (if (or (< (-> self control trans y) (-> self racer hop-start-y))
            (< 10240.0 (vector-dot
                         (-> self control dynam gravity-normal)
                         (vector-! (new 'stack-no-clear 'vector) (-> self control trans) (-> self control shadow-pos))
                         )
               )
            )
        (set! (-> self racer hop?) #f)
        )
    (target-racing-smack-check)
    (if (>= (- (-> *display* base-frame-counter) (-> self state-time)) (seconds 1))
        (logior! (-> self control root-prim prim-core action) (collide-action ca-15))
        )
    (mod-var-jump #t #t (cpad-hold? (-> self control unknown-cpad-info00 number) l1 r1) (-> self control transv))
    (set! (-> self racer shock-offset) (* 0.8 (-> self racer shock-offset)))
    (racer-buzz 0.4)
    (none)
    )
  :code (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    (let ((a0-1 (if (< 0.1 (-> self racer hill-value))
                    'jump
                    )
                )
          )
      (target-racing-jump-anim a0-1 (seconds 0.2))
      )
    (none)
    )
  :post (-> target-racing post)
  )

(defstate target-racing-bounce (target)
  :event (-> target-racing-start event)
  :enter (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    (logior! (-> self control root-prim prim-core action) (collide-action ca-15))
    (sound-play "zoomer-jump")
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (racer-calc-gravity)
    (init-var-jump arg0 arg1 (the-as vector #t) (the-as vector #f) (-> self control transv))
    (logclear! (-> self control status) (cshape-moving-flags onsurf onground tsurf))
    (set! (-> self control unknown-float123)
          (fmax 0.0 (fmin 1.0 (* 0.00004359654 (+ -11468.8 (-> self control unknown-float01)))))
          )
    (none)
    )
  :exit (behavior ()
    (logclear! (-> self control root-prim prim-core action) (collide-action ca-15))
    ((-> target-racing-start exit))
    (none)
    )
  :trans (behavior ()
    (set! (-> self control unknown-float123)
          (fmax
            (-> self control unknown-float123)
            (* 0.003921569 (the float (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) abutton 6)))
            )
          )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 2)
                               )
                       (pad-buttons l1 r1)
                       )
             (or (< (- (-> *display* base-frame-counter) (-> self control unknown-dword11)) (seconds 0.2))
                 (< (vector-dot
                      (-> self control dynam gravity-normal)
                      (vector-! (new 'stack-no-clear 'vector) (-> self control trans) (-> self control shadow-pos))
                      )
                    8192.0
                    )
                 )
             )
        (go target-racing-jump 2048.0 5324.8 #t)
        )
    (if (and (logtest? (-> self control status) (cshape-moving-flags onsurf))
             (>= (- (-> *display* base-frame-counter) (-> self state-time)) (seconds 0.1))
             )
        (go target-racing)
        )
    (mod-var-jump #t #t (cpad-hold? (-> self control unknown-cpad-info00 number) l1 r1) (-> self control transv))
    (target-racing-smack-check)
    (racer-buzz 0.4)
    (none)
    )
  :code (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    (target-racing-land-anim arg2)
    (when (not (ja-group? (-> self draw art-group data 123)))
      (ja-channel-push! 4 (seconds 0.1))
      (ja :group! (-> self draw art-group data 123) :num! (identity (ja-aframe (-> self racer turn-anim-frame) 0)))
      (ja :chan 1 :group! (-> self draw art-group data 124) :num! (chan 0))
      (ja :chan 2 :group! (-> self draw art-group data 125) :num! (chan 0))
      (ja :chan 3 :group! (-> self draw art-group data 126) :num! (chan 0))
      )
    (loop
      (target-racing-turn-anim)
      (suspend)
      )
    (none)
    )
  :post (-> target-racing post)
  )

(defstate target-racing-smack (target)
  :event (-> target-racing-start event)
  :enter (behavior ((arg0 float) (arg1 symbol))
    (sound-play "smack-surface")
    (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.5))
    (set! (-> self racer heavy) arg1)
    (vector-! (-> self control transv) (-> self control unknown-vector70) (-> self control trans))
    (let ((f0-0 (lerp-scale 0.0 -61440.0 arg0 0.0 163840.0)))
      (if (cpad-hold? (-> self control unknown-cpad-info00 number) x)
          (set! f0-0 (* 2.0 f0-0))
          )
      (vector-normalize! (-> self control transv) f0-0)
      )
    (set! (-> self racer boost-curve) 0.0)
    (set! (-> self racer boost-level) 0.0)
    (set! (-> self racer boost-target) 0.0)
    (set! (-> self racer boost-output) 0.0)
    (set! (-> self racer boost-time) 0)
    0
    (none)
    )
  :exit (behavior ()
    (set! (-> self racer heavy) #f)
    ((-> target-racing-start exit))
    (none)
    )
  :trans (behavior ()
    (set! (-> self racer turn-anim-targ) 0.0)
    (none)
    )
  :code (behavior ((arg0 float) (arg1 symbol))
    (sound-play "zoomer-crash-2")
    (ja-channel-push! 2 (seconds 0.05))
    (ja-no-eval :group! (-> self draw art-group data 136) :num! (seek!))
    (ja :chan 1
        :group! (-> self draw art-group data 122)
        :num! (identity (ja-aframe 0.0 0))
        :frame-interp (lerp-scale 1.0 0.25 arg0 0.0 122880.0)
        )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max (lerp-scale 2.0 1.0 arg0 0.0 163840.0)))
      )
    (go target-racing)
    (none)
    )
  :post (-> target-racing post)
  )

(defstate target-racing-falling (target)
  :event (-> target-racing-start event)
  :enter (behavior ()
    (set! (-> self control unknown-surface00) *racer-air-mods*)
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (none)
    )
  :exit (behavior ()
    (logclear! (-> self control root-prim prim-core action) (collide-action ca-15))
    ((-> target-racing-start exit))
    (none)
    )
  :trans (behavior ()
    (if (logtest? (-> self control status) (cshape-moving-flags onsurf))
        (go target-racing)
        )
    (target-racing-smack-check)
    (racer-buzz 0.3)
    (if (>= (- (-> *display* base-frame-counter) (-> self state-time)) (seconds 1))
        (logior! (-> self control root-prim prim-core action) (collide-action ca-15))
        )
    (none)
    )
  :code (behavior ()
    (target-racing-jump-anim #f (seconds 0.1))
    (none)
    )
  :post (-> target-racing post)
  )

(defstate target-racing-hit (target)
  :event target-generic-event-handler
  :enter (behavior ((arg0 handle) (arg1 attack-info))
    (let ((v1-0 (-> self attack-info)))
      (set! (-> v1-0 attacker) arg0)
      (set! (-> v1-0 mode) 'generic)
      (set! (-> v1-0 shove-back) 6144.0)
      (set! (-> v1-0 shove-up) 4915.2)
      (set! (-> v1-0 angle) #f)
      )
    (set! (-> self attack-info trans quad) (the-as uint128 0))
    (combine! (-> self attack-info) arg1)
    (case (-> self attack-info mode)
      (('endlessfall 'death 'explode 'water-vol 'heat 'melt 'instant-death)
       (pickup-collectable! (-> self fact-info-target) (pickup-type eco-green) -1000.0 (the-as handle #f))
       )
      (else
        (pickup-collectable!
          (-> self fact-info-target)
          (pickup-type eco-green)
          (- (-> *FACT-bank* health-single-inc))
          (the-as handle #f)
          )
        )
      )
    (none)
    )
  :exit (behavior ()
    (if (!= (-> self next-state name) 'target-racing-death)
        (logclear! (-> self state-flags) (state-flags being-attacked dying))
        )
    ((-> target-racing-start exit))
    (none)
    )
  :code (behavior ((arg0 handle) (arg1 attack-info))
    (target-timed-invulnerable (-> *TARGET-bank* hit-invulnerable-timeout) self)
    (when (!= (-> self attack-info mode) 'endlessfall)
      (dummy-10 (-> self skel effect) 'group-target-hit -1.0 -1)
      (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.3))
      (sound-play "oof")
      )
    (set! (-> self game hit-time) (-> *display* base-frame-counter))
    (logior! (-> self state-flags) (state-flags being-attacked))
    (set! (-> self racer boost-curve) 0.0)
    (set! (-> self racer boost-level) 0.0)
    (set! (-> self racer boost-target) 0.0)
    (set! (-> self racer boost-output) 0.0)
    (set! (-> self racer boost-time) 0)
    (if (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact-info-target health)))
        (go target-racing-death (-> self attack-info mode))
        )
    (case (-> self attack-info mode)
      (('endlessfall)
       )
      (('darkeco)
       (let ((s5-1 (new 'stack-no-clear 'vector)))
         (set! (-> s5-1 quad) (-> self control transv quad))
         (let ((a2-3 (vector-xz-normalize!
                       (vector-! (new 'stack-no-clear 'vector) (-> self control trans) (-> self attack-info intersection))
                       1.0
                       )
                     )
               )
           (set! (-> a2-3 y) 0.0)
           (let ((gp-1 (vector-reflect-flat! (new 'stack-no-clear 'vector) s5-1 a2-3))
                 (f30-0 (vector-xz-length s5-1))
                 )
             (set! (-> gp-1 y) 0.0)
             (vector-normalize! gp-1 1.0)
             (vector-normalize-copy! (-> self control transv) gp-1 (* 2.0 f30-0))
             (let ((f28-0 (deg-diff (-> self racer rot y) (vector-y-angle gp-1))))
               (if (< 16384.0 (fabs f28-0))
                   (set! f28-0 (deg-diff (-> self racer rot y) (+ 32768.0 (vector-y-angle gp-1))))
                   )
               (set! (-> self racer rotv y) (* f28-0 (lerp-scale 4.0 7.0 f30-0 4096.0 (-> self racer transv-max))))
               )
             )
           )
         )
       )
      (else
        (set! (-> self post-hook) target-racing-post)
        (ja-channel-push! 1 (seconds 0.05))
        (ja-no-eval :group! (-> self draw art-group data 136) :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!))
          )
        )
      )
    (go target-racing)
    (none)
    )
  :post target-no-stick-post
  )

(defstate target-racing-death (target)
  :event (-> target-death event)
  :exit (behavior ()
    (logclear! (-> self state-flags) (state-flags dying))
    (send-event (ppointer->process (-> self manipy)) 'draw #t)
    (send-event (ppointer->process (-> self manipy)) 'anim-mode 'clone-anim)
    (target-timed-invulnerable-off self)
    (set! (-> self control pat-ignore-mask) (new 'static 'pat-surface :noentity #x1))
    (restore-collide-with-as (-> self control))
    ((-> target-racing-start exit))
    (target-exit)
    (set! (-> self racer stick-off) #f)
    (none)
    )
  :code (behavior ((arg0 symbol))
    (local-vars (v1-154 symbol))
    (set! (-> self racer stick-off) #t)
    (set! (-> self neck flex-blend) 0.0)
    (target-timed-invulnerable-off self)
    (logior! (-> self state-flags) (state-flags dying))
    (case (-> self attack-info mode)
      (('explode 'darkeco 'heat 'death 'deadly 'balloonlurker)
       ((-> target-racing-start exit))
       (send-event (ppointer->process (-> self manipy)) 'anim-mode 'loop)
       (send-event (ppointer->process (-> self manipy)) 'draw #f)
       (sound-play "zoomer-explode")
       (process-spawn
         part-tracker
         :init part-tracker-init
         (-> *part-group-id-table* 116)
         -1
         #f
         #f
         #f
         (-> self control trans)
         :to *entity-pool*
         )
       (send-event
         (ppointer->process (-> self manipy))
         'eval
         (lambda :behavior racer
           ()
           (let ((s5-0 (-> self parent-override))
                 (gp-0 (new 'stack 'joint-exploder-tuning 1))
                 )
             (let* ((f0-0 (vector-length (-> s5-0 0 control transv)))
                    (f30-0 (fmin 1.0 (* 0.000008138021 f0-0)))
                    )
               (set! (-> gp-0 duration) (seconds 5))
               (set! (-> gp-0 fountain-rand-transv-hi x) (fmax 24576.0 f0-0))
               (set! (-> gp-0 fountain-rand-transv-hi y) (+ 81920.0 f0-0))
               (set! (-> gp-0 fountain-rand-transv-hi z) 20480.0)
               (set! (-> gp-0 fountain-rand-transv-hi w) 36864.0)
               (vector-negate! (-> gp-0 fountain-rand-transv-lo) (-> s5-0 0 control transv))
               (vector-normalize! (-> gp-0 fountain-rand-transv-lo) (* 12288.0 f30-0))
               )
             (vector+! (-> gp-0 fountain-rand-transv-lo) (-> gp-0 fountain-rand-transv-lo) (-> s5-0 0 control trans))
             (process-spawn
               joint-exploder
               *racer-explode-sg*
               24
               gp-0
               (new 'static 'joint-exploder-static-params
                 :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
                   (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index -1)
                   (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
                   (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
                   (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
                   (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
                   (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
                   (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
                   (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
                   (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
                   (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
                   (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
                   (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
                   (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
                   (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
                   (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index -1)
                   (new 'static 'joint-exploder-static-joint-params :joint-index 18 :parent-joint-index -1)
                   )
                 )
               :to self
               )
             )
           )
         )
       (ja-channel-push! 1 (seconds 0.1))
       (fmax -182044.44 (fmin 182044.44 (* -40.0 (-> self racer rot z))))
       (case (-> self attack-info mode)
         (('balloonlurker)
          (dummy-13 (-> self water) 2.0 (-> self control trans) 1 (-> self control transv))
          (ja-no-eval :group! (-> self draw art-group data 139) :num! (seek! (ja-aframe 240.0 0)) :frame-num 0.0)
          (until (ja-done? 0)
            (set! (-> self racer stick-lock) #t)
            (seek! (-> self control unknown-vector11 y) 6144.0 (* 12288.0 (-> *display* seconds-per-frame)))
            (send-event *camera* 'joystick 0.0 1.0)
            (suspend)
            (ja :num! (seek! (ja-aframe 240.0 0)))
            )
          )
         (else
           (ja-no-eval :group! (-> self draw art-group data 139) :num! (seek!) :frame-num 0.0)
           (until (ja-done? 0)
             (set! (-> self racer stick-lock) #t)
             (send-event *camera* 'joystick 0.0 1.0)
             (seek! (-> self control unknown-vector11 y) 6144.0 (* 12288.0 (-> *display* seconds-per-frame)))
             (if (>= (ja-aframe-num 0) 245.0)
                 (set-forward-vel (* 0.5 (-> self control unknown-float01)))
                 )
             (suspend)
             (ja :num! (seek!))
             )
           )
         )
       )
      (('melt)
       (sound-play "zoomer-melt")
       (process-spawn
         part-tracker
         :init part-tracker-init
         (-> *part-group-id-table* 32)
         -1
         #f
         #f
         #f
         (-> self control trans)
         :to *entity-pool*
         )
       (clear-collide-with-as (-> self control))
       (set! (-> self post-hook) target-no-ja-move-post)
       (ja-channel-set! 0)
       (ja-post)
       (let ((gp-6 (-> *display* base-frame-counter)))
         (until (>= (- (-> *display* base-frame-counter) gp-6) (seconds 2))
           (suspend)
           )
         )
       )
      (('endlessfall)
       (sound-play "death-fall")
       (camera-change-to (the-as string cam-endlessfall) 30 #f)
       (set! (-> self control pat-ignore-mask unknown-bit) 1)
       (let ((f30-0 (fmin -4096.0 (- (-> self control ground-impact-vel)))))
         (let ((gp-8 (new-stack-vector0)))
           (let ((f0-28 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
             0.0
             (vector-! gp-8 (-> self control transv) (vector-float*! gp-8 (-> self control dynam gravity-normal) f0-28))
             )
           (let* ((f0-29 (vector-length gp-8))
                  (f1-9 f0-29)
                  (f2-2 f30-0)
                  )
             (vector+!
               (-> self control transv)
               (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-2)
               (vector-float*! gp-8 gp-8 (/ f0-29 f1-9))
               )
             )
           )
         (let ((gp-9 (-> *display* base-frame-counter)))
           (until (>= (- (-> *display* base-frame-counter) gp-9) (seconds 0.75))
             (vector-seek! (-> self draw color-mult) *zero-vector* (* 1.5 (-> *display* seconds-per-frame)))
             (set-forward-vel (* 0.96 (-> self control unknown-float01)))
             (let ((s5-3 (new-stack-vector0))
                   (f28-0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                   )
               0.0
               (vector-! s5-3 (-> self control transv) (vector-float*! s5-3 (-> self control dynam gravity-normal) f28-0))
               (let* ((f0-38 (vector-length s5-3))
                      (f1-12 f0-38)
                      )
                 (if (< f30-0 f28-0)
                     (set! f28-0 f30-0)
                     )
                 (vector+!
                   (-> self control transv)
                   (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f28-0)
                   (vector-float*! s5-3 s5-3 (/ f0-38 f1-12))
                   )
                 )
               )
             (suspend)
             )
           )
         )
       (camera-change-to (the-as string 'base) 0 #f)
       )
      )
    (set! (-> self control transv quad) (the-as uint128 0))
    (set! (-> self control unknown-float01) 0.0)
    (set! (-> self post-hook) target-no-stick-post)
    (initialize! (-> self game) 'dead (the-as game-save #f) (the-as string #f))
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (until v1-154
      (suspend)
      (set! v1-154 (and (>= (- (-> *display* base-frame-counter) (-> self state-time)) (seconds 1))
                        (zero? (logand (-> *kernel-context* prevent-from-run) (process-mask movie)))
                        )
            )
      )
    (go target-stance)
    (none)
    )
  :post target-racing-post
  )

(defstate target-racing-get-on (target)
  :event target-generic-event-handler
  :exit (-> target-racing-start exit)
  :code (behavior ((arg0 handle))
    (set! (-> self control transv quad) (the-as uint128 0))
    (set! (-> self alt-cam-pos quad) (-> (&-> (-> self control) unknown-qword00) 0))
    (logior! (-> self state-flags) (state-flags use-alt-cam-pos))
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (set! (-> gp-0 quad) (-> self control trans quad))
      (let ((s5-0 (new 'stack-no-clear 'vector)))
        (set! (-> s5-0 quad) (-> self control trans quad))
        (quaternion-copy! (-> self control unknown-quaternion02) (-> self control quat))
        (quaternion-copy! (-> self control unknown-quaternion03) (-> self control unknown-quaternion00))
        (set! (-> self control unknown-uint20) (the-as uint (-> self control unknown-vector11 y)))
        (let* ((s3-0 (handle->process arg0))
               (s4-1 (if (and (nonzero? s3-0) (type-type? (-> s3-0 type) process-drawable))
                         (the-as racer s3-0)
                         )
                     )
               )
          (when s4-1
            (set! (-> s5-0 quad) (-> s4-1 root-override trans quad))
            (quaternion-copy! (-> self control unknown-quaternion03) (-> s4-1 root-override quat))
            (send-event s4-1 'trans (-> self racer bike-trans))
            (quaternion-copy! (the-as quaternion (-> self racer bike-quat)) (-> s4-1 root-override quat))
            (set! (-> self racer bike-scale quad) (-> s4-1 root-override scale quad))
            (set! (-> self control unknown-int21) (the-as int (-> self racer bike-trans y)))
            )
          )
        (set! (-> self control unknown-vector102 quad) (-> gp-0 quad))
        (set! (-> self control unknown-vector103 quad) (-> s5-0 quad))
        )
      )
    (let ((s5-1 #f)
          (gp-1 #f)
          )
      (ja-channel-push! 1 (seconds 0.05))
      (ja-no-eval :group! (-> self draw art-group data 138) :num! (seek! (ja-aframe 77.0 0)) :frame-num 0.0)
      (until (ja-done? 0)
        (when (and (not s5-1) (= (-> self skel root-channel 0) (-> self skel channel)))
          (send-event (ppointer->process (-> self manipy)) 'anim-mode 'clone-anim)
          (set! s5-1 #t)
          )
        (set! (-> self control transv quad) (the-as uint128 0))
        (when (< 50.0 (ja-aframe-num 0))
          (when (not gp-1)
            (sound-play "zoomer-start")
            (set! gp-1 #t)
            )
          (set! (-> self racer front-rotv) 65536.0)
          (set! (-> self racer front-rot)
                (the float
                     (sar
                       (shl
                         (the int (+ (-> self racer front-rot) (* (-> self racer front-rotv) (-> *display* seconds-per-frame))))
                         48
                         )
                       48
                       )
                     )
                )
          (+! (-> self racer bottom-rot) (* 364088.88 (-> *display* seconds-per-frame)))
          (set-twist! (-> self racer front-blade) (the-as float #f) (- (-> self racer front-rot)) (the-as float #f))
          (set-twist! (-> self racer bottom-blade) (the-as float #f) (the-as float #f) (- (-> self racer bottom-rot)))
          )
        (suspend)
        (ja :num! (seek! (ja-aframe 77.0 0)))
        )
      )
    (logclear! (-> self state-flags) (state-flags use-alt-cam-pos))
    (send-event *camera* 'set-slave-option #x6000)
    (set! (-> self control transv quad) (the-as uint128 0))
    (quaternion-copy! (-> self control quat) (-> self control unknown-quaternion00))
    (rot->dir-targ! (-> self control))
    (set! (-> self racer rot y) (y-angle (-> self control)))
    (when *target*
      (when (or (= (-> *target* current-level name) 'lavatube)
                (= (-> *target* current-level name) 'firecanyon)
                (= (-> *target* current-level name) 'citadel)
                )
        (set! (-> *hud-parts* bike-heat) (process-spawn hud-bike-heat :init hud-init-by-other 0 :to self))
        (set! (-> *hud-parts* buzzers 0 next-y-offset) -120)
        (set! (-> *hud-parts* buzzers 0 y-sgn) 0)
        0
        )
      (set! (-> *hud-parts* bike-speed) (process-spawn hud-bike-speed :init hud-init-by-other 0 :to self))
      (set! (-> *hud-parts* power 0 next-y-offset) -120)
      (set! (-> *hud-parts* power 0 y-sgn) 0)
      0
      )
    (go target-racing)
    (none)
    )
  :post (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'vector))
          (f30-0 (fmin 1.0 (* 0.0044444446 (the float (- (-> *display* base-frame-counter) (-> self state-time))))))
          )
      (vector-lerp! gp-0 (-> self control unknown-vector102) (-> self control unknown-vector103) f30-0)
      (set! (-> gp-0 y)
            (lerp
              (-> self control unknown-vector102 y)
              (-> self control unknown-vector103 y)
              (fmax
                0.0
                (fmin
                  1.0
                  (* 0.0044444446 (the float (+ (- (seconds -0.5) (-> self state-time)) (-> *display* base-frame-counter))))
                  )
                )
              )
            )
      (move-to-point! (-> self control) gp-0)
      (quaternion-slerp!
        (-> self control unknown-quaternion00)
        (-> self control unknown-quaternion02)
        (-> self control unknown-quaternion03)
        f30-0
        )
      )
    (let ((f30-1
            (fmax
              0.0
              (fmin 1.0 (* 0.010528533 (+ -279.99 (the float (- (-> *display* base-frame-counter) (-> self state-time))))))
              )
            )
          )
      (set! (-> self control unknown-vector11 y)
            (lerp (the-as float (-> self control unknown-uint20)) (-> self racer cushion-base) f30-1)
            )
      (set! (-> self racer bike-trans y) (lerp
                                           (the-as float (-> self control unknown-uint30))
                                           (+ 4096.0 (the-as float (-> self control unknown-uint30)))
                                           f30-1
                                           )
            )
      )
    (hide-hud-quick)
    (target-no-move-post)
    (none)
    )
  )

(defstate target-racing-get-off (target)
  :event target-generic-event-handler
  :exit (-> target-racing-start exit)
  :code (behavior ((arg0 handle))
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (set! (-> self control unknown-surface00) *racer-mods*)
    (let ((a0-2 (-> *hud-parts* bike-speed)))
      (if a0-2
          (set! (-> a0-2 0 deactivate-when-hidden) #t)
          )
      )
    (let ((a0-4 (-> *hud-parts* bike-heat)))
      (if a0-4
          (set! (-> a0-4 0 deactivate-when-hidden) #t)
          )
      )
    (when (not (ja-group? (-> self draw art-group data 123)))
      (ja-channel-push! 4 (seconds 0.1))
      (ja :group! (-> self draw art-group data 123) :num! (identity (ja-aframe (-> self racer turn-anim-frame) 0)))
      (ja :chan 1 :group! (-> self draw art-group data 124) :num! (chan 0))
      (ja :chan 2 :group! (-> self draw art-group data 125) :num! (chan 0))
      (ja :chan 3 :group! (-> self draw art-group data 126) :num! (chan 0))
      )
    (let ((s5-1 (-> *display* base-frame-counter)))
      (until (>= (- (-> *display* base-frame-counter) s5-1) (seconds 0.5))
        (set! (-> self racer stick-lock) #t)
        (set-forward-vel (* 0.9 (-> self control unknown-float01)))
        (set! (-> self racer turn-anim-targ) 0.0)
        (set! (-> self racer turn-anim-targ) 0.0)
        (target-racing-turn-anim)
        (seek! (-> self control unknown-vector11 y) 6144.0 (* 3.0 (-> *display* seconds-per-frame)))
        (suspend)
        )
      )
    (go target-racing-get-off-jump arg0)
    (none)
    )
  :post target-racing-post
  )

(defstate target-racing-get-off-jump (target)
  :event target-generic-event-handler
  :exit (-> target-racing-start exit)
  :code (behavior ((arg0 handle))
    (sound-play "zoomer-stop")
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (set! (-> self control transv quad) (the-as uint128 0))
    (let ((gp-1 (new 'stack-no-clear 'vector)))
      (set! (-> gp-1 quad) (-> self control trans quad))
      (let ((s4-1 (new 'stack-no-clear 'vector)))
        (set! (-> s4-1 quad) (-> self control trans quad))
        (quaternion-copy! (-> self control unknown-quaternion02) (-> self control quat))
        (quaternion-copy! (-> self control unknown-quaternion03) (-> self control unknown-quaternion00))
        (set! (-> self control unknown-uint20) (the-as uint (-> self control unknown-vector11 y)))
        (let* ((s2-0 (handle->process arg0))
               (s3-0 (if (and (nonzero? s2-0) (type-type? (-> s2-0 type) process-drawable))
                         (the-as racer s2-0)
                         )
                     )
               )
          (when s3-0
            (set! (-> s4-1 quad) (-> s3-0 root-override trans quad))
            (set-yaw-angle-clear-roll-pitch! (-> s3-0 root-override) (quaternion-y-angle (-> self control quat)))
            (quaternion-copy! (-> self control unknown-quaternion03) (-> s3-0 root-override quat))
            (send-event s3-0 'trans (-> self racer bike-trans))
            (quaternion-copy! (the-as quaternion (-> self racer bike-quat)) (-> s3-0 root-override quat))
            (set! (-> self racer bike-scale quad) (-> s3-0 root-override scale quad))
            (set! (-> self control unknown-int21) (the-as int (-> self racer bike-trans y)))
            )
          )
        (set! (-> self control unknown-vector102 quad) (-> gp-1 quad))
        (set! (-> self control unknown-vector103 quad) (-> s4-1 quad))
        )
      (ja-channel-push! 1 (seconds 0.05))
      (ja-no-eval :group! (-> self draw art-group data 137) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      (send-event (handle->process arg0) 'draw)
      (set-yaw-angle-clear-roll-pitch!
        (-> self control)
        (quaternion-y-angle (-> self control unknown-quaternion03))
        )
      (rot->dir-targ! (-> self control))
      (ja-post)
      (vector<-cspace! gp-1 (-> self node-list data 3))
      (set! (-> gp-1 y) (+ -5896.192 (-> gp-1 y)))
      (move-to-point! (-> self control) gp-1)
      )
    (send-event *camera* 'ease-in)
    (ja-channel-set! 0)
    (go target-racing-get-off-hit-ground #f)
    (none)
    )
  :post (behavior ()
    (let* ((f0-2 (deg-diff (-> self racer front-rot) (-> *RACER-bank* default-front-blade)))
           (f0-5 (if (< 0.0 f0-2)
                     (fmax 5461.3335 (* 4.0 f0-2))
                     54613.332
                     )
                 )
           )
      (seek! (-> self racer front-rotv) f0-5 (* 54613.332 (-> *display* seconds-per-frame)))
      )
    (set! (-> self racer front-rot)
          (the float
               (sar
                 (shl
                   (the int (+ (-> self racer front-rot) (* (-> self racer front-rotv) (-> *display* seconds-per-frame))))
                   48
                   )
                 48
                 )
               )
          )
    (when (and (< (fabs (deg-diff (-> *RACER-bank* default-front-blade) (-> self racer front-rot))) 1820.4445)
               (= (-> self racer front-rotv) 5461.3335)
               )
      (set! (-> self racer front-rotv) 0.0)
      (set! (-> self racer front-rot) (-> *RACER-bank* default-front-blade))
      )
    (+! (-> self racer bottom-rot) (* 364088.88 (-> *display* seconds-per-frame)))
    (set-twist! (-> self racer front-blade) (the-as float #f) (- (-> self racer front-rot)) (the-as float #f))
    (set-twist! (-> self racer bottom-blade) (the-as float #f) (the-as float #f) (- (-> self racer bottom-rot)))
    (let ((gp-0 (new 'stack-no-clear 'vector))
          (f30-0
            (fmax
              0.0
              (fmin 1.0 (* 0.004761905 (+ -150.0 (the float (- (-> *display* base-frame-counter) (-> self state-time))))))
              )
            )
          )
      (fmax
        0.0
        (fmin 1.0 (* 0.006666667 (+ -225.0 (the float (- (-> *display* base-frame-counter) (-> self state-time))))))
        )
      (vector-lerp! gp-0 (-> self control unknown-vector102) (-> self control unknown-vector103) f30-0)
      (set! (-> gp-0 y)
            (lerp
              (-> self control unknown-vector102 y)
              (-> self control unknown-vector103 y)
              (fmax
                0.0
                (fmin
                  1.0
                  (* 0.0044444446 (the float (+ (- (seconds -0.5) (-> self state-time)) (-> *display* base-frame-counter))))
                  )
                )
              )
            )
      (move-to-point! (-> self control) gp-0)
      (quaternion-slerp!
        (-> self control unknown-quaternion00)
        (-> self control unknown-quaternion02)
        (-> self control unknown-quaternion03)
        f30-0
        )
      (set! (-> self control unknown-vector11 y)
            (lerp (the-as float (-> self control unknown-uint20)) 6144.0 (fmin 1.0 (* 2.0 f30-0)))
            )
      )
    (vector+! (-> self racer bike-trans) (-> self control trans) (-> self control unknown-vector12))
    (quaternion-copy! (the-as quaternion (-> self racer bike-quat)) (-> self control quat))
    (set! (-> self racer bike-scale quad) (-> self control scale quad))
    (hide-hud)
    (target-no-move-post)
    (none)
    )
  )

(defstate target-racing-get-off-hit-ground (target)
  :event target-standard-event-handler
  :enter (-> target-hit-ground enter)
  :trans (behavior ()
    (logior! (-> self control status) (cshape-moving-flags onsurf onground tsurf))
    ((-> target-hit-ground trans))
    (none)
    )
  :code (behavior ((arg0 symbol))
    (ja-channel-set! 1)
    (ja-no-eval :group! (-> self draw art-group data 35) :num! (seek!) :frame-num (ja-aframe 42.0 0))
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go target-stance)
    (none)
    )
  :post (behavior ()
    (hide-hud)
    (target-post)
    (none)
    )
  )

(defstate target-racing-grab (target)
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (cond
      ((and (= arg2 'query) (= (-> arg3 param 0) 'mode))
       (-> self state name)
       )
      (else
        (case arg2
          (('end-mode)
           (go target-racing)
           )
          (('clone-anim)
           (go target-racing-clone-anim (process->handle (the-as process (-> arg3 param 0))))
           )
          (else
            (target-generic-event-handler arg0 arg1 arg2 arg3)
            )
          )
        )
      )
    )
  :enter (behavior ()
    (set! (-> self control unknown-surface00) *grab-mods*)
    (set! (-> self neck flex-blend) 0.0)
    (logior! (-> self state-flags) (state-flags invulnerable grabbed))
    (set! (-> self racer stick-off) #t)
    (none)
    )
  :exit (behavior ()
    (set! (-> self racer stick-off) #f)
    (logclear! (-> self state-flags) (state-flags invulnerable grabbed))
    (logclear! (-> self water flags) (water-flags wt16))
    ((-> target-racing-start exit))
    (none)
    )
  :code (behavior ()
    (when (not (ja-group? (-> self draw art-group data 123)))
      (ja-channel-push! 4 (seconds 0.1))
      (ja :group! (-> self draw art-group data 123) :num! (identity (ja-aframe (-> self racer turn-anim-frame) 0)))
      (ja :chan 1 :group! (-> self draw art-group data 124) :num! (chan 0))
      (ja :chan 2 :group! (-> self draw art-group data 125) :num! (chan 0))
      (ja :chan 3 :group! (-> self draw art-group data 126) :num! (chan 0))
      )
    (loop
      (target-racing-turn-anim)
      (set-forward-vel 0.0)
      (suspend)
      )
    (none)
    )
  :post target-racing-post
  )

(defstate target-racing-clone-anim (target)
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (if (and (= arg2 'trans) (= (-> arg3 param 0) 'restore))
        (set! (-> self control unknown-uint20) (the-as uint #f))
        )
    ((-> target-racing-grab event) arg0 arg1 arg2 arg3)
    )
  :enter (-> target-clone-anim enter)
  :exit (behavior ()
    (set! (-> self control unknown-vector11 y) (the-as float (-> self control unknown-uint20)))
    (set! (-> self control unknown-vector12 y) (-> self control unknown-vector11 y))
    (send-event (ppointer->process (-> self sidekick)) 'matrix #f)
    ((-> target-clone-anim exit))
    ((-> target-racing-start exit))
    (vector-reset! (-> self control transv))
    (none)
    )
  :code (behavior ((arg0 handle))
    (set! (-> self control unknown-uint20) (the-as uint (-> self control unknown-vector11 y)))
    (set! (-> self control unknown-vector11 y) 0.0)
    (send-event (ppointer->process (-> self sidekick)) 'matrix 'play-anim)
    (clone-anim arg0 33 #t "")
    (go target-racing)
    (none)
    )
  :post (behavior ()
    (racer-sounds)
    (seek! (-> self racer heat) 0.0 (* (-> *RACER-bank* surface-heat-inc) (-> *display* seconds-per-frame)))
    (vector+! (-> self racer bike-trans) (-> self control trans) (-> self control unknown-vector12))
    (quaternion-copy! (the-as quaternion (-> self racer bike-quat)) (-> self control quat))
    (set! (-> self racer bike-scale quad) (-> self control scale quad))
    (target-no-ja-move-post)
    (none)
    )
  )




