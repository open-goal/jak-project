;;-*-Lisp-*-
(in-package goal)

;; name: citadel-obs.gc
;; name in dgo: citadel-obs
;; dgos: CIT, L1

;; DECOMP BEGINS

(deftype citb-arm-section (process-drawable)
  ((sync           sync-info :inline :offset-assert 176)
   (cull-dir-local vector    :inline :offset-assert 192)
   (cull-dot       float             :offset-assert 208)
   (rot-scale      float             :offset-assert 212)
   (y-angle        float             :offset-assert 216)
   )
  :heap-base #x70
  :method-count-assert 23
  :size-assert         #xdc
  :flag-assert         #x17007000dc
  (:methods
    (init-root! (_type_) none 20)
    (setup-new-process! (_type_) none 21)
    (idle () _type_ :state 22)
    )
  )


(defskelgroup *citb-arm-a-sg* citb-arm
  0
  3
  ((1 (meters 20)) (2 (meters 999999)))
  :bounds (static-spherem 0 0 0 14)
  :longest-edge (meters 9)
  )

(defskelgroup *citb-arm-b-sg* citb-arm
  4
  7
  ((5 (meters 20)) (6 (meters 999999)))
  :bounds (static-spherem 0 0 0 20)
  :longest-edge (meters 10)
  )

(defskelgroup *citb-arm-c-sg* citb-arm
  8
  11
  ((9 (meters 20)) (10 (meters 999999)))
  :bounds (static-spherem 0 0 0 25)
  :longest-edge (meters 11)
  )

(defskelgroup *citb-arm-d-sg* citb-arm
  12
  15
  ((13 (meters 20)) (14 (meters 999999)))
  :bounds (static-spherem 0 0 0 29)
  :longest-edge (meters 8)
  )

(defskelgroup *citb-arm-shoulder-a-sg* citb-arm-shoulder
  0
  2
  ((1 (meters 999999)))
  :bounds (static-spherem 0 0 0 22)
  :longest-edge (meters 10)
  )

(defskelgroup *citb-arm-shoulder-b-sg* citb-arm-shoulder
  3
  5
  ((4 (meters 999999)))
  :bounds (static-spherem 0 0 0 22)
  :longest-edge (meters 10)
  )

(defstate idle (citb-arm-section)
  :virtual #t
  :code
  (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'vector))
          (s5-0 (new 'stack-no-clear 'vector))
          )
      (while #t
        (cond
          ((< (- (-> (target-pos 0) y) (-> self root trans y)) -122880.0)
           (set! (-> self draw force-lod) 1)
           )
          (else
            (set! (-> self draw force-lod) 0)
            0
            )
          )
        (set! (-> self y-angle) (* 65536.0 (get-current-phase (-> self sync)) (-> self rot-scale)))
        (quaternion-axis-angle! (-> self root quat) 0.0 1.0 0.0 (-> self y-angle))
        (vector-orient-by-quat! gp-0 (-> self cull-dir-local) (-> self root quat))
        (vector-! s5-0 (-> self root trans) (camera-pos))
        (set! (-> gp-0 y) 0.0)
        (set! (-> s5-0 y) 0.0)
        (vector-normalize! gp-0 1.0)
        (vector-normalize! s5-0 1.0)
        (if (>= (vector-dot gp-0 s5-0) (-> self cull-dot))
            (logior! (-> self draw status) (draw-status drwf01))
            (logclear! (-> self draw status) (draw-status drwf01))
            )
        (suspend)
        )
      )
    (none)
    )
  :post
  (the-as (function none :behavior citb-arm-section) ja-post)
  )

(defmethod init-root! citb-arm-section ((obj citb-arm-section))
  (set! (-> obj root) (new 'process 'trsqv))
  0
  (none)
  )

(defmethod setup-new-process! citb-arm-section ((obj citb-arm-section))
  (logclear! (-> obj mask) (process-mask actor-pause))
  (load-params! (-> obj sync) obj (the-as uint 3000) 0.0 0.15 0.15)
  (cond
    ((> (-> obj sync period) 0)
     (set! (-> obj rot-scale) 1.0)
     )
    (else
      (set! (-> obj rot-scale) -1.0)
      (let ((v1-6 (abs (the-as int (-> obj sync period)))))
        (set! (-> obj sync period) (the-as uint v1-6))
        )
      )
    )
  (logior! (-> obj skel status) 1)
  (set-vector! (-> obj cull-dir-local) 0.0 0.0 -1.0 1.0)
  (set! (-> obj cull-dot) (cos 5461.3335))
  0
  (none)
  )

(defmethod init-from-entity! citb-arm-section ((obj citb-arm-section) (arg0 entity-actor))
  (init-root! obj)
  (process-drawable-from-entity! obj arg0)
  (setup-new-process! obj)
  (go (method-of-object obj idle))
  (none)
  )

(deftype citb-arm (citb-arm-section)
  ((root-override collide-shape-moving  :offset 112)
   )
  :heap-base #x70
  :method-count-assert 23
  :size-assert         #xdc
  :flag-assert         #x17007000dc
  )


(defstate idle (citb-arm)
  :virtual #t
  :trans
  (the-as (function none :behavior citb-arm) rider-trans)
  :post
  (behavior ()
    (if (logtest? (-> self draw status) (draw-status drwf01))
        (clear-collide-with-as (-> self root-override))
        (restore-collide-with-as (-> self root-override))
        )
    (rider-post)
    (none)
    )
  )

(defmethod init-root! citb-arm ((obj citb-arm))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-others))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s5-0 1)
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid ca-1))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 40960.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

(defmethod setup-new-process! citb-arm ((obj citb-arm))
  ((the-as (function citb-arm-section none) (find-parent-method citb-arm 21)) obj)
  (set! (-> obj draw origin-joint-index) (the-as uint 4))
  (set-vector! (-> obj cull-dir-local) 0.0 0.0 -1.0 1.0)
  (set! (-> obj cull-dot) (cos 5461.3335))
  0
  (none)
  )

(deftype citb-arm-shoulder (citb-arm-section)
  ()
  :heap-base #x70
  :method-count-assert 23
  :size-assert         #xdc
  :flag-assert         #x17007000dc
  )


(defmethod setup-new-process! citb-arm-shoulder ((obj citb-arm-shoulder))
  ((the-as (function citb-arm-section none) (find-parent-method citb-arm-shoulder 21)) obj)
  (set! (-> obj draw origin-joint-index) (the-as uint 4))
  (set-vector! (-> obj cull-dir-local) 1.0 0.0 1.0 1.0)
  (set! (-> obj cull-dot) (cos 8374.045))
  0
  (none)
  )

(deftype citb-arm-a (citb-arm)
  ()
  :heap-base #x70
  :method-count-assert 23
  :size-assert         #xdc
  :flag-assert         #x17007000dc
  )


(deftype citb-arm-b (citb-arm)
  ()
  :heap-base #x70
  :method-count-assert 23
  :size-assert         #xdc
  :flag-assert         #x17007000dc
  )


(deftype citb-arm-c (citb-arm)
  ()
  :heap-base #x70
  :method-count-assert 23
  :size-assert         #xdc
  :flag-assert         #x17007000dc
  )


(deftype citb-arm-d (citb-arm)
  ()
  :heap-base #x70
  :method-count-assert 23
  :size-assert         #xdc
  :flag-assert         #x17007000dc
  )


(deftype citb-arm-shoulder-a (citb-arm-shoulder)
  ()
  :heap-base #x70
  :method-count-assert 23
  :size-assert         #xdc
  :flag-assert         #x17007000dc
  )


(deftype citb-arm-shoulder-b (citb-arm-shoulder)
  ()
  :heap-base #x70
  :method-count-assert 23
  :size-assert         #xdc
  :flag-assert         #x17007000dc
  )


(defmethod setup-new-process! citb-arm-a ((obj citb-arm-a))
  (initialize-skeleton obj *citb-arm-a-sg* '())
  ((the-as (function citb-arm none) (find-parent-method citb-arm-a 21)) obj)
  (set! (-> obj root-override root-prim local-sphere z) -184320.0)
  0
  (none)
  )

(defmethod setup-new-process! citb-arm-b ((obj citb-arm-b))
  (initialize-skeleton obj *citb-arm-b-sg* '())
  ((the-as (function citb-arm none) (find-parent-method citb-arm-b 21)) obj)
  (set! (-> obj root-override root-prim local-sphere z) -225280.0)
  0
  (none)
  )

(defmethod setup-new-process! citb-arm-c ((obj citb-arm-c))
  (initialize-skeleton obj *citb-arm-c-sg* '())
  ((the-as (function citb-arm none) (find-parent-method citb-arm-c 21)) obj)
  (set! (-> obj root-override root-prim local-sphere z) -266240.0)
  0
  (none)
  )

(defmethod setup-new-process! citb-arm-d ((obj citb-arm-d))
  (initialize-skeleton obj *citb-arm-d-sg* '())
  ((the-as (function citb-arm none) (find-parent-method citb-arm-d 21)) obj)
  (set! (-> obj root-override root-prim local-sphere z) -307200.0)
  0
  (none)
  )

(defmethod setup-new-process! citb-arm-shoulder-a ((obj citb-arm-shoulder-a))
  (initialize-skeleton obj *citb-arm-shoulder-a-sg* '())
  ((the-as (function citb-arm none) (find-parent-method citb-arm-shoulder-a 21)) (the-as citb-arm obj))
  0
  (none)
  )

(defmethod setup-new-process! citb-arm-shoulder-b ((obj citb-arm-shoulder-b))
  (initialize-skeleton obj *citb-arm-shoulder-b-sg* '())
  ((the-as (function citb-arm none) (find-parent-method citb-arm-shoulder-b 21)) (the-as citb-arm obj))
  0
  (none)
  )

(defskelgroup *citb-disc-a-sg* citb-disc
  0
  4
  ((1 (meters 20)) (2 (meters 40)) (3 (meters 999999)))
  :bounds (static-spherem 0 0 0 12)
  :longest-edge (meters 7.5)
  )

(defskelgroup *citb-disc-b-sg* citb-disc
  5
  9
  ((6 (meters 20)) (7 (meters 40)) (8 (meters 999999)))
  :bounds (static-spherem 0 0 0 12)
  :longest-edge (meters 7.5)
  )

(defskelgroup *citb-disc-c-sg* citb-disc
  10
  14
  ((11 (meters 20)) (12 (meters 40)) (13 (meters 999999)))
  :bounds (static-spherem 0 0 0 12)
  :longest-edge (meters 11)
  )

(defskelgroup *citb-disc-d-sg* citb-disc
  15
  19
  ((16 (meters 20)) (17 (meters 40)) (18 (meters 999999)))
  :bounds (static-spherem 0 0 0 12)
  :longest-edge (meters 8)
  )

(deftype citb-disc (process-drawable)
  ((root-override collide-shape-moving         :offset        112)
   (sync          sync-info            :inline :offset-assert 176)
   (rot-scale     float                        :offset-assert 184)
   )
  :heap-base #x50
  :method-count-assert 22
  :size-assert         #xbc
  :flag-assert         #x16005000bc
  (:methods
    (init! (_type_) none 20)
    (dummy-21 (_type_) none 21)
    )
  (:states
    citb-disc-idle
    )
  )


(defstate citb-disc-idle (citb-disc)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (let ((v1-0 arg2))
      (the-as object (when (= v1-0 'touch)
                       (send-event arg0 'no-look-around 75)
                       #f
                       )
              )
      )
    )
  :trans
  (the-as (function none :behavior citb-disc) rider-trans)
  :code
  (behavior ()
    (while #t
      (update! (-> self sound))
      (quaternion-axis-angle!
        (-> self root-override quat)
        0.0
        1.0
        0.0
        (* 65536.0 (get-current-phase (-> self sync)) (-> self rot-scale))
        )
      (suspend)
      )
    (none)
    )
  :post
  (the-as (function none :behavior citb-disc) rider-post)
  )

(defmethod init! citb-disc ((obj citb-disc))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-others))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s5-0 1)
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid ca-1 ca-4))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 49152.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

(defmethod dummy-21 citb-disc ((obj citb-disc))
  0
  (none)
  )

(defmethod init-from-entity! citb-disc ((obj citb-disc) (arg0 entity-actor))
  (init! obj)
  (process-drawable-from-entity! obj arg0)
  (logclear! (-> obj mask) (process-mask actor-pause))
  (load-params! (-> obj sync) obj (the-as uint 3000) 0.0 0.15 0.15)
  (cond
    ((> (-> obj sync period) 0)
     (set! (-> obj rot-scale) 1.0)
     )
    (else
      (set! (-> obj rot-scale) -1.0)
      (let ((v1-8 (abs (the-as int (-> obj sync period)))))
        (set! (-> obj sync period) (the-as uint v1-8))
        )
      )
    )
  (dummy-21 obj)
  (set! (-> obj sound) (new
                         'process
                         'ambient-sound
                         (new 'static 'sound-spec
                           :mask #x80
                           :num 1.0
                           :group #x1
                           :sound-name (static-sound-name "rotate-plat")
                           :volume #x400
                           :fo-max 20
                           )
                         (-> obj root-override trans)
                         )
        )
  (logior! (-> obj skel status) 1)
  (go citb-disc-idle)
  (none)
  )

(deftype citb-disc-a (citb-disc)
  ()
  :heap-base #x50
  :method-count-assert 22
  :size-assert         #xbc
  :flag-assert         #x16005000bc
  )


(deftype citb-disc-b (citb-disc)
  ()
  :heap-base #x50
  :method-count-assert 22
  :size-assert         #xbc
  :flag-assert         #x16005000bc
  )


(deftype citb-disc-c (citb-disc)
  ()
  :heap-base #x50
  :method-count-assert 22
  :size-assert         #xbc
  :flag-assert         #x16005000bc
  )


(deftype citb-disc-d (citb-disc)
  ()
  :heap-base #x50
  :method-count-assert 22
  :size-assert         #xbc
  :flag-assert         #x16005000bc
  )


(defmethod dummy-21 citb-disc-a ((obj citb-disc-a))
  (initialize-skeleton obj *citb-disc-a-sg* '())
  0
  (none)
  )

(defmethod dummy-21 citb-disc-b ((obj citb-disc-b))
  (initialize-skeleton obj *citb-disc-b-sg* '())
  0
  (none)
  )

(defmethod dummy-21 citb-disc-c ((obj citb-disc-c))
  (initialize-skeleton obj *citb-disc-c-sg* '())
  0
  (none)
  )

(defmethod dummy-21 citb-disc-d ((obj citb-disc-d))
  (initialize-skeleton obj *citb-disc-d-sg* '())
  0
  (none)
  )

(deftype citb-iris-door (eco-door)
  ()
  :heap-base #xa0
  :method-count-assert 27
  :size-assert         #x104
  :flag-assert         #x1b00a00104
  )


(defskelgroup *citb-iris-door-sg* citb-iris-door
  0
  3
  ((1 (meters 20)) (2 (meters 999999)))
  :bounds (static-spherem 0 0 0 8)
  :longest-edge (meters 0)
  )

(defmethod TODO-RENAME-24 citb-iris-door ((obj citb-iris-door))
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-others))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind wall-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 16384.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

(defmethod TODO-RENAME-25 citb-iris-door ((obj citb-iris-door))
  (initialize-skeleton obj *citb-iris-door-sg* '())
  (set! (-> obj open-distance) 32768.0)
  (set! (-> obj close-distance) 49152.0)
  (set! (-> obj auto-close) #t)
  (process-entity-status! obj (entity-perm-status complete) #t)
  (update-transforms! (-> obj root-override))
  0
  (none)
  )

(defskelgroup *citb-button-sg* citb-button
  0
  2
  ((1 (meters 999999)))
  :bounds (static-spherem 0 0 0 3)
  :longest-edge (meters 0)
  )

(deftype citb-button (basebutton)
  ()
  :heap-base #x90
  :method-count-assert 32
  :size-assert         #x100
  :flag-assert         #x2000900100
  )


(defmethod TODO-RENAME-27 citb-button ((obj citb-button))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 12288.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> obj root-override) s5-0)
    )
  (the-as collide-shape-moving 0)
  )

(defmethod TODO-RENAME-26 citb-button ((obj citb-button))
  (initialize-skeleton obj *citb-button-sg* '())
  (logior! (-> obj skel status) 1)
  (ja-channel-set! 1)
  (cond
    ((-> obj down?)
     (let ((s5-0 (-> obj skel root-channel 0)))
       (joint-control-channel-group-eval!
         s5-0
         (the-as art-joint-anim (-> obj draw art-group data 2))
         num-func-identity
         )
       (set! (-> s5-0 frame-num)
             (the float (+ (-> (the-as art-joint-anim (-> obj draw art-group data 2)) data 0 length) -1))
             )
       )
     )
    (else
      (let ((s5-1 (-> obj skel root-channel 0)))
        (joint-control-channel-group-eval!
          s5-1
          (the-as art-joint-anim (-> obj draw art-group data 2))
          num-func-identity
          )
        (set! (-> s5-1 frame-num) 0.0)
        )
      )
    )
  (set! (-> obj anim-speed) 2.0)
  (set! (-> obj timeout) 1.0)
  (update-transforms! (-> obj root-override))
  (ja-post)
  (none)
  )

(deftype citb-launcher (plat)
  ((launcher (pointer launcher)  :offset-assert 264)
   )
  :heap-base #xa0
  :method-count-assert 33
  :size-assert         #x10c
  :flag-assert         #x2100a0010c
  )


(defstate plat-path-active (citb-launcher)
  :virtual #t
  :post
  (behavior ()
    (let ((t9-0 (-> (method-of-type plat plat-path-active) post)))
      (if t9-0
          ((the-as (function none :behavior citb-launcher) t9-0))
          )
      )
    (send-event (ppointer->process (-> self launcher)) 'trans (-> self basetrans))
    (none)
    )
  )

(defskelgroup *citb-launcher-sg* citb-launcher
  0
  2
  ((1 (meters 999999)))
  :bounds (static-spherem 0 0 0 4)
  :longest-edge (meters 0)
  )

(defmethod get-unlit-skel citb-launcher ((obj citb-launcher))
  *citb-launcher-sg*
  )

(defmethod dummy-26 citb-launcher ((obj citb-launcher))
  (let ((f30-0 (res-lump-float (-> obj entity) 'spring-height :default 163840.0))
        (s5-0 (res-lump-value (-> obj entity) 'mode uint128))
        (s4-0 (get-process *default-dead-pool* launcher #x4000))
        )
    (set! (-> obj launcher)
          (the-as
            (pointer launcher)
            (when s4-0
              (let ((t9-3 (method-of-type launcher activate)))
                (t9-3 (the-as launcher s4-0) obj 'launcher (the-as pointer #x70004000))
                )
              (run-now-in-process s4-0 launcher-init-by-other (-> obj root-override trans) f30-0 s5-0 81920.0)
              (-> s4-0 ppointer)
              )
            )
          )
    )
  (set! (-> obj root-override root-prim local-sphere w) 18432.0)
  (logclear! (-> obj mask) (process-mask actor-pause))
  0
  (none)
  )

(defskelgroup *citb-robotboss-sg* citb-robotboss
  0
  2
  ((1 (meters 999999)))
  :bounds (static-spherem 0 17 0 18)
  :longest-edge (meters 6)
  )

(defskelgroup *citb-robotboss-head-sg* citb-robotboss
  6
  8
  ((7 (meters 999999)))
  :bounds (static-spherem 0 30 10 12)
  :longest-edge (meters 2)
  )

(defskelgroup *citb-robotboss-nose-sg* citb-robotboss
  3
  5
  ((4 (meters 999999)))
  :bounds (static-spherem 0 10 20 15)
  :longest-edge (meters 0)
  )

(defskelgroup *citb-robotboss-gun-sg* citb-robotboss
  9
  11
  ((10 (meters 999999)))
  :bounds (static-spherem 0 28 -10 14)
  :longest-edge (meters 5)
  )

(defskelgroup *citb-robotboss-leftshoulder-sg* citb-robotboss
  12
  14
  ((13 (meters 999999)))
  :bounds (static-spherem 17 27 0 14)
  :longest-edge (meters 6)
  )

(defskelgroup *citb-robotboss-rightshoulder-sg* citb-robotboss
  15
  17
  ((16 (meters 999999)))
  :bounds (static-spherem -17 27 0 14)
  :longest-edge (meters 6)
  )

(defskelgroup *citb-robotboss-leftarm-sg* citb-robotboss
  18
  20
  ((19 (meters 999999)))
  :bounds (static-spherem 15 5 -10 20)
  :longest-edge (meters 9)
  )

(defskelgroup *citb-robotboss-rightarm-sg* citb-robotboss
  21
  23
  ((22 (meters 999999)))
  :bounds (static-spherem -15 0 -8 16)
  :longest-edge (meters 3)
  )

(defskelgroup *citb-robotboss-belly-sg* citb-robotboss
  24
  26
  ((25 (meters 999999)))
  :bounds (static-spherem 0 -2 3 10)
  :longest-edge (meters 3)
  )

(deftype citb-robotboss (process-drawable)
  ((root-override collide-shape  :offset        112)
   (shield-on     symbol         :offset-assert 176)
   )
  :heap-base #x50
  :method-count-assert 20
  :size-assert         #xb4
  :flag-assert         #x14005000b4
  (:states
    citb-robotboss-die
    citb-robotboss-idle
    )
  )


(defstate citb-robotboss-idle (citb-robotboss)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (local-vars (sv-96 int) (sv-112 int))
    (the-as object (cond
                     ((= arg2 'shield-off)
                      (stop! (-> self sound))
                      (if (-> self shield-on)
                          (sound-play-by-name (static-sound-name "robotcage-off") (new-sound-id) 1024 0 0 1 #t)
                          )
                      (set! (-> self shield-on) #f)
                      #f
                      )
                     ((= arg2 'shield-on)
                      (let ((v0-3 #t))
                        (set! (-> self shield-on) v0-3)
                        v0-3
                        )
                      )
                     ((= arg2 'die)
                      (dummy-18 self)
                      (the-as symbol (deactivate self))
                      )
                     ((or (= arg2 'touch) (= arg2 'attack))
                      (let ((s4-0 sound-play-by-name)
                            (s3-0 (make-u128 #x7061 (the-as uint #x7a2d646c65696873)))
                            (s2-0 (new-sound-id))
                            (s1-0 1024)
                            (s0-0 0)
                            )
                        (set! sv-96 0)
                        (set! sv-112 1)
                        (let ((t2-1 (target-pos 0)))
                          (s4-0 (the-as sound-name s3-0) s2-0 s1-0 s0-0 sv-96 sv-112 (the-as symbol t2-1))
                          )
                        )
                      (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
                        (set! (-> a1-3 from) self)
                        (set! (-> a1-3 num-params) 2)
                        (set! (-> a1-3 message) 'shove)
                        (set! (-> a1-3 param 0) (-> arg3 param 0))
                        (let ((v1-21 (new 'static 'attack-info :mask #xc0)))
                          (set! (-> v1-21 shove-up) 8192.0)
                          (set! (-> v1-21 shove-back) 12288.0)
                          (set! (-> a1-3 param 1) (the-as uint v1-21))
                          )
                        (the-as symbol (send-event-function arg0 a1-3))
                        )
                      )
                     )
            )
    )
  :code
  (behavior ()
    (let* ((s5-0 (get-process *default-dead-pool* manipy #x4000))
           (gp-0 (when s5-0
                   (let ((t9-1 (method-of-type manipy activate)))
                     (t9-1 (the-as manipy s5-0) self 'manipy (the-as pointer #x70004000))
                     )
                   (run-now-in-process
                     s5-0
                     manipy-init
                     (-> self root-override trans)
                     (-> self entity)
                     *citb-robotboss-nose-sg*
                     #f
                     )
                   (-> s5-0 ppointer)
                   )
                 )
           )
      (send-event (ppointer->process gp-0) 'anim-mode 'loop)
      (send-event (ppointer->process gp-0) 'art-joint-anim "citb-robotboss-nose-idle" 0)
      (send-event (ppointer->process gp-0) 'draw #t)
      )
    (let* ((s5-1 (get-process *default-dead-pool* manipy #x4000))
           (gp-1 (when s5-1
                   (let ((t9-7 (method-of-type manipy activate)))
                     (t9-7 (the-as manipy s5-1) self 'manipy (the-as pointer #x70004000))
                     )
                   (run-now-in-process
                     s5-1
                     manipy-init
                     (-> self root-override trans)
                     (-> self entity)
                     *citb-robotboss-head-sg*
                     #f
                     )
                   (-> s5-1 ppointer)
                   )
                 )
           )
      (send-event (ppointer->process gp-1) 'anim-mode 'loop)
      (send-event (ppointer->process gp-1) 'art-joint-anim "citb-robotboss-head-idle" 0)
      (send-event (ppointer->process gp-1) 'draw #t)
      )
    (let* ((s5-2 (get-process *default-dead-pool* manipy #x4000))
           (gp-2 (when s5-2
                   (let ((t9-13 (method-of-type manipy activate)))
                     (t9-13 (the-as manipy s5-2) self 'manipy (the-as pointer #x70004000))
                     )
                   (run-now-in-process
                     s5-2
                     manipy-init
                     (-> self root-override trans)
                     (-> self entity)
                     *citb-robotboss-gun-sg*
                     #f
                     )
                   (-> s5-2 ppointer)
                   )
                 )
           )
      (send-event (ppointer->process gp-2) 'anim-mode 'loop)
      (send-event (ppointer->process gp-2) 'art-joint-anim "citb-robotboss-gun-idle" 0)
      (send-event (ppointer->process gp-2) 'draw #t)
      )
    (let* ((s5-3 (get-process *default-dead-pool* manipy #x4000))
           (gp-3 (when s5-3
                   (let ((t9-19 (method-of-type manipy activate)))
                     (t9-19 (the-as manipy s5-3) self 'manipy (the-as pointer #x70004000))
                     )
                   (run-now-in-process
                     s5-3
                     manipy-init
                     (-> self root-override trans)
                     (-> self entity)
                     *citb-robotboss-leftshoulder-sg*
                     #f
                     )
                   (-> s5-3 ppointer)
                   )
                 )
           )
      (send-event (ppointer->process gp-3) 'anim-mode 'loop)
      (send-event (ppointer->process gp-3) 'art-joint-anim "citb-robotboss-leftshoulder-idle" 0)
      (send-event (ppointer->process gp-3) 'draw #t)
      )
    (let* ((s5-4 (get-process *default-dead-pool* manipy #x4000))
           (gp-4 (when s5-4
                   (let ((t9-25 (method-of-type manipy activate)))
                     (t9-25 (the-as manipy s5-4) self 'manipy (the-as pointer #x70004000))
                     )
                   (run-now-in-process
                     s5-4
                     manipy-init
                     (-> self root-override trans)
                     (-> self entity)
                     *citb-robotboss-rightshoulder-sg*
                     #f
                     )
                   (-> s5-4 ppointer)
                   )
                 )
           )
      (send-event (ppointer->process gp-4) 'anim-mode 'loop)
      (send-event (ppointer->process gp-4) 'art-joint-anim "citb-robotboss-rightshoulder-idle" 0)
      (send-event (ppointer->process gp-4) 'draw #t)
      )
    (let* ((s5-5 (get-process *default-dead-pool* manipy #x4000))
           (gp-5 (when s5-5
                   (let ((t9-31 (method-of-type manipy activate)))
                     (t9-31 (the-as manipy s5-5) self 'manipy (the-as pointer #x70004000))
                     )
                   (run-now-in-process
                     s5-5
                     manipy-init
                     (-> self root-override trans)
                     (-> self entity)
                     *citb-robotboss-leftarm-sg*
                     #f
                     )
                   (-> s5-5 ppointer)
                   )
                 )
           )
      (send-event (ppointer->process gp-5) 'anim-mode 'loop)
      (send-event (ppointer->process gp-5) 'art-joint-anim "citb-robotboss-leftarm-idle" 0)
      (send-event (ppointer->process gp-5) 'draw #t)
      )
    (let* ((s5-6 (get-process *default-dead-pool* manipy #x4000))
           (gp-6 (when s5-6
                   (let ((t9-37 (method-of-type manipy activate)))
                     (t9-37 (the-as manipy s5-6) self 'manipy (the-as pointer #x70004000))
                     )
                   (run-now-in-process
                     s5-6
                     manipy-init
                     (-> self root-override trans)
                     (-> self entity)
                     *citb-robotboss-rightarm-sg*
                     #f
                     )
                   (-> s5-6 ppointer)
                   )
                 )
           )
      (send-event (ppointer->process gp-6) 'anim-mode 'loop)
      (send-event (ppointer->process gp-6) 'art-joint-anim "citb-robotboss-rightarm-idle" 0)
      (send-event (ppointer->process gp-6) 'draw #t)
      )
    (let* ((s5-7 (get-process *default-dead-pool* manipy #x4000))
           (gp-7 (when s5-7
                   (let ((t9-43 (method-of-type manipy activate)))
                     (t9-43 (the-as manipy s5-7) self 'manipy (the-as pointer #x70004000))
                     )
                   (run-now-in-process
                     s5-7
                     manipy-init
                     (-> self root-override trans)
                     (-> self entity)
                     *citb-robotboss-belly-sg*
                     #f
                     )
                   (-> s5-7 ppointer)
                   )
                 )
           )
      (send-event (ppointer->process gp-7) 'anim-mode 'loop)
      (send-event (ppointer->process gp-7) 'art-joint-anim "citb-robotboss-belly-idle" 0)
      (send-event (ppointer->process gp-7) 'draw #t)
      )
    (update-transforms! (-> self root-override))
    (while #t
      (when (-> self shield-on)
        (update! (-> self sound))
        (spawn (-> self part) (-> self root-override trans))
        (set! (-> *palette-fade-controls* control 7 fade) 1.0)
        )
      (suspend)
      )
    (none)
    )
  :post
  (the-as (function none :behavior citb-robotboss) ja-post)
  )

(defstate citb-robotboss-die (citb-robotboss)
  :code
  (behavior ()
    (dummy-18 self)
    (deactivate self)
    (none)
    )
  )

(defmethod init-from-entity! citb-robotboss ((obj citb-robotboss) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 81920.0 0.0 143360.0)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *citb-robotboss-sg* '())
  (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 601) obj))
  (logclear! (-> obj mask) (process-mask actor-pause))
  (set! (-> obj shield-on) #t)
  (set! (-> obj sound) (new
                         'process
                         'ambient-sound
                         (new 'static 'sound-spec
                           :mask #x80
                           :num 1.0
                           :group #x1
                           :sound-name (static-sound-name "robotcage-lp")
                           :volume #x400
                           :fo-max #x96
                           )
                         (-> obj root-override trans)
                         )
        )
  (if (= (get-task-status (-> obj entity extra perm task)) (task-status invalid))
      (go citb-robotboss-die)
      (go citb-robotboss-idle)
      )
  (none)
  )

(defskelgroup *citb-coil-sg* citb-coil
  0
  3
  ((1 (meters 20)) (2 (meters 999999)))
  :bounds (static-spherem 0 0 0 4)
  :longest-edge (meters 0)
  )

(deftype citb-coil (process-drawable)
  ((part-off sparticle-launch-control  :offset-assert 176)
   )
  :heap-base #x50
  :method-count-assert 20
  :size-assert         #xb4
  :flag-assert         #x14005000b4
  (:states
    citb-coil-break
    citb-coil-broken
    citb-coil-idle
    )
  )


(defmethod relocate citb-coil ((obj citb-coil) (arg0 int))
  (if (nonzero? (-> obj part-off))
      (&+! (-> obj part-off) arg0)
      )
  (the-as citb-coil ((method-of-type process-drawable relocate) obj arg0))
  )

(defmethod deactivate citb-coil ((obj citb-coil))
  (if (nonzero? (-> obj part-off))
      (kill-and-free-particles (-> obj part-off))
      )
  ((method-of-type process-drawable deactivate) obj)
  (none)
  )

(defstate citb-coil-idle (citb-coil)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (case arg2
      (('trigger)
       (go citb-coil-break)
       )
      )
    )
  :code
  (behavior ()
    (while #t
      (let ((a0-0 (-> self skel root-channel 0)))
        (set! (-> a0-0 frame-group) (if (> (-> self skel active-channels) 0)
                                        (-> self skel root-channel 0 frame-group)
                                        )
              )
        (set! (-> a0-0 param 0) (the float (+ (-> (if (> (-> self skel active-channels) 0)
                                                      (-> self skel root-channel 0 frame-group)
                                                      )
                                                  data
                                                  0
                                                  length
                                                  )
                                              -1
                                              )
                                     )
              )
        (set! (-> a0-0 param 1) 1.0)
        (set! (-> a0-0 frame-num) 0.0)
        (joint-control-channel-group!
          a0-0
          (if (> (-> self skel active-channels) 0)
              (-> self skel root-channel 0 frame-group)
              )
          num-func-seek!
          )
        )
      (until (ja-done? 0)
        (suspend)
        (let ((a0-1 (-> self skel root-channel 0)))
          (set! (-> a0-1 param 0) (the float (+ (-> a0-1 frame-group data 0 length) -1)))
          (set! (-> a0-1 param 1) 1.0)
          (joint-control-channel-group-eval! a0-1 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      )
    (none)
    )
  :post
  (behavior ()
    (spawn (-> self part) (-> self root trans))
    (ja-post)
    (none)
    )
  )

(defstate citb-coil-break (citb-coil)
  :code
  (behavior ()
    (process-entity-status! self (entity-perm-status complete) #t)
    (ja-channel-push! 1 30)
    (let ((a0-2 (-> self skel root-channel 0)))
      (set! (-> a0-2 frame-group) (the-as art-joint-anim (-> self draw art-group data 4)))
      (set! (-> a0-2 param 0)
            (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 4)) data 0 length) -1))
            )
      (set! (-> a0-2 param 1) 1.0)
      (set! (-> a0-2 frame-num) 0.0)
      (joint-control-channel-group! a0-2 (the-as art-joint-anim (-> self draw art-group data 4)) num-func-seek!)
      )
    (until (ja-done? 0)
      (suspend)
      (let ((a0-3 (-> self skel root-channel 0)))
        (set! (-> a0-3 param 0) (the float (+ (-> a0-3 frame-group data 0 length) -1)))
        (set! (-> a0-3 param 1) 1.0)
        (joint-control-channel-group-eval! a0-3 (the-as art-joint-anim #f) num-func-seek!)
        )
      )
    (go citb-coil-broken)
    (none)
    )
  :post
  (the-as (function none :behavior citb-coil) ja-post)
  )

(defstate citb-coil-broken (citb-coil)
  :code
  (behavior ()
    (let ((a0-0 (-> self skel root-channel 0)))
      (set! (-> a0-0 frame-group) (the-as art-joint-anim (-> self draw art-group data 5)))
      (set! (-> a0-0 param 0)
            (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 5)) data 0 length) -1))
            )
      (set! (-> a0-0 param 1) 1.0)
      (set! (-> a0-0 frame-num) 0.0)
      (joint-control-channel-group! a0-0 (the-as art-joint-anim (-> self draw art-group data 5)) num-func-seek!)
      )
    (until (ja-done? 0)
      (suspend)
      (let ((a0-1 (-> self skel root-channel 0)))
        (set! (-> a0-1 param 0) (the float (+ (-> a0-1 frame-group data 0 length) -1)))
        (set! (-> a0-1 param 1) 1.0)
        (joint-control-channel-group-eval! a0-1 (the-as art-joint-anim #f) num-func-seek!)
        )
      )
    (while #t
      (spawn (-> self part-off) (-> self root trans))
      (suspend)
      )
    (none)
    )
  :post
  (the-as (function none :behavior citb-coil) ja-post)
  )

(defmethod init-from-entity! citb-coil ((obj citb-coil) (arg0 entity-actor))
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *citb-coil-sg* '())
  (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 596) obj))
  (set! (-> obj part-off) (create-launch-control (-> *part-group-id-table* 602) obj))
  (let ((v1-9 (the-as entity (entity-actor-lookup (-> obj entity) 'state-actor 0))))
    (if (not (the-as entity-actor v1-9))
        (set! v1-9 (-> obj entity))
        )
    (if (logtest? (-> v1-9 extra perm status) (entity-perm-status complete))
        (go citb-coil-broken)
        (go citb-coil-idle)
        )
    )
  (none)
  )

(defskelgroup *citb-hose-sg* citb-hose
  0
  3
  ((1 (meters 20)) (2 (meters 999999)))
  :bounds (static-spherem 0 0 0 10)
  :longest-edge (meters 0)
  )

(deftype citb-hose (process-drawable)
  ()
  :heap-base #x40
  :method-count-assert 20
  :size-assert         #xb0
  :flag-assert         #x14004000b0
  (:states
    citb-hose-die
    citb-hose-idle
    citb-hose-spawn
    )
  )


(defbehavior citb-hose-event-handler citb-hose ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('spawn)
     (go citb-hose-spawn)
     )
    (('trigger)
     (go citb-hose-die)
     )
    )
  )

(defstate citb-hose-idle (citb-hose)
  :event
  citb-hose-event-handler
  :code
  (behavior ()
    (while #t
      (let ((a0-0 (-> self skel root-channel 0)))
        (set! (-> a0-0 frame-group) (the-as art-joint-anim (-> self draw art-group data 3)))
        (set! (-> a0-0 param 0)
              (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 3)) data 0 length) -1))
              )
        (set! (-> a0-0 param 1) 1.0)
        (set! (-> a0-0 frame-num) 0.0)
        (joint-control-channel-group! a0-0 (the-as art-joint-anim (-> self draw art-group data 3)) num-func-seek!)
        )
      (until (ja-done? 0)
        (suspend)
        (let ((a0-1 (-> self skel root-channel 0)))
          (set! (-> a0-1 param 0) (the float (+ (-> a0-1 frame-group data 0 length) -1)))
          (set! (-> a0-1 param 1) 1.0)
          (joint-control-channel-group-eval! a0-1 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      )
    (none)
    )
  :post
  (the-as (function none :behavior citb-hose) ja-post)
  )

(defstate citb-hose-spawn (citb-hose)
  :event
  citb-hose-event-handler
  :code
  (behavior ()
    (ja-channel-push! 1 30)
    (let ((a0-1 (-> self skel root-channel 0)))
      (set! (-> a0-1 frame-group) (the-as art-joint-anim (-> self draw art-group data 4)))
      (set! (-> a0-1 param 0)
            (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 4)) data 0 length) -1))
            )
      (set! (-> a0-1 param 1) 1.0)
      (set! (-> a0-1 frame-num) 0.0)
      (joint-control-channel-group! a0-1 (the-as art-joint-anim (-> self draw art-group data 4)) num-func-seek!)
      )
    (until (ja-done? 0)
      (suspend)
      (let ((a0-2 (-> self skel root-channel 0)))
        (set! (-> a0-2 param 0) (the float (+ (-> a0-2 frame-group data 0 length) -1)))
        (set! (-> a0-2 param 1) 1.0)
        (joint-control-channel-group-eval! a0-2 (the-as art-joint-anim #f) num-func-seek!)
        )
      )
    (go citb-hose-idle)
    (none)
    )
  :post
  (the-as (function none :behavior citb-hose) ja-post)
  )

(defstate citb-hose-die (citb-hose)
  :event
  citb-hose-event-handler
  :code
  (behavior ()
    (process-entity-status! self (entity-perm-status complete) #t)
    (ja-channel-push! 1 30)
    (let ((a0-2 (-> self skel root-channel 0)))
      (set! (-> a0-2 frame-group) (the-as art-joint-anim (-> self draw art-group data 5)))
      (set! (-> a0-2 param 0)
            (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 5)) data 0 length) -1))
            )
      (set! (-> a0-2 param 1) 1.0)
      (set! (-> a0-2 frame-num) 0.0)
      (joint-control-channel-group! a0-2 (the-as art-joint-anim (-> self draw art-group data 5)) num-func-seek!)
      )
    (until (ja-done? 0)
      (suspend)
      (let ((a0-3 (-> self skel root-channel 0)))
        (set! (-> a0-3 param 0) (the float (+ (-> a0-3 frame-group data 0 length) -1)))
        (set! (-> a0-3 param 1) 1.0)
        (joint-control-channel-group-eval! a0-3 (the-as art-joint-anim #f) num-func-seek!)
        )
      )
    (anim-loop)
    (none)
    )
  :post
  (the-as (function none :behavior citb-hose) ja-post)
  )

(defmethod init-from-entity! citb-hose ((obj citb-hose) (arg0 entity-actor))
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *citb-hose-sg* '())
  (let ((v1-3 (the-as entity (entity-actor-lookup (-> obj entity) 'state-actor 0))))
    (if (not (the-as entity-actor v1-3))
        (set! v1-3 (-> obj entity))
        )
    (if (logtest? (-> v1-3 extra perm status) (entity-perm-status complete))
        (go citb-hose-die)
        (go citb-hose-idle)
        )
    )
  (none)
  )

(deftype citb-chains (process-hidden)
  ()
  :method-count-assert 15
  :size-assert         #x70
  :flag-assert         #xf00000070
  )


(defskelgroup *citb-generator-sg* citb-generator
  0
  4
  ((1 (meters 999999)))
  :bounds (static-spherem 0 0 0 2)
  :longest-edge (meters 0)
  )

(defskelgroup *citb-generator-broken-sg* citb-generator
  2
  4
  ((3 (meters 999999)))
  :bounds (static-spherem 0 0 0 2)
  :longest-edge (meters 0)
  )

(deftype citb-generator (process-drawable)
  ((root-override   collide-shape                    :offset        112)
   (normal-look     lod-set                  :inline :offset-assert 176)
   (broken-look     lod-set                  :inline :offset-assert 212)
   (mushroom-pos    vector                   :inline :offset-assert 256)
   (mushroom        symbol                           :offset-assert 272)
   (birth-fuel-cell symbol                           :offset-assert 276)
   (trigger-others  symbol                           :offset-assert 280)
   (part-broken     sparticle-launch-control         :offset-assert 284)
   (part-mushroom   sparticle-launch-control         :offset-assert 288)
   )
  :heap-base #xc0
  :method-count-assert 22
  :size-assert         #x124
  :flag-assert         #x1600c00124
  (:methods
    (init! (_type_) none 20)
    (dummy-21 (_type_) none 21)
    )
  (:states
    citb-generator-break
    citb-generator-broken
    citb-generator-idle
    )
  )


(defmethod relocate citb-generator ((obj citb-generator) (arg0 int))
  (if (nonzero? (-> obj part-broken))
      (&+! (-> obj part-broken) arg0)
      )
  (if (nonzero? (-> obj part-mushroom))
      (&+! (-> obj part-mushroom) arg0)
      )
  (the-as citb-generator ((method-of-type process-drawable relocate) obj arg0))
  )

(defmethod deactivate citb-generator ((obj citb-generator))
  (if (nonzero? (-> obj part-broken))
      (kill-and-free-particles (-> obj part-broken))
      )
  (if (nonzero? (-> obj part-mushroom))
      (kill-and-free-particles (-> obj part-mushroom))
      )
  ((method-of-type process-drawable deactivate) obj)
  (none)
  )

(defbehavior citb-generator-trigger-others citb-generator ()
  (let ((gp-0 (entity-actor-count (-> self entity) 'alt-actor)))
    (dotimes (s5-0 gp-0)
      (let ((s4-0 (entity-actor-lookup (-> self entity) 'alt-actor s5-0))
            (a1-2 (new 'stack-no-clear 'event-message-block))
            )
        (set! (-> a1-2 from) self)
        (set! (-> a1-2 num-params) 0)
        (set! (-> a1-2 message) 'trigger)
        (let ((t9-2 send-event-function)
              (v1-1 s4-0)
              )
          (when (not (t9-2
                       (if v1-1
                           (-> v1-1 extra process)
                           )
                       a1-2
                       )
                     )
            (entity-birth-no-kill s4-0)
            (suspend)
            (send-event
              (if s4-0
                  (-> s4-0 extra process)
                  )
              'trigger
              )
            )
          )
        )
      )
    )
  (let ((gp-1 (-> *display* base-frame-counter)))
    (while (< (- (-> *display* base-frame-counter) gp-1) 150)
      (if (movie?)
          (set! gp-1 (-> *display* base-frame-counter))
          )
      (suspend)
      )
    )
  (let ((gp-2 (entity-actor-count (-> self entity) 'trigger-actor)))
    (dotimes (s5-1 gp-2)
      (let ((s4-1 (entity-actor-lookup (-> self entity) 'trigger-actor s5-1))
            (a1-6 (new 'stack-no-clear 'event-message-block))
            )
        (set! (-> a1-6 from) self)
        (set! (-> a1-6 num-params) 0)
        (set! (-> a1-6 message) 'trigger)
        (let ((t9-8 send-event-function)
              (v1-19 s4-1)
              )
          (when (not (t9-8
                       (if v1-19
                           (-> v1-19 extra process)
                           )
                       a1-6
                       )
                     )
            (entity-birth-no-kill s4-1)
            (suspend)
            (send-event
              (if s4-1
                  (-> s4-1 extra process)
                  )
              'trigger
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defstate citb-generator-idle (citb-generator)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (case arg2
      (('attack)
       (if (-> self mushroom)
           (increment-success-for-hint (game-text-id citadel-break-generator-hint))
           (increment-success-for-hint (game-text-id citadel-break-generators-reminder))
           )
       (go citb-generator-break)
       )
      (('trigger)
       #t
       )
      )
    )
  :exit
  (behavior ()
    (stop! (-> self sound))
    (none)
    )
  :code
  (behavior ()
    (lods-assign! (-> self draw) (-> self normal-look))
    (update-transforms! (-> self root-override))
    (while #t
      (spawn (-> self part) (-> self root-override trans))
      (update! (-> self sound))
      (if (-> self mushroom)
          (spawn (-> self part-mushroom) (-> self mushroom-pos))
          )
      (if (not (-> self mushroom))
          (set! (-> *palette-fade-controls* control 3 fade) (+ 0.3333 (-> *palette-fade-controls* control 3 fade)))
          )
      (when (and *target* (>= 32768.0 (vector-vector-distance (-> self root-override trans) (-> *target* control trans))))
        (if (-> self mushroom)
            (level-hint-spawn
              (game-text-id citadel-break-generator-hint)
              "sksp0381"
              (the-as entity #f)
              *entity-pool*
              (game-task none)
              )
            (level-hint-spawn
              (game-text-id citadel-break-generators-reminder)
              "sksp0384"
              (the-as entity #f)
              *entity-pool*
              (game-task none)
              )
            )
        )
      (suspend)
      )
    (none)
    )
  :post
  (the-as (function none :behavior citb-generator) ja-post)
  )

(defstate citb-generator-break (citb-generator)
  :code
  (behavior ()
    (let ((gp-0 (entity-actor-count (-> self entity) 'open-actor)))
      (dotimes (s5-0 gp-0)
        (let ((s4-0 (entity-actor-lookup (-> self entity) 'open-actor s5-0))
              (a1-2 (new 'stack-no-clear 'event-message-block))
              )
          (set! (-> a1-2 from) self)
          (set! (-> a1-2 num-params) 0)
          (set! (-> a1-2 message) 'open)
          (let ((t9-2 send-event-function)
                (v1-1 s4-0)
                )
            (when (not (t9-2
                         (if v1-1
                             (-> v1-1 extra process)
                             )
                         a1-2
                         )
                       )
              (entity-birth-no-kill s4-0)
              (suspend)
              (send-event
                (if s4-0
                    (-> s4-0 extra process)
                    )
                'open
                )
              )
            )
          )
        )
      )
    (process-entity-status! self (entity-perm-status complete) #t)
    (let ((gp-1 (get-process *default-dead-pool* part-tracker #x4000)))
      (when gp-1
        (let ((t9-7 (method-of-type part-tracker activate)))
          (t9-7 (the-as part-tracker gp-1) *entity-pool* 'part-tracker (the-as pointer #x70004000))
          )
        (run-now-in-process
          gp-1
          part-tracker-init
          (-> *part-group-id-table* 598)
          -1
          #f
          #f
          #f
          (-> self root-override trans)
          )
        (-> gp-1 ppointer)
        )
      )
    (sound-play-by-name (static-sound-name "sagecage-open") (new-sound-id) 1024 0 0 1 #t)
    (go citb-generator-broken)
    (none)
    )
  :post
  (the-as (function none :behavior citb-generator) ja-post)
  )

(defstate citb-generator-broken (citb-generator)
  :code
  (behavior ()
    (lods-assign! (-> self draw) (-> self broken-look))
    (update-transforms! (-> self root-override))
    (cond
      ((-> self birth-fuel-cell)
       (process-drawable-birth-fuel-cell (the-as entity #f) (the-as vector #f) #t)
       (when (-> self child)
         (while (-> self child)
           (suspend)
           )
         (citb-generator-trigger-others)
         )
       )
      (else
        (citb-generator-trigger-others)
        )
      )
    (anim-loop)
    (none)
    )
  :post
  (behavior ()
    (spawn (-> self part-broken) (-> self root-override trans))
    (ja-post)
    (none)
    )
  )

(defmethod init! citb-generator ((obj citb-generator))
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set-vector! (-> s4-0 local-sphere) 0.0 4096.0 0.0 4096.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

(defmethod dummy-21 citb-generator ((obj citb-generator))
  (initialize-skeleton obj *citb-generator-sg* '())
  (setup-lods! (-> obj normal-look) *citb-generator-sg* (-> obj draw art-group) (-> obj entity))
  (setup-lods! (-> obj broken-look) *citb-generator-broken-sg* (-> obj draw art-group) (-> obj entity))
  (set! (-> obj link) (new 'process 'actor-link-info obj))
  (set! (-> obj birth-fuel-cell) (< (the-as uint 1) (the-as uint (-> obj entity extra perm task))))
  (set! (-> obj trigger-others) #f)
  (set! (-> obj mushroom-pos quad) (-> obj root-override trans quad))
  (let ((f30-0 0.0))
    (cond
      ((name= (-> obj name) "citb-generator-1")
       (set! (-> obj mushroom) #t)
       (set! f30-0 21845.334)
       )
      ((name= (-> obj name) "citb-generator-2")
       (set! (-> obj mushroom) #t)
       (set! f30-0 16384.0)
       )
      ((name= (-> obj name) "citb-generator-3")
       (set! (-> obj mushroom) #t)
       (set! f30-0 16384.0)
       )
      ((name= (-> obj name) "citb-generator-4")
       (set! (-> obj mushroom) #t)
       (set! f30-0 -5461.3335)
       )
      (else
        (set! (-> obj mushroom) #f)
        )
      )
    (when (-> obj mushroom)
      (+! (-> obj mushroom-pos x) (* 19251.2 (sin f30-0)))
      (+! (-> obj mushroom-pos z) (* 19251.2 (cos f30-0)))
      )
    )
  (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 600) obj))
  (set! (-> obj part-broken) (create-launch-control (-> *part-group-id-table* 597) obj))
  (set! (-> obj part-mushroom) (create-launch-control (-> *part-group-id-table* 599) obj))
  (set! (-> obj sound) (new
                         'process
                         'ambient-sound
                         (new 'static 'sound-spec
                           :mask #x80
                           :num 1.0
                           :group #x1
                           :sound-name (static-sound-name "mushroom-gen")
                           :volume #x400
                           :fo-max 20
                           )
                         (-> obj root-override trans)
                         )
        )
  0
  (none)
  )

(defmethod init-from-entity! citb-generator ((obj citb-generator) (arg0 entity-actor))
  (init! obj)
  (process-drawable-from-entity! obj arg0)
  (dummy-21 obj)
  (let ((v1-4 (the-as entity (entity-actor-lookup (-> obj entity) 'state-actor 0))))
    (if (not (the-as entity-actor v1-4))
        (set! v1-4 (-> obj entity))
        )
    (if (logtest? (-> v1-4 extra perm status) (entity-perm-status complete))
        (go citb-generator-broken)
        (go citb-generator-idle)
        )
    )
  (none)
  )

(defskelgroup *citadelcam-sg* citadelcam
  0
  2
  ((1 (meters 999999)))
  :bounds (static-spherem 0 0 0 20)
  :longest-edge (meters 0)
  )

(deftype citadelcam (process-drawable)
  ()
  :heap-base #x40
  :method-count-assert 20
  :size-assert         #xb0
  :flag-assert         #x14004000b0
  (:states
    citadelcam-idle
    citadelcam-stair-plats
    )
  )


(defstate citadelcam-idle (citadelcam)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (case arg2
      (('trigger)
       (when (and (task-complete? *game-info* (game-task citadel-sage-blue))
                  (task-complete? *game-info* (game-task citadel-sage-red))
                  (task-complete? *game-info* (game-task citadel-sage-yellow))
                  )
         (logclear! (-> self mask) (process-mask actor-pause))
         (go citadelcam-stair-plats)
         )
       )
      )
    )
  :code
  (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    (anim-loop)
    (none)
    )
  )

(defstate citadelcam-stair-plats (citadelcam)
  :code
  (behavior ()
    (let ((gp-0 (entity-actor-count (-> self entity) 'trigger-actor)))
      (dotimes (s5-0 gp-0)
        (let ((s4-0 (entity-actor-lookup (-> self entity) 'trigger-actor s5-0))
              (a1-2 (new 'stack-no-clear 'event-message-block))
              )
          (set! (-> a1-2 from) self)
          (set! (-> a1-2 num-params) 0)
          (set! (-> a1-2 message) 'trigger)
          (let ((t9-2 send-event-function)
                (v1-1 s4-0)
                )
            (when (not (t9-2
                         (if v1-1
                             (-> v1-1 extra process)
                             )
                         a1-2
                         )
                       )
              (entity-birth-no-kill s4-0)
              (suspend)
              (send-event
                (if s4-0
                    (-> s4-0 extra process)
                    )
                'trigger
                )
              )
            )
          )
        )
      )
    (let* ((gp-1 (get-process *default-dead-pool* pov-camera #x4000))
           (gp-2
             (ppointer->handle
               (when gp-1
                 (let ((t9-6 (method-of-type pov-camera activate)))
                   (t9-6 (the-as pov-camera gp-1) self 'pov-camera (the-as pointer #x70004000))
                   )
                 (run-now-in-process
                   gp-1
                   pov-camera-init-by-other
                   (-> self root trans)
                   *citadelcam-sg*
                   "citadelcam-stair-plats"
                   0
                   #f
                   '()
                   )
                 (-> gp-1 ppointer)
                 )
               )
             )
           )
      (while (handle->process (the-as handle gp-2))
        (suspend)
        )
      )
    (level-hint-spawn
      (game-text-id citadel-climb-plat-hint)
      "sksp0387"
      (the-as entity #f)
      *entity-pool*
      (game-task none)
      )
    (go citadelcam-idle)
    (none)
    )
  )

(defmethod init-from-entity! citadelcam ((obj citadelcam) (arg0 entity-actor))
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (logclear! (-> obj mask) (process-mask actor-pause))
  (go citadelcam-idle)
  (none)
  )

(deftype citb-battlecontroller (battlecontroller)
  ()
  :heap-base #x210
  :method-count-assert 29
  :size-assert         #x27c
  :flag-assert         #x1d0210027c
  )


(defstate battlecontroller-play-intro-camera (citb-battlecontroller)
  :virtual #t
  :code
  (behavior ()
    (level-hint-spawn
      (game-text-id citadel-lurker-bunny-alert)
      "sksp0383"
      (the-as entity #f)
      *entity-pool*
      (game-task none)
      )
    (suspend)
    (let* ((gp-0 (get-process *default-dead-pool* pov-camera #x4000))
           (gp-1 (ppointer->handle (when gp-0
                                     (let ((t9-2 (method-of-type pov-camera activate)))
                                       (t9-2 (the-as pov-camera gp-0) self 'pov-camera (the-as pointer #x70004000))
                                       )
                                     (run-now-in-process
                                       gp-0
                                       pov-camera-init-by-other
                                       (-> (entity-by-name "citadelcam-1") extra trans)
                                       *citadelcam-sg*
                                       "citadel-bunnies"
                                       0
                                       #f
                                       '()
                                       )
                                     (-> gp-0 ppointer)
                                     )
                                   )
                 )
           )
      (send-event (handle->process (the-as handle gp-1)) 'mask 2048)
      (while (handle->process (the-as handle gp-1))
        (set! (-> *target* state-flags) (logand -17 (-> *target* state-flags)))
        (suspend)
        )
      )
    (go-virtual battlecontroller-active)
    (none)
    )
  )

(defstate battlecontroller-die (citb-battlecontroller)
  :virtual #t
  :code
  (behavior ()
    (process-entity-status! self (entity-perm-status complete) #t)
    (let ((t9-2 (-> (the-as (state battlecontroller) (find-parent-method citb-battlecontroller 26)) code)))
      (if t9-2
          ((the-as (function none :behavior battlecontroller) t9-2))
          )
      )
    (none)
    )
  )

(defmethod TODO-RENAME-27 citb-battlecontroller ((obj citb-battlecontroller))
  ((the-as (function battlecontroller none) (find-parent-method citb-battlecontroller 27)) obj)
  (set! (-> obj activate-distance) 143360.0)
  0
  (none)
  )




