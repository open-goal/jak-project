;;-*-Lisp-*-
(in-package goal)

;; name: rolling-robber.gc
;; name in dgo: rolling-robber
;; dgos: L1, ROL

;; DECOMP BEGINS

(defstate fuel-cell-spline-slider (fuel-cell)
  :trans
  (the-as (function none :behavior fuel-cell) hide-hud-quick)
  :code
  (behavior ((arg0 handle) (arg1 float) (arg2 float))
    (logclear! (-> self mask) (process-mask actor-pause))
    (let ((v1-4 (-> self skel root-channel 0)))
      (set! (-> v1-4 frame-group) (the-as art-joint-anim (-> self draw art-group data 2)))
      )
    (if *target*
        (process-grab? *target*)
        )
    (hide-hud-quick)
    (set! *camera-look-through-other* 2)
    (set! (-> *camera-other-fov* data) 11650.845)
    (set! (-> *camera-other-trans* quad) (-> *math-camera* trans quad))
    (set! (-> *camera-other-root* quad) (-> *math-camera* trans quad))
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (while #t
      (dotimes (v1-14 (the int (-> *display* time-adjust-ratio)))
        (set! arg2 (* 0.95 arg2))
        )
      (when (and (< (fabs arg2) 13.653334) (>= (- (-> *display* base-frame-counter) (-> self state-time)) 450))
        (if *target*
            (process-release? *target*)
            )
        (go-virtual wait)
        )
      (set! arg1 (+ arg1 (/ (* arg2 (-> *display* seconds-per-frame)) (path-distance (-> self path)))))
      (cond
        ((< 1.0 arg1)
         (set! arg1 (+ -1.0 arg1))
         )
        ((< arg1 0.0)
         (set! arg1 (+ 1.0 arg1))
         )
        )
      (eval-path-curve! (-> self path) (-> self root-override trans) arg1 'interp)
      (set! (-> self root-override trans y) (+ 8192.0 (-> self root-override trans y)))
      (set! (-> self root-override trans y) (fmax 106496.0 (-> self root-override trans y)))
      (set! (-> self base quad) (-> self root-override trans quad))
      (transform-post)
      (animate self)
      (let ((s4-0 (new 'stack-no-clear 'vector)))
        (vector-! s4-0 (-> self root-override trans) *camera-other-trans*)
        (vector-normalize! s4-0 1.0)
        (forward-down->inv-matrix *camera-other-matrix* s4-0 (new 'static 'vector :y -1.0 :w 1.0))
        )
      (set! *camera-look-through-other* 2)
      (set-letterbox-frames 10)
      (suspend)
      (let ((a0-27 (-> self skel root-channel 0)))
        (set! (-> a0-27 param 0) 0.5)
        (joint-control-channel-group-eval! a0-27 (the-as art-joint-anim #f) num-func-loop!)
        )
      )
    (none)
    )
  )

(defbehavior fuel-cell-init-as-spline-slider fuel-cell ((arg0 handle) (arg1 float) (arg2 float) (arg3 int))
  (initialize self)
  (set! (-> self fact pickup-type) (pickup-type fuel-cell))
  (set! (-> self fact pickup-amount) (the float arg3))
  (initialize-params self 0 1024.0)
  (logclear! (-> self mask) (process-mask actor-pause))
  (set! (-> self actor-pause) #f)
  (set! (-> self entity) (-> arg0 process 0 entity))
  (set! (-> self path) (new 'process 'curve-control self 'path -1000000000.0))
  (set! (-> self movie-pos-index) -1)
  (go fuel-cell-spline-slider arg0 arg1 arg2)
  (none)
  )

(deftype robber (process-drawable)
  ((root-override        collide-shape-moving         :offset        112)
   (curve-position       float                        :offset-assert 176)
   (speed                float                        :offset-assert 180)
   (facing               vector               :inline :offset-assert 192)
   (tangent              vector               :inline :offset-assert 208)
   (run-blend-interp     float                        :offset-assert 224)
   (near-timer           int32                        :offset-assert 228)
   (far-time             uint64                       :offset-assert 232)
   (y-offset             float                        :offset-assert 240)
   (y-offset-desired     float                        :offset-assert 244)
   (y-vel                float                        :offset-assert 248)
   (water-height         float                        :offset-assert 252)
   (timeout              uint64                       :offset-assert 256)
   (last-ambient-time    uint64                       :offset-assert 264)
   (time-to-next-ambient uint64                       :offset-assert 272)
   )
  :heap-base #xb0
  :method-count-assert 20
  :size-assert         #x118
  :flag-assert         #x1400b00118
  (:states
    robber-dead
    robber-debug
    robber-die
    robber-flee
    robber-got-away
    robber-idle
    robber-initial
    robber-initial-notice
    robber-tired
    )
  )


(defskelgroup *robber-sg* robber
  0
  10
  ((1 (meters 20)) (2 (meters 40)) (3 (meters 999999)))
  :bounds (static-spherem 0 0 0 4)
  :longest-edge (meters 0)
  :shadow 4
  )

(defbehavior robber-event-handler robber ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('attack)
     (go robber-die)
     )
    )
  )

(defbehavior robber-task-complete? robber ()
  (local-vars (sv-16 symbol))
  (process-entity-status! self (entity-perm-status complete) #t)
  (when (or (-> self link prev) (-> self link next))
    (set! sv-16 (the-as symbol #f))
    (apply-all (-> self link) actor-link-subtask-complete-hook (& sv-16))
    (cond
      (sv-16
        (close-specific-task! (-> self entity extra perm task) (task-status need-reminder))
        (format #t "robber task is complete~%")
        )
      (else
        )
      )
    sv-16
    )
  )

(defbehavior robber-find-ground robber ()
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    (set! (-> gp-0 quad) (-> self root-override trans quad))
    (let ((t2-0 (new 'stack-no-clear 'collide-tri-result)))
      (set! (-> gp-0 y) (+ 8192.0 (-> gp-0 y)))
      (let ((f0-2 (dummy-10 *collide-cache* gp-0 (new 'static 'vector :y -81920.0 :w 1.0) 40.96 1 self t2-0 1))
            (v1-5 (new 'stack-no-clear 'vector))
            )
        (set! (-> v1-5 quad) (-> self root-override trans quad))
        (set! (-> v1-5 y) (+ (-> gp-0 y) (* -81920.0 f0-2)))
        (cond
          ((and (>= f0-2 0.0) (< 204.8 (fabs (- (-> v1-5 y) (-> self water-height)))))
           (set! (-> self y-offset-desired)
                 (- (+ (-> gp-0 y) (* -81920.0 f0-2)) (- (-> self root-override trans y) (-> self y-offset)))
                 )
           #t
           )
          (else
            (set! (-> self y-offset-desired) 0.0)
            #f
            )
          )
        )
      )
    )
  )

(defbehavior robber-rotate robber ((arg0 target) (arg1 float))
  (let ((s5-0 (new 'stack-no-clear 'matrix))
        (gp-0 (new 'stack-no-clear 'vector))
        )
    (TODO-RENAME-14 (-> self path) (-> self tangent) (-> self curve-position))
    (cond
      ((and arg0 *target*)
       (vector-! gp-0 (-> self root-override trans) (target-pos 0))
       (vector-normalize! gp-0 1.0)
       )
      ((< (-> self speed) 0.0)
       (vector-negate! gp-0 (-> self tangent))
       )
      (else
        (set! (-> gp-0 quad) (-> self tangent quad))
        )
      )
    (matrix-from-two-vectors-max-angle-partial! s5-0 (-> self facing) gp-0 arg1 0.25)
    (vector-matrix*! gp-0 (-> self facing) s5-0)
    (vector-normalize! gp-0 1.0)
    (forward-down->inv-matrix s5-0 gp-0 (new 'static 'vector :y -1.0))
    (matrix->quaternion (-> self root-override quat) s5-0)
    (set! (-> self run-blend-interp) (acos (vector-dot gp-0 (-> self facing))))
    (set! (-> self run-blend-interp) (* 0.0002746582 (-> self run-blend-interp)))
    (if (< (vector-dot (-> self facing) (the-as vector (-> s5-0 vector))) 0.0)
        (set! (-> self run-blend-interp) (- (-> self run-blend-interp)))
        )
    (let ((v0-10 (-> self facing)))
      (set! (-> v0-10 quad) (-> gp-0 quad))
      v0-10
      )
    )
  )

(defbehavior robber-move robber ()
  (+! (-> self curve-position)
      (/ (the float
              (* (- (-> *display* base-frame-counter) (-> *display* old-base-frame-counter)) (the int (-> self speed)))
              )
         (path-distance (-> self path))
         )
      )
  (cond
    ((< 1.0 (-> self curve-position))
     (set! (-> self curve-position) (+ -1.0 (-> self curve-position)))
     )
    ((< (-> self curve-position) 0.0)
     (set! (-> self curve-position) (+ 1.0 (-> self curve-position)))
     )
    )
  (eval-path-curve! (-> self path) (-> self root-override trans) (-> self curve-position) 'interp)
  (cond
    ((< (-> self y-offset-desired) (-> self y-offset))
     (set! (-> self y-vel) (* 0.25 (- (-> self y-offset-desired) (-> self y-offset))))
     (set! (-> self y-vel) (fmax -3.4133334 (-> self y-vel)))
     (+! (-> self y-offset) (-> self y-vel))
     (when (>= (-> self y-offset-desired) (-> self y-offset))
       (set! (-> self y-offset) (-> self y-offset-desired))
       (set! (-> self y-vel) 0.0)
       )
     )
    ((< (-> self y-offset) (-> self y-offset-desired))
     (set! (-> self y-vel) (* 0.5 (- (-> self y-offset-desired) (-> self y-offset))))
     (set! (-> self y-vel) (fmin 13.653334 (-> self y-vel)))
     (+! (-> self y-offset) (-> self y-vel))
     (when (>= (-> self y-offset) (-> self y-offset-desired))
       (set! (-> self y-offset) (-> self y-offset-desired))
       (set! (-> self y-vel) 0.0)
       )
     )
    )
  (let ((f0-34 (+ (-> self root-override trans y) (-> self y-offset))))
    (set! (-> self root-override trans y) f0-34)
    f0-34
    )
  )

(defbehavior robber-calc-speed robber ((arg0 float) (arg1 float) (arg2 float) (arg3 float) (arg4 symbol))
  (let ((gp-1 (vector-! (new 'stack-no-clear 'vector) (-> self root-override trans) (target-pos 0))))
    (set! (-> gp-1 y) 0.0)
    (let* ((f2-1 (/ (- (vector-length gp-1) arg0) (- arg1 arg0)))
           (f0-4 (- 1.0 (fmax 0.0 (fmin 1.0 f2-1))))
           (f0-5 (lerp arg3 arg2 f0-4))
           (f30-0 (* 0.0033333334 f0-5))
           )
      (cond
        ((or (not arg4) (< arg0 (vector-length gp-1)))
         (if (< (-> self speed) 0.0)
             (set! f30-0 (- f30-0))
             )
         )
        ((< (vector-dot gp-1 (-> self tangent)) 0.0)
         (set! f30-0 (- f30-0))
         )
        )
      (set! (-> self speed) f30-0)
      f30-0
      )
    )
  )

(defbehavior robber-calc-anim-speed robber ()
  (let* ((f0-1 (fabs (-> self speed)))
         (f0-2 (* 0.07324219 f0-1))
         (f0-3 (+ -15.0 f0-2))
         (f1-3 (* 0.13333334 f0-3))
         )
    (fmin 1.5 (fmax 0.9 f1-3))
    )
  )

(defstate robber-debug (robber)
  :code
  (behavior ()
    (while #t
      (let ((a0-0 (-> self skel root-channel 0)))
        (set! (-> a0-0 frame-group) (if (> (-> self skel active-channels) 0)
                                        (-> self skel root-channel 0 frame-group)
                                        )
              )
        (set! (-> a0-0 param 0) (the float (+ (-> (if (> (-> self skel active-channels) 0)
                                                      (-> self skel root-channel 0 frame-group)
                                                      )
                                                  data
                                                  0
                                                  length
                                                  )
                                              -1
                                              )
                                     )
              )
        (set! (-> a0-0 param 1) 1.0)
        (set! (-> a0-0 frame-num) 0.0)
        (joint-control-channel-group!
          a0-0
          (if (> (-> self skel active-channels) 0)
              (-> self skel root-channel 0 frame-group)
              )
          num-func-seek!
          )
        )
      (until (ja-done? 0)
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (let ((a1-1 (new 'stack-no-clear 'vector)))
            (clmf-input gp-0 a1-1 1)
            )
          (format *stdcon* "rv ~f ~f ~f~%" (-> gp-0 x) (-> gp-0 y) (-> gp-0 z))
          (vector-float*! gp-0 gp-0 4096.0)
          (+! (-> self curve-position) (/ (-> gp-0 y) (path-distance (-> self path))))
          )
        (cond
          ((< 1.0 (-> self curve-position))
           (set! (-> self curve-position) (+ -1.0 (-> self curve-position)))
           )
          ((< (-> self curve-position) 0.0)
           (set! (-> self curve-position) (+ 1.0 (-> self curve-position)))
           )
          )
        (eval-path-curve! (-> self path) (-> self root-override trans) (-> self curve-position) 'interp)
        (robber-rotate (the-as target #f) 1820.4445)
        (robber-find-ground)
        (suspend)
        (let ((a0-7 (-> self skel root-channel 0)))
          (set! (-> a0-7 param 0) (the float (+ (-> a0-7 frame-group data 0 length) -1)))
          (set! (-> a0-7 param 1) 1.0)
          (joint-control-channel-group-eval! a0-7 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      )
    (none)
    )
  :post
  (the-as (function none :behavior robber) ja-post)
  )

(defstate robber-dead (robber)
  :code
  (behavior ()
    (dummy-18 self)
    (deactivate self)
    (none)
    )
  )

(defstate robber-die (robber)
  :event
  (the-as
    (function process int symbol event-message-block object :behavior robber)
    process-drawable-death-event-handler
    )
  :code
  (behavior ()
    (let ((gp-0 #t))
      (when (robber-task-complete?)
        (let ((v1-3 (-> self entity extra perm)))
          (logior! (-> v1-3 status) (entity-perm-status user-set-from-cstage))
          (cond
            ((zero? (-> v1-3 user-object 1))
             (set! (-> v1-3 user-object 1) 1)
             (set! (-> v1-3 user-object 0) (-> self curve-position))
             (let ((f30-0 (if (>= (-> self speed) 0.0)
                              163840.0
                              -163840.0
                              )
                          )
                   (s5-0 (get-process *default-dead-pool* fuel-cell #x4000))
                   )
               (when s5-0
                 (let ((t9-2 (method-of-type fuel-cell activate)))
                   (t9-2 (the-as fuel-cell s5-0) self 'fuel-cell (the-as pointer #x70004000))
                   )
                 (run-now-in-process
                   s5-0
                   fuel-cell-init-as-spline-slider
                   (process->handle self)
                   (-> self curve-position)
                   f30-0
                   (-> self entity extra perm task)
                   )
                 (-> s5-0 ppointer)
                 )
               )
             )
            (else
              (set! gp-0 #f)
              (logior! (-> self draw status) (draw-status drwf01))
              (let ((s5-1 (new 'stack-no-clear 'vector)))
                (eval-path-curve! (-> self path) s5-1 (the-as float (-> v1-3 user-object 0)) 'interp)
                (set! (-> s5-1 y) (+ 8192.0 (-> s5-1 y)))
                (birth-pickup-at-point
                  s5-1
                  (pickup-type fuel-cell)
                  (the float (-> self entity extra perm task))
                  #f
                  self
                  (the-as fact-info #f)
                  )
                )
              )
            )
          )
        )
      (when gp-0
        (let ((a0-12 (-> self skel root-channel 0)))
          (set! (-> a0-12 frame-group) (the-as art-joint-anim (-> self draw art-group data 8)))
          (set! (-> a0-12 param 0)
                (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 8)) data 0 length) -1))
                )
          (set! (-> a0-12 param 1) 1.0)
          (set! (-> a0-12 frame-num) 0.0)
          (joint-control-channel-group! a0-12 (the-as art-joint-anim (-> self draw art-group data 8)) num-func-seek!)
          )
        (until (ja-done? 0)
          (robber-calc-speed 4096.0 8192.0 122880.0 122880.0 #f)
          (robber-move)
          (robber-rotate (the-as target #f) 1820.4445)
          (suspend)
          (let ((a0-15 (-> self skel root-channel 0)))
            (set! (-> a0-15 param 0) (the float (+ (-> a0-15 frame-group data 0 length) -1)))
            (set! (-> a0-15 param 1) 1.0)
            (joint-control-channel-group-eval! a0-15 (the-as art-joint-anim #f) num-func-seek!)
            )
          )
        )
      )
    (while (-> self child)
      (suspend)
      )
    (go robber-dead)
    (none)
    )
  :post
  (the-as (function none :behavior robber) transform-post)
  )

(defstate robber-got-away (robber)
  :event
  robber-event-handler
  :trans
  (behavior ()
    (if (and (not (and *target*
                       (>= 204800.0 (vector-vector-xz-distance (-> self root-override trans) (-> *target* control trans)))
                       )
                  )
             (robber-find-ground)
             )
        (go robber-idle)
        )
    (if (and *target*
             (>= 122880.0 (vector-vector-xz-distance (-> self root-override trans) (-> *target* control trans)))
             )
        (go robber-flee)
        )
    (none)
    )
  :code
  (behavior ()
    (when (not (= (if (> (-> self skel active-channels) 0)
                      (-> self skel root-channel 0 frame-group)
                      )
                  (-> self draw art-group data 7)
                  )
               )
      (ja-channel-push! 1 60)
      (let ((v1-8 (-> self skel root-channel 0)))
        (set! (-> v1-8 frame-group) (the-as art-joint-anim (-> self draw art-group data 7)))
        )
      )
    (while #t
      (let ((gp-0 (-> self skel root-channel 0)))
        (set! (-> gp-0 param 0) (robber-calc-anim-speed))
        (joint-control-channel-group-eval! gp-0 (the-as art-joint-anim #f) num-func-loop!)
        )
      (if (< 27.306667 (fabs (-> self speed)))
          (set! (-> self speed) (* 0.95 (-> self speed)))
          )
      (robber-move)
      (robber-rotate (the-as target #f) 1820.4445)
      (suspend)
      )
    (none)
    )
  :post
  (the-as (function none :behavior robber) transform-post)
  )

(defstate robber-tired (robber)
  :event
  robber-event-handler
  :enter
  (behavior ()
    (set! (-> self y-offset-desired) -12288.0)
    (none)
    )
  :exit
  (behavior ()
    (set! (-> self y-offset-desired) 0.0)
    (none)
    )
  :trans
  (behavior ()
    (if (not (and *target*
                  (>= 163840.0 (vector-vector-xz-distance (-> self root-override trans) (-> *target* control trans)))
                  )
             )
        (go robber-got-away)
        )
    (none)
    )
  :code
  (behavior ()
    (while #t
      (when (not (= (if (> (-> self skel active-channels) 0)
                        (-> self skel root-channel 0 frame-group)
                        )
                    (-> self draw art-group data 7)
                    )
                 )
        (ja-channel-push! 1 60)
        (let ((v1-8 (-> self skel root-channel 0)))
          (set! (-> v1-8 frame-group) (the-as art-joint-anim (-> self draw art-group data 7)))
          )
        )
      (let ((gp-0 (-> self skel root-channel 0)))
        (set! (-> gp-0 param 0) (robber-calc-anim-speed))
        (joint-control-channel-group-eval! gp-0 (the-as art-joint-anim #f) num-func-loop!)
        )
      (robber-calc-speed 32768.0 122880.0 122060.8 20480.0 #f)
      (robber-move)
      (robber-rotate (the-as target #f) 1820.4445)
      (suspend)
      (when (>= (- (-> *display* base-frame-counter) (the-as int (-> self last-ambient-time)))
                (the-as int (-> self time-to-next-ambient))
                )
        (ja-channel-push! 1 60)
        (let ((a0-14 (-> self skel root-channel 0)))
          (set! (-> a0-14 frame-group) (the-as art-joint-anim (-> self draw art-group data 11)))
          (set! (-> a0-14 param 0)
                (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 11)) data 0 length) -1))
                )
          (set! (-> a0-14 param 1) 1.0)
          (set! (-> a0-14 frame-num) 0.0)
          (joint-control-channel-group! a0-14 (the-as art-joint-anim (-> self draw art-group data 11)) num-func-seek!)
          )
        (until (ja-done? 0)
          (robber-calc-speed 32768.0 122880.0 122060.8 20480.0 #f)
          (robber-move)
          (robber-rotate (the-as target #f) 1820.4445)
          (suspend)
          (let ((a0-17 (-> self skel root-channel 0)))
            (set! (-> a0-17 param 0) (the float (+ (-> a0-17 frame-group data 0 length) -1)))
            (set! (-> a0-17 param 1) 1.0)
            (joint-control-channel-group-eval! a0-17 (the-as art-joint-anim #f) num-func-seek!)
            )
          )
        (set! (-> self last-ambient-time) (the-as uint (-> *display* base-frame-counter)))
        (let* ((f30-0 300.0)
               (f28-0 2.0)
               (f26-0 2.0)
               (v1-41 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-42 (the-as number (logior #x3f800000 v1-41)))
               )
          (set! (-> self time-to-next-ambient)
                (the-as uint (the int (* f30-0 (+ f28-0 (* f26-0 (+ -1.0 (the-as float v1-42)))))))
                )
          )
        )
      )
    (none)
    )
  :post
  (the-as (function none :behavior robber) transform-post)
  )

(defstate robber-flee (robber)
  :event
  robber-event-handler
  :enter
  (behavior ()
    (set! (-> self near-timer) 3000)
    (set! (-> self far-time) (the-as uint (-> *display* base-frame-counter)))
    (set! (-> self y-offset-desired) 0.0)
    (none)
    )
  :trans
  (behavior ()
    (if (not (and *target*
                  (>= 163840.0 (vector-vector-xz-distance (-> self root-override trans) (-> *target* control trans)))
                  )
             )
        (go robber-got-away)
        )
    (when (and *target*
               (>= 102400.0 (vector-vector-xz-distance (-> self root-override trans) (-> *target* control trans)))
               )
      (set! (-> self near-timer)
            (- (-> self near-timer) (- (-> *display* base-frame-counter) (-> *display* old-base-frame-counter)))
            )
      (if (<= (-> self near-timer) 0)
          (go robber-tired)
          )
      (set! (-> self far-time) (the-as uint (-> *display* base-frame-counter)))
      )
    (if (>= (- (-> *display* base-frame-counter) (the-as int (-> self far-time))) 900)
        (set! (-> self near-timer) (the-as int (-> self timeout)))
        )
    (none)
    )
  :code
  (behavior ()
    (while #t
      (when (not (= (if (> (-> self skel active-channels) 0)
                        (-> self skel root-channel 0 frame-group)
                        )
                    (-> self draw art-group data 7)
                    )
                 )
        (ja-channel-push! 1 60)
        (let ((v1-8 (-> self skel root-channel 0)))
          (set! (-> v1-8 frame-group) (the-as art-joint-anim (-> self draw art-group data 7)))
          )
        )
      (let ((gp-0 (-> self skel root-channel 0)))
        (set! (-> gp-0 param 0) (robber-calc-anim-speed))
        (joint-control-channel-group-eval! gp-0 (the-as art-joint-anim #f) num-func-loop!)
        )
      (robber-calc-speed 61440.0 122880.0 204800.0 16384.0 #t)
      (robber-move)
      (robber-rotate (the-as target #f) 1820.4445)
      (suspend)
      (when (>= (- (-> *display* base-frame-counter) (the-as int (-> self last-ambient-time)))
                (the-as int (-> self time-to-next-ambient))
                )
        (ja-channel-push! 1 60)
        (let ((a0-14 (-> self skel root-channel 0)))
          (set! (-> a0-14 frame-group) (the-as art-joint-anim (-> self draw art-group data 11)))
          (set! (-> a0-14 param 0)
                (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 11)) data 0 length) -1))
                )
          (set! (-> a0-14 param 1) 1.0)
          (set! (-> a0-14 frame-num) 0.0)
          (joint-control-channel-group! a0-14 (the-as art-joint-anim (-> self draw art-group data 11)) num-func-seek!)
          )
        (until (ja-done? 0)
          (robber-calc-speed 61440.0 122880.0 204800.0 16384.0 #t)
          (robber-move)
          (robber-rotate (the-as target #f) 1820.4445)
          (suspend)
          (let ((a0-17 (-> self skel root-channel 0)))
            (set! (-> a0-17 param 0) (the float (+ (-> a0-17 frame-group data 0 length) -1)))
            (set! (-> a0-17 param 1) 1.0)
            (joint-control-channel-group-eval! a0-17 (the-as art-joint-anim #f) num-func-seek!)
            )
          )
        (set! (-> self last-ambient-time) (the-as uint (-> *display* base-frame-counter)))
        (let* ((f30-0 300.0)
               (f28-0 3.0)
               (f26-0 5.0)
               (v1-41 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-42 (the-as number (logior #x3f800000 v1-41)))
               )
          (set! (-> self time-to-next-ambient)
                (the-as uint (the int (* f30-0 (+ f28-0 (* f26-0 (+ -1.0 (the-as float v1-42)))))))
                )
          )
        )
      )
    (none)
    )
  :post
  (the-as (function none :behavior robber) transform-post)
  )

(defstate robber-idle (robber)
  :event
  robber-event-handler
  :enter
  (behavior ()
    (set! (-> self speed) 0.0)
    (none)
    )
  :trans
  (behavior ()
    (if (and *target*
             (>= 122880.0 (vector-vector-xz-distance (-> self root-override trans) (-> *target* control trans)))
             )
        (go robber-flee)
        )
    (robber-rotate (the-as target #t) 182.04445)
    (robber-move)
    (none)
    )
  :code
  (behavior ()
    (ja-channel-push! 1 60)
    (while #t
      (let ((a0-1 (-> self skel root-channel 0)))
        (set! (-> a0-1 frame-group) (the-as art-joint-anim (-> self draw art-group data 10)))
        (set! (-> a0-1 param 0)
              (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 10)) data 0 length) -1))
              )
        (set! (-> a0-1 param 1) 1.0)
        (set! (-> a0-1 frame-num) 0.0)
        (joint-control-channel-group! a0-1 (the-as art-joint-anim (-> self draw art-group data 10)) num-func-seek!)
        )
      (until (ja-done? 0)
        (suspend)
        (let ((a0-2 (-> self skel root-channel 0)))
          (set! (-> a0-2 param 0) (the float (+ (-> a0-2 frame-group data 0 length) -1)))
          (set! (-> a0-2 param 1) 1.0)
          (joint-control-channel-group-eval! a0-2 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      )
    (none)
    )
  :post
  (the-as (function none :behavior robber) transform-post)
  )

(defstate robber-initial-notice (robber)
  :event
  robber-event-handler
  :trans
  (behavior ()
    (when (logtest? (-> self draw status) (draw-status drwf03))
      (if (and *target*
               (>= 163840.0 (vector-vector-distance (-> self root-override trans) (-> *target* control trans)))
               )
          (level-hint-spawn
            (game-text-id rolling-flying-lurker-intro)
            "sksp0116"
            (the-as entity #f)
            *entity-pool*
            (game-task none)
            )
          )
      )
    (if (and *target*
             (>= 32768.0 (vector-vector-xz-distance (-> self root-override trans) (-> *target* control trans)))
             )
        (go robber-flee)
        )
    (none)
    )
  :code
  (behavior ()
    (TODO-RENAME-14 (-> self path) (-> self tangent) (-> self curve-position))
    (let ((gp-1 (vector-! (new 'stack-no-clear 'vector) (-> self root-override trans) (target-pos 0)))
          (f0-1 6.826667)
          )
      (set! (-> gp-1 y) 0.0)
      (if (< (vector-dot gp-1 (-> self tangent)) 0.0)
          (set! f0-1 (- f0-1))
          )
      (set! (-> self speed) f0-1)
      )
    (ja-channel-push! 1 60)
    (while #t
      (let ((a0-3 (-> self skel root-channel 0)))
        (set! (-> a0-3 frame-group) (the-as art-joint-anim (-> self draw art-group data 6)))
        (set! (-> a0-3 param 0)
              (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 6)) data 0 length) -1))
              )
        (set! (-> a0-3 param 1) 2.0)
        (set! (-> a0-3 frame-num) 0.0)
        (joint-control-channel-group! a0-3 (the-as art-joint-anim (-> self draw art-group data 6)) num-func-seek!)
        )
      (until (ja-done? 0)
        (robber-calc-speed 61440.0 122880.0 2048.0 2048.0 #t)
        (robber-rotate (the-as target #f) 1820.4445)
        (suspend)
        (let ((a0-6 (-> self skel root-channel 0)))
          (set! (-> a0-6 param 0) (the float (+ (-> a0-6 frame-group data 0 length) -1)))
          (set! (-> a0-6 param 1) 2.0)
          (joint-control-channel-group-eval! a0-6 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      (go robber-flee)
      )
    (none)
    )
  :post
  (the-as (function none :behavior robber) transform-post)
  )

(defstate robber-initial (robber)
  :event
  robber-event-handler
  :enter
  (behavior ()
    (set! (-> self speed) 0.0)
    (none)
    )
  :trans
  (behavior ()
    (if (and *target*
             (>= 122880.0 (vector-vector-xz-distance (-> self root-override trans) (-> *target* control trans)))
             )
        (go robber-initial-notice)
        )
    (robber-move)
    (none)
    )
  :code
  (behavior ()
    (ja-channel-push! 1 60)
    (while #t
      (let ((a0-1 (-> self skel root-channel 0)))
        (set! (-> a0-1 frame-group) (the-as art-joint-anim (-> self draw art-group data 5)))
        (set! (-> a0-1 param 0)
              (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 5)) data 0 length) -1))
              )
        (set! (-> a0-1 param 1) 1.0)
        (set! (-> a0-1 frame-num) 0.0)
        (joint-control-channel-group! a0-1 (the-as art-joint-anim (-> self draw art-group data 5)) num-func-seek!)
        )
      (until (ja-done? 0)
        (suspend)
        (let ((a0-2 (-> self skel root-channel 0)))
          (set! (-> a0-2 param 0) (the float (+ (-> a0-2 frame-group data 0 length) -1)))
          (set! (-> a0-2 param 1) 1.0)
          (joint-control-channel-group-eval! a0-2 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      )
    (none)
    )
  :post
  (the-as (function none :behavior robber) transform-post)
  )

(defmethod init-from-entity! robber ((obj robber) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((s3-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid ca-10 ca-11))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 10240.0)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *robber-sg* '())
  (set! (-> obj root-override pause-adjust-distance) 122880.0)
  (set! (-> obj link) (new 'process 'actor-link-info obj))
  (set! (-> obj path) (new 'process 'curve-control obj 'path -1000000000.0))
  (logior! (-> obj path flags) (path-control-flag display draw-line draw-point draw-text))
  (set! (-> obj fact)
        (new 'process 'fact-info-enemy obj (pickup-type eco-pill-random) (-> *FACT-bank* default-pill-inc))
        )
  (set! (-> obj draw origin-joint-index) (the-as uint 3))
  (set! (-> obj curve-position) (res-lump-float (-> obj entity) 'initial-spline-pos))
  (eval-path-curve! (-> obj path) (-> obj root-override trans) (-> obj curve-position) 'interp)
  (TODO-RENAME-14 (-> obj path) (-> obj tangent) (-> obj curve-position))
  (set! (-> obj facing quad) (-> obj tangent quad))
  (let ((s4-1 (new 'stack-no-clear 'matrix)))
    (forward-down->inv-matrix s4-1 (-> obj facing) (new 'static 'vector :y -1.0))
    (matrix->quaternion (-> obj root-override quat) s4-1)
    )
  (set! (-> obj y-vel) 0.0)
  (set! (-> obj water-height) (res-lump-float (-> obj entity) 'water-height))
  (robber-find-ground)
  (set! (-> obj y-offset) (-> obj y-offset-desired))
  (let ((f0-14 (res-lump-float arg0 'timeout :default 10.0)))
    (set! (-> obj timeout) (the-as uint (the int (* 300.0 f0-14))))
    )
  (set! (-> obj last-ambient-time) (the-as uint 0))
  (set! (-> obj time-to-next-ambient) (the-as uint 0))
  (set! (-> obj speed) 0.0)
  (let ((v1-42 (-> obj entity extra perm)))
    (logior! (-> v1-42 status) (entity-perm-status user-set-from-cstage))
    (if (nonzero? (-> v1-42 user-object 1))
        (go robber-die)
        )
    )
  (if (and (-> obj entity) (logtest? (-> obj entity extra perm status) (entity-perm-status complete)))
      (go robber-dead)
      (go robber-initial)
      )
  (none)
  )




