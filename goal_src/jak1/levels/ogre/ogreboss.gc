;;-*-Lisp-*-
(in-package goal)
(bundles "OGR.DGO")
(require "engine/common-obs/generic-obs.gc")
(require "engine/collide/collide-cache.gc")
(require "engine/anim/joint-mod-h.gc")
(require "engine/physics/trajectory.gc")
(require "engine/camera/pov-camera-h.gc")
(declare-type ogreboss process-drawable)

(define-extern *ogreboss* ogreboss)

;; DECOMP BEGINS

(defskelgroup *ogreboss-sg*
  ogreboss
  ogreboss-lod0-jg
  ogreboss-idle-ja
  ((ogreboss-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 20))

(defskelgroup *ogreboss-cam-sg*
  ogreboss
  ogreboss-cam-lod0-jg
  ogreboss-cam-idle-ja
  ((ogreboss-cam-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 3))

(defskelgroup *ogreboss-shoot-boulder-sg*
  ogreboss
  ogreboss-shoot-boulder-lod0-jg
  ogreboss-shoot-boulder-idle-ja
  ((ogreboss-shoot-boulder-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 300)
  :shadow ogreboss-shoot-boulder-shadow-mg)

(defskelgroup *ogreboss-shoot-boulder-break-sg*
  ogreboss
  ogreboss-shoot-boulder-break-lod0-jg
  ogreboss-shoot-boulder-break-idle-ja
  ((ogreboss-shoot-boulder-break-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 15))

(defskelgroup *ogreboss-bounce-boulder-sg*
  ogreboss
  ogreboss-bounce-boulder-lod0-jg
  ogreboss-bounce-boulder-idle-ja
  ((ogreboss-bounce-boulder-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 50))

(defskelgroup *ogreboss-super-boulder-sg*
  ogreboss
  ogreboss-super-boulder-lod0-jg
  ogreboss-super-boulder-idle-ja
  ((ogreboss-super-boulder-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 8))

(defskelgroup *ogreboss-column-sg*
  ogreboss
  ogreboss-column-lod0-jg
  ogreboss-column-idle-ja
  ((ogreboss-column-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 30))

(define *ogreboss-missile-shadow-control*
  (new 'static
       'shadow-control
       :settings
       (new 'static
            'shadow-settings
            :flags (shadow-flags disable-fade shdf02 shdf03)
            :shadow-dir
            (new 'static 'vector :y -1.0 :w 614400.0)
            :bot-plane
            (new 'static 'plane :y 1.0 :w -102400.0)
            :top-plane
            (new 'static 'plane :y 1.0 :w -143360.0))))

(define *ogreboss-shadow-control*
  (new 'static
       'shadow-control
       :settings
       (new 'static
            'shadow-settings
            :flags (shadow-flags shdf02 shdf03)
            :shadow-dir
            (new 'static 'vector :y -1.0 :w 614400.0)
            :bot-plane
            (new 'static 'plane :y 1.0 :w -102400.0)
            :top-plane
            (new 'static 'plane :y 1.0 :w -143360.0)
            :fade-dist 819200.0)))

(deftype ogreboss-missile (process-drawable)
  ((root            collide-shape-moving :override)
   (parent-override (pointer process-drawable) :overlay-at parent)
   (trajectory      trajectory :inline)
   (src-pos         vector :inline)
   (dest-pos        vector :inline)
   (start-time      time-frame)
   (tumble-quat     quaternion :inline)
   (blast-radius    float)
   (pickup-type     pickup-type))
  (:states
   ogreboss-missile-idle
   ogreboss-missile-impact
   ogreboss-missile-seek))


(defstate ogreboss-missile-idle (ogreboss-missile)
  :enter
    (behavior ()
      (set-time! (-> self state-time)))
  :code
    (behavior ()
      (let ((gp-0 (new 'stack-no-clear 'vector))
            (s5-0 (new 'stack-no-clear 'vector))
            (s4-0 (new 'stack-no-clear 'collide-tri-result)))
        (while (not (time-elapsed? (-> self state-time) (seconds 6)))
          (let ((f0-1 (the float (- (current-time) (-> self start-time))))) (eval-position! (-> self trajectory) f0-1 gp-0))
          (vector-! s5-0 gp-0 (-> self root trans))
          (let ((f0-2 (fill-and-probe-using-line-sphere *collide-cache*
                                                        (-> self root trans)
                                                        s5-0
                                                        (the-as float 4096.0)
                                                        (-> self root root-prim collide-with)
                                                        (-> self parent-override 0)
                                                        s4-0
                                                        (new 'static 'pat-surface :noentity #x1))))
            (cond
              ((>= f0-2 0.0) (vector+*! (-> self root trans) (-> self root trans) s5-0 f0-2) (go ogreboss-missile-impact))
              (else (set! (-> self root trans quad) (-> gp-0 quad)) 0)))
          (quaternion*! (-> self root quat) (-> self root quat) (-> self tumble-quat))
          (spawn (-> self part) (-> self root trans))
          (suspend)))
      (cleanup-for-death self))
  :post transform-post)

(defstate ogreboss-missile-seek (ogreboss-missile)
  :code
    (behavior ()
      (let ((gp-0 (new 'stack-no-clear 'vector))
            (s5-0 (new 'stack-no-clear 'vector))
            (s4-0 (new 'stack-no-clear 'collide-tri-result)))
        (set-time! (-> self state-time))
        (until (time-elapsed? (-> self state-time) (seconds 2))
          (empty))
        (while (not (time-elapsed? (-> self state-time) (seconds 6)))
          (let ((f0-1 (the float (- (current-time) (-> self start-time))))) (eval-position! (-> self trajectory) f0-1 gp-0))
          (vector-! s5-0 gp-0 (-> self root trans))
          (let ((f0-2 (fill-and-probe-using-line-sphere *collide-cache*
                                                        (-> self root trans)
                                                        s5-0
                                                        (the-as float 4096.0)
                                                        (-> self root root-prim collide-with)
                                                        (-> self parent-override 0)
                                                        s4-0
                                                        (new 'static 'pat-surface :noentity #x1))))
            (cond
              ((>= f0-2 0.0) (vector+*! (-> self root trans) (-> self root trans) s5-0 f0-2) (go ogreboss-missile-impact))
              (else (set! (-> self root trans quad) (-> gp-0 quad)) 0)))
          (spawn (-> self part) (-> self root trans))
          (suspend)))
      (cleanup-for-death self))
  :post
    (behavior ()
      (quaternion*! (-> self root quat) (-> self root quat) (-> self tumble-quat))
      (transform-post)))

(defun ogreboss-rock-explosion-effect ((arg0 basic))
  (with-pp
    (sound-play "ogre-explode" :position (the-as symbol arg0))
    (process-spawn part-tracker :init part-tracker-init (-> *part-group-id-table* 471) -1 #f #f #f arg0 :to *entity-pool*)
    (activate! *camera-smush-control* (the-as float 819.2) 37 600 (the-as float 1.0) (the-as float 0.995))
    (let ((gp-2 (manipy-spawn arg0 (-> pp entity) *ogreboss-shoot-boulder-break-sg* #f :to pp)))
      (quaternion-axis-angle! (-> (the-as manipy (-> gp-2 0)) root quat)
                              (the-as float 0.0)
                              (the-as float 1.0)
                              (the-as float 0.0)
                              (* 65536.0 (rand-vu)))
      (send-event (ppointer->process gp-2) 'anim-mode 'play1)
      (the-as handle (ppointer->handle gp-2)))))

(defun ogreboss-missile-scale-explosion ((arg0 handle))
  (let* ((gp-0 (handle->process arg0))
         (f0-0 (-> (the-as process-drawable gp-0) root scale x))
         (f0-2 (seek f0-0 (the-as float 0.0) (seconds-per-frame))))
    (set-vector! (-> (the-as process-drawable gp-0) root scale) f0-2 f0-2 f0-2 1.0))
  0
  (none))

(defstate ogreboss-missile-impact (ogreboss-missile)
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('touched)
         (cond
           (#f
            (cond
              ((= (-> proc type) target) (send-event proc 'attack (-> block param 0) (static-attack-info ((mode 'explode)))))
              (else
               (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
                 (set! (-> a1-2 from) self)
                 (set! (-> a1-2 num-params) 4)
                 (set! (-> a1-2 message) 'attack)
                 (set! (-> a1-2 param 0) (-> block param 0))
                 (set! (-> a1-2 param 1) (the-as uint 'explode))
                 (let ((v1-12 (+ *global-attack-id* 1))) (set! *global-attack-id* v1-12) (set! (-> a1-2 param 2) (the-as uint v1-12)))
                 (set! (-> a1-2 param 3) (the-as uint 0))
                 (send-event-function proc a1-2))))
            (if (= (-> proc type) target) (send-event (ppointer->process (-> self parent-override)) 'victory)))
           (else
            (let* ((s4-0 proc)
                   (t1-0 (if (and (nonzero? s4-0) (type-type? (-> s4-0 type) target)) s4-0)))
              (cond
                (t1-0
                 (let ((s4-1 (new 'stack-no-clear 'vector))
                       (s3-0 (new 'stack-no-clear 'vector))
                       (t2-0 (new 'stack-no-clear 'collide-tri-result)))
                   0.0
                   (set! (-> s4-1 quad) (-> (the-as target t1-0) control trans quad))
                   (+! (-> s4-1 y) 4096.0)
                   (set-vector! s3-0 0.0 (- 118784.0 (-> s4-1 y)) 0.0 1.0)
                   (let ((f30-0 (fill-and-probe-using-line-sphere *collide-cache*
                                                                  s4-1
                                                                  s3-0
                                                                  (the-as float 40.96)
                                                                  (-> self root root-prim collide-with)
                                                                  t1-0
                                                                  t2-0
                                                                  (new 'static 'pat-surface :noentity #x1))))
                     (add-debug-vector #t
                                       (bucket-id debug-no-zbuf)
                                       s4-1
                                       s3-0
                                       (meters 0.00024414062)
                                       (the-as rgba (new 'static 'rgba :g #xff :a #x80)))
                     (when (>= f30-0 0.0)
                       (send-event proc 'attack (-> block param 0) (static-attack-info ((mode 'damage))))
                       (send-event (ppointer->process (-> self parent-override)) 'victory)))))
                (else
                 (let ((v1-37 (new 'stack-no-clear 'vector))) (set-vector! v1-37 0.0 -12288000.0 0.0 1.0) (send-event proc 'impulse v1-37))))))))))
  :code
    (behavior ()
      (logclear! (-> self mask) (process-mask enemy projectile))
      (ogreboss-rock-explosion-effect (the-as basic (-> self root trans)))
      (when (nonzero? (-> self pickup-type))
        (let ((t1-0 (new 'static 'fact-info :options (fact-options fade) :fade-time (seconds 5))))
          (birth-pickup-at-point (-> self root trans) (-> self pickup-type) (-> *FACT-bank* eco-single-inc) #t *entity-pool* t1-0)))
      (ja-channel-set! 0)
      (let ((v1-10 (-> self root root-prim)))
        (set! (-> v1-10 local-sphere w) (-> self blast-radius))
        (set! (-> v1-10 prim-core world-sphere w) (-> self blast-radius))
        (set! (-> v1-10 collide-with) (collide-kind cak-2 cak-3 target crate enemy wall-object ground-object))
        (set! (-> v1-10 prim-core collide-as) (collide-kind enemy)))
      (update-transforms! (-> self root))
      (let ((a1-1 (new 'stack-no-clear 'overlaps-others-params)))
        (set! (-> a1-1 options) (the-as uint 0))
        (set! (-> a1-1 tlist) *touching-list*)
        (find-overlapping-shapes (-> self root) a1-1))
      (suspend)
      (clear-collide-with-as (-> self root))
      (while (-> self child)
        (suspend))
      (cleanup-for-death self))
  :post ja-post)

(deftype ogreboss-missile-init-data (structure)
  ((src          vector)
   (dest         vector)
   (duration     time-frame)
   (xz-speed     float)
   (blast-radius float)
   (pickup-type  pickup-type)))


(defbehavior ogreboss-missile-init-by-other ogreboss-missile ((arg0 ogreboss-missile-init-data) (arg1 entity-actor))
  (set! (-> self entity) arg1)
  (let ((s5-0 (new 'process 'collide-shape-moving self (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction) (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (let ((s4-0 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 3))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s4-0 collide-with) (collide-kind background cak-2 target wall-object ground-object))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 prim-core offense) (collide-offense normal-attack))
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 12288.0)
      (set-root-prim! s5-0 s4-0))
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> self root) s5-0))
  (set! (-> self root trans quad) (-> arg0 src quad))
  (set! (-> self src-pos quad) (-> arg0 src quad))
  (set! (-> self dest-pos quad) (-> arg0 dest quad))
  (set! (-> self root quat vec quad) (-> self parent-override 0 root quat vec quad))
  (vector-identity! (-> self root scale))
  (initialize-skeleton self *ogreboss-shoot-boulder-sg* '())
  (logior! (-> self mask) (process-mask enemy projectile))
  (logclear! (-> self mask) (process-mask actor-pause))
  (set! (-> self draw shadow-ctrl) *ogreboss-missile-shadow-control*)
  (if (> (-> arg0 duration) 0)
    (setup-from-to-duration! (-> self trajectory)
                             (-> arg0 src)
                             (-> arg0 dest)
                             (the float (-> arg0 duration))
                             (the-as float -0.22755557))
    (setup-from-to-xz-vel! (-> self trajectory) (-> arg0 src) (-> arg0 dest) (-> arg0 xz-speed) (the-as float -0.22755557)))
  (set-time! (-> self start-time))
  (set! (-> self blast-radius) (-> arg0 blast-radius))
  (set! (-> self pickup-type) (-> arg0 pickup-type))
  (let ((f30-1 (* 65536.0 (rand-vu))))
    (quaternion-axis-angle! (-> self tumble-quat) (cos f30-1) (the-as float 0.0) (sin f30-1) (the-as float 2730.6667)))
  (set! (-> self part) (create-launch-control (-> *part-group-id-table* 469) self))
  (set-vector! (-> self draw color-emissive) 0.125 0.0625 0.0 0.0)
  (go ogreboss-missile-idle)
  (none))

(deftype ogreboss-super-boulder (process-drawable)
  ((root            collide-shape-moving :override)
   (parent-override (pointer process-drawable) :overlay-at parent)
   (orig-pos        vector :inline)
   (src-pos         vector :inline)
   (spin-axis       vector :inline)
   (joint           joint-mod-blend-local)
   (speed           float)
   (size            float)
   (grow-rate       float)
   (lava            entity-actor)
   (sound-id        sound-id)
   (hit-boss        symbol)
   (tumble-quat     quaternion :inline))
  (:states
   ogreboss-super-boulder-die
   ogreboss-super-boulder-hit
   ogreboss-super-boulder-idle
   ogreboss-super-boulder-killed-player
   ogreboss-super-boulder-land
   ogreboss-super-boulder-roll
   ogreboss-super-boulder-throw))


(defbehavior ogreboss-super-boulder-event-handler ogreboss-super-boulder ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    ;; og:preserve-this PAL patch here
    (('touch 'attack)
     (when (and *target*
                ((method-of-type touching-shapes-entry prims-touching?)
                 (the-as touching-shapes-entry (-> arg3 param 0))
                 (-> self root)
                 (the-as uint 1)))
       (if (send-event arg0 'attack-invinc (-> arg3 param 0) (static-attack-info ((mode 'ogreboss-super-boulder)))) #f)))
    (('effect)
     (case (-> arg3 param 0)
       (('lava-ripple)
        (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-3 from) self)
          (set! (-> a1-3 num-params) 0)
          (set! (-> a1-3 message) 'boulder)
          (let ((t9-3 send-event-function)
                (v1-12 (-> self lava)))
            (t9-3 (if v1-12 (-> v1-12 extra process)) a1-3))))
       (else #f)))))

(defstate ogreboss-super-boulder-idle (ogreboss-super-boulder)
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('speedup) (set! (-> self speed) (* 1.3 (-> self speed))))
        (('grow-faster) (set! (-> self grow-rate) 1.0))
        (('go-throw) (go ogreboss-super-boulder-throw))
        (('go-hit) (go ogreboss-super-boulder-hit))
        (('go-die) (go ogreboss-super-boulder-die))))
  :exit
    (behavior ()
      (sound-stop (-> self sound-id)))
  :code
    (behavior ()
      (ja :group! ogreboss-super-boulder-idle-ja :num! min)
      (set! (-> self joint enable) #t)
      (set! (-> self joint blend) 1.0)
      (set-time! (-> self state-time))
      (loop
        (quaternion-vector-angle! (-> self tumble-quat) (-> self spin-axis) (* 32768.0 (seconds-per-frame) (-> self speed)))
        (quaternion*! (-> self joint transform quat) (-> self joint transform quat) (-> self tumble-quat))
        (+! (-> self size) (* (-> self grow-rate) (seconds-per-frame)))
        (set! (-> self size) (fmin 1.0 (-> self size)))
        (let* ((f0-10 (sqrtf (-> self size)))
               (f28-0 (* 0.0033333334 (the float (- (current-time) (-> self state-time)))))
               (f30-0 (* 116508.445 f28-0 (-> self speed))))
          (set-vector! (-> self joint transform scale) f0-10 f0-10 f0-10 1.0)
          (let ((gp-1 (-> self joint transform)))
            (set! (-> gp-1 trans x) (* 4096.0 (sin f30-0)))
            (set! (-> gp-1 trans y) (+ 122880.0 (* 12288.0 (sin (* 98304.0 f28-0)))))
            (set! (-> gp-1 trans z) (* 4096.0 (cos f30-0)))
            (set! (-> gp-1 trans w) 1.0)))
        (spawn (-> self part) (-> self node-list data 3 bone transform vector 3))
        (sound-play "ogre-rock" :id (-> self sound-id) :position (the-as symbol (-> self joint transform)))
        (suspend)))
  :post transform-post)

(defbehavior ogreboss-super-boulder-impact-effect ogreboss-super-boulder ()
  (sound-play "ogre-boulder" :position (the-as symbol (-> self draw origin)))
  (activate! *camera-smush-control* (the-as float 819.2) 37 600 (the-as float 1.0) (the-as float 0.995))
  (process-spawn part-tracker
                 :init
                 part-tracker-init
                 (-> *part-group-id-table* 471)
                 -1
                 #f
                 #f
                 #f
                 (-> self draw origin)
                 :to
                 *entity-pool*)
  0
  (none))

(defbehavior ogreboss-super-boulder-play-hit-anim ogreboss-super-boulder ()
  (set! (-> self src-pos quad) (-> self root trans quad))
  (ja-no-eval :group! ogreboss-super-boulder-hit-ja :num! (seek!) :frame-num 0.0)
  (until (ja-done? 0)
    (seek! (-> self joint blend) (the-as float 0.0) (* 5.0 (seconds-per-frame)))
    (let* ((f1-1 (/ (- (ja-frame-num 0) (ja-aframe (the-as float 54.0) 0))
                    (- (the float (ja-num-frames 0)) (ja-aframe (the-as float 54.0) 0))))
           (f0-13 (fmax 0.0 (fmin 1.0 f1-1))))
      (vector-lerp! (-> self root trans) (-> self src-pos) (-> self orig-pos) f0-13))
    (suspend)
    (ja :num! (seek!)))
  0)

(defstate ogreboss-super-boulder-throw (ogreboss-super-boulder)
  :event ogreboss-super-boulder-event-handler
  :code
    (behavior ()
      (set! (-> self hit-boss) #f)
      (set! (-> self src-pos quad) (-> self root trans quad))
      (ja-no-eval :group! ogreboss-super-boulder-throw-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (seek! (-> self joint blend) (the-as float 0.0) (* 5.0 (seconds-per-frame)))
        (let* ((f1-1 (/ (- (ja-frame-num 0) (ja-aframe (the-as float 32.0) 0))
                        (- (the float (ja-num-frames 0)) (ja-aframe (the-as float 32.0) 0))))
               (f0-13 (fmax 0.0 (fmin 1.0 f1-1))))
          (vector-lerp! (-> self root trans) (-> self src-pos) (-> self orig-pos) f0-13))
        0
        (suspend)
        (ja :num! (seek!)))
      (go ogreboss-super-boulder-land))
  :post transform-post)

(defstate ogreboss-super-boulder-hit (ogreboss-super-boulder)
  :event ogreboss-super-boulder-event-handler
  :code
    (behavior ()
      (set! (-> self hit-boss) #t)
      (ogreboss-super-boulder-play-hit-anim)
      (go ogreboss-super-boulder-land))
  :post transform-post)

(defstate ogreboss-super-boulder-die (ogreboss-super-boulder)
  :event ogreboss-super-boulder-event-handler
  :code
    (behavior ()
      (ogreboss-super-boulder-play-hit-anim)
      (ogreboss-rock-explosion-effect (the-as basic (-> self draw origin)))
      (ogreboss-rock-explosion-effect (the-as basic (-> self draw origin)))
      (ja-channel-set! 0)
      (while (-> self child)
        (suspend))
      (cleanup-for-death self))
  :post transform-post)

(defstate ogreboss-super-boulder-land (ogreboss-super-boulder)
  :event ogreboss-super-boulder-event-handler
  :code
    (behavior ()
      (set! (-> self root trans quad) (-> self orig-pos quad))
      (ogreboss-super-boulder-impact-effect)
      (set! (-> self joint enable) #f)
      (ja-no-eval :group! ogreboss-super-boulder-roll-ja :num! (seek! (ja-aframe (the-as float 100.0) 0)) :frame-num 0.0)
      (until (ja-done? 0)
        (when (< 81920.0 (vector-vector-distance (the-as vector (-> self root root-prim prim-core)) (target-pos 0)))
          (ja-channel-push! 1 (seconds 0.1))
          (go ogreboss-super-boulder-roll))
        (suspend)
        (ja :num! (seek! (ja-aframe (the-as float 100.0) 0))))
      (go ogreboss-super-boulder-roll))
  :post
    (behavior ()
      (transform-post)
      0))

(defstate ogreboss-super-boulder-roll (ogreboss-super-boulder)
  :event ogreboss-super-boulder-event-handler
  :code
    (behavior ()
      (ogreboss-super-boulder-impact-effect)
      (ja-no-eval :group!
                  ogreboss-super-boulder-roll-ja
                  :num!
                  (seek! (ja-aframe (the-as float 162.0) 0))
                  :frame-num
                  (ja-aframe (the-as float 100.0) 0))
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! (ja-aframe (the-as float 162.0) 0))))
      (set! (-> self root root-prim local-sphere w) 28672.0)
      (cond
        ((-> self hit-boss)
         (while (let ((gp-2 (new 'stack-no-clear 'event-message-block)))
                  (set! (-> gp-2 from) self)
                  (set! (-> gp-2 num-params) 0)
                  (set! (-> gp-2 message) 'break)
                  (let ((s5-0 send-event-function)
                        (v1-22 (entity-actor-lookup (-> self entity) 'alt-actor 0)))
                    (not (s5-0 (if v1-22 (-> v1-22 extra process)) gp-2))))
           (suspend)))
        (else
         (while (let ((gp-3 (new 'stack-no-clear 'event-message-block)))
                  (set! (-> gp-3 from) self)
                  (set! (-> gp-3 num-params) 0)
                  (set! (-> gp-3 message) 'break-no-damage)
                  (let ((s5-1 send-event-function)
                        (v1-27 (entity-actor-lookup (-> self entity) 'alt-actor 0)))
                    (not (s5-1 (if v1-27 (-> v1-27 extra process)) gp-3))))
           (suspend))))
      (ja-no-eval :group! ogreboss-super-boulder-roll-ja :num! (seek!) :frame-num (ja-aframe (the-as float 162.0) 0))
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!)))
      (cleanup-for-death self))
  :post
    (behavior ()
      (transform-post)
      0))

(defmethod relocate ((this ogreboss-super-boulder) (offset int))
  (if (nonzero? (-> this joint)) (&+! (-> this joint) offset))
  (call-parent-method this offset))

(defstate ogreboss-super-boulder-killed-player (ogreboss-super-boulder)
  :code
    (behavior ()
      (clear-collide-with-as (-> self root))
      (ja-post)
      (loop
        (suspend))))

(defbehavior ogreboss-super-boulder-init-by-other ogreboss-super-boulder ((arg0 vector) (arg1 float) (arg2 entity-actor))
  (set! (-> self entity) arg2)
  (let ((s4-0 (new 'process 'collide-shape-moving self (collide-list-enum hit-by-others))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction) (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (let ((s3-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 3))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 40960.0)
      (set-root-prim! s4-0 s3-0))
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> self root) s4-0))
  (set! (-> self orig-pos quad) (-> arg0 quad))
  (set! (-> self root trans quad) (-> self parent-override 0 root trans quad))
  (set! (-> self root quat vec quad) (-> self parent-override 0 root quat vec quad))
  (vector-identity! (-> self root scale))
  (initialize-skeleton self *ogreboss-super-boulder-sg* '())
  ;; og:preserve-this PAL patch here
  (logclear! (-> self mask) (process-mask actor-pause enemy))
  (set! (-> self lava) (entity-actor-lookup (-> self entity) 'water-actor 0))
  (logior! (-> self skel effect flags) 1)
  (set! (-> self draw origin-joint-index) (the-as uint 3))
  (let ((f30-1 (* 65536.0 (rand-vu))))
    (quaternion-axis-angle! (-> self tumble-quat) (cos f30-1) (the-as float 0.0) (sin f30-1) (the-as float 2730.6667)))
  (set! (-> self joint) (new 'process 'joint-mod-blend-local self 3 #f))
  (set! (-> self part) (create-launch-control (-> *part-group-id-table* 468) self))
  (set-vector! (-> self draw color-emissive) 0.125 0.0625 0.0 0.0)
  (set! (-> self speed) 1.0)
  (set! (-> self size) 0.0)
  (set! (-> self grow-rate) (/ 300.0 arg1))
  (set! (-> self sound-id) (new-sound-id))
  (go ogreboss-super-boulder-idle)
  (none))

(deftype ogreboss-bounce-boulder (process-drawable)
  ((root            collide-shape-moving :override)
   (parent-override (pointer ogreboss-super-boulder) :overlay-at parent)
   (src-pos         vector :inline)
   (side-dir        vector :inline)
   (side-pos        float)
   (dest-pos        float)
   (boulder-type    int8))
  (:states
   ogreboss-bounce-boulder-idle))


(defbehavior ogreboss-bounce-boulder-event-handler ogreboss-bounce-boulder ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('touch)
     (if (and *target*
              ((method-of-type touching-shapes-entry prims-touching?)
               (the-as touching-shapes-entry (-> arg3 param 0))
               (-> self root)
               (the-as uint 1)))
       (send-event arg0 'attack (-> arg3 param 0) (new 'static 'attack-info))))))

(defstate ogreboss-bounce-boulder-idle (ogreboss-bounce-boulder)
  :event ogreboss-bounce-boulder-event-handler
  :code
    (behavior ()
      (set-time! (-> self state-time))
      (let ((f30-0 2.0))
        (ja-no-eval :group!
                    ogreboss-bounce-boulder-idle-ja
                    :num!
                    (seek! (ja-aframe (the-as float 40.0) 0) f30-0)
                    :frame-num 0.0)
        (until (ja-done? 0)
          (set! (-> self side-pos) (* (fmin 1.0 (/ (ja-frame-num 0) (ja-aframe (the-as float 40.0) 0))) (-> self dest-pos)))
          (suspend)
          (ja :num! (seek! (ja-aframe (the-as float 40.0) 0) f30-0)))
        (ja-no-eval :group!
                    ogreboss-bounce-boulder-idle-ja
                    :num! (seek! max f30-0)
                    :frame-num
                    (ja-aframe (the-as float 40.0) 0))
        (until (ja-done? 0)
          (if (>= (ja-frame-num 0) (ja-aframe (the-as float 235.0) 0))
            (seek! (-> self side-pos) (the-as float 0.0) (* 20480.0 (seconds-per-frame))))
          (suspend)
          (ja :num! (seek! max f30-0))))
      (cleanup-for-death self))
  :post
    (behavior ()
      (vector+*! (-> self root trans) (-> self src-pos) (-> self side-dir) (-> self side-pos))
      (transform-post)
      (find-ground-and-draw-shadow (the-as vector (-> self root root-prim prim-core))
                                   (the-as vector #f)
                                   (the-as float 49152.0)
                                   (collide-kind background)
                                   (the-as process-drawable #f)
                                   (the-as float 0.0)
                                   (the-as float 409600.0))))

(defbehavior ogreboss-bounce-boulder-init-by-other ogreboss-bounce-boulder ((arg0 int) (arg1 entity-actor))
  (set! (-> self entity) arg1)
  (let ((s5-0 (new 'process 'collide-shape-moving self (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction) (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (let ((s4-0 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 3))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 14336.0)
      (set-root-prim! s5-0 s4-0))
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> self root) s5-0))
  (set! (-> self boulder-type) arg0)
  (set! (-> self root trans quad) (-> self parent-override 0 root trans quad))
  (set! (-> self root quat vec quad) (-> self parent-override 0 root quat vec quad))
  (vector-identity! (-> self root scale))
  (set! (-> self src-pos quad) (-> self root trans quad))
  (set! (-> self side-pos) 0.0)
  (set! (-> self dest-pos)
        (the-as float
                (cond
                  ((zero? arg0) 0.0)
                  ((= arg0 1) -20480.0)
                  ((= arg0 2) 20480.0)
                  (else 0.0))))
  (vector-x-quaternion! (-> self side-dir) (-> self root quat))
  (initialize-skeleton self *ogreboss-bounce-boulder-sg* '())
  (logclear! (-> self mask) (process-mask actor-pause))
  (set! (-> self draw origin-joint-index) (the-as uint 3))
  (set-vector! (-> self draw color-emissive) 0.125 0.0625 0.0 0.0)
  (go ogreboss-bounce-boulder-idle)
  (none))

(deftype ogreboss (process-drawable)
  ((root                      collide-shape :override)
   (old-player-transform      transformq :inline)
   (level                     float)
   (difficulty                float)
   (boulder                   handle)
   (column                    handle)
   (z-plane                   vector :inline)
   (far-pos                   vector :inline)
   (near-pos                  vector :inline)
   (side-dir                  vector :inline)
   (target-offset-array       vector 3 :inline)
   (target-offset-array-2     vector :inline :overlay-at (-> target-offset-array 1))
   (target-offset-array-3     vector :inline :overlay-at (-> target-offset-array 2))
   (target-actor-array        entity-actor 3)
   (target-blast-radius-array float 3)
   (shuffle-pos               float)
   (target-count              int8)
   (hit-count                 int8)
   (max-hit-count             int8)
   (roll-boulder              int8)
   (try-count                 uint8)
   (hit-time                  time-frame)
   (grow-time                 float)
   (lava                      entity-actor)
   (vulnerable                symbol)
   (bridge-assembled          symbol)
   (at-near-spot              symbol)
   (submerged                 symbol)
   (try-counted               symbol))
  (:states
   ogreboss-dead
   ogreboss-die
   ogreboss-idle
   ogreboss-intro
   ogreboss-stage1
   ogreboss-stage2
   ogreboss-stage3-hit
   ogreboss-stage3-shuffle
   ogreboss-stage3-throw
   ogreboss-wait-for-player))


(defbehavior ogreboss-inc-try-count ogreboss ()
  (when (not (-> self try-counted))
    (set! (-> self try-counted) #t)
    (let ((gp-0 (-> self entity extra perm)))
      (logior! (-> gp-0 status) (entity-perm-status user-set-from-cstage))
      (seekl! (-> gp-0 user-int8 0) 255 1)
      (set! (-> self try-count) (the-as uint (-> gp-0 user-int8 0)))))
  0
  (none))

(defbehavior ogreboss-player-inside-range? ogreboss ((arg0 float))
  (< (vector-vector-distance (-> self far-pos) (target-pos 0)) arg0))

(defun ogreboss-set-stage1-camera ()
  0
  (none))

(defun ogreboss-set-stage2-camera ()
  0
  (none))

(defun ogreboss-reset-camera ()
  0
  (none))

(defbehavior ogreboss-idle-loop ogreboss ()
  (loop
    (ja-channel-push! 1 (seconds 0.1))
    (let ((v1-0 (rand-vu-int-range 0 2)))
      (cond
        ((zero? v1-0)
         (ja-no-eval :group! ogreboss-idle-ja :num! (seek! (ja-aframe (the-as float 140.0) 0)) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek! (ja-aframe (the-as float 140.0) 0))))
         (suspend-for (seconds 0.167))
         (ja-no-eval :group!
                     ogreboss-idle-ja
                     :num!
                     (seek! (ja-aframe (the-as float 168.0) 0))
                     :frame-num
                     (ja-aframe (the-as float 140.0) 0))
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek! (ja-aframe (the-as float 168.0) 0))))
         (suspend-for (seconds 0.167))
         (ja-no-eval :group! ogreboss-idle-ja :num! (seek!) :frame-num (ja-aframe (the-as float 168.0) 0))
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek!))))
        ((= v1-0 1)
         (ja-no-eval :group! ogreboss-idle-alt-ja :num! (seek!) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek!))))
        (else
         (dotimes (gp-7 4)
           (ja-no-eval :group! ogreboss-idle-bored-ja :num! (seek!) :frame-num 0.0)
           (until (ja-done? 0)
             (suspend)
             (ja :num! (seek!))))))))
  (the-as none 0)
  (none))

(defstate ogreboss-idle (ogreboss)
  :enter
    (behavior ()
      (when (zero? (-> self try-count))
        (let ((gp-0 (manipy-spawn (-> self root trans) (-> self entity) *ogreboss-column-sg* #f :to self)))
          (set! (-> self column) (ppointer->handle gp-0))
          (send-event (ppointer->process gp-0) 'anim-mode 'loop)
          (send-event (ppointer->process gp-0) 'art-joint-anim "ogreboss-column-idle" 0)
          (send-event (ppointer->process gp-0) 'draw #t))))
  :trans
    (behavior ()
      (try-preload-stream *art-control* "$GAMCAM23" 0 self (the-as float -99.0))
      (when *target*
        (let ((gp-0 (-> *target* control trans)))
          (if (and (< 122880.0 (-> gp-0 y))
                   (< (-> gp-0 x) 892928.0)
                   (and (ogreboss-player-inside-range? (the-as float 737280.0)) (< 0.0 (vector4-dot gp-0 (-> self z-plane)))))
            (go ogreboss-intro)))))
  :code
    (behavior ()
      (ogreboss-reset-camera)
      (ogreboss-idle-loop))
  :post ja-post)

(defstate ogreboss-intro (ogreboss)
  :code
    (behavior ()
      (when (zero? (-> self try-count))
        (process-drawable-delay-player (seconds 1))
        (let ((gp-0 (get-process *default-dead-pool* pov-camera #x4000)))
          (ppointer->handle (when gp-0
                              (let ((t9-2 (method-of-type pov-camera activate)))
                                (t9-2 (the-as pov-camera gp-0) self 'pov-camera (the-as pointer #x70004000)))
                              (run-now-in-process gp-0
                                                  pov-camera-init-by-other
                                                  (-> self root trans)
                                                  *ogreboss-cam-sg*
                                                  "ogreboss-cam-intro"
                                                  0
                                                  #f
                                                  '((0 setting-reset music ogreboss) (2 ambient camera "gamcam23")))
                              (-> gp-0 ppointer))))
        (send-event (handle->process (-> self column)) 'anim-mode 'play1)
        (send-event (handle->process (-> self column)) 'art-joint-anim "ogreboss-column-intro" 0)
        (ja-no-eval :group! ogreboss-intro-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!)))
        (close-specific-task! (game-task ogre-boss) (task-status need-hint))
        (suspend)
        (send-event *target* 'continue (get-continue-by-name *game-info* "ogre-start"))
        (ogreboss-inc-try-count))
      (set-setting! 'music 'ogreboss 0.0 0)
      (go ogreboss-wait-for-player))
  :post ja-post)

(defstate ogreboss-wait-for-player (ogreboss)
  :trans
    (behavior ()
      (when *target*
        (if (ogreboss-player-inside-range? (the-as float 614400.0)) (go ogreboss-stage1))
        (if (not (ogreboss-player-inside-range? (the-as float 737280.0))) (go ogreboss-idle))))
  :code
    (behavior ()
      (ogreboss-idle-loop))
  :post ja-post)

(defun ogreboss-debug-adjust-difficulty ()
  0
  (none))

(defbehavior ogreboss-pick-target ogreboss ()
  (local-vars (gp-0 int))
  (cond
    ((rand-vu-percent? (the-as float 0.4)) (set! gp-0 (rand-vu-int-range 0 (+ (-> self target-count) -1))))
    (else
     (set! gp-0 0)
     (let ((f30-0 4096000.0)
           (s5-0 (target-pos 0)))
       (dotimes (s4-0 (-> self target-count))
         (let* ((v1-6 (-> self target-actor-array s4-0))
                (s3-0 (if v1-6 (-> v1-6 extra process))))
           (when s3-0
             (let ((f0-0 (vector-vector-distance s5-0 (-> (the-as process-drawable s3-0) root trans))))
               (when (< f0-0 f30-0)
                 (set! f30-0 f0-0)
                 (set! gp-0 s4-0)))))))))
  gp-0)

(defbehavior ogreboss-shoot-boulder ogreboss ((arg0 pickup-type))
  (let ((gp-0 (new 'stack-no-clear 'ogreboss-missile-init-data)))
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      ;; og:preserve-this
      (set! (-> gp-0 src) (-> self node-list data (#if *jak1-full-game* 50 52) bone transform vector 3))
      (set! (-> gp-0 duration)
            (the-as time-frame (the int (* 300.0 (+ 1.25 (/ (-> self level) -4) (/ 0.5 (-> self difficulty)))))))
      (set! (-> gp-0 pickup-type) arg0)
      (set! (-> gp-0 blast-radius) 32768.0)
      (cond
        (*target*
         (let ((v1-10 (ogreboss-pick-target)))
           (let* ((a0-3 (-> self target-actor-array v1-10))
                  (a1-0 (if a0-3 (-> a0-3 extra process))))
             (if a1-0
               (set! (-> s5-0 quad) (-> (the-as process-drawable a1-0) root trans quad))
               (set! (-> s5-0 quad) (-> self root trans quad))))
           (vector+! s5-0 s5-0 (-> self target-offset-array v1-10))
           (set! (-> gp-0 blast-radius) (-> self target-blast-radius-array v1-10))))
        (else (vector+*! s5-0 (-> self root trans) *z-vector* (the-as float 409600.0))))
      (set! (-> gp-0 dest) s5-0))
    (sound-play "ogre-fires" :position (the-as symbol (-> self root trans)))
    (process-spawn part-tracker
                   :init
                   part-tracker-init
                   (-> *part-group-id-table* 470)
                   -1
                   #f
                   #f
                   #f
                   (-> gp-0 src)
                   :to
                   *entity-pool*)
    (process-spawn ogreboss-missile gp-0 (-> self entity) :to self))
  0
  (none))

(defbehavior ogreboss-submerge ogreboss ((arg0 time-frame) (arg1 float))
  (when (not (-> self submerged))
    (cond
      ((ja-group? ogreboss-dive-ja) (until (ja-done? 0) (suspend) (ja :num! (seek! max arg1))))
      (else
       (ja-channel-push! 1 (seconds 0.1))
       (ja-no-eval :group! ogreboss-dive-ja :num! (seek! (ja-aframe (the-as float 22.0) 0) arg1) :frame-num 0.0)
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek! (ja-aframe (the-as float 22.0) 0) arg1)))
       (cond
         ((-> self at-near-spot)
          (let ((a1-7 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-7 from) self)
            (set! (-> a1-7 num-params) 0)
            (set! (-> a1-7 message) 'submerge2)
            (let ((t9-8 send-event-function)
                  (v1-31 (-> self lava)))
              (t9-8 (if v1-31 (-> v1-31 extra process)) a1-7))))
         (else
          (let ((a1-8 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-8 from) self)
            (set! (-> a1-8 num-params) 0)
            (set! (-> a1-8 message) 'submerge1)
            (let ((t9-9 send-event-function)
                  (v1-35 (-> self lava)))
              (t9-9 (if v1-35 (-> v1-35 extra process)) a1-8)))))
       (ja-no-eval :group! ogreboss-dive-ja :num! (seek! max arg1) :frame-num (ja-aframe (the-as float 22.0) 0))
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek! max arg1)))))
    (logior! (-> self draw status) (draw-status hidden))
    (set! (-> self submerged) #t)
    (suspend-for arg0))
  0
  (none))

(defbehavior ogreboss-emerge ogreboss ((arg0 float))
  (when (-> self submerged)
    (set! (-> self submerged) #f)
    (logclear! (-> self draw status) (draw-status hidden))
    (cond
      ((-> self at-near-spot)
       (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
         (set! (-> a1-0 from) self)
         (set! (-> a1-0 num-params) 0)
         (set! (-> a1-0 message) 'emerge2)
         (let ((t9-0 send-event-function)
               (v1-6 (-> self lava)))
           (t9-0 (if v1-6 (-> v1-6 extra process)) a1-0))))
      (else
       (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
         (set! (-> a1-1 from) self)
         (set! (-> a1-1 num-params) 0)
         (set! (-> a1-1 message) 'emerge1)
         (let ((t9-1 send-event-function)
               (v1-10 (-> self lava)))
           (t9-1 (if v1-10 (-> v1-10 extra process)) a1-1)))))
    (ja-no-eval :group! ogreboss-rise-ja :num! (seek! max arg0) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max arg0))))
  0
  (none))

(defbehavior ogreboss-move-near ogreboss ((arg0 time-frame) (arg1 float))
  (when (not (-> self at-near-spot))
    (ogreboss-submerge arg0 arg1)
    (set! (-> self at-near-spot) #t)
    (set! (-> self root trans quad) (-> self near-pos quad))
    (ogreboss-emerge arg1))
  0
  (none))

(defbehavior ogreboss-move-far ogreboss ((arg0 time-frame) (arg1 float))
  (when (-> self at-near-spot)
    (ogreboss-submerge arg0 arg1)
    (set! (-> self at-near-spot) #f)
    (set! (-> self root trans quad) (-> self far-pos quad))
    (ogreboss-emerge arg1))
  0
  (none))

(defbehavior ogreboss-post ogreboss ()
  (transform-post)
  (send-event *camera* 'point-of-interest (-> self node-list data 5 bone transform vector 3))
  0
  (none))

(defstate ogreboss-stage1 (ogreboss)
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('next-stage) (set! (-> self bridge-assembled) #t) (go ogreboss-stage2))))
  :enter
    (behavior ()
      (set-time! (-> self state-time)))
  :trans
    (behavior ()
      (if (and (-> self bridge-assembled)
               (ogreboss-player-inside-range? (the-as float 524288.0))
               (time-elapsed? (-> self state-time) (seconds 0.1)))
        (go ogreboss-stage2)))
  :code
    (behavior ()
      (logior! (-> self mask) (process-mask enemy))
      (ogreboss-set-stage1-camera)
      (ogreboss-move-near (seconds 3) (the-as float 1.0))
      (cond
        ((ja-group? ogreboss-victory-ja)
         (ja-channel-push! 1 (seconds 0.1))
         (ja-no-eval :group! ogreboss-idle-ja :num! (seek!) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek!))))
        (else
         (ja-channel-push! 1 (seconds 0.1))
         (ja-no-eval :group! ogreboss-roar-ja :num! (seek!) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek!)))))
      (let* ((gp-0 (the int (* (-> self difficulty) (+ 8.0 (* 4.0 (-> self level))))))
             (f0-17 1.0)
             (f1-2 0.15)
             (f2-2 (-> self difficulty))
             (f30-0 (+ f0-17 (* f1-2 (* f2-2 f2-2) (-> self level)))))
        (ja-channel-push! 1 (seconds 0.1))
        (ja-no-eval :group! ogreboss-attack2-start-ja :num! (seek! max f30-0) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max f30-0)))
        (countdown (gp-1 (+ gp-0 -1))
          (let ((boulder-pickup (pickup-type none)))
            (let ((f28-0 0.0))
              (cond
                ((>= 1.0 (-> *target* fact health)) (set! f28-0 0.1))
                ((>= 2.0 (-> *target* fact health)) (set! f28-0 0.05)))
              (set! f28-0
                    (cond
                      ((< (-> self try-count) (the-as uint 5)) (* 0.0 f28-0))
                      ((< (-> self try-count) (the-as uint 10)) (/ f28-0 2))
                      (else (empty) f28-0)))
              (if (and *target* (< (rand-vu) f28-0)) (set! boulder-pickup (pickup-type eco-green))))
            (ogreboss-shoot-boulder (the-as pickup-type boulder-pickup)))
          (ja-no-eval :group! ogreboss-attack2-loop-ja :num! (seek! max f30-0) :frame-num 0.0)
          (until (ja-done? 0)
            (suspend)
            (ja :num! (seek! max f30-0)))
          (ogreboss-inc-try-count))
        (ogreboss-shoot-boulder (pickup-type eco-blue))
        (ja-no-eval :group! ogreboss-attack2-last-ja :num! (seek! max f30-0) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max f30-0))))
      (ogreboss-move-far (seconds 2) (the-as float 1.0))
      (ja-channel-push! 1 (seconds 0.1))
      (ja-no-eval :group! ogreboss-victory-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!)))
      (go ogreboss-stage1))
  :post ogreboss-post)

(defbehavior ogreboss-roll-boulder ogreboss ()
  (sound-play "ogre-fires" :position (the-as symbol (-> self root trans)))
  (+! (-> self roll-boulder) (rand-vu-int-range 1 2))
  (if (>= (-> self roll-boulder) 3) (+! (-> self roll-boulder) -3))
  (let ((v1-7 (-> self roll-boulder)))
    (cond
      ((zero? v1-7) (process-spawn ogreboss-bounce-boulder 2 (-> self entity) :to self))
      ((= v1-7 1) (process-spawn ogreboss-bounce-boulder 1 (-> self entity) :to self))
      (else (process-spawn ogreboss-bounce-boulder 0 (-> self entity) :to self))))
  0
  (none))

(defbehavior ogreboss-blend-hit-anim ogreboss ()
  (let ((f1-0 0.0)
        (f0-0 0.0))
    (let ((f30-0 (the float (- (current-time) (-> self hit-time)))))
      (when (and (> (-> self hit-count) 0) (>= 45.0 f30-0))
        (set! f0-0
              (+ (ja-aframe (the-as float 0.0) 1)
                 (* (/ f30-0 45) (- (ja-aframe (the-as float 8.0) 1) (ja-aframe (the-as float 0.0) 1)))))
        (set! f1-0
              (cond
                ((< f30-0 7.5) (* 0.120000005 f30-0))
                ((< f30-0 22.5) 0.9)
                (else (* 0.04 (- 45.0 f30-0)))))))
    (ja :chan 1 :frame-interp f1-0 :num-func num-func-identity :frame-num f0-0))
  0
  (none))

(defbehavior ogreboss-update-super-boulder ogreboss ()
  (let ((a1-0 (handle->process (-> self boulder))))
    (if a1-0 (set! (-> (the-as ogreboss-super-boulder a1-0) root trans quad) (-> self root trans quad))))
  0
  (none))

(defbehavior ogreboss-update-shuffling ogreboss ()
  (ogreboss-update-super-boulder)
  (ogreboss-blend-hit-anim)
  0
  (none))

(defbehavior ogreboss-attack-event-handler ogreboss ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('attack)
     (when (-> self vulnerable)
       (if ((method-of-type touching-shapes-entry prims-touching?)
            (the-as touching-shapes-entry (-> arg3 param 0))
            (the-as collide-shape-moving (-> self root))
            (the-as uint 128))
         (ja :chan 1 :group! ogreboss-hit-crotch-ja :num! min :frame-interp 0.0)
         (ja :chan 1 :group! ogreboss-hit-chest-ja :num! min :frame-interp 0.0))
       (set-time! (-> self hit-time))
       (let ((v1-17 (rand-vu-int-range 0 2)))
         (cond
           ((zero? v1-17) (sound-play "ogre-grunt1" :position (the-as symbol (-> self root trans))))
           ((= v1-17 1) (sound-play "ogre-grunt2" :position (the-as symbol (-> self root trans))))
           (else (sound-play "ogre-grunt3" :position (the-as symbol (-> self root trans))))))
       (+! (-> self hit-count) 1)
       (if (>= (-> self hit-count) (-> self max-hit-count)) (go ogreboss-stage3-hit))
       (send-event (handle->process (-> self boulder)) 'speedup))
     #t)))

(defstate ogreboss-stage2 (ogreboss)
  :event ogreboss-attack-event-handler
  :enter
    (behavior ()
      (set! (-> self boulder) (the-as handle #f)))
  :trans
    (behavior ()
      0)
  :code
    (behavior ()
      (ogreboss-set-stage2-camera)
      (ogreboss-move-far (seconds 0.1) (the-as float 2.0))
      (let ((f30-0 (* 0.75 (-> self difficulty))))
        (let ((gp-0 #f))
          (ja-channel-push! 1 (seconds 0.2))
          (ja-no-eval :group! ogreboss-attack2-start-ja :num! (seek! max 1.5) :frame-num 0.0)
          (until (ja-done? 0)
            (suspend)
            (ja :num! (seek! max 1.5)))
          (set-time! (-> self state-time))
          (while (not gp-0)
            (ogreboss-roll-boulder)
            (set! gp-0
                  (or (and (time-elapsed? (-> self state-time) (seconds 2)) (not (ogreboss-player-inside-range? (the-as float 524288.0))))
                      (ogreboss-player-inside-range? (the-as float 409600.0))))
            (ja-no-eval :group! ogreboss-attack2-loop-ja :num! (seek! max f30-0) :frame-num 0.0)
            (until (ja-done? 0)
              (if gp-0 0)
              (suspend)
              (ja :num! (seek! max f30-0)))))
        (ogreboss-roll-boulder)
        (ja-no-eval :group! ogreboss-attack2-last-ja :num! (seek! max f30-0) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max f30-0))))
      (go ogreboss-stage3-shuffle))
  :post ogreboss-post)

(defbehavior ogreboss-spawn-super-boulder ogreboss ()
  (set! (-> self boulder)
        (ppointer->handle (process-spawn ogreboss-super-boulder (-> self far-pos) (-> self grow-time) (-> self entity) :to self)))
  0
  (none))

(defstate ogreboss-stage3-shuffle (ogreboss)
  :event ogreboss-attack-event-handler
  :enter
    (behavior ()
      (set-time! (-> self state-time))
      (set! (-> self hit-count) 0)
      (set! (-> self max-hit-count) (the int (* 6.0 (-> self difficulty))))
      (set! (-> self grow-time) (* 300.0 (+ (/ 10.0 (-> self difficulty)) (* -1.0 (-> self level)))))
      (set! (-> self boulder) (the-as handle #f)))
  :exit
    (behavior ()
      (send-event *camera* 'point-of-interest #f)
      (set! (-> self vulnerable) #f))
  :trans
    (behavior ()
      (let ((v1-1 (handle->process (-> self boulder))))
        (if (and v1-1 (>= (-> (the-as ogreboss-super-boulder v1-1) size) 1.0)) (go ogreboss-stage3-throw)))
      (when (and (not (ogreboss-player-inside-range? (the-as float 409600.0))) (time-elapsed? (-> self state-time) (seconds 0.5)))
        (set-time! (-> self state-time))
        (send-event (handle->process (-> self boulder)) 'grow-faster))
      0)
  :code
    (behavior ()
      (set! (-> self shuffle-pos) 0.0)
      (let ((f30-0 (+ 1.0 (* (/ (-> self difficulty) 4) (-> self level))))
            (gp-0 (if (rand-vu-percent? (the-as float 0.5)) 0 1)))
        (ja-channel-push! 1 (seconds 0.2))
        (ja-no-eval :group! ogreboss-shuffle-prepare-ja :num! (seek! max f30-0) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max f30-0)))
        (ogreboss-spawn-super-boulder)
        (set-time! (-> self state-time))
        (ja-channel-push! 2 (seconds 0.05))
        (ja :chan 1 :group! ogreboss-hit-chest-ja :num! min :frame-interp 0.0)
        (set! (-> self vulnerable) #t)
        (loop
          (if (>= -61440.0 (-> self shuffle-pos)) (set! gp-0 1))
          (if (>= (-> self shuffle-pos) 61440.0) (set! gp-0 0))
          (cond
            ((zero? gp-0)
             (set! gp-0 1)
             (ja-no-eval :group! ogreboss-shuffle-right-start-ja :num! (seek! max f30-0) :frame-num 0.0)
             (until (ja-done? 0)
               (ogreboss-update-shuffling)
               (suspend)
               (ja :num! (seek! max f30-0)))
             (let ((s5-1 (rand-vu-int-range 1 5)))
               (while (and (> s5-1 0) (< -61440.0 (-> self shuffle-pos)))
                 (ja-no-eval :group! ogreboss-shuffle-right-loop-ja :num! (seek! max f30-0) :frame-num 0.0)
                 (until (ja-done? 0)
                   (ogreboss-update-shuffling)
                   (set! (-> self shuffle-pos) (- (-> self shuffle-pos) (* 16384.0 (seconds-per-frame) f30-0)))
                   (suspend)
                   (ja :num! (seek! max f30-0)))
                 (+! s5-1 -1)))
             (ja-no-eval :group! ogreboss-shuffle-right-stop-ja :num! (seek! max f30-0) :frame-num 0.0)
             (until (ja-done? 0)
               (ogreboss-update-shuffling)
               (suspend)
               (ja :num! (seek! max f30-0))))
            (else
             (set! gp-0 0)
             (ja-no-eval :group! ogreboss-shuffle-left-start-ja :num! (seek! max f30-0) :frame-num 0.0)
             (until (ja-done? 0)
               (ogreboss-update-shuffling)
               (suspend)
               (ja :num! (seek! max f30-0)))
             (let ((s5-2 (rand-vu-int-range 1 5)))
               (while (and (> s5-2 0) (< (-> self shuffle-pos) 61440.0))
                 (ja-no-eval :group! ogreboss-shuffle-left-loop-ja :num! (seek! max f30-0) :frame-num 0.0)
                 (until (ja-done? 0)
                   (ogreboss-update-shuffling)
                   (+! (-> self shuffle-pos) (* 16384.0 (seconds-per-frame) f30-0))
                   (suspend)
                   (ja :num! (seek! max f30-0)))
                 (+! s5-2 -1)))
             (ja-no-eval :group! ogreboss-shuffle-left-stop-ja :num! (seek! max f30-0) :frame-num 0.0)
             (until (ja-done? 0)
               (ogreboss-update-shuffling)
               (suspend)
               (ja :num! (seek! max f30-0))))))))
  :post
    (behavior ()
      (vector+*! (-> self root trans) (-> self far-pos) (-> self side-dir) (-> self shuffle-pos))
      (ogreboss-post)))

(defstate ogreboss-stage3-throw (ogreboss)
  :code
    (behavior ()
      (ja-channel-push! 1 (seconds 0.1))
      (send-event (handle->process (-> self boulder)) 'go-throw)
      (ja-no-eval :group! ogreboss-attack3-throw-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!)))
      (ja-channel-push! 1 (seconds 0.1))
      (ja-no-eval :group! ogreboss-victory-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!)))
      (ogreboss-submerge (seconds 1) (the-as float 1.0))
      (while (handle->process (-> self boulder))
        (suspend))
      (set! (-> self bridge-assembled) #f)
      (go ogreboss-stage1))
  :post transform-post)

(defstate ogreboss-stage3-hit (ogreboss)
  :code
    (behavior ()
      (+! (-> self level) 1.0)
      (if (< 2.0 (-> self level)) (go ogreboss-die))
      (send-event (handle->process (-> self boulder)) 'go-hit)
      (ja-channel-push! 1 (seconds 0.2))
      (ja-no-eval :group! ogreboss-hit-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!)))
      (set! (-> self bridge-assembled) #f)
      (set! (-> self submerged) #t)
      (while (handle->process (-> self boulder))
        (suspend))
      (go ogreboss-stage1))
  :post transform-post)

(defbehavior ogreboss-trigger-steps ogreboss ()
  (let ((gp-0 (entity-actor-count (-> self entity) 'trigger-actor)))
    (dotimes (s5-0 gp-0)
      (let ((v1-1 (* 600 (+ s5-0 1)))
            (s4-0 (new 'stack-no-clear 'event-message-block)))
        (set! (-> s4-0 from) self)
        (set! (-> s4-0 num-params) 1)
        (set! (-> s4-0 message) 'trigger)
        (set! (-> s4-0 param 0) (the-as uint v1-1))
        (let ((s3-0 send-event-function)
              (v1-2 (entity-actor-lookup (-> self entity) 'trigger-actor s5-0)))
          (s3-0 (if v1-2 (-> v1-2 extra process)) s4-0)))))
  #f)

(defstate ogreboss-die (ogreboss)
  :code
    (behavior ()
      (ogreboss-reset-camera)
      (send-event (handle->process (-> self boulder)) 'go-die)
      (ja-channel-push! 1 (seconds 0.2))
      (ja-no-eval :group! ogreboss-hit-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (transform-post)
        (suspend)
        (ja :num! (seek!)))
      (ogreboss-trigger-steps)
      (go ogreboss-dead)))

(defstate ogreboss-dead (ogreboss)
  :event process-drawable-fuel-cell-handler
  :code
    (behavior ()
      (remove-setting! 'music)
      (ogreboss-reset-camera)
      (let ((gp-0 (new 'stack-no-clear 'event-message-block)))
        (set! (-> gp-0 from) self)
        (set! (-> gp-0 num-params) 0)
        (set! (-> gp-0 message) 'complete)
        (let ((s5-0 send-event-function)
              (v1-3 (entity-actor-lookup (-> self entity) 'alt-actor 0)))
          (s5-0 (if v1-3 (-> v1-3 extra process)) gp-0)))
      (process-entity-status! self (entity-perm-status complete) #t)
      (close-specific-task! (game-task ogre-boss) (task-status need-reminder))
      (clear-collide-with-as (-> self root))
      (ja-channel-set! 0)
      (ja-post)
      (when (not (task-complete? *game-info* (-> self entity extra perm task)))
        (let ((gp-1 (new 'stack-no-clear 'vector)))
          (let ((a0-9 (entity-actor-lookup (-> self entity) 'trigger-actor 2)))
            (if (not a0-9) (set! a0-9 (-> self entity)))
            (set! (-> gp-1 quad) (-> a0-9 extra trans quad)))
          (label cfg-6)
          (birth-pickup-at-point gp-1
                                 (pickup-type fuel-cell)
                                 (the float (-> self entity extra perm task))
                                 #f
                                 self
                                 (the-as fact-info #f)))
        (when (not (-> self child))
          (suspend)
          (goto cfg-6))
        (while (-> self child)
          (suspend)))
      (cleanup-for-death self)))

(defbehavior ogreboss-get-targets ogreboss ()
  (let ((gp-1 (min 3 (entity-actor-count (-> self entity) 'target-actor))))
    (dotimes (s5-0 gp-1)
      (set! (-> self target-actor-array s5-0) (entity-actor-lookup (-> self entity) 'target-actor s5-0)))
    (set! (-> self target-count) gp-1))
  (set-vector! (-> self target-offset-array 0) 0.0 16384.0 0.0 1.0)
  (set-vector! (-> self target-offset-array-2) 0.0 16384.0 0.0 1.0)
  (set-vector! (-> self target-offset-array-3) 0.0 16384.0 0.0 1.0)
  (set! (-> self target-blast-radius-array 0) 24576.0)
  (set! (-> self target-blast-radius-array 1) 24576.0)
  (set! (-> self target-blast-radius-array 2) 24576.0)
  0
  (none))

(defmethod init-from-entity! ((this ogreboss) (arg0 entity-actor))
  (logior! (-> this mask) (process-mask attackable))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 6) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 40960.0 0.0 53248.0)
      (set-root-prim! s4-0 s3-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 131))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core action) (collide-action solid))
        (set! (-> s2-0 prim-core offense) (collide-offense touch))
        (set! (-> s2-0 transform-index) 3)
        (set-vector! (-> s2-0 local-sphere) 0.0 8192.0 0.0 14336.0)
        (append-prim s3-0 s2-0))
      (let ((s2-1 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 3))))
        (set! (-> s2-1 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-1 collide-with) (collide-kind target))
        (set! (-> s2-1 prim-core action) (collide-action solid))
        (set! (-> s2-1 prim-core offense) (collide-offense touch))
        (set! (-> s2-1 transform-index) 5)
        (set-vector! (-> s2-1 local-sphere) 0.0 0.0 0.0 28672.0)
        (append-prim s3-0 s2-1))
      (let ((s2-2 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 3))))
        (set! (-> s2-2 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-2 collide-with) (collide-kind target))
        (set! (-> s2-2 prim-core action) (collide-action solid))
        (set! (-> s2-2 prim-core offense) (collide-offense touch))
        (set! (-> s2-2 transform-index) 7)
        (set-vector! (-> s2-2 local-sphere) 0.0 0.0 0.0 14336.0)
        (append-prim s3-0 s2-2))
      (let ((s2-3 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 3))))
        (set! (-> s2-3 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-3 collide-with) (collide-kind target))
        (set! (-> s2-3 prim-core action) (collide-action solid))
        (set! (-> s2-3 prim-core offense) (collide-offense touch))
        (set! (-> s2-3 transform-index) 43)
        (set-vector! (-> s2-3 local-sphere) 0.0 0.0 0.0 12288.0)
        (append-prim s3-0 s2-3))
      (let ((s2-4 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 3))))
        (set! (-> s2-4 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-4 collide-with) (collide-kind target))
        (set! (-> s2-4 prim-core action) (collide-action solid))
        (set! (-> s2-4 prim-core offense) (collide-offense touch))
        (set! (-> s2-4 transform-index) 42)
        (set-vector! (-> s2-4 local-sphere) 0.0 0.0 0.0 12288.0)
        (append-prim s3-0 s2-4))
      (let ((s2-5 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 3))))
        (set! (-> s2-5 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-5 collide-with) (collide-kind target))
        (set! (-> s2-5 prim-core action) (collide-action solid))
        (set! (-> s2-5 prim-core offense) (collide-offense touch))
        (set! (-> s2-5 transform-index) 27)
        (set-vector! (-> s2-5 local-sphere) 0.0 0.0 0.0 8192.0)
        (append-prim s3-0 s2-5)))
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0))
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (initialize-skeleton this *ogreboss-sg* '())
  (set! (-> this draw origin-joint-index) (the-as uint 5))
  (ogreboss-get-targets)
  (set! (-> this try-count) (-> this entity extra perm user-uint8 0))
  (cond
    ((< (-> this try-count) (the-as uint 5)) (set! (-> this difficulty) 1.0))
    ((< (-> this try-count) (the-as uint 10)) (set! (-> this difficulty) 0.83334))
    ((< (-> this try-count) (the-as uint 15)) (set! (-> this difficulty) 0.66667))
    (else (set! (-> this difficulty) 0.5)))
  (set! (-> this lava) (entity-actor-lookup (-> this entity) 'water-actor 0))
  (set! *ogreboss* (the-as ogreboss (process->ppointer this)))
  (set! (-> this level) 0.0)
  (set! (-> this vulnerable) #f)
  (set! (-> this bridge-assembled) #f)
  (set! (-> this submerged) #f)
  (vector-z-quaternion! (-> this z-plane) (-> this root quat))
  (set! (-> this z-plane w) (- (vector-dot (-> this z-plane) (-> this root trans))))
  (vector-x-quaternion! (-> this side-dir) (-> this root quat))
  (set! (-> this far-pos quad) (-> this root trans quad))
  (let ((f0-38 1.0)) (set-vector! (-> this root scale) f0-38 f0-38 f0-38 1.0))
  (vector+*! (-> this near-pos) (-> this far-pos) (-> this z-plane) (the-as float 348160.0))
  (set! (-> this at-near-spot) #t)
  (set! (-> this try-counted) #f)
  (set! (-> this root trans quad) (-> this near-pos quad))
  (if (and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status complete)))
    (go ogreboss-dead)
    (go ogreboss-idle))
  (none))
