;;-*-Lisp-*-
(in-package goal)

;; name: citb-plat.gc
;; name in dgo: citb-plat
;; dgos: CIT, L1

;; DECOMP BEGINS

(import "goal_src/jak1/import/citb-exit-plat-ag.gc")
(import "goal_src/jak1/import/plat-eco-citb-ag.gc")
(import "goal_src/jak1/import/plat-citb-ag.gc")
(import "goal_src/jak1/import/citb-stopbox-ag.gc")
(import "goal_src/jak1/import/citb-firehose-ag.gc")
(import "goal_src/jak1/import/citb-rotatebox-ag.gc")
(import "goal_src/jak1/import/citb-chain-plat-ag.gc")
(import "goal_src/jak1/import/citb-donut-ag.gc")

(defskelgroup *plat-citb-sg* plat-citb plat-citb-lod0-jg plat-citb-idle-ja
              ((plat-citb-lod0-mg (meters 20)) (plat-citb-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(defskelgroup *plat-eco-citb-unlit-sg* plat-eco-citb plat-eco-citb-lod0-jg plat-eco-citb-idle-ja
              ((plat-eco-citb-lod0-mg (meters 20))
               (plat-eco-citb-lod1-mg (meters 40))
               (plat-eco-citb-lod2-mg (meters 999999))
               )
              :bounds (static-spherem 0 0 0 3)
              )

(defskelgroup *plat-eco-citb-lit-sg* plat-eco-citb plat-eco-citb-lit-lod0-jg plat-eco-citb-idle-ja
              ((plat-eco-citb-lit-lod0-mg (meters 20))
               (plat-eco-citb-lit-lod1-mg (meters 40))
               (plat-eco-citb-lit-lod2-mg (meters 999999))
               )
              :bounds (static-spherem 0 0 0 3)
              )

(defskelgroup *citb-chain-plat-sg* citb-chain-plat citb-chain-plat-lod0-jg citb-chain-plat-idle-ja
              ((citb-chain-plat-lod0-mg (meters 20)) (citb-chain-plat-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              )

(deftype citb-base-plat (process-drawable)
  ((root-override collide-shape-moving  :offset        112)
   (idle-distance float                 :offset-assert 176)
   )
  :heap-base #x50
  :method-count-assert 25
  :size-assert         #xb4
  :flag-assert         #x19005000b4
  (:methods
    (citb-base-plat-idle () _type_ :state 20)
    (citb-base-plat-method-21 (_type_) none 21)
    (citb-base-plat-method-22 (_type_) none 22)
    (citb-base-plat-active () _type_ :state 23)
    (citb-base-plat-method-24 (_type_) none 24)
    )
  )


(defstate citb-base-plat-idle (citb-base-plat)
  :virtual #t
  :trans (behavior ()
    (if (and *target* (>= (-> self idle-distance)
                          (vector-vector-distance (-> self root-override trans) (-> *target* control trans))
                          )
             )
        (go-virtual citb-base-plat-active)
        )
    (none)
    )
  :code (the-as (function none :behavior citb-base-plat) anim-loop)
  :post (the-as (function none :behavior citb-base-plat) ja-post)
  )

(defstate citb-base-plat-active (citb-base-plat)
  :virtual #t
  :trans (behavior ()
    (if (or (not *target*) (< (+ 8192.0 (-> self idle-distance))
                              (vector-vector-distance (-> self root-override trans) (-> *target* control trans))
                              )
            )
        (go-virtual citb-base-plat-idle)
        )
    (rider-trans)
    (none)
    )
  :code (the-as (function none :behavior citb-base-plat) anim-loop)
  :post (the-as (function none :behavior citb-base-plat) rider-post)
  )

(defmethod citb-base-plat-method-21 citb-base-plat ((obj citb-base-plat))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-others))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s5-0 1)
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 20480.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

(defmethod citb-base-plat-method-22 citb-base-plat ((obj citb-base-plat))
  (initialize-skeleton obj *plat-citb-sg* '())
  0
  (none)
  )

(defmethod citb-base-plat-method-24 citb-base-plat ((obj citb-base-plat))
  (go (method-of-object obj citb-base-plat-idle))
  0
  (none)
  )

(defmethod init-from-entity! citb-base-plat ((obj citb-base-plat) (arg0 entity-actor))
  (citb-base-plat-method-21 obj)
  (process-drawable-from-entity! obj arg0)
  (set! (-> obj idle-distance) 245760.0)
  (citb-base-plat-method-22 obj)
  (logior! (-> obj skel status) (janim-status inited))
  (citb-base-plat-method-24 obj)
  (none)
  )

(deftype citb-plat-eco (plat-eco)
  ()
  :heap-base #x100
  :method-count-assert 33
  :size-assert         #x165
  :flag-assert         #x2101000165
  )


(defmethod baseplat-method-24 citb-plat-eco ((obj citb-plat-eco))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-others))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s5-0 1)
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 12288.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

(defmethod baseplat-method-26 citb-plat-eco ((obj citb-plat-eco))
  (logclear! (-> obj mask) (process-mask actor-pause))
  (set! (-> obj notice-dist) 8192.0)
  (none)
  )

(defmethod get-unlit-skel citb-plat-eco ((obj citb-plat-eco))
  *plat-eco-citb-unlit-sg*
  )

(defmethod get-lit-skel citb-plat-eco ((obj citb-plat-eco))
  *plat-eco-citb-lit-sg*
  )

(deftype citb-plat (plat)
  ((trans-offset vector :inline :offset-assert 272)
   )
  :heap-base #xb0
  :method-count-assert 33
  :size-assert         #x120
  :flag-assert         #x2100b00120
  )


(defstate plat-path-active (citb-plat)
  :virtual #t
  :trans (behavior ()
    (set! (-> self path-pos) (if (logtest? (-> self fact options) (fact-options wrap-phase))
                                 (get-current-phase (-> self sync))
                                 (get-current-phase-with-mirror (-> self sync))
                                 )
          )
    (eval-path-curve! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
    (vector+! (-> self basetrans) (-> self basetrans) (-> self trans-offset))
    (if (< (vector-vector-distance (-> self root-override trans) (ear-trans)) 81920.0)
        (sound-play "eco-plat-hover" :id (-> self sound-id) :position (the-as symbol (-> self root-override trans)))
        )
    (plat-trans)
    (none)
    )
  )

(defmethod get-unlit-skel citb-plat ((obj citb-plat))
  *plat-citb-sg*
  )

(defmethod baseplat-method-24 citb-plat ((obj citb-plat))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-others))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s5-0 1)
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 12288.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

(defmethod baseplat-method-26 citb-plat ((obj citb-plat))
  (logclear! (-> obj mask) (process-mask actor-pause))
  (set! (-> obj root-override scale quad) (-> (res-lump-struct (-> obj entity) 'scale vector) quad))
  (let ((f0-0 (-> obj root-override scale x)))
    (set! (-> obj root-override root-prim local-sphere w)
          (* (-> obj root-override root-prim local-sphere w) f0-0)
          )
    (set! (-> obj draw bounds w) (* (-> obj draw bounds w) f0-0))
    )
  (set! (-> obj trans-offset quad) (-> (the-as vector ((method-of-type res-lump get-property-struct)
                                                       (-> obj entity)
                                                       'trans-offset
                                                       'interp
                                                       -1000000000.0
                                                       *null-vector*
                                                       (the-as (pointer res-tag) #f)
                                                       *res-static-buf*
                                                       )
                                               )
                                       quad
                                       )
        )
  0
  (none)
  )

(deftype citb-stair-plat (citb-base-plat)
  ((idle-height float       :offset-assert 180)
   (rise-height float       :offset-assert 184)
   (delay       time-frame  :offset-assert 192)
   (rise        symbol      :offset-assert 200)
   )
  :heap-base #x60
  :method-count-assert 25
  :size-assert         #xcc
  :flag-assert         #x19006000cc
  )


(defstate citb-base-plat-idle (citb-stair-plat)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('trigger)
                      (logclear! (-> self mask) (process-mask actor-pause))
                      (let ((v0-0 #t))
                        (set! (-> self rise) v0-0)
                        v0-0
                        )
                      )
                     )
            )
    )
  :trans (the-as (function none :behavior citb-stair-plat) #f)
  :code (behavior ()
    (logior! (-> self draw status) (draw-status hidden))
    (while (not (-> self rise))
      (suspend)
      )
    (logclear! (-> self draw status) (draw-status hidden))
    (set-vector! (-> self draw color-mult) 0.0 0.0 0.0 1.0)
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (while (< (- (-> *display* base-frame-counter) (-> self state-time)) (-> self delay))
      (ja-post)
      (suspend)
      )
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (loop
      (let ((f30-0 (- 1.0 (* 0.0011111111 (the float (- (-> *display* base-frame-counter) (-> self state-time)))))))
        (when (< f30-0 0.0)
          (set! (-> self root-override trans y) (-> self rise-height))
          (go-virtual citb-base-plat-active)
          )
        (set! (-> self root-override trans y) (lerp (-> self rise-height) (-> self idle-height) (* f30-0 f30-0)))
        )
      (let ((f0-12 (fmax 0.0 (fmin 1.0 (* 0.000012207031 (+ 409600.0 (-> self root-override trans y)))))))
        (set! (-> self draw color-mult x) f0-12)
        (set! (-> self draw color-mult y) f0-12)
        (set! (-> self draw color-mult z) f0-12)
        )
      (transform-post)
      (suspend)
      )
    (none)
    )
  :post (the-as (function none :behavior citb-stair-plat) #f)
  )

(defstate citb-base-plat-active (citb-stair-plat)
  :virtual #t
  :trans (the-as (function none :behavior citb-stair-plat) #f)
  :code (behavior ()
    (set! (-> self root-override trans y) (-> self rise-height))
    (suspend)
    (update-transforms! (-> self root-override))
    (logior! (-> self mask) (process-mask actor-pause))
    (anim-loop)
    (none)
    )
  :post (the-as (function none :behavior citb-stair-plat) ja-post)
  )

(defmethod citb-base-plat-method-22 citb-stair-plat ((obj citb-stair-plat))
  (initialize-skeleton obj *plat-citb-sg* '())
  (set! (-> obj rise-height) (-> obj root-override trans y))
  (set! (-> obj idle-height) (+ -409600.0 (-> obj rise-height)))
  (set! (-> obj root-override trans y) (-> obj idle-height))
  (set! (-> obj rise) #f)
  (set! (-> obj delay)
        (the-as time-frame (the int (* 300.0 (res-lump-float (-> obj entity) 'delay :default 1.0))))
        )
  (let ((f0-7 1.5))
    (set-vector! (-> obj root-override scale) f0-7 f0-7 f0-7 1.0)
    (set! (-> obj root-override root-prim local-sphere w)
          (* (-> obj root-override root-prim local-sphere w) f0-7)
          )
    (set! (-> obj draw bounds w) (* (-> obj draw bounds w) f0-7))
    )
  0
  (none)
  )

(defmethod citb-base-plat-method-24 citb-stair-plat ((obj citb-stair-plat))
  (if (and (task-complete? *game-info* (game-task citadel-sage-blue))
           (task-complete? *game-info* (game-task citadel-sage-red))
           (task-complete? *game-info* (game-task citadel-sage-yellow))
           )
      (go (method-of-object obj citb-base-plat-active))
      (go (method-of-object obj citb-base-plat-idle))
      )
  0
  (none)
  )

(define *citb-chain-plat-constants* (new 'static 'rigid-body-platform-constants
                                      :drag-factor 2.0
                                      :buoyancy-factor 2.0
                                      :max-buoyancy-depth (meters 3)
                                      :gravity-factor 1.0
                                      :gravity (meters 80)
                                      :player-weight (meters 35)
                                      :player-bonk-factor 1.0
                                      :player-dive-factor 1.0
                                      :player-force-distance (meters 1000)
                                      :player-force-clamp (meters 1000000)
                                      :player-force-timeout (seconds 0.1)
                                      :explosion-force (meters 1000)
                                      :linear-damping 1.0
                                      :angular-damping 1.0
                                      :control-point-count 5
                                      :mass 2.0
                                      :inertial-tensor-x (meters 10)
                                      :inertial-tensor-y (meters 5)
                                      :inertial-tensor-z (meters 10)
                                      :idle-distance (meters 70)
                                      :platform #t
                                      :sound-name "blue-eco-on"
                                      )
        )

(deftype citb-chain-plat (rigid-body-platform)
  ((orig-trans   vector     :inline :offset-assert 736)
   (orig-quat    quaternion :inline :offset-assert 752)
   (beam-end     vector     :inline :offset-assert 768)
   (float-offset float              :offset-assert 784)
   (idle-offset  float              :offset-assert 788)
   )
  :heap-base #x2b0
  :method-count-assert 35
  :size-assert         #x318
  :flag-assert         #x2302b00318
  (:states
    citb-chain-plat-settle
    )
  )


(defmethod rigid-body-platform-method-22 citb-chain-plat ((obj citb-chain-plat) (arg0 vector) (arg1 float))
  (+ 12288.0
     (* 2048.0
        (fmax 0.0 (fmin 1.0 (* 0.000024414063 (-> obj float-height-offset))))
        (cos (* 109.22667 (+ (* 60.0 arg1) (* 0.03 (-> arg0 x)) (* 0.03 (-> arg0 z)))))
        )
     (-> obj float-height-offset)
     (-> obj orig-trans y)
     )
  )

(defmethod rigid-body-platform-method-27 citb-chain-plat ((obj citb-chain-plat) (arg0 vector))
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    (vector-! gp-0 arg0 (-> obj rbody position))
    (set! (-> gp-0 y) 0.0)
    (let* ((f0-1 (vector-length gp-0))
           (f1-1 (* 4.0 (fmax 0.0 (fmin 4096.0 (+ -819.2 f0-1)))))
           )
      (when (< 0.0 f1-1)
        (vector-float*! gp-0 gp-0 (/ f1-1 f0-1))
        (rigid-body-method-15 (-> obj rbody) gp-0)
        )
      )
    )
  0
  (none)
  )

(defmethod rigid-body-platform-method-23 citb-chain-plat ((obj citb-chain-plat) (arg0 float))
  ((the-as (function rigid-body-platform float none) (find-parent-method citb-chain-plat 23)) obj arg0)
  (rigid-body-platform-method-27 obj (-> obj orig-trans))
  0
  (none)
  )

(defstate rigid-body-platform-idle (citb-chain-plat)
  :virtual #t
  :trans (behavior ()
    (when (>= (- (-> *display* base-frame-counter) (-> self state-time)) (seconds 0.1))
      (set! (-> self state-time) (-> *display* base-frame-counter))
      (if (and (and *target* (>= (-> self info idle-distance)
                                 (vector-vector-distance (-> self root-overlay trans) (-> *target* control trans))
                                 )
                    )
               (send-event *target* 'query 'powerup (pickup-type eco-blue))
               )
          (go-virtual rigid-body-platform-float)
          )
      )
    (none)
    )
  :code (behavior ()
    (anim-loop)
    (none)
    )
  :post (the-as (function none :behavior citb-chain-plat) ja-post)
  )

(defstate rigid-body-platform-float (citb-chain-plat)
  :virtual #t
  :event (the-as
    (function process int symbol event-message-block object :behavior citb-chain-plat)
    rigid-body-platform-event-handler
    )
  :enter (behavior ()
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (none)
    )
  :exit (behavior ()
    (stop! (-> self sound))
    (none)
    )
  :trans (behavior ()
    (cond
      ((and (and *target* (>= (-> self info idle-distance)
                              (vector-vector-distance (-> self root-overlay trans) (-> *target* control trans))
                              )
                 )
            (send-event *target* 'query 'powerup (pickup-type eco-blue))
            )
       (when (< (- (-> *display* base-frame-counter) (-> self state-time)) (seconds 1))
         (if (rand-vu-percent? 0.05)
             (spawn-projectile-blue *target*)
             )
         )
       (seek! (-> self float-height-offset) (-> self float-offset) (* 8192.0 (-> *display* seconds-per-frame)))
       (draw-eco-beam (-> self root-overlay trans) (-> self beam-end))
       (update-trans! (-> self sound) (-> self root-overlay trans))
       (update! (-> self sound))
       )
      (else
        (seek! (-> self float-height-offset) (-> self idle-offset) (* 16384.0 (-> *display* seconds-per-frame)))
        (stop! (-> self sound))
        (if (= (-> self float-height-offset) (-> self idle-offset))
            (go citb-chain-plat-settle)
            )
        )
      )
    (none)
    )
  :code (behavior ()
    (anim-loop)
    (none)
    )
  :post (the-as (function none :behavior citb-chain-plat) rigid-body-platform-post)
  )

(defstate citb-chain-plat-settle (citb-chain-plat)
  :trans (the-as (function none :behavior citb-chain-plat) rider-trans)
  :code (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'vector))
          (s5-0 (new 'stack-no-clear 'quaternion))
          )
      (set! (-> gp-0 quad) (-> self root-overlay trans quad))
      (quaternion-copy! s5-0 (-> self root-overlay quat))
      (set! (-> self state-time) (-> *display* base-frame-counter))
      (while (< (- (-> *display* base-frame-counter) (-> self state-time)) (seconds 0.25))
        (let ((f30-0 (* 0.013333334 (the float (- (-> *display* base-frame-counter) (-> self state-time))))))
          (quaternion-slerp! (-> self root-overlay quat) s5-0 (-> self orig-quat) f30-0)
          (vector-lerp! (-> self root-overlay trans) gp-0 (-> self orig-trans) f30-0)
          )
        (suspend)
        )
      )
    (set! (-> self root-overlay trans quad) (-> self orig-trans quad))
    (quaternion-copy! (-> self root-overlay quat) (-> self orig-quat))
    (rigid-body-method-22
      (-> self rbody)
      (-> self root-overlay trans)
      (-> self root-overlay quat)
      (-> self info linear-damping)
      (-> self info angular-damping)
      )
    (suspend)
    (go-virtual rigid-body-platform-idle)
    (none)
    )
  :post (the-as (function none :behavior citb-chain-plat) rider-post)
  )

(defmethod rigid-body-platform-method-30 citb-chain-plat ((obj citb-chain-plat))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s5-0 1)
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 20480.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> obj root-overlay) s5-0)
    )
  0
  (none)
  )

(defmethod rigid-body-platform-method-31 citb-chain-plat ((obj citb-chain-plat))
  (initialize-skeleton obj *citb-chain-plat-sg* '())
  (set! (-> obj orig-trans quad) (-> obj root-overlay trans quad))
  (quaternion-copy! (-> obj orig-quat) (-> obj root-overlay quat))
  (set! (-> obj beam-end quad) (-> obj orig-trans quad))
  (set! (-> obj beam-end y) (+ -49152.0 (-> obj beam-end y)))
  (rigid-body-platform-method-29 obj *citb-chain-plat-constants*)
  (set! (-> obj idle-offset) 0.0)
  (set! (-> obj float-offset) (res-lump-float (-> obj entity) 'height-info :default 4096.0))
  (set! (-> obj float-height-offset) (-> obj idle-offset))
  (set! (-> obj sound)
        (new 'process 'ambient-sound (static-sound-spec "eco-plat-hover" :fo-max 50) (-> obj root-overlay trans))
        )
  (let ((s5-0 (-> obj info control-point-count)))
    (dotimes (s4-0 s5-0)
      (let ((s3-0 (-> obj control-point-array data s4-0)))
        (let ((f30-0 (* 65536.0 (/ (the float s4-0) (the float s5-0)))))
          (set! (-> s3-0 local-pos x) (* 16384.0 (sin f30-0)))
          (set! (-> s3-0 local-pos y) 0.0)
          (set! (-> s3-0 local-pos z) (* 16384.0 (cos f30-0)))
          )
        (set! (-> s3-0 local-pos w) 1.0)
        )
      )
    )
  0
  (none)
  )

(defskelgroup *citb-rotatebox-sg* citb-rotatebox citb-rotatebox-lod0-jg citb-rotatebox-idle-ja
              ((citb-rotatebox-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -5 0 10)
              )

(deftype citb-rotatebox (citb-base-plat)
  ()
  :heap-base #x50
  :method-count-assert 25
  :size-assert         #xb4
  :flag-assert         #x19005000b4
  )


(defstate citb-base-plat-active (citb-rotatebox)
  :virtual #t
  :trans (the-as (function none :behavior citb-rotatebox) rider-trans)
  :code (behavior ()
    (loop
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      (if (or (not *target*) (< (+ 8192.0 (-> self idle-distance))
                                (vector-vector-distance (-> self root-override trans) (-> *target* control trans))
                                )
              )
          (go-virtual citb-base-plat-idle)
          )
      )
    (none)
    )
  )

(defmethod citb-base-plat-method-21 citb-rotatebox ((obj citb-rotatebox))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-others))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s5-0 1)
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 -20480.0 0.0 40960.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

(defmethod citb-base-plat-method-22 citb-rotatebox ((obj citb-rotatebox))
  (initialize-skeleton obj *citb-rotatebox-sg* '())
  0
  (none)
  )

(defskelgroup *citb-donut-sg* citb-donut citb-donut-lod0-jg citb-donut-idle-ja
              ((citb-donut-lod0-mg (meters 20)) (citb-donut-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 10)
              )

(deftype citb-donut (citb-base-plat)
  ((sync sync-info :inline :offset-assert 180)
   )
  :heap-base #x50
  :method-count-assert 25
  :size-assert         #xbc
  :flag-assert         #x19005000bc
  )


(defstate citb-base-plat-active (citb-donut)
  :virtual #t
  :post (behavior ()
    (update! (-> self sound))
    (quaternion-axis-angle!
      (-> self root-override quat)
      0.0
      1.0
      0.0
      (* 65536.0 (get-current-phase (-> self sync)))
      )
    (rider-post)
    (none)
    )
  )

(defmethod citb-base-plat-method-21 citb-donut ((obj citb-donut))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-others))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s5-0 1)
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 40960.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

(defmethod citb-base-plat-method-22 citb-donut ((obj citb-donut))
  (initialize-skeleton obj *citb-donut-sg* '())
  (setup-params! (-> obj sync) (the-as uint 9000) 0.0 0.15 0.15)
  (set! (-> obj sound)
        (new 'process 'ambient-sound (static-sound-spec "rotate-plat" :fo-max 20) (-> obj root-override trans))
        )
  (logclear! (-> obj mask) (process-mask actor-pause))
  0
  (none)
  )

(defskelgroup *citb-stopbox-sg* citb-stopbox citb-stopbox-lod0-jg citb-stopbox-idle-ja
              ((citb-stopbox-lod0-mg (meters 20)) (citb-stopbox-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 -2 0 5.5)
              )

(deftype citb-stopbox (plat)
  ()
  :heap-base #xa0
  :method-count-assert 33
  :size-assert         #x108
  :flag-assert         #x2100a00108
  )


(defstate plat-path-active (citb-stopbox)
  :virtual #t
  :trans (behavior ()
    (set! (-> self path-pos) (get-current-phase (-> self sync)))
    (eval-path-curve! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
    (if (< (vector-vector-distance (-> self root-override trans) (ear-trans)) 81920.0)
        (sound-play "eco-plat-hover" :id (-> self sound-id) :position (the-as symbol (-> self root-override trans)))
        )
    (plat-trans)
    (none)
    )
  )

(defmethod get-unlit-skel citb-stopbox ((obj citb-stopbox))
  *citb-stopbox-sg*
  )

(defmethod baseplat-method-24 citb-stopbox ((obj citb-stopbox))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-others))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s5-0 1)
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid rider-plat-sticky rider-plat))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 -8192.0 0.0 22528.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

(defmethod baseplat-method-26 citb-stopbox ((obj citb-stopbox))
  (logior! (-> obj fact options) (fact-options wrap-phase))
  (logclear! (-> obj mask) (process-mask actor-pause))
  0
  (none)
  )

(deftype citb-firehose (process-drawable)
  ((root-override collide-shape         :offset        112)
   (idle-distance float                 :offset-assert 176)
   (sync          sync-info     :inline :offset-assert 180)
   (last-sync     float                 :offset-assert 188)
   (blast-pos     vector        :inline :offset-assert 192)
   )
  :heap-base #x60
  :method-count-assert 20
  :size-assert         #xd0
  :flag-assert         #x14006000d0
  (:states
    citb-firehose-active
    citb-firehose-blast
    citb-firehose-idle
    )
  )


(defskelgroup *citb-firehose-sg* citb-firehose citb-firehose-lod0-jg citb-firehose-idle-ja
              ((citb-firehose-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 3 0 15)
              )

(defstate citb-firehose-idle (citb-firehose)
  :trans (behavior ()
    (if (and *target* (>= (-> self idle-distance)
                          (vector-vector-distance (-> self root-override trans) (-> *target* control trans))
                          )
             )
        (go citb-firehose-active)
        )
    (none)
    )
  :code (behavior ()
    (loop
      (suspend)
      )
    (none)
    )
  :post (the-as (function none :behavior citb-firehose) ja-post)
  )

(defstate citb-firehose-active (citb-firehose)
  :trans (behavior ()
    (if (or (not *target*) (< (+ 8192.0 (-> self idle-distance))
                              (vector-vector-distance (-> self root-override trans) (-> *target* control trans))
                              )
            )
        (go citb-firehose-idle)
        )
    (let ((f0-2 (get-current-phase (-> self sync)))
          (f1-1 (-> self last-sync))
          )
      (set! (-> self last-sync) f0-2)
      (if (< f0-2 f1-1)
          (go citb-firehose-blast)
          )
      )
    (none)
    )
  :code (behavior ()
    (loop
      (suspend)
      )
    (none)
    )
  :post (the-as (function none :behavior citb-firehose) ja-post)
  )

(defbehavior citb-firehose-blast-particles citb-firehose ()
  (let ((gp-0 (new 'stack-no-clear 'quaternion)))
    (quaternion-identity! gp-0)
    (quaternion-rotate-local-x! gp-0 gp-0 -16384.0)
    (dotimes (s5-0 16)
      (quaternion-rotate-local-z! gp-0 gp-0 2048.0)
      (quaternion-copy! *particle-quat* gp-0)
      (launch-particles :system *sp-particle-system-3d* (-> *part-id-table* 2541) (-> self blast-pos))
      )
    )
  (spawn (-> self part) (-> self blast-pos))
  )

(defstate citb-firehose-blast (citb-firehose)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('touch)
       (send-event
         proc
         'attack
         (-> event param 0)
         (static-attack-info ((mode 'damage) (shove-back (meters 6)) (shove-up (meters 3))))
         )
       )
      )
    )
  :code (behavior ()
    (ja-no-eval :group! (-> self draw art-group data 3) :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (ja-channel-push! 1 (seconds 0.1))
    (restore-collide-with-as (-> self root-override))
    (sound-play "eco-torch" :position (the-as symbol (-> self blast-pos)))
    (dotimes (gp-1 2)
      (ja-no-eval :group! (-> self draw art-group data 4) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (set! (-> self blast-pos quad) (-> self node-list data 5 bone transform vector 3 quad))
        (citb-firehose-blast-particles)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (clear-collide-with-as (-> self root-override))
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! (-> self draw art-group data 5) :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go citb-firehose-active)
    (none)
    )
  :post (the-as (function none :behavior citb-firehose) transform-post)
  )

(defmethod init-from-entity! citb-firehose ((obj citb-firehose) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 3) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 -61440.0 0.0 36864.0)
      (set-root-prim! s4-0 s3-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core offense) (collide-offense normal-attack))
        (set-vector! (-> s2-0 local-sphere) 0.0 -49152.0 0.0 12288.0)
        (append-prim s3-0 s2-0)
        )
      (let ((s2-1 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
        (set! (-> s2-1 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-1 collide-with) (collide-kind target))
        (set! (-> s2-1 prim-core offense) (collide-offense normal-attack))
        (set-vector! (-> s2-1 local-sphere) 0.0 -61440.0 0.0 14336.0)
        (append-prim s3-0 s2-1)
        )
      (let ((s2-2 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
        (set! (-> s2-2 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-2 collide-with) (collide-kind target))
        (set! (-> s2-2 prim-core offense) (collide-offense normal-attack))
        (set-vector! (-> s2-2 local-sphere) 0.0 -73728.0 0.0 16384.0)
        (append-prim s3-0 s2-2)
        )
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *citb-firehose-sg* '())
  (load-params! (-> obj sync) obj (the-as uint 900) 0.0 0.15 0.15)
  (set! (-> obj idle-distance) 286720.0)
  (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 685) obj))
  (clear-collide-with-as (-> obj root-override))
  (go citb-firehose-idle)
  (none)
  )

(defskelgroup *citb-exit-plat-sg* citb-exit-plat citb-exit-plat-lod0-jg citb-exit-plat-idle-ja
              ((citb-exit-plat-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 30)
              )

(deftype citb-exit-plat (plat-button)
  ((idle-height float   :offset-assert 240)
   (rise-height float   :offset-assert 244)
   (activated   symbol  :offset-assert 248)
   )
  :heap-base #x90
  :method-count-assert 33
  :size-assert         #xfc
  :flag-assert         #x21009000fc
  (:states
    citb-exit-plat-idle
    citb-exit-plat-rise
    )
  )


(defstate citb-exit-plat-idle (citb-exit-plat)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('trigger)
       (let ((v1-3 (-> self entity extra perm)))
         (logior! (-> v1-3 status) (entity-perm-status user-set-from-cstage))
         (set! (-> v1-3 user-int8 0) 1)
         )
       (go citb-exit-plat-rise)
       )
      )
    )
  :code (behavior ()
    (logior! (-> self draw status) (draw-status hidden))
    (clear-collide-with-as (-> self root-override))
    (loop
      (suspend)
      )
    (none)
    )
  )

(defstate citb-exit-plat-rise (citb-exit-plat)
  :trans (the-as (function none :behavior citb-exit-plat) rider-trans)
  :code (behavior ()
    (logclear! (-> self draw status) (draw-status hidden))
    (restore-collide-with-as (-> self root-override))
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (loop
      (let ((f30-0 (- 1.0 (* 0.0016666667 (the float (- (-> *display* base-frame-counter) (-> self state-time)))))))
        (when (< f30-0 0.0)
          (set! (-> self root-override trans y) (-> self rise-height))
          (go-virtual plat-button-idle)
          )
        (set! (-> self root-override trans y) (lerp (-> self rise-height) (-> self idle-height) (* f30-0 f30-0)))
        )
      (suspend)
      )
    (none)
    )
  :post (the-as (function none :behavior citb-exit-plat) rider-post)
  )

(defbehavior citb-exit-plat-move-player citb-exit-plat ((arg0 vector))
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (vector-! gp-0 (-> self root-override trans) arg0)
      (vector-! s5-0 (-> *target* control trans) (-> self root-override trans))
      (set! (-> s5-0 y) 0.0)
      (let ((f30-0 (vector-length s5-0)))
        (when (< 122880.0 f30-0)
          (vector-normalize! s5-0 1.0)
          (vector+*! gp-0 gp-0 s5-0 (- 122880.0 f30-0))
          )
        )
      )
    (move-by-vector! (-> *target* control) gp-0)
    )
  (send-event *target* 'reset-height)
  0
  (none)
  )

(defstate plat-button-move-downward (citb-exit-plat)
  :virtual #t
  :trans (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (set! (-> gp-0 quad) (-> self root-override trans quad))
      (let ((t9-1 (-> (the-as (state plat-button) (find-parent-method citb-exit-plat 23)) trans)))
        (if t9-1
            (t9-1)
            )
        )
      (citb-exit-plat-move-player gp-0)
      )
    (none)
    )
  :post (the-as (function none :behavior citb-exit-plat) transform-post)
  )

(defstate plat-button-move-upward (citb-exit-plat)
  :virtual #t
  :trans (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (set! (-> gp-0 quad) (-> self root-override trans quad))
      (let ((t9-1 (-> (the-as (state plat-button) (find-parent-method citb-exit-plat 24)) trans)))
        (if t9-1
            (t9-1)
            )
        )
      (citb-exit-plat-move-player gp-0)
      )
    (none)
    )
  :post (the-as (function none :behavior citb-exit-plat) transform-post)
  )

(defmethod can-activate? citb-exit-plat ((obj citb-exit-plat))
  (not (movie?))
  )

(defmethod plat-button-method-31 citb-exit-plat ((obj citb-exit-plat))
  (initialize-skeleton obj *citb-exit-plat-sg* '())
  (none)
  )

(defmethod plat-button-method-32 citb-exit-plat ((obj citb-exit-plat))
  (if (-> obj activated)
      (go (method-of-object obj plat-button-idle))
      (go citb-exit-plat-idle)
      )
  0
  (none)
  )

(defmethod plat-button-method-28 citb-exit-plat ((obj citb-exit-plat))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-others))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s5-0 1)
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 122880.0)
      (set-root-prim! s5-0 s4-0)
      (let ((s3-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 1))))
        (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
        (set! (-> s3-0 collide-with) (collide-kind target))
        (set! (-> s3-0 prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
        (set! (-> s3-0 transform-index) 4)
        (set-vector! (-> s3-0 local-sphere) 0.0 -2867.2 0.0 7372.8)
        (append-prim s4-0 s3-0)
        )
      (let ((s3-1 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 2))))
        (set! (-> s3-1 prim-core collide-as) (collide-kind ground-object))
        (set! (-> s3-1 collide-with) (collide-kind target))
        (set! (-> s3-1 prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> s3-1 prim-core offense) (collide-offense indestructible))
        (set! (-> s3-1 transform-index) 3)
        (set-vector! (-> s3-1 local-sphere) 0.0 0.0 0.0 122880.0)
        (append-prim s4-0 s3-1)
        )
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> obj root-override) s5-0)
    s5-0
    )
  )

(defmethod can-target-move? citb-exit-plat ((obj citb-exit-plat))
  (process-entity-status! obj (entity-perm-status bit-7) #t)
  (logclear! (-> obj mask) (process-mask actor-pause))
  (set! (-> obj draw light-index) (the-as uint 255))
  (let ((a0-5 (entity-actor-lookup (-> obj entity) 'state-actor 0)))
    (set! (-> obj activated) (logtest? (-> a0-5 extra perm status) (entity-perm-status complete)))
    )
  (cond
    ((= (-> *game-info* current-continue level) 'finalboss)
     (let ((v1-8 (-> obj entity extra perm)))
       (logior! (-> v1-8 status) (entity-perm-status user-set-from-cstage))
       (set! (-> v1-8 user-int8 0) 1)
       )
     (set! (-> obj activated) #t)
     (set! (-> obj path-pos) 0.0)
     )
    (else
      (set! (-> obj path-pos) 1.0)
      )
    )
  (let ((s5-0 (-> obj root-override trans)))
    (eval-path-curve! (-> obj path) s5-0 (-> obj path-pos) 'interp)
    (vector+! s5-0 s5-0 (-> obj trans-off))
    )
  (set! (-> obj rise-height) (-> obj root-override trans y))
  (set! (-> obj idle-height) (+ -286720.0 (-> obj rise-height)))
  (if (-> obj activated)
      (set! (-> obj root-override trans y) (-> obj rise-height))
      (set! (-> obj root-override trans y) (-> obj idle-height))
      )
  (set! (-> obj allow-auto-kill) #f)
  (process-entity-status! obj (entity-perm-status bit-3) #t)
  0
  (none)
  )
