;;-*-Lisp-*-
(in-package goal)

;; name: lavatube-energy.gc
;; name in dgo: lavatube-energy
;; dgos: L1, LAV

;; DECOMP BEGINS

(import "goal_src/jak1/import/energyball-ag.gc")
(import "goal_src/jak1/import/energybase-ag.gc")
(import "goal_src/jak1/import/energyhub-ag.gc")
(import "goal_src/jak1/import/energyarm-ag.gc")
(import "goal_src/jak1/import/energydoor-ag.gc")

(defpartgroup group-energyarm
  :id 544
  :bounds (static-bspherem 0 0 0 4)
  :parts ((sp-item 1931 :fade-after (meters 120)) (sp-item 2167 :fade-after (meters 60) :falloff-to (meters 60)))
  )

(defpart 1931
  :init-specs ((:texture (new 'static 'texture-id :index #x12 :page #x2))
    (:num 1.0)
    (:scale-x (meters 2) (meters 0.5))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 192.0 32.0)
    (:g 128.0 64.0)
    (:b 64.0 128.0)
    (:a 64.0 32.0)
    (:scalevel-x (meters -0.016666668))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -1.0666667)
    (:timer (seconds 0.2))
    (:flags (bit0 bit2 bit3 bit14))
    )
  )

(defpart 2167
  :init-specs ((:texture (new 'static 'texture-id :index #xf :page #x2))
    (:num 1.0 8.0)
    (:scale-x (meters 0.5) (meters 0.3))
    (:scale-y :copy scale-x)
    (:r 128.0 128.0)
    (:g 128.0)
    (:b 64.0)
    (:a 64.0 64.0)
    (:vel-y (meters 0.013333334) (meters 0.08))
    (:scalevel-x (meters -0.00055555557))
    (:scalevel-y :copy scalevel-x)
    (:fade-g -0.2)
    (:fade-b -0.2)
    (:fade-a -0.6)
    (:accel-y (meters -0.0016666667))
    (:friction 0.94)
    (:timer (seconds 0.1) (seconds 0.497))
    (:flags (bit2))
    (:conerot-x (degrees 0) (degrees 180))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpartgroup group-energyball-always
  :id 545
  :bounds (static-bspherem 0 0 0 8)
  :parts ((sp-item 2168 :fade-after (meters 80) :falloff-to (meters 80))
    (sp-item 2169 :fade-after (meters 120))
    (sp-item 2170 :fade-after (meters 120))
    (sp-item 2171 :fade-after (meters 120) :flags (is-3d))
    (sp-item 2172 :fade-after (meters 80) :falloff-to (meters 80))
    (sp-item 2173 :fade-after (meters 120) :falloff-to (meters 120))
    (sp-item 2174 :fade-after (meters 120) :falloff-to (meters 120))
    (sp-item 2175 :fade-after (meters 120) :falloff-to (meters 120))
    )
  )

(defpart 2168
  :init-specs ((:texture (new 'static 'texture-id :index #x12 :page #x2))
    (:num 8.0)
    (:y (meters -5.5))
    (:scale-x (meters 0.2) (meters 0.1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 192.0)
    (:g 192.0)
    (:b 64.0 128.0)
    (:a 8.0 24.0)
    (:vel-y (meters 0.10666667) (meters 0.053333335))
    (:rotvel-z (degrees -0.15) (degrees 0.3))
    (:fade-a 0.35555556)
    (:accel-y (meters -0.0004) (meters -0.0004))
    (:friction 0.9)
    (:timer (seconds 0.4) (seconds 0.197))
    (:flags (bit2 bit3 bit14))
    (:next-time (seconds 0.1) (seconds 0.397))
    (:next-launcher 2176)
    (:conerot-x (degrees 0) (degrees 90))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 2176
  :init-specs ((:scale-x (meters 1.2)) (:scale-y :copy scale-x) (:a 48.0) (:timer (seconds 0.017)))
  )

(defpart 2177
  :init-specs ((:texture (new 'static 'texture-id :index #x12 :page #x2))
    (:num 8.0)
    (:scale-x (meters 0.3) (meters 0.2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 192.0)
    (:g 192.0)
    (:b 64.0 128.0)
    (:a 64.0)
    (:vel-y (meters 0.10666667) (meters 0.053333335))
    (:rotvel-z (degrees -0.15) (degrees 0.3))
    (:friction 0.9)
    (:timer (seconds 0.035) (seconds 0.137))
    (:flags (bit2 bit3 bit14))
    (:next-time (seconds 0.035) (seconds 0.137))
    (:next-launcher 2176)
    (:conerot-x (degrees 0) (degrees 180))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 5.5))
    )
  )

(defpart 2169
  :init-specs ((:texture (new 'static 'texture-id :index #x12 :page #x2))
    (:num 1.0)
    (:y (meters -5.5))
    (:scale-x (meters 8) (meters 4))
    (:scale-y (meters 24))
    (:r 192.0 32.0)
    (:g 128.0 64.0)
    (:b 64.0 128.0)
    (:a 64.0 64.0)
    (:timer (seconds 0.017))
    (:flags (bit2 bit3 bit14))
    )
  )

(defpart 2170
  :init-specs ((:texture (new 'static 'texture-id :index #x12 :page #x2))
    (:num 1.0)
    (:y (meters -5.5))
    (:scale-x (meters 12) (meters 8))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 192.0 32.0)
    (:g 128.0 64.0)
    (:b 64.0 128.0)
    (:a 16.0 32.0)
    (:timer (seconds 0.017))
    (:flags (bit2 bit3 bit14))
    )
  )

(defpart 2171
  :init-specs ((:texture (new 'static 'texture-id :index #x12 :page #x2))
    (:num 1.0)
    (:y (meters -5))
    (:scale-x (meters 12) (meters 8))
    (:rot-y (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 192.0 32.0)
    (:g 128.0 64.0)
    (:b 64.0 128.0)
    (:a 16.0 32.0)
    (:scalevel-x (meters -0.040404037))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.12121211)
    (:timer (seconds 0.66))
    (:flags (bit2 bit3 bit14))
    )
  )

(defpart 2172
  :init-specs ((:texture (new 'static 'texture-id :index #xf :page #x2))
    (:num 2.0)
    (:y (meters -5.5))
    (:scale-x (meters 0.5))
    (:rot-z (degrees 70) (degrees 40))
    (:scale-y (meters 12))
    (:r 255.0)
    (:g 196.0)
    (:b 64.0)
    (:a 32.0 64.0)
    (:scalevel-y (meters 0.85333335))
    (:fade-g -3.2666667)
    (:fade-b -1.0666667)
    (:fade-a -1.6)
    (:timer (seconds 0.2))
    (:flags (bit2 bit3 bit14))
    )
  )

(defpart 2173
  :init-specs ((:texture (new 'static 'texture-id :index #x1f :page #x2))
    (:num 1.0)
    (:scale-x (meters 8) (meters 6))
    (:rot-x 4)
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 1) (meters 0.5))
    (:r 255.0)
    (:g 196.0)
    (:b 196.0)
    (:a 128.0)
    (:fade-a -6.4)
    (:timer (seconds 0.14))
    (:flags (bit2 bit3 bit14))
    (:next-time (seconds 0.035))
    (:next-launcher 2178)
    )
  )

(defpart 2178
  :init-specs ((:b 0.0) (:a 64.0) (:fade-g -4.266667))
  )

(defpart 2174
  :init-specs ((:texture (new 'static 'texture-id :index #x23 :page #x2))
    (:num 1.0)
    (:scale-x (meters 8) (meters 4))
    (:rot-x 4)
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 1) (meters 0.5))
    (:r 255.0)
    (:g 196.0)
    (:b 196.0)
    (:a 128.0)
    (:fade-a -6.4)
    (:timer (seconds 0.14))
    (:flags (bit2 bit3 bit14))
    (:next-time (seconds 0.035))
    (:next-launcher 2178)
    )
  )

(defpart 2175
  :init-specs ((:texture (new 'static 'texture-id :index #x24 :page #x2))
    (:num 1.0)
    (:scale-x (meters 8) (meters 4))
    (:rot-x 4)
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 1) (meters 0.5))
    (:r 255.0)
    (:g 196.0)
    (:b 196.0)
    (:a 128.0)
    (:fade-a -6.4)
    (:timer (seconds 0.14))
    (:flags (bit2 bit3 bit14))
    (:next-time (seconds 0.035))
    (:next-launcher 2178)
    )
  )

(defpartgroup group-energyball-explode
  :id 546
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 45)
  :parts ((sp-item 2179 :period (seconds 2) :length (seconds 0.017))
    (sp-item 2180 :period (seconds 2) :length (seconds 0.135))
    (sp-item 2181 :period (seconds 2) :length (seconds 0.067))
    (sp-item 2182 :period (seconds 2) :length (seconds 0.067))
    )
  )

(defpart 2180
  :init-specs ((:texture (new 'static 'texture-id :index #xf :page #x2))
    (:num 8.0)
    (:y (meters 0))
    (:scale-x (meters 0.5) (meters 1))
    (:scale-y :copy scale-x)
    (:r 192.0 32.0)
    (:g 128.0 64.0)
    (:b 64.0 64.0)
    (:a 32.0 96.0)
    (:vel-y (meters 0.06666667) (meters 0.26666668))
    (:scalevel-x (meters -0.0026666666))
    (:scalevel-y :copy scalevel-x)
    (:accel-y (meters -0.00016666666) (meters -0.00016666666))
    (:friction 0.9)
    (:timer (seconds 1))
    (:flags (bit2 bit14))
    (:next-time (seconds 0.1) (seconds 0.297))
    (:next-launcher 2183)
    (:conerot-x (degrees 0) (degrees 180))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 2) (meters 4))
    )
  )

(defpart 2183
  :init-specs ((:fade-a -1.0666667))
  )

(defpart 2182
  :init-specs ((:texture (new 'static 'texture-id :index #xf :page #x2))
    (:num 6.0)
    (:y (meters 0))
    (:scale-x (meters 0.4))
    (:rot-z (degrees 0) (degrees 180))
    (:scale-y (meters 24))
    (:r 192.0 32.0)
    (:g 128.0 64.0)
    (:b 64.0 64.0)
    (:a 32.0 64.0)
    (:scalevel-y (meters 1.6666666))
    (:fade-a -1.6)
    (:timer (seconds 0.2))
    (:flags (bit2 bit3 bit14))
    )
  )

(defpart 2179
  :init-specs ((:texture (new 'static 'texture-id :index #x12 :page #x2))
    (:num 1.0)
    (:y (meters 0))
    (:scale-x (meters 40))
    (:scale-y :copy scale-x)
    (:r 192.0 32.0)
    (:g 128.0 64.0)
    (:b 64.0 64.0)
    (:a 128.0)
    (:fade-a -2.3272727)
    (:timer (seconds 0.18))
    (:flags (bit2 bit3 bit14))
    )
  )

(defpart 2181
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 12.0)
    (:x (meters -2) (meters 4))
    (:y (meters -2) (meters 4))
    (:z (meters -2) (meters 4))
    (:scale-x (meters 5) (meters 2.5))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 192.0 32.0)
    (:g 128.0 64.0)
    (:b 64.0 64.0)
    (:a 64.0 64.0)
    (:vel-y (meters 0.10666667) (meters 0.053333335))
    (:scalevel-x (meters 0.02))
    (:rotvel-z (degrees -0.6) (degrees 1.2))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.28444445)
    (:accel-y (meters 0.00016666666) (meters 0.000033333334))
    (:friction 0.8)
    (:timer (seconds 1.7))
    (:flags (bit2 bit3 bit14))
    (:conerot-x (degrees 0) (degrees 180))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 0) (meters 6))
    )
  )

(deftype energydoor (process-drawable)
  ((root-override collide-shape-moving  :offset        112)
   (alt-actor     entity-actor          :offset-assert 176)
   )
  :heap-base #x50
  :method-count-assert 20
  :size-assert         #xb4
  :flag-assert         #x14005000b4
  (:states
    energydoor-closed-till-near
    energydoor-closed-till-task
    energydoor-closing
    energydoor-opened
    energydoor-opening
    )
  )


(defskelgroup *energydoor-sg* energydoor energydoor-lod0-jg energydoor-idle-ja
              ((energydoor-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 14 0 35)
              )

(defbehavior energydoor-player-dist energydoor ()
  (let ((gp-0 (new 'stack-no-clear 'vector))
        (s5-0 (new 'stack-no-clear 'matrix))
        )
    (vector-! gp-0 (target-pos 0) (-> self root-override trans))
    (quaternion->matrix s5-0 (-> self root-override quat))
    (vector-dot gp-0 (the-as vector (-> s5-0 vector)))
    )
  )

(defbehavior energydoor-open-handler energydoor ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (the-as object (case arg2
                   (('open?)
                    #t
                    )
                   )
          )
  )

(defbehavior energydoor-closed-handler energydoor ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('open)
     (go energydoor-opening)
     )
    (('open?)
     #f
     )
    )
  )

(defstate energydoor-closing (energydoor)
  :event energydoor-closed-handler
  :code (behavior ()
    (ja-no-eval :group! (ja-group) :num! (seek! 0.0) :frame-num max)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! 0.0))
      )
    (if (or (task-closed? (-> self entity extra perm task) (task-status need-resolution))
            (< (energydoor-player-dist) 0.0)
            )
        (go energydoor-closed-till-near)
        (go energydoor-closed-till-task)
        )
    (none)
    )
  :post (the-as (function none :behavior energydoor) transform-post)
  )

(defstate energydoor-opened (energydoor)
  :event energydoor-open-handler
  :trans (behavior ()
    (let ((f30-0 (energydoor-player-dist)))
      (cond
        ((< f30-0 -450560.0)
         (go energydoor-closing)
         )
        ((and (not (task-closed? (-> self entity extra perm task) (task-status need-resolution)))
              (< 61440.0 f30-0)
              (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
                (set! (-> a1-1 from) self)
                (set! (-> a1-1 num-params) 0)
                (set! (-> a1-1 message) 'open?)
                (let ((t9-3 send-event-function)
                      (v1-7 (-> self alt-actor))
                      )
                  (not (t9-3
                         (if v1-7
                             (-> v1-7 extra process)
                             )
                         a1-1
                         )
                       )
                  )
                )
              )
         (go energydoor-closing)
         )
        )
      )
    (none)
    )
  :code (behavior ()
    (ja :num-func num-func-identity :frame-num max)
    (transform-post)
    (loop
      (suspend)
      )
    (none)
    )
  )

(defstate energydoor-opening (energydoor)
  :event energydoor-open-handler
  :code (behavior ()
    (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go energydoor-opened)
    (none)
    )
  :post (the-as (function none :behavior energydoor) transform-post)
  )

(defstate energydoor-closed-till-task (energydoor)
  :event energydoor-closed-handler
  :trans (behavior ()
    (cond
      ((task-closed? (-> self entity extra perm task) (task-status need-resolution))
       (go energydoor-opening)
       )
      ((let ((a1-1 (new 'stack-no-clear 'event-message-block)))
         (set! (-> a1-1 from) self)
         (set! (-> a1-1 num-params) 0)
         (set! (-> a1-1 message) 'open?)
         (let ((t9-2 send-event-function)
               (v1-5 (-> self alt-actor))
               )
           (t9-2
             (if v1-5
                 (-> v1-5 extra process)
                 )
             a1-1
             )
           )
         )
       (go energydoor-opening)
       )
      )
    (none)
    )
  :code (behavior ()
    (ja :num-func num-func-identity :frame-num 0.0)
    (transform-post)
    (loop
      (suspend)
      )
    (none)
    )
  )

(defstate energydoor-closed-till-near (energydoor)
  :event energydoor-closed-handler
  :trans (behavior ()
    (if (< -409600.0 (energydoor-player-dist))
        (go energydoor-opening)
        )
    (none)
    )
  :code (behavior ()
    (ja :num-func num-func-identity :frame-num 0.0)
    (transform-post)
    (loop
      (suspend)
      )
    (none)
    )
  )

(defmethod init-from-entity! energydoor ((obj energydoor) (arg0 entity-actor))
  (with-pp
    (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-player))))
      (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
      (set! (-> s4-0 reaction) default-collision-reaction)
      (set! (-> s4-0 no-reaction)
            (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
            )
      (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
        (set! (-> s3-0 prim-core collide-as) (collide-kind wall-object))
        (set! (-> s3-0 collide-with) (collide-kind target))
        (set! (-> s3-0 prim-core action) (collide-action solid))
        (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
        (set! (-> s3-0 transform-index) 8)
        (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 102400.0)
        (set-root-prim! s4-0 s3-0)
        )
      (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
      (backup-collide-with-as s4-0)
      (set! (-> obj root-override) s4-0)
      )
    (process-drawable-from-entity! obj arg0)
    (initialize-skeleton obj *energydoor-sg* '())
    (set! (-> obj root-override pause-adjust-distance) 245760.0)
    (set! (-> obj alt-actor) (entity-actor-lookup arg0 'alt-actor 0))
    (cond
      ((< (energydoor-player-dist) -409600.0)
       (go energydoor-closed-till-near)
       )
      ((task-closed? (-> obj entity extra perm task) (task-status need-resolution))
       (go energydoor-opened)
       )
      (else
        (let ((a1-9 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-9 from) pp)
          (set! (-> a1-9 num-params) 0)
          (set! (-> a1-9 message) 'open?)
          (let ((t9-12 send-event-function)
                (v1-25 (-> obj alt-actor))
                )
            (cond
              ((t9-12
                 (if v1-25
                     (-> v1-25 extra process)
                     )
                 a1-9
                 )
               (go energydoor-opened)
               )
              ((< 0.0 (energydoor-player-dist))
               (go energydoor-closed-till-task)
               )
              (else
                (go energydoor-opened)
                )
              )
            )
          )
        )
      )
    (none)
    )
  )

(deftype energybase (process-drawable)
  ()
  :heap-base #x40
  :method-count-assert 20
  :size-assert         #xb0
  :flag-assert         #x14004000b0
  (:states
    energybase-idle
    energybase-stopped
    energybase-stopping
    )
  )


(defskelgroup *energybase-sg* energybase energybase-lod0-jg energybase-idle-ja
              ((energybase-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 40 0 40)
              )

(defstate energybase-stopped (energybase)
  :code (behavior ()
    (ja-post)
    (loop
      (suspend)
      )
    (none)
    )
  )

(defstate energybase-stopping (energybase)
  :code (behavior ()
    (let ((f30-0 1.0))
      (loop
        (ja-no-eval :group! (ja-group) :num! (seek! max f30-0) :frame-num 0.0)
        (until (ja-done? 0)
          (set! f30-0 (- f30-0 (* 0.002 (-> *display* time-adjust-ratio))))
          (if (< f30-0 0.0)
              (go energybase-stopped)
              )
          (suspend)
          (ja :num! (seek! max f30-0))
          )
        )
      )
    (none)
    )
  :post (the-as (function none :behavior energybase) ja-post)
  )

(defstate energybase-idle (energybase)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('stop)
       (go energybase-stopping)
       )
      )
    )
  :code (behavior ()
    (loop
      (if (and *target* (>= 307200.0 (vector-vector-distance (-> self root trans) (-> *target* control trans))))
          (level-hint-spawn (text-id lavatube-balls) "sksp0375" (the-as entity #f) *entity-pool* (game-task none))
          )
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (none)
    )
  :post (the-as (function none :behavior energybase) ja-post)
  )

(defmethod init-from-entity! energybase ((obj energybase) (arg0 entity-actor))
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *energybase-sg* '())
  (if (task-closed? (game-task lavatube-balls) (task-status need-resolution))
      (go energybase-stopped)
      (go energybase-idle)
      )
  (none)
  )

(deftype energyhub (process-drawable)
  ((self-override         energyhub                  :offset         28)
   (alts                  entity-actor       3       :offset-assert 176)
   (arm                   handle             5       :offset-assert 192)
   (rot-mat               matrix             :inline :offset-assert 240)
   (rot-mat-init          matrix             :inline :offset-assert 304)
   (rotation-speed        oscillating-float  :inline :offset-assert 368)
   (rotation-speed-offset delayed-rand-float :inline :offset-assert 392)
   (y-rotation            float                      :offset-assert 420)
   (x-rotation            float                      :offset-assert 424)
   (palette-val           float                      :offset-assert 428)
   )
  :heap-base #x140
  :method-count-assert 20
  :size-assert         #x1b0
  :flag-assert         #x14014001b0
  (:states
    energyhub-idle
    energyhub-stop
    energyhub-stopped
    )
  )


(deftype energyarm (process-drawable)
  ((parent-overide     (pointer energyhub)          :offset         12)
   (self-override      energyarm                    :offset         28)
   (root-override      collide-shape-moving         :offset        112)
   (offset             vector               :inline :offset-assert 176)
   (y-rotation         float                        :offset-assert 192)
   (y-chatter-rotation bouncing-float       :inline :offset-assert 196)
   (y-chatter-min      delayed-rand-float   :inline :offset-assert 240)
   (x-rotation         bouncing-float       :inline :offset-assert 268)
   (x-fall-rotation    bouncing-float       :inline :offset-assert 308)
   (rot-mat            matrix               :inline :offset-assert 352)
   (ball               handle                       :offset-assert 416)
   (x-correction       float                        :offset-assert 424)
   )
  :heap-base #x140
  :method-count-assert 20
  :size-assert         #x1ac
  :flag-assert         #x14014001ac
  (:states
    energyarm-fall
    energyarm-idle
    energyarm-no-ball
    energyarm-stop
    )
  )


(deftype energyball (process-drawable)
  ((parent-overide (pointer energyarm)   :offset  12)
   (root-override  collide-shape-moving  :offset 112)
   )
  :heap-base #x40
  :method-count-assert 20
  :size-assert         #xb0
  :flag-assert         #x14004000b0
  (:states
    energyball-idle
    )
  )


(defskelgroup *energyball-sg* energyball energyball-lod0-jg energyball-idle-ja
              ((energyball-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 6)
              )

(defstate energyball-idle (energyball)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('attack)
                      (when (and (>= arg1 2) (= (-> event param 1) 'eco-yellow))
                        (increment-success-for-hint (text-id lavatube-balls))
                        (sound-play "dcrate-break")
                        (process-spawn
                          part-tracker
                          :init part-tracker-init
                          (-> *part-group-id-table* 546)
                          600
                          #f
                          #f
                          #f
                          (-> self root-override trans)
                          :to *entity-pool*
                          )
                        (cleanup-for-death self)
                        (the-as symbol (deactivate self))
                        )
                      )
                     )
            )
    )
  :trans (behavior ()
    (rider-trans)
    (spawn (-> self part) (-> self root-override trans))
    (let* ((v1-3 (-> self parent-overide))
           (s5-0 (if v1-3
                     (-> v1-3 0 self-override)
                     )
                 )
           (gp-0 (if (and (nonzero? s5-0) (type-type? (-> s5-0 type) energyarm))
                     s5-0
                     )
                 )
           (s4-0 (new 'stack-no-clear 'vector))
           (s5-1 (new 'stack-no-clear 'matrix))
           (f0-1 (the float (-> *display* base-frame-counter)))
           (f30-0 (- f0-1 (* (the float (the int (/ f0-1 -150.0))) -150.0)))
           )
      (when gp-0
        (set-vector! s4-0 0.0 -61440.0 -106496.0 1.0)
        (vector-matrix*! s4-0 s4-0 (-> gp-0 rot-mat))
        (vector+! (-> self root-override trans) s4-0 (-> gp-0 root-override trans))
        (matrix-rotate-y! s5-1 (* -436.90668 f30-0))
        (matrix*! s5-1 s5-1 (-> gp-0 rot-mat))
        (matrix->quaternion (-> self root-override quat) s5-1)
        )
      )
    (none)
    )
  :code (behavior ()
    (loop
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (none)
    )
  :post (the-as (function none :behavior energyball) rider-post)
  )

(defun energyball-init ((arg0 energyball))
  (set! (-> arg0 mask) (logior (process-mask attackable) (-> arg0 mask)))
  (let ((s5-0 (new 'process 'collide-shape-moving arg0 (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind wall-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 20480.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> arg0 root-override) s5-0)
    s5-0
    )
  )

(defbehavior energyball-init-by-other energyball ((arg0 vector))
  (energyball-init self)
  (set! (-> self root-override trans quad) (-> arg0 quad))
  (initialize-skeleton self *energyball-sg* '())
  (set! (-> self part) (create-launch-control (-> *part-group-id-table* 545) self))
  (go energyball-idle)
  (none)
  )

(defskelgroup *energyarm-sg* energyarm energyarm-lod0-jg energyarm-idle-ja
              ((energyarm-lod0-mg (meters 20)) (energyarm-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 -20 17)
              )

(defbehavior energyarm-trans energyarm ()
  (rider-trans)
  (let* ((v1-0 (-> self parent-overide))
         (gp-0 (if v1-0
                   (-> v1-0 0 self-override)
                   )
               )
         (s5-0 (if (and (nonzero? gp-0) (type-type? (-> gp-0 type) energyhub))
                   gp-0
                   )
               )
         (gp-1 (new 'stack-no-clear 'vector))
         (s4-0 (new 'stack-no-clear 'matrix))
         )
    0.0
    (when s5-0
      (matrix-rotate-y!
        (-> self rot-mat)
        (+ (* -1820.4445 (-> self y-chatter-rotation osc value)) (-> self y-rotation))
        )
      (matrix*! (-> self rot-mat) (-> self rot-mat) (-> s5-0 rot-mat))
      (let ((f0-7 (* (-> self x-correction) (-> s5-0 x-rotation) (cos (-> self y-rotation)))))
        (matrix-rotate-x!
          s4-0
          (+ f0-7 (* 910.2222 (-> self x-rotation osc value)) (* -7281.778 (-> self x-fall-rotation osc value)))
          )
        )
      (matrix*! (-> self rot-mat) s4-0 (-> self rot-mat))
      (set-vector! gp-1 0.0 0.0 -81920.0 1.0)
      (vector-matrix*! (-> self draw bounds) gp-1 (-> self rot-mat))
      (set! (-> self draw bounds w) 69632.0)
      (matrix->quaternion (-> self root-override quat) (-> self rot-mat))
      (vector-matrix*! gp-1 (-> self offset) (-> s5-0 rot-mat))
      (vector+! (-> self root-override trans) (-> s5-0 root trans) gp-1)
      )
    )
  )

(defstate energyarm-stop (energyarm)
  :enter (behavior ()
    '()
    (none)
    )
  :trans (behavior ()
    (update! (-> self x-rotation) 0.0)
    (update! (-> self y-chatter-rotation) 0.0)
    (energyarm-trans)
    (none)
    )
  :code (behavior ()
    (loop
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (none)
    )
  :post (the-as (function none :behavior energyarm) rider-post)
  )

(defstate energyarm-no-ball (energyarm)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('stop)
       (go energyarm-stop)
       )
      )
    )
  :enter (behavior ()
    (set! (-> self y-chatter-rotation osc target) 1.0)
    (none)
    )
  :trans (behavior ()
    (set! (-> self x-correction) (fmax -1.0 (+ -0.1 (-> self x-correction))))
    (update! (-> self x-rotation) 0.0)
    (when (at-min? (-> self x-rotation))
      (let* ((f30-0 0.15)
             (v1-6 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
             (v1-7 (the-as number (logior #x3f800000 v1-6)))
             )
        (set! (-> self x-rotation osc vel) (fmax (* f30-0 (+ -1.0 (the-as float v1-7))) (-> self x-rotation osc vel)))
        )
      )
    (update! (-> self y-chatter-rotation) 0.0)
    (when (at-max? (-> self y-chatter-rotation))
      (let* ((f30-1 -0.1)
             (v1-16 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
             (v1-17 (the-as number (logior #x3f800000 v1-16)))
             (f30-2 (* f30-1 (+ -1.0 (the-as float v1-17))))
             )
        (update! (-> self y-chatter-min))
        (set! (-> self y-chatter-rotation min-value) (fabs (-> self y-chatter-min value)))
        (set! (-> self y-chatter-rotation osc vel) (fmin f30-2 (-> self y-chatter-rotation osc vel)))
        )
      )
    (energyarm-trans)
    (none)
    )
  :code (behavior ()
    (loop
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (none)
    )
  :post (the-as (function none :behavior energyarm) rider-post)
  )

(defstate energyarm-fall (energyarm)
  :enter (behavior ()
    (set! (-> self x-fall-rotation osc target) 1.0)
    (none)
    )
  :trans (behavior ()
    (update! (-> self x-fall-rotation) 0.0)
    (update! (-> self y-chatter-rotation) 0.0)
    (when (at-max? (-> self x-fall-rotation))
      (set! (-> self y-chatter-rotation min-value) -1.0)
      (set! (-> self y-chatter-rotation osc vel) 0.2)
      (if (< -0.01 (-> self x-fall-rotation osc vel))
          (go energyarm-no-ball)
          )
      )
    (energyarm-trans)
    (none)
    )
  :code (behavior ()
    (loop
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (none)
    )
  :post (the-as (function none :behavior energyarm) rider-post)
  )

(defstate energyarm-idle (energyarm)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('stop)
       (go energyarm-stop)
       )
      )
    )
  :trans (behavior ()
    (update! (-> self x-rotation) 0.0)
    (when (at-min? (-> self x-rotation))
      (let* ((f30-0 0.15)
             (v1-6 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
             (v1-7 (the-as number (logior #x3f800000 v1-6)))
             )
        (set! (-> self x-rotation osc vel) (fmax (* f30-0 (+ -1.0 (the-as float v1-7))) (-> self x-rotation osc vel)))
        )
      )
    (energyarm-trans)
    (cond
      ((handle->process (-> self ball))
       (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 6)))
       (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 5)))
       (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 4)))
       )
      ((!= (-> self ball) #f)
       (set! (-> self ball) (the-as handle #f))
       (let ((a1-8 (new 'stack-no-clear 'event-message-block)))
         (set! (-> a1-8 from) self)
         (set! (-> a1-8 num-params) 0)
         (set! (-> a1-8 message) 'flash)
         (let ((t9-10 send-event-function)
               (v1-24 (-> self parent-overide))
               )
           (t9-10
             (if v1-24
                 (-> v1-24 0 self-override)
                 )
             a1-8
             )
           )
         )
       )
      )
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (-> self skel root-channel 0)))
      (set! (-> gp-0 num-func) num-func-identity)
      (set! (-> gp-0 frame-num) (* (rand-float-gen) (the float (ja-num-frames 0))))
      )
    (loop
      (suspend)
      (let* ((f30-1 0.25)
             (f28-0 0.25)
             (v1-9 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
             (v1-10 (the-as number (logior #x3f800000 v1-9)))
             (f0-9 (+ f30-1 (* f28-0 (+ -1.0 (the-as float v1-10)))))
             )
        (ja :num! (loop! f0-9))
        )
      )
    (none)
    )
  :post (the-as (function none :behavior energyarm) rider-post)
  )

(defun energyarm-init ((arg0 energyarm))
  (let ((s5-0 (new 'process 'collide-shape-moving arg0 (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind wall-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 -12288.0 -81920.0 69632.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> arg0 root-override) s5-0)
    )
  (let ((v0-5 (create-launch-control (-> *part-group-id-table* 544) arg0)))
    (set! (-> arg0 part) v0-5)
    v0-5
    )
  )

(defbehavior energyarm-init-by-other energyarm ((arg0 vector) (arg1 float))
  (energyarm-init self)
  (let* ((v1-0 (-> self parent-overide))
         (s4-0 (if v1-0
                   (-> v1-0 0 self-override)
                   )
               )
         (a0-3 (if (and (nonzero? s4-0) (type-type? (-> s4-0 type) energyhub))
                   s4-0
                   )
               )
         )
    (if a0-3
        (set! (-> self root-override trans quad) (-> a0-3 root trans quad))
        )
    )
  (initialize-skeleton self *energyarm-sg* '())
  (logclear! (-> self mask) (process-mask actor-pause))
  (set! (-> self offset quad) (-> arg0 quad))
  (set! (-> self y-rotation) arg1)
  (set-params! (-> self x-rotation) 0.0 1.0 0.0 0.7 0.08 0.1 0.97)
  (set-params! (-> self x-fall-rotation) 0.0 1.0 0.0 0.7 0.005 0.08 0.97)
  (set-params! (-> self y-chatter-rotation) 0.0 1.0 0.0 0.7 0.02 0.3 0.97)
  (set-params! (-> self y-chatter-min) 300 600 1.0)
  (set! (-> self x-correction) 0.0)
  (cond
    ((task-closed? (game-task lavatube-balls) (task-status need-resolution))
     (set! (-> self ball) (the-as handle #f))
     (go energyarm-stop)
     )
    (else
      (set! (-> self ball) (ppointer->handle (process-spawn energyball (-> self root-override trans) :to self)))
      (go energyarm-idle)
      )
    )
  (none)
  )

(defskelgroup *energyhub-sg* energyhub energyhub-lod0-jg energyhub-idle-ja
              ((energyhub-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 2 0 10)
              )

(defbehavior energyhub-trans energyhub ()
  (+! (-> self y-rotation)
      (* 36.40889
         (-> self rotation-speed value)
         (the float (- (-> *display* base-frame-counter) (-> *display* old-base-frame-counter)))
         )
      )
  (cond
    ((< 65536.0 (-> self y-rotation))
     (set! (-> self y-rotation) (+ -65536.0 (-> self y-rotation)))
     )
    ((< (-> self y-rotation) 0.0)
     (set! (-> self y-rotation) (+ 65536.0 (-> self y-rotation)))
     )
    )
  (let ((gp-0 (new 'stack-no-clear 'matrix)))
    (let* ((f0-9 (the float (-> *display* base-frame-counter)))
           (f28-0 (- f0-9 (* (the float (the int (/ f0-9 1200.0))) 1200.0)))
           )
      (matrix-rotate-y! gp-0 (-> self y-rotation))
      (matrix*! (-> self rot-mat) gp-0 (-> self rot-mat-init))
      (set! (-> self x-rotation) (* 728.1778 (sin (* 54.613335 f28-0))))
      )
    (matrix-rotate-x! gp-0 (-> self x-rotation))
    (matrix*! (-> self rot-mat) gp-0 (-> self rot-mat))
    )
  (matrix->quaternion (-> self root quat) (-> self rot-mat))
  )

(defbehavior energyhub-set-lava-height energyhub ((arg0 float))
  (let ((v1-0 (-> self alts 2)))
    (when v1-0
      (let ((v1-2 (-> v1-0 extra process)))
        (when v1-2
          (let* ((f0-1 (- 0.0 (-> self palette-val)))
                 (f0-2 (if (< 0.0 f0-1)
                           (fmin 0.1 f0-1)
                           (fmax -0.1 f0-1)
                           )
                       )
                 )
            (+! (-> self palette-val) f0-2)
            )
          (set! (-> *palette-fade-controls* control 2 fade) (-> self palette-val))
          (set! (-> (the-as process-drawable v1-2) root scale x) 1.25)
          (set! (-> (the-as process-drawable v1-2) root scale z) 1.25)
          )
        )
      )
    )
  )

(defstate energyhub-stopped (energyhub)
  :enter (behavior ()
    (set! (-> self rotation-speed target) 0.0)
    (set! (-> self rotation-speed accel) 0.0005)
    (dotimes (gp-0 5)
      (send-event (handle->process (-> self arm gp-0)) 'stop)
      )
    (if (nonzero? (-> self sound))
        (stop! (-> self sound))
        )
    (none)
    )
  :trans (behavior ()
    (update! (-> self rotation-speed) 0.0)
    (energyhub-trans)
    (energyhub-set-lava-height -122880.0)
    (none)
    )
  :code (behavior ()
    (loop
      (suspend)
      (let* ((f30-0 1.0)
             (f28-0 0.25)
             (v1-1 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
             (v1-2 (the-as number (logior #x3f800000 v1-1)))
             (f0-4 (+ f30-0 (* f28-0 (+ -1.0 (the-as float v1-2)))))
             )
        (ja :num! (loop! f0-4))
        )
      )
    (none)
    )
  :post (the-as (function none :behavior energyhub) ja-post)
  )

(defstate energyhub-stop (energyhub)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('flash)
                      (set! (-> self palette-val) 1.9921875)
                      )
                     )
            )
    )
  :enter (behavior ()
    (set! (-> self rotation-speed target) 0.0)
    (set! (-> self rotation-speed accel) 0.0005)
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) self)
      (set! (-> a1-0 num-params) 0)
      (set! (-> a1-0 message) 'stop)
      (let ((t9-0 send-event-function)
            (v1-1 (-> self alts 0))
            )
        (t9-0
          (if v1-1
              (-> v1-1 extra process)
              )
          a1-0
          )
        )
      )
    (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-1 from) self)
      (set! (-> a1-1 num-params) 0)
      (set! (-> a1-1 message) 'open)
      (let ((t9-1 send-event-function)
            (v1-5 (-> self alts 1))
            )
        (t9-1
          (if v1-5
              (-> v1-5 extra process)
              )
          a1-1
          )
        )
      )
    (close-specific-task! (game-task lavatube-balls) (task-status need-resolution))
    (level-hint-spawn
      (text-id lavatube-balls-resolution)
      "sksp0378"
      (the-as entity #f)
      *entity-pool*
      (game-task none)
      )
    (if (nonzero? (-> self sound))
        (stop! (-> self sound))
        )
    (none)
    )
  :trans (behavior ()
    (update! (-> self rotation-speed) 0.0)
    (energyhub-trans)
    (energyhub-set-lava-height -122880.0)
    (if (< (-> self rotation-speed value) 0.3)
        (go energyhub-stopped)
        )
    (none)
    )
  :code (behavior ()
    (loop
      (suspend)
      (let* ((f30-0 1.0)
             (f28-0 0.25)
             (v1-1 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
             (v1-2 (the-as number (logior #x3f800000 v1-1)))
             (f0-4 (+ f30-0 (* f28-0 (+ -1.0 (the-as float v1-2)))))
             )
        (ja :num! (loop! f0-4))
        )
      )
    (none)
    )
  :post (the-as (function none :behavior energyhub) ja-post)
  )

(defstate energyhub-idle (energyhub)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('flash)
                      (set! (-> self palette-val) 1.9921875)
                      )
                     )
            )
    )
  :trans (behavior ()
    (if (nonzero? (-> self sound))
        (update! (-> self sound))
        )
    (let ((gp-0 0))
      (dotimes (s5-0 5)
        (let* ((s4-0 (handle->process (-> self arm s5-0)))
               (v1-10 (if (and (nonzero? s4-0) (type-type? (-> s4-0 type) energyarm))
                          (the-as energyarm s4-0)
                          )
                      )
               )
          (if (and v1-10 (handle->process (-> v1-10 ball)))
              (+! gp-0 1)
              )
          )
        )
      (cond
        ((zero? gp-0)
         (energyhub-set-lava-height -122880.0)
         (go energyhub-stop)
         )
        ((= gp-0 1)
         (set! (-> self rotation-speed target) 1.8)
         (energyhub-set-lava-height -129024.0)
         )
        ((= gp-0 2)
         (set! (-> self rotation-speed target) 1.6)
         (energyhub-set-lava-height -135168.0)
         )
        ((= gp-0 3)
         (set! (-> self rotation-speed target) 1.4)
         (energyhub-set-lava-height -141312.0)
         )
        ((= gp-0 4)
         (set! (-> self rotation-speed target) 1.2)
         (energyhub-set-lava-height -147456.0)
         )
        (else
          (set! (-> self rotation-speed target) 1.0)
          (energyhub-set-lava-height -151552.0)
          )
        )
      )
    (update! (-> self rotation-speed-offset))
    (update! (-> self rotation-speed) (-> self rotation-speed-offset value))
    (energyhub-trans)
    (none)
    )
  :code (behavior ()
    (loop
      (suspend)
      (let* ((f30-0 1.0)
             (f28-0 0.25)
             (v1-1 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
             (v1-2 (the-as number (logior #x3f800000 v1-1)))
             (f0-4 (+ f30-0 (* f28-0 (+ -1.0 (the-as float v1-2)))))
             )
        (ja :num! (loop! f0-4))
        )
      )
    (none)
    )
  :post (the-as (function none :behavior energyhub) ja-post)
  )

(defmethod init-from-entity! energyhub ((obj energyhub) (arg0 entity-actor))
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *energyhub-sg* '())
  (set! (-> obj sound) (new 'process 'ambient-sound arg0 (-> obj root trans)))
  (let ((s5-1 (entity-actor-count (-> obj entity) 'alt-actor)))
    (dotimes (s4-0 (min 3 s5-1))
      (set! (-> obj alts s4-0) (entity-actor-lookup (-> obj entity) 'alt-actor s4-0))
      )
    )
  (quaternion->matrix (-> obj rot-mat-init) (-> obj root quat))
  (let ((f30-0 13107.2)
        (s5-2 (new 'stack-no-clear 'vector))
        (s4-1 (new 'stack-no-clear 'matrix))
        )
    (set-vector! s5-2 0.0 2457.6 -24576.0 1.0)
    (matrix-rotate-y! s4-1 f30-0)
    (dotimes (s3-0 5)
      (set! (-> obj arm s3-0) (ppointer->handle (process-spawn energyarm s5-2 (* (the float s3-0) f30-0) :to obj)))
      (vector-matrix*! s5-2 s5-2 s4-1)
      )
    )
  (set! (-> obj root pause-adjust-distance) 245760.0)
  (set! (-> obj y-rotation) 0.0)
  (set! (-> obj x-rotation) 0.0)
  (set-params! (-> obj rotation-speed-offset) 300 600 0.25)
  (set! (-> obj palette-val) 0.0)
  (cond
    ((task-closed? (game-task lavatube-balls) (task-status need-resolution))
     (set-params! (-> obj rotation-speed) 0.0 0.01 0.1 0.9)
     (go energyhub-stopped)
     )
    (else
      (set-params! (-> obj rotation-speed) 1.0 0.01 0.1 0.9)
      (go energyhub-idle)
      )
    )
  (none)
  )

(deftype energylava (process-drawable)
  ((root-override basic  :offset 112)
   )
  :heap-base #x40
  :method-count-assert 20
  :size-assert         #xb0
  :flag-assert         #x14004000b0
  (:states
    energylava-idle
    )
  )


(defskelgroup *energylava-sg* energylava 0 2 ((1 (meters 999999))) :bounds (static-spherem 0 0 0 120))

(defstate energylava-idle (energylava)
  :code (behavior ()
    (loop
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (none)
    )
  :post (the-as (function none :behavior energylava) ja-post)
  )

(defmethod init-from-entity! energylava ((obj energylava) (arg0 entity-actor))
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *energylava-sg* '())
  (go energylava-idle)
  (none)
  )
