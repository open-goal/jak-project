;;-*-Lisp-*-
(in-package goal)

;; name: yakow.gc
;; name in dgo: yakow
;; dgos: L1, VI1

(declare-type yakow process-drawable)

;; DECOMP BEGINS

(defskelgroup *village1cam-sg* village1cam village1cam-lod0-jg village1cam-anim-ja
              ((village1cam-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(defun yakow-cam ()
  (with-pp
    (let ((gp-0 (entity-actor-lookup (-> pp entity) 'alt-actor 0)))
      (if gp-0
          (process-spawn pov-camera (-> gp-0 extra trans) *village1cam-sg* "anim" 0 #f '() :to pp)
          )
      )
    (none)
    )
  )

(deftype yakow-bank (basic)
  ((walk-cycle-frame-count  float)
   (run-cycle-frame-count   float)
   (walk-speed              meters)
   (run-speed               meters)
   (walk-anim-speed         float)
   (run-anim-speed          float)
   (walk-away-dist          meters)
   (run-away-dist           meters)
   (walk-rotate-speed       float)
   (run-rotate-speed        float)
   (walk-turn-time          time-frame)
   (run-turn-time           time-frame)
   (max-walk-speed          float)
   (min-run-speed           float)
   (walk-run-blend-rate     float)
   (walk-turn-blend-rate    float)
   (max-run-speed           float)
   (acceleration            meters)
   (default-patrol-time     time-frame)
   (default-idle-distance   meters)
   (safe-distance           meters)
   (min-run-anim-speed      float)
   (max-run-anim-speed      float)
   (min-walk-anim-speed     float)
   (speed-boost-impulse     meters)
   )
  )


(define *YAKOW-bank* (new 'static 'yakow-bank
                       :walk-cycle-frame-count 16.0
                       :run-cycle-frame-count 16.0
                       :walk-speed (meters 2.13)
                       :run-speed (meters 6)
                       :walk-anim-speed 1.0
                       :run-anim-speed 2.0
                       :walk-away-dist (meters 10)
                       :run-away-dist (meters 6)
                       :walk-rotate-speed 131072.0
                       :run-rotate-speed 131072.0
                       :walk-turn-time (seconds 0.5)
                       :run-turn-time (seconds 0.2)
                       :max-walk-speed 16384.0
                       :min-run-speed 15155.2
                       :walk-run-blend-rate 6.0
                       :walk-turn-blend-rate 4.0
                       :max-run-speed 61440.0
                       :acceleration (meters 3)
                       :default-patrol-time (seconds 1)
                       :default-idle-distance (meters 10)
                       :safe-distance (meters 20)
                       :min-run-anim-speed 0.5
                       :max-run-anim-speed 1.5
                       :min-walk-anim-speed 0.5
                       :speed-boost-impulse (meters 4)
                       )
        )

(deftype yakow (process-drawable)
  ((root                collide-shape-moving :override)
   (fact                fact-info-enemy      :override)
   (player-attack-id    int32)
   (walk-run-blend      float)
   (walk-turn-blend     float)
   (run-mode            basic)
   (travel-speed        meters)
   (final-speed         meters)
   (rotate-speed        float)
   (turn-time           time-frame)
   (vulnerable          basic)
   (grazing             basic)
   (push-velocity       vector                :inline)
   (home-base           vector                :inline)
   (dest-base           vector                :inline)
   (dest-rot            degrees)
   (enable-turn-around  basic)
   (rotating            basic)
   (in-pen              basic)
   )
  (:states
    yakow-die
    yakow-graze
    yakow-graze-kicked
    yakow-idle
    yakow-kicked
    yakow-notice
    yakow-run-away
    (yakow-walk-to vector)
    )
  )


(defskelgroup *yakow-sg* yakow yakow-lod0-jg yakow-idle-ja
              ((yakow-lod0-mg (meters 20)) (yakow-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 2.5 0 4.4)
              :longest-edge (meters 1.3)
              :shadow yakow-shadow-mg
              )

(defbehavior yakow-default-event-handler yakow ((arg0 process-drawable) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('touch)
     (let* ((s4-0 arg0)
            (v1-2 (if (and (nonzero? s4-0) (type-type? (-> s4-0 type) process-drawable))
                      s4-0
                      )
                  )
            )
       (when (and v1-2 (< 8192.0 (- (-> v1-2 root trans y) (-> self root trans y))))
         (do-push-aways! (-> self root))
         (send-shove-back (-> self root) arg0 (the-as touching-shapes-entry (-> arg3 param 0)) 0.7 6144.0 16384.0)
         )
       )
     )
    (('attack)
     (let ((v1-9 (-> arg3 param 2)))
       (cond
         ((!= v1-9 (-> self player-attack-id))
          (set! (-> self player-attack-id) (the-as int v1-9))
          (if (-> self vulnerable)
              (go yakow-kicked)
              )
          )
         (else
           'push
           )
         )
       )
     )
    )
  )

yakow-default-event-handler

(defbehavior yakow-task-complete? yakow ((arg0 symbol))
  (local-vars (sv-16 symbol) (sv-20 (pointer process-tree)))
  (let ((gp-0
          (not (and (-> self entity) (logtest? (-> self entity extra perm status) (entity-perm-status complete))))
          )
        )
    (if arg0
        (process-entity-status! self (entity-perm-status complete) #t)
        (process-entity-status! self (entity-perm-status complete) #f)
        )
    (when (or (-> self link prev) (-> self link next))
      (set! sv-16 (the-as symbol #f))
      (set! sv-20 (-> self child))
      (apply-all (-> self link) actor-link-subtask-complete-hook (& sv-16))
      (cond
        (sv-16
          (close-specific-task! (-> self entity extra perm task) (task-status need-hint))
          (close-specific-task! (-> self entity extra perm task) (task-status need-introduction))
          (close-specific-task! (-> self entity extra perm task) (task-status need-reminder))
          (if gp-0
              (yakow-cam)
              )
          ;; og:preserve-this PAL patch here
          (process-spawn-function
            process
            (lambda :behavior process
              ()
              (while (or (-> *setting-control* current ambient)
                         (-> *setting-control* current movie)
                         (-> *setting-control* current hint)
                         )
                (suspend)
                )
              (level-hint-spawn
                (text-id village1-yakow-resolution)
                "sksp018a"
                (the-as entity #f)
                *entity-pool*
                (game-task none)
                )
              )
            :to self
            )
          )
        (else
          (open-specific-task! (-> self entity extra perm task) (task-status need-reminder))
          )
        )
      sv-16
      )
    )
  )

(defbehavior yakow-common-post yakow ()
  (update-direction-from-time-of-day (-> self draw shadow-ctrl))
  (if *target*
      (look-at-enemy! (-> *target* neck) (the-as vector (-> self root root-prim prim-core)) #f self)
      )
  (ja-post)
  (none)
  )

(defbehavior yakow-simple-post yakow ()
  (yakow-common-post)
  (update-transforms! (-> self root))
  (none)
  )

(defbehavior yakow-post yakow ()
  (nav-control-method-11 (-> self nav) (-> self nav target-pos))
  (set! (-> self rotating) #f)
  (let ((f30-0 0.0))
    (when (< 40.96 (vector-length (-> self nav travel)))
      (let ((s5-0 (new 'stack-no-clear 'vector))
            (gp-0 (new 'stack-no-clear 'vector))
            )
        (vector-z-quaternion! s5-0 (-> self root quat))
        (seek-toward-heading-vec! (-> self root) (-> self nav travel) (-> self rotate-speed) (-> self turn-time))
        (vector-z-quaternion! gp-0 (-> self root quat))
        (set! (-> self rotating) (< (vector-dot gp-0 s5-0) (cos (* 8192.0 (seconds-per-frame)))))
        (when (-> self rotating)
          (let ((v1-16 (new 'stack-no-clear 'vector)))
            (vector-cross! v1-16 gp-0 s5-0)
            (set! f30-0 (sign (-> v1-16 y)))
            )
          )
        )
      )
    (seek! (-> self walk-turn-blend) f30-0 (* (-> *YAKOW-bank* walk-turn-blend-rate) (seconds-per-frame)))
    )
  (set! (-> self final-speed)
        (fmin (-> self travel-speed) (* (vector-length (-> self nav travel)) (-> *display* frames-per-second)))
        )
  (let ((v1-24 (vector-normalize-copy! (new-stack-vector0) (-> self nav travel) (-> self final-speed))))
    (set! (-> self root transv x) (-> v1-24 x))
    (set! (-> self root transv z) (-> v1-24 z))
    )
  (vector-v++! (-> self root transv) (compute-acc-due-to-gravity (-> self root) (new-stack-vector0) 0.0))
  (let ((gp-2 (new 'stack-no-clear 'vector)))
    (set! (-> gp-2 quad) (-> self root trans quad))
    (integrate-for-enemy-with-move-to-ground!
      (-> self root)
      (-> self root transv)
      (collide-kind background)
      8192.0
      #t
      #f
      #f
      )
    (set! (-> self final-speed)
          (* (vector-vector-xz-distance gp-2 (-> self root trans)) (-> *display* frames-per-second))
          )
    )
  (set! (-> self travel-speed) (fmin (-> self travel-speed) (-> self final-speed)))
  (water-control-method-10 (-> self water))
  (when (and (logtest? (-> self nav current-poly pat) 2)
             (not (and (-> self entity) (logtest? (-> self entity extra perm status) (entity-perm-status complete))))
             )
    (set! (-> self in-pen) #t)
    (set! (-> self nav destination-pos quad) (-> self dest-base quad))
    (yakow-task-complete? #t)
    )
  (yakow-common-post)
  (none)
  )

(defbehavior yakow-generate-travel-vector yakow ()
  (let ((gp-1 (vector-! (new 'stack-no-clear 'vector) (-> self root trans) (target-pos 0)))
        (s5-1 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)))
        )
    0.0
    0.0
    (set! (-> gp-1 y) 0.0)
    (set! (-> self nav travel quad) (-> gp-1 quad))
    (vector-normalize! (-> self nav travel) 409600.0)
    (nav-control-method-24 (-> self nav) 204.8 (the-as clip-travel-vector-to-mesh-return-info #f))
    (when (not (-> self enable-turn-around))
      (set! (-> gp-1 quad) (-> self nav travel quad))
      (let ((f30-0 (vector-length gp-1)))
        (vector-normalize! gp-1 1.0)
        (if (and (< 409.6 f30-0) (>= (vector-dot s5-1 gp-1) (cos 10922.667)))
            (set! (-> s5-1 quad) (-> gp-1 quad))
            )
        )
      (set! (-> self nav travel quad) (-> s5-1 quad))
      (vector-normalize! (-> self nav travel) 409600.0)
      (nav-control-method-24 (-> self nav) 204.8 (the-as clip-travel-vector-to-mesh-return-info #f))
      (vector-length (-> self nav travel))
      )
    )
  (vector+! (-> self nav target-pos) (-> self root trans) (-> self nav travel))
  )

(defbehavior yakow-run-post yakow ()
  (yakow-generate-travel-vector)
  (yakow-post)
  (none)
  )

(defbehavior yakow-blend-walk-run yakow ()
  (let ((gp-0 (current-time)))
    (loop
      (let ((f30-0 (-> self final-speed)))
        (cond
          ((and (>= 409.6 (-> self final-speed)) (not (-> self rotating)))
           (if (not (ja-group? yakow-idle-ja))
               (ja-channel-push! 1 (seconds 0.15))
               )
           (ja :group! yakow-idle-ja :num! min)
           (while (or (not (time-elapsed? gp-0 (seconds 0.2))) (< (-> self final-speed) 409.6))
             (suspend)
             (ja :num! (loop!))
             )
           )
          (else
            (set! gp-0 (current-time))
            )
          )
        (when (not (ja-group? yakow-walk-ja))
          (ja-channel-push! 3 (seconds 0.075))
          (ja :group! yakow-walk-ja :num! min :frame-interp 0.0)
          (ja :chan 1 :group! yakow-walk-left-ja :num! min :frame-interp 0.0)
          (ja :chan 2 :group! yakow-run-ja :num! min :frame-interp 0.0)
          )
        (if (< (-> self walk-turn-blend) 0.0)
            (ja :chan 1 :group! yakow-walk-left-ja)
            (ja :chan 1 :group! yakow-walk-right-ja)
            )
        (cond
          ((< f30-0 (-> *YAKOW-bank* min-run-speed))
           (set! (-> self run-mode) #f)
           )
          ((< (-> *YAKOW-bank* max-walk-speed) f30-0)
           (set! (-> self run-mode) #t)
           )
          )
        (if (-> self run-mode)
            (seek! (-> self walk-run-blend) 1.0 (* (-> *YAKOW-bank* walk-run-blend-rate) (seconds-per-frame)))
            (seek! (-> self walk-run-blend) 0.0 (* (-> *YAKOW-bank* walk-run-blend-rate) (seconds-per-frame)))
            )
        (ja :chan 1 :frame-interp (fabs (-> self walk-turn-blend)))
        (ja :chan 2 :frame-interp (-> self walk-run-blend))
        (let* ((f0-25 (* (-> *YAKOW-bank* walk-anim-speed) f30-0))
               (f1-5 (-> *YAKOW-bank* walk-speed))
               (f0-26 (* f0-25 (/ 1.0 f1-5)))
               )
          (let* ((f1-9 (* (-> *YAKOW-bank* run-anim-speed) f30-0))
                 (f2-1 (-> *YAKOW-bank* run-speed))
                 (f1-12
                   (fmax (fmin (* f1-9 (/ 1.0 f2-1)) (-> *YAKOW-bank* max-run-anim-speed)) (-> *YAKOW-bank* min-run-anim-speed))
                   )
                 )
            (if (-> self run-mode)
                (set! f0-26 f1-12)
                )
            )
          (if (-> self rotating)
              (set! f0-26 (fmax (-> *YAKOW-bank* min-walk-anim-speed) f0-26))
              )
          (ja :num! (loop! f0-26))
          )
        )
      (ja :chan 1 :num-func num-func-identity :frame-num (ja-frame-num 0))
      (ja :chan 2 :num-func num-func-identity :frame-num (ja-frame-num 0))
      (suspend)
      0
      )
    )
  (none)
  )

(defbehavior yakow-facing-direction? yakow ((arg0 vector) (arg1 float))
  (let ((s4-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)))
        (s5-0 (new 'stack-no-clear 'vector))
        )
    (set! (-> s5-0 quad) (-> arg0 quad))
    (set! (-> s5-0 y) 0.0)
    (vector-normalize! s5-0 1.0)
    (>= (vector-dot s4-0 s5-0) (cos arg1))
    )
  )

(defbehavior yakow-facing-point? yakow ((arg0 vector) (arg1 float))
  (let ((v1-1 (vector-! (new 'stack-no-clear 'vector) arg0 (-> self root trans))))
    (yakow-facing-direction? v1-1 arg1)
    )
  )

(defbehavior yakow-facing-player? yakow ((arg0 float))
  (yakow-facing-point? (target-pos 0) arg0)
  )

(defstate yakow-idle (yakow)
  :event yakow-default-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self travel-speed) 0.0)
    )
  :trans (behavior ()
    (if (and (time-elapsed? (-> self state-time) (-> *YAKOW-bank* default-patrol-time))
             (and *target*
                  (>= (-> self fact idle-distance) (vector-vector-distance (-> self root trans) (-> *target* control trans)))
                  )
             (not (yakow-facing-player? 21845.334))
             )
        (go yakow-notice)
        )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.15))
    (loop
      (cond
        ((rand-vu-percent? 0.2)
         (effect-control-method-10 (-> self skel effect) 'yakow-1 0.0 -1)
         )
        ((rand-vu-percent? 0.2)
         (effect-control-method-10 (-> self skel effect) 'yakow-2 0.0 -1)
         )
        )
      (let ((f30-0 (rand-vu-float-range 0.9 1.1)))
        (ja-no-eval :group! yakow-idle-ja :num! (seek! max f30-0) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max f30-0))
          )
        )
      (when (rand-vu-percent? 0.25)
        (ja-channel-push! 1 (seconds 0.1))
        (ja-no-eval :group! yakow-graze-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!))
          )
        (ja-channel-push! 1 (seconds 0.1))
        )
      )
    )
  :post ja-post
  )

(defstate yakow-notice (yakow)
  :event yakow-default-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self travel-speed) 0.0)
    )
  :code (behavior ()
    (go yakow-run-away)
    )
  :post yakow-simple-post
  )

(defstate yakow-walk-to (yakow)
  :event yakow-default-event-handler
  :enter (behavior ((arg0 vector))
    (set-time! (-> self state-time))
    (logior! (-> self nav flags) (nav-control-flags navcf10))
    (set! (-> self nav destination-pos quad) (-> arg0 quad))
    (set! (-> self rotate-speed) (-> *YAKOW-bank* walk-rotate-speed))
    (set! (-> self turn-time) (-> *YAKOW-bank* walk-turn-time))
    )
  :trans (behavior ()
    (if (and (time-elapsed? (-> self state-time) (-> *YAKOW-bank* default-patrol-time))
             (not (-> self in-pen))
             (and *target*
                  (>= (-> self fact idle-distance) (vector-vector-distance (-> self root trans) (-> *target* control trans)))
                  )
             (not (yakow-facing-player? 21845.334))
             )
        (go yakow-notice)
        )
    (when (time-elapsed? (-> self state-time) (seconds 0.05))
      (when (or (logtest? (nav-control-flags navcf19) (-> self nav flags))
                (< (vector-vector-xz-distance (-> self root trans) (-> self nav destination-pos)) 4096.0)
                )
        (if (-> self in-pen)
            (go yakow-graze)
            (go yakow-idle)
            )
        )
      )
    (seek!
      (-> self travel-speed)
      (-> *YAKOW-bank* walk-speed)
      (* (-> *YAKOW-bank* acceleration) (seconds-per-frame))
      )
    )
  :code (the-as (function vector object) yakow-blend-walk-run)
  :post (behavior ()
    (nav-control-method-19
      (-> self nav)
      (-> self nav target-pos)
      (-> self root)
      (-> self nav destination-pos)
      131072.0
      )
    (if (logtest? (nav-control-flags navcf21) (-> self nav flags))
        (logclear! (-> self nav flags) (nav-control-flags navcf10))
        )
    (yakow-post)
    )
  )

(defstate yakow-graze (yakow)
  :event yakow-default-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self travel-speed) 0.0)
    (set! (-> self grazing) #t)
    (let ((v1-3 (entity-actor-lookup (-> self entity) 'alt-actor 0)))
      (send-event
        (if v1-3
            (-> v1-3 extra process)
            )
        'update
        )
      )
    )
  :code (behavior ()
    (while (< 546.13336 (fabs (deg-diff (-> self dest-rot) (y-angle (-> self root)))))
      (if (not (ja-group? yakow-walk-ja))
          (ja-channel-push! 1 (seconds 0.075))
          )
      (seek-toward-yaw-angle! (-> self root) (-> self dest-rot) 16384.0 (seconds 0.5))
      (ja :group! yakow-walk-ja :num! (loop!))
      (suspend)
      )
    (ja-channel-push! 1 (seconds 0.15))
    (loop
      (ja-no-eval :group! yakow-idle-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      (when (rand-vu-percent? 0.5)
        (ja-channel-push! 1 (seconds 0.1))
        (ja-no-eval :group! yakow-graze-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!))
          )
        (ja-channel-push! 1 (seconds 0.1))
        )
      )
    )
  :post yakow-simple-post
  )

(defstate yakow-graze-kicked (yakow)
  :event #f
  :code (behavior ()
    (ja-no-eval :group! yakow-kicked-in-place-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go yakow-graze)
    )
  :post yakow-simple-post
  )

(defstate yakow-run-away (yakow)
  :event yakow-default-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (logior! (-> self nav flags) (nav-control-flags navcf10))
    (set! (-> self rotate-speed) (-> *YAKOW-bank* run-rotate-speed))
    (set! (-> self turn-time) (-> *YAKOW-bank* run-turn-time))
    )
  :trans (behavior ()
    (when (or (not *target*)
              (< (-> *YAKOW-bank* safe-distance) (vector-vector-distance (-> self root trans) (-> *target* control trans)))
              )
      (if (-> self in-pen)
          (go yakow-walk-to (-> self dest-base))
          (go yakow-walk-to (-> self home-base))
          )
      )
    (let* ((f0-2 (* (if (-> self run-mode)
                        0.5
                        1.0
                        )
                    (vector-vector-distance (-> self root trans) (target-pos 0))
                    )
                 )
           (f30-2 (lerp-scale
                    (-> *YAKOW-bank* run-speed)
                    (-> *YAKOW-bank* walk-speed)
                    f0-2
                    (-> *YAKOW-bank* run-away-dist)
                    (-> *YAKOW-bank* walk-away-dist)
                    )
                  )
           )
      (if (yakow-facing-player? 21845.334)
          (set! f30-2 0.0)
          )
      (set! (-> self enable-turn-around) (< (-> *YAKOW-bank* run-speed) f30-2))
      (seek! (-> self travel-speed) f30-2 (* (-> *YAKOW-bank* acceleration) (seconds-per-frame)))
      )
    )
  :code yakow-blend-walk-run
  :post yakow-run-post
  )

(defstate yakow-kicked (yakow)
  :event #f
  :enter (behavior ()
    (set-time! (-> self state-time))
    (if (-> self grazing)
        (go yakow-graze-kicked)
        )
    (set! (-> self travel-speed)
          (fmax
            (fmin (+ (-> self travel-speed) (-> *YAKOW-bank* speed-boost-impulse)) (-> *YAKOW-bank* max-run-speed))
            (-> *YAKOW-bank* run-speed)
            )
          )
    )
  :exit (behavior ()
    '()
    )
  :trans (behavior ()
    (if (time-elapsed? (-> self state-time) (seconds 0.2))
        (seek!
          (-> self travel-speed)
          (-> *YAKOW-bank* run-speed)
          (* (-> *YAKOW-bank* acceleration) (seconds-per-frame))
          )
        )
    0
    )
  :code (behavior ()
    (set! (-> self enable-turn-around) #t)
    1.0
    (suspend)
    (ja-channel-push! 1 (seconds 0.05))
    (cond
      ((< 40.96 (vector-length (-> self nav travel)))
       (ja :group! yakow-kicked-ja)
       (ja :num-func num-func-identity :frame-num 0.0)
       (until (ja-done? 0)
         (suspend)
         (let* ((f0-3 0.75)
                (f1-0 0.25)
                (f2-0 (-> *YAKOW-bank* run-speed))
                (f0-4 (fmax f0-3 (fmin
                                   (* f1-0 (/ 1.0 f2-0) (-> self final-speed) (-> *YAKOW-bank* run-anim-speed))
                                   (-> *YAKOW-bank* max-run-anim-speed)
                                   )
                            )
                      )
                )
           (ja :num! (seek! max f0-4))
           )
         )
       )
      (else
        (ja-no-eval :group! yakow-kicked-in-place-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (if (< 40.96 (-> self final-speed))
              (go yakow-run-away)
              )
          (suspend)
          (ja :num! (seek!))
          )
        )
      )
    (go yakow-run-away)
    )
  :post yakow-run-post
  )

(defstate yakow-die (yakow)
  :event #f
  :code (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 collide-with) (collide-kind))
      (set! (-> v1-1 prim-core collide-as) (collide-kind))
      )
    0
    (drop-pickup (-> self fact) #t *entity-pool* (-> self fact) 0)
    (process-entity-status! self (entity-perm-status dead) #t)
    )
  )

(defmethod init-from-entity! ((this yakow) (arg0 entity-actor))
  (stack-size-set! (-> this main-thread) 512)
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((s3-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid attackable attackable-unused))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set-vector! (-> s3-0 local-sphere) 0.0 4096.0 0.0 10240.0)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (set! (-> this align) (new 'process 'align-control this))
  (set! (-> this nav) (new 'process 'nav-control (-> this root) 16 40960.0))
  (logior! (-> this nav flags) (nav-control-flags display-marks navcf3 navcf5 navcf6 navcf7))
  (set! (-> this nav nearest-y-threshold) 409600.0)
  (set! (-> this fact)
        (new 'process 'fact-info-enemy this (pickup-type eco-pill-random) (-> *FACT-bank* default-pill-inc))
        )
  (set! (-> this fact idle-distance) (-> *YAKOW-bank* default-idle-distance))
  (initialize-skeleton this *yakow-sg* '())
  (set! (-> this draw shadow-ctrl)
        (new 'process 'shadow-control -4096.0 4096.0 614400.0 (the-as float 24) 245760.0)
        )
  (set! (-> this link) (new 'process 'actor-link-info this))
  (set! (-> this water) (new 'process 'water-control this 6 0.0 8192.0 2048.0))
  (set! (-> this water flags) (water-flags wt01))
  (set! (-> this water height) (res-lump-float (-> this entity) 'water-height))
  (set! (-> this water ripple-size) 12288.0)
  (set! (-> this home-base quad) (-> this root trans quad))
  (let ((v1-40 (res-lump-struct (-> this entity) 'alt-vector vector)))
    (when v1-40
      (set! (-> this dest-base quad) (-> v1-40 quad))
      (set! (-> this dest-rot) (-> v1-40 w))
      (set! (-> this dest-base w) 1.0)
      )
    )
  (set! (-> this vulnerable) #t)
  (set! (-> this grazing) #f)
  (set! (-> this enable-turn-around) #f)
  (set! (-> this in-pen)
        (and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status complete)))
        )
  (cond
    ((-> this in-pen)
     (set! (-> this root trans quad) (-> this dest-base quad))
     (set-yaw-angle-clear-roll-pitch! (-> this root) (-> this dest-rot))
     (go yakow-graze)
     )
    (else
      (yakow-task-complete? #f)
      (go yakow-idle)
      )
    )
  (none)
  )
