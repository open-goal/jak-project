;;-*-Lisp-*-
(in-package goal)

;; name: ice-cube.gc
;; name in dgo: ice-cube
;; dgos: L1, SNO

;; DECOMP BEGINS

(import "goal_src/jak1/import/ice-cube-ag.gc")
(import "goal_src/jak1/import/ice-cube-break-ag.gc")

(defskelgroup *ice-cube-break-sg* ice-cube-break ice-cube-break-lod0-jg -1
              ((ice-cube-break-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -15 0 50)
              )

(deftype ice-cube (nav-enemy)
  ((part2                  sparticle-launch-control         :offset-assert 400)
   (part3                  sparticle-launch-control         :offset-assert 404)
   (part4                  sparticle-launch-control         :offset-assert 408)
   (track-target?          symbol                           :offset-assert 412)
   (slow-down?             symbol                           :offset-assert 416)
   (tracking-player?       symbol                           :offset-assert 420)
   (force-spawn-pt         int32                            :offset-assert 424)
   (speed                  float                            :offset-assert 428)
   (anim-blend             float                            :offset-assert 432)
   (prev-charge-angle-diff float                            :offset-assert 436)
   (charge-angle           float                            :offset-assert 440)
   (ground-y               float                            :offset-assert 444)
   (cprims-type            uint64                           :offset-assert 448)
   (next-skid-sound-time   time-frame                       :offset-assert 456)
   (starting-pos           vector                   :inline :offset-assert 464)
   (target-pt              vector                   :inline :offset-assert 480)
   )
  :heap-base #x180
  :method-count-assert 76
  :size-assert         #x1f0
  :flag-assert         #x4c018001f0
  (:methods
    (ice-cube-method-51 (_type_ vector vector) symbol :replace 51)
    (ice-cube-method-53 (_type_ vector vector) symbol :replace 53)
    )
  (:states
    ice-cube-appear
    ice-cube-appear-land
    ice-cube-become-mean
    ice-cube-face-player
    ice-cube-mean-charge
    ice-cube-mean-charge-done
    ice-cube-mean-turn-to-charge
    ice-cube-retract-spikes
    ice-cube-shatter
    ice-cube-tired
    ice-cube-trying-to-appear
    )
  )


(defskelgroup *ice-cube-sg* ice-cube ice-cube-lod0-jg -1
              ((ice-cube-lod0-mg (meters 20)) (ice-cube-lod1-mg (meters 40)) (ice-cube-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 3 0 3.6)
              :shadow ice-cube-shadow-mg
              )

(define *ice-cube-nav-enemy-info* (new 'static 'nav-enemy-info
                                    :idle-anim 5
                                    :walk-anim 6
                                    :turn-anim -1
                                    :notice-anim 7
                                    :run-anim 6
                                    :jump-anim 6
                                    :jump-land-anim 6
                                    :victory-anim 7
                                    :taunt-anim 7
                                    :die-anim 7
                                    :neck-joint 5
                                    :player-look-at-joint 5
                                    :run-travel-speed (meters 20)
                                    :run-rotate-speed (degrees 2880.0)
                                    :run-acceleration (meters 1)
                                    :run-turn-time (seconds 0.1)
                                    :walk-travel-speed (meters 3)
                                    :walk-rotate-speed (degrees 720.0)
                                    :walk-acceleration (meters 1)
                                    :walk-turn-time (seconds 0.5)
                                    :attack-shove-back (meters 3)
                                    :attack-shove-up (meters 2)
                                    :shadow-size (meters 1)
                                    :notice-nav-radius (meters 1.5)
                                    :nav-nearest-y-threshold (meters 10)
                                    :notice-distance (meters 35)
                                    :stop-chase-distance (meters 45)
                                    :frustration-distance (meters 8)
                                    :frustration-time (seconds 4)
                                    :die-anim-hold-frame 10000000000.0
                                    :jump-anim-start-frame 10.0
                                    :jump-land-anim-end-frame 10000000000.0
                                    :jump-height-min (meters 3)
                                    :jump-height-factor 0.5
                                    :jump-start-anim-speed 1.0
                                    :shadow-max-y (meters 1)
                                    :shadow-min-y (meters -3.5)
                                    :shadow-locus-dist (meters 150)
                                    :use-align #f
                                    :draw-shadow #f
                                    :move-to-ground #t
                                    :hover-if-no-ground #f
                                    :use-momentum #f
                                    :use-flee #f
                                    :use-proximity-notice #f
                                    :use-jump-blocked #f
                                    :use-jump-patrol #f
                                    :gnd-collide-with (collide-kind background)
                                    :debug-draw-neck #f
                                    :debug-draw-jump #f
                                    )
        )

(defpartgroup group-ice-cube-appear1
  :id 507
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 16)
  :parts ((sp-item 1887 :fade-after (meters 70) :falloff-to (meters 70))
    (sp-item 1888 :fade-after (meters 70) :falloff-to (meters 70))
    )
  )

(defpart 1888
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 16.0)
    (:x (meters -2) (meters 4))
    (:y (meters 0.5) (meters 1))
    (:z (meters -2) (meters 4))
    (:scale-x (meters 0.24) (meters 0.24))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 128.0)
    (:b 128.0)
    (:a 128.0 64.0)
    (:vel-y (meters 0.033333335) (meters 0.05))
    (:rotvel-z (degrees -2.4) (degrees 3.4666667))
    (:accel-y (meters -0.0013333333))
    (:friction 0.99)
    (:timer (seconds 1.5))
    (:flags (bit2 bit12))
    (:conerot-x (degrees 0) (degrees 40))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 1887
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 32.0)
    (:x (meters -2) (meters 4))
    (:y (meters 0.5) (meters 1))
    (:z (meters -2) (meters 4))
    (:scale-x (meters 2.5) (meters 2.5))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 128.0)
    (:b 128.0)
    (:a 32.0 32.0)
    (:vel-y (meters 0.05) (meters 0.016666668))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -1.2) (degrees 1.2))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.07111111)
    (:accel-y (meters -0.0013333333))
    (:friction 0.99)
    (:timer (seconds 1.5))
    (:flags (bit2 bit12))
    (:conerot-x (degrees 0) (degrees 40))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpartgroup group-ice-cube-appear2
  :id 508
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 16)
  :parts ((sp-item 1889 :fade-after (meters 70) :falloff-to (meters 70)))
  )

(defpart 1889
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 1.0 2.0)
    (:x (meters -0.25) (meters 0.5))
    (:z (meters -0.25) (meters 0.5))
    (:scale-x (meters 0.2) (meters 0.1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 128.0)
    (:b 128.0)
    (:a 64.0 64.0)
    (:vel-y (meters 0) (meters 0.006666667))
    (:rotvel-z (degrees -2.4) (degrees 3.4666667))
    (:accel-y (meters -0.0013333333))
    (:timer (seconds 0.5))
    (:flags (bit2 bit12))
    (:conerot-x (degrees 0) (degrees 30))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpartgroup group-ice-cube-foot-puff
  :id 567
  :duration (seconds 0.017)
  :linger-duration (seconds 1.5)
  :bounds (static-bspherem 0 0 0 2)
  :parts ((sp-item 2325) (sp-item 2326) (sp-item 2327))
  )

(defpart 2325
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 16.0)
    (:scale-x (meters 1) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 196.0 64.0)
    (:g 196.0 64.0)
    (:b 196.0 64.0)
    (:a 16.0 32.0)
    (:vel-y (meters 0.02) (meters 0.01))
    (:scalevel-x (meters 0.0033333334))
    (:rotvel-z (degrees -0.2) (degrees 0.4))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.16)
    (:accel-y (meters -0.00033333333))
    (:friction 0.95)
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-x (degrees 60) (degrees 30))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 2326
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 12.0)
    (:scale-x (meters 0.5) (meters 0.25))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 196.0 64.0)
    (:g 196.0 64.0)
    (:b 196.0 64.0)
    (:a 16.0 16.0)
    (:vel-y (meters 0.053333335) (meters 0.02))
    (:scalevel-x (meters 0.0016666667))
    (:rotvel-z (degrees -0.2) (degrees 0.4))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.21333334)
    (:accel-y (meters -0.00033333333))
    (:friction 0.95)
    (:timer (seconds 0.5))
    (:flags (bit2 bit12))
    (:conerot-x (degrees 60) (degrees 30))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 2327
  :init-specs ((:texture (new 'static 'texture-id :index #x4 :page #x2))
    (:num 32.0)
    (:x (meters -0.4) (meters 0.8))
    (:y (meters -0.1) (meters 0.4))
    (:z (meters -0.4) (meters 0.8))
    (:scale-x (meters 0.07) (meters 0.02))
    (:scale-y :copy scale-x)
    (:r 196.0 2.0 64.0)
    (:g 196.0 1 64.0)
    (:b 196.0 1 64.0)
    (:a 64.0 64.0)
    (:vel-y (meters 0.015) (meters 0.006666667))
    (:fade-a -0.42666668)
    (:accel-y (meters -0.0013333333) (meters 0.00066666666))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-x (degrees 30) (degrees 50.000004))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 0.5))
    )
  )

(defpartgroup group-ice-cube-shatter
  :id 509
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 16)
  :parts ((sp-item 1890) (sp-item 1891) (sp-item 1892))
  )

(defpart 1892
  :init-specs ((:texture (new 'static 'texture-id :index #xf :page #x2))
    (:num 64.0)
    (:y (meters 1))
    (:scale-x (meters 0.24) (meters 0.24))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 96.0 32.0)
    (:vel-y (meters 0.033333335) (meters 0.13333334))
    (:accel-y (meters -0.000033333334))
    (:friction 0.99)
    (:timer (seconds 0.2) (seconds 0.297))
    (:flags (bit2 bit12))
    (:conerot-x (degrees 0) (degrees 140))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 0) (meters 1.5))
    )
  )

(defpart 1891
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 8.0)
    (:x (meters -2) (meters 4))
    (:y (meters 1))
    (:z (meters -2) (meters 4))
    (:scale-x (meters 3) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 64.0 64.0)
    (:vel-y (meters 0) (meters 0.016666668))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.3) (degrees 0.6))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.28444445)
    (:friction 0.99)
    (:timer (seconds 1.5))
    (:flags (bit2 bit12))
    (:conerot-x (degrees 0) (degrees 120))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 0) (meters 1.5))
    )
  )

(defpart 1890
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 16.0)
    (:x (meters -2) (meters 4))
    (:y (meters 1))
    (:z (meters -2) (meters 4))
    (:scale-x (meters 1) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 32.0 32.0)
    (:vel-y (meters 0.13333334) (meters 0.033333335))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -1.2) (degrees 1.2))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.35555556)
    (:friction 0.99)
    (:timer (seconds 0.6))
    (:flags (bit2 bit12))
    (:conerot-x (degrees 0) (degrees 120))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 0) (meters 1.5))
    )
  )

;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 98]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 176]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 194]
(defbehavior ice-cube-default-event-handler ice-cube ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (the-as object (case arg2
                   (('attack)
                    (cond
                      ((and (= (-> arg0 type) target)
                            (= (-> self cprims-type) 2)
                            (not (send-event *target* 'query 'powerup (pickup-type eco-red)))
                            )
                       (when (and (cond
                                    ((= (-> arg0 type) target)
                                     (send-event arg0 'attack (-> arg3 param 0) (new 'static 'attack-info))
                                     )
                                    (else
                                      (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
                                        (set! (-> a1-3 from) self)
                                        (set! (-> a1-3 num-params) 4)
                                        (set! (-> a1-3 message) 'attack)
                                        (set! (-> a1-3 param 0) (-> arg3 param 0))
                                        (set! (-> a1-3 param 1) (the-as uint #f))
                                        (let ((v1-20 (+ *global-attack-id* 1)))
                                          (set! *global-attack-id* v1-20)
                                          (set! (-> a1-3 param 2) (the-as uint v1-20))
                                          )
                                        (set! (-> a1-3 param 3) (the-as uint 0))
                                        (send-event-function arg0 a1-3)
                                        )
                                      )
                                    )
                                  (= (-> arg0 type) target)
                                  )
                         (set-collide-offense (-> self collide-info) 2 (collide-offense no-offense))
                         (logior! (-> self nav-enemy-flags) (nav-enemy-flags navenmf8))
                         (level-hint-spawn
                           (text-id snow-ice-cube-hint)
                           "sksp0350"
                           (the-as entity #f)
                           *entity-pool*
                           (game-task none)
                           )
                         )
                       )
                      (else
                        (nav-enemy-set-hit-from-direction arg0)
                        (go ice-cube-shatter)
                        )
                      )
                    )
                   (('touch)
                    (when (and (cond
                                 ((= (-> arg0 type) target)
                                  (send-event arg0 'attack (-> arg3 param 0) (new 'static 'attack-info))
                                  )
                                 (else
                                   (let ((a1-7 (new 'stack-no-clear 'event-message-block)))
                                     (set! (-> a1-7 from) self)
                                     (set! (-> a1-7 num-params) 4)
                                     (set! (-> a1-7 message) 'attack)
                                     (set! (-> a1-7 param 0) (-> arg3 param 0))
                                     (set! (-> a1-7 param 1) (the-as uint #f))
                                     (let ((v1-38 (+ *global-attack-id* 1)))
                                       (set! *global-attack-id* v1-38)
                                       (set! (-> a1-7 param 2) (the-as uint v1-38))
                                       )
                                     (set! (-> a1-7 param 3) (the-as uint 0))
                                     (send-event-function arg0 a1-7)
                                     )
                                   )
                                 )
                               (= (-> arg0 type) target)
                               )
                      (set-collide-offense (-> self collide-info) 2 (collide-offense no-offense))
                      ;; NOTE fixed decompiler bug
                      (logior! (-> self nav-enemy-flags) (nav-enemy-flags navenmf8))
                      )
                    )
                   (('touched)
                    (when (!= (-> arg0 type) target)
                      (cond
                        ((= (-> arg0 type) target)
                         (send-event arg0 'attack (-> arg3 param 0) (static-attack-info ((mode #f))))
                         )
                        (else
                          (let ((a1-10 (new 'stack-no-clear 'event-message-block)))
                            (set! (-> a1-10 from) self)
                            (set! (-> a1-10 num-params) 4)
                            (set! (-> a1-10 message) 'attack)
                            (set! (-> a1-10 param 0) (-> arg3 param 0))
                            (set! (-> a1-10 param 1) (the-as uint #f))
                            (let ((v1-54 (+ *global-attack-id* 1)))
                              (set! *global-attack-id* v1-54)
                              (set! (-> a1-10 param 2) (the-as uint v1-54))
                              )
                            (set! (-> a1-10 param 3) (the-as uint 0))
                            (send-event-function arg0 a1-10)
                            )
                          )
                        )
                      )
                    )
                   )
          )
  )

(defmethod initialize-collision ice-cube ((obj ice-cube))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 5) 0)))
      (set! (-> s4-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 12288.0 0.0 14745.6)
      (set-root-prim! s5-0 s4-0)
      (let ((s3-0 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 3))))
        (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
        (set! (-> s3-0 collide-with) (collide-kind target))
        (set! (-> s3-0 prim-core action) (collide-action solid))
        (set! (-> s3-0 prim-core offense) (collide-offense touch))
        (set-vector! (-> s3-0 local-sphere) 0.0 3276.8 0.0 3276.8)
        (append-prim s4-0 s3-0)
        )
      (let ((s3-1 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 3))))
        (set! (-> s3-1 prim-core collide-as) (collide-kind enemy))
        (set! (-> s3-1 collide-with) (collide-kind target))
        (set! (-> s3-1 prim-core action) (collide-action solid))
        (set! (-> s3-1 prim-core offense) (collide-offense touch))
        (set-vector! (-> s3-1 local-sphere) 0.0 5734.4 0.0 3276.8)
        (append-prim s4-0 s3-1)
        )
      (let ((s3-2 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 3))))
        (set! (-> s3-2 prim-core collide-as) (collide-kind enemy))
        (set! (-> s3-2 collide-with) (collide-kind target))
        (set! (-> s3-2 prim-core action) (collide-action solid))
        (set! (-> s3-2 prim-core offense) (collide-offense touch))
        (set-vector! (-> s3-2 local-sphere) 0.0 8192.0 0.0 3276.8)
        (append-prim s4-0 s3-2)
        )
      (let ((s3-3 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 1))))
        (set! (-> s3-3 prim-core collide-as) (collide-kind enemy))
        (set! (-> s3-3 collide-with) (collide-kind target))
        (set! (-> s3-3 prim-core offense) (collide-offense normal-attack))
        (set! (-> s3-3 transform-index) 6)
        (set-vector! (-> s3-3 local-sphere) 819.2 0.0 0.0 2048.0)
        (append-prim s4-0 s3-3)
        )
      (let ((s3-4 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 1))))
        (set! (-> s3-4 prim-core collide-as) (collide-kind enemy))
        (set! (-> s3-4 collide-with) (collide-kind target))
        (set! (-> s3-4 prim-core offense) (collide-offense normal-attack))
        (set! (-> s3-4 transform-index) 4)
        (set-vector! (-> s3-4 local-sphere) 0.0 2048.0 0.0 4505.6)
        (append-prim s4-0 s3-4)
        )
      )
    (set! (-> s5-0 nav-radius) 6144.0)
    (backup-collide-with-as s5-0)
    (set! (-> s5-0 max-iteration-count) (the-as uint 1))
    (set! (-> obj collide-info) s5-0)
    )
  (set! (-> obj cprims-type) (the-as uint 0))
  (set-root-prim-collide-with! (-> obj collide-info) (collide-kind target))
  (set! (-> obj collide-info event-self) 'touched)
  (nav-enemy-method-57 obj)
  0
  (none)
  )

(defmethod nav-enemy-method-57 ice-cube ((obj ice-cube))
  (when (!= (-> obj cprims-type) 1)
    (set! (-> obj cprims-type) (the-as uint 1))
    (let ((v1-3 (-> obj collide-info root-prim)))
      (set-vector! (-> v1-3 local-sphere) 0.0 12288.0 0.0 14745.6)
      (set-vector! (-> (the-as collide-shape-prim-group v1-3) prims 3 local-sphere) 819.2 0.0 0.0 2048.0)
      (set-vector! (-> (the-as collide-shape-prim-group v1-3) prims 4 local-sphere) 0.0 2048.0 0.0 4505.6)
      )
    )
  (none)
  )

(defmethod nav-enemy-method-58 ice-cube ((obj ice-cube))
  (when (!= (-> obj cprims-type) 2)
    (set! (-> obj cprims-type) (the-as uint 2))
    (let ((v1-3 (-> obj collide-info root-prim)))
      (set-vector! (-> v1-3 local-sphere) 0.0 12288.0 0.0 16384.0)
      (set-vector! (-> (the-as collide-shape-prim-group v1-3) prims 3 local-sphere) 819.2 0.0 0.0 4915.2)
      (set-vector! (-> (the-as collide-shape-prim-group v1-3) prims 4 local-sphere) 0.0 2048.0 0.0 9420.8)
      )
    )
  (none)
  )

(defmethod nav-enemy-method-48 ice-cube ((obj ice-cube))
  (process-drawable-from-entity! obj (-> obj entity))
  (initialize-skeleton obj *ice-cube-sg* '())
  (init-defaults! obj *ice-cube-nav-enemy-info*)
  (set! (-> obj neck up) (the-as uint 0))
  (set! (-> obj neck nose) (the-as uint 1))
  (set! (-> obj neck ear) (the-as uint 2))
  0
  (none)
  )

(defmethod deactivate ice-cube ((obj ice-cube))
  (if (nonzero? (-> obj part2))
      (kill-and-free-particles (-> obj part2))
      )
  (if (nonzero? (-> obj part3))
      (kill-and-free-particles (-> obj part3))
      )
  (if (nonzero? (-> obj part4))
      (kill-and-free-particles (-> obj part4))
      )
  ((method-of-type process-drawable deactivate) obj)
  (none)
  )

(defmethod relocate ice-cube ((obj ice-cube) (arg0 int))
  (if (nonzero? (-> obj part2))
      (&+! (-> obj part2) arg0)
      )
  (if (nonzero? (-> obj part3))
      (&+! (-> obj part3) arg0)
      )
  (if (nonzero? (-> obj part4))
      (&+! (-> obj part4) arg0)
      )
  (the-as ice-cube ((the-as (function nav-enemy int nav-enemy) (find-parent-method ice-cube 7)) obj arg0))
  )

(defmethod init-from-entity! ice-cube ((obj ice-cube) (arg0 entity-actor))
  (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 507) obj))
  (set! (-> obj part2) (create-launch-control (-> *part-group-id-table* 508) obj))
  (set! (-> obj part3) (create-launch-control (-> *part-group-id-table* 509) obj))
  (set! (-> obj part4) (create-launch-control (-> *part-group-id-table* 567) obj))
  (initialize-collision obj)
  (nav-enemy-method-48 obj)
  (let ((s4-0 (-> obj path curve num-cverts)))
    (if (<= s4-0 0)
        (go process-drawable-art-error "no path")
        )
    (let ((v1-21 (res-lump-value arg0 'mode uint128 :default (the-as uint128 -1))))
      (if (and (>= (the-as int v1-21) 0) (< (the-as int v1-21) s4-0))
          (set! (-> obj force-spawn-pt) (the-as int v1-21))
          (set! (-> obj force-spawn-pt) -1)
          )
      )
    )
  (go ice-cube-trying-to-appear)
  (none)
  )

(defmethod nav-enemy-method-60 ice-cube ((obj ice-cube) (arg0 symbol))
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    (when (-> obj tracking-player?)
      (if (and *target* arg0)
          (set! (-> obj target-pt quad) (-> (target-pos 0) quad))
          )
      )
    (vector-! gp-0 (-> obj target-pt) (-> obj collide-info trans))
    (seek-toward-heading-vec! (-> obj collide-info) gp-0 524288.0 (seconds 0.1))
    (let ((v0-5 (< (fabs (deg- (quaternion-y-angle (-> obj collide-info quat)) (vector-y-angle gp-0))) 364.0889)))
      (b! #t cfg-10 :delay (nop!))
      (the-as none 0)
      (set! v0-5 (the-as symbol #f))
      (label cfg-10)
      v0-5
      )
    )
  )

(defmethod ice-cube-method-51 ice-cube ((obj ice-cube) (arg0 vector) (arg1 vector))
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (let* ((s4-0 (new 'stack-no-clear 'collide-tri-result))
           (f0-0 40960.0)
           (f30-0 (+ f0-0 40960.0))
           )
      (set! (-> s5-0 quad) (-> arg0 quad))
      (+! (-> s5-0 y) f0-0)
      (let ((f0-2 (fill-and-probe-using-y-probe
                    *collide-cache*
                    s5-0
                    f30-0
                    (collide-kind background)
                    (-> obj collide-info process)
                    s4-0
                    (new 'static 'pat-surface :noentity #x1)
                    )
                  )
            )
        (if (or (< f0-2 0.0) (= (logand #b111000 (the-as int (-> s4-0 pat))) 8)) ;; yes this is bugged
            (return #f)
            )
        (set! (-> s5-0 y) (- (-> s5-0 y) (* f0-2 f30-0)))
        )
      )
    (set! (-> arg1 quad) (-> s5-0 quad))
    )
  #t
  )

(defmethod nav-enemy-method-52 ice-cube ((obj ice-cube) (arg0 vector))
  (when *target*
    (let ((f0-0 (vector-vector-xz-distance arg0 (target-pos 0))))
      (when (and (>= f0-0 40960.0) (>= 81920.0 f0-0) (not (nav-enemy-method-50 obj arg0)))
        (let ((a0-4 (new 'stack-no-clear 'vector)))
          (set! (-> a0-4 quad) (-> arg0 quad))
          (set! (-> a0-4 w) (-> obj collide-info root-prim local-sphere w))
          (if (sphere-in-view-frustum? (the-as sphere a0-4))
              (return #t)
              )
          )
        )
      )
    )
  #f
  )

(defmethod ice-cube-method-53 ice-cube ((obj ice-cube) (arg0 vector) (arg1 vector))
  (local-vars (s1-0 int) (s2-0 int))
  (let ((s3-0 (-> obj path curve num-cverts)))
    (if (<= s3-0 0)
        (return #f)
        )
    (cond
      ((>= (-> obj force-spawn-pt) 0)
       (set! s1-0 (-> obj force-spawn-pt))
       (set! s2-0 1)
       )
      (else
        (set! s1-0 (rand-vu-int-count s3-0))
        (set! s2-0 s3-0)
        )
      )
    (while (> s2-0 0)
      (eval-path-curve-div! (-> obj path) arg0 (the float s1-0) 'interp)
      (when (nav-enemy-method-52 obj arg0)
        (let ((a1-3 (new 'stack-no-clear 'vector))
              (s3-1 (new 'stack-no-clear 'collide-tri-result))
              )
          (set! (-> a1-3 quad) (-> arg0 quad))
          (set! (-> a1-3 y) (+ 16384.0 (-> a1-3 y)))
          (if (>= (fill-and-probe-using-line-sphere
                    *collide-cache*
                    a1-3
                    (new 'static 'vector :y -32768.0 :w 1.0)
                    409.6
                    (collide-kind background)
                    obj
                    s3-1
                    (new 'static 'pat-surface :noentity #x1)
                    )
                  0.0
                  )
              (set! (-> arg0 quad) (-> s3-1 intersect quad))
              )
          )
        (cond
          (*target*
            (vector-! arg1 (target-pos 0) arg0)
            (set! (-> arg1 y) 0.0)
            )
          (else
            (set-vector! arg1 (rand-vu-float-range -4096.0 4096.0) 0.0 (rand-vu-float-range -4096.0 4096.0) 1.0)
            (set! (-> arg1 x) (+ 409.6 (-> arg1 x)))
            )
          )
        (vector-normalize! arg1 1.0)
        (return #t)
        )
      (set! s1-0 (mod (+ s1-0 1) s3-0))
      (+! s2-0 -1)
      )
    )
  #f
  )

(defstate ice-cube-trying-to-appear (ice-cube)
  :enter (behavior ()
    (ja-channel-set! 0)
    (ja-post)
    (logior! (-> self draw status) (draw-status hidden))
    (clear-collide-with-as (-> self collide-info))
    (none)
    )
  :exit (behavior ()
    (logclear! (-> self draw status) (draw-status hidden))
    (restore-collide-with-as (-> self collide-info))
    (none)
    )
  :trans (behavior ()
    (when (and *target* (>= 163840.0 (vector-vector-distance (-> self collide-info trans) (-> *target* control trans))))
      (let ((s5-0 (new 'stack-no-clear 'vector))
            (gp-0 (new 'stack-no-clear 'vector))
            )
        (when (ice-cube-method-53 self s5-0 gp-0)
          (set! (-> self collide-info trans quad) (-> s5-0 quad))
          (forward-up->quaternion (-> self collide-info quat) gp-0 *up-vector*)
          (nav-enemy-method-57 self)
          (go ice-cube-appear)
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend)
    0
    (none)
    )
  )

(defstate ice-cube-appear (ice-cube)
  :event ice-cube-default-event-handler
  :enter (behavior ()
    (nav-enemy-method-57 self)
    (set! (-> self ground-y) (-> self collide-info trans y))
    (spawn (-> self part) (-> self collide-info trans))
    (set-current-poly! (-> self nav) (nav-control-method-16 (-> self nav) (-> self collide-info trans)))
    (set! (-> self collide-info trans y) (+ -12288.0 (-> self collide-info trans y)))
    (set! (-> self collide-info transv quad) (-> *null-vector* quad))
    (set! (-> self collide-info transv y) (rand-vu-float-range 102400.0 114688.0))
    (none)
    )
  :trans (behavior ()
    (when (and (< (-> self collide-info trans y) (-> self ground-y)) (< (-> self collide-info transv y) 0.0))
      (set! (-> self collide-info trans y) (-> self ground-y))
      (set! (-> self collide-info transv quad) (-> *null-vector* quad))
      (go ice-cube-appear-land)
      )
    (let* ((s5-0 (-> self node-list))
           (a0-2 (-> s5-0 length))
           (gp-0 (new 'stack-no-clear 'vector))
           )
      (vector<-cspace! gp-0 (-> s5-0 data (nav-enemy-rnd-int-count a0-2)))
      (spawn (-> self part2) gp-0)
      )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! ice-cube-appear-jump-up-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (loop
      (suspend)
      )
    (none)
    )
  :post (the-as (function none :behavior ice-cube) nav-enemy-falling-post)
  )

(defstate ice-cube-appear-land (ice-cube)
  :event ice-cube-default-event-handler
  :code (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (vector<-cspace! gp-0 (-> self node-list data 29))
      (spawn (-> self part4) gp-0)
      (vector<-cspace! gp-0 (-> self node-list data 25))
      (spawn (-> self part4) gp-0)
      )
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! ice-cube-appear-land-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (if (target-in-range? self (-> self nav-info notice-distance))
        (go ice-cube-become-mean)
        (go-virtual nav-enemy-idle)
        )
    (none)
    )
  :post (the-as (function none :behavior ice-cube) ja-post)
  )

(defstate nav-enemy-idle (ice-cube)
  :virtual #t
  :event ice-cube-default-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy nav-enemy-idle) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self draw force-lod) -1)
    (logior! (-> self mask) (process-mask actor-pause))
    (none)
    )
  )

(defstate nav-enemy-patrol (ice-cube)
  :virtual #t
  :event ice-cube-default-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy nav-enemy-patrol) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self draw force-lod) -1)
    (logior! (-> self mask) (process-mask actor-pause))
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((t9-1 (-> (method-of-type nav-enemy nav-enemy-patrol) code)))
      (if t9-1
          ((the-as (function none) t9-1))
          )
      )
    (none)
    )
  )

(defstate nav-enemy-notice (ice-cube)
  :virtual #t
  :enter (the-as (function none :behavior ice-cube) #f)
  :exit (the-as (function none :behavior ice-cube) #f)
  :trans (the-as (function none :behavior ice-cube) #f)
  :code (behavior ()
    (nav-enemy-method-57 self)
    (logclear! (-> self nav-enemy-flags) (nav-enemy-flags navenmf1))
    (logclear! (-> self mask) (process-mask actor-pause))
    (go ice-cube-face-player)
    (none)
    )
  :post (the-as (function none :behavior ice-cube) #f)
  )

(defstate ice-cube-face-player (ice-cube)
  :event ice-cube-default-event-handler
  :enter (behavior ()
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (logior! (-> self nav-enemy-flags) (nav-enemy-flags navenmf2))
    (nav-enemy-method-57 self)
    (logclear! (-> self mask) (process-mask actor-pause))
    (if (or (not *target*)
            (logtest? (-> *target* state-flags)
                      (state-flags being-attacked invulnerable timed-invulnerable invuln-powerup do-not-notice dying)
                      )
            (not (nav-enemy-test-point-near-nav-mesh? (-> *target* control shadow-pos)))
            )
        (go-virtual nav-enemy-patrol)
        )
    (set! (-> self tracking-player?) #t)
    (set! (-> self target-pt quad) (-> (target-pos 0) quad))
    (nav-enemy-neck-control-look-at)
    (set-vector! (-> self collide-info transv) 0.0 114688.0 0.0 1.0)
    (none)
    )
  :code (behavior ()
    (local-vars (gp-0 symbol))
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! ice-cube-appear-jump-up-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (let ((f30-0 (-> self collide-info transv y)))
        (integrate-for-enemy-with-move-to-ground!
          (-> self collide-info)
          (-> self collide-info transv)
          (collide-kind background)
          32768.0
          #f
          #f
          #f
          )
        (if (< 0.0 f30-0)
            (set! (-> self collide-info transv y) f30-0)
            )
        )
      (+! (-> self collide-info transv y) (* -544768.0 (-> *display* seconds-per-frame)))
      (let* ((v1-26 (>= 0.0 (-> self collide-info transv y)))
             (v1-27 (and v1-26 (logtest? (-> self collide-info status) (cshape-moving-flags onsurf))))
             )
        (set! gp-0 (nav-enemy-method-60 self (not v1-27)))
        )
      (suspend)
      (ja :num! (seek!))
      )
    (loop
      (let ((s5-0
              (and (>= 0.0 (-> self collide-info transv y))
                   (logtest? (-> self collide-info status) (cshape-moving-flags onsurf))
                   )
              )
            )
        (set! gp-0 (and s5-0 gp-0))
        (if gp-0
            (goto cfg-26)
            )
        (integrate-for-enemy-with-move-to-ground!
          (-> self collide-info)
          (-> self collide-info transv)
          (collide-kind background)
          32768.0
          #f
          #f
          #f
          )
        (+! (-> self collide-info transv y) (* -544768.0 (-> *display* seconds-per-frame)))
        (set! gp-0 (nav-enemy-method-60 self (not s5-0)))
        )
      (suspend)
      )
    (label cfg-26)
    (let ((gp-1 (new 'stack-no-clear 'vector)))
      (vector<-cspace! gp-1 (-> self node-list data 29))
      (spawn (-> self part4) gp-1)
      (vector<-cspace! gp-1 (-> self node-list data 25))
      (spawn (-> self part4) gp-1)
      )
    (ja-no-eval :group! ice-cube-appear-land-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go ice-cube-become-mean)
    (none)
    )
  :post (the-as (function none :behavior ice-cube) nav-enemy-simple-post)
  )

(defstate ice-cube-become-mean (ice-cube)
  :event ice-cube-default-event-handler
  :enter (behavior ()
    (set! (-> self draw force-lod) 0)
    (logclear! (-> self mask) (process-mask actor-pause))
    (nav-enemy-method-57 self)
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.075))
    (let ((gp-0 #f))
      (ja-no-eval :group! ice-cube-extend-spikes-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (when (and (not gp-0) (>= (ja-aframe-num 0) 8.0))
          (set! gp-0 #t)
          (nav-enemy-method-58 self)
          )
        (suspend)
        (ja :num! (seek!))
        )
      )
    (go ice-cube-mean-turn-to-charge)
    (none)
    )
  :post (the-as (function none :behavior ice-cube) nav-enemy-simple-post)
  )

(defmethod nav-enemy-method-54 ice-cube ((obj ice-cube) (arg0 vector))
  (let* ((s4-0 (-> obj path curve num-cverts))
         (s2-0 (nav-enemy-rnd-int-count s4-0))
         (s5-0 (new 'stack-no-clear 'vector))
         )
    (dotimes (s3-0 s4-0)
      (eval-path-curve-div! (-> obj path) s5-0 (the float s2-0) 'interp)
      (when (>= (vector-vector-xz-distance s5-0 (-> obj collide-info trans)) 32768.0)
        (when (ice-cube-method-51 obj s5-0 s5-0)
          (set! (-> obj target-pt quad) (-> s5-0 quad))
          (return #t)
          )
        )
      (set! s2-0 (mod (+ s2-0 1) s4-0))
      )
    )
  #f
  )

(defstate ice-cube-mean-turn-to-charge (ice-cube)
  :event ice-cube-default-event-handler
  :enter (behavior ()
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (logior! (-> self nav-enemy-flags) (nav-enemy-flags navenmf2))
    (nav-enemy-method-58 self)
    (if (or (not *target*)
            (logtest? (-> *target* state-flags)
                      (state-flags being-attacked invulnerable timed-invulnerable invuln-powerup do-not-notice dying)
                      )
            (not (nav-enemy-test-point-near-nav-mesh? (-> *target* control shadow-pos)))
            )
        (go ice-cube-retract-spikes)
        )
    (set! (-> self tracking-player?) #t)
    (set! (-> self target-pt quad) (-> (target-pos 0) quad))
    (nav-enemy-neck-control-look-at)
    (set-vector! (-> self collide-info transv) 0.0 114688.0 0.0 1.0)
    (none)
    )
  :code (behavior ()
    (local-vars (gp-0 symbol))
    (ja-channel-push! 1 (seconds 0.075))
    (ja-no-eval :group! ice-cube-turn-on-player-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (let ((f30-0 (-> self collide-info transv y)))
        (integrate-for-enemy-with-move-to-ground!
          (-> self collide-info)
          (-> self collide-info transv)
          (collide-kind background)
          32768.0
          #f
          #f
          #f
          )
        (if (< 0.0 f30-0)
            (set! (-> self collide-info transv y) f30-0)
            )
        )
      (+! (-> self collide-info transv y) (* -544768.0 (-> *display* seconds-per-frame)))
      (let* ((v1-26 (>= 0.0 (-> self collide-info transv y)))
             (v1-27 (and v1-26 (logtest? (-> self collide-info status) (cshape-moving-flags onsurf))))
             )
        (set! gp-0 (nav-enemy-method-60 self (not v1-27)))
        )
      (suspend)
      (ja :num! (seek!))
      )
    (loop
      (let ((s5-0
              (and (>= 0.0 (-> self collide-info transv y))
                   (logtest? (-> self collide-info status) (cshape-moving-flags onsurf))
                   )
              )
            )
        (set! gp-0 (and s5-0 gp-0))
        (if gp-0
            (goto cfg-26)
            )
        (integrate-for-enemy-with-move-to-ground!
          (-> self collide-info)
          (-> self collide-info transv)
          (collide-kind background)
          32768.0
          #f
          #f
          #f
          )
        (+! (-> self collide-info transv y) (* -544768.0 (-> *display* seconds-per-frame)))
        (set! gp-0 (nav-enemy-method-60 self (not s5-0)))
        )
      (suspend)
      )
    (label cfg-26)
    (let ((gp-1 (new 'stack-no-clear 'vector)))
      (vector<-cspace! gp-1 (-> self node-list data 29))
      (spawn (-> self part4) gp-1)
      (vector<-cspace! gp-1 (-> self node-list data 25))
      (spawn (-> self part4) gp-1)
      )
    (ja-no-eval :group! ice-cube-turn-on-player-land-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go ice-cube-mean-charge)
    (none)
    )
  :post (the-as (function none :behavior ice-cube) nav-enemy-simple-post)
  )

(defstate ice-cube-mean-charge (ice-cube)
  :event ice-cube-default-event-handler
  :enter (behavior ()
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (nav-enemy-method-58 self)
    (logior! (-> self nav-enemy-flags) (nav-enemy-flags navenmf2))
    (set! (-> self next-skid-sound-time) (-> *display* base-frame-counter))
    (if (or (not *target*)
            (logtest? (-> *target* state-flags)
                      (state-flags being-attacked invulnerable timed-invulnerable invuln-powerup do-not-notice dying)
                      )
            (not (nav-enemy-test-point-near-nav-mesh? (-> *target* control shadow-pos)))
            )
        (go ice-cube-retract-spikes)
        )
    (set! (-> self target-speed) (-> self nav-info run-travel-speed))
    (set! (-> self acceleration) (-> self nav-info run-acceleration))
    (set! (-> self rotate-speed) (-> self nav-info run-rotate-speed))
    (set! (-> self turn-time) (-> self nav-info run-turn-time))
    (logclear! (-> self nav flags) (nav-control-flags navcf8))
    (set-root-prim-collide-with! (-> self collide-info) (collide-kind cak-2 cak-3 target crate enemy))
    (set! (-> self track-target?) #t)
    (set! (-> self slow-down?) #f)
    (set! (-> self speed) 81920.0)
    (set! (-> self prev-charge-angle-diff) 0.0)
    (let ((a0-6 (-> self collide-info trans)))
      (set! (-> self starting-pos quad) (-> a0-6 quad))
      )
    (set! (-> self charge-angle) (quaternion-y-angle (-> self collide-info quat)))
    (none)
    )
  :exit (behavior ()
    (logior! (-> self nav flags) (nav-control-flags navcf8))
    (set-root-prim-collide-with! (-> self collide-info) (collide-kind target))
    (none)
    )
  :trans (behavior ()
    (when (or (not *target*) (logtest? (-> *target* state-flags) (state-flags do-not-notice)))
      (cond
        ((= (-> self speed) 0.0)
         (go ice-cube-mean-charge-done)
         )
        (else
          (set! (-> self slow-down?) #t)
          (set! (-> self track-target?) #f)
          (set! (-> self tracking-player?) #f)
          )
        )
      )
    (if (-> self tracking-player?)
        (set! (-> self target-pt quad) (-> (target-pos 0) quad))
        )
    (let ((gp-1 (new 'stack-no-clear 'vector))
          (s5-0 (new 'stack-no-clear 'vector))
          )
      (vector-! gp-1 (-> self target-pt) (-> self starting-pos))
      (vector-! s5-0 (-> self collide-info trans) (-> self starting-pos))
      (let ((f30-0 (vector-xz-length gp-1))
            (f28-0 (vector-xz-length s5-0))
            )
        (if (< (+ 14336.0 f30-0) f28-0)
            (set! (-> self slow-down?) #t)
            )
        (let ((f0-5 (atan (-> gp-1 x) (-> gp-1 z)))
              (gp-2 (-> self nav target-pos))
              )
          (if (< f30-0 (+ 8192.0 f28-0))
              (set! (-> self track-target?) #f)
              )
          (cond
            ((-> self track-target?)
             (let ((f26-0 (deg-seek-smooth (-> self charge-angle) f0-5 (* 2730.6667 (-> *display* seconds-per-frame)) 0.25)))
               (set! (-> self prev-charge-angle-diff) (deg- f26-0 (-> self charge-angle)))
               (set! (-> self charge-angle) f26-0)
               )
             )
            (else
              (let ((f0-11 (* 0.99 (-> self prev-charge-angle-diff))))
                (set! (-> self prev-charge-angle-diff) f0-11)
                (+! (-> self charge-angle) f0-11)
                )
              )
            )
          (set-vector! gp-2 0.0 0.0 (+ 15360.0 (fmax f30-0 f28-0)) 1.0)
          (vector-rotate-around-y! gp-2 gp-2 (-> self charge-angle))
          (vector+! gp-2 gp-2 (-> self starting-pos))
          (nav-control-method-28 (-> self nav) (collide-kind wall-object ground-object))
          (nav-control-method-11 (-> self nav) gp-2)
          )
        )
      )
    (set! (-> self nav travel y) 0.0)
    (when (-> self slow-down?)
      (set! (-> self speed)
            (seek-with-smooth (-> self speed) 0.0 (* 81920.0 (-> *display* seconds-per-frame)) 0.8 1638.4)
            )
      (if (>= 0.0 (-> self speed))
          (go ice-cube-mean-charge-done)
          )
      (when (zero? (nav-enemy-rnd-int-count 45))
        (let ((gp-3 (new 'stack-no-clear 'vector)))
          (vector<-cspace! gp-3 (-> self node-list data 29))
          (spawn (-> self part4) gp-3)
          (vector<-cspace! gp-3 (-> self node-list data 25))
          (spawn (-> self part4) gp-3)
          )
        )
      (when (>= (-> *display* base-frame-counter) (-> self next-skid-sound-time))
        (set! (-> self next-skid-sound-time) (+ (-> *display* base-frame-counter) (nav-enemy-rnd-int-range 60 120)))
        (sound-play "ice-stop" :vol (the float (the int (* 0.0012207031 (-> self speed)))))
        )
      )
    (let ((f30-1 (* (vector-xz-length (-> self nav travel)) (-> *display* frames-per-second))))
      (if (< f30-1 13107.2)
          (go ice-cube-mean-charge-done)
          )
      (set! (-> self collide-info transv quad) (-> self nav travel quad))
      (if (< (-> self speed) f30-1)
          (set! f30-1 (-> self speed))
          )
      (set! (-> self anim-blend) (fmin 1.0 (* 0.000016276043 f30-1)))
      (vector-normalize! (-> self collide-info transv) f30-1)
      )
    (set! (-> self collide-info transv y) (+ -36864.0 (-> self collide-info transv y)))
    (quaternion-rotate-y-to-vector!
      (-> self collide-info quat)
      (-> self collide-info quat)
      (the-as quaternion (-> self collide-info transv))
      (* 16384.0 (-> *display* seconds-per-frame))
      )
    (integrate-for-enemy-with-move-to-ground!
      (-> self collide-info)
      (-> self collide-info transv)
      (collide-kind background)
      8192.0
      #f
      #f
      #f
      )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja :group! ice-cube-invuln-run-ja :num! min)
    (until (-> self slow-down?)
      (suspend)
      (ja :num! (loop!))
      )
    (ja-channel-push! 2 (seconds 0.07))
    (ja :group! ice-cube-invuln-stopping-upright-ja :num! min)
    (ja :chan 1 :group! ice-cube-invuln-stopping-ja :num! (chan 0) :frame-interp (-> self anim-blend))
    (loop
      (suspend)
      (ja :num! (loop!))
      (ja :chan 1 :num! (chan 0) :frame-interp (-> self anim-blend))
      )
    (none)
    )
  :post (the-as (function none :behavior ice-cube) nav-enemy-simple-post)
  )

(defstate ice-cube-mean-charge-done (ice-cube)
  :event ice-cube-default-event-handler
  :code (behavior ()
    (nav-enemy-method-58 self)
    (nav-enemy-neck-control-inactive)
    (go ice-cube-retract-spikes)
    (none)
    )
  )

(defstate ice-cube-retract-spikes (ice-cube)
  :event ice-cube-default-event-handler
  :code (behavior ()
    (nav-enemy-method-58 self)
    (nav-enemy-neck-control-inactive)
    (ja-channel-push! 1 (seconds 0.07))
    (let ((gp-0 #f))
      (ja-no-eval :group! ice-cube-retract-spikes-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (when (and (not gp-0) (>= (ja-aframe-num 0) 3.0))
          (set! gp-0 #t)
          (nav-enemy-method-57 self)
          )
        (suspend)
        (ja :num! (seek!))
        )
      )
    (go ice-cube-tired)
    (none)
    )
  :post (the-as (function none :behavior ice-cube) nav-enemy-simple-post)
  )

(defstate ice-cube-tired (ice-cube)
  :event ice-cube-default-event-handler
  :enter (behavior ()
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (none)
    )
  :trans (behavior ()
    (when (>= (- (-> *display* base-frame-counter) (-> self state-time)) (seconds 2))
      (cond
        ((or (not *target*) (< (-> self enemy-info idle-distance)
                               (vector-vector-distance (-> self collide-info trans) (-> *target* control trans))
                               )
             )
         (go-virtual nav-enemy-idle)
         )
        ((target-in-range? self (-> self nav-info notice-distance))
         (go ice-cube-face-player)
         )
        (else
          (go-virtual nav-enemy-patrol)
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! ice-cube-head-wipe-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (ja-channel-push! 1 (seconds 0.2))
    (loop
      (ja-no-eval :group! ice-cube-breathing-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (none)
    )
  :post (the-as (function none :behavior ice-cube) nav-enemy-simple-post)
  )

(defstate ice-cube-shatter (ice-cube)
  :code (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (vector<-cspace! gp-0 (-> self node-list data 3))
      (spawn (-> self part3) gp-0)
      )
    (drop-pickup (-> self enemy-info) #t *entity-pool* (-> self enemy-info) 0)
    (clear-collide-with-as (-> self collide-info))
    (cleanup-for-death self)
    (let ((gp-1 (new 'stack 'joint-exploder-tuning 1)))
      (set! (-> gp-1 duration) (seconds 3))
      (set! (-> gp-1 gravity) -327680.0)
      (set! (-> gp-1 fountain-rand-transv-lo quad) (-> (target-pos 0) quad))
      (process-spawn
        joint-exploder
        *ice-cube-break-sg*
        2
        gp-1
        (new 'static 'joint-exploder-static-params
          :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
            (new 'static 'joint-exploder-static-joint-params :joint-index 28)
            (new 'static 'joint-exploder-static-joint-params :joint-index 23)
            (new 'static 'joint-exploder-static-joint-params :joint-index 8)
            (new 'static 'joint-exploder-static-joint-params :joint-index 7)
            (new 'static 'joint-exploder-static-joint-params :joint-index 26)
            (new 'static 'joint-exploder-static-joint-params :joint-index 21)
            (new 'static 'joint-exploder-static-joint-params :joint-index 24)
            (new 'static 'joint-exploder-static-joint-params :joint-index 29)
            (new 'static 'joint-exploder-static-joint-params :joint-index 11)
            (new 'static 'joint-exploder-static-joint-params :joint-index 4)
            (new 'static 'joint-exploder-static-joint-params :joint-index 6)
            (new 'static 'joint-exploder-static-joint-params :joint-index 5)
            (new 'static 'joint-exploder-static-joint-params :joint-index 12)
            (new 'static 'joint-exploder-static-joint-params :joint-index 13)
            (new 'static 'joint-exploder-static-joint-params :joint-index 14)
            (new 'static 'joint-exploder-static-joint-params :joint-index 15)
            (new 'static 'joint-exploder-static-joint-params :joint-index 16)
            (new 'static 'joint-exploder-static-joint-params :joint-index 17)
            (new 'static 'joint-exploder-static-joint-params :joint-index 18)
            (new 'static 'joint-exploder-static-joint-params :joint-index 19)
            (new 'static 'joint-exploder-static-joint-params :joint-index 3)
            (new 'static 'joint-exploder-static-joint-params :joint-index 20)
            )
          )
        :to self
        )
      )
    (sound-play "ice-explode")
    (suspend)
    (ja-channel-set! 0)
    (ja-post)
    (until (not (-> self child))
      (suspend)
      )
    (none)
    )
  )
