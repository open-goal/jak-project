;;-*-Lisp-*-
(in-package goal)

;; name: snow-ball.gc
;; name in dgo: snow-ball
;; dgos: L1, SNO

;; DECOMP BEGINS

(import "goal_src/jak1/import/snow-ball-ag.gc")

(deftype snow-ball-shadow (process-drawable)
  ()
  :heap-base #x40
  :method-count-assert 20
  :size-assert         #xb0
  :flag-assert         #x14004000b0
  (:states
    snow-ball-shadow-idle
    )
  )


(deftype snow-ball-junction (structure)
  ((enter-time time-frame  :offset-assert   0)
   (exit-time  time-frame  :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #x10
  :flag-assert         #x900000010
  )


(deftype snow-ball-path-info (structure)
  ((hug-path? symbol         :offset-assert   0)
   (path-pos  vector :inline :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x20
  :flag-assert         #x900000020
  )


(deftype snow-ball-roller (process-drawable)
  ((root-override          collide-shape-moving           :offset        112)
   (which-path             int32                          :offset-assert 176)
   (path-u                 float                          :offset-assert 180)
   (path-speed             float                          :offset-assert 184)
   (path-length            float                          :offset-assert 188)
   (path-fall-u            float                          :offset-assert 192)
   (path-coming-out-u      float                          :offset-assert 196)
   (path-faded-up-u        float                          :offset-assert 200)
   (delay-til-bounce       int32                          :offset-assert 204)
   (rolling-sound-id       sound-id                       :offset-assert 208)
   (rolling-sound-enabled? symbol                         :offset-assert 212)
   (last-bounce-time       time-frame                     :offset-assert 216)
   (hit-player-time        time-frame                     :offset-assert 224)
   (path-info              snow-ball-path-info  :inline   :offset-assert 240)
   (junctions              snow-ball-junction   4 :inline :offset-assert 272)
   )
  :heap-base #xe0
  :method-count-assert 23
  :size-assert         #x150
  :flag-assert         #x1700e00150
  (:methods
    (follow-path (_type_) none 20)
    (play-landing-sound (_type_ float) sound-id 21)
    (snow-ball-roller-method-22 (_type_ process-drawable) none 22)
    )
  (:states
    snow-ball-roller-idle
    )
  )


(deftype snow-ball (process)
  ((child-override         (pointer snow-ball-roller)   :offset         20)
   (state-time             time-frame                   :offset-assert 112)
   (last-path-picked       int32                        :offset-assert 120)
   (same-path-picked-count int32                        :offset-assert 124)
   (delay-til-next         int32                        :offset-assert 128)
   (path                   curve-control              2 :offset-assert 132)
   )
  :heap-base #x20
  :method-count-assert 16
  :size-assert         #x8c
  :flag-assert         #x100020008c
  (:methods
    (snow-ball-method-14 (_type_ (inline-array snow-ball-junction) float int) symbol 14)
    (snow-ball-method-15 (_type_ (inline-array snow-ball-junction) int) symbol 15)
    )
  (:states
    snow-ball-idle
    )
  )


(defskelgroup *snow-ball-sg* snow-ball snow-ball-lod0-jg snow-ball-idle-ja
              ((snow-ball-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(defskelgroup *snow-ball-shadow-sg* snow-ball snow-ball-shadow-lod0-jg -1
              ((snow-ball-shadow-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -1.5 0 2)
              :shadow snow-ball-shadow-shadow-mg
              )

(define *snow-ball-shadow-control*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :flags (shadow-flags disable-fade shdf03)
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 245760.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 26624.0)
                                           :top-plane (new 'static 'plane :y 1.0)
                                           :fade-dist 819200.0
                                           )
                               )
  )

(defstate snow-ball-shadow-idle (snow-ball-shadow)
  :trans (behavior ()
    (set! (-> self root trans quad) (-> (the-as process-drawable (-> self parent 0)) root trans quad))
    (update-direction-from-time-of-day (-> self draw shadow-ctrl))
    0
    (none)
    )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
      )
    (none)
    )
  :post (the-as (function none :behavior snow-ball-shadow) ja-post)
  )

(defbehavior snow-ball-shadow-init-by-other snow-ball-shadow ()
  (stack-size-set! (-> self main-thread) 128)
  (logclear! (-> self mask) (process-mask actor-pause movie enemy platform projectile))
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> (the-as process-drawable (-> self parent 0)) root trans quad))
  (quaternion-identity! (-> self root quat))
  (vector-identity! (-> self root scale))
  (initialize-skeleton self *snow-ball-shadow-sg* '())
  (ja-channel-set! 1)
  (ja :group! snow-ball-shadow-idle-ja :num! min)
  (set! (-> self draw shadow-ctrl) *snow-ball-shadow-control*)
  (go snow-ball-shadow-idle)
  (none)
  )

(defbehavior snow-ball-roller-path-init snow-ball-roller ()
  (set! (-> self path-u) 0.0)
  (set! (-> self path-length) (path-distance (-> self path)))
  (none)
  )

(defmethod follow-path snow-ball-roller ((obj snow-ball-roller))
  (let ((s5-0 (-> obj path-info)))
    (set! (-> s5-0 hug-path?) #f)
    (let ((s4-0 (new 'stack-no-clear 'vector)))
      (set! (-> s4-0 quad) (-> s5-0 path-pos quad))
      (eval-path-curve! (-> obj path) (-> s5-0 path-pos) (-> obj path-u) 'interp)
      (let ((f0-1 (-> obj path-coming-out-u)))
        (when (< (-> obj path-u) f0-1)
          (set! (-> s5-0 path-pos y) (+ (- -20480.0 (* -20480.0 (/ (-> obj path-u) f0-1))) (-> s5-0 path-pos y)))
          (set! (-> s5-0 hug-path?) #t)
          )
        )
      (let ((f0-6 (-> obj path-faded-up-u)))
        (cond
          ((< (-> obj path-u) f0-6)
           (let* ((f0-7 (/ (-> obj path-u) f0-6))
                  (f0-8 (* f0-7 f0-7))
                  )
             (set-vector! (-> obj draw color-mult) f0-8 f0-8 f0-8 1.0)
             )
           )
          (else
            (vector-identity! (-> obj draw color-mult))
            )
          )
        )
      (cond
        ((>= (-> obj path-u) (-> obj path-fall-u))
         (set! (-> s5-0 path-pos y) -409600.0)
         (set! (-> s5-0 path-pos x) (+ (-> s4-0 x) (-> obj root-override transv x)))
         (set! (-> s5-0 path-pos z) (+ (-> s4-0 z) (-> obj root-override transv z)))
         (set! (-> obj rolling-sound-enabled?) #f)
         )
        (else
          (set! (-> obj root-override transv x) (- (-> s5-0 path-pos x) (-> s4-0 x)))
          (set! (-> obj root-override transv z) (- (-> s5-0 path-pos z) (-> s4-0 z)))
          )
        )
      )
    )
  (none)
  )

(defmethod play-landing-sound snow-ball-roller ((obj snow-ball-roller) (arg0 float))
  (let ((f30-0 (* 0.0018780049 (fmin 53248.0 (fmax 0.0 (+ -4096.0 (fabs arg0)))))))
    (sound-play "snowball-land" :vol f30-0)
    )
  )

(defbehavior snow-ball-roller-path-update snow-ball-roller ()
  (local-vars (f0-5 float))
  (let ((f0-0 (-> self root-override trans y)))
    (+! (-> self root-override transv y) (* -491520.0 (-> *display* seconds-per-frame)))
    (let ((f30-0 (+ f0-0 (* (-> self root-override transv y) (-> *display* seconds-per-frame)))))
      (follow-path self)
      (let ((a1-0 (new 'stack-no-clear 'vector)))
        (let ((a0-1 (-> self path-info)))
          (set! (-> a1-0 quad) (-> a0-1 path-pos quad))
          )
        (set! (-> a1-0 y) (+ 9216.0 (-> a1-0 y)))
        (cond
          ((-> self path-info hug-path?)
           (move-to-point! (-> self root-override) a1-0)
           (set! (-> self root-override transv y) 0.0)
           )
          ((begin (set! f0-5 (- f30-0 (-> a1-0 y))) (< 0.0 f0-5))
           (+! (-> a1-0 y) f0-5)
           (move-to-point! (-> self root-override) a1-0)
           )
          (else
            (move-to-point! (-> self root-override) a1-0)
            (let ((f0-7 (-> self root-override transv y)))
              (cond
                ((>= -40960.0 f0-7)
                 (set! (-> self root-override transv y) (* 0.4 (- f0-7)))
                 (play-landing-sound self (-> self root-override transv y))
                 )
                (else
                  (set! (-> self root-override transv y) 0.0)
                  )
                )
              )
            (when (< (-> self path-u) (-> self path-fall-u))
              (when (>= (- (-> *display* base-frame-counter) (-> self last-bounce-time)) (-> self delay-til-bounce))
                (let ((f0-13 (rand-vu-float-range 8192.0 20480.0)))
                  (+! (-> self root-override transv y) f0-13)
                  (play-landing-sound self f0-13)
                  )
                (set! (-> self last-bounce-time) (-> *display* base-frame-counter))
                (set! (-> self delay-til-bounce) (rand-vu-int-range 300 2100))
                )
              )
            )
          )
        )
      )
    )
  (let ((s4-0 (new 'stack-no-clear 'vector)))
    (path-control-method-14 (-> self path) s4-0 (-> self path-u))
    (let ((gp-0 (new 'stack-no-clear 'matrix)))
      (let ((s5-0 (new 'stack-no-clear 'matrix)))
        (let ((s3-0 (new 'stack-no-clear 'vector)))
          (vector-negate! s3-0 (-> *standard-dynamics* gravity-normal))
          (forward-down->inv-matrix gp-0 s4-0 s3-0)
          )
        (matrix-rotate-x! s5-0 (* 1.1317686 (-> self path-u) (-> self path-length)))
        (matrix*! gp-0 s5-0 gp-0)
        )
      (matrix->quaternion (-> self root-override quat) gp-0)
      )
    )
  (+! (-> self path-u) (* (-> self path-speed) (-> *display* seconds-per-frame)))
  (if (< 1.0 (-> self path-u))
      (set! (-> self path-u) 1.0)
      )
  (let ((f0-23 (- 819200.0 (-> self root-override trans y))))
    (when (>= f0-23 0.0)
      (cond
        ((>= f0-23 245760.0)
         (deactivate self)
         )
        (else
          (let ((f0-25 (- 1.0 (* 0.0000040690106 f0-23))))
            (set! (-> self root-override scale x) f0-25)
            (set! (-> self root-override scale y) f0-25)
            (set! (-> self root-override scale z) f0-25)
            )
          )
        )
      )
    )
  (let ((v1-54 (< (vector-vector-distance (-> self root-override trans) (math-camera-pos)) 163840.0)))
    (cond
      ((zero? (-> self rolling-sound-id))
       (if (and v1-54 (-> self rolling-sound-enabled?))
           (set! (-> self rolling-sound-id)
                 (sound-play "snowball-roll" :position (the-as symbol (-> self root-override trans)))
                 )
           )
       )
      ((and v1-54 (-> self rolling-sound-enabled?))
       (sound-play
         "snowball-roll"
         :id (-> self rolling-sound-id)
         :position (the-as symbol (-> self root-override trans))
         )
       )
      (else
        (sound-stop (-> self rolling-sound-id))
        (set! (-> self rolling-sound-id) (new 'static 'sound-id))
        0
        )
      )
    )
  (none)
  )

(defmethod snow-ball-roller-method-22 snow-ball-roller ((obj snow-ball-roller) (arg0 process-drawable))
  (cond
    ((< (+ 4096.0 (-> arg0 root trans y)) (-> obj root-override trans y))
     (let ((f0-2 81920.0))
       (+! (-> obj root-override transv y) f0-2)
       (play-landing-sound obj f0-2)
       )
     )
    (else
      (let ((f0-3 24576.0))
        (+! (-> obj root-override transv y) f0-3)
        (play-landing-sound obj f0-3)
        )
      )
    )
  (let ((s4-0 (new 'stack-no-clear 'vector)))
    (let ((s3-0 (new 'stack-no-clear 'vector)))
      (vector-! s4-0 (-> arg0 root trans) (-> obj root-override trans))
      (set! (-> s4-0 y) 0.0)
      (vector-normalize! s4-0 1.0)
      (path-control-method-14 (-> obj path) s3-0 (-> obj path-u))
      (set! (-> s3-0 y) 0.0)
      (vector-normalize! s3-0 1.0)
      (let* ((f28-0 (atan (-> s4-0 x) (-> s4-0 z)))
             (f30-0 (atan (-> s3-0 x) (-> s3-0 z)))
             (f0-11 (deg- f28-0 f30-0))
             )
        (when (< (fabs f0-11) 10922.667)
          (let ((f30-1 (+ f30-0 (if (>= f0-11 0.0)
                                    10922.667
                                    -10922.667
                                    )
                          )
                       )
                )
            (set-vector! s4-0 (sin f30-1) 0.0 (cos f30-1) 1.0)
            )
          )
        )
      )
    (vector-normalize! s4-0 25600.0)
    (vector+! s4-0 s4-0 (-> obj root-override trans))
    (vector-! s4-0 s4-0 (-> arg0 root trans))
    (set! (-> s4-0 y) 0.0)
    (let ((f30-2 (vector-length s4-0)))
      (vector-normalize! s4-0 1.0)
      (send-event arg0 'attack #f (static-attack-info ((vector s4-0) (shove-up (meters 3)) (shove-back f30-2))))
      )
    )
  (none)
  )

(defstate snow-ball-roller-idle (snow-ball-roller)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('touch 'attack)
                      (when (= (-> proc type) target)
                        (do-push-aways! (-> self root-override))
                        (when (>= (- (-> *display* base-frame-counter) (-> self hit-player-time)) (seconds 0.5))
                          (set! (-> self hit-player-time) (-> *display* base-frame-counter))
                          (the-as symbol (snow-ball-roller-method-22 self *target*))
                          )
                        )
                      )
                     )
            )
    )
  :enter (behavior ()
    (set! (-> self last-bounce-time) (-> *display* base-frame-counter))
    (snow-ball-roller-path-init)
    (none)
    )
  :exit (behavior ()
    (set! (-> self rolling-sound-enabled?) #f)
    (when (nonzero? (-> self rolling-sound-id))
      (sound-stop (-> self rolling-sound-id))
      (set! (-> self rolling-sound-id) (new 'static 'sound-id))
      0
      )
    (none)
    )
  :trans (behavior ()
    (snow-ball-roller-path-update)
    (none)
    )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
      )
    (none)
    )
  :post (the-as (function none :behavior snow-ball-roller) transform-post)
  )

(defbehavior snow-ball-roller-init-by-other snow-ball-roller ((arg0 entity-actor) (arg1 snow-ball) (arg2 float) (arg3 int) (arg4 (inline-array snow-ball-junction)))
  (set! (-> self rolling-sound-id) (new 'static 'sound-id))
  (set! (-> self rolling-sound-enabled?) #t)
  (set! (-> self path-speed) arg2)
  (set! (-> self which-path) arg3)
  (set! (-> self hit-player-time) 0)
  (set! (-> self entity) arg0)
  (dotimes (s3-0 4)
    (mem-copy! (the-as pointer (-> self junctions s3-0)) (the-as pointer (-> arg4 s3-0)) 16)
    )
  (let ((s4-1 (new 'process 'collide-shape-moving self (collide-list-enum hit-by-player))))
    (set! (-> s4-1 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-1 reaction) default-collision-reaction)
    (set! (-> s4-1 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((s3-1 (new 'process 'collide-shape-prim-sphere s4-1 (the-as uint 0))))
      (set! (-> s3-1 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-1 collide-with) (collide-kind target))
      (set! (-> s3-1 prim-core action) (collide-action solid))
      (set! (-> s3-1 prim-core offense) (collide-offense indestructible))
      (set-vector! (-> s3-1 local-sphere) 0.0 0.0 0.0 10240.0)
      (set-root-prim! s4-1 s3-1)
      )
    (set! (-> s4-1 nav-radius) (* 0.75 (-> s4-1 root-prim local-sphere w)))
    (backup-collide-with-as s4-1)
    (set! (-> self root-override) s4-1)
    )
  (set-vector! (-> self root-override transv) 0.0 0.0 0.0 1.0)
  (process-drawable-from-entity! self arg0)
  (initialize-skeleton self *snow-ball-sg* '())
  (logclear! (-> self mask) (process-mask actor-pause))
  (set! (-> self path) (new 'process 'curve-control self 'path (the float (+ arg3 1))))
  (logior! (-> self path flags) (path-control-flag display draw-line draw-point draw-text))
  (let ((v1-33 (-> self which-path)))
    (cond
      ((zero? v1-33)
       (set! (-> self path-fall-u) 0.8667)
       (set! (-> self path-coming-out-u) 0.05)
       (set! (-> self path-faded-up-u) 0.075)
       )
      ((= v1-33 1)
       (set! (-> self path-fall-u) 0.9105)
       (set! (-> self path-coming-out-u) 0.05)
       (set! (-> self path-faded-up-u) 0.075)
       )
      )
    )
  (set! (-> self delay-til-bounce) (rand-vu-int-range 900 2100))
  (process-spawn snow-ball-shadow :to self)
  (go snow-ball-roller-idle)
  (none)
  )

(defmethod snow-ball-method-14 snow-ball ((obj snow-ball) (arg0 (inline-array snow-ball-junction)) (arg1 float) (arg2 int))
  (local-vars (v1-0 (pointer float)))
  (if (zero? arg2)
      (set! v1-0 (new 'static 'array float 8 0.3309 0.36 0.4691 0.5061 0.6904 0.7264 0.864 0.8667))
      (set! v1-0 (new 'static 'array float 8 0.3344 0.3528 0.4919 0.5246 0.6967 0.7272 0.8677 0.9105))
      )
  (let ((a0-4 (* arg1 (-> *display* seconds-per-frame)))
        (a1-1 (-> arg0 0))
        (a2-2 (-> *display* base-frame-counter))
        )
    (dotimes (a3-1 4)
      (set! (-> a1-1 enter-time) (+ a2-2 (the int (/ (-> v1-0 0) a0-4))))
      (set! (-> a1-1 exit-time) (+ a2-2 (the int (/ (-> v1-0 1) a0-4))))
      (set! v1-0 (&-> v1-0 2))
      (&+! a1-1 16)
      )
    )
  #f
  )

(defmethod snow-ball-method-15 snow-ball ((obj snow-ball) (arg0 (inline-array snow-ball-junction)) (arg1 int))
  (local-vars (v0-0 symbol))
  (let ((v1-0 (-> obj child-override)))
    (while v1-0
      (let ((a0-1 (-> arg0 0))
            (a3-1 (-> v1-0 0 junctions))
            )
        (dotimes (t0-0 3)
          (if (and (>= (-> a3-1 0 exit-time) (-> a0-1 enter-time)) (>= (-> a0-1 exit-time) (-> a3-1 0 enter-time)))
              (return #f)
              )
          (&+! a0-1 16)
          (set! a3-1 (the-as (inline-array snow-ball-junction) (-> a3-1 1)))
          )
        (when (= arg1 (-> v1-0 0 which-path))
          (if (>= (-> a3-1 0 exit-time) (-> a0-1 enter-time))
              (return #f)
              )
          )
        )
      (set! v1-0 (the-as (pointer snow-ball-roller) (-> v1-0 0 brother)))
      )
    )
  (return #t)
  v0-0
  )

(defstate snow-ball-idle (snow-ball)
  :code (behavior ()
    (local-vars (gp-0 int))
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (set! (-> self delay-til-next) 0)
    (label cfg-1)
    (when (>= (- (-> *display* base-frame-counter) (-> self state-time)) (-> self delay-til-next))
      (set! gp-0 (cond
                   ((>= (-> self same-path-picked-count) 2)
                    (if (zero? (-> self last-path-picked))
                        (set! gp-0 1)
                        (set! gp-0 0)
                        )
                    gp-0
                    )
                   (else
                     (rand-vu-int-range 0 1)
                     )
                   )
            )
      (let ((s4-0 0)
            (s5-0 (new 'stack-no-clear 'inline-array 'snow-ball-junction 4))
            )
        (loop
          (let ((s3-0 (/ (+ 98304.0 (rand-vu-float-range 0.0 32768.0)) (path-distance (-> self path gp-0)))))
            (snow-ball-method-14 self s5-0 s3-0 gp-0)
            (when (snow-ball-method-15 self s5-0 gp-0)
              (process-spawn snow-ball-roller (-> self entity) self s3-0 gp-0 s5-0 :to self)
              (set! (-> self state-time) (-> *display* base-frame-counter))
              (set! (-> self delay-til-next) (rand-vu-int-range 450 1650))
              (cond
                ((= gp-0 (-> self last-path-picked))
                 (+! (-> self same-path-picked-count) 1)
                 )
                (else
                  (set! (-> self last-path-picked) gp-0)
                  (set! (-> self same-path-picked-count) 1)
                  )
                )
              (goto cfg-22)
              )
            )
          (+! s4-0 1)
          (if (< 5 s4-0)
              (goto cfg-22)
              )
          )
        )
      )
    (label cfg-22)
    (suspend)
    (b! #t cfg-1 :delay (nop!))
    (none)
    )
  )

(defmethod relocate snow-ball ((obj snow-ball) (arg0 int))
  (dotimes (v1-0 2)
    (if (nonzero? (-> obj path v1-0))
        (&+! (-> obj path v1-0) arg0)
        )
    )
  (the-as snow-ball ((the-as (function process-drawable int process-drawable) (find-parent-method snow-ball 7))
                     (the-as process-drawable obj)
                     arg0
                     )
          )
  )

(defmethod init-from-entity! snow-ball ((obj snow-ball) (arg0 entity-actor))
  (set! (-> obj last-path-picked) 1)
  (set! (-> obj same-path-picked-count) 1)
  (dotimes (s5-0 2)
    (set! (-> obj path s5-0) (new 'process 'curve-control obj 'path (the float (+ s5-0 1))))
    )
  (logclear! (-> obj mask) (process-mask actor-pause))
  (go snow-ball-idle)
  (none)
  )
