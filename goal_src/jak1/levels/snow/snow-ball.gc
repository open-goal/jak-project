;;-*-Lisp-*-
(in-package goal)

;; name: snow-ball.gc
;; name in dgo: snow-ball
;; dgos: L1, SNO

;; DECOMP BEGINS

(import "goal_src/jak1/import/snow-ball-ag.gc")

(defclass snow-ball (process)
  "Spawns snow-ball-rollers every delay-til-next frames that roll along predefined paths."
  (:fields 
    (child-override         (pointer snow-ball-roller)   :offset         20)
    (state-time             time-frame                   :offset-assert 112)
    (last-path-picked       int32                        :offset-assert 120)
    (same-path-picked-count int32                        :offset-assert 124)
    (delay-til-next         int32                        :offset-assert 128)
    (path                   curve-control              2 :offset-assert 132)
   )
  (:types
    (snow-ball-junction (structure)
      ((enter-time time-frame  :offset-assert   0)
       (exit-time  time-frame  :offset-assert   8)
      )
      (:options
        :method-count-assert 9
        :size-assert         #x10
        :flag-assert         #x900000010
       )
      )
    (snow-ball-roller (process-drawable)
      "A snow ball that rolls along a path and can hit the player."
      ((root-override          collide-shape-moving           :offset        112)
       (which-path             int32                          :offset-assert 176)
       (path-u                 float                          :offset-assert 180)
       (path-speed             float                          :offset-assert 184)
       (path-length            float                          :offset-assert 188)
       (path-fall-u            float                          :offset-assert 192)
       (path-coming-out-u      float                          :offset-assert 196)
       (path-faded-up-u        float                          :offset-assert 200)
       (delay-til-bounce       int32                          :offset-assert 204)
       (rolling-sound-id       sound-id                       :offset-assert 208)
       (rolling-sound-enabled? symbol                         :offset-assert 212)
       (last-bounce-time       time-frame                     :offset-assert 216)
       (hit-player-time        time-frame                     :offset-assert 224)
       (path-info              snow-ball-path-info  :inline   :offset-assert 240)
       (junctions              snow-ball-junction   4 :inline :offset-assert 272)
      )
      (:types
        (snow-ball-shadow (process-drawable)
          (:globals
            (*snow-ball-shadow-control*
            (new 'static 'shadow-control 
                :settings (new 'static 'shadow-settings
                            :flags (shadow-flags disable-fade shdf03)
                            :shadow-dir (new 'static 'vector :y -1.0 :w 245760.0)
                            :bot-plane (new 'static 'plane :y 1.0 :w 26624.0)
                            :top-plane (new 'static 'plane :y 1.0)
                            :fade-dist 819200.0
                          )
                )
            )
          )
          (:behaviors
              (snow-ball-shadow-init-by-other ()
                (stack-size-set! (-> self main-thread) 128)
                (logclear! (-> self mask) (process-mask actor-pause movie enemy platform projectile))
                (set! (-> self root) (new 'process 'trsqv))
                (set! (-> self root trans quad) (-> (the-as process-drawable (-> self parent 0)) root trans quad))
                (quaternion-identity! (-> self root quat))
                (vector-identity! (-> self root scale))
                (initialize-skeleton self *snow-ball-shadow-sg* '())
                (ja-channel-set! 1)
                (ja :group! snow-ball-shadow-idle-ja :num! min)
                (set! (-> self draw shadow-ctrl) *snow-ball-shadow-control*)
                (go snow-ball-shadow-idle)
                (none)
              )
            )
          (:states
            (snow-ball-shadow-idle
                :trans (behavior ()
                  (set! (-> self root trans quad) (-> (the-as process-drawable (-> self parent 0)) root trans quad))
                  (update-direction-from-time-of-day (-> self draw shadow-ctrl))
                  0
                  (none)
                )
                :code (behavior ()
                  (loop
                    (logior! (-> self mask) (process-mask sleep-code))
                    (suspend)
                    )
                  (none)
                )
                :post (the-as (function none :behavior snow-ball-shadow) ja-post)
              )
            )
          (:skelgroups
            (*snow-ball-shadow-sg* snow-ball-shadow-lod0-jg -1
              ((snow-ball-shadow-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -1.5 0 2)
              :shadow snow-ball-shadow-shadow-mg
            )
           )
          (:options
              :heap-base #x40
              :method-count-assert 20
              :size-assert         #xb0
              :flag-assert         #x14004000b0
            )
          ) 
        (snow-ball-path-info (structure)
          ((hug-path? symbol         :offset-assert   0)
           (path-pos  vector :inline :offset-assert  16)
          )
          (:options
            :method-count-assert 9
            :size-assert         #x20
            :flag-assert         #x900000020
          )
        )
       )
      (:methods
        (follow-path () (none)
          (let ((info (-> self path-info)))
            (set! (-> info hug-path?) #f)
            (let ((path-pos (new 'stack-no-clear 'vector)))
              (set! (-> path-pos quad) (-> info path-pos quad))
              (eval-path-curve! (-> self path) (-> info path-pos) (-> self path-u) 'interp)
              (let ((bounce-threshold (-> self path-coming-out-u)))
                (when (< (-> self path-u) bounce-threshold)
                  (set! (-> info path-pos y) (+ (- -20480.0 (* -20480.0 (/ (-> self path-u) bounce-threshold))) (-> info path-pos y)))
                  (set! (-> info hug-path?) #t)
                  )
                )
              (let ((fade-threshold (-> self path-faded-up-u)))
                (cond
                  ((< (-> self path-u) fade-threshold)
                    (let* ((fade-factor (/ (-> self path-u) fade-threshold))
                           (opacity (* fade-factor fade-factor))
                          )
                      (set-vector! (-> self draw color-mult) opacity opacity opacity 1.0)
                      )
                  )
                  (else
                    (vector-identity! (-> self draw color-mult))
                    )
                  )
                )
              (cond
                ((>= (-> self path-u) (-> self path-fall-u))
                  (set! (-> info path-pos y) -409600.0)
                  (set! (-> info path-pos x) (+ (-> path-pos x) (-> self root-override transv x)))
                  (set! (-> info path-pos z) (+ (-> path-pos z) (-> self root-override transv z)))
                  (set! (-> self rolling-sound-enabled?) #f)
                )
                (else
                  (set! (-> self root-override transv x) (- (-> info path-pos x) (-> path-pos x)))
                  (set! (-> self root-override transv z) (- (-> info path-pos z) (-> path-pos z)))
                  )
                )
              )
            )
          (none)
        )
        (play-landing-sound ((speed float)) (sound-id)
          (let ((volume (* 0.0018780049 (fmin 53248.0 (fmax 0.0 (+ -4096.0 (fabs speed)))))))
            (sound-play "snowball-land" :vol volume)
          )
        )
        (hit! ((other process-drawable)) (none)
          (cond
            ((< (+ 4096.0 (-> other root trans y)) (-> self root-override trans y))
            (let ((impact-velocity 81920.0))
              (+! (-> self root-override transv y) impact-velocity)
              (play-landing-sound self impact-velocity)
              )
            )
            (else
              (let ((impact-velocity 24576.0))
                (+! (-> self root-override transv y) impact-velocity)
                (play-landing-sound self impact-velocity)
                )
              )
            )
          (let ((hit-vector (new 'stack-no-clear 'vector)))
            (let ((path-vector (new 'stack-no-clear 'vector)))
              (vector-! hit-vector (-> other root trans) (-> self root-override trans))
              (set! (-> hit-vector y) 0.0)
              (vector-normalize! hit-vector 1.0)
              (TODO-RENAME-14 (-> self path) path-vector (-> self path-u))
              (set! (-> path-vector y) 0.0)
              (vector-normalize! path-vector 1.0)
              (let* ((hit-angle (atan (-> hit-vector x) (-> hit-vector z)))
                    (path-angle (atan (-> path-vector x) (-> path-vector z)))
                    (angle-difference (deg- hit-angle path-angle))
                    )
                (when (< (fabs angle-difference) 10922.667)
                  (let ((adjusted-angle (+ path-angle (if (>= angle-difference 0.0)
                                            10922.667
                                            -10922.667
                                            )
                                  )
                              )
                        )
                    (set-vector! hit-vector (sin adjusted-angle) 0.0 (cos adjusted-angle) 1.0)
                    )
                  )
                )
              )
            (vector-normalize! hit-vector 25600.0)
            (vector+! hit-vector hit-vector (-> self root-override trans))
            (vector-! hit-vector hit-vector (-> other root trans))
            (set! (-> hit-vector y) 0.0)
            (let ((force (vector-length hit-vector)))
              (vector-normalize! hit-vector 1.0)
              (send-event other 'attack #f (static-attack-info ((vector hit-vector) (shove-up (meters 3)) (shove-back force))))
            )
          )
          (none)
        )
      )
      (:behaviors
        
        (snow-ball-roller-path-init ()
          (set! (-> self path-u) 0.0)
          (set! (-> self path-length) (path-distance (-> self path)))
          (none)
        )

        (snow-ball-roller-path-update ()
          (local-vars (time-since-last-bounce float))
          (let ((y (-> self root-override trans y)))
            (+! (-> self root-override transv y) (* -491520.0 (-> *display* seconds-per-frame)))
            (let ((new-y (+ y (* (-> self root-override transv y) (-> *display* seconds-per-frame)))))
              (follow-path self)
              (let ((path-pos (new 'stack-no-clear 'vector)))
                (let ((info (-> self path-info)))
                  (set! (-> path-pos quad) (-> info path-pos quad))
                  )
                (set! (-> path-pos y) (+ 9216.0 (-> path-pos y)))
                (cond
                  ((-> self path-info hug-path?)
                  (move-to-point! (-> self root-override) path-pos)
                  (set! (-> self root-override transv y) 0.0)
                  )
                  ((begin (set! time-since-last-bounce (- new-y (-> path-pos y))) (< 0.0 time-since-last-bounce))
                  (+! (-> path-pos y) time-since-last-bounce)
                  (move-to-point! (-> self root-override) path-pos)
                  )
                  (else
                    (move-to-point! (-> self root-override) path-pos)
                    (let ((y-vel (-> self root-override transv y)))
                      (cond
                        ((>= -40960.0 y-vel)
                        (set! (-> self root-override transv y) (* 0.4 (- y-vel)))
                        (play-landing-sound self (-> self root-override transv y))
                        )
                        (else
                          (set! (-> self root-override transv y) 0.0)
                          )
                        )
                      )
                    (when (< (-> self path-u) (-> self path-fall-u))
                      (when (>= (- (-> *display* base-frame-counter) (-> self last-bounce-time)) (-> self delay-til-bounce))
                        (let ((bounce-force (rand-vu-float-range 8192.0 20480.0)))
                          (+! (-> self root-override transv y) bounce-force)
                          (play-landing-sound self bounce-force)
                          )
                        (set! (-> self last-bounce-time) (-> *display* base-frame-counter))
                        (set! (-> self delay-til-bounce) (rand-vu-int-range 300 2100))
                        )
                      )
                    )
                  )
                )
              )
            )
          (let ((path-vector (new 'stack-no-clear 'vector)))
            (TODO-RENAME-14 (-> self path) path-vector (-> self path-u))
            (let ((inverse-gravity-matrix (new 'stack-no-clear 'matrix)))
              (let ((rotatin-matrix (new 'stack-no-clear 'matrix)))
                (let ((inverse-gravity-normal (new 'stack-no-clear 'vector)))
                  (vector-negate! inverse-gravity-normal (-> *standard-dynamics* gravity-normal))
                  (forward-down->inv-matrix inverse-gravity-matrix path-vector inverse-gravity-normal)
                  )
                (matrix-rotate-x! rotatin-matrix (* 1.1317686 (-> self path-u) (-> self path-length)))
                (matrix*! inverse-gravity-matrix rotatin-matrix inverse-gravity-matrix)
                )
              (matrix->quaternion (-> self root-override quat) inverse-gravity-matrix)
              )
            )
          (+! (-> self path-u) (* (-> self path-speed) (-> *display* seconds-per-frame)))
          (if (< 1.0 (-> self path-u))
              (set! (-> self path-u) 1.0)
              )
          (let ((distance-to-ground (- 819200.0 (-> self root-override trans y))))
            (when (>= distance-to-ground 0.0)
              (cond
                ((>= distance-to-ground 245760.0)
                (deactivate self)
                )
                (else
                  (let ((squish-factor (- 1.0 (* 0.0000040690106 distance-to-ground))))
                    (set! (-> self root-override scale x) squish-factor)
                    (set! (-> self root-override scale y) squish-factor)
                    (set! (-> self root-override scale z) squish-factor)
                    )
                  )
                )
              )
            )
          (let ((play-sound? (< (vector-vector-distance (-> self root-override trans) (math-camera-pos)) 163840.0)))
            (cond
              ((zero? (-> self rolling-sound-id))
              (if (and play-sound? (-> self rolling-sound-enabled?))
                  (set! (-> self rolling-sound-id)
                        (sound-play "snowball-roll" :position (the-as symbol (-> self root-override trans)))
                        )
                  )
              )
              ((and play-sound? (-> self rolling-sound-enabled?))
              (sound-play
                "snowball-roll"
                :id (-> self rolling-sound-id)
                :position (the-as symbol (-> self root-override trans))
                )
              )
              (else
                (sound-stop (-> self rolling-sound-id))
                (set! (-> self rolling-sound-id) (new 'static 'sound-id))
                0
                )
              )
            )
          (none)
        )

        (snow-ball-roller-init-by-other ((other entity-actor) (parent snow-ball) (speed float) (path int) (junctions (inline-array snow-ball-junction)))
          (set! (-> self rolling-sound-id) (new 'static 'sound-id))
          (set! (-> self rolling-sound-enabled?) #t)
          (set! (-> self path-speed) speed)
          (set! (-> self which-path) path)
          (set! (-> self hit-player-time) 0)
          (set! (-> self entity) other)
          (dotimes (i 4)
            (mem-copy! (the-as pointer (-> self junctions i)) (the-as pointer (-> junctions i)) 16)
            )
          (let ((collide-shape (new 'process 'collide-shape-moving self (collide-list-enum hit-by-player))))
            (set! (-> collide-shape dynam) (copy *standard-dynamics* 'process))
            (set! (-> collide-shape reaction) default-collision-reaction)
            (set! (-> collide-shape no-reaction)
                  (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
                  )
            (let ((collide-sphere (new 'process 'collide-shape-prim-sphere collide-shape (the-as uint 0))))
              (set! (-> collide-sphere prim-core collide-as) (collide-kind enemy))
              (set! (-> collide-sphere collide-with) (collide-kind target))
              (set! (-> collide-sphere prim-core action) (collide-action solid))
              (set! (-> collide-sphere prim-core offense) (collide-offense indestructible))
              (set-vector! (-> collide-sphere local-sphere) 0.0 0.0 0.0 10240.0)
              (set-root-prim! collide-shape collide-sphere)
              )
            (set! (-> collide-shape nav-radius) (* 0.75 (-> collide-shape root-prim local-sphere w)))
            (backup-collide-with-as collide-shape)
            (set! (-> self root-override) collide-shape)
            )
          (set-vector! (-> self root-override transv) 0.0 0.0 0.0 1.0)
          (process-drawable-from-entity! self other)
          (initialize-skeleton self *snow-ball-sg* '())
          (logclear! (-> self mask) (process-mask actor-pause))
          (set! (-> self path) (new 'process 'curve-control self 'path (the float (+ path 1))))
          (logior! (-> self path flags) (path-control-flag display draw-line draw-point draw-text))
          (let ((path (-> self which-path)))
            (cond
              ((zero? path)
                (set! (-> self path-fall-u) 0.8667)
                (set! (-> self path-coming-out-u) 0.05)
                (set! (-> self path-faded-up-u) 0.075)
              )
              ((= path 1)
                (set! (-> self path-fall-u) 0.9105)
                (set! (-> self path-coming-out-u) 0.05)
                (set! (-> self path-faded-up-u) 0.075)
              )
              )
            )
          (set! (-> self delay-til-bounce) (rand-vu-int-range 900 2100))
          (process-spawn snow-ball-shadow :to self)
          (go snow-ball-roller-idle)
          (none)
          )
      )
      (:states
        (snow-ball-roller-idle
          :event (behavior ((from process) (argc int) (msg symbol) (block event-message-block))
            (let ((message msg))
              (the-as object (when (or (= message 'touch) (= message 'attack))
                              (when (= (-> from type) target)
                                (do-push-aways! (-> self root-override))
                                (when (>= (- (-> *display* base-frame-counter) (-> self hit-player-time)) (seconds 0.5))
                                  (set! (-> self hit-player-time) (-> *display* base-frame-counter))
                                  (hit! self *target*)
                                  )
                                )
                              )
                      )
              )
          )
          :enter (behavior ()
            (set! (-> self last-bounce-time) (-> *display* base-frame-counter))
            (snow-ball-roller-path-init)
            (none)
          )
          :exit (behavior ()
            (set! (-> self rolling-sound-enabled?) #f)
            (when (nonzero? (-> self rolling-sound-id))
              (sound-stop (-> self rolling-sound-id))
              (set! (-> self rolling-sound-id) (new 'static 'sound-id))
              0
              )
            (none)
          )
          :trans (behavior ()
            (snow-ball-roller-path-update)
            (none)
          )
          :code (behavior ()
            (loop
              (logior! (-> self mask) (process-mask sleep-code))
              (suspend)
              )
            (none)
          )
          :post (the-as (function none :behavior snow-ball-roller) transform-post)
        )
      )
      (:skelgroups
        (*snow-ball-sg* snow-ball-lod0-jg snow-ball-idle-ja
          ((snow-ball-lod0-mg (meters 999999)))
          :bounds (static-spherem 0 0 0 3)
        )
   )
      (:options
        :heap-base #xe0
        :method-count-assert 23
        :size-assert         #x150
        :flag-assert         #x1700e00150
      )
   )
  )
  (:methods
    (set-junction-times! ((junctions (inline-array snow-ball-junction)) (speed float) (flag int)) (symbol) 
      (local-vars (junction-timings (pointer float)))
      (if (zero? flag)
          (set! junction-timings (new 'static 'array float 8 0.3309 0.36 0.4691 0.5061 0.6904 0.7264 0.864 0.8667))
          (set! junction-timings (new 'static 'array float 8 0.3344 0.3528 0.4919 0.5246 0.6967 0.7272 0.8677 0.9105))
          )
      (let ((frame-rate-scaler (* speed (-> *display* seconds-per-frame)))
            (junction (-> junctions 0))
            (frame (-> *display* base-frame-counter))
            )
        (dotimes (i 4)
          (set! (-> junction enter-time) (+ frame (the int (/ (-> junction-timings 0) frame-rate-scaler))))
          (set! (-> junction exit-time) (+ frame (the int (/ (-> junction-timings 1) frame-rate-scaler))))
          (set! junction-timings (&-> junction-timings 2))
          (&+! junction 16)
          )
        )
      #f
     )
    (path-clear? ((junctions (inline-array snow-ball-junction)) (path int)) (symbol) 
      (local-vars (unused symbol))
      (let ((child (-> self child-override)))
        (while child
          (let ((junction (-> junctions 0))
                (child-junction (-> child 0 junctions))
                )
            (dotimes (i 3)
              (if (and (>= (-> child-junction 0 exit-time) (-> junction enter-time)) (>= (-> junction exit-time) (-> child-junction 0 enter-time)))
                  (return #f)
                  )
              (&+! junction 16)
              (set! child-junction (the-as (inline-array snow-ball-junction) (-> child-junction 1)))
              )
            (when (= path (-> child 0 which-path))
              (if (>= (-> child-junction 0 exit-time) (-> junction enter-time))
                  (return #f)
                  )
              )
            )
          (set! child (the-as (pointer snow-ball-roller) (-> child 0 brother)))
          )
        )
      (return #t)
      unused
     )
    (relocate ((offset int)) (snow-ball)
      (dotimes (i 2)
        (if (nonzero? (-> self path i))
            (&+! (-> self path i) offset)
            )
        )
      (the-as snow-ball ((the-as (function process-drawable int process-drawable) (find-parent-method snow-ball 7))
                        (the-as process-drawable self)
                        offset
                        )
              )
      )
    (init-from-entity! ((entity entity-actor)) (none)
      (set! (-> self last-path-picked) 1)
      (set! (-> self same-path-picked-count) 1)
      (dotimes (i 2)
        (set! (-> self path i) (new 'process 'curve-control self 'path (the float (+ i 1))))
        )
      (logclear! (-> self mask) (process-mask actor-pause))
      (go snow-ball-idle)
      (none)
      )
   )
  (:states
    (snow-ball-idle
      :code (behavior ()
        (local-vars (selected-path int))
        (set! (-> self state-time) (-> *display* base-frame-counter))
        (set! (-> self delay-til-next) 0)
        (label unused)
        (when (>= (- (-> *display* base-frame-counter) (-> self state-time)) (-> self delay-til-next))
          (set! selected-path (cond
                      ((>= (-> self same-path-picked-count) 2)
                        (if (zero? (-> self last-path-picked))
                            (set! selected-path 1)
                            (set! selected-path 0)
                            )
                        selected-path
                        )
                      (else
                        (rand-vu-int-range 0 1)
                        )
                      )
                )
          (let ((attempts 0)
                (junctions (new 'stack-no-clear 'inline-array 'snow-ball-junction 4))
                )
            (loop
              (let ((speed (/ (+ 98304.0 (rand-vu-float-range 0.0 32768.0)) (path-distance (-> self path selected-path)))))
                (set-junction-times! self junctions speed selected-path)
                (when (path-clear? self junctions selected-path)
                  (process-spawn snow-ball-roller (-> self entity) self speed selected-path junctions :to self)
                  (set! (-> self state-time) (-> *display* base-frame-counter))
                  (set! (-> self delay-til-next) (rand-vu-int-range 450 1650))
                  (cond
                    ((= selected-path (-> self last-path-picked))
                    (+! (-> self same-path-picked-count) 1)
                    )
                    (else
                      (set! (-> self last-path-picked) selected-path)
                      (set! (-> self same-path-picked-count) 1)
                      )
                    )
                  (goto end)
                  )
                )
              (+! attempts 1)
              (if (< 5 attempts)
                  (goto end)
                  )
              )
            )
          )
        (label end)
        (suspend)
        (b! #t unused :delay (nop!))
        (none)
       )
     ) 
   )
  (:options
    :heap-base #x20
    :method-count-assert 16
    :size-assert         #x8c
    :flag-assert         #x100020008c
   )
  )
