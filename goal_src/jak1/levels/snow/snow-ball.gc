;;-*-Lisp-*-
(in-package goal)

;; name: snow-ball.gc
;; name in dgo: snow-ball
;; dgos: L1, SNO

;; DECOMP BEGINS

(deftype snow-ball-shadow (process-drawable)
  ()
  (:states
    snow-ball-shadow-idle
    )
  )


(deftype snow-ball-junction (structure)
  ((enter-time  time-frame)
   (exit-time   time-frame)
   )
  )


(deftype snow-ball-path-info (structure)
  ((hug-path?  symbol)
   (path-pos   vector  :inline)
   )
  )


(deftype snow-ball-roller (process-drawable)
  ((root                    collide-shape-moving :override)
   (which-path              int32)
   (path-u                  float)
   (path-speed              float)
   (path-length             float)
   (path-fall-u             float)
   (path-coming-out-u       float)
   (path-faded-up-u         float)
   (delay-til-bounce        int32)
   (rolling-sound-id        sound-id)
   (rolling-sound-enabled?  symbol)
   (last-bounce-time        time-frame)
   (hit-player-time         time-frame)
   (path-info               snow-ball-path-info   :inline)
   (junctions               snow-ball-junction    4 :inline)
   )
  (:methods
    (follow-path (_type_) none)
    (play-landing-sound (_type_ float) sound-id)
    (snow-ball-roller-method-22 (_type_ process-drawable) none)
    )
  (:states
    snow-ball-roller-idle
    )
  )


(deftype snow-ball (process)
  ((child-override          (pointer snow-ball-roller)  :overlay-at child)
   (state-time              time-frame)
   (last-path-picked        int32)
   (same-path-picked-count  int32)
   (delay-til-next          int32)
   (path                    curve-control               2)
   )
  (:methods
    (snow-ball-method-14 (_type_ (inline-array snow-ball-junction) float int) symbol)
    (snow-ball-method-15 (_type_ (inline-array snow-ball-junction) int) symbol)
    )
  (:states
    snow-ball-idle
    )
  )


(defskelgroup *snow-ball-sg* snow-ball snow-ball-lod0-jg snow-ball-idle-ja
              ((snow-ball-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(defskelgroup *snow-ball-shadow-sg* snow-ball snow-ball-shadow-lod0-jg -1
              ((snow-ball-shadow-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -1.5 0 2)
              :shadow snow-ball-shadow-shadow-mg
              )

(define *snow-ball-shadow-control*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :flags (shadow-flags disable-fade shdf03)
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 245760.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 26624.0)
                                           :top-plane (new 'static 'plane :y 1.0)
                                           :fade-dist 819200.0
                                           )
                               )
  )

(defstate snow-ball-shadow-idle (snow-ball-shadow)
  :trans (behavior ()
    (set! (-> self root trans quad) (-> (the-as process-drawable (-> self parent 0)) root trans quad))
    (update-direction-from-time-of-day (-> self draw shadow-ctrl))
    0
    )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
      )
    )
  :post ja-post
  )

(defbehavior snow-ball-shadow-init-by-other snow-ball-shadow ()
  (stack-size-set! (-> self main-thread) 128)
  (logclear! (-> self mask) (process-mask actor-pause movie enemy platform projectile))
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> (the-as process-drawable (-> self parent 0)) root trans quad))
  (quaternion-identity! (-> self root quat))
  (vector-identity! (-> self root scale))
  (initialize-skeleton self *snow-ball-shadow-sg* '())
  (ja-channel-set! 1)
  (ja :group! snow-ball-shadow-idle-ja :num! min)
  (set! (-> self draw shadow-ctrl) *snow-ball-shadow-control*)
  (go snow-ball-shadow-idle)
  (none)
  )

(defbehavior snow-ball-roller-path-init snow-ball-roller ()
  (set! (-> self path-u) 0.0)
  (set! (-> self path-length) (path-distance (-> self path)))
  (none)
  )

(defmethod follow-path ((this snow-ball-roller))
  (let ((s5-0 (-> this path-info)))
    (set! (-> s5-0 hug-path?) #f)
    (let ((s4-0 (new 'stack-no-clear 'vector)))
      (set! (-> s4-0 quad) (-> s5-0 path-pos quad))
      (eval-path-curve! (-> this path) (-> s5-0 path-pos) (-> this path-u) 'interp)
      (let ((f0-1 (-> this path-coming-out-u)))
        (when (< (-> this path-u) f0-1)
          (+! (-> s5-0 path-pos y) (- -20480.0 (* -20480.0 (/ (-> this path-u) f0-1))))
          (set! (-> s5-0 hug-path?) #t)
          )
        )
      (let ((f0-6 (-> this path-faded-up-u)))
        (cond
          ((< (-> this path-u) f0-6)
           (let* ((f0-7 (/ (-> this path-u) f0-6))
                  (f0-8 (* f0-7 f0-7))
                  )
             (set-vector! (-> this draw color-mult) f0-8 f0-8 f0-8 1.0)
             )
           )
          (else
            (vector-identity! (-> this draw color-mult))
            )
          )
        )
      (cond
        ((>= (-> this path-u) (-> this path-fall-u))
         (set! (-> s5-0 path-pos y) -409600.0)
         (set! (-> s5-0 path-pos x) (+ (-> s4-0 x) (-> this root transv x)))
         (set! (-> s5-0 path-pos z) (+ (-> s4-0 z) (-> this root transv z)))
         (set! (-> this rolling-sound-enabled?) #f)
         )
        (else
          (set! (-> this root transv x) (- (-> s5-0 path-pos x) (-> s4-0 x)))
          (set! (-> this root transv z) (- (-> s5-0 path-pos z) (-> s4-0 z)))
          )
        )
      )
    )
  (none)
  )

(defmethod play-landing-sound ((this snow-ball-roller) (arg0 float))
  (let ((f30-0 (* 0.0018780049 (fmin 53248.0 (fmax 0.0 (+ -4096.0 (fabs arg0)))))))
    (sound-play "snowball-land" :vol f30-0)
    )
  )

(defbehavior snow-ball-roller-path-update snow-ball-roller ()
  (local-vars (f0-5 float))
  (let ((f0-0 (-> self root trans y)))
    (+! (-> self root transv y) (* -491520.0 (seconds-per-frame)))
    (let ((f30-0 (+ f0-0 (* (-> self root transv y) (seconds-per-frame)))))
      (follow-path self)
      (let ((a1-0 (new 'stack-no-clear 'vector)))
        (let ((a0-1 (-> self path-info)))
          (set! (-> a1-0 quad) (-> a0-1 path-pos quad))
          )
        (+! (-> a1-0 y) 9216.0)
        (cond
          ((-> self path-info hug-path?)
           (move-to-point! (-> self root) a1-0)
           (set! (-> self root transv y) 0.0)
           )
          ((begin (set! f0-5 (- f30-0 (-> a1-0 y))) (< 0.0 f0-5))
           (+! (-> a1-0 y) f0-5)
           (move-to-point! (-> self root) a1-0)
           )
          (else
            (move-to-point! (-> self root) a1-0)
            (let ((f0-7 (-> self root transv y)))
              (cond
                ((>= -40960.0 f0-7)
                 (set! (-> self root transv y) (* 0.4 (- f0-7)))
                 (play-landing-sound self (-> self root transv y))
                 )
                (else
                  (set! (-> self root transv y) 0.0)
                  )
                )
              )
            (when (< (-> self path-u) (-> self path-fall-u))
              (when (time-elapsed? (-> self last-bounce-time) (-> self delay-til-bounce))
                (let ((f0-13 (rand-vu-float-range 8192.0 20480.0)))
                  (+! (-> self root transv y) f0-13)
                  (play-landing-sound self f0-13)
                  )
                (set-time! (-> self last-bounce-time))
                (set! (-> self delay-til-bounce) (rand-vu-int-range 300 2100))
                )
              )
            )
          )
        )
      )
    )
  (let ((s4-0 (new 'stack-no-clear 'vector)))
    (path-control-method-14 (-> self path) s4-0 (-> self path-u))
    (let ((gp-0 (new 'stack-no-clear 'matrix)))
      (let ((s5-0 (new 'stack-no-clear 'matrix)))
        (let ((s3-0 (new 'stack-no-clear 'vector)))
          (vector-negate! s3-0 (-> *standard-dynamics* gravity-normal))
          (forward-down->inv-matrix gp-0 s4-0 s3-0)
          )
        (matrix-rotate-x! s5-0 (* 1.1317686 (-> self path-u) (-> self path-length)))
        (matrix*! gp-0 s5-0 gp-0)
        )
      (matrix->quaternion (-> self root quat) gp-0)
      )
    )
  (+! (-> self path-u) (* (-> self path-speed) (seconds-per-frame)))
  (if (< 1.0 (-> self path-u))
      (set! (-> self path-u) 1.0)
      )
  (let ((f0-23 (- 819200.0 (-> self root trans y))))
    (when (>= f0-23 0.0)
      (cond
        ((>= f0-23 245760.0)
         (deactivate self)
         )
        (else
          (let ((f0-25 (- 1.0 (* 0.0000040690106 f0-23))))
            (set! (-> self root scale x) f0-25)
            (set! (-> self root scale y) f0-25)
            (set! (-> self root scale z) f0-25)
            )
          )
        )
      )
    )
  (let ((v1-54 (< (vector-vector-distance (-> self root trans) (math-camera-pos)) 163840.0)))
    (cond
      ((zero? (-> self rolling-sound-id))
       (if (and v1-54 (-> self rolling-sound-enabled?))
           (set! (-> self rolling-sound-id) (sound-play "snowball-roll" :position (the-as symbol (-> self root trans))))
           )
       )
      ((and v1-54 (-> self rolling-sound-enabled?))
       (sound-play "snowball-roll" :id (-> self rolling-sound-id) :position (the-as symbol (-> self root trans)))
       )
      (else
        (sound-stop (-> self rolling-sound-id))
        (set! (-> self rolling-sound-id) (new 'static 'sound-id))
        0
        )
      )
    )
  (none)
  )

(defmethod snow-ball-roller-method-22 ((this snow-ball-roller) (arg0 process-drawable))
  (cond
    ((< (+ 4096.0 (-> arg0 root trans y)) (-> this root trans y))
     (let ((f0-2 81920.0))
       (+! (-> this root transv y) f0-2)
       (play-landing-sound this f0-2)
       )
     )
    (else
      (let ((f0-3 24576.0))
        (+! (-> this root transv y) f0-3)
        (play-landing-sound this f0-3)
        )
      )
    )
  (let ((s4-0 (new 'stack-no-clear 'vector)))
    (let ((s3-0 (new 'stack-no-clear 'vector)))
      (vector-! s4-0 (-> arg0 root trans) (-> this root trans))
      (set! (-> s4-0 y) 0.0)
      (vector-normalize! s4-0 1.0)
      (path-control-method-14 (-> this path) s3-0 (-> this path-u))
      (set! (-> s3-0 y) 0.0)
      (vector-normalize! s3-0 1.0)
      (let* ((f28-0 (atan (-> s4-0 x) (-> s4-0 z)))
             (f30-0 (atan (-> s3-0 x) (-> s3-0 z)))
             (f0-11 (deg- f28-0 f30-0))
             )
        (when (< (fabs f0-11) 10922.667)
          (let ((f30-1 (+ f30-0 (if (>= f0-11 0.0)
                                    10922.667
                                    -10922.667
                                    )
                          )
                       )
                )
            (set-vector! s4-0 (sin f30-1) 0.0 (cos f30-1) 1.0)
            )
          )
        )
      )
    (vector-normalize! s4-0 25600.0)
    (vector+! s4-0 s4-0 (-> this root trans))
    (vector-! s4-0 s4-0 (-> arg0 root trans))
    (set! (-> s4-0 y) 0.0)
    (let ((f30-2 (vector-length s4-0)))
      (vector-normalize! s4-0 1.0)
      (send-event arg0 'attack #f (static-attack-info ((vector s4-0) (shove-up (meters 3)) (shove-back f30-2))))
      )
    )
  (none)
  )

(defstate snow-ball-roller-idle (snow-ball-roller)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch 'attack)
       (when (= (-> proc type) target)
         (do-push-aways! (-> self root))
         (when (time-elapsed? (-> self hit-player-time) (seconds 0.5))
           (set-time! (-> self hit-player-time))
           (snow-ball-roller-method-22 self *target*)
           )
         )
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self last-bounce-time))
    (snow-ball-roller-path-init)
    )
  :exit (behavior ()
    (set! (-> self rolling-sound-enabled?) #f)
    (when (nonzero? (-> self rolling-sound-id))
      (sound-stop (-> self rolling-sound-id))
      (set! (-> self rolling-sound-id) (new 'static 'sound-id))
      0
      )
    )
  :trans (behavior ()
    (snow-ball-roller-path-update)
    )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
      )
    )
  :post transform-post
  )

(defbehavior snow-ball-roller-init-by-other snow-ball-roller ((arg0 entity-actor) (arg1 snow-ball) (arg2 float) (arg3 int) (arg4 (inline-array snow-ball-junction)))
  (set! (-> self rolling-sound-id) (new 'static 'sound-id))
  (set! (-> self rolling-sound-enabled?) #t)
  (set! (-> self path-speed) arg2)
  (set! (-> self which-path) arg3)
  (set! (-> self hit-player-time) 0)
  (set! (-> self entity) arg0)
  (dotimes (s3-0 4)
    (mem-copy! (the-as pointer (-> self junctions s3-0)) (the-as pointer (-> arg4 s3-0)) 16)
    )
  (let ((s4-1 (new 'process 'collide-shape-moving self (collide-list-enum hit-by-player))))
    (set! (-> s4-1 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-1 reaction) default-collision-reaction)
    (set! (-> s4-1 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((s3-1 (new 'process 'collide-shape-prim-sphere s4-1 (the-as uint 0))))
      (set! (-> s3-1 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-1 collide-with) (collide-kind target))
      (set! (-> s3-1 prim-core action) (collide-action solid))
      (set! (-> s3-1 prim-core offense) (collide-offense indestructible))
      (set-vector! (-> s3-1 local-sphere) 0.0 0.0 0.0 10240.0)
      (set-root-prim! s4-1 s3-1)
      )
    (set! (-> s4-1 nav-radius) (* 0.75 (-> s4-1 root-prim local-sphere w)))
    (backup-collide-with-as s4-1)
    (set! (-> self root) s4-1)
    )
  (set-vector! (-> self root transv) 0.0 0.0 0.0 1.0)
  (process-drawable-from-entity! self arg0)
  (initialize-skeleton self *snow-ball-sg* '())
  (logclear! (-> self mask) (process-mask actor-pause))
  (set! (-> self path) (new 'process 'curve-control self 'path (the float (+ arg3 1))))
  (logior! (-> self path flags) (path-control-flag display draw-line draw-point draw-text))
  (let ((v1-33 (-> self which-path)))
    (cond
      ((zero? v1-33)
       (set! (-> self path-fall-u) 0.8667)
       (set! (-> self path-coming-out-u) 0.05)
       (set! (-> self path-faded-up-u) 0.075)
       )
      ((= v1-33 1)
       (set! (-> self path-fall-u) 0.9105)
       (set! (-> self path-coming-out-u) 0.05)
       (set! (-> self path-faded-up-u) 0.075)
       )
      )
    )
  (set! (-> self delay-til-bounce) (rand-vu-int-range 900 2100))
  (process-spawn snow-ball-shadow :to self)
  (go snow-ball-roller-idle)
  (none)
  )

(defmethod snow-ball-method-14 ((this snow-ball) (arg0 (inline-array snow-ball-junction)) (arg1 float) (arg2 int))
  (local-vars (v1-0 (pointer float)))
  (if (zero? arg2)
      (set! v1-0 (new 'static 'array float 8 0.3309 0.36 0.4691 0.5061 0.6904 0.7264 0.864 0.8667))
      (set! v1-0 (new 'static 'array float 8 0.3344 0.3528 0.4919 0.5246 0.6967 0.7272 0.8677 0.9105))
      )
  (let ((a0-4 (* arg1 (seconds-per-frame)))
        (a1-1 (-> arg0 0))
        (a2-2 (current-time))
        )
    (dotimes (a3-1 4)
      (set! (-> a1-1 enter-time) (+ a2-2 (the int (/ (-> v1-0 0) a0-4))))
      (set! (-> a1-1 exit-time) (+ a2-2 (the int (/ (-> v1-0 1) a0-4))))
      (set! v1-0 (&-> v1-0 2))
      (&+! a1-1 16)
      )
    )
  #f
  )

(defmethod snow-ball-method-15 ((this snow-ball) (arg0 (inline-array snow-ball-junction)) (arg1 int))
  (local-vars (v0-0 symbol))
  (let ((v1-0 (-> this child-override)))
    (while v1-0
      (let ((a0-1 (-> arg0 0))
            (a3-1 (-> v1-0 0 junctions))
            )
        (dotimes (t0-0 3)
          (if (and (>= (-> a3-1 0 exit-time) (-> a0-1 enter-time)) (>= (-> a0-1 exit-time) (-> a3-1 0 enter-time)))
              (return #f)
              )
          (&+! a0-1 16)
          (set! a3-1 (the-as (inline-array snow-ball-junction) (-> a3-1 1)))
          )
        (when (= arg1 (-> v1-0 0 which-path))
          (if (>= (-> a3-1 0 exit-time) (-> a0-1 enter-time))
              (return #f)
              )
          )
        )
      (set! v1-0 (the-as (pointer snow-ball-roller) (-> v1-0 0 brother)))
      )
    )
  (return #t)
  v0-0
  )

(defstate snow-ball-idle (snow-ball)
  :code (behavior ()
    (local-vars (gp-0 int))
    (set-time! (-> self state-time))
    (set! (-> self delay-til-next) 0)
    (label cfg-1)
    (when (time-elapsed? (-> self state-time) (-> self delay-til-next))
      (set! gp-0 (cond
                   ((>= (-> self same-path-picked-count) 2)
                    (if (zero? (-> self last-path-picked))
                        (set! gp-0 1)
                        (set! gp-0 0)
                        )
                    gp-0
                    )
                   (else
                     (rand-vu-int-range 0 1)
                     )
                   )
            )
      (let ((s4-0 0)
            (s5-0 (new 'stack-no-clear 'inline-array 'snow-ball-junction 4))
            )
        (loop
          (let ((s3-0 (/ (+ 98304.0 (rand-vu-float-range 0.0 32768.0)) (path-distance (-> self path gp-0)))))
            (snow-ball-method-14 self s5-0 s3-0 gp-0)
            (when (snow-ball-method-15 self s5-0 gp-0)
              (process-spawn snow-ball-roller (-> self entity) self s3-0 gp-0 s5-0 :to self)
              (set-time! (-> self state-time))
              (set! (-> self delay-til-next) (rand-vu-int-range 450 1650))
              (cond
                ((= gp-0 (-> self last-path-picked))
                 (+! (-> self same-path-picked-count) 1)
                 )
                (else
                  (set! (-> self last-path-picked) gp-0)
                  (set! (-> self same-path-picked-count) 1)
                  )
                )
              (goto cfg-22)
              )
            )
          (+! s4-0 1)
          (if (< 5 s4-0)
              (goto cfg-22)
              )
          )
        )
      )
    (label cfg-22)
    (suspend)
    (b! #t cfg-1 :delay (nop!))
    )
  )

(defmethod relocate ((this snow-ball) (arg0 int))
  (dotimes (v1-0 2)
    (if (nonzero? (-> this path v1-0))
        (&+! (-> this path v1-0) arg0)
        )
    )
  (call-parent-method this arg0)
  )

(defmethod init-from-entity! ((this snow-ball) (arg0 entity-actor))
  (set! (-> this last-path-picked) 1)
  (set! (-> this same-path-picked-count) 1)
  (dotimes (s5-0 2)
    (set! (-> this path s5-0) (new 'process 'curve-control this 'path (the float (+ s5-0 1))))
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (go snow-ball-idle)
  (none)
  )
