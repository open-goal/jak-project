;;-*-Lisp-*-
(in-package goal)
(bundles "BEA.DGO")
(require "engine/math/matrix.gc")
(require "engine/math/vector.gc")
(require "engine/game/game-h.gc")

;; DECOMP BEGINS

(deftype twist-joint (structure)
  ((ry      float)
   (max-dry float))
  :allow-misaligned)

(deftype twister (basic)
  ((num-joints   int32)
   (first-joint  int32)
   (last-joint   int32)
   (something    uint16 :overlay-at last-joint)
   (max-speed    float)
   (smoothing    float)
   (min-dist     float)
   (target       float)
   (ry           float)
   (max-speed-ry float)
   (data         twist-joint :inline :dynamic))
  (:methods
   (new (symbol type int int float float float float) _type_)
   (twister-method-9 (_type_ int int float) none)
   (set-target! (_type_ float) none)
   (twister-method-11 (_type_) none)
   (twister-method-12 (_type_ process-drawable) none)))

(defmethod new twister ((allocation symbol) (type-to-make type) (arg0 int) (arg1 int) (arg2 float) (arg3 float) (arg4 float) (arg5 float))
  (let* ((gp-0 (+ (- 1 arg0) arg1))
         (v0-0 (object-new allocation type-to-make (the-as int (+ (-> type-to-make size) (* gp-0 16))))))
    (set! (-> v0-0 first-joint) arg0)
    (set! (-> v0-0 last-joint) arg1)
    (set! (-> v0-0 num-joints) gp-0)
    (set! (-> v0-0 max-speed) arg2)
    (set! (-> v0-0 smoothing) arg4)
    (set! (-> v0-0 min-dist) arg5)
    (set! (-> v0-0 target) 0.0)
    (set! (-> v0-0 ry) 0.0)
    (set! (-> v0-0 max-speed-ry) arg3)
    (dotimes (v1-4 gp-0)
      (set! (-> v0-0 data v1-4 ry) 0.0)
      (set! (-> v0-0 data v1-4 max-dry) 0.0))
    v0-0))

(defmethod asize-of ((this twister))
  (+ (* (-> this num-joints) 16) 40))

(defmethod twister-method-9 ((this twister) (arg0 int) (arg1 int) (arg2 float))
  (let ((v1-1 (- arg0 (-> this first-joint)))
        (a1-2 (- arg1 (-> this first-joint))))
    (while (>= a1-2 v1-1)
      (set! (-> this data v1-1 max-dry) arg2)
      (+! v1-1 1)))
  0
  (none))

(defmethod set-target! ((this twister) (arg0 float))
  (set! (-> this target) arg0)
  0
  (none))

(defmethod twister-method-11 ((this twister))
  (let* ((s5-0 (+ (-> this num-joints) -1))
         (s4-0 (-> this data s5-0)))
    (let ((f0-2 (deg-diff (-> s4-0 ry) (-> this target))))
      (+! (-> s4-0 ry) (seek-with-smooth 0.0 f0-2 (-> this max-speed) (-> this smoothing) (-> this min-dist))))
    (let ((f30-1 (-> s4-0 ry)))
      (while (> s5-0 0)
        (+! s5-0 -1)
        (let ((s4-1 (-> this data s5-0)))
          (let ((f0-9 (deg-diff f30-1 (-> s4-1 ry))))
            (cond
              ((= (-> s4-1 max-dry) 0.0) (set! f0-9 0.0))
              ((< (fabs f0-9) (-> s4-1 max-dry)))
              ((< f0-9 0.0)
               (set! f0-9 (seek-with-smooth f0-9 (- (-> s4-1 max-dry)) (-> this max-speed) (-> this smoothing) (-> this min-dist))))
              (else (set! f0-9 (seek-with-smooth f0-9 (-> s4-1 max-dry) (-> this max-speed) (-> this smoothing) (-> this min-dist)))))
            (+! f30-1 f0-9))
          (set! (-> s4-1 ry) f30-1)))))
  0
  (none))

(defmethod twister-method-12 ((this twister) (arg0 process-drawable))
  (let ((s4-0 (new 'stack-no-clear 'matrix)))
    (dotimes (s3-0 (-> this num-joints))
      (let ((s2-0 (-> arg0 node-list data (+ (-> this first-joint) s3-0) bone transform)))
        (matrix-rotate-y! s4-0 (-> this data s3-0 ry))
        (vector-! (-> s2-0 vector 3) (-> s2-0 vector 3) (-> arg0 root trans))
        (matrix*! s2-0 s2-0 s4-0)
        (vector+! (-> s2-0 vector 3) (-> s2-0 vector 3) (-> arg0 root trans)))))
  0
  (none))
