;;-*-Lisp-*-
(in-package goal)

;; name: swamp-bat.gc
;; name in dgo: swamp-bat
;; dgos: L1, SWA

(declare-type swamp-bat-slave process-drawable)
(declare-type swamp-bat process-drawable)

;; DECOMP BEGINS

(deftype swamp-bat-idle-path (structure)
  ((origin  vector  :inline)
   (x-axis  vector  :inline)
   (y-axis  vector  :inline)
   )
  (:methods
    (swamp-bat-idle-path-method-9 (_type_ vector float) vector)
    )
  )


(defmethod swamp-bat-idle-path-method-9 ((this swamp-bat-idle-path) (arg0 vector) (arg1 float))
  (let ((f30-0 (* 65536.0 arg1)))
    (set! (-> arg0 quad) (-> this origin quad))
    (vector+*! arg0 arg0 (-> this x-axis) (cos f30-0))
    (vector+*! arg0 arg0 (-> this y-axis) (sin f30-0))
    )
  arg0
  )

(deftype swamp-bat (process-drawable)
  ((root                 collide-shape             :override)
   (fact                 fact-info-enemy           :override)
   (child-process        (pointer swamp-bat-slave)  :overlay-at child)
   (path-origin          vector                     :inline)
   (idle-position-angle  float                      8)
   (path-select-plane    plane                      2 :inline)
   (path-list            curve-control              2)
   (path-select          int8)
   (slave-count          int8)
   (path-count           int8)
   )
  (:states
    swamp-bat-idle
    swamp-bat-launch-slaves
    )
  )


(defmethod relocate ((this swamp-bat) (arg0 int))
  (dotimes (v1-0 2)
    (if (nonzero? (-> this path-list v1-0))
        (&+! (-> this path-list v1-0) arg0)
        )
    )
  (call-parent-method this arg0)
  )

(deftype swamp-bat-slave (process-drawable)
  ((root                 collide-shape-moving :override)
   (parent-process       (pointer swamp-bat)   :overlay-at parent)
   (sync                 sync-info             :inline)
   (idle-anim-speed      float)
   (strafe-envelope      float)
   (strafe-distance      float)
   (path-point-count     float)
   (idle-path            swamp-bat-idle-path   :inline)
   (idle-position        vector                :inline)
   (idle-position-index  int8)
   (path-select          int8)
   (launch-ready         symbol)
   )
  (:methods
    (swamp-bat-slave-method-20 (_type_) float)
    )
  (:states
    (swamp-bat-slave-die handle)
    swamp-bat-slave-idle
    swamp-bat-slave-launch
    swamp-bat-slave-return
    swamp-bat-slave-strafe
    swamp-bat-slave-swoop
    )
  )


(defbehavior swamp-bat-slave-event-handler swamp-bat-slave ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('attack)
     (logclear! (-> self mask) (process-mask actor-pause))
     (go swamp-bat-slave-die (process->handle arg0))
     )
    (('touch)
     (level-hint-spawn (text-id swamp-bat-duck-hint) "sksp0156" (the-as entity #f) *entity-pool* (game-task none))
     (send-event arg0 'attack (-> arg3 param 0) (new 'static 'attack-info))
     )
    (('launch)
     (if (-> self launch-ready)
         (go swamp-bat-slave-launch)
         )
     )
    )
  )

swamp-bat-slave-event-handler

(defbehavior swamp-bat-slave-post swamp-bat-slave ()
  (transform-post)
  )

(defmethod swamp-bat-slave-method-20 ((this swamp-bat-slave))
  (* (get-current-phase (-> this sync)) (-> this path-point-count))
  )

(defbehavior swamp-bat-slave-path-post swamp-bat-slave ()
  (let ((s2-0 (-> self parent-process 0 path-list (-> self path-select)))
        (s5-0 (new-stack-vector0))
        (gp-0 (new-stack-vector0))
        (s4-0 (new-stack-vector0))
        (f30-0 (swamp-bat-slave-method-20 self))
        (s3-0 (new 'static 'vector :y 1.0 :w 1.0))
        )
    (eval-path-curve-div! s2-0 s5-0 f30-0 'interp)
    (path-control-method-12 s2-0 gp-0 f30-0)
    (vector-cross! s4-0 gp-0 s3-0)
    (vector-normalize! s4-0 1.0)
    (let ((f0-4 (fmax
                  (fmin (- (vector-dot (target-pos 0) s4-0) (vector-dot s5-0 s4-0)) (-> self strafe-envelope))
                  (- (-> self strafe-envelope))
                  )
                )
          )
      (seek! (-> self strafe-distance) f0-4 (* 20480.0 (seconds-per-frame)))
      )
    (vector-float*! s4-0 s4-0 (-> self strafe-distance))
    (vector+! (-> self root trans) s5-0 s4-0)
    (forward-up->quaternion (-> self root quat) gp-0 s3-0)
    )
  (swamp-bat-slave-post)
  )

(defskelgroup *swamp-bat-slave-sg* swamp-bat swamp-bat-lod0-jg swamp-bat-idle-ja
              ((swamp-bat-lod0-mg (meters 20)) (swamp-bat-lod1-mg (meters 40)) (swamp-bat-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 2.5)
              )

(defbehavior swamp-bat-slave-get-new-path swamp-bat-slave ()
  (set! (-> self path-select) (-> self parent-process 0 path-select))
  (set! (-> self idle-path origin quad) (-> self parent-process 0 path-origin quad))
  (let* ((f28-0 (-> self parent-process 0 idle-position-angle (-> self idle-position-index)))
         (f30-0 (cos f28-0))
         (f26-0 (sin f28-0))
         (f28-1 (cos 8192.0))
         )
    (let ((f0-0 (sin 8192.0)))
      (set! (-> self idle-path x-axis x) (* 12288.0 f30-0))
      (set! (-> self idle-path x-axis y) 0.0)
      (set! (-> self idle-path x-axis z) (* 12288.0 f26-0))
      (set! (-> self idle-path x-axis w) 1.0)
      (set! (-> self idle-path y-axis x) (* -12288.0 f26-0 f28-1))
      (set! (-> self idle-path y-axis y) (* 12288.0 f0-0))
      )
    (set! (-> self idle-path y-axis z) (* 12288.0 f30-0 f28-1))
    )
  (set! (-> self idle-path y-axis w) 1.0)
  (vector+! (-> self idle-position) (the-as vector (-> self idle-path)) (-> self idle-path x-axis))
  (set! (-> self path-point-count)
        (the float (+ (-> self parent-process 0 path-list (-> self path-select) curve num-cverts) -1))
        )
  )

(defstate swamp-bat-slave-idle (swamp-bat-slave)
  :event swamp-bat-slave-event-handler
  :code (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self launch-ready) #f)
    (ja-channel-push! 1 (seconds 0.165))
    (ja :group! swamp-bat-idle-ja)
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (set! (-> s5-0 quad) (-> self root trans quad))
      (let ((s4-0 (quaternion-copy! (new 'stack-no-clear 'quaternion) (-> self root quat)))
            (gp-0 (new-stack-quaternion0))
            )
        (let ((s2-0 (path-control-method-12
                      (-> self parent-process 0 path-list (-> self path-select))
                      (new 'stack-no-clear 'vector)
                      0.1
                      )
                    )
              )
          0
          (let* ((f0-0 300.0)
                 (f1-0 32768.0)
                 (s3-0 (the int (* f0-0 (/ 1.0 f1-0) (vector-vector-distance s5-0 (-> self idle-position)))))
                 )
            (forward-up->quaternion gp-0 s2-0 (new 'static 'vector :y 1.0 :w 1.0))
            (loop
              (let ((v1-17 (- (current-time) (-> self state-time))))
                (when (>= v1-17 s3-0)
                  0
                  (goto cfg-10)
                  )
                (let ((f30-1 (/ (the float v1-17) (the float s3-0))))
                  (when *run-time-assert-enable*
                    (set-pos *__private-assert-info* "swamp-bat" (the-as uint 283) (the-as uint 20))
                    (__assert (< f30-1 1.0) "(< interp 1.0)")
                    )
                  (vector-lerp! (-> self root trans) s5-0 (-> self idle-position) f30-1)
                  (quaternion-slerp! (-> self root quat) s4-0 gp-0 f30-1)
                  )
                )
              (ja :num! (loop! (-> self idle-anim-speed)))
              (suspend)
              0
              )
            )
          )
        (label cfg-10)
        (set! (-> self root trans quad) (-> self idle-position quad))
        (quaternion-copy! (-> self root quat) gp-0)
        )
      )
    (set! (-> self launch-ready) #t)
    (logior! (-> self mask) (process-mask actor-pause))
    (let ((f30-2 0.0))
      (loop
        (let ((f26-0 (cos f30-2))
              (f28-0 (sin f30-2))
              )
          (set! (-> self root trans quad) (-> self idle-path origin quad))
          (vector+*! (-> self root trans) (-> self root trans) (-> self idle-path x-axis) f26-0)
          (vector+*! (-> self root trans) (-> self root trans) (-> self idle-path y-axis) f28-0)
          )
        (ja :num! (loop! (-> self idle-anim-speed)))
        (suspend)
        (+! f30-2 (* 32768.0 (seconds-per-frame) (-> self idle-anim-speed)))
        )
      )
    )
  :post swamp-bat-slave-post
  )

(defstate swamp-bat-slave-launch (swamp-bat-slave)
  :event swamp-bat-slave-event-handler
  :code (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self launch-ready) #f)
    (ja-channel-push! 1 (seconds 0.1))
    (let ((gp-0 (new-stack-vector0)))
      (set! (-> gp-0 quad) (-> self root trans quad))
      (let ((s5-0 (new-stack-vector0)))
        (eval-path-curve-div! (-> self parent-process 0 path-list (-> self path-select)) s5-0 0.0 'interp)
        (ja :group! swamp-bat-idle-ja)
        (loop
          (let ((s4-0 (- (current-time) (-> self state-time))))
            (if (>= s4-0 (seconds 0.3))
                (go swamp-bat-slave-swoop)
                )
            (let ((f0-1 (* 0.011111111 (the float s4-0))))
              (vector-lerp! (-> self root trans) gp-0 s5-0 f0-1)
              )
            )
          (ja :num! (loop! (-> self idle-anim-speed)))
          (suspend)
          0
          )
        )
      )
    )
  :post swamp-bat-slave-post
  )

(defstate swamp-bat-slave-swoop (swamp-bat-slave)
  :event swamp-bat-slave-event-handler
  :code (behavior ()
    (set! (-> self strafe-envelope) 0.0)
    (ja-channel-push! 1 (seconds 0.1))
    (ja :group! swamp-bat-notice-ja :num! min)
    (until (ja-done? 0)
      (if (< (ja-aframe-num 0) 10.0)
          (sync-now! (-> self sync) 0.0)
          )
      (suspend)
      (ja :num! (seek!))
      )
    (set! (-> self strafe-envelope) 20480.0)
    (ja-channel-push! 1 (seconds 0.1))
    (ja :group! swamp-bat-swoop-ja)
    (loop
      (if (>= (swamp-bat-slave-method-20 self) 2.0)
          (go swamp-bat-slave-strafe)
          )
      (ja :num! (loop!))
      (suspend)
      )
    )
  :post swamp-bat-slave-path-post
  )

(defstate swamp-bat-slave-strafe (swamp-bat-slave)
  :event swamp-bat-slave-event-handler
  :code (behavior ()
    (set! (-> self strafe-envelope) 20480.0)
    (ja-channel-push! 1 (seconds 0.1))
    (ja :group! swamp-bat-strafe-ja)
    (loop
      (if (>= (swamp-bat-slave-method-20 self) 6.0)
          (go swamp-bat-slave-return)
          )
      (ja :num! (loop!))
      (suspend)
      )
    )
  :post swamp-bat-slave-path-post
  )

(defstate swamp-bat-slave-return (swamp-bat-slave)
  :event swamp-bat-slave-event-handler
  :code (behavior ()
    (set! (-> self strafe-envelope) 0.0)
    (ja-channel-push! 1 (seconds 0.075))
    (ja :group! swamp-bat-strafe-ja)
    (let ((f30-0 (+ -1.0 (-> self path-point-count)))
          (gp-0 #t)
          )
      (loop
        (let ((f28-0 (swamp-bat-slave-method-20 self)))
          (if (>= f28-0 f30-0)
              (go swamp-bat-slave-idle)
              )
          (when (and gp-0 (>= f28-0 7.0) (< f28-0 8.0))
            (set! gp-0 #f)
            (when (!= (-> self path-select) (-> self parent-process 0 path-select))
              (swamp-bat-slave-get-new-path)
              (go swamp-bat-slave-idle)
              )
            )
          )
        (ja :num! (loop!))
        (suspend)
        )
      )
    )
  :post swamp-bat-slave-path-post
  )

(defstate swamp-bat-slave-die (swamp-bat-slave)
  :event process-drawable-death-event-handler
  :code (behavior ((arg0 handle))
    (ja-channel-push! 1 (seconds 0.07))
    (let ((gp-0 (new-stack-vector0)))
      (let ((v1-1 (handle->process arg0)))
        (if v1-1
            (vector-! gp-0 (-> self root trans) (-> (the-as swamp-bat v1-1) root trans))
            )
        )
      (+! (-> gp-0 y) -6144.0)
      (vector-normalize! gp-0 98304.0)
      (ja :group! swamp-bat-die-ja)
      (until (ja-done? 0)
        (vector-v++! (-> self root trans) gp-0)
        (ja :num! (seek! max 0.5))
        (suspend)
        )
      )
    (cleanup-for-death self)
    )
  :post swamp-bat-slave-post
  )

(defbehavior swamp-bat-slave-init-by-other swamp-bat-slave ((arg0 swamp-bat-slave) (arg1 int))
  (logior! (-> self mask) (process-mask enemy))
  (let ((s4-0 (new 'process 'collide-shape-moving self (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 1) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 6144.0)
      (set-root-prim! s4-0 s3-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core action) (collide-action solid))
        (set! (-> s2-0 prim-core offense) (collide-offense indestructible))
        (set! (-> s2-0 transform-index) 3)
        (set-vector! (-> s2-0 local-sphere) 0.0 0.0 0.0 4096.0)
        (append-prim s3-0 s2-0)
        )
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> self root) s4-0)
    )
  (set! (-> self root trans quad) (-> arg0 root trans quad))
  (set! (-> self root quat vec quad) (-> arg0 root quat vec quad))
  (vector-float*! (-> self root scale) *identity-vector* 2.0)
  (set! (-> self root pause-adjust-distance) 286720.0)
  (set! (-> self fact)
        (new 'process 'fact-info-enemy self (pickup-type eco-pill-random) (-> *FACT-bank* default-pill-inc))
        )
  (set! (-> self idle-anim-speed) (rand-vu-float-range 0.9 1.1))
  (set! (-> self strafe-distance) 0.0)
  (set! (-> self strafe-envelope) 0.0)
  (set! (-> self idle-position-index) arg1)
  (swamp-bat-slave-get-new-path)
  (set! (-> self root trans quad) (-> self idle-position quad))
  (setup-params! (-> self sync) (the-as uint 1200) 0.0 0.15 0.15)
  (initialize-skeleton self *swamp-bat-slave-sg* '())
  (logclear! (-> self mask) (process-mask actor-pause))
  (go swamp-bat-slave-idle)
  (none)
  )

(defbehavior swamp-bat-setup-new-path swamp-bat ((arg0 int))
  (when *run-time-assert-enable*
    (set-pos *__private-assert-info* "swamp-bat" (the-as uint 520) (the-as uint 2))
    (__assert-zero-lim-range-int arg0 (-> self path-count) "path-index" "(-> self path-count)")
    )
  (when (< 0.0 (the float (+ (-> self path-list arg0 curve num-cverts) -1)))
    (set! (-> self path-select) arg0)
    (let ((f30-0 0.0)
          (f28-0 (/ 65536.0 (the float (-> self slave-count))))
          )
      (eval-path-curve-div! (-> self path-list arg0) (-> self path-origin) 0.0 'interp)
      (dotimes (v1-16 (-> self slave-count))
        (set! (-> self idle-position-angle v1-16) f30-0)
        (+! f30-0 f28-0)
        )
      )
    #f
    )
  )

(defbehavior swamp-bat-make-path-select-plane swamp-bat ((arg0 int))
  (when *run-time-assert-enable*
    (set-pos *__private-assert-info* "swamp-bat" (the-as uint 538) (the-as uint 2))
    (__assert-zero-lim-range-int arg0 (-> self path-count) "path-index" "(-> self path-count)")
    )
  (let* ((s5-0 (-> self path-list arg0))
         (gp-1 (path-control-method-12 s5-0 (-> self path-select-plane arg0) 5.0))
         (s5-1 (eval-path-curve-div! s5-0 (new 'stack-no-clear 'vector) 5.0 'interp))
         )
    (set! (-> gp-1 y) 0.0)
    (vector-normalize! gp-1 1.0)
    (set! (-> gp-1 w) (- (vector-dot s5-1 gp-1)))
    )
  )

(defbehavior swamp-bat-update-path swamp-bat ()
  (dotimes (gp-0 (-> self path-count))
    (when (!= (-> self path-select) gp-0)
      (let* ((s5-0 (-> self path-select-plane gp-0))
             (f0-2 (+ (vector-dot (target-pos 0) (the-as vector s5-0)) (-> s5-0 w)))
             )
        (if (< 0.0 f0-2)
            (swamp-bat-setup-new-path gp-0)
            )
        )
      )
    )
  (none)
  )

(defbehavior swamp-bat-debug swamp-bat ()
  0
  (none)
  )

(defbehavior swamp-bat-check-slave-paths-match? swamp-bat ((arg0 int))
  (let ((v1-0 (the-as (pointer process-tree) (-> self child-process))))
    (while v1-0
      (if (and (-> (the-as swamp-bat-slave (-> v1-0 0)) launch-ready)
               (!= (-> (the-as swamp-bat-slave (-> v1-0 0)) path-select) arg0)
               )
          (return #f)
          )
      (set! v1-0 (-> v1-0 0 brother))
      )
    )
  #t
  )

(defstate swamp-bat-idle (swamp-bat)
  :trans swamp-bat-debug
  :code (behavior ()
    (when (zero? (-> self path-count))
      (process-entity-status! self (entity-perm-status dead) #t)
      (deactivate self)
      )
    (loop
      (when (and (time-elapsed? (-> self state-time) (seconds 0.2))
                 *target*
                 (>= (-> self fact idle-distance) (vector-vector-distance (-> self root trans) (-> *target* control trans)))
                 )
        (when (not (-> self child-process))
          (process-entity-status! self (entity-perm-status dead) #t)
          (deactivate self)
          )
        (swamp-bat-update-path)
        (if (or (point-in-vol? (-> self vol) (target-pos 5))
                (not (swamp-bat-check-slave-paths-match? (-> self path-select)))
                )
            (go swamp-bat-launch-slaves)
            )
        )
      (let ((gp-1 (new 'static 'matrix)))
        (quaternion->matrix gp-1 (-> self root quat))
        (set! (-> gp-1 vector 3 quad) (-> self root trans quad))
        )
      (suspend)
      )
    )
  :post #f
  )

(defbehavior swamp-bat-launch-slave swamp-bat ()
  (let ((gp-0 (the-as (pointer process-tree) (-> self child-process)))
        (v0-0 (the-as object #f))
        )
    (while (and gp-0 (not v0-0))
      (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-0 from) self)
        (set! (-> a1-0 num-params) 0)
        (set! (-> a1-0 message) 'launch)
        (set! v0-0 (send-event-function (ppointer->process gp-0) a1-0))
        )
      (set! gp-0 (-> gp-0 0 brother))
      )
    v0-0
    )
  )

(defstate swamp-bat-launch-slaves (swamp-bat)
  :trans swamp-bat-debug
  :code (behavior ()
    (set-time! (-> self state-time))
    (loop
      (swamp-bat-update-path)
      (when (time-elapsed? (-> self state-time) (seconds 0.5))
        (set-time! (-> self state-time))
        (if (not (swamp-bat-launch-slave))
            (go swamp-bat-idle)
            )
        )
      (suspend)
      )
    )
  :post #f
  )

(defmethod init-from-entity! ((this swamp-bat) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 0.0)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (logior! (-> this mask) (process-mask enemy))
  (set! (-> this vol) (new 'process 'vol-control this))
  (logior! (-> this vol flags) 3)
  (set! (-> this path-list 0) (new 'process 'curve-control this 'path -1000000000.0))
  (set! (-> this path-list 1) (new 'process 'curve-control this 'pathb -1000000000.0))
  (logior! (-> this path-list 0 flags) (path-control-flag display draw-line draw-point draw-text))
  (logior! (-> this path-list 1 flags) (path-control-flag display draw-line draw-point draw-text))
  (set! (-> this path-count) 0)
  (when (< 0.0 (the float (+ (-> this path-list 0 curve num-cverts) -1)))
    (+! (-> this path-count) 1)
    (swamp-bat-make-path-select-plane 0)
    )
  (when (< 0.0 (the float (+ (-> this path-list 1 curve num-cverts) -1)))
    (+! (-> this path-count) 1)
    (swamp-bat-make-path-select-plane 1)
    )
  (if (!= (-> this path-count) 2)
      (go process-drawable-art-error "need 2 paths")
      )
  (set! (-> this fact)
        (new 'process 'fact-info-enemy this (pickup-type eco-pill-random) (-> *FACT-bank* default-pill-inc))
        )
  (let ((a1-10 (res-lump-value arg0 'num-lurkers uint128 :default (the-as uint128 6))))
    (set! (-> this slave-count) (max 2 (min 8 (the-as int a1-10))))
    )
  (swamp-bat-setup-new-path 0)
  (swamp-bat-update-path)
  (dotimes (s5-1 (-> this slave-count))
    (process-spawn swamp-bat-slave this s5-1 :to this :stack-size 4512)
    )
  (go swamp-bat-idle)
  (none)
  )
