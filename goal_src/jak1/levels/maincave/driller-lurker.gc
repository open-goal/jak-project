;;-*-Lisp-*-
(in-package goal)

;; name: driller-lurker.gc
;; name in dgo: driller-lurker
;; dgos: L1, MAI, MAINCAVE


;; DECOMP BEGINS

(import "goal_src/jak1/import/driller-lurker-ag.gc")

(deftype driller-lurker (process-drawable)
  ((root-overeride          collide-shape-moving  :offset        112)
   (hit-player?             symbol                :offset-assert 176)
   (played-drill-sound?     symbol                :offset-assert 180)
   (mode                    uint64                :offset-assert 184)
   (path-u                  float                 :offset-assert 192)
   (path-units-per-meter    float                 :offset-assert 196)
   (path-speed              float                 :offset-assert 200)
   (targ-path-speed         float                 :offset-assert 204)
   (path-dir                float                 :offset-assert 208)
   (path-ry                 float                 :offset-assert 212)
   (facing-ry               float                 :offset-assert 216)
   (drill-rz                float                 :offset-assert 220)
   (drill-speed             float                 :offset-assert 224)
   (up-blend                float                 :offset-assert 228)
   (player-path-u           float                 :offset-assert 232)
   (ambient-drilling-u      float                 :offset-assert 236)
   (timeout                 int32                 :offset-assert 240)
   (neck                    joint-mod             :offset-assert 244)
   (drill                   joint-mod             :offset-assert 248)
   (sound2                  ambient-sound         :offset-assert 252)
   (last-update-time        time-frame            :offset-assert 256)
   (last-player-path-u-time time-frame            :offset-assert 264)
   (started-chasing-time    time-frame            :offset-assert 272)
   (hit-player-time         time-frame            :offset-assert 280)
   (player-attack-id        uint64                :offset-assert 288)
   )
  :heap-base #xc0
  :method-count-assert 28
  :size-assert         #x128
  :flag-assert         #x1c00c00128
  (:methods
    (driller-lurker-method-20 (_type_ symbol target) symbol 20)
    (driller-lurker-method-21 (_type_) none 21)
    (driller-lurker-method-22 (_type_) none 22)
    (driller-lurker-method-23 (_type_) float 23)
    (driller-lurker-method-24 (_type_) symbol 24)
    (driller-lurker-method-25 (_type_) symbol 25)
    (driller-lurker-method-26 (_type_) symbol 26)
    (driller-lurker-method-27 (_type_) object 27)
    )
  (:states
    driller-lurker-attack
    (driller-lurker-chase symbol)
    driller-lurker-debug-play-anims
    driller-lurker-die
    driller-lurker-idle-drilling
    driller-lurker-jammed-standing
    driller-lurker-patrol
    driller-lurker-patrol-pause
    )
  )


(defskelgroup *driller-lurker-sg* driller-lurker driller-lurker-lod0-jg -1
              ((driller-lurker-lod0-mg (meters 20))
               (driller-lurker-lod1-mg (meters 40))
               (driller-lurker-lod2-mg (meters 999999))
               )
              :bounds (static-spherem 0 1.5 0 7.75)
              :longest-edge (meters 2.3)
              :shadow driller-lurker-shadow-mg
              )

(define *driller-lurker-shadow-control*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :flags (shadow-flags shdf00 shdf03)
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 614400.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 4096.0)
                                           :top-plane (new 'static 'plane :y 1.0 :w -2048.0)
                                           :fade-dist 245760.0
                                           )
                               )
  )

(defpartgroup group-driller-lurker-drilling-debris
  :id 331
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 8)
  :parts ((sp-item 728 :fade-after (meters 80) :falloff-to (meters 80))
    (sp-item 2075 :fade-after (meters 60) :falloff-to (meters 60))
    (sp-item 2076 :fade-after (meters 60) :falloff-to (meters 60))
    (sp-item 2077 :fade-after (meters 40) :falloff-to (meters 40))
    )
  )

(defpart 728
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 4.0)
    (:x (meters -0.5) (meters 1))
    (:y (meters -0.5) (meters 1))
    (:z (meters -0.5) (meters 1))
    (:scale-x (meters 1.5) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 64.0 32.0)
    (:g 64.0 32.0)
    (:b 64.0 32.0)
    (:a 32.0 64.0)
    (:vel-y (meters 0.026666667) (meters 0.026666667))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -1.2) (degrees 1.2))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.45714286)
    (:accel-y (meters 0.00066666666))
    (:friction 0.9)
    (:timer (seconds 0.7))
    (:flags (bit2 bit12 bit14))
    (:conerot-x (degrees 0) (degrees 180))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 2075
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 4.0)
    (:x (meters -0.5) (meters 1))
    (:y (meters -0.5) (meters 1))
    (:z (meters -0.5) (meters 1))
    (:scale-x (meters 0.5) (meters 0.25))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 64.0 32.0)
    (:g 64.0 32.0)
    (:b 64.0 32.0)
    (:a 32.0 32.0)
    (:vel-y (meters 0.053333335) (meters 0.10666667))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -1.2) (degrees 1.2))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.30476192)
    (:accel-y (meters 0.00066666666))
    (:friction 0.9)
    (:timer (seconds 0.7))
    (:flags (bit2 bit12 bit14))
    (:conerot-x (degrees 0) (degrees 180))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 2076
  :init-specs ((:texture (new 'static 'texture-id :index #x1d :page #x2))
    (:num 4.0)
    (:x (meters -0.5) (meters 1))
    (:y (meters -0.5) (meters 1))
    (:z (meters -0.5) (meters 1))
    (:scale-x (meters 0.1) (meters 0.1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 96.0 64.0)
    (:g 128.0 64.0)
    (:b 192.0 64.0)
    (:a 128.0)
    (:vel-y (meters 0.053333335) (meters 0.10666667))
    (:rotvel-z (degrees -1.2) (degrees 1.2))
    (:accel-y (meters -0.0033333334))
    (:friction 0.97)
    (:timer (seconds 1.5))
    (:flags (bit2 bit12 bit14))
    (:next-time (seconds 1.25))
    (:next-launcher 2078)
    (:conerot-x (degrees 0) (degrees 180))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 2078
  :init-specs ((:fade-a -1.7066667))
  )

(defpart 2077
  :init-specs ((:texture (new 'static 'texture-id :index #x1d :page #x2))
    (:num 8.0 8.0)
    (:x (meters -0.5) (meters 1))
    (:y (meters -0.5) (meters 1))
    (:z (meters -0.5) (meters 1))
    (:scale-x (meters 0.05) (meters 0.15))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 96.0 64.0)
    (:g 128.0 64.0)
    (:b 192.0 64.0)
    (:a 64.0 64.0)
    (:vel-y (meters 0.053333335) (meters 0.10666667))
    (:rotvel-z (degrees -1.2) (degrees 1.2))
    (:accel-y (meters -0.0033333334))
    (:friction 0.97)
    (:timer (seconds 0.5))
    (:flags (bit2 bit12 bit14))
    (:next-time (seconds 0.017))
    (:next-launcher 2078)
    (:conerot-x (degrees 0) (degrees 180))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defbehavior driller-lurker-default-event-handler driller-lurker ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (sv-96 collide-shape-prim))
  (cond
    ((= arg2 'attack)
     (cond
       ((= (-> arg0 type) target)
        (let ((v1-3 (-> arg3 param 2)))
          (when (!= v1-3 (-> self player-attack-id))
            (set! (-> self player-attack-id) v1-3)
            (case (-> self mode)
              ((5)
               (let ((v1-5 *target*))
                 (when (!= (-> arg3 param 1) 'flop)
                   (let ((f0-4 (atan
                                 (- (-> v1-5 control trans x) (-> self root-overeride trans x))
                                 (- (-> v1-5 control trans z) (-> self root-overeride trans z))
                                 )
                               )
                         )
                     (quaternion-axis-angle! (-> self root-overeride quat) 0.0 1.0 0.0 f0-4)
                     )
                   )
                 )
               (go driller-lurker-die)
               )
              (else
                (let ((s4-0 *target*)
                      (s2-0 #f)
                      (s3-0 #f)
                      )
                  (let* ((s1-0 (the-as touching-shapes-entry (-> arg3 param 0)))
                         (s0-0 (-> s1-0 head))
                         )
                    (while s0-0
                      (set! sv-96 (get-touched-prim s0-0 (-> self root-overeride) s1-0))
                      (if (and (logtest? (-> (get-touched-prim s0-0 (-> s4-0 control) s1-0) prim-core action) (collide-action solid))
                               (logtest? (-> sv-96 prim-id) 1)
                               )
                          (set! s2-0 #t)
                          )
                      (if (logtest? (-> sv-96 prim-id) 2)
                          (set! s3-0 #t)
                          )
                      (set! s0-0 (-> s0-0 next))
                      )
                    )
                  (cond
                    ((or s2-0 (not s3-0))
                     (when (send-event
                             arg0
                             'attack
                             (-> arg3 param 0)
                             (static-attack-info ((shove-up (meters 2)) (shove-back (meters 3))))
                             )
                       (set! (-> self hit-player?) #t)
                       (set! (-> self hit-player-time) (-> *display* base-frame-counter))
                       (set-collide-offense (-> self root-overeride) 2 (collide-offense no-offense))
                       (let ((v1-39 (-> self mode)))
                         (if (or (zero? v1-39) (= v1-39 1) (= v1-39 2))
                             (go driller-lurker-chase #t)
                             )
                         )
                       )
                     )
                    (s3-0
                      (when (!= (-> arg3 param 1) 'flop)
                        (let ((f0-11 (atan
                                       (- (-> s4-0 control trans x) (-> self root-overeride trans x))
                                       (- (-> s4-0 control trans z) (-> self root-overeride trans z))
                                       )
                                     )
                              )
                          (quaternion-axis-angle! (-> self root-overeride quat) 0.0 1.0 0.0 f0-11)
                          )
                        )
                      (go driller-lurker-die)
                      )
                    )
                  )
                )
              )
            )
          )
        )
       (else
         (go driller-lurker-die)
         )
       )
     )
    ((= arg2 'touch)
     (when (= (-> arg0 type) target)
       (when (send-event
               arg0
               'attack
               (-> arg3 param 0)
               (static-attack-info ((shove-up (meters 2)) (shove-back (meters 3))))
               )
         (set! (-> self hit-player?) #t)
         (set! (-> self hit-player-time) (-> *display* base-frame-counter))
         (set-collide-offense (-> self root-overeride) 2 (collide-offense no-offense))
         (let ((v1-62 (-> self mode)))
           (if (or (zero? v1-62) (= v1-62 1) (= v1-62 2))
               (go driller-lurker-chase #t)
               )
           )
         )
       )
     )
    )
  )

(defmethod driller-lurker-method-20 driller-lurker ((obj driller-lurker) (arg0 symbol) (arg1 target))
  (let ((v1-1 (-> *display* base-frame-counter)))
    (when (!= v1-1 (-> obj last-update-time))
      (set! (-> obj last-update-time) v1-1)
      (let* ((f0-0 (-> obj path-speed))
             (f1-1 (seek f0-0 (-> obj targ-path-speed) (* 12288.0 (-> *display* seconds-per-frame))))
             )
        (set! (-> obj path-speed) f1-1)
        (when (< 0.0 f1-1)
          (let* ((f0-5 (-> obj path-u))
                 (f30-0 (* (-> obj path-dir) f1-1 (-> *display* seconds-per-frame)))
                 (s4-0 #t)
                 (f0-6 (+ f0-5 (* 0.00024414062 (-> obj path-units-per-meter) f30-0)))
                 )
            (cond
              ((< f0-6 0.0)
               (set! s4-0 #f)
               (cond
                 (arg0
                   (set! f0-6 (- f0-6))
                   (set! (-> obj path-dir) (- (-> obj path-dir)))
                   (set! (-> obj path-speed) 0.0)
                   )
                 (else
                   (set! f0-6 0.0)
                   (set! (-> obj path-speed) 0.0)
                   )
                 )
               )
              ((< 1.0 f0-6)
               (set! s4-0 #f)
               (cond
                 (arg0
                   (set! f0-6 (- 2.0 f0-6))
                   (set! (-> obj path-dir) (- (-> obj path-dir)))
                   (set! (-> obj path-speed) 0.0)
                   )
                 (else
                   (set! f0-6 1.0)
                   (set! (-> obj path-speed) 0.0)
                   )
                 )
               )
              )
            (set! (-> obj path-u) f0-6)
            (let ((s3-1 (new 'stack-no-clear 'vector)))
              (set! (-> s3-1 quad) (-> obj root-overeride trans quad))
              (eval-path-curve! (-> obj path) (-> obj root-overeride trans) f0-6 'interp)
              (when s4-0
                (let ((f0-7 (vector-vector-xz-distance s3-1 (-> obj root-overeride trans))))
                  #|
                    fix for higher framerate:

                    when the lurker changes directions, path-speed can get extremely close to 0
                    when this happens, the change in u on a frame may be extremely small

                    so the vector-vector-xz-distance is very small (because you didn't move much
                    on the path) and (set! (-> obj path-units-per-meter) (* (/ (fabs f30-0) f0-7)
                    (-> obj path-units-per-meter))) makes things blow up because that division isn't
                    accurate for tiny numbers
                  |#
                  (when (> f0-7 0.00001)
                    (set! (-> obj path-units-per-meter) (* (/ (fabs f30-0) f0-7) (-> obj path-units-per-meter)))))
                )
              )
            )
          )
        )
      (let ((s4-1 (new 'stack-no-clear 'vector)))
        (path-control-method-14 (-> obj path) s4-1 (-> obj path-u))
        (let ((f0-13 (atan (-> s4-1 x) (-> s4-1 z))))
          (if (< (-> obj path-dir) 0.0)
              (set! f0-13 (+ 32768.0 f0-13))
              )
          (set! (-> obj path-ry) f0-13)
          )
        )
      (case (-> obj mode)
        ((4)
         (when *target*
           (let ((a0-13 (target-pos 0))
                 (v1-26 (new 'stack-no-clear 'vector))
                 )
             (vector-! v1-26 a0-13 (-> obj root-overeride trans))
             (let ((f0-16 (atan (-> v1-26 x) (-> v1-26 z))))
               (set! (-> obj facing-ry)
                     (deg-seek-smooth (-> obj facing-ry) f0-16 (* 32768.0 (-> *display* seconds-per-frame)) 0.25)
                     )
               )
             )
           (when (< 16384.0 (fabs (deg- (-> obj facing-ry) (-> obj path-ry))))
             (set! (-> obj path-dir) (- (-> obj path-dir)))
             (set! (-> obj path-ry) (+ 32768.0 (-> obj path-ry)))
             )
           )
         )
        (else
          (if (!= (-> obj mode) 1)
              (set! (-> obj facing-ry)
                    (deg-seek-smooth (-> obj facing-ry) (-> obj path-ry) (* 32768.0 (-> *display* seconds-per-frame)) 0.25)
                    )
              )
          )
        )
      (quaternion-axis-angle! (-> obj root-overeride quat) 0.0 1.0 0.0 (-> obj facing-ry))
      (let ((f30-2 0.0))
        (when *target*
          (let ((f0-34 (vector-vector-xz-distance (target-pos 0) (-> obj root-overeride trans))))
            (if (< f0-34 36864.0)
                (set! f30-2 (- 1.0 (* 0.00006510417 (fmax 0.0 (+ -21504.0 f0-34)))))
                )
            )
          )
        (let ((f28-1 (* 0.0001373291 (fmin 7281.778 (fabs (deg- (-> obj path-ry) (-> obj facing-ry)))))))
          (cond
            ((< 0.0 f30-2)
             (let ((s3-2 (new 'stack-no-clear 'vector)))
               (vector-! s3-2 (target-pos 0) (-> obj root-overeride trans))
               (let* ((f1-27 (vector-x-angle s3-2))
                      (f1-29 (fmax 728.1778 (fmin 10194.489 f1-27)))
                      (f0-46 (* 0.000105637766 (+ -728.1778 f1-29)))
                      (f0-47 (lerp f28-1 f0-46 f30-2))
                      )
                 (set! (-> obj up-blend)
                       (seek-with-smooth (-> obj up-blend) f0-47 (* 8192.0 (-> *display* seconds-per-frame)) 0.25 0.01)
                       )
                 )
               )
             )
            (else
              (set! (-> obj up-blend)
                    (seek-with-smooth (-> obj up-blend) f28-1 (* 8192.0 (-> *display* seconds-per-frame)) 0.125 0.01)
                    )
              )
            )
          )
        )
      (when (and arg1 *target*)
        (set-target! (-> obj neck) (target-pos 5))
        (if *target*
            (look-at-enemy! (-> *target* neck) (the-as vector (-> obj root-overeride root-prim prim-core)) 'attacking obj)
            )
        )
      (let ((f30-3 (-> obj drill-speed)))
        (let ((v1-56 (-> obj mode)))
          (cond
            ((or (= v1-56 2) (zero? v1-56))
             (set! f30-3 (seek f30-3 72817.78 (* 372827.03 (-> *display* seconds-per-frame))))
             )
            ((= v1-56 1)
             (set! f30-3 (seek f30-3 276707.56 (* 372827.03 (-> *display* seconds-per-frame))))
             )
            ((or (= v1-56 3) (= v1-56 4))
             (set! f30-3 (if (>= (- (-> *display* base-frame-counter) (-> obj started-chasing-time)) (seconds 2.25))
                             (seek f30-3 0.0 (* 600746.7 (-> *display* seconds-per-frame)))
                             (seek f30-3 276707.56 (* 372827.03 (-> *display* seconds-per-frame)))
                             )
                   )
             )
            ((= v1-56 5)
             (set! f30-3 (if (>= (- (-> *display* base-frame-counter) (-> obj started-chasing-time)) (seconds 5.75))
                             (seek f30-3 276707.56 (* 372827.03 (-> *display* seconds-per-frame)))
                             (seek f30-3 0.0 (* 600746.7 (-> *display* seconds-per-frame)))
                             )
                   )
             )
            )
          )
        (set! (-> obj drill-speed) f30-3)
        (cond
          ((>= f30-3 36408.89)
           (update-trans! (-> obj sound) (-> obj root-overeride trans))
           (update! (-> obj sound))
           (set! (-> obj played-drill-sound?) #t)
           )
          (else
            (when (-> obj played-drill-sound?)
              (set! (-> obj played-drill-sound?) #f)
              (stop! (-> obj sound))
              )
            )
          )
        (let ((f0-69 (+ (-> obj drill-rz) (* f30-3 (-> *display* seconds-per-frame)))))
          (set! (-> obj drill-rz) (- f0-69 (* (the float (the int (/ f0-69 65536.0))) 65536.0)))
          )
        )
      (let ((s5-2 (new 'stack-no-clear 'quaternion)))
        (quaternion-axis-angle! s5-2 0.0 0.0 1.0 (-> obj drill-rz))
        (set-trs! (-> obj drill) (the-as vector #f) s5-2 (the-as vector #f))
        )
      0
      )
    )
  (when (and (-> obj hit-player?)
             (or (not *target*)
                 (and (not (logtest? (-> *target* state-flags)
                                     (state-flags being-attacked invulnerable timed-invulnerable invuln-powerup do-not-notice dying)
                                     )
                           )
                      (>= (- (-> *display* base-frame-counter) (-> obj hit-player-time)) (seconds 0.05))
                      )
                 )
             )
    (set-collide-offense (-> obj root-overeride) 2 (collide-offense touch))
    (set! (-> obj hit-player?) #f)
    #f
    )
  )

(defmethod driller-lurker-method-23 driller-lurker ((obj driller-lurker))
  (let ((v1-1 (-> *display* base-frame-counter)))
    (when (!= v1-1 (-> obj last-player-path-u-time))
      (set! (-> obj last-player-path-u-time) v1-1)
      (cond
        (*target*
          (let* ((s5-0 (-> obj path))
                 (s4-0 (method-of-object s5-0 path-control-method-20))
                 )
            (target-pos 0)
            (set! (-> obj player-path-u) (s4-0 s5-0))
            )
          )
        (else
          (set! (-> obj player-path-u) 0.0)
          )
        )
      )
    )
  (-> obj player-path-u)
  )

(defmethod driller-lurker-method-25 driller-lurker ((obj driller-lurker))
  (when *target*
    (let* ((s5-0 (target-pos 0))
           (f0-1 (- (-> s5-0 y) (-> obj root-overeride trans y)))
           )
      (when (and (>= 32768.0 f0-1) (>= f0-1 -2048.0))
        (case (-> obj mode)
          ((1)
           (if (>= 73728.0 (vector-vector-xz-distance (-> obj root-overeride trans) s5-0))
               (return #t)
               )
           )
          (else
            (when (>= 102400.0 (vector-vector-xz-distance (-> obj root-overeride trans) s5-0))
              (let ((f0-8 (atan (- (-> s5-0 x) (-> obj root-overeride trans x)) (- (-> s5-0 z) (-> obj root-overeride trans z))))
                    )
                (if (>= 20024.889 (fabs (deg- f0-8 (-> obj facing-ry))))
                    (return #t)
                    )
                )
              )
            )
          )
        )
      )
    )
  #f
  )

(defmethod driller-lurker-method-26 driller-lurker ((obj driller-lurker))
  (when *target*
    (let* ((a1-0 (target-pos 0))
           (f0-1 (- (-> a1-0 y) (-> obj root-overeride trans y)))
           )
      (if (and (< f0-1 40960.0)
               (< -10240.0 f0-1)
               (< (vector-vector-xz-distance (-> obj root-overeride trans) a1-0) 143360.0)
               )
          (return #f)
          )
      )
    )
  #t
  )

(defmethod driller-lurker-method-24 driller-lurker ((obj driller-lurker))
  (when *target*
    (let* ((a1-0 (target-pos 0))
           (f0-1 (- (-> a1-0 y) (-> obj root-overeride trans y)))
           )
      (when (and (< f0-1 40960.0) (< -10240.0 f0-1))
        (let ((f0-2 (vector-vector-xz-distance (-> obj root-overeride trans) a1-0)))
          (cond
            ((>= 17408.0 f0-2)
             (return #t)
             )
            ((< f0-2 143360.0)
             (let ((f0-3 (driller-lurker-method-23 obj))
                   (f1-5 (-> obj path-u))
                   )
               (if (>= (* 0.1 (-> obj path-units-per-meter)) (fabs (- f0-3 f1-5)))
                   (return #t)
                   )
               )
             )
            )
          )
        )
      )
    )
  #f
  )

(defmethod driller-lurker-method-27 driller-lurker ((obj driller-lurker))
  (let ((a2-0 (-> obj node-list data 25 bone transform))
        (s5-0 (new 'stack-no-clear 'vector))
        )
    (set-vector! s5-0 0.0 0.0 8192.0 1.0)
    (vector-matrix*! s5-0 s5-0 a2-0)
    (vector-float*! s5-0 s5-0 (/ 1.0 (-> s5-0 w)))
    (spawn (-> obj part) s5-0)
    )
  )

(defstate driller-lurker-debug-play-anims (driller-lurker)
  :code (behavior ()
    0
    (none)
    )
  :post (the-as (function none :behavior driller-lurker) transform-post)
  )

(defstate driller-lurker-idle-drilling (driller-lurker)
  :event driller-lurker-default-event-handler
  :enter (behavior ()
    (set! (-> self mode) (the-as uint 1))
    (set! (-> self targ-path-speed) 0.0)
    (set! (-> self path-speed) 0.0)
    (shut-down! (-> self neck))
    (none)
    )
  :exit (behavior ()
    (stop! (-> self sound2))
    (none)
    )
  :trans (behavior ()
    (if (driller-lurker-method-25 self)
        (go driller-lurker-chase #t)
        )
    (driller-lurker-method-20 self #t (the-as target #f))
    (none)
    )
  :code (behavior ()
    (update-trans! (-> self sound2) (-> self root-overeride trans))
    (loop
      (set! (-> self timeout) (rand-vu-int-range 4 8))
      (ja-channel-push! 1 (seconds 0.2))
      (dotimes (gp-0 (-> self timeout))
        (let ((f30-0 (rand-vu-float-range 1.0 1.8)))
          (ja-no-eval :group! driller-lurker-idle-drilling-ja :num! (seek! max f30-0) :frame-num 0.0)
          (until (ja-done? 0)
            (update! (-> self sound2))
            (if (and (>= (ja-aframe-num 0) 7.0) (>= 13.0 (ja-aframe-num 0)))
                (driller-lurker-method-27 self)
                )
            (suspend)
            (ja :num! (seek! max f30-0))
            )
          )
        )
      (stop! (-> self sound2))
      (ja-channel-push! 1 (seconds 0.2))
      (if (zero? (rand-vu-int-count 2))
          (ja :group! driller-lurker-idle-look-left-ja :num! min)
          (ja :group! driller-lurker-idle-look-right-ja :num! min)
          )
      (ja-no-eval :num! (seek!))
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (none)
    )
  :post (the-as (function none :behavior driller-lurker) transform-post)
  )

(defstate driller-lurker-patrol (driller-lurker)
  :event driller-lurker-default-event-handler
  :enter (behavior ()
    (set! (-> self mode) (the-as uint 2))
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (set! (-> self timeout) (rand-vu-int-range 900 3600))
    (set! (-> self targ-path-speed) 15360.0)
    (if (>= 4096.0 (-> self path-speed))
        (set! (-> self targ-path-speed) 15360.0)
        )
    (shut-down! (-> self neck))
    (none)
    )
  :trans (behavior ()
    (if (driller-lurker-method-25 self)
        (go driller-lurker-chase #t)
        )
    (driller-lurker-method-20 self #t (the-as target #f))
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 2 (seconds 0.2))
    (ja :group! driller-lurker-walk-ja :num! min)
    (ja :chan 1 :group! driller-lurker-walk-up-ja :num! (chan 0) :frame-interp (-> self up-blend))
    (loop
      (suspend)
      (ja :num! (seek!))
      (if (= (ja-group-size) 2)
          (ja :chan 1 :num! (chan 0) :frame-interp (-> self up-blend))
          )
      (when (ja-done? 0)
        (if (and (>= (- (-> *display* base-frame-counter) (-> self state-time)) (-> self timeout))
                 (>= 546.13336 (fabs (deg- (-> self path-ry) (-> self facing-ry))))
                 )
            (go driller-lurker-patrol-pause)
            )
        (ja :num-func num-func-identity :frame-num 0.0)
        )
      )
    (none)
    )
  :post (the-as (function none :behavior driller-lurker) transform-post)
  )

(defstate driller-lurker-patrol-pause (driller-lurker)
  :event driller-lurker-default-event-handler
  :enter (behavior ()
    (set! (-> self mode) (the-as uint 2))
    (set! (-> self path-speed) 0.0)
    (set! (-> self targ-path-speed) 0.0)
    (shut-down! (-> self neck))
    (none)
    )
  :trans (behavior ()
    (if (driller-lurker-method-25 self)
        (go driller-lurker-chase #t)
        )
    (driller-lurker-method-20 self #t (the-as target #f))
    (none)
    )
  :code (behavior ()
    (set! (-> self timeout) (rand-vu-int-range 2 4))
    (let ((s5-0 -1))
      (dotimes (gp-0 (-> self timeout))
        (let ((v1-0 (rand-vu-int-count 3)))
          (if (= v1-0 s5-0)
              (set! v1-0 (mod (+ v1-0 1) 3))
              )
          (set! s5-0 v1-0)
          (cond
            ((zero? v1-0)
             (if (not (ja-group? driller-lurker-idle-ja))
                 (ja-channel-push! 1 (seconds 0.2))
                 )
             (ja :group! driller-lurker-idle-ja :num! min)
             )
            ((= v1-0 1)
             (if (not (ja-group? driller-lurker-idle-look-left-ja))
                 (ja-channel-push! 1 (seconds 0.2))
                 )
             (ja :group! driller-lurker-idle-look-left-ja :num! min)
             )
            ((= v1-0 2)
             (if (not (ja-group? driller-lurker-idle-look-right-ja))
                 (ja-channel-push! 1 (seconds 0.2))
                 )
             (ja :group! driller-lurker-idle-look-right-ja :num! min)
             )
            )
          )
        (ja-no-eval :num! (seek!))
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!))
          )
        )
      )
    (go driller-lurker-patrol)
    (none)
    )
  :post (the-as (function none :behavior driller-lurker) transform-post)
  )

(defstate driller-lurker-chase (driller-lurker)
  :event driller-lurker-default-event-handler
  :enter (behavior ((arg0 symbol))
    (if arg0
        (set! (-> self started-chasing-time) (-> *display* base-frame-counter))
        )
    (set! (-> self mode) (the-as uint 3))
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (set! (-> self targ-path-speed) 23552.0)
    (none)
    )
  :trans (behavior ()
    (if (driller-lurker-method-24 self)
        (go driller-lurker-attack)
        )
    (if (driller-lurker-method-26 self)
        (go driller-lurker-patrol)
        )
    (if (>= (- (-> *display* base-frame-counter) (-> self started-chasing-time)) (seconds 3))
        (go driller-lurker-jammed-standing)
        )
    (let* ((gp-0 (-> self path))
           (s5-0 (method-of-object gp-0 path-control-method-20))
           )
      (target-pos 0)
      (let ((f0-1 (- (s5-0 gp-0) (-> self path-u))))
        (when (>= (fabs f0-1) (* 0.1 (-> self path-units-per-meter)))
          (cond
            ((< 0.0 f0-1)
             (when (< (-> self path-dir) 0.0)
               (set! (-> self path-dir) 1.0)
               (set! (-> self path-speed) 0.0)
               )
             )
            (else
              (when (>= (-> self path-dir) 0.0)
                (set! (-> self path-dir) -1.0)
                (set! (-> self path-speed) 0.0)
                )
              )
            )
          )
        )
      )
    (driller-lurker-method-20 self #f (the-as target #t))
    (none)
    )
  :code (behavior ((arg0 symbol))
    (ja-channel-push! 2 (seconds 0.2))
    (ja :group! driller-lurker-run-ja :num! min)
    (ja :chan 1 :group! driller-lurker-run-up-ja :num! (chan 0) :frame-interp (-> self up-blend))
    (loop
      (suspend)
      (ja :num! (seek!))
      (if (= (ja-group-size) 2)
          (ja :chan 1 :num! (chan 0) :frame-interp (-> self up-blend))
          )
      (if (ja-done? 0)
          (ja :num-func num-func-identity :frame-num 0.0)
          )
      )
    (none)
    )
  :post (the-as (function none :behavior driller-lurker) transform-post)
  )

(defstate driller-lurker-attack (driller-lurker)
  :event driller-lurker-default-event-handler
  :enter (behavior ()
    (set! (-> self mode) (the-as uint 4))
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (set! (-> self path-speed) 0.0)
    (set! (-> self targ-path-speed) 0.0)
    (none)
    )
  :trans (behavior ()
    (cond
      ((driller-lurker-method-24 self)
       (set! (-> self state-time) (-> *display* base-frame-counter))
       )
      (else
        (if (>= (- (-> *display* base-frame-counter) (-> self state-time)) (seconds 0.5))
            (go driller-lurker-chase #f)
            )
        )
      )
    (if (>= (- (-> *display* base-frame-counter) (-> self started-chasing-time)) (seconds 3))
        (go driller-lurker-jammed-standing)
        )
    (driller-lurker-method-20 self #f (the-as target #t))
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 2 (seconds 0.2))
    (ja :group! driller-lurker-attack-ja :num! min)
    (ja :chan 1 :group! driller-lurker-attack-up-ja :num! (chan 0) :frame-interp (-> self up-blend))
    (loop
      (suspend)
      (ja :num! (seek!))
      (if (= (ja-group-size) 2)
          (ja :chan 1 :num! (chan 0) :frame-interp (-> self up-blend))
          )
      (if (ja-done? 0)
          (ja :num-func num-func-identity :frame-num 0.0)
          )
      )
    (none)
    )
  :post (the-as (function none :behavior driller-lurker) transform-post)
  )

(defstate driller-lurker-jammed-standing (driller-lurker)
  :event driller-lurker-default-event-handler
  :enter (behavior ()
    (set! (-> self mode) (the-as uint 5))
    (set! (-> self path-speed) 0.0)
    (set! (-> self targ-path-speed) 0.0)
    (shut-down! (-> self neck))
    (none)
    )
  :trans (behavior ()
    (driller-lurker-method-20 self #f (the-as target #f))
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! driller-lurker-drill-jams-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (set! (-> self started-chasing-time) (-> *display* base-frame-counter))
    (cond
      (*target*
        (go driller-lurker-chase #f)
        (set! (-> self path-speed) 5888.0)
        )
      (else
        (set! (-> self path-speed) 7680.0)
        (go driller-lurker-patrol)
        )
      )
    (none)
    )
  :post (the-as (function none :behavior driller-lurker) transform-post)
  )

(defstate driller-lurker-die (driller-lurker)
  :event (the-as
    (function process int symbol event-message-block object :behavior driller-lurker)
    process-drawable-death-event-handler
    )
  :code (behavior ()
    (shut-down! (-> self neck))
    (logclear! (-> self mask) (process-mask actor-pause))
    (ja-channel-push! 1 (seconds 0.2))
    (clear-collide-with-as (-> self root-overeride))
    (ja-no-eval :group! driller-lurker-die-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (send-event self 'death-end)
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    (none)
    )
  :post (the-as (function none :behavior driller-lurker) ja-post)
  )

(defmethod relocate driller-lurker ((obj driller-lurker) (arg0 int))
  (if (nonzero? (-> obj neck))
      (&+! (-> obj neck) arg0)
      )
  (if (nonzero? (-> obj drill))
      (&+! (-> obj drill) arg0)
      )
  (if (nonzero? (-> obj sound2))
      (&+! (-> obj sound2) arg0)
      )
  (the-as
    driller-lurker
    ((the-as (function process-drawable int process-drawable) (find-parent-method driller-lurker 7)) obj arg0)
    )
  )

(defmethod deactivate driller-lurker ((obj driller-lurker))
  (if (nonzero? (-> obj sound2))
      (stop! (-> obj sound2))
      )
  ((method-of-type process-drawable deactivate) obj)
  (none)
  )

(defmethod init-from-entity! driller-lurker ((obj driller-lurker) (arg0 entity-actor))
  (local-vars (sv-16 res-tag))
  (set! (-> obj hit-player?) #f)
  (set! (-> obj played-drill-sound?) #f)
  (set! (-> obj hit-player-time) 0)
  (set! (-> obj mode) (the-as uint 0))
  (set! (-> obj drill-rz) 0.0)
  (set! (-> obj drill-speed) 72817.78)
  (set! (-> obj last-update-time) 0)
  (set! (-> obj last-player-path-u-time) 0)
  (set! (-> obj started-chasing-time) 0)
  (set! (-> obj player-attack-id) (the-as uint 0))
  (set! (-> obj ambient-drilling-u) -1.0)
  (set! (-> obj mask) (logior (process-mask enemy) (-> obj mask)))
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 6) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid attackable attackable-unused))
      (set! (-> s3-0 prim-core offense) (collide-offense normal-attack))
      (set-vector! (-> s3-0 local-sphere) 0.0 11264.0 0.0 22528.0)
      (set-root-prim! s4-0 s3-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 2))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core action) (collide-action solid attackable attackable-unused))
        (set! (-> s2-0 prim-core offense) (collide-offense touch))
        (set-vector! (-> s2-0 local-sphere) 0.0 3276.8 0.0 4505.6)
        (append-prim s3-0 s2-0)
        )
      (let ((s2-1 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 2))))
        (set! (-> s2-1 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-1 collide-with) (collide-kind target))
        (set! (-> s2-1 prim-core action) (collide-action solid attackable attackable-unused))
        (set! (-> s2-1 prim-core offense) (collide-offense touch))
        (set-vector! (-> s2-1 local-sphere) 0.0 7372.8 0.0 4505.6)
        (append-prim s3-0 s2-1)
        )
      (let ((s2-2 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 2))))
        (set! (-> s2-2 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-2 collide-with) (collide-kind target))
        (set! (-> s2-2 prim-core action) (collide-action solid attackable attackable-unused))
        (set! (-> s2-2 prim-core offense) (collide-offense touch))
        (set-vector! (-> s2-2 local-sphere) 0.0 11468.8 0.0 4505.6)
        (append-prim s3-0 s2-2)
        )
      (let ((s2-3 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 1))))
        (set! (-> s2-3 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-3 collide-with) (collide-kind target))
        (set! (-> s2-3 prim-core offense) (collide-offense normal-attack))
        (set! (-> s2-3 transform-index) 25)
        (set-vector! (-> s2-3 local-sphere) 0.0 0.0 4096.0 3276.8)
        (append-prim s3-0 s2-3)
        )
      (let ((s2-4 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 1))))
        (set! (-> s2-4 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-4 collide-with) (collide-kind target))
        (set! (-> s2-4 prim-core offense) (collide-offense normal-attack))
        (set! (-> s2-4 transform-index) 25)
        (set-vector! (-> s2-4 local-sphere) 0.0 0.0 5734.4 3686.4)
        (append-prim s3-0 s2-4)
        )
      (let ((s2-5 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 1))))
        (set! (-> s2-5 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-5 collide-with) (collide-kind target))
        (set! (-> s2-5 prim-core offense) (collide-offense normal-attack))
        (set! (-> s2-5 transform-index) 25)
        (set-vector! (-> s2-5 local-sphere) 0.0 0.0 9420.8 2457.6)
        (append-prim s3-0 s2-5)
        )
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> obj root-overeride) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *driller-lurker-sg* '())
  (set! (-> obj path) (new 'process 'curve-control obj 'path -1000000000.0))
  (logior! (-> obj path flags) (path-control-flag display draw-line draw-point draw-text))
  (if (< (-> obj path curve num-cverts) 2)
      (go process-drawable-art-error "bad path")
      )
  (set! (-> obj fact)
        (new 'process 'fact-info-enemy obj (pickup-type eco-pill-random) (-> *FACT-bank* default-pill-inc))
        )
  (set! (-> obj draw shadow-ctrl) *driller-lurker-shadow-control*)
  (set! (-> obj sound)
        (new 'process 'ambient-sound (static-sound-spec "drill-idle" :fo-max 40) (-> obj root-overeride trans))
        )
  (set! (-> obj sound2)
        (new 'process 'ambient-sound (static-sound-spec "drill-idle2" :fo-max 60) (-> obj root-overeride trans))
        )
  (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 331) obj))
  (let ((f0-34 (path-distance (-> obj path))))
    (set! (-> obj path-units-per-meter) (/ 4096.0 f0-34))
    )
  (set! (-> obj path-dir) 1.0)
  (set! (-> obj path-u) 0.0)
  (set! (-> obj path-speed) 15360.0)
  (set! (-> obj targ-path-speed) 15360.0)
  (set! (-> obj up-blend) 0.0)
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-91
          (res-lump-data
            arg0
            'driller-lurker
            (pointer float)
            :tag-ptr (the-as (pointer res-tag) (new 'stack-no-clear 'vector))
            )
          )
        )
    (when v1-91
      (set! (-> obj path-u) (fmax 0.0 (fmin 1.0 (-> v1-91 0))))
      (if (< (-> v1-91 1) 0.0)
          (set! (-> obj path-dir) -1.0)
          )
      (let ((f0-45 (-> v1-91 2)))
        (when (!= f0-45 12345.0)
          (let ((f30-0 (* 182.04445 f0-45)))
            (set! (-> obj ambient-drilling-u) (-> obj path-u))
            (quaternion-axis-angle! (-> obj root-overeride quat) 0.0 1.0 0.0 f30-0)
            (set! (-> obj facing-ry) f30-0)
            )
          )
        )
      )
    )
  (eval-path-curve! (-> obj path) (-> obj root-overeride trans) (-> obj path-u) 'interp)
  (let ((s5-1 (new 'stack-no-clear 'vector)))
    (path-control-method-14 (-> obj path) s5-1 (-> obj path-u))
    (let ((f0-51 (atan (-> s5-1 x) (-> s5-1 z))))
      (if (< (-> obj path-dir) 0.0)
          (set! f0-51 (+ 32768.0 f0-51))
          )
      (set! (-> obj path-ry) f0-51)
      (if (< (-> obj ambient-drilling-u) 0.0)
          (set! (-> obj facing-ry) f0-51)
          )
      )
    )
  (let ((v1-103 (new 'process 'joint-mod (joint-mod-handler-mode reset) obj 6)))
    (set! (-> obj neck) v1-103)
    (set-vector! (-> obj neck twist-max) 8192.0 8192.0 0.0 1.0)
    (set! (-> v1-103 up) (the-as uint 1))
    (set! (-> v1-103 nose) (the-as uint 2))
    (set! (-> v1-103 ear) (the-as uint 0))
    (set! (-> v1-103 max-dist) 102400.0)
    (set! (-> v1-103 ignore-angle) 16384.0)
    )
  (set! (-> obj drill) (new 'process 'joint-mod (joint-mod-handler-mode joint-set*) obj 38))
  (transform-post)
  (create-connection!
    *cavecrystal-light-control*
    obj
    (-> obj entity)
    (the-as (function object object object object object) cavecrystal-light-control-default-callback)
    -1
    8192.0
    )
  (if (>= (-> obj ambient-drilling-u) 0.0)
      (go driller-lurker-idle-drilling)
      (go driller-lurker-patrol)
      )
  (none)
  )
