;;-*-Lisp-*-
(in-package goal)

;; name: gnawer.gc
;; name in dgo: gnawer
;; dgos: L1, MAI, MAINCAVE

(declare-type gnawer process-drawable)


(define-extern gnawer-joint-callback (function gnawer none))

;; DECOMP BEGINS

(deftype gnawer-falling-segment (process-drawable)
  ((transv       vector  :inline)
   (facing-rot   vector  :inline)
   (facing-rotv  vector  :inline)
   )
  (:state-methods
    falling
    )
  )


(deftype gnawer-segment-info (structure)
  ((num-joints   int32)
   (joint-index  int8  8)
   )
  )


(deftype gnawer-segment (structure)
  ((place                       int32)
   (world-pos                   vector  :inline)
   (anim-to-local-trans-offset  vector  :inline)
   (orient-mat                  matrix  :inline)
   )
  )


(deftype gnawer-route (structure)
  ((src-pt-index       int32)
   (dest-pt-index      int32)
   (total-travel-time  time-frame)
   (src-ang            float)
   (dest-ang           float)
   (delta-ang          float)
   (surface-dist       float)
   (total-dist         float)
   (src-pt-offset      vector  :inline)
   (dest-pt-offset     vector  :inline)
   (surface-dir        vector  :inline)
   )
  )


(deftype gnawer (process-drawable)
  ((root            collide-shape  :override)
   (hit-points      int32)
   (gnawer-id       int32)
   (total-money     int32)
   (money-mask      uint32)
   (eco-green-mask  uint32)
   (hidden?         symbol)
   (show-damage?    symbol)
   (route-dist      float)
   (speed           float)
   (anim-speed      float)
   (part2           sparticle-launch-control)
   (sound2          ambient-sound)
   (last-hit-time   time-frame)
   (post-trans      vector          :inline)
   (fall-trans      vector          :inline)
   (route           gnawer-route    :inline)
   (segments        gnawer-segment  10 :inline)
   )
  (:methods
    (gnawer-method-20 (_type_ int) matrix)
    (gnawer-method-21 (_type_ int bounding-box symbol float) float)
    (gnawer-method-22 (_type_ float) symbol)
    (gnawer-method-23 (_type_) none)
    (gnawer-method-24 (_type_) none)
    (gnawer-method-25 (_type_) symbol)
    (gnawer-method-26 (_type_) none)
    (gnawer-method-27 (_type_) none)
    (gnawer-method-28 (_type_ int int) symbol)
    (gnawer-method-29 (_type_ int vector vector) float)
    (gnawer-method-30 (_type_ process-drawable) uint)
    )
  (:states
    gnawer-chewing-on-post
    gnawer-die
    gnawer-dying-give-pickups
    gnawer-give-fuel-cell
    gnawer-put-items-at-dest
    gnawer-retreat-into-post
    gnawer-run
    gnawer-wait-to-run
    )
  )


(defskelgroup *gnawer-sg* gnawer gnawer-lod0-jg -1
              ((gnawer-lod0-mg (meters 20)) (gnawer-lod1-mg (meters 40)) (gnawer-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 0.5 0 8)
              :longest-edge (meters 0.8)
              )

(defskelgroup *gnawer-segment-sg* gnawer gnawer-segment-lod0-jg -1
              ((gnawer-segment-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 2)
              )

(define *gnawer-segment-infos*
  (new 'static 'inline-array gnawer-segment-info 10
    (new 'static 'gnawer-segment-info
      :num-joints 8
      :joint-index (new 'static 'array int8 8 4 31 13 32 33 34 35 36)
      )
    (new 'static 'gnawer-segment-info :num-joints 3 :joint-index (new 'static 'array int8 8 5 14 15 0 0 0 0 0))
    (new 'static 'gnawer-segment-info :num-joints 3 :joint-index (new 'static 'array int8 8 6 16 17 0 0 0 0 0))
    (new 'static 'gnawer-segment-info :num-joints 3 :joint-index (new 'static 'array int8 8 7 18 19 0 0 0 0 0))
    (new 'static 'gnawer-segment-info :num-joints 3 :joint-index (new 'static 'array int8 8 8 20 21 0 0 0 0 0))
    (new 'static 'gnawer-segment-info :num-joints 3 :joint-index (new 'static 'array int8 8 9 22 23 0 0 0 0 0))
    (new 'static 'gnawer-segment-info :num-joints 3 :joint-index (new 'static 'array int8 8 10 24 25 0 0 0 0 0))
    (new 'static 'gnawer-segment-info :num-joints 3 :joint-index (new 'static 'array int8 8 11 26 27 0 0 0 0 0))
    (new 'static 'gnawer-segment-info :num-joints 3 :joint-index (new 'static 'array int8 8 12 28 29 0 0 0 0 0))
    (new 'static 'gnawer-segment-info :num-joints 1 :joint-index (new 'static 'array int8 8 30 0 0 0 0 0 0 0))
    )
  )

(defpartgroup group-gnawer-loses-segment
  :id 329
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 8)
  :parts ((sp-item 727 :binding 2309)
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2310)
    )
  )

(defpart 2310
  :init-specs ((:texture (new 'static 'texture-id :index #x12 :page #x2))
    (:num 2.0)
    (:scale-x (meters 16))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 64.0 128.0)
    (:g 0.0 32.0)
    (:b 192.0 128.0)
    (:a 128.0)
    (:fade-a -4.266667)
    (:timer (seconds 0.1))
    (:flags (bit2 bit3 bit14))
    )
  )

(defpart 727
  :init-specs ((:texture (new 'static 'texture-id :index #x1d :page #x2))
    (:num 16.0 16.0)
    (:scale-x (meters 0.25) (meters 0.25))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 32.0 64.0)
    (:g 0.0 16.0)
    (:b 96.0 64.0)
    (:a 128.0)
    (:vel-y (meters 0.02) (meters 0.04))
    (:rotvel-z (degrees -1.2) (degrees 1.2))
    (:fade-a -0.28444445)
    (:accel-y (meters -0.001) (meters -0.00066666666))
    (:friction 0.975)
    (:timer (seconds 1) (seconds 0.497))
    (:flags (bit2))
    (:conerot-x (degrees 45) (degrees 135))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 0) (meters 2))
    )
  )

(defpart 2309
  :init-specs ((:texture (new 'static 'texture-id :index #xb :page #x2))
    (:num 0.25 0.5)
    (:scale-x (meters 0.7) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 32.0 64.0)
    (:g 0.0 16.0)
    (:b 96.0 64.0)
    (:a 16.0 48.0)
    (:rotvel-z (degrees -0.2) (degrees 0.4))
    (:fade-a -0.42666668)
    (:accel-y (meters -0.00066666666))
    (:timer (seconds 0.5) (seconds 0.997))
    (:flags (bit2))
    )
  )

(defpartgroup group-gnawer-crumbs
  :id 330
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 8)
  :parts ((sp-item 2141 :fade-after (meters 60) :falloff-to (meters 60)))
  )

(defpart 2141
  :init-specs ((:texture (new 'static 'texture-id :index #x17 :page #x2))
    (:num 1.0 2.0)
    (:scale-x (meters 0.15) (meters 0.35))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 64.0 128.0)
    (:g 64.0 128.0)
    (:b 64.0 128.0)
    (:a 16.0 32.0)
    (:vel-y (meters 0.006666667) (meters 0.008333334))
    (:rotvel-z (degrees -1.2) (degrees 1.2))
    (:fade-a -0.16)
    (:accel-y (meters -0.00083333335))
    (:timer (seconds 0.7))
    (:flags (bit2))
    (:conerot-x (degrees 0) (degrees 180))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defstate falling (gnawer-falling-segment)
  :virtual #t
  :trans (behavior ()
    (+! (-> self transv y) (* -409600.0 (seconds-per-frame)))
    (vector-v+! (-> self root trans) (-> self root trans) (-> self transv))
    (+! (-> self facing-rot x) (* (-> self facing-rotv x) (seconds-per-frame)))
    (set! (-> self facing-rot z)
          (deg-seek (-> self facing-rot z) 16384.0 (* (-> self facing-rotv z) (seconds-per-frame)))
          )
    (quaternion-zxy! (-> self root quat) (-> self facing-rot))
    (seek! (-> self root scale x) 0.0 (* 0.5 (seconds-per-frame)))
    (set! (-> self root scale y) (-> self root scale x))
    (set! (-> self root scale z) (-> self root scale x))
    )
  :code (behavior ()
    (ja-channel-push! 1 0)
    (dotimes (gp-0 1)
      (ja-no-eval :group! gnawer-segment-idle-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (ja-no-eval :group! gnawer-segment-die-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    )
  :post ja-post
  )

(defbehavior gnawer-falling-segment-init-by-other gnawer-falling-segment ((arg0 gnawer) (arg1 vector) (arg2 vector))
  (set! (-> self entity) (-> arg0 entity))
  (logior! (-> self mask) (process-mask enemy))
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> arg1 quad))
  (vector-identity! (-> self root scale))
  (let ((s5-1 (new 'stack-no-clear 'vector)))
    (let ((s4-0 (new 'stack-no-clear 'vector)))
      (set-vector!
        s5-1
        (+ (-> arg2 x) (rand-vu-float-range -0.2 0.2))
        (+ (-> arg2 y) (rand-vu-float-range -0.2 0.2))
        (+ (-> arg2 z) (rand-vu-float-range -0.2 0.2))
        1.0
        )
      (vector-normalize! s5-1 1.0)
      (set-vector!
        s4-0
        (+ (-> arg2 x) (rand-vu-float-range -0.2 0.2))
        (+ (-> arg2 y) (rand-vu-float-range 0.0 0.4))
        (+ (-> arg2 z) (rand-vu-float-range -0.2 0.2))
        1.0
        )
      (vector-normalize! s4-0 1.0)
      (set-heading-vec-clear-roll-pitch! (-> self root) s5-1)
      (vector-float*! (-> self transv) s4-0 (rand-vu-float-range 20480.0 40960.0))
      )
    (rot-zxy-from-vector! (-> self facing-rot) s5-1)
    )
  (set-vector!
    (-> self facing-rotv)
    (rand-vu-float-range 5461.3335 16384.0)
    0.0
    (rand-vu-float-range 16384.0 36408.89)
    1.0
    )
  (initialize-skeleton self *gnawer-segment-sg* '())
  (go-virtual falling)
  (none)
  )

(defmethod gnawer-method-23 ((this gnawer))
  (when (not (-> this hidden?))
    (set! (-> this hidden?) #t)
    (logior! (-> this draw status) (draw-status hidden))
    (logclear! (-> this mask) (process-mask attackable))
    (set! (-> this skel postbind-function) #f)
    (set! (-> this root trans quad) (-> this post-trans quad))
    (clear-collide-with-as (-> this root))
    (dotimes (v1-12 10)
      (set! (-> this segments v1-12 world-pos quad) (-> this post-trans quad))
      )
    (set-vector! (-> this draw bounds) 0.0 0.0 0.0 12288.0)
    )
  (none)
  )

(defmethod gnawer-method-26 ((this gnawer))
  (when (-> this hidden?)
    (set! (-> this hidden?) #f)
    (restore-collide-with-as (-> this root))
    (set! (-> this skel postbind-function) gnawer-joint-callback)
    (logclear! (-> this draw status) (draw-status hidden))
    )
  (none)
  )

(defmethod gnawer-method-24 ((this gnawer))
  (local-vars (sv-48 vector) (sv-64 vector))
  (let ((s5-0 0)
        (s4-0 0)
        )
    (let ((f30-0 -1.0)
          (s3-0 (-> this path curve num-cverts))
          )
      (dotimes (s2-0 3)
        (let ((s1-0 (rand-vu-int-count s3-0))
              (s0-0 (rand-vu-int-count s3-0))
              )
          (when (= s1-0 s0-0)
            (set! s0-0 (rand-vu-int-count s3-0))
            (if (= s1-0 s0-0)
                (set! s0-0 (mod (+ s1-0 1) s3-0))
                )
            )
          (set! sv-48 (new 'stack-no-clear 'vector))
          (set! sv-64 (new 'stack-no-clear 'vector))
          (eval-path-curve-div! (-> this path) sv-48 (the float s1-0) 'interp)
          (eval-path-curve-div! (-> this path) sv-64 (the float s0-0) 'interp)
          (let ((f0-4 (vector-vector-distance sv-48 sv-64)))
            (when (< f30-0 f0-4)
              (set! f30-0 f0-4)
              (set! s5-0 s1-0)
              (set! s4-0 s0-0)
              )
            )
          )
        )
      )
    (set! (-> this route src-pt-index) s5-0)
    (set! (-> this route dest-pt-index) s4-0)
    )
  (let ((v1-13 (-> this route src-pt-index))
        (s5-1 (-> this route dest-pt-index))
        )
    (eval-path-curve-div! (-> this path) (-> this route src-pt-offset) (the float v1-13) 'interp)
    (eval-path-curve-div! (-> this path) (-> this route dest-pt-offset) (the float s5-1) 'interp)
    )
  (vector-! (-> this route src-pt-offset) (-> this route src-pt-offset) (-> this post-trans))
  (vector-! (-> this route dest-pt-offset) (-> this route dest-pt-offset) (-> this post-trans))
  (let ((f30-1 (-> this route src-pt-offset y)))
    (set! (-> this route src-pt-offset y) 0.0)
    (vector-normalize! (-> this route src-pt-offset) 10240.0)
    (set! (-> this route src-pt-offset y) f30-1)
    )
  (let ((f30-2 (-> this route dest-pt-offset y)))
    (set! (-> this route dest-pt-offset y) 0.0)
    (vector-normalize! (-> this route dest-pt-offset) 10240.0)
    (set! (-> this route dest-pt-offset y) f30-2)
    )
  (let ((f30-3 (atan (-> this route src-pt-offset x) (-> this route src-pt-offset z)))
        (f0-15 (atan (-> this route dest-pt-offset x) (-> this route dest-pt-offset z)))
        )
    (set! (-> this route src-ang) f30-3)
    (set! (-> this route dest-ang) f0-15)
    (let ((f30-4 (deg- f0-15 f30-3)))
      0.0
      (let* ((v0-13 (rand-vu-int-count 100))
             (f0-17 (cond
                      ((< v0-13 67)
                       131072.0
                       )
                      ((< v0-13 82)
                       196608.0
                       )
                      (else
                        65536.0
                        )
                      )
                    )
             )
        (set! (-> this route delta-ang) (if (>= f30-4 0.0)
                                            (- f30-4 f0-17)
                                            (+ f30-4 f0-17)
                                            )
              )
        )
      )
    )
  (let ((f30-5 (* 0.9817476 (-> this route delta-ang)))
        (f28-0 (- (-> this route dest-pt-offset y) (-> this route src-pt-offset y)))
        )
    (set-vector! (-> this route surface-dir) f30-5 f28-0 0.0 1.0)
    (vector-normalize! (-> this route surface-dir) 1.0)
    (let ((f0-25 (sqrtf (+ (* f30-5 f30-5) (* f28-0 f28-0)))))
      (set! (-> this route surface-dist) f0-25)
      (set! (-> this route total-dist) (+ 20480.0 f0-25))
      )
    )
  (set! (-> this route total-travel-time)
        (the-as time-frame (the int (/ (-> this route total-dist) (* 0.016666668 (-> this speed)))))
        )
  (none)
  )

(defmethod gnawer-method-22 ((this gnawer) (arg0 float))
  (let ((s4-0 (new 'stack-no-clear 'bounding-box))
        (a3-0 #t)
        (gp-0 #t)
        )
    (dotimes (s2-0 10)
      (let ((v1-4 (-> this segments s2-0 place)))
        (cond
          ((>= v1-4 0)
           (let ((f0-1 (- arg0 (* 3891.2 (the float v1-4)))))
             (cond
               ((< f0-1 0.0)
                (set! f0-1 0.0)
                (set! gp-0 #f)
                )
               ((>= f0-1 (-> this route total-dist))
                (set! f0-1 (-> this route total-dist))
                )
               (else
                 (set! gp-0 #f)
                 )
               )
             (gnawer-method-21 this s2-0 s4-0 a3-0 f0-1)
             )
           )
          (else
            (gnawer-method-20 this s2-0)
            )
          )
        )
      (set! a3-0 #f)
      )
    (set-vector!
      (-> this root trans)
      (* 0.5 (+ (-> s4-0 min x) (-> s4-0 max x)))
      (* 0.5 (+ (-> s4-0 min y) (-> s4-0 max y)))
      (* 0.5 (+ (-> s4-0 min z) (-> s4-0 max z)))
      1.0
      )
    (let* ((f0-10 (- (-> s4-0 max x) (-> this root trans x)))
           (f1-12 (- (-> s4-0 max y) (-> this root trans y)))
           (f2-7 (- (-> s4-0 max z) (-> this root trans z)))
           (f0-14 (sqrtf (+ (* f0-10 f0-10) (* f1-12 f1-12) (* f2-7 f2-7))))
           (a0-3 (-> this draw bounds))
           (v1-21 (-> this root root-prim))
           (f0-15 (+ 12288.0 f0-14))
           )
      (vector-reset! a0-3)
      (set! (-> a0-3 w) f0-15)
      (vector-reset! (-> v1-21 local-sphere))
      (set! (-> v1-21 local-sphere w) f0-15)
      (set! (-> v1-21 prim-core world-sphere quad) (-> this root trans quad))
      (set! (-> v1-21 prim-core world-sphere w) f0-15)
      )
    gp-0
    )
  )

(defmethod gnawer-method-21 ((this gnawer) (arg0 int) (arg1 bounding-box) (arg2 symbol) (arg3 float))
  (let ((gp-0 (-> this segments arg0)))
    (let ((f0-1 (+ 10240.0 (-> this route surface-dist))))
      (cond
        ((< arg3 10240.0)
         (let ((f0-3 (* 0.00009765625 arg3)))
           (vector-float*! (-> gp-0 world-pos) (-> this route src-pt-offset) f0-3)
           )
         (set! (-> gp-0 world-pos y) (-> this route src-pt-offset y))
         (vector+! (-> gp-0 world-pos) (-> gp-0 world-pos) (-> this post-trans))
         )
        ((< arg3 f0-1)
         (let* ((f30-0 (/ (+ -10240.0 arg3) (-> this route surface-dist)))
                (f28-0 (+ (* (-> this route delta-ang) f30-0) (-> this route src-ang)))
                )
           (set-vector!
             (-> gp-0 world-pos)
             (* 10240.0 (sin f28-0))
             (lerp (-> this route src-pt-offset y) (-> this route dest-pt-offset y) f30-0)
             (* 10240.0 (cos f28-0))
             1.0
             )
           )
         (vector+! (-> gp-0 world-pos) (-> gp-0 world-pos) (-> this post-trans))
         )
        (else
          (let ((f0-19 (- 1.0 (* 0.00009765625 (- arg3 f0-1)))))
            (vector-float*! (-> gp-0 world-pos) (-> this route dest-pt-offset) f0-19)
            )
          (set! (-> gp-0 world-pos y) (-> this route dest-pt-offset y))
          (vector+! (-> gp-0 world-pos) (-> gp-0 world-pos) (-> this post-trans))
          )
        )
      )
    (cond
      (arg2
        (set! (-> arg1 min quad) (-> gp-0 world-pos quad))
        (set! (-> arg1 max quad) (-> gp-0 world-pos quad))
        )
      (else
        (add-point! arg1 (the-as vector3s (-> gp-0 world-pos)))
        )
      )
    (let ((s4-1 (new 'stack-no-clear 'vector)))
      (vector-! s4-1 (-> gp-0 world-pos) (-> this post-trans))
      (set! (-> s4-1 y) 0.0)
      (vector-normalize! s4-1 1.0)
      (let ((f0-24 (atan (-> s4-1 x) (-> s4-1 z)))
            (s3-1 (new 'stack-no-clear 'vector))
            )
        (vector-rotate-around-y! s3-1 (-> this route surface-dir) f0-24)
        (set! (-> gp-0 orient-mat vector 1 quad) (-> s4-1 quad))
        (set! (-> gp-0 orient-mat vector 2 quad) (-> s3-1 quad))
        )
      )
    (vector-cross!
      (the-as vector (-> gp-0 orient-mat))
      (-> gp-0 orient-mat vector 1)
      (-> gp-0 orient-mat vector 2)
      )
    (vector-normalize! (the-as vector (-> gp-0 orient-mat)) 1.0)
    (set! (-> gp-0 orient-mat vector 0 w) 0.0)
    (set! (-> gp-0 orient-mat vector 1 w) 0.0)
    (set! (-> gp-0 orient-mat vector 2 w) 0.0)
    )
  )

(defmethod gnawer-method-20 ((this gnawer) (arg0 int))
  (let ((v1-3 (-> this segments arg0))
        (a0-1 (-> this segments (+ arg0 -1)))
        )
    (set! (-> v1-3 world-pos quad) (-> a0-1 world-pos quad))
    (let ((v0-0 (-> v1-3 orient-mat)))
      (let* ((a2-3 (-> a0-1 orient-mat))
             (v1-4 (-> a2-3 vector 0 quad))
             (a0-2 (-> a2-3 vector 1 quad))
             (a1-5 (-> a2-3 vector 2 quad))
             (a2-4 (-> a2-3 vector 3 quad))
             )
        (set! (-> v0-0 vector 0 quad) v1-4)
        (set! (-> v0-0 vector 1 quad) a0-2)
        (set! (-> v0-0 vector 2 quad) a1-5)
        (set! (-> v0-0 vector 3 quad) a2-4)
        )
      v0-0
      )
    )
  )

(defmethod gnawer-method-25 ((this gnawer))
  (dotimes (s5-0 3)
    (when (> (-> this hit-points) 0)
      (+! (-> this hit-points) -1)
      (+! (-> this speed) 4096.0)
      (when (> (-> this hit-points) 0)
        (set! (-> this show-damage?) #t)
        (let ((s4-0 (+ (-> this hit-points) 2)))
          (let ((s3-0 (-> this segments s4-0)))
            (let ((s1-0 (new 'stack-no-clear 'vector))
                  (s2-0 (-> s3-0 world-pos))
                  )
              (vector-! s1-0 s2-0 (-> this root trans))
              (set! (-> s1-0 y) 0.0)
              (vector-normalize! s1-0 1.0)
              (process-spawn gnawer-falling-segment this s2-0 s1-0 :to this)
              )
            (set! (-> s3-0 place) -1)
            )
          (while (< s4-0 10)
            (let ((v1-20 (-> this segments s4-0)))
              (if (>= (-> v1-20 place) 0)
                  (+! (-> v1-20 place) -1)
                  )
              )
            (+! s4-0 1)
            )
          )
        )
      )
    )
  (close-specific-task! (game-task cave-gnawers) (task-status need-hint))
  (<= (-> this hit-points) 0)
  )

(defmethod gnawer-method-28 ((this gnawer) (arg0 int) (arg1 int))
  (when (> arg0 0)
    (let* ((v1-1 (rand-vu-int-count arg0))
           (a0-2 v1-1)
           )
      (until (= a0-2 v1-1)
        (let ((a1-2 (ash 1 a0-2)))
          (if (not (logtest? a1-2 arg1))
              (return (the-as symbol a1-2))
              )
          )
        (set! a0-2 (mod (+ a0-2 1) arg0))
        )
      )
    )
  (the-as symbol 0)
  )

(defmethod gnawer-method-27 ((this gnawer))
  (set! (-> this eco-green-mask) (the-as uint 0))
  (let ((s4-0 (-> this path curve num-cverts))
        (s3-0 (get-death-count *game-info* #f))
        (s5-0 (-> this money-mask))
        )
    (when (and *target* (or (and (= s3-0 1) (and (>= 1.0 (-> *target* fact health)) (rand-vu-percent? 0.1)))
                            (and (< 1 s3-0) (and (>= 2.0 (-> *target* fact health)) (rand-vu-percent? 0.05)))
                            )
               )
      (let ((v1-14 (gnawer-method-28 this s4-0 (the-as int s5-0))))
        (logior s5-0 (the-as uint v1-14))
        (set! (-> this eco-green-mask) (the-as uint (logior (-> this eco-green-mask) (the-as uint v1-14))))
        )
      )
    )
  (none)
  )

(defmethod gnawer-method-29 ((this gnawer) (arg0 int) (arg1 vector) (arg2 vector))
  (let ((s1-0 (-> this path curve num-cverts))
        (s2-0 (new 'stack-no-clear 'vector))
        )
    0.0
    0.0
    (eval-path-curve-div! (-> this path) s2-0 0.0 'interp)
    (let* ((f30-0 (-> s2-0 y))
           (f28-0 f30-0)
           )
      (eval-path-curve-div! (-> this path) s2-0 (the float (+ s1-0 -1)) 'interp)
      (let ((f30-1 (fmin f30-0 (-> s2-0 y)))
            (f28-1 (fmax f28-0 (-> s2-0 y)))
            )
        (eval-path-curve-div! (-> this path) arg1 (the float arg0) 'interp)
        (vector-! arg2 arg1 (-> this post-trans))
        (let ((f0-9 (+ 16384.0 (* 16384.0 (/ (fmax 0.0 (- (-> arg2 y) f30-1)) (- f28-1 f30-1))))))
          (set! (-> arg2 y) 0.0)
          (vector-normalize! arg2 f0-9)
          )
        )
      )
    )
  (vector+! arg2 arg2 (-> this post-trans))
  (set! (-> arg2 y) (+ 4096.0 (-> arg2 y)))
  )

(defmethod gnawer-method-30 ((this gnawer) (arg0 process-drawable))
  (local-vars (sv-48 vector))
  (let ((gp-0 (-> this entity extra perm)))
    (logior! (-> gp-0 status) (entity-perm-status user-set-from-cstage))
    (let ((s5-0 (-> gp-0 user-uint16 0))
          (s2-0 -1)
          )
      (let ((f30-0 0.0)
            (s1-0 (-> this path curve num-cverts))
            )
        (dotimes (s0-0 s1-0)
          (when (logtest? (ash 1 s0-0) s5-0)
            (let ((a2-0 (new 'stack-no-clear 'vector)))
              (set! sv-48 (new 'stack-no-clear 'vector))
              (gnawer-method-29 this s0-0 a2-0 sv-48)
              )
            (let* ((t9-1 vector-vector-xz-distance)
                   (a1-2 (-> arg0 root trans))
                   (f0-0 (t9-1 sv-48 a1-2))
                   )
              (when (or (< s2-0 0) (< f0-0 f30-0))
                (set! s2-0 s0-0)
                (set! f30-0 f0-0)
                )
              )
            )
          )
        )
      (when (>= s2-0 0)
        (let ((v0-2 (logxor s5-0 (the-as uint (ash 1 s2-0)))))
          (set! (-> gp-0 user-int16 0) (the-as int v0-2))
          v0-2
          )
        )
      )
    )
  )

(defstate gnawer-chewing-on-post (gnawer)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch)
       (if (= (-> proc type) target)
           (send-event
             proc
             'shove
             (-> block param 0)
             (static-attack-info ((shove-up (meters 1.5)) (shove-back (meters 2.5))))
             )
           )
       (go gnawer-retreat-into-post)
       )
      (('attack)
       (sound-play "gnawer-dies" :pitch -0.25)
       (go gnawer-retreat-into-post)
       )
      )
    )
  :exit (behavior ()
    (stop! (-> self sound2))
    )
  :trans (behavior ()
    (if (and *target* (>= 81920.0 (vector-vector-distance (target-pos 0) (-> self root trans))))
        (go gnawer-retreat-into-post)
        )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.075))
    (if (zero? (rand-vu-int-count 2))
        (ja :group! gnawer-tear-side-to-side-ja
            :num! (identity (rand-vu-float-range 0.0 (the float (+ (-> (ja-group) data 0 length) -1))))
            )
        (ja :group! gnawer-tug-ja
            :num! (identity (rand-vu-float-range 0.0 (the float (+ (-> (ja-group) data 0 length) -1))))
            )
        )
    (ja-no-eval :num! (seek!))
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (loop
      (let ((gp-2 (rand-vu-int-range 1 2))
            (s4-0 (rand-vu-int-range 1 2))
            )
        (dotimes (s5-0 gp-2)
          (dotimes (s3-0 s4-0)
            (set! (-> self anim-speed) (rand-vu-float-range 0.8 1.0))
            (ja-channel-push! 1 (seconds 0.075))
            (ja-no-eval :group! gnawer-tear-side-to-side-ja :num! (seek! max (-> self anim-speed)) :frame-num 0.0)
            (until (ja-done? 0)
              (suspend)
              (ja :num! (seek! max (-> self anim-speed)))
              )
            )
          (set! s4-0 (rand-vu-int-range 1 2))
          (dotimes (s3-1 s4-0)
            (set! (-> self anim-speed) (rand-vu-float-range 0.8 1.0))
            (ja-channel-push! 1 (seconds 0.075))
            (ja-no-eval :group! gnawer-tug-ja :num! (seek! max (-> self anim-speed)) :frame-num 0.0)
            (until (ja-done? 0)
              (suspend)
              (ja :num! (seek! max (-> self anim-speed)))
              )
            )
          )
        )
      (ja-channel-push! 1 (seconds 0.075))
      (ja-no-eval :group! gnawer-up-to-chew-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (let ((gp-3 (new 'stack-no-clear 'vector)))
          (vector<-cspace! gp-3 (joint-node gnawer-lod0-jg nandibleR))
          (spawn (-> self part2) gp-3)
          )
        (let ((gp-4 (new 'stack-no-clear 'vector)))
          (vector<-cspace! gp-4 (joint-node gnawer-lod0-jg mandibleL))
          (spawn (-> self part2) gp-4)
          )
        (suspend)
        (ja :num! (seek!))
        )
      (let ((gp-5 (rand-vu-int-range 1 4)))
        (set! (-> self anim-speed) (rand-vu-float-range 0.8 1.0))
        (dotimes (s5-1 gp-5)
          (ja-channel-push! 1 (seconds 0.075))
          (ja-no-eval :group! gnawer-chew-ja :num! (seek! max (-> self anim-speed)) :frame-num 0.0)
          (until (ja-done? 0)
            (let ((s4-1 (new 'stack-no-clear 'vector)))
              (vector<-cspace! s4-1 (joint-node gnawer-lod0-jg nandibleR))
              (spawn (-> self part2) s4-1)
              )
            (let ((s4-2 (new 'stack-no-clear 'vector)))
              (vector<-cspace! s4-2 (joint-node gnawer-lod0-jg mandibleL))
              (spawn (-> self part2) s4-2)
              )
            (update! (-> self sound2))
            (suspend)
            (ja :num! (seek! max (-> self anim-speed)))
            )
          )
        )
      (stop! (-> self sound2))
      (ja-no-eval :group! gnawer-down-from-chew-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    )
  :post transform-post
  )

(defstate gnawer-retreat-into-post (gnawer)
  :exit (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    )
  :code (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    (ja-channel-push! 1 (seconds 0.075))
    (ja-no-eval :group! gnawer-notice-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (quaternion-identity! (-> self root quat))
    (go gnawer-wait-to-run)
    )
  :post transform-post
  )

(defstate gnawer-wait-to-run (gnawer)
  :code (behavior ()
    (set! (-> self draw origin-joint-index) (the-as uint 0))
    (gnawer-method-23 self)
    (set-time! (-> self state-time))
    (let ((gp-0 (rand-vu-int-range 240 360)))
      (until (time-elapsed? (-> self state-time) gp-0)
        (suspend)
        )
      )
    (go gnawer-run)
    )
  )

(defstate gnawer-run (gnawer)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (v0-0 object))
    (case message
      (('touch)
       (if (= (-> proc type) target)
           (send-event
             proc
             'shove
             (-> block param 0)
             (static-attack-info ((shove-up (meters 1.5)) (shove-back (meters 2.5))))
             )
           )
       )
      (('attack)
       (cond
         ((= (-> proc type) target)
          (send-event
            proc
            'attack
            (-> block param 0)
            (static-attack-info ((shove-up (meters 1.5)) (shove-back (meters 2.5))))
            )
          )
         (else
           (if (not (time-elapsed? (-> self last-hit-time) (seconds 0.5)))
               (return #f)
               )
           (let* ((a2-1 (the-as object (-> block param 0)))
                  (v1-19 (-> (get-touched-prim
                               (-> (the-as touching-shapes-entry a2-1) head)
                               (-> self root)
                               (the-as touching-shapes-entry a2-1)
                               )
                             prim-id
                             )
                         )
                  (v1-22 (-> self segments v1-19))
                  )
             (spawn (-> self part) (-> v1-22 world-pos))
             )
           (if (gnawer-method-25 self)
               (go gnawer-die)
               )
           (return #t)
           v0-0
           )
         )
       )
      )
    )
  :enter (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    (set! (-> self route-dist) 0.0)
    (gnawer-method-24 self)
    (set-time! (-> self last-hit-time))
    (gnawer-method-26 self)
    )
  :exit (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    (stop! (-> self sound))
    )
  :trans (behavior ()
    (+! (-> self route-dist) (* (-> self speed) (seconds-per-frame)))
    (if (gnawer-method-22 self (-> self route-dist))
        (go gnawer-wait-to-run)
        )
    (update! (-> self sound))
    )
  :code (behavior ()
    (local-vars (v1-19 symbol) (v1-35 symbol))
    (ja-channel-set! 1)
    (ja :group! gnawer-run-ja :num! min)
    (ja-no-eval :num! (seek!))
    (loop
      (until v1-19
        (suspend)
        (ja :num! (seek!))
        (set! v1-19 (or (ja-done? 0) (-> self show-damage?)))
        )
      (when (-> self show-damage?)
        (until (not (-> self show-damage?))
          (set! (-> self show-damage?) #f)
          (ja-channel-push! 1 (seconds 0.1))
          (ja :group! gnawer-takes-hit-ja :num! min)
          (until v1-35
            (suspend)
            (ja :num! (seek!))
            (set! v1-35 (or (ja-done? 0) (-> self show-damage?)))
            )
          )
        (ja-channel-push! 1 (seconds 0.1))
        )
      (ja :group! gnawer-run-ja :num! min)
      )
    )
  :post transform-post
  )

(defstate gnawer-die (gnawer)
  :enter (behavior ()
    (let ((v1-0 (-> self segments)))
      (set! (-> self fall-trans quad) (-> v1-0 0 world-pos quad))
      (vector-! (-> self root transv) (-> v1-0 0 world-pos) (-> self post-trans))
      )
    (set! (-> self root transv y) 0.0)
    (vector-normalize! (-> self root transv) 1.0)
    (set! (-> self root transv y) 0.3)
    (vector-normalize! (-> self root transv) 32768.0)
    )
  :trans (behavior ()
    (+! (-> self root transv y) (* -409600.0 (seconds-per-frame)))
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (set! (-> gp-0 quad) (-> self fall-trans quad))
      (vector-v+! (-> self fall-trans) (-> self fall-trans) (-> self root transv))
      (vector-! gp-0 (-> self fall-trans) gp-0)
      (dotimes (v1-6 10)
        (let ((a1-3 (-> self segments v1-6)))
          (vector+! (-> a1-3 world-pos) (-> a1-3 world-pos) gp-0)
          )
        )
      (vector+! (-> self root trans) (-> self root trans) gp-0)
      )
    (spool-push *art-control* "maincavecam-gnawer-fuel-cell" 0 self -1.0)
    )
  :code (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    (process-entity-status! self (entity-perm-status bit-3) #t)
    (ja-channel-push! 1 (seconds 0.1))
    (clear-collide-with-as (-> self root))
    (ja-no-eval :group! gnawer-die-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go gnawer-dying-give-pickups)
    )
  :post ja-post
  )

(defstate gnawer-dying-give-pickups (gnawer)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('notify)
       (if (and (= (-> proc type) money) (= (-> block param 0) 'pickup))
           (gnawer-method-30 self (the-as process-drawable proc))
           )
       )
      )
    )
  :trans (behavior ()
    (spool-push *art-control* "maincavecam-gnawer-fuel-cell" 0 self -1.0)
    )
  :code (behavior ()
    (local-vars (sv-128 symbol))
    (clear-collide-with-as (-> self root))
    (set! (-> self skel postbind-function) #f)
    (ja-channel-set! 0)
    (ja-post)
    (logior! (-> self draw status) (draw-status hidden))
    (process-entity-status! self (entity-perm-status complete) #t)
    (gnawer-method-27 self)
    (let ((v1-10 (-> self entity extra perm)))
      (logior! (-> v1-10 status) (entity-perm-status user-set-from-cstage))
      (set! (-> v1-10 user-int16 0) (the-as int (-> self money-mask)))
      )
    (dotimes (gp-0 (-> self path curve num-cverts))
      (let ((s4-0 (new 'stack-no-clear 'vector))
            (s5-0 (new 'stack-no-clear 'vector))
            )
        (gnawer-method-29 self gp-0 s4-0 s5-0)
        (let ((a1-2 7))
          (let ((v1-14 (ash 1 gp-0)))
            (cond
              ((logtest? v1-14 (-> self eco-green-mask))
               (set! a1-2 4)
               )
              ((logtest? v1-14 (-> self money-mask))
               (set! a1-2 5)
               )
              )
            )
          (let ((v1-19 (birth-pickup-at-point s4-0 (the-as pickup-type a1-2) 1.0 #f self (the-as fact-info #f))))
            (send-event (ppointer->process v1-19) 'jump s5-0)
            )
          )
        )
      (set-time! (-> self state-time))
      (until (time-elapsed? (-> self state-time) (seconds 0.05))
        (suspend)
        )
      )
    (set! sv-128 (the-as symbol #f))
    (apply-all (-> self link) actor-link-subtask-complete-hook (& sv-128))
    (when sv-128
      (save-reminder (get-task-control (game-task cave-gnawers)) (-> self gnawer-id) 3)
      (go gnawer-give-fuel-cell)
      )
    (set! (-> self trans-hook) #f)
    (process-entity-status! self (entity-perm-status bit-3) #f)
    (logior! (-> self mask) (process-mask actor-pause))
    (until (not (-> self child))
      (suspend)
      )
    (cleanup-for-death self)
    )
  )

(defstate gnawer-give-fuel-cell (gnawer)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('notify)
       (cond
         ((and (= (-> proc type) maincavecam) (= (-> block param 0) 'die))
          (process-entity-status! self (entity-perm-status bit-3) #f)
          (let ((v0-0 (the-as uint (logior (-> self mask) (process-mask actor-pause)))))
            (set! (-> self mask) (the-as process-mask v0-0))
            v0-0
            )
          )
         ((and (= (-> proc type) money) (= (-> block param 0) 'pickup))
          (gnawer-method-30 self (the-as process-drawable proc))
          )
         )
       )
      )
    )
  :code (behavior ()
    (when (not (task-complete? *game-info* (-> self entity extra perm task)))
      (spool-push *art-control* "maincavecam-gnawer-fuel-cell" 0 self -1.0)
      (logclear! (-> self mask) (process-mask actor-pause))
      (process-entity-status! self (entity-perm-status bit-3) #t)
      (let ((gp-0 (new 'stack-no-clear 'vector)))
        (set-vector! gp-0 4503813.0 46363.85 -12796366.0 1.0)
        (let ((s5-0 (the-as maincavecam (get-process *default-dead-pool* maincavecam #x4000))))
          (set! (-> (the-as
                      maincavecam
                      (-> (when s5-0
                            (let ((t9-4 (method-of-type maincavecam activate)))
                              (t9-4 s5-0 self 'maincavecam (the-as pointer #x70004000))
                              )
                            (run-now-in-process
                              s5-0
                              pov-camera-init-by-other
                              gp-0
                              *maincavecam-sg*
                              (new 'static 'spool-anim :name "maincavecam-gnawer-fuel-cell" :index 3 :parts 1 :command-list '())
                              0
                              self
                              '()
                              )
                            (-> s5-0 ppointer)
                            )
                          0
                          )
                      )
                    seq
                    )
                (the-as uint 0)
                )
          )
        )
      0
      (sound-play "cell-prize")
      (until (not (-> self child))
        (suspend)
        )
      )
    (process-entity-status! self (entity-perm-status bit-3) #f)
    (logior! (-> self mask) (process-mask actor-pause))
    (cleanup-for-death self)
    )
  )

(defstate gnawer-put-items-at-dest (gnawer)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('notify)
       (if (and (= (-> proc type) money) (= (-> block param 0) 'pickup))
           (gnawer-method-30 self (the-as process-drawable proc))
           )
       )
      )
    )
  :code (behavior ()
    (set! (-> self draw origin-joint-index) (the-as uint 0))
    (clear-collide-with-as (-> self root))
    (set! (-> self skel postbind-function) #f)
    (ja-channel-set! 0)
    (ja-post)
    (logior! (-> self draw status) (draw-status hidden))
    (case (get-reminder (get-task-control (game-task cave-gnawers)) 3)
      (((-> self gnawer-id))
       (when (not (task-complete? *game-info* (-> self entity extra perm task)))
         (let ((a0-7 (new 'stack-no-clear 'vector)))
           (set-vector! a0-7 4485903.0 51184.027 -12815461.0 1.0)
           (birth-pickup-at-point
             a0-7
             (pickup-type fuel-cell)
             (the float (-> self entity extra perm task))
             #f
             self
             (the-as fact-info #f)
             )
           )
         )
       )
      )
    (let ((gp-0 (-> self entity extra perm user-uint16 0)))
      (when (nonzero? gp-0)
        (let ((s5-0 (-> self path curve num-cverts)))
          (dotimes (s4-0 s5-0)
            (when (logtest? (ash 1 s4-0) gp-0)
              (let ((a2-1 (new 'stack-no-clear 'vector))
                    (s3-0 (new 'stack-no-clear 'vector))
                    )
                (gnawer-method-29 self s4-0 a2-1 s3-0)
                (birth-pickup-at-point s3-0 (pickup-type money) 1.0 #f self (the-as fact-info #f))
                )
              )
            )
          )
        )
      )
    (until (not (-> self child))
      (suspend)
      )
    (cleanup-for-death self)
    )
  )

(defun gnawer-joint-callback ((arg0 gnawer))
  (dotimes (s5-0 10)
    (let* ((v1-1 (-> *gnawer-segment-infos* s5-0))
           (s4-0 (-> arg0 segments s5-0))
           (s3-0 (-> v1-1 joint-index))
           )
      (countdown (s2-0 (-> v1-1 num-joints))
        (let ((s1-0 (-> arg0 node-list data (-> s3-0 0) bone transform)))
          (vector-! (-> s1-0 vector 3) (-> s1-0 vector 3) (-> arg0 root trans))
          (vector+! (-> s1-0 vector 3) (-> s1-0 vector 3) (-> s4-0 anim-to-local-trans-offset))
          (matrix*! s1-0 s1-0 (-> s4-0 orient-mat))
          (vector+! (-> s1-0 vector 3) (-> s1-0 vector 3) (-> s4-0 world-pos))
          )
        (set! s3-0 (&-> s3-0 1))
        )
      )
    )
  0
  (none)
  )

(defmethod deactivate ((this gnawer))
  (if (nonzero? (-> this part2))
      (kill-and-free-particles (-> this part2))
      )
  (if (nonzero? (-> this sound2))
      (stop! (-> this sound2))
      )
  ((method-of-type process-drawable deactivate) this)
  (none)
  )

(defmethod relocate ((this gnawer) (arg0 int))
  (if (nonzero? (-> this part2))
      (&+! (-> this part2) arg0)
      )
  (if (nonzero? (-> this sound2))
      (&+! (-> this sound2) arg0)
      )
  (call-parent-method this arg0)
  )

(defmethod init-from-entity! ((this gnawer) (arg0 entity-actor))
  (local-vars (sv-16 res-tag) (sv-32 res-tag) (sv-48 res-tag))
  (set! (-> this hidden?) #f)
  (set! (-> this show-damage?) #f)
  (set! (-> this hit-points) 6)
  (set! (-> this speed) 24576.0)
  (set! (-> this last-hit-time) 0)
  (set! (-> this route-dist) 0.0)
  (logclear! (-> this mask) (process-mask attackable))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 8) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set-vector! (-> s3-0 local-sphere) 0.0 32768.0 0.0 53248.0)
      (set-root-prim! s4-0 s3-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 2))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core offense) (collide-offense no-offense))
        (set! (-> s2-0 transform-index) 13)
        (set-vector! (-> s2-0 local-sphere) 0.0 0.0 0.0 6144.0)
        (append-prim s3-0 s2-0)
        )
      (let ((s2-1 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 2))))
        (set! (-> s2-1 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-1 collide-with) (collide-kind target))
        (set! (-> s2-1 prim-core offense) (collide-offense no-offense))
        (set! (-> s2-1 transform-index) 6)
        (set-vector! (-> s2-1 local-sphere) 0.0 0.0 0.0 6144.0)
        (append-prim s3-0 s2-1)
        )
      (let ((s2-2 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 3))))
        (set! (-> s2-2 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-2 collide-with) (collide-kind target))
        (set! (-> s2-2 prim-core offense) (collide-offense no-offense))
        (set! (-> s2-2 transform-index) 7)
        (set-vector! (-> s2-2 local-sphere) 0.0 -409.6 1228.8 6144.0)
        (append-prim s3-0 s2-2)
        )
      (let ((s2-3 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 4))))
        (set! (-> s2-3 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-3 collide-with) (collide-kind target))
        (set! (-> s2-3 prim-core offense) (collide-offense no-offense))
        (set! (-> s2-3 transform-index) 8)
        (set-vector! (-> s2-3 local-sphere) 0.0 0.0 0.0 6144.0)
        (append-prim s3-0 s2-3)
        )
      (let ((s2-4 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 5))))
        (set! (-> s2-4 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-4 collide-with) (collide-kind target))
        (set! (-> s2-4 prim-core offense) (collide-offense no-offense))
        (set! (-> s2-4 transform-index) 9)
        (set-vector! (-> s2-4 local-sphere) 0.0 0.0 0.0 6144.0)
        (append-prim s3-0 s2-4)
        )
      (let ((s2-5 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 6))))
        (set! (-> s2-5 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-5 collide-with) (collide-kind target))
        (set! (-> s2-5 prim-core offense) (collide-offense no-offense))
        (set! (-> s2-5 transform-index) 10)
        (set-vector! (-> s2-5 local-sphere) 0.0 0.0 0.0 6144.0)
        (append-prim s3-0 s2-5)
        )
      (let ((s2-6 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 7))))
        (set! (-> s2-6 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-6 collide-with) (collide-kind target))
        (set! (-> s2-6 prim-core offense) (collide-offense no-offense))
        (set! (-> s2-6 transform-index) 11)
        (set-vector! (-> s2-6 local-sphere) 0.0 0.0 0.0 6144.0)
        (append-prim s3-0 s2-6)
        )
      (let ((s2-7 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 7))))
        (set! (-> s2-7 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-7 collide-with) (collide-kind target))
        (set! (-> s2-7 prim-core offense) (collide-offense no-offense))
        (set! (-> s2-7 transform-index) 12)
        (set-vector! (-> s2-7 local-sphere) 0.0 0.0 0.0 6144.0)
        (append-prim s3-0 s2-7)
        )
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (quaternion-identity! (-> this root quat))
  (initialize-skeleton this *gnawer-sg* '())
  (set! (-> this draw origin-joint-index) (the-as uint 8))
  (set! (-> this post-trans quad) (-> this root trans quad))
  (let ((f0-40 (res-lump-float (-> this entity) 'rotoffset)))
    (quaternion-rotate-y! (-> this root quat) (-> this root quat) f0-40)
    )
  (+! (-> this root trans y) -2048.0)
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-81 (res-lump-data arg0 'trans-offset (pointer float) :tag-ptr (& sv-16))))
    (when v1-81
      (+! (-> this root trans x) (-> v1-81 0))
      (+! (-> this root trans y) (-> v1-81 1))
      (+! (-> this root trans z) (-> v1-81 2))
      )
    )
  (set! (-> this path) (new 'process 'curve-control this 'path -1000000000.0))
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (if (< (-> this path curve num-cverts) 2)
      (go process-drawable-art-error "bad path")
      )
  (set! (-> this part2) (create-launch-control (-> *part-group-id-table* 330) this))
  (set! (-> this total-money) 0)
  (set! (-> this money-mask) (the-as uint 0))
  (set! sv-32 (new 'static 'res-tag))
  (let ((v1-96 (res-lump-data arg0 'extra-count (pointer int32) :tag-ptr (& sv-32))))
    (when v1-96
      (case (-> v1-96 0)
        ((5)
         (set! (-> this total-money) (-> v1-96 1))
         )
        )
      )
    )
  (when (> (-> this total-money) 0)
    (set! sv-48 (new 'static 'res-tag))
    (let ((a0-49 (res-lump-data arg0 'gnawer (pointer int32) :tag-ptr (& sv-48))))
      (cond
        (a0-49
          (let ((v1-100 0))
            (dotimes (a1-30 (-> this total-money))
              (let ((a3-15 (-> a0-49 a1-30)))
                (set! v1-100 (logior v1-100 (ash 1 a3-15)))
                )
              )
            (set! (-> this money-mask) (the-as uint v1-100))
            )
          )
        (else
          (go process-drawable-art-error "bad actor params")
          )
        )
      )
    )
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 329) this))
  (set! (-> this sound)
        (new 'process 'ambient-sound (static-sound-spec "gnawer-crawl" :fo-min 30 :fo-max 30) (-> this root trans))
        )
  (set! (-> this sound2)
        (new 'process 'ambient-sound (static-sound-spec "gnawer-chew" :fo-max 40) (-> this root trans))
        )
  (dotimes (v1-110 10)
    (let ((a0-59 (-> this segments v1-110)))
      (set! (-> a0-59 place) v1-110)
      (set! (-> a0-59 world-pos quad) (-> this post-trans quad))
      (vector-reset! (-> a0-59 anim-to-local-trans-offset))
      (+! (-> a0-59 anim-to-local-trans-offset z) (* 5447.68 (the float v1-110)))
      )
    )
  (logior! (-> this skel status) (janim-status inited))
  (set! (-> this link) (new 'process 'actor-link-info this))
  (set! (-> this gnawer-id) (+ (actor-count-before (-> this link)) 1))
  (if (and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status complete)))
      (go gnawer-put-items-at-dest)
      (go gnawer-chewing-on-post)
      )
  (none)
  )
