;;-*-Lisp-*-
(in-package goal)

;; name: gnawer.gc
;; name in dgo: gnawer
;; dgos: L1, MAI, MAINCAVE

(declare-type gnawer process-drawable)


(define-extern gnawer-joint-callback (function gnawer none))

;; DECOMP BEGINS

(import "goal_src/jak1/import/gnawer-ag.gc")

(deftype gnawer-falling-segment (process-drawable)
  ((transv      vector :inline :offset-assert 176)
   (facing-rot  vector :inline :offset-assert 192)
   (facing-rotv vector :inline :offset-assert 208)
   )
  :heap-base #x70
  :method-count-assert 21
  :size-assert         #xe0
  :flag-assert         #x15007000e0
  (:methods
    (falling () _type_ :state 20)
    )
  )


(deftype gnawer-segment-info (structure)
  ((num-joints  int32   :offset-assert   0)
   (joint-index int8  8 :offset-assert   4)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )


(deftype gnawer-segment (structure)
  ((place                      int32          :offset-assert   0)
   (world-pos                  vector :inline :offset-assert  16)
   (anim-to-local-trans-offset vector :inline :offset-assert  32)
   (orient-mat                 matrix :inline :offset-assert  48)
   )
  :method-count-assert 9
  :size-assert         #x70
  :flag-assert         #x900000070
  )


(deftype gnawer-route (structure)
  ((src-pt-index      int32              :offset-assert   0)
   (dest-pt-index     int32              :offset-assert   4)
   (total-travel-time time-frame         :offset-assert   8)
   (src-ang           float              :offset-assert  16)
   (dest-ang          float              :offset-assert  20)
   (delta-ang         float              :offset-assert  24)
   (surface-dist      float              :offset-assert  28)
   (total-dist        float              :offset-assert  32)
   (src-pt-offset     vector     :inline :offset-assert  48)
   (dest-pt-offset    vector     :inline :offset-assert  64)
   (surface-dir       vector     :inline :offset-assert  80)
   )
  :method-count-assert 9
  :size-assert         #x60
  :flag-assert         #x900000060
  )


(deftype gnawer (process-drawable)
  ((root-override  collide-shape                       :offset        112)
   (hit-points     int32                               :offset-assert 176)
   (gnawer-id      int32                               :offset-assert 180)
   (total-money    int32                               :offset-assert 184)
   (money-mask     uint32                              :offset-assert 188)
   (eco-green-mask uint32                              :offset-assert 192)
   (hidden?        symbol                              :offset-assert 196)
   (show-damage?   symbol                              :offset-assert 200)
   (route-dist     float                               :offset-assert 204)
   (speed          float                               :offset-assert 208)
   (anim-speed     float                               :offset-assert 212)
   (part2          sparticle-launch-control            :offset-assert 216)
   (sound2         ambient-sound                       :offset-assert 220)
   (last-hit-time  time-frame                          :offset-assert 224)
   (post-trans     vector                   :inline    :offset-assert 240)
   (fall-trans     vector                   :inline    :offset-assert 256)
   (route          gnawer-route             :inline    :offset-assert 272)
   (segments       gnawer-segment           10 :inline :offset-assert 368)
   )
  :heap-base #x560
  :method-count-assert 31
  :size-assert         #x5d0
  :flag-assert         #x1f056005d0
  (:methods
    (gnawer-method-20 (_type_ int) matrix 20)
    (gnawer-method-21 (_type_ int bounding-box symbol float) float 21)
    (gnawer-method-22 (_type_ float) symbol 22)
    (gnawer-method-23 (_type_) none 23)
    (gnawer-method-24 (_type_) none 24)
    (gnawer-method-25 (_type_) symbol 25)
    (gnawer-method-26 (_type_) none 26)
    (gnawer-method-27 (_type_) none 27)
    (gnawer-method-28 (_type_ int int) symbol 28)
    (gnawer-method-29 (_type_ int vector vector) float 29)
    (gnawer-method-30 (_type_ process-drawable) uint 30)
    )
  (:states
    gnawer-chewing-on-post
    gnawer-die
    gnawer-dying-give-pickups
    gnawer-give-fuel-cell
    gnawer-put-items-at-dest
    gnawer-retreat-into-post
    gnawer-run
    gnawer-wait-to-run
    )
  )


(defskelgroup *gnawer-sg* gnawer gnawer-lod0-jg -1
              ((gnawer-lod0-mg (meters 20)) (gnawer-lod1-mg (meters 40)) (gnawer-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 0.5 0 8)
              :longest-edge (meters 0.8)
              )

(defskelgroup *gnawer-segment-sg* gnawer gnawer-segment-lod0-jg -1
              ((gnawer-segment-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 2)
              )

(define *gnawer-segment-infos*
  (new 'static 'inline-array gnawer-segment-info 10
    (new 'static 'gnawer-segment-info
      :num-joints 8
      :joint-index (new 'static 'array int8 8 4 #x1f #xd #x20 #x21 #x22 #x23 #x24)
      )
    (new 'static 'gnawer-segment-info :num-joints 3 :joint-index (new 'static 'array int8 8 5 #xe #xf 0 0 0 0 0))
    (new 'static 'gnawer-segment-info
      :num-joints 3
      :joint-index (new 'static 'array int8 8 #x6 #x10 #x11 0 0 0 0 0)
      )
    (new 'static 'gnawer-segment-info
      :num-joints 3
      :joint-index (new 'static 'array int8 8 #x7 #x12 #x13 0 0 0 0 0)
      )
    (new 'static 'gnawer-segment-info
      :num-joints 3
      :joint-index (new 'static 'array int8 8 #x8 #x14 #x15 0 0 0 0 0)
      )
    (new 'static 'gnawer-segment-info
      :num-joints 3
      :joint-index (new 'static 'array int8 8 #x9 #x16 #x17 0 0 0 0 0)
      )
    (new 'static 'gnawer-segment-info
      :num-joints 3
      :joint-index (new 'static 'array int8 8 #xa #x18 #x19 0 0 0 0 0)
      )
    (new 'static 'gnawer-segment-info
      :num-joints 3
      :joint-index (new 'static 'array int8 8 #xb #x1a #x1b 0 0 0 0 0)
      )
    (new 'static 'gnawer-segment-info
      :num-joints 3
      :joint-index (new 'static 'array int8 8 #xc #x1c #x1d 0 0 0 0 0)
      )
    (new 'static 'gnawer-segment-info :num-joints 1 :joint-index (new 'static 'array int8 8 #x1e 0 0 0 0 0 0 0))
    )
  )

(defpartgroup group-gnawer-loses-segment
  :id 329
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 8)
  :parts ((sp-item 727 :binding 2309)
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2309 :flags (start-dead))
    (sp-item 2310)
    )
  )

(defpart 2310
  :init-specs ((:texture (new 'static 'texture-id :index #x12 :page #x2))
    (:num 2.0)
    (:scale-x (meters 16))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 64.0 128.0)
    (:g 0.0 32.0)
    (:b 192.0 128.0)
    (:a 128.0)
    (:fade-a -4.266667)
    (:timer (seconds 0.1))
    (:flags (bit2 bit3 bit14))
    )
  )

(defpart 727
  :init-specs ((:texture (new 'static 'texture-id :index #x1d :page #x2))
    (:num 16.0 16.0)
    (:scale-x (meters 0.25) (meters 0.25))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 32.0 64.0)
    (:g 0.0 16.0)
    (:b 96.0 64.0)
    (:a 128.0)
    (:vel-y (meters 0.02) (meters 0.04))
    (:rotvel-z (degrees -1.2) (degrees 1.2))
    (:fade-a -0.28444445)
    (:accel-y (meters -0.001) (meters -0.00066666666))
    (:friction 0.975)
    (:timer (seconds 1) (seconds 0.497))
    (:flags (bit2))
    (:conerot-x (degrees 45) (degrees 135))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 0) (meters 2))
    )
  )

(defpart 2309
  :init-specs ((:texture (new 'static 'texture-id :index #xb :page #x2))
    (:num 0.25 0.5)
    (:scale-x (meters 0.7) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 32.0 64.0)
    (:g 0.0 16.0)
    (:b 96.0 64.0)
    (:a 16.0 48.0)
    (:rotvel-z (degrees -0.2) (degrees 0.4))
    (:fade-a -0.42666668)
    (:accel-y (meters -0.00066666666))
    (:timer (seconds 0.5) (seconds 0.997))
    (:flags (bit2))
    )
  )

(defpartgroup group-gnawer-crumbs
  :id 330
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 8)
  :parts ((sp-item 2141 :fade-after (meters 60) :falloff-to (meters 60)))
  )

(defpart 2141
  :init-specs ((:texture (new 'static 'texture-id :index #x17 :page #x2))
    (:num 1.0 2.0)
    (:scale-x (meters 0.15) (meters 0.35))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 64.0 128.0)
    (:g 64.0 128.0)
    (:b 64.0 128.0)
    (:a 16.0 32.0)
    (:vel-y (meters 0.006666667) (meters 0.008333334))
    (:rotvel-z (degrees -1.2) (degrees 1.2))
    (:fade-a -0.16)
    (:accel-y (meters -0.00083333335))
    (:timer (seconds 0.7))
    (:flags (bit2))
    (:conerot-x (degrees 0) (degrees 180))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defstate falling (gnawer-falling-segment)
  :virtual #t
  :trans (behavior ()
    (+! (-> self transv y) (* -409600.0 (-> *display* seconds-per-frame)))
    (vector-v+! (-> self root trans) (-> self root trans) (-> self transv))
    (+! (-> self facing-rot x) (* (-> self facing-rotv x) (-> *display* seconds-per-frame)))
    (set! (-> self facing-rot z)
          (deg-seek (-> self facing-rot z) 16384.0 (* (-> self facing-rotv z) (-> *display* seconds-per-frame)))
          )
    (quaternion-zxy! (-> self root quat) (-> self facing-rot))
    (seek! (-> self root scale x) 0.0 (* 0.5 (-> *display* seconds-per-frame)))
    (set! (-> self root scale y) (-> self root scale x))
    (set! (-> self root scale z) (-> self root scale x))
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 0)
    (dotimes (gp-0 1)
      (ja-no-eval :group! gnawer-segment-idle-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (ja-no-eval :group! gnawer-segment-die-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (none)
    )
  :post (the-as (function none :behavior gnawer-falling-segment) ja-post)
  )

(defbehavior gnawer-falling-segment-init-by-other gnawer-falling-segment ((arg0 gnawer) (arg1 vector) (arg2 vector))
  (set! (-> self entity) (-> arg0 entity))
  (set! (-> self mask) (logior (process-mask enemy) (-> self mask)))
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> arg1 quad))
  (vector-identity! (-> self root scale))
  (let ((s5-1 (new 'stack-no-clear 'vector)))
    (let ((s4-0 (new 'stack-no-clear 'vector)))
      (set-vector!
        s5-1
        (+ (-> arg2 x) (rand-vu-float-range -0.2 0.2))
        (+ (-> arg2 y) (rand-vu-float-range -0.2 0.2))
        (+ (-> arg2 z) (rand-vu-float-range -0.2 0.2))
        1.0
        )
      (vector-normalize! s5-1 1.0)
      (set-vector!
        s4-0
        (+ (-> arg2 x) (rand-vu-float-range -0.2 0.2))
        (+ (-> arg2 y) (rand-vu-float-range 0.0 0.4))
        (+ (-> arg2 z) (rand-vu-float-range -0.2 0.2))
        1.0
        )
      (vector-normalize! s4-0 1.0)
      (set-heading-vec-clear-roll-pitch! (-> self root) s5-1)
      (vector-float*! (-> self transv) s4-0 (rand-vu-float-range 20480.0 40960.0))
      )
    (rot-zxy-from-vector! (-> self facing-rot) s5-1)
    )
  (set-vector!
    (-> self facing-rotv)
    (rand-vu-float-range 5461.3335 16384.0)
    0.0
    (rand-vu-float-range 16384.0 36408.89)
    1.0
    )
  (initialize-skeleton self *gnawer-segment-sg* '())
  (go-virtual falling)
  (none)
  )

(defmethod gnawer-method-23 gnawer ((obj gnawer))
  (when (not (-> obj hidden?))
    (set! (-> obj hidden?) #t)
    (logior! (-> obj draw status) (draw-status hidden))
    (logclear! (-> obj mask) (process-mask attackable))
    (set! (-> obj skel postbind-function) #f)
    (set! (-> obj root-override trans quad) (-> obj post-trans quad))
    (clear-collide-with-as (-> obj root-override))
    (dotimes (v1-12 10)
      (set! (-> obj segments v1-12 world-pos quad) (-> obj post-trans quad))
      )
    (set-vector! (-> obj draw bounds) 0.0 0.0 0.0 12288.0)
    )
  (none)
  )

(defmethod gnawer-method-26 gnawer ((obj gnawer))
  (when (-> obj hidden?)
    (set! (-> obj hidden?) #f)
    (restore-collide-with-as (-> obj root-override))
    (set! (-> obj skel postbind-function) gnawer-joint-callback)
    (logclear! (-> obj draw status) (draw-status hidden))
    )
  (none)
  )

(defmethod gnawer-method-24 gnawer ((obj gnawer))
  (local-vars (sv-48 vector) (sv-64 vector))
  (let ((s5-0 0)
        (s4-0 0)
        )
    (let ((f30-0 -1.0)
          (s3-0 (-> obj path curve num-cverts))
          )
      (dotimes (s2-0 3)
        (let ((s1-0 (rand-vu-int-count s3-0))
              (s0-0 (rand-vu-int-count s3-0))
              )
          (when (= s1-0 s0-0)
            (set! s0-0 (rand-vu-int-count s3-0))
            (if (= s1-0 s0-0)
                (set! s0-0 (mod (+ s1-0 1) s3-0))
                )
            )
          (set! sv-48 (new 'stack-no-clear 'vector))
          (set! sv-64 (new 'stack-no-clear 'vector))
          (eval-path-curve-div! (-> obj path) sv-48 (the float s1-0) 'interp)
          (eval-path-curve-div! (-> obj path) sv-64 (the float s0-0) 'interp)
          (let ((f0-4 (vector-vector-distance sv-48 sv-64)))
            (when (< f30-0 f0-4)
              (set! f30-0 f0-4)
              (set! s5-0 s1-0)
              (set! s4-0 s0-0)
              )
            )
          )
        )
      )
    (set! (-> obj route src-pt-index) s5-0)
    (set! (-> obj route dest-pt-index) s4-0)
    )
  (let ((v1-13 (-> obj route src-pt-index))
        (s5-1 (-> obj route dest-pt-index))
        )
    (eval-path-curve-div! (-> obj path) (-> obj route src-pt-offset) (the float v1-13) 'interp)
    (eval-path-curve-div! (-> obj path) (-> obj route dest-pt-offset) (the float s5-1) 'interp)
    )
  (vector-! (-> obj route src-pt-offset) (-> obj route src-pt-offset) (-> obj post-trans))
  (vector-! (-> obj route dest-pt-offset) (-> obj route dest-pt-offset) (-> obj post-trans))
  (let ((f30-1 (-> obj route src-pt-offset y)))
    (set! (-> obj route src-pt-offset y) 0.0)
    (vector-normalize! (-> obj route src-pt-offset) 10240.0)
    (set! (-> obj route src-pt-offset y) f30-1)
    )
  (let ((f30-2 (-> obj route dest-pt-offset y)))
    (set! (-> obj route dest-pt-offset y) 0.0)
    (vector-normalize! (-> obj route dest-pt-offset) 10240.0)
    (set! (-> obj route dest-pt-offset y) f30-2)
    )
  (let ((f30-3 (atan (-> obj route src-pt-offset x) (-> obj route src-pt-offset z)))
        (f0-15 (atan (-> obj route dest-pt-offset x) (-> obj route dest-pt-offset z)))
        )
    (set! (-> obj route src-ang) f30-3)
    (set! (-> obj route dest-ang) f0-15)
    (let ((f30-4 (deg- f0-15 f30-3)))
      0.0
      (let* ((v0-13 (rand-vu-int-count 100))
             (f0-17 (cond
                      ((< v0-13 67)
                       131072.0
                       )
                      ((< v0-13 82)
                       196608.0
                       )
                      (else
                        65536.0
                        )
                      )
                    )
             )
        (set! (-> obj route delta-ang) (if (>= f30-4 0.0)
                                           (- f30-4 f0-17)
                                           (+ f30-4 f0-17)
                                           )
              )
        )
      )
    )
  (let ((f30-5 (* 0.9817476 (-> obj route delta-ang)))
        (f28-0 (- (-> obj route dest-pt-offset y) (-> obj route src-pt-offset y)))
        )
    (set-vector! (-> obj route surface-dir) f30-5 f28-0 0.0 1.0)
    (vector-normalize! (-> obj route surface-dir) 1.0)
    (let ((f0-25 (sqrtf (+ (* f30-5 f30-5) (* f28-0 f28-0)))))
      (set! (-> obj route surface-dist) f0-25)
      (set! (-> obj route total-dist) (+ 20480.0 f0-25))
      )
    )
  (set! (-> obj route total-travel-time)
        (the-as time-frame (the int (/ (-> obj route total-dist) (* 0.016666668 (-> obj speed)))))
        )
  (none)
  )

(defmethod gnawer-method-22 gnawer ((obj gnawer) (arg0 float))
  (let ((s4-0 (new 'stack-no-clear 'bounding-box))
        (a3-0 #t)
        (gp-0 #t)
        )
    (dotimes (s2-0 10)
      (let ((v1-4 (-> obj segments s2-0 place)))
        (cond
          ((>= v1-4 0)
           (let ((f0-1 (- arg0 (* 3891.2 (the float v1-4)))))
             (cond
               ((< f0-1 0.0)
                (set! f0-1 0.0)
                (set! gp-0 #f)
                )
               ((>= f0-1 (-> obj route total-dist))
                (set! f0-1 (-> obj route total-dist))
                )
               (else
                 (set! gp-0 #f)
                 )
               )
             (gnawer-method-21 obj s2-0 s4-0 a3-0 f0-1)
             )
           )
          (else
            (gnawer-method-20 obj s2-0)
            )
          )
        )
      (set! a3-0 #f)
      )
    (set-vector!
      (-> obj root-override trans)
      (* 0.5 (+ (-> s4-0 min x) (-> s4-0 max x)))
      (* 0.5 (+ (-> s4-0 min y) (-> s4-0 max y)))
      (* 0.5 (+ (-> s4-0 min z) (-> s4-0 max z)))
      1.0
      )
    (let* ((f0-10 (- (-> s4-0 max x) (-> obj root-override trans x)))
           (f1-12 (- (-> s4-0 max y) (-> obj root-override trans y)))
           (f2-7 (- (-> s4-0 max z) (-> obj root-override trans z)))
           (f0-14 (sqrtf (+ (* f0-10 f0-10) (* f1-12 f1-12) (* f2-7 f2-7))))
           (a0-3 (-> obj draw bounds))
           (v1-21 (-> obj root-override root-prim))
           (f0-15 (+ 12288.0 f0-14))
           )
      (vector-reset! a0-3)
      (set! (-> a0-3 w) f0-15)
      (vector-reset! (-> v1-21 local-sphere))
      (set! (-> v1-21 local-sphere w) f0-15)
      (set! (-> v1-21 prim-core world-sphere quad) (-> obj root-override trans quad))
      (set! (-> v1-21 prim-core world-sphere w) f0-15)
      )
    gp-0
    )
  )

(defmethod gnawer-method-21 gnawer ((obj gnawer) (arg0 int) (arg1 bounding-box) (arg2 symbol) (arg3 float))
  (let ((gp-0 (-> obj segments arg0)))
    (let ((f0-1 (+ 10240.0 (-> obj route surface-dist))))
      (cond
        ((< arg3 10240.0)
         (let ((f0-3 (* 0.00009765625 arg3)))
           (vector-float*! (-> gp-0 world-pos) (-> obj route src-pt-offset) f0-3)
           )
         (set! (-> gp-0 world-pos y) (-> obj route src-pt-offset y))
         (vector+! (-> gp-0 world-pos) (-> gp-0 world-pos) (-> obj post-trans))
         )
        ((< arg3 f0-1)
         (let* ((f30-0 (/ (+ -10240.0 arg3) (-> obj route surface-dist)))
                (f28-0 (+ (* (-> obj route delta-ang) f30-0) (-> obj route src-ang)))
                )
           (set-vector!
             (-> gp-0 world-pos)
             (* 10240.0 (sin f28-0))
             (lerp (-> obj route src-pt-offset y) (-> obj route dest-pt-offset y) f30-0)
             (* 10240.0 (cos f28-0))
             1.0
             )
           )
         (vector+! (-> gp-0 world-pos) (-> gp-0 world-pos) (-> obj post-trans))
         )
        (else
          (let ((f0-19 (- 1.0 (* 0.00009765625 (- arg3 f0-1)))))
            (vector-float*! (-> gp-0 world-pos) (-> obj route dest-pt-offset) f0-19)
            )
          (set! (-> gp-0 world-pos y) (-> obj route dest-pt-offset y))
          (vector+! (-> gp-0 world-pos) (-> gp-0 world-pos) (-> obj post-trans))
          )
        )
      )
    (cond
      (arg2
        (set! (-> arg1 min quad) (-> gp-0 world-pos quad))
        (set! (-> arg1 max quad) (-> gp-0 world-pos quad))
        )
      (else
        (add-point! arg1 (the-as vector3s (-> gp-0 world-pos)))
        )
      )
    (let ((s4-1 (new 'stack-no-clear 'vector)))
      (vector-! s4-1 (-> gp-0 world-pos) (-> obj post-trans))
      (set! (-> s4-1 y) 0.0)
      (vector-normalize! s4-1 1.0)
      (let ((f0-24 (atan (-> s4-1 x) (-> s4-1 z)))
            (s3-1 (new 'stack-no-clear 'vector))
            )
        (vector-rotate-around-y! s3-1 (-> obj route surface-dir) f0-24)
        (set! (-> gp-0 orient-mat vector 1 quad) (-> s4-1 quad))
        (set! (-> gp-0 orient-mat vector 2 quad) (-> s3-1 quad))
        )
      )
    (vector-cross!
      (the-as vector (-> gp-0 orient-mat))
      (-> gp-0 orient-mat vector 1)
      (-> gp-0 orient-mat vector 2)
      )
    (vector-normalize! (the-as vector (-> gp-0 orient-mat)) 1.0)
    (set! (-> gp-0 orient-mat vector 0 w) 0.0)
    (set! (-> gp-0 orient-mat vector 1 w) 0.0)
    (set! (-> gp-0 orient-mat vector 2 w) 0.0)
    )
  )

(defmethod gnawer-method-20 gnawer ((obj gnawer) (arg0 int))
  (let ((v1-3 (-> obj segments arg0))
        (a0-1 (-> obj segments (+ arg0 -1)))
        )
    (set! (-> v1-3 world-pos quad) (-> a0-1 world-pos quad))
    (let ((v0-0 (-> v1-3 orient-mat)))
      (let* ((a2-3 (-> a0-1 orient-mat))
             (v1-4 (-> a2-3 vector 0 quad))
             (a0-2 (-> a2-3 vector 1 quad))
             (a1-5 (-> a2-3 vector 2 quad))
             (a2-4 (-> a2-3 vector 3 quad))
             )
        (set! (-> v0-0 vector 0 quad) v1-4)
        (set! (-> v0-0 vector 1 quad) a0-2)
        (set! (-> v0-0 vector 2 quad) a1-5)
        (set! (-> v0-0 vector 3 quad) a2-4)
        )
      v0-0
      )
    )
  )

(defmethod gnawer-method-25 gnawer ((obj gnawer))
  (dotimes (s5-0 3)
    (when (> (-> obj hit-points) 0)
      (+! (-> obj hit-points) -1)
      (set! (-> obj speed) (+ 4096.0 (-> obj speed)))
      (when (> (-> obj hit-points) 0)
        (set! (-> obj show-damage?) #t)
        (let ((s4-0 (+ (-> obj hit-points) 2)))
          (let ((s3-0 (-> obj segments s4-0)))
            (let ((s1-0 (new 'stack-no-clear 'vector))
                  (s2-0 (-> s3-0 world-pos))
                  )
              (vector-! s1-0 s2-0 (-> obj root-override trans))
              (set! (-> s1-0 y) 0.0)
              (vector-normalize! s1-0 1.0)
              (process-spawn gnawer-falling-segment obj s2-0 s1-0 :to obj)
              )
            (set! (-> s3-0 place) -1)
            )
          (while (< s4-0 10)
            (let ((v1-20 (-> obj segments s4-0)))
              (if (>= (-> v1-20 place) 0)
                  (+! (-> v1-20 place) -1)
                  )
              )
            (+! s4-0 1)
            )
          )
        )
      )
    )
  (close-specific-task! (game-task cave-gnawers) (task-status need-hint))
  (<= (-> obj hit-points) 0)
  )

(defmethod gnawer-method-28 gnawer ((obj gnawer) (arg0 int) (arg1 int))
  (when (> arg0 0)
    (let* ((v1-1 (rand-vu-int-count arg0))
           (a0-2 v1-1)
           )
      (until (= a0-2 v1-1)
        (let ((a1-2 (ash 1 a0-2)))
          (if (not (logtest? a1-2 arg1))
              (return (the-as symbol a1-2))
              )
          )
        (set! a0-2 (mod (+ a0-2 1) arg0))
        )
      )
    )
  (the-as symbol 0)
  )

(defmethod gnawer-method-27 gnawer ((obj gnawer))
  (set! (-> obj eco-green-mask) (the-as uint 0))
  (let ((s4-0 (-> obj path curve num-cverts))
        (s3-0 (get-death-count *game-info* #f))
        (s5-0 (-> obj money-mask))
        )
    (when (and *target*
               (or (and (= s3-0 1) (and (>= 1.0 (-> *target* fact-info-target health)) (rand-vu-percent? 0.1)))
                   (and (< 1 s3-0) (and (>= 2.0 (-> *target* fact-info-target health)) (rand-vu-percent? 0.05)))
                   )
               )
      (let ((v1-14 (gnawer-method-28 obj s4-0 (the-as int s5-0))))
        (logior s5-0 (the-as uint v1-14))
        (set! (-> obj eco-green-mask) (the-as uint (logior (-> obj eco-green-mask) (the-as uint v1-14))))
        )
      )
    )
  (none)
  )

(defmethod gnawer-method-29 gnawer ((obj gnawer) (arg0 int) (arg1 vector) (arg2 vector))
  (let ((s1-0 (-> obj path curve num-cverts))
        (s2-0 (new 'stack-no-clear 'vector))
        )
    0.0
    0.0
    (eval-path-curve-div! (-> obj path) s2-0 0.0 'interp)
    (let* ((f30-0 (-> s2-0 y))
           (f28-0 f30-0)
           )
      (eval-path-curve-div! (-> obj path) s2-0 (the float (+ s1-0 -1)) 'interp)
      (let ((f30-1 (fmin f30-0 (-> s2-0 y)))
            (f28-1 (fmax f28-0 (-> s2-0 y)))
            )
        (eval-path-curve-div! (-> obj path) arg1 (the float arg0) 'interp)
        (vector-! arg2 arg1 (-> obj post-trans))
        (let ((f0-9 (+ 16384.0 (* 16384.0 (/ (fmax 0.0 (- (-> arg2 y) f30-1)) (- f28-1 f30-1))))))
          (set! (-> arg2 y) 0.0)
          (vector-normalize! arg2 f0-9)
          )
        )
      )
    )
  (vector+! arg2 arg2 (-> obj post-trans))
  (set! (-> arg2 y) (+ 4096.0 (-> arg2 y)))
  )

(defmethod gnawer-method-30 gnawer ((obj gnawer) (arg0 process-drawable))
  (local-vars (sv-48 vector))
  (let ((gp-0 (-> obj entity extra perm)))
    (logior! (-> gp-0 status) (entity-perm-status user-set-from-cstage))
    (let ((s5-0 (-> gp-0 user-uint16 0))
          (s2-0 -1)
          )
      (let ((f30-0 0.0)
            (s1-0 (-> obj path curve num-cverts))
            )
        (dotimes (s0-0 s1-0)
          (when (logtest? (ash 1 s0-0) s5-0)
            (let ((a2-0 (new 'stack-no-clear 'vector)))
              (set! sv-48 (new 'stack-no-clear 'vector))
              (gnawer-method-29 obj s0-0 a2-0 sv-48)
              )
            (let* ((t9-1 vector-vector-xz-distance)
                   (a1-2 (-> arg0 root trans))
                   (f0-0 (t9-1 sv-48 a1-2))
                   )
              (when (or (< s2-0 0) (< f0-0 f30-0))
                (set! s2-0 s0-0)
                (set! f30-0 f0-0)
                )
              )
            )
          )
        )
      (when (>= s2-0 0)
        (let ((v0-2 (logxor s5-0 (the-as uint (ash 1 s2-0)))))
          (set! (-> gp-0 user-int16 0) (the-as int v0-2))
          v0-2
          )
        )
      )
    )
  )

(defstate gnawer-chewing-on-post (gnawer)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('touch)
       (if (= (-> proc type) target)
           (send-event
             proc
             'shove
             (-> event param 0)
             (static-attack-info ((shove-up (meters 1.5)) (shove-back (meters 2.5))))
             )
           )
       (go gnawer-retreat-into-post)
       )
      (('attack)
       (sound-play "gnawer-dies" :pitch -0.25)
       (go gnawer-retreat-into-post)
       )
      )
    )
  :exit (behavior ()
    (stop! (-> self sound2))
    (none)
    )
  :trans (behavior ()
    (if (and *target* (>= 81920.0 (vector-vector-distance (target-pos 0) (-> self root-override trans))))
        (go gnawer-retreat-into-post)
        )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.075))
    (if (zero? (rand-vu-int-count 2))
        (ja :group! gnawer-tear-side-to-side-ja
            :num! (identity (rand-vu-float-range 0.0 (the float (+ (-> (ja-group) data 0 length) -1))))
            )
        (ja :group! gnawer-tug-ja
            :num! (identity (rand-vu-float-range 0.0 (the float (+ (-> (ja-group) data 0 length) -1))))
            )
        )
    (ja-no-eval :num! (seek!))
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (loop
      (let ((gp-2 (rand-vu-int-range 1 2))
            (s4-0 (rand-vu-int-range 1 2))
            )
        (dotimes (s5-0 gp-2)
          (dotimes (s3-0 s4-0)
            (set! (-> self anim-speed) (rand-vu-float-range 0.8 1.0))
            (ja-channel-push! 1 (seconds 0.075))
            (ja-no-eval :group! gnawer-tear-side-to-side-ja :num! (seek! max (-> self anim-speed)) :frame-num 0.0)
            (until (ja-done? 0)
              (suspend)
              (ja :num! (seek! max (-> self anim-speed)))
              )
            )
          (set! s4-0 (rand-vu-int-range 1 2))
          (dotimes (s3-1 s4-0)
            (set! (-> self anim-speed) (rand-vu-float-range 0.8 1.0))
            (ja-channel-push! 1 (seconds 0.075))
            (ja-no-eval :group! gnawer-tug-ja :num! (seek! max (-> self anim-speed)) :frame-num 0.0)
            (until (ja-done? 0)
              (suspend)
              (ja :num! (seek! max (-> self anim-speed)))
              )
            )
          )
        )
      (ja-channel-push! 1 (seconds 0.075))
      (ja-no-eval :group! gnawer-up-to-chew-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (let ((gp-3 (new 'stack-no-clear 'vector)))
          (vector<-cspace! gp-3 (-> self node-list data 34))
          (spawn (-> self part2) gp-3)
          )
        (let ((gp-4 (new 'stack-no-clear 'vector)))
          (vector<-cspace! gp-4 (-> self node-list data 33))
          (spawn (-> self part2) gp-4)
          )
        (suspend)
        (ja :num! (seek!))
        )
      (let ((gp-5 (rand-vu-int-range 1 4)))
        (set! (-> self anim-speed) (rand-vu-float-range 0.8 1.0))
        (dotimes (s5-1 gp-5)
          (ja-channel-push! 1 (seconds 0.075))
          (ja-no-eval :group! gnawer-chew-ja :num! (seek! max (-> self anim-speed)) :frame-num 0.0)
          (until (ja-done? 0)
            (let ((s4-1 (new 'stack-no-clear 'vector)))
              (vector<-cspace! s4-1 (-> self node-list data 34))
              (spawn (-> self part2) s4-1)
              )
            (let ((s4-2 (new 'stack-no-clear 'vector)))
              (vector<-cspace! s4-2 (-> self node-list data 33))
              (spawn (-> self part2) s4-2)
              )
            (update! (-> self sound2))
            (suspend)
            (ja :num! (seek! max (-> self anim-speed)))
            )
          )
        )
      (stop! (-> self sound2))
      (ja-no-eval :group! gnawer-down-from-chew-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (none)
    )
  :post (the-as (function none :behavior gnawer) transform-post)
  )

(defstate gnawer-retreat-into-post (gnawer)
  :exit (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    (none)
    )
  :code (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    (ja-channel-push! 1 (seconds 0.075))
    (ja-no-eval :group! gnawer-notice-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (quaternion-identity! (-> self root-override quat))
    (go gnawer-wait-to-run)
    (none)
    )
  :post (the-as (function none :behavior gnawer) transform-post)
  )

(defstate gnawer-wait-to-run (gnawer)
  :code (behavior ()
    (set! (-> self draw origin-joint-index) (the-as uint 0))
    (gnawer-method-23 self)
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (let ((gp-0 (rand-vu-int-range 240 360)))
      (until (>= (- (-> *display* base-frame-counter) (-> self state-time)) gp-0)
        (suspend)
        )
      )
    (go gnawer-run)
    (none)
    )
  )

(defstate gnawer-run (gnawer)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (local-vars (v0-0 object))
    (case event-type
      (('touch)
       (if (= (-> proc type) target)
           (send-event
             proc
             'shove
             (-> event param 0)
             (static-attack-info ((shove-up (meters 1.5)) (shove-back (meters 2.5))))
             )
           )
       )
      (('attack)
       (cond
         ((= (-> proc type) target)
          (send-event
            proc
            'attack
            (-> event param 0)
            (static-attack-info ((shove-up (meters 1.5)) (shove-back (meters 2.5))))
            )
          )
         (else
           (if (< (- (-> *display* base-frame-counter) (-> self last-hit-time)) (seconds 0.5))
               (return #f)
               )
           (let* ((a2-1 (the-as object (-> event param 0)))
                  (v1-19 (-> (get-touched-prim
                               (-> (the-as touching-shapes-entry a2-1) head)
                               (-> self root-override)
                               (the-as touching-shapes-entry a2-1)
                               )
                             prim-id
                             )
                         )
                  (v1-22 (-> self segments v1-19))
                  )
             (spawn (-> self part) (-> v1-22 world-pos))
             )
           (if (gnawer-method-25 self)
               (go gnawer-die)
               )
           (return #t)
           v0-0
           )
         )
       )
      )
    )
  :enter (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    (set! (-> self route-dist) 0.0)
    (gnawer-method-24 self)
    (set! (-> self last-hit-time) (-> *display* base-frame-counter))
    (gnawer-method-26 self)
    (none)
    )
  :exit (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    (stop! (-> self sound))
    (none)
    )
  :trans (behavior ()
    (+! (-> self route-dist) (* (-> self speed) (-> *display* seconds-per-frame)))
    (if (gnawer-method-22 self (-> self route-dist))
        (go gnawer-wait-to-run)
        )
    (update! (-> self sound))
    (none)
    )
  :code (behavior ()
    (local-vars (v1-19 symbol) (v1-35 symbol))
    (ja-channel-set! 1)
    (ja :group! gnawer-run-ja :num! min)
    (ja-no-eval :num! (seek!))
    (loop
      (until v1-19
        (suspend)
        (ja :num! (seek!))
        (set! v1-19 (or (ja-done? 0) (-> self show-damage?)))
        )
      (when (-> self show-damage?)
        (until (not (-> self show-damage?))
          (set! (-> self show-damage?) #f)
          (ja-channel-push! 1 (seconds 0.1))
          (ja :group! gnawer-takes-hit-ja :num! min)
          (until v1-35
            (suspend)
            (ja :num! (seek!))
            (set! v1-35 (or (ja-done? 0) (-> self show-damage?)))
            )
          )
        (ja-channel-push! 1 (seconds 0.1))
        )
      (ja :group! gnawer-run-ja :num! min)
      )
    (none)
    )
  :post (the-as (function none :behavior gnawer) transform-post)
  )

(defstate gnawer-die (gnawer)
  :enter (behavior ()
    (let ((v1-0 (-> self segments)))
      (set! (-> self fall-trans quad) (-> v1-0 0 world-pos quad))
      (vector-! (-> self root-override transv) (-> v1-0 0 world-pos) (-> self post-trans))
      )
    (set! (-> self root-override transv y) 0.0)
    (vector-normalize! (-> self root-override transv) 1.0)
    (set! (-> self root-override transv y) 0.3)
    (vector-normalize! (-> self root-override transv) 32768.0)
    (none)
    )
  :trans (behavior ()
    (+! (-> self root-override transv y) (* -409600.0 (-> *display* seconds-per-frame)))
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (set! (-> gp-0 quad) (-> self fall-trans quad))
      (vector-v+! (-> self fall-trans) (-> self fall-trans) (-> self root-override transv))
      (vector-! gp-0 (-> self fall-trans) gp-0)
      (dotimes (v1-6 10)
        (let ((a1-3 (-> self segments v1-6)))
          (vector+! (-> a1-3 world-pos) (-> a1-3 world-pos) gp-0)
          )
        )
      (vector+! (-> self root-override trans) (-> self root-override trans) gp-0)
      )
    (spool-push *art-control* "maincavecam-gnawer-fuel-cell" 0 self -1.0)
    (none)
    )
  :code (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    (process-entity-status! self (entity-perm-status bit-3) #t)
    (ja-channel-push! 1 (seconds 0.1))
    (clear-collide-with-as (-> self root-override))
    (ja-no-eval :group! gnawer-die-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go gnawer-dying-give-pickups)
    (none)
    )
  :post (the-as (function none :behavior gnawer) ja-post)
  )

(defstate gnawer-dying-give-pickups (gnawer)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('notify)
                      (if (and (= (-> proc type) money) (= (-> event param 0) 'pickup))
                          (gnawer-method-30 self (the-as process-drawable proc))
                          )
                      )
                     )
            )
    )
  :trans (behavior ()
    (spool-push *art-control* "maincavecam-gnawer-fuel-cell" 0 self -1.0)
    (none)
    )
  :code (behavior ()
    (local-vars (sv-128 symbol))
    (clear-collide-with-as (-> self root-override))
    (set! (-> self skel postbind-function) #f)
    (ja-channel-set! 0)
    (ja-post)
    (logior! (-> self draw status) (draw-status hidden))
    (process-entity-status! self (entity-perm-status complete) #t)
    (gnawer-method-27 self)
    (let ((v1-10 (-> self entity extra perm)))
      (logior! (-> v1-10 status) (entity-perm-status user-set-from-cstage))
      (set! (-> v1-10 user-int16 0) (the-as int (-> self money-mask)))
      )
    (dotimes (gp-0 (-> self path curve num-cverts))
      (let ((s4-0 (new 'stack-no-clear 'vector))
            (s5-0 (new 'stack-no-clear 'vector))
            )
        (gnawer-method-29 self gp-0 s4-0 s5-0)
        (let ((a1-2 7))
          (let ((v1-14 (ash 1 gp-0)))
            (cond
              ((logtest? v1-14 (-> self eco-green-mask))
               (set! a1-2 4)
               )
              ((logtest? v1-14 (-> self money-mask))
               (set! a1-2 5)
               )
              )
            )
          (let ((v1-19 (birth-pickup-at-point s4-0 (the-as pickup-type a1-2) 1.0 #f self (the-as fact-info #f))))
            (send-event (ppointer->process v1-19) 'jump s5-0)
            )
          )
        )
      (set! (-> self state-time) (-> *display* base-frame-counter))
      (until (>= (- (-> *display* base-frame-counter) (-> self state-time)) (seconds 0.05))
        (suspend)
        )
      )
    (set! sv-128 (the-as symbol #f))
    (apply-all (-> self link) actor-link-subtask-complete-hook (& sv-128))
    (when sv-128
      (save-reminder (get-task-control (game-task cave-gnawers)) (-> self gnawer-id) 3)
      (go gnawer-give-fuel-cell)
      )
    (set! (-> self trans-hook) #f)
    (process-entity-status! self (entity-perm-status bit-3) #f)
    (logior! (-> self mask) (process-mask actor-pause))
    (until (not (-> self child))
      (suspend)
      )
    (cleanup-for-death self)
    (none)
    )
  )

(defstate gnawer-give-fuel-cell (gnawer)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('notify)
                      (cond
                        ((and (= (-> proc type) maincavecam) (= (-> event param 0) 'die))
                         (process-entity-status! self (entity-perm-status bit-3) #f)
                         (let ((v0-0 (the-as uint (logior (-> self mask) (process-mask actor-pause)))))
                           (set! (-> self mask) (the-as process-mask v0-0))
                           v0-0
                           )
                         )
                        ((and (= (-> proc type) money) (= (-> event param 0) 'pickup))
                         (gnawer-method-30 self (the-as process-drawable proc))
                         )
                        )
                      )
                     )
            )
    )
  :code (behavior ()
    (when (not (task-complete? *game-info* (-> self entity extra perm task)))
      (spool-push *art-control* "maincavecam-gnawer-fuel-cell" 0 self -1.0)
      (logclear! (-> self mask) (process-mask actor-pause))
      (process-entity-status! self (entity-perm-status bit-3) #t)
      (let ((gp-0 (new 'stack-no-clear 'vector)))
        (set-vector! gp-0 4503813.0 46363.85 -12796366.0 1.0)
        (let ((s5-0 (the-as maincavecam (get-process *default-dead-pool* maincavecam #x4000))))
          (set! (-> (the-as
                      maincavecam
                      (-> (when s5-0
                            (let ((t9-4 (method-of-type maincavecam activate)))
                              (t9-4 s5-0 self 'maincavecam (the-as pointer #x70004000))
                              )
                            (run-now-in-process
                              s5-0
                              pov-camera-init-by-other
                              gp-0
                              *maincavecam-sg*
                              (new 'static 'spool-anim :name "maincavecam-gnawer-fuel-cell" :index 3 :parts 1 :command-list '())
                              0
                              self
                              '()
                              )
                            (-> s5-0 ppointer)
                            )
                          0
                          )
                      )
                    seq
                    )
                (the-as uint 0)
                )
          )
        )
      0
      (sound-play "cell-prize")
      (until (not (-> self child))
        (suspend)
        )
      )
    (process-entity-status! self (entity-perm-status bit-3) #f)
    (logior! (-> self mask) (process-mask actor-pause))
    (cleanup-for-death self)
    (none)
    )
  )

(defstate gnawer-put-items-at-dest (gnawer)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('notify)
                      (if (and (= (-> proc type) money) (= (-> event param 0) 'pickup))
                          (gnawer-method-30 self (the-as process-drawable proc))
                          )
                      )
                     )
            )
    )
  :code (behavior ()
    (set! (-> self draw origin-joint-index) (the-as uint 0))
    (clear-collide-with-as (-> self root-override))
    (set! (-> self skel postbind-function) #f)
    (ja-channel-set! 0)
    (ja-post)
    (logior! (-> self draw status) (draw-status hidden))
    (case (get-reminder (get-task-control (game-task cave-gnawers)) 3)
      (((-> self gnawer-id))
       (when (not (task-complete? *game-info* (-> self entity extra perm task)))
         (let ((a0-7 (new 'stack-no-clear 'vector)))
           (set-vector! a0-7 4485903.0 51184.027 -12815461.0 1.0)
           (birth-pickup-at-point
             a0-7
             (pickup-type fuel-cell)
             (the float (-> self entity extra perm task))
             #f
             self
             (the-as fact-info #f)
             )
           )
         )
       )
      )
    (let ((gp-0 (-> self entity extra perm user-uint16 0)))
      (when (nonzero? gp-0)
        (let ((s5-0 (-> self path curve num-cverts)))
          (dotimes (s4-0 s5-0)
            (when (logtest? (ash 1 s4-0) gp-0)
              (let ((a2-1 (new 'stack-no-clear 'vector))
                    (s3-0 (new 'stack-no-clear 'vector))
                    )
                (gnawer-method-29 self s4-0 a2-1 s3-0)
                (birth-pickup-at-point s3-0 (pickup-type money) 1.0 #f self (the-as fact-info #f))
                )
              )
            )
          )
        )
      )
    (until (not (-> self child))
      (suspend)
      )
    (cleanup-for-death self)
    (none)
    )
  )

(defun gnawer-joint-callback ((arg0 gnawer))
  (dotimes (s5-0 10)
    (let* ((v1-1 (-> *gnawer-segment-infos* s5-0))
           (s4-0 (-> arg0 segments s5-0))
           (s3-0 (-> v1-1 joint-index))
           )
      (countdown (s2-0 (-> v1-1 num-joints))
        (let ((s1-0 (-> arg0 node-list data (-> s3-0 0) bone transform)))
          (vector-! (-> s1-0 vector 3) (-> s1-0 vector 3) (-> arg0 root-override trans))
          (vector+! (-> s1-0 vector 3) (-> s1-0 vector 3) (-> s4-0 anim-to-local-trans-offset))
          (matrix*! s1-0 s1-0 (-> s4-0 orient-mat))
          (vector+! (-> s1-0 vector 3) (-> s1-0 vector 3) (-> s4-0 world-pos))
          )
        (set! s3-0 (&-> s3-0 1))
        )
      )
    )
  0
  (none)
  )

(defmethod deactivate gnawer ((obj gnawer))
  (if (nonzero? (-> obj part2))
      (kill-and-free-particles (-> obj part2))
      )
  (if (nonzero? (-> obj sound2))
      (stop! (-> obj sound2))
      )
  ((method-of-type process-drawable deactivate) obj)
  (none)
  )

(defmethod relocate gnawer ((obj gnawer) (arg0 int))
  (if (nonzero? (-> obj part2))
      (&+! (-> obj part2) arg0)
      )
  (if (nonzero? (-> obj sound2))
      (&+! (-> obj sound2) arg0)
      )
  (the-as
    gnawer
    ((the-as (function nav-enemy int nav-enemy) (find-parent-method gnawer 7)) (the-as nav-enemy obj) arg0)
    )
  )

(defmethod init-from-entity! gnawer ((obj gnawer) (arg0 entity-actor))
  (local-vars (sv-16 res-tag) (sv-32 res-tag) (sv-48 res-tag))
  (set! (-> obj hidden?) #f)
  (set! (-> obj show-damage?) #f)
  (set! (-> obj hit-points) 6)
  (set! (-> obj speed) 24576.0)
  (set! (-> obj last-hit-time) 0)
  (set! (-> obj route-dist) 0.0)
  (logclear! (-> obj mask) (process-mask attackable))
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 8) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set-vector! (-> s3-0 local-sphere) 0.0 32768.0 0.0 53248.0)
      (set-root-prim! s4-0 s3-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 2))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core offense) (collide-offense no-offense))
        (set! (-> s2-0 transform-index) 13)
        (set-vector! (-> s2-0 local-sphere) 0.0 0.0 0.0 6144.0)
        (append-prim s3-0 s2-0)
        )
      (let ((s2-1 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 2))))
        (set! (-> s2-1 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-1 collide-with) (collide-kind target))
        (set! (-> s2-1 prim-core offense) (collide-offense no-offense))
        (set! (-> s2-1 transform-index) 6)
        (set-vector! (-> s2-1 local-sphere) 0.0 0.0 0.0 6144.0)
        (append-prim s3-0 s2-1)
        )
      (let ((s2-2 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 3))))
        (set! (-> s2-2 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-2 collide-with) (collide-kind target))
        (set! (-> s2-2 prim-core offense) (collide-offense no-offense))
        (set! (-> s2-2 transform-index) 7)
        (set-vector! (-> s2-2 local-sphere) 0.0 -409.6 1228.8 6144.0)
        (append-prim s3-0 s2-2)
        )
      (let ((s2-3 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 4))))
        (set! (-> s2-3 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-3 collide-with) (collide-kind target))
        (set! (-> s2-3 prim-core offense) (collide-offense no-offense))
        (set! (-> s2-3 transform-index) 8)
        (set-vector! (-> s2-3 local-sphere) 0.0 0.0 0.0 6144.0)
        (append-prim s3-0 s2-3)
        )
      (let ((s2-4 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 5))))
        (set! (-> s2-4 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-4 collide-with) (collide-kind target))
        (set! (-> s2-4 prim-core offense) (collide-offense no-offense))
        (set! (-> s2-4 transform-index) 9)
        (set-vector! (-> s2-4 local-sphere) 0.0 0.0 0.0 6144.0)
        (append-prim s3-0 s2-4)
        )
      (let ((s2-5 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 6))))
        (set! (-> s2-5 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-5 collide-with) (collide-kind target))
        (set! (-> s2-5 prim-core offense) (collide-offense no-offense))
        (set! (-> s2-5 transform-index) 10)
        (set-vector! (-> s2-5 local-sphere) 0.0 0.0 0.0 6144.0)
        (append-prim s3-0 s2-5)
        )
      (let ((s2-6 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 7))))
        (set! (-> s2-6 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-6 collide-with) (collide-kind target))
        (set! (-> s2-6 prim-core offense) (collide-offense no-offense))
        (set! (-> s2-6 transform-index) 11)
        (set-vector! (-> s2-6 local-sphere) 0.0 0.0 0.0 6144.0)
        (append-prim s3-0 s2-6)
        )
      (let ((s2-7 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 7))))
        (set! (-> s2-7 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-7 collide-with) (collide-kind target))
        (set! (-> s2-7 prim-core offense) (collide-offense no-offense))
        (set! (-> s2-7 transform-index) 12)
        (set-vector! (-> s2-7 local-sphere) 0.0 0.0 0.0 6144.0)
        (append-prim s3-0 s2-7)
        )
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (quaternion-identity! (-> obj root-override quat))
  (initialize-skeleton obj *gnawer-sg* '())
  (set! (-> obj draw origin-joint-index) (the-as uint 8))
  (set! (-> obj post-trans quad) (-> obj root-override trans quad))
  (let ((f0-40 (res-lump-float (-> obj entity) 'rotoffset)))
    (quaternion-rotate-y! (-> obj root-override quat) (-> obj root-override quat) f0-40)
    )
  (set! (-> obj root-override trans y) (+ -2048.0 (-> obj root-override trans y)))
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-81 (res-lump-data arg0 'trans-offset (pointer float) :tag-ptr (& sv-16))))
    (when v1-81
      (+! (-> obj root-override trans x) (-> v1-81 0))
      (+! (-> obj root-override trans y) (-> v1-81 1))
      (+! (-> obj root-override trans z) (-> v1-81 2))
      )
    )
  (set! (-> obj path) (new 'process 'curve-control obj 'path -1000000000.0))
  (logior! (-> obj path flags) (path-control-flag display draw-line draw-point draw-text))
  (if (< (-> obj path curve num-cverts) 2)
      (go process-drawable-art-error "bad path")
      )
  (set! (-> obj part2) (create-launch-control (-> *part-group-id-table* 330) obj))
  (set! (-> obj total-money) 0)
  (set! (-> obj money-mask) (the-as uint 0))
  (set! sv-32 (new 'static 'res-tag))
  (let ((v1-96 (res-lump-data arg0 'extra-count (pointer int32) :tag-ptr (& sv-32))))
    (when v1-96
      (case (-> v1-96 0)
        ((5)
         (set! (-> obj total-money) (-> v1-96 1))
         )
        )
      )
    )
  (when (> (-> obj total-money) 0)
    (set! sv-48 (new 'static 'res-tag))
    (let ((a0-49 (res-lump-data arg0 'gnawer (pointer int32) :tag-ptr (& sv-48))))
      (cond
        (a0-49
          (let ((v1-100 0))
            (dotimes (a1-30 (-> obj total-money))
              (let ((a3-15 (-> a0-49 a1-30)))
                (set! v1-100 (logior v1-100 (ash 1 a3-15)))
                )
              )
            (set! (-> obj money-mask) (the-as uint v1-100))
            )
          )
        (else
          (go process-drawable-art-error "bad actor params")
          )
        )
      )
    )
  (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 329) obj))
  (set! (-> obj sound)
        (new
          'process
          'ambient-sound
          (static-sound-spec "gnawer-crawl" :fo-min 30 :fo-max 30)
          (-> obj root-override trans)
          )
        )
  (set! (-> obj sound2)
        (new 'process 'ambient-sound (static-sound-spec "gnawer-chew" :fo-max 40) (-> obj root-override trans))
        )
  (dotimes (v1-110 10)
    (let ((a0-59 (-> obj segments v1-110)))
      (set! (-> a0-59 place) v1-110)
      (set! (-> a0-59 world-pos quad) (-> obj post-trans quad))
      (vector-reset! (-> a0-59 anim-to-local-trans-offset))
      (+! (-> a0-59 anim-to-local-trans-offset z) (* 5447.68 (the float v1-110)))
      )
    )
  (logior! (-> obj skel status) (janim-status inited))
  (set! (-> obj link) (new 'process 'actor-link-info obj))
  (set! (-> obj gnawer-id) (+ (actor-count-before (-> obj link)) 1))
  (if (and (-> obj entity) (logtest? (-> obj entity extra perm status) (entity-perm-status complete)))
      (go gnawer-put-items-at-dest)
      (go gnawer-chewing-on-post)
      )
  (none)
  )
