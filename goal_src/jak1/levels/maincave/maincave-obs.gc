;;-*-Lisp-*-
(in-package goal)

;; name: maincave-obs.gc
;; name in dgo: maincave-obs
;; dgos: L1, MAI, MAINCAVE

;; DECOMP BEGINS

(import "goal_src/jak1/import/caveelevator-ag.gc")
(import "goal_src/jak1/import/cavespatulatwo-ag.gc")
(import "goal_src/jak1/import/cavetrapdoor-ag.gc")
(import "goal_src/jak1/import/maincavecam-ag.gc")
(import "goal_src/jak1/import/cavecrusher-ag.gc")
(import "goal_src/jak1/import/cavespatula-darkcave-ag.gc")

(deftype maincavecam (pov-camera)
  ((seq uint64  :offset-assert 224)
   )
  :heap-base #x80
  :method-count-assert 30
  :size-assert         #xe8
  :flag-assert         #x1e008000e8
  )


(defskelgroup *maincavecam-sg* maincavecam maincavecam-lod0-jg -1
              ((maincavecam-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 10)
              )

(defmethod set-stack-size! maincavecam ((obj maincavecam))
  (stack-size-set! (-> obj main-thread) 512)
  (none)
  )

(defstate pov-camera-playing (maincavecam)
  :virtual #t
  :code (behavior ()
    (cond
      ((zero? (-> self seq))
       (let ((gp-1
               (ppointer->handle
                 (process-spawn
                   fuel-cell
                   :init fuel-cell-init-as-clone
                   (process->handle self)
                   (-> self entity extra perm task)
                   :to (ppointer->process (-> self parent))
                   )
                 )
               )
             )
         (ja-play-spooled-anim
           (new 'static 'spool-anim :name "maincavecam-gnawer-fuel-cell" :index 3 :parts 1 :command-list '())
           (the-as art-joint-anim #f)
           (the-as art-joint-anim #f)
           (the-as (function process-drawable symbol) false-func)
           )
         (let ((a0-7 (handle->process gp-1)))
           (if a0-7
               (send-event a0-7 'stop-cloning)
               )
           )
         )
       )
      (else
        (suspend)
        0
        )
      )
    (go-virtual pov-camera-done-playing)
    (none)
    )
  )

(deftype cave-water (water-anim)
  ()
  :heap-base #x70
  :method-count-assert 30
  :size-assert         #xdc
  :flag-assert         #x1e007000dc
  )


(define ripple-for-cave-water (new 'static 'ripple-wave-set
                                :count 3
                                :converted #f
                                :normal-scale 1.0
                                :wave (new 'static 'inline-array ripple-wave 4
                                  (new 'static 'ripple-wave :scale 40.0 :xdiv 1 :speed 1.5)
                                  (new 'static 'ripple-wave :scale 40.0 :xdiv -1 :zdiv 1 :speed 1.5)
                                  (new 'static 'ripple-wave :scale 20.0 :xdiv 5 :zdiv 3 :speed 0.75)
                                  (new 'static 'ripple-wave)
                                  )
                                )
        )

(defmethod water-vol-method-22 cave-water ((obj cave-water))
  (let ((t9-0 (method-of-type water-anim water-vol-method-22)))
    (t9-0 obj)
    )
  (let ((v1-2 (new 'process 'ripple-control)))
    (set! (-> obj draw ripple) v1-2)
    (set! (-> v1-2 global-scale) 3072.0)
    (set! (-> v1-2 close-fade-dist) 163840.0)
    (set! (-> v1-2 far-fade-dist) 245760.0)
    (set! (-> v1-2 waveform) ripple-for-cave-water)
    )
  (case (-> obj look)
    ((37 14)
     (set-vector! (-> obj draw color-mult) 0.2 0.1 0.3 0.75)
     )
    )
  (none)
  )

(deftype cavecrusher (process-drawable)
  ((root-override collide-shape  :offset 112)
   )
  :heap-base #x40
  :method-count-assert 20
  :size-assert         #xb0
  :flag-assert         #x14004000b0
  (:states
    cavecrusher-idle
    )
  )


(defskelgroup *cavecrusher-sg* cavecrusher cavecrusher-lod0-jg -1
              ((cavecrusher-lod0-mg (meters 20)) (cavecrusher-lod1-mg (meters 40)) (cavecrusher-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(defstate cavecrusher-idle (cavecrusher)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('touch 'attack)
                      (when (= (-> proc type) target)
                        (if ((method-of-type touching-shapes-entry prims-touching-action?)
                             (the-as touching-shapes-entry (-> event param 0))
                             (-> *target* control)
                             (collide-action solid)
                             (collide-action)
                             )
                            (the-as symbol (target-attack-up *target* 'attack-or-shove 'deadlyup))
                            )
                        )
                      )
                     )
            )
    )
  :code (behavior ()
    (loop
      (ja-no-eval :group! (-> self draw art-group data 4) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (update! (-> self sound))
        (suspend)
        (ja :num! (seek!))
        )
      )
    (none)
    )
  :post (the-as (function none :behavior cavecrusher) ja-post)
  )

(defmethod init-from-entity! cavecrusher ((obj cavecrusher) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 0)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 11468.8)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *cavecrusher-sg* '())
  (set! (-> obj sound)
        (new 'process 'ambient-sound (static-sound-spec "crush-click" :fo-max 30) (-> obj root-override trans))
        )
  (ja-channel-push! 1 0)
  (let ((s5-1 (-> obj skel root-channel 0)))
    (joint-control-channel-group-eval!
      s5-1
      (the-as art-joint-anim (-> obj draw art-group data 4))
      num-func-identity
      )
    (set! (-> s5-1 frame-num) 0.0)
    )
  (ja-post)
  (update-transforms! (-> obj root-override))
  (go cavecrusher-idle)
  (none)
  )

(deftype cavetrapdoor (process-drawable)
  ((root-override       collide-shape-moving  :offset        112)
   (delay-before-wiggle int32                 :offset-assert 176)
   )
  :heap-base #x50
  :method-count-assert 22
  :size-assert         #xb4
  :flag-assert         #x16005000b4
  (:methods
    (idle () _type_ :state 20)
    (trigger () _type_ :state 21)
    )
  )


(defskelgroup *cavetrapdoor-sg* cavetrapdoor cavetrapdoor-lod0-jg -1
              ((cavetrapdoor-lod0-mg (meters 20)) (cavetrapdoor-lod1-mg (meters 40)) (cavetrapdoor-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              :longest-edge (meters 5.7)
              )

(defstate idle (cavetrapdoor)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('touch)
       (when (= (-> proc type) target)
         (when (>= (- (-> (target-pos 0) y) (-> self root-override trans y)) 409.6)
           (send-event proc 'no-look-around (seconds 1.5))
           (go-virtual trigger)
           )
         )
       )
      )
    )
  :code (behavior ()
    (ja-no-eval :group! (-> self draw art-group data 4) :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (transform-post)
      (suspend)
      (ja :num! (seek!))
      )
    (anim-loop)
    (none)
    )
  )

(defstate trigger (cavetrapdoor)
  :virtual #t
  :code (behavior ()
    (when (nonzero? (-> self delay-before-wiggle))
      (set! (-> self state-time) (-> *display* base-frame-counter))
      (until (>= (- (-> *display* base-frame-counter) (-> self state-time)) (-> self delay-before-wiggle))
        (suspend)
        )
      )
    (ja-no-eval :group! (-> self draw art-group data 5) :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (clear-collide-with-as (-> self root-override))
    (ja-no-eval :group! (-> self draw art-group data 6) :num! (seek! (ja-aframe 290.0 0)) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! (ja-aframe 290.0 0)))
      )
    (restore-collide-with-as (-> self root-override))
    (ja-no-eval :num! (seek!))
    (while (not (ja-done? 0))
      (suspend)
      (ja-eval)
      )
    (until (or (or (not *target*)
                   (< 28672.0 (vector-vector-distance (-> self root-override trans) (-> *target* control trans)))
                   )
               (and (not (and (logtest? (-> *target* control unknown-surface00 flags) (surface-flags jump))
                              (not (logtest? (-> *target* control status) (cshape-moving-flags onsurf)))
                              )
                         )
                    (not (logtest? (-> *target* control root-prim prim-core action) (collide-action edgegrab-cam)))
                    )
               )
      (ja-no-eval :group! (-> self draw art-group data 7) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      (label cfg-14)
      )
    (ja-no-eval :group! (-> self draw art-group data 8) :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (when (and (and *target* (>= 28672.0 (vector-vector-distance (-> self root-override trans) (-> *target* control trans))))
                 (or (and (logtest? (-> *target* control unknown-surface00 flags) (surface-flags jump))
                          (not (logtest? (-> *target* control status) (cshape-moving-flags onsurf)))
                          )
                     (logtest? (-> *target* control root-prim prim-core action) (collide-action edgegrab-cam))
                     )
                 )
        (while (not (ja-min? 0))
          (suspend)
          (ja :num! (seek! 0.0))
          )
        (goto cfg-14)
        )
      (suspend)
      (ja :num! (seek!))
      )
    (go-virtual idle)
    (none)
    )
  :post (the-as (function none :behavior cavetrapdoor) pusher-post)
  )

(defmethod init-from-entity! cavetrapdoor ((obj cavetrapdoor) (arg0 entity-actor))
  (logior! (-> obj mask) (process-mask platform))
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s4-0 1)
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 9830.4 10240.0 0.0 17203.2)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *cavetrapdoor-sg* '())
  (ja-channel-push! 1 0)
  (let ((s4-1 (-> obj skel root-channel 0)))
    (joint-control-channel-group-eval!
      s4-1
      (the-as art-joint-anim (-> obj draw art-group data 4))
      num-func-identity
      )
    (set! (-> s4-1 frame-num) 0.0)
    )
  (ja-post)
  (update-transforms! (-> obj root-override))
  (let ((f0-7 (quaternion-y-angle (-> obj root-override quat)))
        (s4-2 (-> obj draw bounds))
        )
    (set-vector! s4-2 0.0 -8192.0 4096.0 1.0)
    (vector-rotate-around-y! s4-2 s4-2 f0-7)
    (set! (-> s4-2 w) 25600.0)
    )
  (set! (-> obj delay-before-wiggle) (the int (* 300.0 (res-lump-float arg0 'delay))))
  (create-connection!
    *cavecrystal-light-control*
    obj
    (-> obj entity)
    (the-as (function object object object object object) cavecrystal-light-control-default-callback)
    -1
    8192.0
    )
  (go (method-of-object obj idle))
  (none)
  )

(deftype caveflamepots (process-drawable)
  ((root-override      collide-shape           :offset        112)
   (shove-up           float                   :offset-assert 176)
   (cycle-speed        int32                   :offset-assert 180)
   (cycle-pause        int32                   :offset-assert 184)
   (cycle-offset       uint32                  :offset-assert 188)
   (was-deadly?        symbol                  :offset-assert 192)
   (should-play-sound? symbol                  :offset-assert 196)
   (launch-pos         vector        2 :inline :offset-assert 208)
   )
  :heap-base #x80
  :method-count-assert 20
  :size-assert         #xf0
  :flag-assert         #x14008000f0
  (:states
    caveflamepots-active
    )
  )


(defpart 704
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 1.0)
    (:scale-x (meters 2))
    (:rot-z (degrees -180) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 128.0)
    (:b 0.0)
    (:a 128.0)
    (:vel-y (meters 0.04) (meters 0.01))
    (:scalevel-x (meters -0.0039999997))
    (:rotvel-z (degrees -1.8) (degrees 1.8))
    (:scalevel-y :copy scalevel-x)
    (:fade-g -1.28)
    (:fade-a -0.85333335)
    (:accel-y (meters -0.0006))
    (:timer (seconds 16.68))
    (:flags (bit2 bit3))
    )
  )

(defpart 705
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 1.0)
    (:scale-x (meters 2))
    (:rot-z (degrees -180) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 128.0)
    (:b 0.0)
    (:a 128.0)
    (:vel-y (meters 0.04) (meters 0.01))
    (:scalevel-x (meters -0.0039999997))
    (:rotvel-z (degrees -1.8) (degrees 1.8))
    (:scalevel-y :copy scalevel-x)
    (:fade-g -1.28)
    (:fade-a -0.85333335)
    (:accel-y (meters -0.0006))
    (:timer (seconds 16.68))
    (:flags (bit2 bit3))
    )
  )

(defstate caveflamepots-active (caveflamepots)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('touch 'attack)
       (when (= (-> proc type) target)
         (when ((method-of-type touching-shapes-entry prims-touching-action?)
                (the-as touching-shapes-entry (-> event param 0))
                (-> *target* control)
                (collide-action solid)
                (collide-action)
                )
           (let ((s4-0 (new 'stack 'attack-info)))
             (calc-shove-up (-> self root-override) s4-0 (-> self shove-up))
             (if (or (= (-> *target* control unknown-surface00 mode) 'air)
                     (>= (+ (-> *display* base-frame-counter) (seconds -0.2)) (-> *target* control unknown-dword11))
                     (< 0.75 (-> *target* control poly-normal y))
                     )
                 (send-event
                   proc
                   'attack-or-shove
                   (-> event param 0)
                   (static-attack-info ((mode 'burn) (vector (-> s4-0 vector)) (shove-up (-> s4-0 shove-up))))
                   )
                 (send-event
                   proc
                   'attack-or-shove
                   (-> event param 0)
                   (static-attack-info ((mode 'burn)
                                        (shove-up (meters 0))
                                        (shove-back (meters 2))
                                        (vector (-> *target* control poly-normal))
                                        (angle 'shove)
                                        )
                                       )
                   )
                 )
             )
           )
         )
       )
      )
    )
  :trans (behavior ()
    (let* ((v1-0 (-> self cycle-speed))
           (a0-1 (- v1-0 (-> self cycle-pause)))
           (gp-0 (mod (+ (-> *display* base-frame-counter) (the-as time-frame (-> self cycle-offset))) v1-0))
           )
      (cond
        ((< gp-0 a0-1)
         (when (sphere-in-view-frustum? (the-as sphere (-> self root-override root-prim prim-core)))
           (launch-particles (-> *part-id-table* 704) (the-as vector (-> self launch-pos)))
           (launch-particles (-> *part-id-table* 705) (the-as vector (&-> self stack 112)))
           )
         (when (-> self should-play-sound?)
           (set! (-> self should-play-sound?) #f)
           (sound-play "hot-flame")
           )
         (cond
           ((< gp-0 30)
            (when (-> self was-deadly?)
              (set! (-> self was-deadly?) #f)
              (clear-collide-with-as (-> self root-override))
              )
            )
           (else
             (when (not (-> self was-deadly?))
               (set! (-> self was-deadly?) #t)
               (restore-collide-with-as (-> self root-override))
               )
             )
           )
         (when (and (not (-> self was-deadly?)) (< 60 gp-0))
           (set! (-> self was-deadly?) #t)
           (restore-collide-with-as (-> self root-override))
           )
         )
        (else
          (set! (-> self should-play-sound?) #t)
          (when (-> self was-deadly?)
            (set! (-> self was-deadly?) #f)
            (clear-collide-with-as (-> self root-override))
            )
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
      )
    (none)
    )
  )

(defmethod init-from-entity! caveflamepots ((obj caveflamepots) (arg0 entity-actor))
  (local-vars (sv-16 res-tag) (sv-32 res-tag) (sv-48 res-tag))
  (set! (-> obj was-deadly?) #f)
  (set! (-> obj should-play-sound?) #f)
  (set! (-> obj shove-up) (res-lump-float arg0 'shove :default 8192.0))
  (logclear! (-> obj mask) (process-mask enemy))
  (logclear! (-> obj mask) (process-mask attackable))
  (logior! (-> obj mask) (process-mask actor-pause))
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 4) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core offense) (collide-offense no-offense))
      (set-vector! (-> s3-0 local-sphere) 0.0 12288.0 0.0 10240.0)
      (set-root-prim! s4-0 s3-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 1))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-0 local-sphere) 4915.2 8192.0 0.0 3686.4)
        (append-prim s3-0 s2-0)
        )
      (let ((s2-1 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 1))))
        (set! (-> s2-1 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-1 collide-with) (collide-kind target))
        (set! (-> s2-1 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-1 local-sphere) 4915.2 14336.0 0.0 3276.8)
        (append-prim s3-0 s2-1)
        )
      (let ((s2-2 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 1))))
        (set! (-> s2-2 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-2 collide-with) (collide-kind target))
        (set! (-> s2-2 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-2 local-sphere) -4915.2 8192.0 0.0 3686.4)
        (append-prim s3-0 s2-2)
        )
      (let ((s2-3 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 1))))
        (set! (-> s2-3 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-3 collide-with) (collide-kind target))
        (set! (-> s2-3 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-3 local-sphere) -4915.2 14336.0 0.0 3276.8)
        (append-prim s3-0 s2-3)
        )
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (let ((v1-42 (new 'process 'path-control obj 'path 0.0)))
    (set! (-> obj path) v1-42)
    (logior! (-> v1-42 flags) (path-control-flag display draw-line draw-point draw-text))
    (if (<= (-> v1-42 curve num-cverts) 0)
        (go process-drawable-art-error "no path")
        )
    )
  (let ((f0-23 (res-lump-float arg0 'rotoffset)))
    (if (!= f0-23 0.0)
        (quaternion-rotate-y! (-> obj root-override quat) (-> obj root-override quat) f0-23)
        )
    )
  (let ((f30-0 (quaternion-y-angle (-> obj root-override quat))))
    (let ((s4-1 (-> obj launch-pos)))
      (let ((v1-53 s4-1))
        (set! (-> v1-53 0 x) 6144.0)
        (set! (-> v1-53 0 y) 0.0)
        (set! (-> v1-53 0 z) 0.0)
        (set! (-> v1-53 0 w) 1.0)
        )
      (vector-rotate-around-y! (the-as vector s4-1) (the-as vector s4-1) f30-0)
      (vector+! (the-as vector s4-1) (the-as vector s4-1) (-> obj root-override trans))
      )
    (let ((s4-2 (the-as object (&-> obj stack 112))))
      (set-vector! (the-as vector s4-2) -6144.0 0.0 0.0 1.0)
      (vector-rotate-around-y! (the-as vector s4-2) (the-as vector s4-2) f30-0)
      (vector+! (the-as vector s4-2) (the-as vector s4-2) (-> obj root-override trans))
      )
    (let ((s4-3 (-> obj root-override root-prim)))
      (dotimes (s3-1 (-> (the-as collide-shape-prim-group s4-3) num-prims))
        (let ((a1-19 (-> (the-as collide-shape-prim-group s4-3) prims s3-1 local-sphere)))
          (vector-rotate-around-y! a1-19 a1-19 f30-0)
          )
        )
      )
    )
  (update-transforms! (-> obj root-override))
  (let ((f30-1 300.0))
    (set! sv-16 (new 'static 'res-tag))
    (let ((v1-70 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-16))))
      (set! (-> obj cycle-speed) (the int (* f30-1 (if (and v1-70 (> (the-as int (-> sv-16 elt-count)) 0))
                                                       (-> v1-70 0)
                                                       4.0
                                                       )
                                             )
                                      )
            )
      )
    )
  (let ((f30-2 (the float (-> obj cycle-speed))))
    (set! sv-32 (new 'static 'res-tag))
    (let ((v1-74 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-32))))
      (set! (-> obj cycle-offset)
            (the-as uint (the int (* f30-2 (if (and v1-74 (< 1 (the-as int (-> sv-32 elt-count))))
                                               (-> v1-74 1)
                                               0.0
                                               )
                                     )
                              )
                    )
            )
      )
    )
  (let ((f30-3 300.0))
    (set! sv-48 (new 'static 'res-tag))
    (let ((v1-77 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-48))))
      (set! (-> obj cycle-pause) (the int (* f30-3 (if (and v1-77 (< 2 (the-as int (-> sv-48 elt-count))))
                                                       (-> v1-77 2)
                                                       2.0
                                                       )
                                             )
                                      )
            )
      )
    )
  (go caveflamepots-active)
  (none)
  )

(deftype cavespatula (process-drawable)
  ((root-override collide-shape-moving         :offset        112)
   (sync          sync-info            :inline :offset-assert 176)
   )
  :heap-base #x50
  :method-count-assert 20
  :size-assert         #xb8
  :flag-assert         #x14005000b8
  (:states
    cavespatula-idle
    )
  )


(defskelgroup *cavespatula-sg* cavespatula 0 -1
              ((1 (meters 20)) (2 (meters 999999)))
              :bounds (static-spherem 0 -1 0 18)
              )

(defskelgroup *cavespatula-darkcave-sg* cavespatula-darkcave cavespatula-darkcave-lod0-jg -1
              ((cavespatula-darkcave-lod0-mg (meters 20)) (cavespatula-darkcave-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 -1 0 18)
              )

(defstate cavespatula-idle (cavespatula)
  :trans (behavior ()
    (rider-trans)
    (update! (-> self sound))
    (let ((f0-0 (get-current-phase (-> self sync))))
      (quaternion-axis-angle! (-> self root-override quat) 0.0 1.0 0.0 (* -65536.0 f0-0))
      )
    (none)
    )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
      )
    (none)
    )
  :post (the-as (function none :behavior cavespatula) rider-post)
  )

(defmethod init-from-entity! cavespatula ((obj cavespatula) (arg0 entity-actor))
  (logior! (-> obj mask) (process-mask platform))
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s4-0 1)
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 0)
      (set-vector! (-> s3-0 local-sphere) 0.0 -8192.0 0.0 67584.0)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (set! (-> obj sound)
        (new 'process 'ambient-sound (static-sound-spec "spatula" :fo-min 25 :fo-max 50) (-> obj root-override trans))
        )
  (case (-> (if (-> obj entity)
                (-> obj entity extra level)
                (-> *level* level-default)
                )
            name
            )
    (('darkcave)
     (initialize-skeleton obj *cavespatula-darkcave-sg* '())
     (ja-channel-push! 1 0)
     (let ((s5-1 (-> obj skel root-channel 0)))
       (joint-control-channel-group-eval!
         s5-1
         (the-as art-joint-anim (-> obj draw art-group data 3))
         num-func-identity
         )
       (set! (-> s5-1 frame-num) 0.0)
       )
     )
    (else
      (initialize-skeleton obj *cavespatula-sg* '())
      (ja-channel-push! 1 0)
      (let ((s5-2 (-> obj skel root-channel 0)))
        (joint-control-channel-group-eval!
          s5-2
          (the-as art-joint-anim (-> obj draw art-group data 3))
          num-func-identity
          )
        (set! (-> s5-2 frame-num) 0.0)
        )
      )
    )
  (logior! (-> obj skel status) (janim-status inited))
  (load-params! (-> obj sync) obj (the-as uint 3000) 0.0 0.15 0.15)
  (ja-post)
  (update-transforms! (-> obj root-override))
  (create-connection!
    *cavecrystal-light-control*
    obj
    (-> obj entity)
    (the-as (function object object object object object) cavecrystal-light-control-default-callback)
    -1
    32768.0
    )
  (go cavespatula-idle)
  (none)
  )

(deftype cavespatulatwo (process-drawable)
  ((root-override collide-shape-moving         :offset        112)
   (sync          sync-info            :inline :offset-assert 176)
   )
  :heap-base #x50
  :method-count-assert 20
  :size-assert         #xb8
  :flag-assert         #x14005000b8
  (:states
    cavespatulatwo-idle
    )
  )


(defskelgroup *cavespatulatwo-sg* cavespatulatwo cavespatulatwo-lod0-jg -1
              ((cavespatulatwo-lod0-mg (meters 20)) (cavespatulatwo-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 2.5 0 21)
              :longest-edge (meters 8.7)
              )

(defstate cavespatulatwo-idle (cavespatulatwo)
  :trans (behavior ()
    (rider-trans)
    (update! (-> self sound))
    (let ((f0-0 (get-current-phase (-> self sync))))
      (quaternion-axis-angle! (-> self root-override quat) 0.0 1.0 0.0 (* -65536.0 f0-0))
      )
    (none)
    )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
      )
    (none)
    )
  :post (the-as (function none :behavior cavespatulatwo) rider-post)
  )

(defmethod init-from-entity! cavespatulatwo ((obj cavespatulatwo) (arg0 entity-actor))
  (logior! (-> obj mask) (process-mask platform))
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s4-0 1)
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 0)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 75776.0)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *cavespatulatwo-sg* '())
  (logclear! (-> obj mask) (process-mask actor-pause))
  (logior! (-> obj skel status) (janim-status inited))
  (load-params! (-> obj sync) obj (the-as uint 3000) 0.0 0.15 0.15)
  (ja-channel-push! 1 0)
  (let ((s5-1 (-> obj skel root-channel 0)))
    (joint-control-channel-group-eval!
      s5-1
      (the-as art-joint-anim (-> obj draw art-group data 3))
      num-func-identity
      )
    (set! (-> s5-1 frame-num) 0.0)
    )
  (transform-post)
  (set! (-> obj sound)
        (new 'process 'ambient-sound (static-sound-spec "spatula" :fo-min 25 :fo-max 50) (-> obj root-override trans))
        )
  (go cavespatulatwo-idle)
  (none)
  )

(deftype caveelevator (process-drawable)
  ((root-override           collide-shape-moving         :offset        112)
   (elev-mode               uint64                       :offset-assert 176)
   (elev-type               int32                        :offset-assert 184)
   (prev-frame-num          float                        :offset-assert 188)
   (last-update-bounce-time time-frame                   :offset-assert 192)
   (orig-trans              vector               :inline :offset-assert 208)
   (sync                    sync-info            :inline :offset-assert 224)
   (smush                   smush-control        :inline :offset-assert 232)
   (anim                    int32                2       :offset-assert 264)
   (wheel-ry-mat            matrix               :inline :offset        272)
   )
  :heap-base #xe0
  :method-count-assert 22
  :size-assert         #x150
  :flag-assert         #x1600e00150
  (:methods
    (caveelevator-method-20 (_type_) none 20)
    (caveelevator-method-21 (_type_) float 21)
    )
  (:states
    caveelevator-cycle-active
    caveelevator-one-way-idle-end
    caveelevator-one-way-idle-start
    caveelevator-one-way-travel-to-end
    caveelevator-one-way-travel-to-start
    )
  )


(defskelgroup *caveelevator-sg* caveelevator caveelevator-lod0-jg -1
              ((caveelevator-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4.25)
              )

(defun cavecrystal-light-control-caveelevator-callback ((arg0 (pointer cavecrystal)) (arg1 int) (arg2 float))
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (let ((v1-1 (-> arg0 0 node-list)))
      (if (and (>= arg1 0) (nonzero? v1-1))
          (vector<-cspace! s5-0 (-> v1-1 data arg1))
          (set! (-> s5-0 quad) (-> arg0 0 root-override trans quad))
          )
      )
    (set! (-> s5-0 w) arg2)
    (let ((f0-1 (cavecrystal-light-control-method-10 *cavecrystal-light-control* s5-0))
          (a2-2 (new 'static 'vector :x 1.0 :y 1.0 :z 1.0 :w 1.0))
          (a1-5 (new 'static 'vector :x 0.3 :y 0.3 :z 0.3 :w 1.0))
          )
      (vector-lerp! (-> arg0 0 draw color-mult) a1-5 a2-2 f0-1)
      )
    )
  )

(defmethod caveelevator-method-20 caveelevator ((obj caveelevator))
  (let ((v1-1 (-> *display* base-frame-counter)))
    (when (!= v1-1 (-> obj last-update-bounce-time))
      (set! (-> obj last-update-bounce-time) v1-1)
      (when (!= (-> obj smush amp) 0.0)
        (let ((s5-0 (new 'stack-no-clear 'vector)))
          (set! (-> s5-0 quad) (-> obj orig-trans quad))
          (+! (-> s5-0 y) (* 819.2 (update! (-> obj smush))))
          (move-to-point! (-> obj root-override) s5-0)
          )
        )
      )
    )
  (none)
  )

(defmethod caveelevator-method-21 caveelevator ((obj caveelevator))
  (let ((s5-0 (new 'stack-no-clear 'vector))
        (gp-0 (-> obj draw bounds))
        )
    (vector<-cspace! s5-0 (-> obj node-list data 3))
    (vector-! gp-0 s5-0 (-> obj root-override trans))
    (set! (-> gp-0 w) 17408.0)
    )
  )

(defstate caveelevator-cycle-active (caveelevator)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('bonk)
                      (activate! (-> self smush) -1.0 60 150 1.0 1.0)
                      )
                     )
            )
    )
  :enter (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    (none)
    )
  :exit (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    (none)
    )
  :trans (behavior ()
    (rider-trans)
    (caveelevator-method-20 self)
    (none)
    )
  :code (behavior ()
    (loop
      (let ((f30-1 (* (get-current-phase (-> self sync)) (the float (ja-num-frames 0)))))
        (if (< (-> self prev-frame-num) f30-1)
            (ja :num! (seek! f30-1 10000.0))
            (ja :num-func num-func-identity :frame-num f30-1)
            )
        (set! (-> self prev-frame-num) f30-1)
        )
      (suspend)
      )
    (none)
    )
  :post (behavior ()
    (rider-post)
    (caveelevator-method-21 self)
    (none)
    )
  )

(defstate caveelevator-one-way-idle-start (caveelevator)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('bonk)
       (activate! (-> self smush) -1.0 60 150 1.0 1.0)
       (go caveelevator-one-way-travel-to-end)
       )
      (('attack 'touch)
       (if (and (= (-> proc type) target)
                (>= 8192.0 (vector-vector-xz-distance (target-pos 0) (-> self root-override trans)))
                )
           (go caveelevator-one-way-travel-to-end)
           )
       )
      )
    )
  :trans (behavior ()
    (rider-trans)
    (caveelevator-method-20 self)
    (none)
    )
  :code (behavior ()
    (ja :group! (-> (the-as art-joint-anim (+ (* (-> self anim 0) 4) (the-as int (-> self draw art-group))))
                   master-art-group-name
                   )
        :num! min
        )
    (loop
      (suspend)
      )
    (none)
    )
  :post (behavior ()
    (rider-post)
    (caveelevator-method-21 self)
    (none)
    )
  )

(defstate caveelevator-one-way-travel-to-end (caveelevator)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('bonk)
                      (activate! (-> self smush) -1.0 60 150 1.0 1.0)
                      )
                     )
            )
    )
  :enter (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    (none)
    )
  :exit (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    (none)
    )
  :trans (behavior ()
    (rider-trans)
    (caveelevator-method-20 self)
    (none)
    )
  :code (behavior ()
    (ja :group! (-> self draw art-group data (-> self anim 0)) :num! min)
    (ja-no-eval :num! (seek!))
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go caveelevator-one-way-idle-end)
    (none)
    )
  :post (behavior ()
    (rider-post)
    (caveelevator-method-21 self)
    (none)
    )
  )

(defstate caveelevator-one-way-idle-end (caveelevator)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('bonk)
                      (activate! (-> self smush) -1.0 60 150 1.0 1.0)
                      )
                     )
            )
    )
  :enter (behavior ()
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (none)
    )
  :trans (behavior ()
    (cond
      ((zero? (-> self root-override riders num-riders))
       (if (>= (- (-> *display* base-frame-counter) (-> self state-time)) (seconds 3))
           (go caveelevator-one-way-travel-to-start)
           )
       )
      (else
        (set! (-> self state-time) (-> *display* base-frame-counter))
        )
      )
    (rider-trans)
    (caveelevator-method-20 self)
    (none)
    )
  :code (behavior ()
    (ja :group! (-> self draw art-group data (-> self anim 0)) :num! max)
    (loop
      (suspend)
      )
    (none)
    )
  :post (behavior ()
    (rider-post)
    (caveelevator-method-21 self)
    (none)
    )
  )

(defstate caveelevator-one-way-travel-to-start (caveelevator)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('bonk)
                      (activate! (-> self smush) -1.0 60 150 1.0 1.0)
                      )
                     )
            )
    )
  :enter (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    (none)
    )
  :exit (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    (none)
    )
  :trans (behavior ()
    (rider-trans)
    (caveelevator-method-20 self)
    (none)
    )
  :code (behavior ()
    (ja :group! (-> self draw art-group data (-> self anim 1)) :num! min)
    (ja-no-eval :num! (seek!))
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go caveelevator-one-way-idle-start)
    (none)
    )
  :post (behavior ()
    (rider-post)
    (caveelevator-method-21 self)
    (none)
    )
  )

(defun caveelevator-joint-callback ((arg0 caveelevator))
  (let* ((gp-0 arg0)
         (f1-1 (- (-> arg0 node-list data 3 bone transform vector 3 y) (-> gp-0 orig-trans y)))
         (f30-0 (* 5.0929585 (- f1-1 (* (the float (the int (/ f1-1 12867.963))) 12867.963))))
         (s3-0 (-> arg0 node-list data 5 bone transform))
         (s4-0 (-> arg0 node-list data 4 bone transform))
         (s5-0 (new 'stack-no-clear 'vector))
         )
    (set! (-> s5-0 quad) (-> s3-0 vector 3 quad))
    (matrix-rotate-x! s3-0 f30-0)
    (matrix*! s3-0 s3-0 (-> gp-0 wheel-ry-mat))
    (set! (-> s3-0 vector 3 quad) (-> s5-0 quad))
    (set! (-> s5-0 quad) (-> s4-0 vector 3 quad))
    (matrix-rotate-x! s4-0 (- f30-0))
    (matrix*! s4-0 s4-0 (-> gp-0 wheel-ry-mat))
    (set! (-> s4-0 vector 3 quad) (-> s5-0 quad))
    )
  0
  (none)
  )

(defmethod init-from-entity! caveelevator ((obj caveelevator) (arg0 entity-actor))
  (local-vars (v1-43 int) (sv-16 res-tag))
  (set! (-> obj prev-frame-num) 10000.0)
  (set! (-> obj last-update-bounce-time) 0)
  (logior! (-> obj mask) (process-mask platform))
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s4-0 1)
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid rider-plat-sticky rider-plat))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 17408.0)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *caveelevator-sg* '())
  (logior! (-> obj skel status) (janim-status inited))
  (set! (-> obj skel postbind-function) caveelevator-joint-callback)
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-28 (res-lump-data arg0 'trans-offset (pointer float) :tag-ptr (& sv-16))))
    (when v1-28
      (+! (-> obj root-override trans x) (-> v1-28 0))
      (+! (-> obj root-override trans y) (-> v1-28 1))
      (+! (-> obj root-override trans z) (-> v1-28 2))
      )
    )
  (set! (-> obj orig-trans quad) (-> obj root-override trans quad))
  (let ((f0-13 (res-lump-float (-> obj entity) 'rotoffset)))
    (if (!= f0-13 0.0)
        (quaternion-rotate-y! (-> obj root-override quat) (-> obj root-override quat) f0-13)
        )
    )
  (let ((f0-14 (quaternion-y-angle (-> obj root-override quat))))
    (matrix-rotate-y! (-> obj wheel-ry-mat) f0-14)
    )
  (set-zero! (-> obj smush))
  (let ((s5-1 (res-lump-value arg0 'mode uint128)))
    0
    (set! (-> obj elev-type) (the-as int s5-1))
    (let ((v1-42 s5-1))
      (cond
        ((zero? v1-42)
         (set! v1-43 0)
         (set! (-> obj anim 0) 2)
         )
        ((= (the-as uint v1-42) 1)
         (set! v1-43 1)
         (set! (-> obj anim 0) 3)
         (set! (-> obj anim 1) 4)
         )
        ((= (the-as uint v1-42) 2)
         (set! v1-43 0)
         (set! (-> obj anim 0) 5)
         )
        (else
          (set! v1-43 0)
          (set! (-> obj anim 0) 2)
          (set! (-> obj elev-type) (the-as int s5-1))
          )
        )
      )
    (set! (-> obj elev-mode) (the-as uint v1-43))
    (ja-channel-set! 1)
    (let ((s4-1 (-> obj skel root-channel 0)))
      (joint-control-channel-group-eval!
        s4-1
        (the-as art-joint-anim (-> obj draw art-group data (-> obj anim 0)))
        num-func-identity
        )
      (set! (-> s4-1 frame-num) 0.0)
      )
    (if (= (the-as uint s5-1) 1)
        (create-connection!
          *cavecrystal-light-control*
          obj
          (-> obj entity)
          (the-as (function object object object object object) cavecrystal-light-control-caveelevator-callback)
          3
          8192.0
          )
        (create-connection!
          *cavecrystal-light-control*
          obj
          (-> obj entity)
          (the-as (function object object object object object) cavecrystal-light-control-default-callback)
          3
          8192.0
          )
        )
    )
  (transform-post)
  (let ((v1-55 (-> obj elev-mode)))
    (cond
      ((zero? v1-55)
       (load-params! (-> obj sync) obj (the-as uint 3000) 0.0 0.15 0.15)
       (go caveelevator-cycle-active)
       )
      ((= v1-55 1)
       (go caveelevator-one-way-idle-start)
       )
      )
    )
  (none)
  )
