;;-*-Lisp-*-
(in-package goal)

(deftype test-actor (process-drawable)
  ((root       collide-shape-moving :override)
   (birth-time time-frame)
   (base       vector :inline)
   (old-base   vector :inline)
   (bob-offset int64)
   (bob-amount float))
  (:methods
   (init-collision! (_type_) none))
  (:state-methods
   idle))

(def-art-elt test-actor-ag test-actor-lod0-jg 0)
(def-art-elt test-actor-ag test-actor-lod0-mg 1)
(def-art-elt test-actor-ag test-actor-idle-ja 2)
(defskelgroup *test-actor-sg*
  test-actor
  test-actor-lod0-jg
  test-actor-idle-ja
  ((test-actor-lod0-mg (meters 9999999)))
  :bounds (static-spherem 0 0 0 5)
  :texture-level 2)

(defmethod init-collision! ((this test-actor))
  (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) default-collision-reaction)
    (set! (-> cshape no-reaction) (the (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (let ((cgroup (new 'process 'collide-shape-prim-group cshape (the uint 1) 0)))
      (set! (-> cgroup prim-core collide-as) (collide-kind ground-object))
      (set! (-> cgroup collide-with) (collide-kind target))
      (set! (-> cgroup prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> cgroup transform-index) 0)
      (set-vector! (-> cgroup local-sphere) 0.0 0.0 0.0 (meters 5))
      (set-root-prim! cshape cgroup)
      (let ((mesh (new 'process 'collide-shape-prim-mesh cshape (the uint 0) (the uint 0))))
        (set! (-> mesh prim-core collide-as) (collide-kind ground-object))
        (set! (-> mesh collide-with) (collide-kind target))
        (set! (-> mesh prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> mesh prim-core offense) (collide-offense indestructible))
        (set! (-> mesh transform-index) 0)
        (set-vector! (-> mesh local-sphere) 0.0 (meters 0) 0.0 (meters 5))
        (append-prim cgroup mesh))
      ; (let ((sphere (new 'process 'collide-shape-prim-sphere cshape (the uint 0))))
      ;   (set! (-> sphere prim-core collide-as) (collide-kind enemy))
      ;   (set! (-> sphere collide-with) (collide-kind target))
      ;   (set! (-> sphere prim-core action) (collide-action solid))
      ;   (set! (-> sphere prim-core offense) (collide-offense normal-attack))
      ;   (set-vector! (-> sphere local-sphere) 0.0 0.0 0.0 (meters 2))
      ;   (set-root-prim! cshape sphere)
      ;   )
      )
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (backup-collide-with-as cshape)
    (set! (-> this root) cshape))
  (none))

(defmethod init-from-entity! ((this test-actor) (e entity-actor))
  (logior! (-> this mask) (process-mask enemy))
  (init-collision! this)
  (process-drawable-from-entity! this e)
  (set! (-> this bob-amount) 1024.0)
  (set! (-> this bob-offset)
        (+ (the int (-> this root trans x)) (the int (-> this root trans y)) (the int (-> this root trans z))))
  (set-time! (-> this birth-time))
  (vector-copy! (-> this base) (-> this root trans))
  (vector-copy! (-> this old-base) (-> this root trans))
  (initialize-skeleton this *test-actor-sg* '())
  (logclear! (-> this mask) (process-mask actor-pause))
  (transform-post)
  (go-virtual idle :proc this)
  (none))

(defbehavior test-actor-init-by-other test-actor ((pos vector))
  (logior! (-> self mask) (process-mask enemy))
  (init-collision! self)
  (initialize-skeleton self *test-actor-sg* '())
  (vector-copy! (-> self root trans) pos)
  (quaternion-identity! (-> self root quat))
  (vector-identity! (-> self root scale))
  (set! (-> self bob-amount) 1024.0)
  (set! (-> self bob-offset)
        (+ (the int (-> self root trans x)) (the int (-> self root trans y)) (the int (-> self root trans z))))
  (set-time! (-> self birth-time))
  (vector-copy! (-> self base) (-> self root trans))
  (vector-copy! (-> self old-base) (-> self root trans))
  (logclear! (-> self mask) (process-mask actor-pause))
  (transform-post)
  (go-virtual idle))

(defstate idle (test-actor)
  :virtual #t
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('attack 'touch)
         ; (if (= (-> proc type) target)
         ;   (send-event proc 'attack #f (static-attack-info ((shove-up (meters 2.5)) (shove-back (meters 7.5)))))
         ;   )
         #t)))
  :code
    (behavior ()
      (loop
        (quaternion-rotate-y! (-> self root quat) (-> self root quat) (* (degrees 45) (seconds-per-frame)))
        (let ((bob (-> self bob-amount)))
          (when (< 0.0 bob)
            (set! (-> self root trans y)
                  (+ (-> self base y)
                     (* bob
                        (sin (* 109.22667 (the float (mod (+ (- (current-time) (-> self birth-time)) (-> self bob-offset)) (seconds 2))))))))
            (update-transforms! (-> self root))))
        ; (debug-draw-tris (-> (res-lump-struct (-> self draw art-group data 0 extra) 'collide-mesh-group (array collide-mesh)) 0) self 2)
        ; (dotimes (i (-> self node-list length))
        ;   (let* ((joint (-> self node-list data i)) (jpos (vector<-cspace! (new-stack-vector0) joint)))
        ;     (add-debug-sphere #t (bucket-id debug) jpos (meters 0.1) (static-rgba 0 #xff 0 #x40))
        ;     (add-debug-text-sphere (!= (-> joint joint) #f) (bucket-id debug) jpos (meters 0.1) (-> joint joint name) (static-rgba 0 #xff 0 #x40))
        ;     )
        ;   )
        (suspend)))
  :post transform-post)
