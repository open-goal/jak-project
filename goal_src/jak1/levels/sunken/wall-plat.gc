;;-*-Lisp-*-
(in-package goal)

;; name: wall-plat.gc
;; name in dgo: wall-plat
;; dgos: L1, SUN, SUNKEN

(declare-type wall-plat process-drawable)

;; DECOMP BEGINS


(deftype wall-plat (process-drawable)
  ((root-override   collide-shape-moving         :offset        112)
   (use-sync?       symbol                       :offset-assert 176)
   (extended-amount float                        :offset-assert 180)
   (in-trans        vector               :inline :offset-assert 192)
   (out-trans       vector               :inline :offset-assert 208)
   (sync            sync-info-paused     :inline :offset-assert 224)
   )
  :heap-base #x80
  :method-count-assert 20
  :size-assert         #xf0
  :flag-assert         #x14008000f0
  (:states
    wall-plat-extended
    wall-plat-extending
    wall-plat-retracted
    wall-plat-retracting
    wall-plat-sync-idle
    )
  )


(defskelgroup *wall-plat-sg* wall-plat wall-plat-lod0-jg -1
              ((wall-plat-lod0-mg (meters 999999)))
              :bounds (static-spherem 1 -2 0 6.5)
              )

(defstate wall-plat-retracted (wall-plat)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('trigger)
       (go wall-plat-extending)
       )
      )
    )
  :code (behavior ()
    (set! (-> self extended-amount) 0.0)
    (move-to-point! (-> self root-override) (-> self in-trans))
    (transform-post)
    (clear-collide-with-as (-> self root-override))
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
      )
    (none)
    )
  )

(defstate wall-plat-extending (wall-plat)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('touch)
                      (send-event proc 'no-look-around (seconds 1.5))
                      #f
                      )
                     )
            )
    )
  :enter (behavior ()
    (sound-play "wall-plat")
    (none)
    )
  :trans (the-as (function none :behavior wall-plat) rider-trans)
  :code (behavior ()
    (restore-collide-with-as (-> self root-override))
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (loop
      (seek! (-> self extended-amount) 1.0 (* 2.5 (-> *display* seconds-per-frame)))
      (let ((gp-0 (new 'stack-no-clear 'vector)))
        (vector-lerp! gp-0 (-> self in-trans) (-> self out-trans) (-> self extended-amount))
        (move-to-point! (-> self root-override) gp-0)
        )
      (suspend)
      (if (= (-> self extended-amount) 1.0)
          (go wall-plat-extended)
          )
      )
    (none)
    )
  :post (the-as (function none :behavior wall-plat) rider-post)
  )

(defstate wall-plat-extended (wall-plat)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('untrigger)
       (go wall-plat-retracting)
       )
      )
    )
  :code (behavior ()
    (set! (-> self extended-amount) 1.0)
    (move-to-point! (-> self root-override) (-> self out-trans))
    (transform-post)
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
      )
    (none)
    )
  )

(defstate wall-plat-retracting (wall-plat)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('touch)
                      (send-event proc 'no-look-around (seconds 1.5))
                      #f
                      )
                     )
            )
    )
  :enter (behavior ()
    (sound-play "wall-plat")
    (none)
    )
  :trans (the-as (function none :behavior wall-plat) rider-trans)
  :code (behavior ()
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (loop
      (seek! (-> self extended-amount) 0.0 (* 2.5 (-> *display* seconds-per-frame)))
      (let ((gp-0 (new 'stack-no-clear 'vector)))
        (vector-lerp! gp-0 (-> self in-trans) (-> self out-trans) (-> self extended-amount))
        (move-to-point! (-> self root-override) gp-0)
        )
      (suspend)
      (if (= (-> self extended-amount) 0.0)
          (go wall-plat-retracted)
          )
      )
    (none)
    )
  :post (the-as (function none :behavior wall-plat) rider-post)
  )

(defstate wall-plat-sync-idle (wall-plat)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('touch)
                      (send-event proc 'no-look-around (seconds 1.5))
                      #f
                      )
                     )
            )
    )
  :enter (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    (none)
    )
  :exit (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    (none)
    )
  :trans (the-as (function none :behavior wall-plat) rider-trans)
  :code (behavior ()
    (let ((gp-0 #f))
      (loop
        (let ((f30-0 (get-current-phase-with-mirror (-> self sync))))
          (let ((s5-0 (new 'stack-no-clear 'vector)))
            (vector-lerp! s5-0 (-> self in-trans) (-> self out-trans) f30-0)
            (move-to-point! (-> self root-override) s5-0)
            )
          (cond
            ((= f30-0 0.0)
             (set! gp-0 #f)
             (clear-collide-with-as (-> self root-override))
             )
            ((= f30-0 1.0)
             (set! gp-0 #f)
             (restore-collide-with-as (-> self root-override))
             )
            (else
              (when (not gp-0)
                (sound-play "wall-plat")
                (set! gp-0 #t)
                )
              (restore-collide-with-as (-> self root-override))
              )
            )
          )
        (suspend)
        )
      )
    (none)
    )
  :post (the-as (function none :behavior wall-plat) rider-post)
  )

(defmethod init-from-entity! wall-plat ((obj wall-plat) (arg0 entity-actor))
  (set! (-> obj extended-amount) 0.0)
  (logior! (-> obj mask) (process-mask platform))
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s4-0 1)
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid rider-plat-sticky rider-plat))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 2)
      (set-vector! (-> s3-0 local-sphere) 0.0 -6144.0 -12288.0 19456.0)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *wall-plat-sg* '())
  (logior! (-> obj skel status) (janim-status inited))
  (set! (-> obj use-sync?) (load-params! (-> obj sync) obj (the-as uint 1500) 0.0 0.2 0.2))
  (let ((f30-0 (quaternion-y-angle (-> obj root-override quat)))
        (s4-1 (new 'stack-no-clear 'vector))
        )
    (set-vector! s4-1 0.0 0.0 (+ 1638.4 (res-lump-float arg0 'tunemeters)) 1.0)
    (vector-rotate-around-y! s4-1 s4-1 f30-0)
    (vector+! (-> obj out-trans) (-> obj root-override trans) s4-1)
    (set-vector! s4-1 0.0 0.0 20480.0 1.0)
    (vector-rotate-around-y! s4-1 s4-1 f30-0)
    (vector+! (-> obj in-trans) (-> obj out-trans) s4-1)
    )
  (ja-channel-push! 1 0)
  (let ((s5-1 (-> obj skel root-channel 0)))
    (joint-control-channel-group-eval!
      s5-1
      (the-as art-joint-anim (-> obj draw art-group data 2))
      num-func-identity
      )
    (set! (-> s5-1 frame-num) 0.0)
    )
  (ja-post)
  (update-transforms! (-> obj root-override))
  (cond
    ((-> obj use-sync?)
     (logclear! (-> obj mask) (process-mask actor-pause))
     (go wall-plat-sync-idle)
     )
    (else
      (go wall-plat-retracted)
      )
    )
  (none)
  )
