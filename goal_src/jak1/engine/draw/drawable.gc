;;-*-Lisp-*-
(in-package goal)

;; name: drawable.gc
;; name in dgo: drawable
;; dgos: GAME, ENGINE

(defun sphere-cull ((arg0 vector))
  #t
  ;; todo
  )

(defun guard-band-cull ((arg0 vector))
  (local-vars (v1-0 uint128) (v1-1 uint128) (v1-2 uint128))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf10 :class vf)
         (vf20 :class vf)
         (vf21 :class vf)
         (vf22 :class vf)
         (vf23 :class vf)
         (vf9 :class vf)
         )
        (init-vf0-vector)
        ;; NOTE: manually added
        (let ((at-0 *math-camera*))
          (.lvf vf20 (&-> at-0 guard-plane 0 quad))
          (.lvf vf21 (&-> at-0 guard-plane 1 quad))
          (.lvf vf22 (&-> at-0 guard-plane 2 quad))
          (.lvf vf23 (&-> at-0 guard-plane 3 quad))
          )
        (.lvf vf10 (&-> arg0 quad))
        (.mul.x.vf acc vf20 vf10)
        (.add.mul.y.vf acc vf21 vf10 acc)
        (.add.mul.z.vf acc vf22 vf10 acc)
        (.sub.mul.w.vf vf9 vf23 vf0 acc)
        (.sub.w.vf vf9 vf9 vf10)
        (.mov v1-0 vf9)
        (.pcgtw v1-1 0 v1-0)
        (.ppach v1-2 (the-as uint128 0) v1-1)
        (nonzero? (the-as int v1-2))
        )
  )

(defun sphere-in-view-frustum? ((arg0 sphere))
  (local-vars (r0-0 uint128) (v1-1 uint128) (v1-2 uint128) (v1-3 uint128))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
   (init-vf0-vector)
   (set! r0-0 (the uint128 0))
   (let ((v1-0 *math-camera*))
    (.lvf vf6 (&-> arg0 quad))
    (.lvf vf1 (&-> v1-0 plane 0 quad))
    (.lvf vf2 (&-> v1-0 plane 1 quad))
    (.lvf vf3 (&-> v1-0 plane 2 quad))
    (.lvf vf4 (&-> v1-0 plane 3 quad))
    )
   (.mul.x.vf acc vf1 vf6)
   (.add.mul.y.vf acc vf2 vf6 acc)
   (.add.mul.z.vf acc vf3 vf6 acc)
   (.sub.mul.w.vf vf5 vf4 vf0 acc)
   (.add.w.vf vf5 vf5 vf6)
   (.mov v1-1 vf5)
   (.pcgtw v1-2 r0-0 v1-1)
   (.ppach v1-3 r0-0 v1-2)
   (zero? (the-as int v1-3))
   )
  )

(defun line-in-view-frustum? ((arg0 vector) (arg1 vector))
  (local-vars (v1-1 uint128) (v1-2 uint128) (v1-3 uint128) (a0-1 uint128) (a0-2 uint128) (a0-3 uint128))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf10 :class vf)
         (vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (let ((v1-0 *math-camera*))
      (.lvf vf9 (&-> arg0 quad))
      (.lvf vf10 (&-> arg1 quad))
      (.lvf vf16 (&-> v1-0 plane 0 quad))
      (.lvf vf17 (&-> v1-0 plane 1 quad))
      (.lvf vf18 (&-> v1-0 plane 2 quad))
      (.lvf vf19 (&-> v1-0 plane 3 quad))
      )
    (.mul.x.vf acc vf16 vf9)
    (.add.mul.y.vf acc vf17 vf9 acc)
    (.add.mul.z.vf acc vf18 vf9 acc)
    (.sub.mul.w.vf vf9 vf19 vf0 acc)
    (.mul.x.vf acc vf16 vf10)
    (.add.mul.y.vf acc vf17 vf10 acc)
    (.add.mul.z.vf acc vf18 vf10 acc)
    (.sub.mul.w.vf vf10 vf19 vf0 acc)
    (.mov v1-1 vf9)
    (.pcgtw v1-2 0 v1-1)
    (.ppach v1-3 (the-as uint128 0) v1-2)
    (.mov a0-1 vf10)
    (.pcgtw a0-2 0 a0-1)
    (.ppach a0-3 (the-as uint128 0) a0-2)
    (zero? (logand (the-as int v1-3) (the-as int a0-3)))
    )
  )

(defun vis-cull ((id int))
  "Is this thing visible? By draw-node id."
  ;; todo
  #t

  #|
  (let* ((addr (scratchpad-ptr int8 :offset (+ #x3b80 (/ id 8)))) ;; address of the vis data
         (vis-byte (-> addr 0)) ;; vis byte
         (shift-amount (+ 56 (logand id 7)))
         (shifted (shl vis-byte shift-amount))
         )
    (< shifted 0)
    )
    |#
  )

(defun error-sphere ((arg0 drawable-error) (arg1 string))
  (when *artist-error-spheres*
    (when (vis-cull (-> arg0 id))
      (when (sphere-cull (-> arg0 bsphere))
        (add-debug-sphere
          #t
          (bucket-id debug)
          (-> arg0 bsphere)
          (-> arg0 bsphere w)
          (new 'static 'rgba :r #x80 :a #x80)
          )
        (add-debug-text-3d #t (bucket-id debug-no-zbuf) arg1 (-> arg0 bsphere) (font-color white) (the-as vector2h #f))
        )
      )
    )
  0
  (none)
  )

(defmethod login drawable ((obj drawable))
  obj
  )

(defmethod draw drawable ((obj drawable) (arg0 drawable) (arg1 display-frame))
  0
  (none)
  )

(defmethod collide-with-box drawable ((obj drawable) (arg0 int) (arg1 collide-list))
  0
  (none)
  )

(defmethod collide-y-probe drawable ((obj drawable) (arg0 int) (arg1 collide-list))
  0
  (none)
  )

(defmethod collide-ray drawable ((obj drawable) (arg0 int) (arg1 collide-list))
  0
  (none)
  )

(defmethod collect-ambients drawable ((obj drawable) (arg0 sphere) (arg1 int) (arg2 ambient-list))
  0
  (none)
  )

(defmethod collect-stats drawable ((obj drawable))
  0
  (none)
  )

(defmethod debug-draw drawable ((obj drawable) (arg0 drawable) (arg1 display-frame))
  0
  (none)
  )

(defmethod draw drawable-error ((obj drawable-error) (arg0 drawable-error) (arg1 display-frame))
  (error-sphere arg0 (-> arg0 name))
  (none)
  )

(defmethod unpack-vis drawable ((obj drawable) (arg0 (pointer int8)) (arg1 (pointer int8)))
  arg1
  )

(define *edit-instance* (the-as string #f))

(when *debug-segment*
  (define *instance-mem-usage* (new 'debug 'memory-usage-block))
  )

(defun-debug find-instance-by-name ((arg0 string))
  (dotimes (s5-0 (-> *level* length))
    (let ((v1-3 (-> *level* level s5-0)))
      (when (= (-> v1-3 status) 'active)
        (let ((s4-0 (-> v1-3 bsp drawable-trees)))
          (dotimes (s3-0 (-> s4-0 length))
            (let ((v1-7 (-> s4-0 trees s3-0)))
              (case (-> v1-7 type)
                ((drawable-tree-instance-shrub)
                 (let ((s2-0 (-> (the-as drawable-tree-instance-shrub v1-7) info prototype-inline-array-shrub)))
                   (dotimes (s1-0 (-> s2-0 length))
                     (if (string= arg0 (the-as string (-> s2-0 data s1-0 name)))
                         (return (-> s2-0 data s1-0))
                         )
                     )
                   )
                 )
                ((drawable-tree-instance-tie)
                 (let ((s2-1 (-> (the-as drawable-tree-instance-tie v1-7) prototypes prototype-array-tie)))
                   (dotimes (s1-1 (-> s2-1 length))
                     (if (string= arg0 (the-as string (-> s2-1 array-data s1-1 name)))
                         (return (-> s2-1 array-data s1-1))
                         )
                     )
                   )
                 )
                )
              )
            )
          )
        )
      )
    )
  (the-as prototype-bucket #f)
  )

(defun-debug find-instance-by-index ((arg0 type) (arg1 int) (arg2 bsp-header))
  (dotimes (v1-0 (-> *level* length))
    (let ((a3-3 (-> *level* level v1-0)))
      (when (= (-> a3-3 status) 'active)
        (let ((a3-4 (-> a3-3 bsp)))
          (when (or (not arg2) (= a3-4 arg2))
            (let ((a3-5 (-> a3-4 drawable-trees)))
              (dotimes (t0-5 (-> a3-5 length))
                (let ((t1-3 (-> a3-5 trees t0-5)))
                  (case (-> t1-3 type)
                    ((drawable-tree-instance-shrub)
                     (when (= arg0 (-> t1-3 type))
                       (let ((v1-2 (-> (the-as drawable-tree-instance-shrub t1-3) info prototype-inline-array-shrub)))
                         (return (-> v1-2 data arg1))
                         )
                       )
                     )
                    ((drawable-tree-instance-tie)
                     (when (= arg0 (-> t1-3 type))
                       (let ((v1-5 (-> (the-as drawable-tree-instance-tie t1-3) prototypes prototype-array-tie)))
                         (return (-> v1-5 array-data arg1))
                         )
                       )
                     )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  (the-as prototype-bucket #f)
  )

(defun-debug prototype-bucket-type ((arg0 prototype-bucket))
  (case (-> arg0 geometry 1 type)
    ((prototype-shrubbery shrubbery)
     instance-shrubbery
     )
    ((prototype-tie prototype-tie tie-fragment)
     instance-tie
     )
    )
  )

(defun-debug prototype-bucket-recalc-fields ((arg0 prototype-bucket))
  (case (prototype-bucket-type arg0)
    ((instance-shrubbery)
     (set! (-> arg0 rdists x) (/ 1.0 (- (-> arg0 dists w) (-> arg0 dists x))))
     )
    (else
      (set! (-> arg0 dists z) (+ (-> arg0 dists x) (* 0.33333334 (- (-> arg0 dists w) (-> arg0 dists x)))))
      (set! (-> arg0 rdists x) (/ 1.0 (- (-> arg0 dists z) (-> arg0 dists x))))
      )
    )
  (set! (-> arg0 rdists z) (/ 1.0 (- (-> arg0 dists w) (-> arg0 dists z))))
  (set! (-> arg0 dists y) (* 0.5 (-> arg0 dists x)))
  (set! (-> arg0 rdists y) (/ 1.0 (-> arg0 dists y)))
  arg0
  )


#|
(defun-debug draw-instance-info ((arg0 string))
  (local-vars
    (sv-16 int)
    (sv-32 uint)
    (sv-48 uint)
    (sv-64 int)
    (sv-80 int)
    (sv-96 int)
    (sv-112 int)
    (sv-128 int)
    (sv-144 int)
    )
  (when (and *display-instance-info* *edit-instance*)
    (let ((s5-0 (find-instance-by-name *edit-instance*)))
      (when s5-0
        (let ((s2-0 (prototype-bucket-type s5-0)))
          (let ((s4-0 0))
            0
            (cond
              ((= s2-0 instance-shrubbery)
               (set! s4-0 595)
               )
              ((= s2-0 instance-tie)
               (reset! *instance-mem-usage*)
               (dotimes (s4-1 4)
                 (when (nonzero? (-> s5-0 geometry s4-1))
                   (let* ((a0-4 (-> s5-0 geometry s4-1))
                          (t9-3 (method-of-object a0-4 mem-usage))
                          (a1-0 *instance-mem-usage*)
                          (v1-16 s4-1)
                          )
                     (t9-3 a0-4 a1-0 (logior (cond
                                               ((= v1-16 1)
                                                4
                                                )
                                               ((= v1-16 2)
                                                8
                                                )
                                               ((= v1-16 3)
                                                16
                                                )
                                               (else
                                                 0
                                                 )
                                               )
                                             2
                                             )
                           )
                     )
                   )
                 )
               (set! s4-0 (+ (calculate-total *instance-mem-usage*) 580))
               )
              )
            (mem-usage s5-0 (reset! *instance-mem-usage*) 0)
            (let ((v1-26 (calculate-total *instance-mem-usage*)))
              (format
                arg0
                "~%~A ~A b @ #x~X ~,,2fK/~,,2fK~%"
                s2-0
                (-> s5-0 name)
                s5-0
                (* 0.0009765625 (the float v1-26))
                (* 0.0009765625 (the float s4-0))
                )
              )
            )
          (format arg0 "near: ~m  mid: ~m  far: ~m~%" (-> s5-0 dists x) (-> s5-0 dists z) (-> s5-0 dists w))
          (let ((s3-1 0)
                (s4-2 0)
                )
            (cond
              ((= s2-0 instance-shrubbery)
               (let ((f30-0 0.0))
                 (format
                   arg0
                   "usage: vis: ~D  shurb: ~D  trans-shrub ~D  bill: ~D   in level: ~D~%"
                   (-> s5-0 count 0)
                   (-> s5-0 count 1)
                   (-> s5-0 count 2)
                   (-> s5-0 count 3)
                   (-> s5-0 in-level)
                   )
                 (format arg0 "~%frag#     tris   dverts   strlen  tex~%")
                 (let ((s1-1 (-> s5-0 geometry 1))
                       (s2-1 (+ (-> s5-0 count 1) (-> s5-0 count 2)))
                       )
                   (dotimes (s0-0 (-> (the-as drawable-group s1-1) length))
                     (set! sv-16 (shrub-num-tris (the-as shrubbery (+ (+ (* s0-0 32) 32) (the-as int s1-1)))))
                     (set! sv-32 (-> (the-as prototype-shrubbery (+ (the-as uint s1-1) (* s0-0 32))) data 0 header data 2))
                     (set! sv-48 (-> (the-as prototype-shrubbery (+ (the-as uint s1-1) (* s0-0 32))) data 0 header data 0))
                     (format
                       arg0
                       "~5D     ~4D    ~5D   ~6f    ~D~%"
                       s0-0
                       sv-16
                       sv-32
                       (/ (* 2.0 (the float sv-16)) (the float (- sv-32 (the-as uint sv-16))))
                       sv-48
                       )
                     (+! s3-1 sv-16)
                     (+! s4-2 sv-32)
                     (set! f30-0
                           (+ 29.0
                              (* 5.5 (the float (- sv-32 (the-as uint sv-16))))
                              (* 22.0 (the float sv-48))
                              (* 8.0 (the float sv-32))
                              (* 53.0 (the float (/ (+ s2-1 9) (the-as uint 10))))
                              (* (the float s2-1) (+ 15.0 (* 5.0 (the float sv-48)) (* 13.5 (the float sv-32))))
                              f30-0
                              )
                           )
                     )
                   (format
                     arg0
                     "total     ~4D    ~5D   ~6f    ~D  speed: ~f~%"
                     s3-1
                     s4-2
                     (/ (* 2.0 (the float s3-1)) (the float (- s4-2 s3-1)))
                     (-> s5-0 utextures)
                     (/ f30-0 (* (the float s2-1) (the float s3-1)))
                     )
                   )
                 )
               )
              ((= s2-0 instance-tie)
               (set! sv-144 0)
               (let ((s1-2 0)
                     (s0-1 0)
                     (s2-2 0)
                     )
                 (format arg0 "~%level   visible  frags   tris   dverts   strlen  tex  ttris~%")
                 (set! sv-64 1)
                 (set! sv-80 3)
                 (while (>= sv-80 sv-64)
                   (let ((v1-65 (-> s5-0 geometry sv-64)))
                     (set! sv-96 0)
                     (set! sv-112 0)
                     (set! sv-128 0)
                     (dotimes (a0-23 (-> (the-as prototype-tie v1-65) length))
                       (set! sv-96 (+ sv-96 (l.hu (+ (the-as uint v1-65) (* a0-23 64) 68))))
                       (set! sv-112 (+ sv-112 (l.hu (+ (the-as uint v1-65) (* a0-23 64) 70))))
                       (set! sv-128 (+ sv-128 (l.hu (+ (the-as uint v1-65) (* a0-23 64) 60))))
                       )
                     (set! sv-144 (+ sv-144 (-> s5-0 count sv-64)))
                     (format arg0 "~5D  ~7D  ~5D   ~5D" sv-64 (-> s5-0 count sv-64) (-> (the-as prototype-tie v1-65) length) sv-96)
                     )
                   (format
                     arg0
                     "    ~5D   ~6f  ~3D  ~5D~%"
                     sv-112
                     (/ (* 2.0 (the float sv-96)) (the float (- sv-112 sv-96)))
                     sv-128
                     (* (the-as uint sv-96) (-> s5-0 count sv-64))
                     )
                   (+! s1-2 (* (the-as uint sv-96) (-> s5-0 count sv-64)))
                   (+! s0-1 (* (the-as uint sv-112) (-> s5-0 count sv-64)))
                   (+! s3-1 sv-96)
                   (+! s4-2 sv-112)
                   (+! s2-2 sv-128)
                   (set! sv-64 (+ sv-64 1))
                   )
                 (let ((t9-18 format)
                       (a0-39 arg0)
                       (a1-22 "total  ~7D/~3D      ~5D")
                       (a3-11 (-> s5-0 in-level))
                       )
                   (t9-18 a0-39 a1-22 sv-144 a3-11 s3-1)
                   )
                 (format
                   arg0
                   "    ~5D   ~6f  ~3D  ~5D~%"
                   s4-2
                   (/ (* 2.0 (the float s1-2)) (the float (- s0-1 s1-2)))
                   s2-2
                   s1-2
                   )
                 )
               )
              )
            )
          )
        )
      )
    )
  (none)
  )
|#

(defun dma-add-process-drawable ((arg0 process-drawable) (arg1 draw-control) (arg2 symbol) (arg3 dma-buffer))
  (local-vars (v1-37 float) (sv-16 process-drawable))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf15 :class vf)
         (vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf2 :class vf)
         (vf20 :class vf)
         (vf21 :class vf)
         (vf22 :class vf)
         (vf23 :class vf)
         (vf24 :class vf)
         (vf25 :class vf)
         (vf26 :class vf)
         (vf27 :class vf)
         (vf28 :class vf)
         (vf29 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         )
    (init-vf0-vector)
    (set! sv-16 arg0)
    (logclear! (-> arg1 status) (draw-status was-drawn))
    (when (zero? (logand (-> arg1 status) (draw-status hidden no-anim no-skeleton-update)))
      (let ((s4-0 (the-as vector (+ 48 (the-as int (scratchpad-object int)))))
            (vu-lgt (the-as vu-lights (+ 64 (the-as int (scratchpad-object int)))))
            (tod *time-of-day-context*)
            )
        (.lvf vf16 (&-> arg1 origin quad))
        (.lvf vf17 (&-> arg1 bounds quad))
        (.mul.x.vf vf16 vf16 vf0 :mask #b1000)
        (.add.vf vf16 vf16 vf17)
        (.svf (&-> s4-0 quad) vf16)
        (.lvf vf28 (&-> arg1 color-mult quad))
        (.lvf vf29 (&-> arg1 color-emissive quad))
        (when (sphere-in-view-frustum? (the-as sphere s4-0))
          (case (-> arg1 global-effect)
            (((draw-effect title))
             (when (not (-> tod title-updated))
               (set! (-> tod title-updated) #t)
               (let ((s0-0 (-> *math-camera* inv-camera-rot))
                     (a1-1 (new 'stack-no-clear 'vector))
                     (s1-0 (new 'stack-no-clear 'vector))
                     )
                 (set-vector! a1-1 0.612 0.5 -0.612 0.0)
                 (set-vector! s1-0 -0.696 0.174 0.696 0.0)
                 (vector-matrix*! (the-as vector (-> tod title-light-group)) a1-1 s0-0)
                 (vector-matrix*! (the-as vector (-> tod title-light-group dir1)) s1-0 s0-0)
                 )
               (set-vector! (-> *time-of-day-context* current-shadow) 0.612 -0.5 -0.612 1.0)
               )
             (vu-lights<-light-group! vu-lgt (-> tod title-light-group))
             )
            (else
              (let ((interp (-> arg1 secondary-interp))
                    (cur-interp (-> arg1 current-secondary-interp))
                    (shadow-msk (-> arg1 shadow-mask))
                    (lev-idx (-> arg1 level-index))
                    (lgt (-> tod light-group (-> *target* draw light-index)))
                    (cur-lgt (new 'stack-no-clear 'light-group))
                    )
                (cond
                  ((= (-> arg1 light-index) 255)
                   )
                  ((= lev-idx 2)
                   (set! lgt (-> tod light-group (-> arg1 light-index)))
                   )
                  (else
                    (set! lgt (-> tod moods lev-idx light-group (-> arg1 light-index)))
                    )
                  )
                (when (not (or (= lev-idx 2) (zero? shadow-msk)))
                  (let* ((lgt-msk-0 (-> tod light-masks-0 lev-idx))
                         (lgt-msk-1 (-> tod light-masks-1 lev-idx))
                         (lgt-interp (-> tod light-interp lev-idx))
                         (a0-13 (logand lgt-msk-0 shadow-msk))
                         (v1-18 (logand lgt-msk-1 shadow-msk))
                         )
                    (cond
                      ((and (zero? a0-13) (zero? v1-18))
                       )
                      (else
                        (set! interp (cond
                                       ((and (nonzero? a0-13) (nonzero? v1-18))
                                        1.0
                                        )
                                       ((zero? a0-13)
                                        (quad-copy! (the-as pointer cur-lgt) (the-as pointer lgt) 12)
                                        (set! lgt cur-lgt)
                                        (set! (-> lgt dir1 levels x) 0.0)
                                        lgt-interp
                                        )
                                       (else
                                         (quad-copy! (the-as pointer cur-lgt) (the-as pointer lgt) 12)
                                         (set! lgt cur-lgt)
                                         (set! (-> lgt dir0 levels x) 0.0)
                                         (- 1.0 lgt-interp)
                                         )
                                       )
                              )
                        )
                      )
                    )
                  )
                (if *teleport*
                    (set! cur-interp interp)
                    )
                (when (not (or (paused?) (= interp cur-interp)))
                  (let ((f0-15 (- cur-interp interp)))
                    (set! cur-interp (cond
                                       ((< (fabs f0-15) 0.2)
                                        interp
                                        )
                                       ((< f0-15 0.0)
                                        (+ 0.2 cur-interp)
                                        )
                                       (else
                                         (+ -0.2 cur-interp)
                                         )
                                       )
                          )
                    )
                  (set! (-> arg1 current-secondary-interp) cur-interp)
                  )
                (cond
                  ((= cur-interp 0.0)
                   (vu-lights<-light-group! vu-lgt lgt)
                   )
                  (else
                    (if (!= lgt cur-lgt)
                        (quad-copy! (the-as pointer cur-lgt) (the-as pointer lgt) 12)
                        )
                    (let ((f0-20 (- 1.0 cur-interp)))
                      (set! (-> cur-lgt dir0 levels x) (* (-> cur-lgt dir0 levels x) f0-20))
                      (set! (-> cur-lgt dir0 levels y) (* (-> cur-lgt dir0 levels y) f0-20))
                      (set! (-> cur-lgt dir1 levels x) (* (-> cur-lgt dir1 levels x) f0-20))
                      (set! (-> cur-lgt dir1 levels y) (* (-> cur-lgt dir1 levels y) f0-20))
                      (set! (-> cur-lgt dir2 levels x) (* (-> cur-lgt dir2 levels x) f0-20))
                      (set! (-> cur-lgt dir2 levels y) (* (-> cur-lgt dir2 levels y) f0-20))
                      )
                    (vu-lights<-light-group! vu-lgt cur-lgt)
                    )
                  )
                )
              (.lvf vf2 (&-> vu-lgt color 0 quad))
              (.lvf vf3 (&-> vu-lgt color 1 quad))
              (.lvf vf4 (&-> vu-lgt color 2 quad))
              (.lvf vf5 (&-> vu-lgt ambient quad))
              (.mul.vf vf5 vf5 vf28)
              (.mul.vf vf2 vf2 vf28)
              (.mul.vf vf3 vf3 vf28)
              (.mul.vf vf4 vf4 vf28)
              (.add.vf vf5 vf5 vf29)
              (.svf (&-> vu-lgt color 0 quad) vf2)
              (.svf (&-> vu-lgt color 1 quad) vf3)
              (.svf (&-> vu-lgt color 2 quad) vf4)
              (.svf (&-> vu-lgt ambient quad) vf5)
              (.mov v1-37 vf5)
              )
            )
          (if *display-lights*
              (add-debug-lights #t (bucket-id debug) (the-as (inline-array light) (-> tod light-group)) (-> arg1 origin))
              )
          (let ((at-0 *math-camera*))
            (.lvf vf16 (&-> at-0 plane 0 quad))
            (.lvf vf17 (&-> at-0 plane 1 quad))
            (.lvf vf18 (&-> at-0 plane 2 quad))
            (.lvf vf19 (&-> at-0 plane 3 quad))
            (.lvf vf20 (&-> at-0 guard-plane 0 quad))
            (.lvf vf21 (&-> at-0 guard-plane 1 quad))
            (.lvf vf22 (&-> at-0 guard-plane 2 quad))
            (.lvf vf23 (&-> at-0 guard-plane 3 quad))
            (.lvf vf24 (&-> at-0 camera-rot vector 0 quad))
            (.lvf vf25 (&-> at-0 camera-rot vector 1 quad))
            (.lvf vf26 (&-> at-0 camera-rot vector 2 quad))
            (.lvf vf27 (&-> at-0 camera-rot vector 3 quad))
            )
          (let ((v1-42 (the-as vector (+ 176 (the-as int (scratchpad-object int))))))
            (.lvf vf15 (&-> s4-0 quad))
            (.mul.w.vf acc vf27 vf0)
            (.add.mul.x.vf acc vf24 vf15 acc)
            (.add.mul.y.vf acc vf25 vf15 acc)
            (.add.mul.z.vf vf15 vf26 vf15 acc :mask #b111)
            (.mul.vf vf28 vf15 vf15)
            (.max.w.vf vf29 vf0 vf0)
            (.add.y.vf acc vf28 vf28)
            (.add.mul.z.vf vf28 vf29 vf28 acc :mask #b1)
            (.sqrt.vf Q vf28 :ftf #b0)
            (.sub.w.vf vf28 vf0 vf15 :mask #b1000)
            (.wait.vf)
            (.add.vf vf15 vf28 Q :mask #b1000)
            (.svf (&-> v1-42 quad) vf15)
            (when (< 0.0 (+ (-> v1-42 z) (-> arg1 bounds w)))
              (let ((lod-to-use 0))
                (let ((cam-dist (-> v1-42 w)))
                  (when (nonzero? (-> arg1 lod-set max-lod))
                    (cond
                      ((>= (-> arg1 force-lod) 0)
                       (set! lod-to-use (-> arg1 force-lod))
                       (if (#if (not PC_PORT)
                                (< (-> arg1 lod-set lod (-> arg1 lod-set max-lod) dist) cam-dist)
                                (and (-> *pc-settings* ps2-lod-dist?) (< (-> arg1 lod-set lod (-> arg1 lod-set max-lod) dist) cam-dist)))
                           (return #f)
                           )
                       )
                      (else
                        (while (and (< lod-to-use (-> arg1 lod-set max-lod)) (< (-> arg1 lod-set lod lod-to-use dist) cam-dist))
                          (+! lod-to-use 1)
                          )
                        )
                      )
                    )
                  ;; lod hacks!
                  (with-pc
                    (if (not (-> *pc-settings* ps2-lod-dist?))
                      (set! lod-to-use (minmax (-> *pc-settings* lod-force-actor) 0 (-> arg1 lod-set max-lod))))
                    )
                  (if (#if (not PC_PORT)
                           (and (< (-> arg1 lod-set lod lod-to-use dist) cam-dist) (< (-> arg1 force-lod) 0))
                           (and (-> *pc-settings* ps2-lod-dist?) (< (-> arg1 lod-set lod lod-to-use dist) cam-dist) (< (-> arg1 force-lod) 0))
                           )
                      (return #f)
                      )
                  (let ((v1-64 (-> arg1 sink-group level))
                        (a0-26 (+ (-> arg1 sink-group merc-sink foreground-texture-page) 6))
                        )
                    (when (#if (not PC_PORT)
                               (not (logtest? (-> arg1 status) (draw-status do-not-check-distance)))
                               (and (-> *pc-settings* ps2-lod-dist?) (not (logtest? (-> arg1 status) (draw-status do-not-check-distance))))
                               )
                      (if (< cam-dist (-> v1-64 closest-object a0-26))
                          (set! (-> v1-64 closest-object a0-26) cam-dist)
                          )
                      (when (and (!= a0-26 6) (!= (-> arg1 level-index) 2))
                        (let ((a1-45 (cond
                                       ((< 102400.0 cam-dist)
                                        (-> arg1 mgeo header masks 0)
                                        )
                                       ((< 81920.0 cam-dist)
                                        (-> arg1 mgeo header masks 1)
                                        )
                                       (else
                                         (-> arg1 mgeo header masks 2)
                                         )
                                       )
                                     )
                              )
                          (logior! (-> v1-64 texture-mask a0-26) a1-45)
                          )
                        )
                      )
                    )
                  (if (or (guard-band-cull s4-0) (< cam-dist (* 1.2 (-> *math-camera* d))))
                      (logior! (-> arg1 status) (draw-status needs-clip))
                      (logclear! (-> arg1 status) (draw-status needs-clip))
                      )
                  (logior! (-> arg1 status) (draw-status was-drawn))
                  (if (logtest? (-> arg1 status) (draw-status skip-bones))
                      (return #f)
                      )
                  (draw-bones arg1 arg3 cam-dist)
                  )
                (when (and (< lod-to-use (-> arg1 cur-lod)) (logtest? (-> arg1 status) (draw-status has-joint-channels)))
                  ;; NOTE : added this check for PC port to prevent memory corruption
                  (if (< (-> *matrix-engine* length) MATRIX_ENGINE_AMOUNT)
                    (let ((v1-82 *matrix-engine*))
                      (set! (-> v1-82 (-> v1-82 length)) (process->handle sv-16))
                      (+! (-> v1-82 length) 1)
                      )
                    )
                  )
                (lod-set! arg1 lod-to-use)
                )
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(define *hud-lights* (new 'global 'vu-lights))
(set-vector! (-> *hud-lights* direction 0) 1.0 0.0 0.0 1.0)
(set-vector! (-> *hud-lights* direction 1) 0.0 1.0 0.0 1.0)
(set-vector! (-> *hud-lights* direction 2) 0.0 0.0 1.0 1.0)
(set-vector! (-> *hud-lights* color 0) 0.0 0.0 0.0 1.0)
(set-vector! (-> *hud-lights* color 1) 0.0 0.0 0.0 1.0)
(set-vector! (-> *hud-lights* color 2) 0.5 0.5 0.5 1.0)
(set-vector! (-> *hud-lights* ambient) 0.5 0.5 0.5 1.0)

(defun dma-add-process-drawable-hud ((arg0 process-drawable) (arg1 draw-control) (arg2 symbol) (arg3 dma-buffer))
  (logclear! (-> arg1 status) (draw-status was-drawn))
  (when (zero? (logand (-> arg1 status) (draw-status hidden no-anim no-skeleton-update)))
    (let ((v1-6 (the-as vu-lights (+ 64 (scratchpad-object int))))
          (a0-3 *hud-lights*)
          )
      (set! (-> v1-6 direction 0 quad) (-> a0-3 direction 0 quad))
      (set! (-> v1-6 direction 1 quad) (-> a0-3 direction 1 quad))
      (set! (-> v1-6 direction 2 quad) (-> a0-3 direction 2 quad))
      (set! (-> v1-6 color 0 quad) (-> a0-3 color 0 quad))
      (set! (-> v1-6 color 1 quad) (-> a0-3 color 1 quad))
      (set! (-> v1-6 color 2 quad) (-> a0-3 color 2 quad))
      (set! (-> v1-6 ambient quad) (-> a0-3 ambient quad))
      )
    (lod-set! arg1 0)
    (logior! (-> arg1 status) (draw-status was-drawn))
    (draw-bones-hud arg1 arg3)
    )
  0
  (none)
  )

(defun add-process-drawable ((arg0 process-drawable) (arg1 draw-control) (arg2 symbol) (arg3 dma-buffer))
  ((-> arg1 dma-add-func) arg0 arg1 arg2 arg3)
  (none)
  )

(defun foreground-engine-execute ((arg0 engine) (arg1 display-frame) (arg2 int) (arg3 int))
  (let ((s4-0 (-> *display* frames (-> *display* on-screen) frame global-buf base)))
    (if *debug-segment*
        (add-frame
          (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
          'draw
          (new 'static 'rgba :r #x40 :b #x40 :a #x80)
          )
        )
    (let ((a1-2 (+ (+ (* arg3 32) 272 (* 2608 arg2)) (the-as int *level*)))
          (s2-1 (-> arg1 global-buf))
          )
      ; (let ((v1-14 (-> s2-1 base)))
      ;   (.sync.l)
      ;   (.cache dxwbin v1-14 0)
      ;   (.sync.l)
      ;   (.cache dxwbin v1-14 1)
      ;   )
      ; (.sync.l)
      0
      (bones-init s2-1 (the-as dma-foreground-sink-group a1-2))
      (execute-connections arg0 s2-1)
      )
    (bones-wrapup)
    (if *debug-segment*
        (add-frame
          (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
          'draw
          (new 'static 'rgba :r #xbe :g #x55 :b #x82 :a #x80)
          )
        )
    (let ((v1-24 *dma-mem-usage*))
      (when (nonzero? v1-24)
        (set! (-> v1-24 length) (max 36 (-> v1-24 length)))
        (set! (-> v1-24 data 35 name) "pris-fragment")
        (+! (-> v1-24 data 35 count) 1)
        (+! (-> v1-24 data 35 used)
            (&- (-> *display* frames (-> *display* on-screen) frame global-buf base) (the-as uint s4-0))
            )
        (set! (-> v1-24 data 35 total) (-> v1-24 data 35 used))
        )
      )
    )
  ;; todo
  (when (logtest? *vu1-enable-user* (vu1-renderer-mask generic))
    (when (nonzero? (-> *merc-globals* first))
      (let ((s4-1 (-> *display* frames (-> *display* on-screen) frame global-buf base)))
        (let ((a0-25 (-> (the-as (pointer uint32) (+ (the-as uint *level*) (* 2608 arg2) (* arg3 32))) 69)))
          (generic-merc-add-to-cue (the-as generic-dma-foreground-sink a0-25))
          )
        (let ((a0-26 *dma-mem-usage*))
          (when (nonzero? a0-26)
            (set! (-> a0-26 length) (max 87 (-> a0-26 length)))
            (set! (-> a0-26 data 86 name) "pris-generic")
            (+! (-> a0-26 data 86 count) 1)
            (+! (-> a0-26 data 86 used)
                (&- (-> *display* frames (-> *display* on-screen) frame global-buf base) (the-as uint s4-1))
                )
            (set! (-> a0-26 data 86 total) (-> a0-26 data 86 used))
            )
          )
        )
      )
    )
  (when #t
    (let ((v1-41 *shadow-queue*))
      (+! (-> v1-41 cur-run) 1)
      )
    )
  0
  (none)
  )

(defun-debug main-debug-hook ()
  (when (not (or (= *master-mode* 'menu) (= *master-mode* 'progress)))
    (execute-connections *debug-engine* #f)
    ;; (draw-instance-info *stdcon*)
    )
  (none)
  )

(define *debug-hook* main-debug-hook)

(define *add-sphere* #f)

(define *generic-effect-mode* 0)

(defun real-main-draw-hook ()
  "The main drawing function. This dispatches all renderers and is called directly from the display-loop
  in main.gc"
  (when *slow-frame-rate*
    (dotimes (v1-2 50000000) ;; was 50000
      (nop!)
      (nop!)
      (nop!)
      (nop!)
      (nop!)
      (nop!)
      )
    )
  "Function to be executed to set up for engine dma" ;; accidental docstring from the original game

  ;; update render enables from the debug menu
  (set! *vu1-enable-user* *vu1-enable-user-menu*)
  (set! *texture-enable-user* *texture-enable-user-menu*)

  ;; reset and display dma memory stats.
  (when *debug-segment*
    (when (or *stats-memory* *stats-memory-short*)
      (dotimes (gp-0 (-> *level* length))
        (let ((s5-0 (-> *level* level gp-0)))
          (if (= (-> s5-0 status) 'active)
              (print-mem-usage (compute-memory-usage s5-0 #f) s5-0 *stdcon*)
              )
          )
        )
      )
    (reset! *dma-mem-usage*)
    )

  ;; todo shrub matrix

  ;; initialize dma buckets that are generic sinks.
  ;; other renderers may output to these, so do them first.
  (generic-init-buffers)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; texture uploads
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; next we use the texture system to build DMA commands to load texture.
  ;; internally, add-tex-to-dma! has special logic to avoid loading textures
  ;; that won't be used. (though it's pretty basic, it doesn't actually track per-texture usage)

  ;; level tfrag's upload if the level is running.
  (with-profiler "texture-upload"
    (when (logtest? *texture-enable-user* 1)
      (dotimes (gp-1 (-> *level* length))
        (let ((a1-2 (-> *level* level gp-1)))
          (if (= (-> a1-2 status) 'active)
              (add-tex-to-dma! *texture-pool* a1-2 0)
              )
          )
        )
      )
    ;; level pris's upload if the level is running.
    (when (logtest? *texture-enable-user* 2)
      (dotimes (gp-2 (-> *level* length))
        (let ((a1-3 (-> *level* level gp-2)))
          (if (= (-> a1-3 status) 'active)
              (add-tex-to-dma! *texture-pool* a1-3 1)
              )
          )
        )
      )

    ;; level shrubs upload if the level is loading.
    (when (logtest? *texture-enable-user* 4)
      (dotimes (gp-3 (-> *level* length))
        (let ((a1-4 (-> *level* level gp-3)))
          (if (= (-> a1-4 status) 'active)
              (add-tex-to-dma! *texture-pool* a1-4 2)
              )
          )
        )
      )

    ;; alpha and common.
    (when (logtest? *texture-enable-user* 8)
      (let ((uploaded-common #f))
        (dotimes (gp-4 (-> *level* length))
          (let ((a1-5 (-> *level* level gp-4)))
            (when (= (-> a1-5 status) 'active)
              (add-tex-to-dma! *texture-pool* a1-5 3)
              (when (not uploaded-common)
                (upload-one-common! *texture-pool* (-> *level* level0))
                (set! uploaded-common #t)
                )
              )
            )
          )
        (when (not uploaded-common)
          (upload-one-common! *texture-pool* (-> *level* level0))
          #t
          )
        )
      )

    ;; water.
    (when (logtest? *texture-enable-user* 16)
      (dotimes (gp-5 (-> *level* length))
        (let ((a1-8 (-> *level* level gp-5)))
          (if (= (-> a1-8 status) 'active)
              (add-tex-to-dma! *texture-pool* a1-8 4)
              )
          )
        )
      )
    )

  ;;;;;;;;;;;;;
  ;; sky
  ;;;;;;;;;;;;;
  (with-profiler "sky"
    (when (zero? (logand *vu1-enable-user* (vu1-renderer-mask sky)))
      ;; the sky is disabled. Just draw a solid gradient on the whole screen.
      (with-dma-buffer-add-bucket ((dma-buf (-> (current-frame) global-buf)) (bucket-id sky-draw))
        (dma-buffer-add-gs-set dma-buf
                               (zbuf-1 (new 'static 'gs-zbuf :zbp #x1c0 :psm (gs-psm ct24)))
                               (test-1 (new 'static 'gs-test :ate #x1 :atst (gs-atest always) :zte #x1 :ztst (gs-ztest always)))
                               (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1))
                               )
        (screen-gradient
          dma-buf
          (-> *display* bg-clear-color 0)
          (-> *display* bg-clear-color 1)
          (-> *display* bg-clear-color 2)
          (-> *display* bg-clear-color 3)
          )
        )
      )
    (when (logtest? *vu1-enable-user* (vu1-renderer-mask sky))
      ;; check if we want the sky, and if we actually have textures ready.
      ;; we generate sky textures on the previous frame and they sit in vram (8160) until the next frame.
      ;; on the first frame after we request sky, we draw the textures, but they aren't ready until the next frame.
      (cond
        ((and (-> *time-of-day-context* sky) *sky-drawn*)
         (render-sky-tng *time-of-day-context*)
         )
        (else
          ;; todo
          (with-dma-buffer-add-bucket ((dma-buf (-> (current-frame) global-buf)) (bucket-id sky-draw))
            (dma-buffer-add-gs-set dma-buf
                                   (zbuf-1 (new 'static 'gs-zbuf :zbp #x1c0 :psm (gs-psm ct24)))
                                   (test-1 (new 'static 'gs-test :ate #x1 :atst (gs-atest always) :zte #x1 :ztst (gs-ztest always)))
                                   (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1))
                                   )
            (screen-gradient
              dma-buf
              (-> *time-of-day-context* erase-color)
              (-> *time-of-day-context* erase-color)
              (-> *time-of-day-context* erase-color)
              (-> *time-of-day-context* erase-color)
              )
            )
          )
        )
      )
    )


  ;; update mood lighting, draw sky textures.
  (with-profiler "time-of-day" (update-time-of-day *time-of-day-context*))

  ;; reset the closest object and desired texture masks for all levels.
  ; (dotimes (v1-150 (-> *level* length))
  ;   (let ((a0-59 (-> *level* level v1-150)))
  ;     (when (= (-> a0-59 status) 'active)
  ;       (dotimes (a1-38 9)
  ;         (set! (-> a0-59 closest-object a1-38) 4095996000.0)
  ;         (set! (-> a0-59 texture-mask a1-38) (the-as uint 0))
  ;         )
  ;       )
  ;     )
  ;   )
  (add-ee-profile-frame 'draw :r #x40 :b #x40 :a #x80)

  ;;;;;;; OCEAN
  (with-profiler "ocean"
    (update-ocean) ;; ocean map update
    (draw-ocean)   ;; far, mid, near, transition, and texture.
    )
  (add-ee-profile-frame 'draw :b #xff :a #x80)

  ;; reset MERC
  (with-profiler "merc"
    (set! (-> *merc-global-array* count) (the-as uint 0))
    (set! *merc-globals* (the-as merc-globals (-> *merc-global-array* globals)))
    (set! (-> *shadow-queue* cur-run) (the-as uint 0))
    )

  ;; draw the background!
  (with-profiler "background"
    (init-background)
    (execute-connections *background-draw-engine* (-> *display* frames (-> *display* on-screen) frame))

    ;; finish bg (most of the work is here)
    (reset! (-> *perf-stats* data 3))
    (finish-background)
    (read! (-> *perf-stats* data 3))
    (update-wait-stats (-> *perf-stats* data 3) (-> *background-work* wait-to-vu0) (the-as uint 0) (the-as uint 0))
    )

  ;; perf stats are printed and restarted here, for some reason.
  (with-profiler "stats"
    (end-perf-stat-collection)
    (when (not (paused?))
      (when *stats-poly*
        (dotimes (gp-8 (-> *level* length))
          (let ((v1-193 (-> *level* level gp-8)))
            (if (= (-> v1-193 status) 'active)
                (collect-stats (-> v1-193 bsp))
                )
            )
          )
        (print-terrain-stats)
        )
      (if *display-perf-stats*
          (print-perf-stats)
          )
      )
    (start-perf-stat-collection)
    )

  ;; draw the foreground engines.
  (with-profiler "foreground-engines"
    (foreground-engine-execute
      (-> *level* level-default foreground-draw-engine 0)
      (-> *display* frames (-> *display* on-screen) frame)
      2
      0
      )
    (foreground-engine-execute
      (-> *level* level-default foreground-draw-engine 1)
      (-> *display* frames (-> *display* on-screen) frame)
      2
      1
      )
    )

  ;; handle extra processing for foreground

  (let ((gp-9 (-> *display* frames (-> *display* on-screen) frame global-buf)))
    (with-profiler "bones" (bones-mtx-calc-execute)) ;; skinning matrix calculation
    (with-profiler "gmerc" (generic-merc-execute-all gp-9)) ;; mercneric conversion.
    (with-profiler "shadow" (shadow-execute-all gp-9 *shadow-queue*))
    (with-profiler "eyes" (update-eyes))
    )

  ;; sprite draw
  (when (logtest? (vu1-renderer-mask sprite) *vu1-enable-user*)
    (with-profiler "sprite"
      (swap-fake-shadow-buffers)
      (sprite-draw *display*)
      )
    )
  ;; debug drawing
  (with-profiler "debug-draw"
    (when *debug-segment*
      (debug-draw-actors *level* *display-actor-marks*)
      (collide-shape-draw-debug-marks)
      )
    (render-boundaries)
    )

  ;; for some reason we clear the touching list here...
  (with-profiler "touching"
    (send-events-for-touching-shapes *touching-list*)
    (free-all-prim-nodes *touching-list*)
    )

  (add-ee-profile-frame 'draw :r #x40 :b #x40 :a #x80)
  ;; spawn actors, compact heaps, etc.
  (with-profiler "actors-update"
    (actors-update *level*)
    )
  (add-ee-profile-frame 'draw  :r #x80 :a #x80)

  (when (not (paused?))
    (if *stats-collide*
        (print-collide-stats)
        )
    )

  (none)
  )

(defun main-draw-hook ()
  "Nice."
  (real-main-draw-hook)
  (none)
  )

(define *draw-hook* main-draw-hook)



(defun debug-init-buffer ((arg0 bucket-id) (arg1 gs-zbuf) (arg2 gs-test))
  "Initialize a bucket for debug draw with the given zbuf and test settings"
  (let* ((t0-0 (-> *display* frames (-> *display* on-screen) frame global-buf))
         (v1-3 (-> t0-0 base))
         )
    (let* ((a3-3 t0-0)
           (t1-0 (the-as object (-> a3-3 base)))
           )
      (set! (-> (the-as dma-packet t1-0) dma) (new 'static 'dma-tag :qwc #x3 :id (dma-tag-id cnt)))
      (set! (-> (the-as dma-packet t1-0) vif0) (new 'static 'vif-tag))
      (set! (-> (the-as dma-packet t1-0) vif1) (new 'static 'vif-tag :imm #x3 :cmd (vif-cmd direct) :msk #x1))
      (set! (-> a3-3 base) (&+ (the-as pointer t1-0) 16))
      )
    (let* ((a3-4 t0-0)
           (t1-2 (the-as object (-> a3-4 base)))
           )
      (set! (-> (the-as gs-gif-tag t1-2) tag)
       (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x2)
       )
      (set! (-> (the-as gs-gif-tag t1-2) regs)
       (new 'static 'gif-tag-regs
            :regs0 (gif-reg-id a+d)
            :regs1 (gif-reg-id a+d)
            :regs2 (gif-reg-id a+d)
            :regs3 (gif-reg-id a+d)
            :regs4 (gif-reg-id a+d)
            :regs5 (gif-reg-id a+d)
            :regs6 (gif-reg-id a+d)
            :regs7 (gif-reg-id a+d)
            :regs8 (gif-reg-id a+d)
            :regs9 (gif-reg-id a+d)
            :regs10 (gif-reg-id a+d)
            :regs11 (gif-reg-id a+d)
            :regs12 (gif-reg-id a+d)
            :regs13 (gif-reg-id a+d)
            :regs14 (gif-reg-id a+d)
            :regs15 (gif-reg-id a+d)
            )
       )
      (set! (-> a3-4 base) (&+ (the-as pointer t1-2) 16))
      )
    (let* ((a3-5 t0-0)
           (t1-4 (-> a3-5 base))
           )
      (set! (-> (the-as (pointer gs-zbuf) t1-4) 0) arg1)
      (set! (-> (the-as (pointer gs-reg64) t1-4) 1) (gs-reg64 zbuf-1))
      (set! (-> (the-as (pointer gs-test) t1-4) 2) arg2)
      (set! (-> (the-as (pointer gs-reg64) t1-4) 3) (gs-reg64 test-1))
      (set! (-> a3-5 base) (&+ t1-4 32))
      )
    (let ((a3-6 (-> t0-0 base)))
      (let ((a1-4 (the-as object (-> t0-0 base))))
        (set! (-> (the-as dma-packet a1-4) dma) (new 'static 'dma-tag :id (dma-tag-id next)))
        (set! (-> (the-as dma-packet a1-4) vif0) (new 'static 'vif-tag))
        (set! (-> (the-as dma-packet a1-4) vif1) (new 'static 'vif-tag))
        (set! (-> t0-0 base) (&+ (the-as pointer a1-4) 16))
        )
      (dma-bucket-insert-tag
       (-> *display* frames (-> *display* on-screen) frame bucket-group)
       arg0
       v1-3
       (the-as (pointer dma-tag) a3-6)
       )
      )
    )
  (none)
  )

(define *screen-shot* #f)
(defun display-frame-start ((disp display) (new-frame-idx int) (odd-even int))
  "Set up a new frame. Call this before drawing anything.
   new-frame-idx is the display frame that will be set up.
   odd-even is the odd-even of the new frame"


  ;; due to a HW bug in the PS2, you must set this.
  ;;(set! (-> (the-as vif-bank #x10003c00) err me0) 1)

  ;; figure out how fast we're going compared to the desired.
  ;; larger = slower than we should.
  ;; due to vsync, we should never go too fast.
  (let ((time-ratio (the float
                         (+ (/ (timer-count (the-as timer-bank #x10000800)) (the-as uint *ticks-per-frame*))
                            1 ;; so we round up.
                            )
                         )

          )
        )

    (let ((float-time-ratio (/ (the float (timer-count (the-as timer-bank #x10000800))) (the float *ticks-per-frame*))))
      ;; on the PS2, if you have > 1/60 seconds between frames, it means you missed a vsync.
      ;; this doesn't seem to be the case on my machine. It appears that glfwSwapBuffers sometimes returns ~1 ms early,
      ;; making the next frame ~1 ms too long.

      ;; to work around with, we internally run the game at 60 fps if it appears to be slightly too slow.
      ;; if we actually do miss a frame, the time ratio will be around 2.

      (#when PC_PORT
        (if (< float-time-ratio 1.3)
            (set! time-ratio 1.0)
            )
        #|
        (if (> time-ratio 1.)
            (format #t "LAG ~f frames~%" (- time-ratio 1.))
            )
        |#
        )
      )


    ;; inform display system of our speed. This will adjust the scaling used in all physics calculations
    (set-time-ratios *display* time-ratio)

    ;; set our "old" counters.  In the event of a game load/save, these will not jump
    (set! (-> disp old-base-frame-counter) (-> disp base-frame-counter))
    (set! (-> disp old-game-frame-counter) (-> disp game-frame-counter))
    (set! (-> disp old-real-frame-counter) (-> disp real-frame-counter))
    (set! (-> disp old-integral-frame-counter) (-> disp integral-frame-counter))
    (set! (-> disp old-real-integral-frame-counter) (-> disp real-integral-frame-counter))
    (set! (-> disp old-part-frame-counter) (-> disp part-frame-counter))
    (set! (-> disp old-actual-frame-counter) (-> disp actual-frame-counter))
    (set! (-> disp old-real-actual-frame-counter) (-> disp real-actual-frame-counter))

    ;; get the increment in seconds unit.
    (let ((scaled-seconds (* (the int time-ratio) (the int (-> disp time-factor)))))
      ;; tell the sparticle system
      (set-particle-frame-time (min (seconds 0.04) scaled-seconds))

      ;; the "not real" frame counters only count when unpaused
      (when (not (paused?))
        ;; these count by scaled time
        (+! (-> disp base-frame-counter) scaled-seconds)
        (+! (-> disp part-frame-counter) scaled-seconds)
        ;; this counts actual frames, not seconds. Will count 2 frames if we lag
        (+! (-> disp integral-frame-counter) (the int time-ratio))
        ;; this counts actual frames, not doubling for lag. Will count 1 per frame drawn
        (+! (-> disp actual-frame-counter) 1)
        ;; game counter will count seconds that we're not in a movie
        (if (not (movie?))
            (+! (-> disp game-frame-counter) scaled-seconds)
            )
        )
      ;; real counts like base, but increments when paused
      (+! (-> disp real-frame-counter) scaled-seconds)
      )
    ;; actual frames, lag counts as 2x
    (+! (-> disp real-integral-frame-counter) (the int time-ratio))
    )
  ;; actual real frames (for real)
  (+! (-> disp real-actual-frame-counter) 1)

  ;; reset the timer.
  (timer-reset (the-as timer-bank #x10000800))

  ;; take a screenshot, if desired
  (when *screen-shot*
    (if *debug-segment*
        (store-image odd-even)
        )
    (set! *screen-shot* #f)
    )

  ;; set up the frame object.
  (let ((new-frame (-> disp frames new-frame-idx frame)))
    ;; profile setup
    (when *debug-segment*
      (dotimes (s2-0 2)
        (reset (-> new-frame profile-bar s2-0))
        )
      )
    ;; right now, the old frame is being rendered.
    ;; if we set *sync-dma*, we will wait here until it finishes rendering.
    (if *sync-dma*
        (sync-path 0 0)
        )

    ;; reset the global dma buffer.
    (let ((v1-56 (-> new-frame global-buf)))
      (set! (-> v1-56 base) (-> v1-56 data))
      (set! (-> v1-56 end) (&-> v1-56 data-buffer (-> v1-56 allocated-length)))
      )

    ;; reset the debug dma buffer
    (when *debug-segment*
      (let ((v1-59 (-> new-frame debug-buf)))
        (set! (-> v1-59 base) (-> v1-59 data))
        (set! (-> v1-59 end) (&-> v1-59 data-buffer (-> v1-59 allocated-length)))
        )
      )

    ;; reset the calc buffer. This holds the buckets themselves and what is sent
    ;; to actually draw the frame.
    (let ((v1-60 (-> new-frame calc-buf)))
      (set! (-> v1-60 base) (-> v1-60 data))
      (set! (-> v1-60 end) (&-> v1-60 data-buffer (-> v1-60 allocated-length)))
      )

    ;; the default buffer holds a DMA chain to fully reset the GS.
    ;; reinitialize it, just to be safe
    (default-buffer-init *default-regs-buffer*)
    ;; and add it to the very beginning of the calc buf
    (let* ((v1-61 (-> new-frame calc-buf))
           (a2-1 *default-regs-buffer*)
           (a0-28 (the-as object (-> v1-61 base)))
           )
      (set! (-> (the-as dma-packet a0-28) dma)
       (new 'static 'dma-tag
            :id (dma-tag-id call)
            :addr (the-as int (-> a2-1 data))
            )
       )
      (set! (-> (the-as dma-packet a0-28) vif0) (new 'static 'vif-tag))
      (set! (-> (the-as dma-packet a0-28) vif1) (new 'static 'vif-tag))
      (set! (-> v1-61 base) (&+ (the-as pointer a0-28) 16))
      )

    ;; could be used for debugging or something, but is set to nothing.
    (*pre-draw-hook* (-> new-frame calc-buf))

    ;; reset debugging stuff
    (when (not (paused?))
      (clear *stdcon1*)
      (debug-reset-buffers)
      )

    ;; add the buckets
    (set! (-> new-frame bucket-group) (dma-buffer-add-buckets (-> new-frame calc-buf) BUCKET_COUNT))
    )

  ;; initialize the debug bucket
  (debug-init-buffer (bucket-id debug-no-zbuf)
    (new 'static 'gs-zbuf :zbp #x1c0 :psm (gs-psm ct24) :zmsk #x1)
    (new 'static 'gs-test :zte #x1 :ztst (gs-ztest always))
    )

  ;; setup our drawing offset for even/odd offset
  (set-draw-env-offset (-> disp frames new-frame-idx draw) 2048 2048 odd-even)

  ;; read controllers
  (service-cpads)
  ;; now we are ready to run a frame!
  (none)
  )

(defun display-frame-finish ((disp display))
  "End drawing. Call this after drawing everything.
   Note that this does not start a DMA transfer, just finishes up the buffered data for
   the frame."
  (let* ((this-frame (-> disp frames (-> disp on-screen) frame))
         (this-calc-buf (-> this-frame calc-buf))
         )
    ;; post draw stuff
    (tie-init-buffers this-calc-buf)
    (merc-vu1-init-buffers)
    (*post-draw-hook* (-> disp frames (-> disp on-screen) frame calc-buf))

    ;; iterate through all buckets and append a final GS state reset.
    (dotimes (bucket-idx BUCKET_COUNT)
      (let* ((this-global-buf (-> this-frame global-buf))
             (a2-0 (-> this-global-buf base))
             )
        ;; clear GS state after the bucket
        (let* ((a0-3 this-global-buf)
               (t0-0 *default-regs-buffer*)
               (a1-0 (the-as object (-> a0-3 base)))
               )
          (set! (-> (the-as dma-packet a1-0) dma)
           (new 'static 'dma-tag
                :id (dma-tag-id call)
                :addr (the-as int (-> t0-0 data))
                )
           )
          (set! (-> (the-as dma-packet a1-0) vif0) (new 'static 'vif-tag :irq #x1))
          (set! (-> (the-as dma-packet a1-0) vif1) (new 'static 'vif-tag))
          (set! (-> a0-3 base) (&+ (the-as pointer a1-0) 16))
          )
        (let ((a3-4 (-> this-global-buf base)))
          (let ((a0-4 (the-as object (-> this-global-buf base))))
            (set!
             (-> (the-as dma-packet a0-4) dma)
             (new 'static 'dma-tag :id (dma-tag-id next))
             )
            (set! (-> (the-as dma-packet a0-4) vif0) (new 'static 'vif-tag))
            (set! (-> (the-as dma-packet a0-4) vif1) (new 'static 'vif-tag))
            (set! (-> this-global-buf base) (&+ (the-as pointer a0-4) 16))
            )
          (dma-bucket-insert-tag
           (-> *display* frames (-> *display* on-screen) frame bucket-group)
           (the-as bucket-id bucket-idx)
           a2-0
           (the-as (pointer dma-tag) a3-4)
           )
          )
        )
      )
    ;; append a FLUSHE and IRQ to end the calc-buf
    (let* ((v1-14 this-calc-buf)
           (a0-10 (the-as object (-> v1-14 base)))
           )
      (set! (-> (the-as dma-packet a0-10) dma)
       (new 'static 'dma-tag :id (dma-tag-id cnt))
       )
      (set! (-> (the-as dma-packet a0-10) vif0)
       (new 'static 'vif-tag :cmd (vif-cmd flushe) :msk #x1)
       )
      (set! (-> (the-as dma-packet a0-10) vif1) (new 'static 'vif-tag :irq #x1))
      (set! (-> v1-14 base) (&+ (the-as pointer a0-10) 16))
      )
    ;; patch the buckets. Now sending the calc buf will send everything!
    (dma-buffer-patch-buckets (-> this-frame bucket-group) BUCKET_COUNT)
    ;; append the final END.
    (let* ((v1-15 this-calc-buf)
           (a0-13 (the-as object (-> v1-15 base)))
           )
      (set! (-> (the-as dma-packet a0-13) dma)
       (new 'static 'dma-tag :id (dma-tag-id end))
       )
      (set! (-> (the-as (pointer uint64) a0-13) 1) (the-as uint 0))
      (set! (-> v1-15 base) (&+ (the-as pointer a0-13) 16))
      )
    ;; final cache flush after finishing DMA chains
    (flush-cache 0)
    ;; print debug stats.
    (when (not (paused?))
      (when *stats-buffer*
        (let* ((global-buf (-> this-frame global-buf))
               (calc-current (-> this-calc-buf base))
               (calc-start (-> this-calc-buf data))
               (global-current (-> global-buf base))
               (global-start (-> global-buf data))
               (global-end (-> global-buf end))
               )
          (format *stdcon* "~0kvu1 buf = ~d~%" (&- calc-current (the-as uint calc-start)))
          (format *stdcon* "~0kglobal buf = ~d~%" (&- global-current (the-as uint global-start)))
          (format *stdcon* "~0kbase = #x~x~%" global-current)
          (format *stdcon* "~0kend = #x~x~%" global-end)
          )
        )
      )
    )
  disp
  )

(defun determine-pause-mode ()
  "Update pause system"

  ;; debug frame advance
  (when (and *debug-pause* (= *master-mode* 'pause))
    (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons start r2))
    (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons start r2))
    (while (and (= *master-mode* 'pause)
                (not (cpad-pressed? 0 start r2)))
      (sync-path 0 0)
      (service-cpads)
      )
    (toggle-pause)
    )
  (when (or (not *progress-process*) (can-go-back? (-> *progress-process* 0)))
    (if (or (cpad-pressed? 0 select r3 start) ;; push pause
            (and (logtest? (-> *cpad-list* cpads 0 valid) 128) ;; controller lost
                 (= *master-mode* 'game)
                 (>= (-> *display* base-frame-counter) (-> *game-info* blackout-time))
                 ;; this is a hack. this is initialized to (seconds 1000). It prevents controller-loss pause from
                 ;; triggering in the first few seconds of gameplay.
                 (< (seconds 1003) (-> *display* real-frame-counter))
                 )
            (and (cpad-pressed? 0 r2) (paused?)) ;; debug press
            *pause-lock*
            )
        (toggle-pause)
        )
    )
  ;; if we toggled out of pause, kill it.
  (if (!= *master-mode* 'progress)
      (deactivate-progress)
      )
  0
  )

(define *surrogate-dma-buffer* (the dma-buffer #f))

(#when PC_PORT
  (define *disasm-count* 0)

  (defmacro disasm-next-dma (&key (count 1))
    `(set! *disasm-count* ,count)
    )
  )

(defun display-sync ((disp display))
  "Switch frames! This assumes that you have called display-frame-finish on the current frame.
   It will:
    - wait for the current rendering frame to stop.
    - do a vsync to get that frame on screen (possibly waiting up to 1 frame, if the prev frame
                                              did not finish in time. This is why we drop to 30fps
                                              as soon as we don't fit into 60 fps)
    - start rendering the current frame
    - initialize DMA buffers for the next frame drawing, advance to next frame"

  ;; wait for rendering to finish.
  (sync-path 0 0)
  ;; remember when.
  ;; NOTE : setting this to 0 to get rid of lag compensation in PC port, since it's not helpful
  (set! (-> disp frames (-> disp on-screen) frame run-time) (#if PC_PORT 0 (the-as int (timer-count (the-as timer-bank #x10000800)))))

  ;; now, do a vsync. If we finished rendering in time, this will just wait until the next.
  (let ((frame-idx (-> disp on-screen))
        (syncv-result (syncv 0))
        )

    ;; starting here, we are in a new frame
    ;; syncv returns odd/even (if you miss multiple syncv's due to the sync-path above taking many
    ;; frames, this will get us back on the correct field)
    (set! *oddeven* syncv-result)

    ;; if we need to change video modes:
    (when (-> *video-parms* set-video-mode)
      ;; to GS
      (set-display2 *display* 0 512 (-> *video-parms* screen-sy) 2 49)
      (set! (-> *video-parms* set-video-mode) #f)
      ;; reset video mode is for changing ntsc/pal
      (when (-> *video-parms* reset-video-mode)
        (set! (-> *video-parms* reset-video-mode) #f)
        ;; need to call reset-graph with some magic number
        ;; also stash this parameter so that if things go really wrong and our DMA transfer
        ;; times out, we can reset-graph to the appropriate video mode
        (if (or (= (-> *setting-control* current video-mode) 'ntsc) (= (-> *setting-control* current video-mode) 'custom))
            (set! *video-reset-parm* 2)
            (set! *video-reset-parm* 3)
            )
        (reset-graph 0 1 *video-reset-parm* 1)
        )
      )

    ;; setup the env (Sony functions)
    (put-display-env (-> disp frames frame-idx display))
    (put-draw-env (the-as (pointer gif-tag) (-> disp frames frame-idx gif)))

    ;; begin rendering the next frame
    (let ((dma-buf-to-send (-> disp frames frame-idx frame calc-buf)))
      (when (nonzero? (dma-buffer-length dma-buf-to-send))
        ;; was dma-send-chain originally.
        (#when PC_PORT
          (when (> *disasm-count* 0)
            (disasm-dma-list (the-as dma-packet (-> dma-buf-to-send data-buffer)) 'details #t #t -1)
            (-! *disasm-count* 1)
            )
          )
        (__send-gfx-dma-chain (the-as dma-bank-source #x10009000)
                               (cond
                                 ;; some buffer for debugging, not used
                                 (*surrogate-dma-buffer*
                                  *surrogate-dma-buffer*
                                  )
                                 (else
                                  (-> dma-buf-to-send data-buffer)
                                  )
                                 )
                               )
        )
      )

    (determine-pause-mode)

    ;; update display frame
    (let ((next-frame (+ frame-idx 1)))
      (if (< 1 next-frame)
          (set! next-frame 0)
          )
      (set! (-> disp last-screen) (-> disp on-screen))
      (set! (-> disp on-screen) next-frame)

      ;; initialize next frame
      (display-frame-start disp next-frame syncv-result)
      )
    )
  (none)
  )

(defun swap-display ((disp display))
  "Swap frames! Synchronizes with rendering and vsync, kicks off the next render, and initializes the
   to-draw frame"
  (display-frame-finish disp)
  (display-sync disp) ;; also starts next
  )

(defun-debug marks-cam-restore ()
  (let ((a0-0 (new-stack-vector0))
        (a1-0 (new-stack-matrix0))
        )
    (set! (-> a0-0 x) 1672489.2)
    (set! (-> a0-0 y) 60862.703)
    (set! (-> a0-0 z) -13051605.0)
    (set! (-> a0-0 w) 1.0)
    (set! (-> a1-0 vector 0 x) -0.1783)
    (set! (-> a1-0 vector 0 y) 0.0)
    (set! (-> a1-0 vector 0 z) 0.9839)
    (set! (-> a1-0 vector 0 w) 0.0)
    (set! (-> a1-0 vector 1 x) -0.0629)
    (set! (-> a1-0 vector 1 y) 0.9979)
    (set! (-> a1-0 vector 1 z) -0.0114)
    (set! (-> a1-0 vector 1 w) 0.0)
    (set! (-> a1-0 vector 2 x) -0.9819)
    (set! (-> a1-0 vector 2 y) -0.064)
    (set! (-> a1-0 vector 2 z) -0.178)
    (set! (-> a1-0 vector 2 w) 0.0)
    (set! (-> a1-0 vector 3 x) 0.0)
    (set! (-> a1-0 vector 3 y) 0.0)
    (set! (-> a1-0 vector 3 z) 0.0)
    (set! (-> a1-0 vector 3 w) 1.0)
    (debug-set-camera-pos-rot! a0-0 a1-0)
    )
  (send-event *camera* 'set-fov 17294.205)
  (clear *camera-old-level*)
  (format *camera-old-level* "village3")
  (set! *camera-old-cpu* 1219)
  (set! *camera-old-vu* 9602)
  (set! *camera-old-tfrag-bytes* 0)
  (clear *camera-old-stat-string-tfrag*)
  (clear *camera-old-stat-string-tfrag-near*)
  (clear *camera-old-stat-string-total*)
  (set! *display-camera-old-stats* #t)
  (none)
  )

(defun-debug eddie-cam-restore ()
  (let ((a0-0 (new-stack-vector0))
        (a1-0 (new-stack-matrix0))
        )
    (set! (-> a0-0 x) -427963.66)
    (set! (-> a0-0 y) 24967.182)
    (set! (-> a0-0 z) 339465.53)
    (set! (-> a0-0 w) 1.0)
    (set! (-> a1-0 vector 0 x) -0.6026)
    (set! (-> a1-0 vector 0 y) 0.0)
    (set! (-> a1-0 vector 0 z) 0.7979)
    (set! (-> a1-0 vector 0 w) 0.0)
    (set! (-> a1-0 vector 1 x) -0.1522)
    (set! (-> a1-0 vector 1 y) 0.9816)
    (set! (-> a1-0 vector 1 z) -0.1149)
    (set! (-> a1-0 vector 1 w) 0.0)
    (set! (-> a1-0 vector 2 x) -0.7833)
    (set! (-> a1-0 vector 2 y) -0.1908)
    (set! (-> a1-0 vector 2 z) -0.5915)
    (set! (-> a1-0 vector 2 w) 0.0)
    (set! (-> a1-0 vector 3 x) 0.0)
    (set! (-> a1-0 vector 3 y) 0.0)
    (set! (-> a1-0 vector 3 z) 0.0)
    (set! (-> a1-0 vector 3 w) 1.0)
    (debug-set-camera-pos-rot! a0-0 a1-0)
    )
  (none)
  )

(defun-debug gregs-jungle-cam-restore ()
  (let ((a0-0 (new-stack-vector0))
        (a1-0 (new-stack-matrix0))
        )
    (set! (-> a0-0 x) 1399233.0)
    (set! (-> a0-0 y) 39027.11)
    (set! (-> a0-0 z) -1485580.1)
    (set! (-> a0-0 w) 1.0)
    (set! (-> a1-0 vector 0 x) 0.9965)
    (set! (-> a1-0 vector 0 y) 0.0)
    (set! (-> a1-0 vector 0 z) 0.0829)
    (set! (-> a1-0 vector 0 w) 0.0)
    (set! (-> a1-0 vector 1 x) -0.0021)
    (set! (-> a1-0 vector 1 y) 0.9996)
    (set! (-> a1-0 vector 1 z) 0.0253)
    (set! (-> a1-0 vector 1 w) 0.0)
    (set! (-> a1-0 vector 2 x) -0.0829)
    (set! (-> a1-0 vector 2 y) -0.0254)
    (set! (-> a1-0 vector 2 z) 0.9962)
    (set! (-> a1-0 vector 2 w) 0.0)
    (set! (-> a1-0 vector 3 x) 0.0)
    (set! (-> a1-0 vector 3 y) 0.0)
    (set! (-> a1-0 vector 3 z) 0.0)
    (set! (-> a1-0 vector 3 w) 1.0)
    (debug-set-camera-pos-rot! a0-0 a1-0)
    )
  (send-event *camera* 'set-fov 11650.845)
  (clear *camera-old-level*)
  (format *camera-old-level* "jungle")
  (set! *camera-old-cpu* 5801)
  (set! *camera-old-vu* 9605)
  (set! *camera-old-tfrag-bytes* #x1ffee0)
  (clear *camera-old-stat-string-tfrag*)
  (clear *camera-old-stat-string-tfrag-near*)
  (clear *camera-old-stat-string-total*)
  (none)
  )

(defun-debug gregs-village1-cam-restore ()
  (let ((a0-0 (new-stack-vector0))
        (a1-0 (new-stack-matrix0))
        )
    (set! (-> a0-0 x) -511224.06)
    (set! (-> a0-0 y) 157579.95)
    (set! (-> a0-0 z) 764585.25)
    (set! (-> a0-0 w) 1.0)
    (set! (-> a1-0 vector 0 x) -0.9009)
    (set! (-> a1-0 vector 0 y) 0.0)
    (set! (-> a1-0 vector 0 z) -0.4338)
    (set! (-> a1-0 vector 0 w) 0.0)
    (set! (-> a1-0 vector 1 x) 0.0984)
    (set! (-> a1-0 vector 1 y) 0.9739)
    (set! (-> a1-0 vector 1 z) -0.2043)
    (set! (-> a1-0 vector 1 w) 0.0)
    (set! (-> a1-0 vector 2 x) 0.4225)
    (set! (-> a1-0 vector 2 y) -0.2268)
    (set! (-> a1-0 vector 2 z) -0.8774)
    (set! (-> a1-0 vector 2 w) 0.0)
    (set! (-> a1-0 vector 3 x) 0.0)
    (set! (-> a1-0 vector 3 y) 0.0)
    (set! (-> a1-0 vector 3 z) 0.0)
    (set! (-> a1-0 vector 3 w) 1.0)
    (debug-set-camera-pos-rot! a0-0 a1-0)
    )
  (send-event *camera* 'set-fov 11650.845)
  (clear *camera-old-level*)
  (format *camera-old-level* "village1")
  (set! *camera-old-cpu* 4899)
  (set! *camera-old-vu* 9605)
  (set! *camera-old-tfrag-bytes* #x24e680)
  (clear *camera-old-stat-string-tfrag*)
  (clear *camera-old-stat-string-tfrag-near*)
  (clear *camera-old-stat-string-total*)
  (none)
  )

(defun-debug gregs-texture-cam-restore ()
  (let ((a0-0 (new-stack-vector0))
        (a1-0 (new-stack-matrix0))
        )
    (set! (-> a0-0 x) 1103816.0)
    (set! (-> a0-0 y) 96275.71)
    (set! (-> a0-0 z) -632064.5)
    (set! (-> a0-0 w) 1.0)
    (set! (-> a1-0 vector 0 x) 0.4063)
    (set! (-> a1-0 vector 0 y) 0.0)
    (set! (-> a1-0 vector 0 z) -0.9137)
    (set! (-> a1-0 vector 0 w) 1.0)
    (set! (-> a1-0 vector 1 x) 0.2824)
    (set! (-> a1-0 vector 1 y) 0.951)
    (set! (-> a1-0 vector 1 z) 0.1256)
    (set! (-> a1-0 vector 1 w) 1.0)
    (set! (-> a1-0 vector 2 x) 0.8689)
    (set! (-> a1-0 vector 2 y) -0.3091)
    (set! (-> a1-0 vector 2 z) 0.3864)
    (set! (-> a1-0 vector 2 w) 1.0)
    (set! (-> a1-0 vector 3 x) 0.0)
    (set! (-> a1-0 vector 3 y) 0.0)
    (set! (-> a1-0 vector 3 z) 0.0)
    (set! (-> a1-0 vector 3 w) 1.0)
    (debug-set-camera-pos-rot! a0-0 a1-0)
    )
  (send-event *camera* 'set-fov 11650.845)
  (clear *camera-old-level*)
  (format *camera-old-level* "village1")
  (set! *camera-old-cpu* 4772)
  (set! *camera-old-vu* 9603)
  (set! *camera-old-tfrag-bytes* #x22e680)
  (clear *camera-old-stat-string-tfrag*)
  (clear *camera-old-stat-string-tfrag-near*)
  (clear *camera-old-stat-string-total*)
  (none)
  )

(defun-debug gregs-texture2-cam-restore ()
  (let ((a0-0 (new-stack-vector0))
        (a1-0 (new-stack-matrix0))
        )
    (set! (-> a0-0 x) 1954572.9)
    (set! (-> a0-0 y) 135123.98)
    (set! (-> a0-0 z) -1028725.44)
    (set! (-> a0-0 w) 1.0)
    (set! (-> a1-0 vector 0 x) 0.2535)
    (set! (-> a1-0 vector 0 y) 0.0)
    (set! (-> a1-0 vector 0 z) 0.9673)
    (set! (-> a1-0 vector 0 w) 1.0)
    (set! (-> a1-0 vector 1 x) -0.1051)
    (set! (-> a1-0 vector 1 y) 0.994)
    (set! (-> a1-0 vector 1 z) 0.0275)
    (set! (-> a1-0 vector 1 w) 1.0)
    (set! (-> a1-0 vector 2 x) -0.9615)
    (set! (-> a1-0 vector 2 y) -0.1087)
    (set! (-> a1-0 vector 2 z) 0.252)
    (set! (-> a1-0 vector 2 w) 1.0)
    (set! (-> a1-0 vector 3 x) 0.0)
    (set! (-> a1-0 vector 3 y) 0.0)
    (set! (-> a1-0 vector 3 z) 0.0)
    (set! (-> a1-0 vector 3 w) 1.0)
    (debug-set-camera-pos-rot! a0-0 a1-0)
    )
  (send-event *camera* 'set-fov 11650.845)
  (clear *camera-old-level*)
  (format *camera-old-level* "village1")
  (set! *camera-old-cpu* 4936)
  (set! *camera-old-vu* #x4b0c)
  (set! *camera-old-tfrag-bytes* #x22e680)
  (clear *camera-old-stat-string-tfrag*)
  (clear *camera-old-stat-string-tfrag-near*)
  (clear *camera-old-stat-string-total*)
  (none)
  )

(defun-debug cave-cam-restore ()
  (let ((a0-0 (new-stack-vector0))
        (a1-0 (new-stack-matrix0))
        )
    (set! (-> a0-0 x) -1449013.1)
    (set! (-> a0-0 y) 15114.015)
    (set! (-> a0-0 z) -1621305.5)
    (set! (-> a0-0 w) 1.0)
    (set! (-> a1-0 vector 0 x) -0.8223)
    (set! (-> a1-0 vector 0 y) 0.0)
    (set! (-> a1-0 vector 0 z) -0.5689)
    (set! (-> a1-0 vector 0 w) 0.0)
    (set! (-> a1-0 vector 1 x) 0.0076)
    (set! (-> a1-0 vector 1 y) 0.9999)
    (set! (-> a1-0 vector 1 z) -0.0111)
    (set! (-> a1-0 vector 1 w) 0.0)
    (set! (-> a1-0 vector 2 x) 0.5689)
    (set! (-> a1-0 vector 2 y) -0.0135)
    (set! (-> a1-0 vector 2 z) -0.8222)
    (set! (-> a1-0 vector 2 w) 0.0)
    (set! (-> a1-0 vector 3 x) 0.0)
    (set! (-> a1-0 vector 3 y) 0.0)
    (set! (-> a1-0 vector 3 z) 0.0)
    (set! (-> a1-0 vector 3 w) 1.0)
    (debug-set-camera-pos-rot! a0-0 a1-0)
    )
  (none)
  )

(defun-debug paals-cam-restore ()
  (let ((a0-0 (new-stack-vector0))
        (a1-0 (new-stack-matrix0))
        )
    (set! (-> a0-0 x) -791260.7)
    (set! (-> a0-0 y) 50858.62)
    (set! (-> a0-0 z) -163715.47)
    (set! (-> a0-0 w) 1.0)
    (set! (-> a1-0 vector 0 x) -0.7816)
    (set! (-> a1-0 vector 0 y) 0.0)
    (set! (-> a1-0 vector 0 z) -0.6236)
    (set! (-> a1-0 vector 0 w) 0.0)
    (set! (-> a1-0 vector 1 x) 0.0672)
    (set! (-> a1-0 vector 1 y) 0.9941)
    (set! (-> a1-0 vector 1 z) -0.0843)
    (set! (-> a1-0 vector 1 w) 0.0)
    (set! (-> a1-0 vector 2 x) 0.62)
    (set! (-> a1-0 vector 2 y) -0.1079)
    (set! (-> a1-0 vector 2 z) -0.7771)
    (set! (-> a1-0 vector 2 w) 0.0)
    (set! (-> a1-0 vector 3 x) 0.0)
    (set! (-> a1-0 vector 3 y) 0.0)
    (set! (-> a1-0 vector 3 z) 0.0)
    (set! (-> a1-0 vector 3 w) 1.0)
    (debug-set-camera-pos-rot! a0-0 a1-0)
    )
  (none)
  )
