;;-*-Lisp-*-
(in-package goal)

;; name: target-death.gc
;; name in dgo: target-death
;; dgos: GAME, ENGINE

;; DECOMP BEGINS

(import "goal_src/jak1/import/deathcam-ag.gc")

(defskelgroup *deathcam-sg* deathcam deathcam-lod0-jg deathcam-idle-ja
              ((deathcam-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              :texture-level 2
              )

(define *auto-continue* #f)

(defun next-level ((arg0 symbol))
  (let ((v1-0 (lookup-level-info arg0)))
    (the-as level-load-info (when v1-0
                              (let* ((a0-1 *level-load-list*)
                                     (a1-0 (car a0-1))
                                     )
                                (while (not (null? a0-1))
                                  (let ((a1-1 (the-as basic (-> (the-as level-load-info a1-0) name))))
                                    (if (= (-> (the-as level-load-info a1-1) index) (+ (-> v1-0 index) 1))
                                        (return (the-as level-load-info a1-1))
                                        )
                                    )
                                  (set! a0-1 (cdr a0-1))
                                  (set! a1-0 (car a0-1))
                                  )
                                )
                              #f
                              )
            )
    )
  )

(defstate target-continue (target)
  :event target-generic-event-handler
  :exit (behavior ()
    (set! (-> *load-boundary-target* 0 quad) (-> (camera-pos) quad))
    (set! (-> *load-boundary-target* 1 quad) (-> (target-pos 0) quad))
    (set! (-> *load-boundary-target* 2 quad) (-> *load-boundary-target* 0 quad))
    (set! (-> *load-boundary-target* 3 quad) (-> *load-boundary-target* 1 quad))
    (when (not (logtest? (-> *game-info* current-continue flags) (continue-flags intro sage-intro title)))
      (set! (-> *level* border?) (-> *level* play?))
      (set! (-> *setting-control* default border-mode) (-> *level* play?))
      )
    (remove-setting! 'allow-pause)
    (remove-setting! 'allow-progress)
    (remove-setting! 'bg-a)
    (remove-setting! 'music-volume)
    (remove-setting! 'sfx-volume)
    (remove-setting! 'ambient-volume)
    (remove-setting! 'music)
    (none)
    )
  :code (behavior ((arg0 continue-point))
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (if (-> *art-control* reserve-buffer)
        (reserve-free *art-control* (-> *art-control* reserve-buffer heap))
        )
    (add-setting! 'bg-a 'abs 1.0 0)
    (set! (-> *setting-control* current bg-a) 1.0)
    (set-setting! 'sfx-volume 'abs 0.0 0)
    (set-setting! 'ambient-volume 'abs 0.0 0)
    (let ((v1-20 (lookup-level-info (-> arg0 level))))
      (when v1-20
        (set-setting! 'music (-> v1-20 music-bank) 0.0 0)
        (set-setting! 'music-volume 'abs 0.0 0)
        )
      )
    (set! (-> *level* border?) #f)
    (set! (-> *setting-control* default border-mode) #f)
    (reset-target-state #t)
    (target-exit)
    (ja-channel-set! 0)
    (quaternion-copy! (-> self control unknown-quaternion00) (-> arg0 quat))
    (move-to-point! (-> self control) (-> arg0 trans))
    (rot->dir-targ! (-> self control))
    (set! (-> (&-> (-> self control) unknown-qword00) 0) (-> self control trans quad))
    (cond
      ((not (string= (-> arg0 name) "default"))
       (set! *external-cam-mode* #f)
       (cam-stop)
       (suspend)
       0
       )
      (else
        (send-event *camera* 'clear-entity)
        (send-event *camera* 'change-state cam-fixed 0)
        (suspend)
        0
        )
      )
    (set! (-> *load-state* vis-nick) (-> arg0 vis-nick))
    (set! (-> *load-state* want 0 name) (-> arg0 lev0))
    (set! (-> *load-state* want 0 display?) (-> arg0 disp0))
    (set! (-> *load-state* want 0 force-vis?) #f)
    (set! (-> *load-state* want 0 force-inside?) #f)
    (set! (-> *load-state* want 1 name) (-> arg0 lev1))
    (set! (-> *load-state* want 1 display?) (-> arg0 disp1))
    (set! (-> *load-state* want 1 force-vis?) #f)
    (set! (-> *load-state* want 1 force-inside?) #f)
    (when (not (string= (-> arg0 name) "default"))
      (while (not (and (or (not (-> arg0 lev0)) (not (-> arg0 disp0)) (= (level-status *level* (-> arg0 lev0)) 'active))
                       (or (not (-> arg0 lev1)) (not (-> arg0 disp1)) (= (level-status *level* (-> arg0 lev1)) 'active))
                       )
                  )
        (let ((v1-52 (lookup-level-info (-> arg0 level))))
          (if (and v1-52
                   (= (-> *setting-control* current music) (-> v1-52 music-bank))
                   (not (logtest? (-> arg0 flags) (continue-flags sage-intro title)))
                   )
              (remove-setting! 'music-volume)
              )
          )
        (suspend)
        )
      )
    (backup-load-state-and-set-cmds *load-state* '())
    (execute-command *load-state* '(teleport))
    (let* ((s5-0 (-> arg0 load-commands))
           (a1-18 (car s5-0))
           )
      (while (not (null? s5-0))
        (execute-command *load-state* (the-as pair a1-18))
        (set! s5-0 (cdr s5-0))
        (set! a1-18 (car s5-0))
        )
      )
    (restore-load-state *load-state*)
    (set! (-> *ACTOR-bank* birth-max) 1000)
    (new 'stack 'transformq)
    (cond
      ((not (string= (-> arg0 name) "default"))
       (cam-start #t)
       (suspend)
       (suspend)
       (set! (-> *camera-combiner* trans quad) (-> arg0 camera-trans quad))
       (let ((s5-1 (-> *camera-combiner* inv-camera-rot))
             (s4-0 (-> arg0 camera-rot))
             )
         (matrix-identity! s5-1)
         (set! (-> s5-1 vector 0 x) (-> s4-0 0))
         (set! (-> s5-1 vector 0 y) (-> s4-0 1))
         (set! (-> s5-1 vector 0 z) (-> s4-0 2))
         (set! (-> s5-1 vector 1 x) (-> s4-0 3))
         (set! (-> s5-1 vector 1 y) (-> s4-0 4))
         (set! (-> s5-1 vector 1 z) (-> s4-0 5))
         (set! (-> s5-1 vector 2 x) (-> s4-0 6))
         (set! (-> s5-1 vector 2 y) (-> s4-0 7))
         (set! (-> s5-1 vector 2 z) (-> s4-0 8))
         )
       (send-event *camera* 'change-target self)
       (send-event *camera* 'no-intro)
       (send-event *camera* 'clear-entity)
       (send-event *camera* 'force-blend 0)
       (send-event *camera* 'change-state cam-fixed 0)
       (send-event *camera* 'change-state cam-string 0)
       )
      (else
        (send-event *camera* 'change-target self)
        (send-event *camera* 'change-state cam-string 0)
        (send-event *camera* 'teleport)
        (send-event *camera* 'no-intro)
        (send-event *camera* 'clear-entity)
        )
      )
    (send-event self 'level-enter (-> arg0 level))
    (dotimes (v1-124 (-> *level* length))
      (let ((a0-64 (-> *level* level v1-124)))
        (if (= (-> a0-64 status) 'active)
            (set! (-> a0-64 all-visible?) 'loading)
            )
        )
      )
    (let ((s5-2 (level-get *level* (-> arg0 level))))

      ;; vis info check added for PC, don't bother waiting for vis if the level doesn't have it.
      (when (and s5-2 (-> s5-2 vis-info 0))
        (while (and (= (-> s5-2 all-visible?) 'loading) (-> *level* vis?))
          (suspend)
          )
        )
      )
    (set! *spawn-actors* #t)
    (set! *teleport* #t)
    (set! (-> *ACTOR-bank* birth-max) 1000)
    (set-blackout-frames (seconds 0.1))
    (cond
      ((logtest? (-> arg0 flags) (continue-flags title))
       (go target-title)
       )
      ((logtest? (-> arg0 flags) (continue-flags intro))
       (start-sequence-a)
       )
      ((logtest? (-> arg0 flags) (continue-flags sage-intro))
       (let ((s5-3 (entity-by-name "sage-23")))
         (when s5-3
           (set-blackout-frames (seconds 100))
           (entity-birth-no-kill s5-3)
           (suspend)
           (send-event
             (if s5-3
                 (-> s5-3 extra process)
                 )
             'play-anim
             )
           )
         )
       )
      ((and (logtest? (-> arg0 flags) (continue-flags sage-ecorocks))
            (or (= (get-task-status (game-task beach-ecorocks)) (task-status need-hint))
                (= (get-task-status (game-task beach-ecorocks)) (task-status need-introduction))
                )
            (#when PC_PORT (not (is-speedrun-category? 'il-village1)))  ;; modified for PC port - skip green sage cutscene in Sandover IL speedrun
            )
       (let ((s5-4 (entity-by-name "sage-23")))
         (when s5-4
           (set-blackout-frames (seconds 100))
           (entity-birth-no-kill s5-4)
           (suspend)
           (set! arg0 (get-continue-by-name *game-info* "village1-hut"))
           (send-event
             (if s5-4
                 (-> s5-4 extra process)
                 )
             'play-anim
             )
           )
         )
       )
      ((logtest? (-> arg0 flags) (continue-flags demo))
       (go target-demo)
       )
      ((logtest? (-> arg0 flags) (continue-flags sage-demo-convo))
       (set-blackout-frames (seconds 1))
       (process-spawn-function
         process
         (lambda ()
           (local-vars (v1-10 basic))
           (let ((gp-0 (entity-by-name "sage-23")))
             (when gp-0
               (set-blackout-frames (seconds 100))
               (entity-birth-no-kill gp-0)
               (suspend)
               (suspend)
               (send-event
                 (if gp-0
                     (-> gp-0 extra process)
                     )
                 'play-anim
                 )
               )
             )
           (let ((gp-1 (-> *display* base-frame-counter)))
             (until (>= (- (-> *display* base-frame-counter) gp-1) (seconds 2))
               (suspend)
               )
             )
           (until (not v1-10)
             (suspend)
             (set! v1-10 (and *target* (logtest? (-> *target* state-flags) (state-flags grabbed))))
             )
           (set! (-> *cpad-list* cpads 0 change-time) (-> *display* base-frame-counter))
           (reset-actors 'dead)
           (start 'play (get-continue-by-name *game-info* "misty-start"))
           )
         )
       )
      ((logtest? (-> arg0 flags) (continue-flags warp))
       (let ((s5-6 (new 'static 'vector)))
         (cond
           ((string= (-> arg0 name) "village1-warp")
            (set! (-> s5-6 quad) (-> (entity-by-name "villagea-part-1") extra trans quad))
            (suspend)
            (let ((s4-2 (new 'stack-no-clear 'event-message-block)))
              (set! (-> s4-2 from) self)
              (set! (-> s4-2 num-params) 0)
              (set! (-> s4-2 message) 'hidden-other)
              (let ((s3-0 send-event-function)
                    (v1-175 (entity-by-name "sage-23"))
                    )
                (s3-0
                  (if v1-175
                      (-> v1-175 extra process)
                      )
                  s4-2
                  )
                )
              )
            (let ((s4-3 (new 'stack-no-clear 'event-message-block)))
              (set! (-> s4-3 from) self)
              (set! (-> s4-3 num-params) 0)
              (set! (-> s4-3 message) 'hidden-other)
              (let ((s3-1 send-event-function)
                    (v1-179 (entity-by-name "assistant-11"))
                    )
                (s3-1
                  (if v1-179
                      (-> v1-179 extra process)
                      )
                  s4-3
                  )
                )
              )
            (set-continue! *game-info* "village1-hut")
            )
           ((or (string= (-> arg0 name) "training-warp") (string= (-> arg0 name) "game-start"))
            (if (logtest? (-> arg0 flags) (continue-flags game-start))
                (close-specific-task! (game-task intro) (task-status need-resolution))
                )
            (set! (-> s5-6 quad) (-> (entity-by-name "training-part-1") extra trans quad))
            (set-continue! *game-info* "training-start")
            )
           ((string= (-> arg0 name) "village2-warp")
            (set! (-> s5-6 quad) (-> (entity-by-name "villageb-part-55") extra trans quad))
            (when (task-closed? (game-task village2-levitator) (task-status need-hint))
              (suspend)
              (let ((s4-6 (new 'stack-no-clear 'event-message-block)))
                (set! (-> s4-6 from) self)
                (set! (-> s4-6 num-params) 0)
                (set! (-> s4-6 message) 'hidden-other)
                (let ((s3-2 send-event-function)
                      (v1-201 (entity-by-name "assistant-bluehut-1"))
                      )
                  (s3-2
                    (if v1-201
                        (-> v1-201 extra process)
                        )
                    s4-6
                    )
                  )
                )
              (let ((s4-7 (new 'stack-no-clear 'event-message-block)))
                (set! (-> s4-7 from) self)
                (set! (-> s4-7 num-params) 0)
                (set! (-> s4-7 message) 'hidden-other)
                (let ((s3-3 send-event-function)
                      (v1-205 (entity-by-name "sage-bluehut-1"))
                      )
                  (s3-3
                    (if v1-205
                        (-> v1-205 extra process)
                        )
                    s4-7
                    )
                  )
                )
              (let ((s4-8 (new 'stack-no-clear 'event-message-block)))
                (set! (-> s4-8 from) self)
                (set! (-> s4-8 num-params) 0)
                (set! (-> s4-8 message) 'hidden-other)
                (let ((s3-4 send-event-function)
                      (v1-209 (entity-by-name "flutflut-bluehut-1"))
                      )
                  (s3-4
                    (if v1-209
                        (-> v1-209 extra process)
                        )
                    s4-8
                    )
                  )
                )
              )
            (set-continue! *game-info* "village2-start")
            )
           ((string= (-> arg0 name) "village3-warp")
            (set! (-> s5-6 quad) (-> (entity-by-name "villagec-part-32") extra trans quad))
            (when (task-closed? (game-task village3-button) (task-status need-hint))
              (suspend)
              (let ((s4-10 (new 'stack-no-clear 'event-message-block)))
                (set! (-> s4-10 from) self)
                (set! (-> s4-10 num-params) 0)
                (set! (-> s4-10 message) 'hidden-other)
                (let ((s3-5 send-event-function)
                      (v1-220 (entity-by-name "assistant-villagec-1"))
                      )
                  (s3-5
                    (if v1-220
                        (-> v1-220 extra process)
                        )
                    s4-10
                    )
                  )
                )
              (let ((s4-11 (new 'stack-no-clear 'event-message-block)))
                (set! (-> s4-11 from) self)
                (set! (-> s4-11 num-params) 0)
                (set! (-> s4-11 message) 'hidden-other)
                (let ((s3-6 send-event-function)
                      (v1-224 (entity-by-name "sage-villagec-1"))
                      )
                  (s3-6
                    (if v1-224
                        (-> v1-224 extra process)
                        )
                    s4-11
                    )
                  )
                )
              )
            (set-continue! *game-info* "village3-start")
            )
           ((string= (-> arg0 name) "citadel-warp")
            (set! (-> s5-6 quad) (-> (entity-by-name "citb-part-1") extra trans quad))
            (when (task-closed? (game-task village4-button) (task-status need-hint))
              (suspend)
              (let ((s4-13 (new 'stack-no-clear 'event-message-block)))
                (set! (-> s4-13 from) self)
                (set! (-> s4-13 num-params) 0)
                (set! (-> s4-13 message) 'hidden-other)
                (let ((s3-7 send-event-function)
                      (v1-235 (entity-by-name "assistant-lavatube-end-3"))
                      )
                  (s3-7
                    (if v1-235
                        (-> v1-235 extra process)
                        )
                    s4-13
                    )
                  )
                )
              )
            (set-continue! *game-info* "lavatube-end")
            )
           )
         (go target-warp-in s5-6 (-> arg0 trans))
         )
       )
      (else
        (let ((s5-7 (-> *display* base-frame-counter)))
          (until (>= (- (-> *display* base-frame-counter) s5-7) (seconds 0.05))
            (suspend)
            )
          )
        )
      )
    (set-continue! *game-info* arg0)
    (when *auto-continue*
      (let ((s5-8 (next-level (-> arg0 level))))
        (when (and s5-8 (not (null? (-> s5-8 continues))))
          (format 0 "~A ~A ~A~%" (-> arg0 level) (-> s5-8 name) (car (-> s5-8 continues)))
          (inspect global)
          (process-spawn-function process (lambda ((arg0 continue-point)) (start 'play arg0)) (car (-> s5-8 continues)))
          )
        )
      )
    (ja-channel-set! 1)
    (ja :group! eichar-stance-loop-ja)
    (suspend)
    (logior! (-> self control status) (cshape-moving-flags onsurf onground tsurf))
    (go target-stance)
    (none)
    )
  :post target-no-move-post
  )

(define *smack-mods* (new 'static 'surface
                       :name 'jump
                       :tiltv 32768.0
                       :tiltvv 131072.0
                       :transv-max 40960.0
                       :target-speed 40960.0
                       :seek0 0.3
                       :seek90 0.3
                       :seek180 0.3
                       :fric 0.05
                       :nonlin-fric-dist 1.0
                       :slip-factor 1.0
                       :slide-factor 1.0
                       :slope-up-factor 1.0
                       :slope-down-factor 1.0
                       :slope-slip-angle 1.0
                       :impact-fric 1.0
                       :bend-factor 1.0
                       :bend-speed 1.0
                       :alignv 1.0
                       :slope-up-traction 1.0
                       :align-speed 1.0
                       :mult-hook (lambda :behavior target
                         ((arg0 surface) (arg1 surface) (arg2 surface) (arg3 int))
                         (when (= arg3 1)
                           (let ((f30-0 (-> self control unknown-float40))
                                 (f28-0 (-> self control unknown-float41))
                                 )
                             (set! (-> arg0 seek0) (lerp (-> arg0 seek0) (the-as float 409600.0) f28-0))
                             (set! (-> arg0 seek90) (lerp (-> arg0 seek90) (the-as float 409600.0) f28-0))
                             (set! (-> arg0 seek180) (lerp (-> arg0 seek180) (the-as float 409600.0) f28-0))
                             (set! (-> arg0 target-speed) (lerp (-> arg0 target-speed) f30-0 f28-0))
                             (set! (-> arg0 transv-max) (lerp (-> arg0 transv-max) f30-0 f28-0))
                             )
                           )
                         (none)
                         )
                       :mode 'air
                       :flags (surface-flags jump)
                       )
        )

(define *smack-up-mods*
  (new 'static 'surface
    :name 'jump
    :turnv 131072.0
    :turnvv 32768.0
    :tiltv 32768.0
    :tiltvv 131072.0
    :transv-max 40960.0
    :target-speed 40960.0
    :seek0 0.3
    :seek90 0.3
    :seek180 0.3
    :fric 0.05
    :nonlin-fric-dist 1.0
    :slip-factor 1.0
    :slide-factor 1.0
    :slope-up-factor 1.0
    :slope-down-factor 1.0
    :slope-slip-angle 1.0
    :impact-fric 1.0
    :bend-factor 1.0
    :bend-speed 1.0
    :alignv 1.0
    :slope-up-traction 1.0
    :align-speed 1.0
    :mult-hook (lambda :behavior target
      ((arg0 surface) (arg1 surface) (arg2 surface) (arg3 int))
      (when (= arg3 1)
        (let ((f30-0 (-> self control unknown-float40))
              (f28-0 (-> self control unknown-float41))
              )
          (set! (-> arg0 seek0) (lerp (-> arg0 seek0) (the-as float 409600.0) f28-0))
          (set! (-> arg0 seek90) (lerp (-> arg0 seek90) (the-as float 409600.0) f28-0))
          (set! (-> arg0 seek180) (lerp (-> arg0 seek180) (the-as float 409600.0) f28-0))
          (set! (-> arg0 target-speed) (lerp (-> arg0 target-speed) f30-0 f28-0))
          (set! (-> arg0 transv-max) (lerp (-> arg0 transv-max) f30-0 f28-0))
          )
        )
      (none)
      )
    :mode 'air
    :flags (surface-flags no-turn-around no-rotate-toward-transv jump)
    )
  )

(defbehavior velocity-set-to-target! target ((arg0 vector) (arg1 float) (arg2 attack-info))
  (let* ((v1-1 (-> self control trans))
         (gp-1 (vector-! (new 'stack-no-clear 'vector) arg0 v1-1))
         )
    (set! (-> gp-1 y) 0.0)
    (set! (-> self control unknown-vector40 quad) (-> gp-1 quad))
    (vector-xz-normalize! (-> self control unknown-vector40) (the-as float 1.0))
    (set! (-> self control unknown-float50) 1.0)
    (set! (-> self control unknown-float40) arg1)
    (set! (-> self control unknown-float41) (- 1.0 (-> arg2 control)))
    gp-1
    )
  )

(defbehavior target-hit-effect target ((arg0 attack-info))
  (process-spawn
    part-tracker
    :init part-tracker-init
    (-> *part-group-id-table* 1)
    -1
    #f
    #f
    #f
    (if (logtest? (-> arg0 mask) (attack-mask intersection))
        (-> arg0 intersection)
        (-> self control root-prim prim-core)
        )
    :to self
    )
  (let ((v1-9 (-> arg0 mode)))
    (cond
      ((or (= v1-9 'endlessfall) (= v1-9 'instant-death))
       )
      ((begin
         (target-timed-invulnerable (-> arg0 invinc-time) self)
         (cpad-set-buzz! (-> *cpad-list* cpads 0) 0 255 (seconds 0.5))
         (let ((v1-13 (-> arg0 angle)))
           (= v1-13 'up)
           )
         )
       (sound-play "hit-up")
       )
      (else
        (sound-play "oof")
        )
      )
    )
  (case (-> arg0 mode)
    (('burn 'burnup)
     (if (not (handle->process (-> self burn-proc)))
         (set! (-> self burn-proc)
               (ppointer->handle (process-spawn-function process process-drawable-burn-effect (seconds 4) :to self))
               )
         )
     )
    (('tar)
     (sound-play "get-burned")
     )
    )
  0
  (none)
  )

(defbehavior target-hit-push target ((arg0 vector) (arg1 matrix) (arg2 float) (arg3 float) (arg4 attack-info))
  (case (-> arg4 angle)
    (('jump 'up 'up-forward)
     (when (and (not (logtest? (-> self control root-prim prim-core action) (collide-action racer flut)))
                (not (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact-info-target health))))
                )
       (if (and (cpad-pressed? (-> self control unknown-cpad-info00 number) circle) (can-feet?))
           (go target-attack-air #f)
           )
       (if (and (cpad-pressed? (-> self control unknown-cpad-info00 number) square)
                (< (vector-dot (-> self control dynam gravity-normal) (-> self control transv)) 26624.0)
                (and (< -61440.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                     (>= (- (-> *display* base-frame-counter) (-> self control unknown-dword36))
                         (the-as time-frame (-> *TARGET-bank* stuck-timeout))
                         )
                     (not (logtest? (-> self state-flags) (state-flags prevent-attack)))
                     (not (logtest? (-> self control unknown-surface01 flags) (surface-flags prevent-attacks-during-launch-jump surf08))
                          )
                     )
                )
           (go
             target-flop
             (the-as float 65502.96)
             (the-as float -163840.0)
             (the-as float (if (= (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) stick0-speed) 0.0)
                               0.0
                               68812.8
                               )
                     )
             )
           )
       )
     )
    )
  (when (if (and (< (target-move-dist (-> *TARGET-bank* stuck-time)) (-> *TARGET-bank* stuck-distance))
                 (and (>= (- (-> *display* base-frame-counter) (-> self state-time))
                          (the-as time-frame (-> *TARGET-bank* stuck-time))
                          )
                      (not (and *cheat-mode* (cpad-hold? (-> self control unknown-cpad-info00 number) r2)))
                      )
                 )
            #t
            )
    (logior! (-> self control status) (cshape-moving-flags onsurf))
    (return (the-as object 'stuck))
    )
  (let ((s1-0 (new-stack-vector0)))
    (set! (-> s1-0 z) arg2)
    (vector-matrix*! s1-0 s1-0 arg1)
    (vector+! s1-0 s1-0 arg0)
    (cond
      ((< (vector-vector-distance arg0 s1-0) (fabs (-> arg4 dist)))
       (velocity-set-to-target! s1-0 (fabs arg3) arg4)
       #t
       )
      (else
        (set! (-> self control unknown-float40) 0.0)
        (set! (-> self control unknown-float41) (- 1.0 (-> arg4 control)))
        #f
        )
      )
    )
  )

(defbehavior target-hit-orient target ((arg0 attack-info) (arg1 vector))
  (let ((s5-0 #f))
    (if (and (!= (-> arg0 angle) 'front)
             (!= (-> arg0 angle) 'shove)
             (logtest? (-> arg0 mask) (attack-mask vector))
             (!= (-> arg0 shove-back) 0.0)
             )
        (forward-up-nopitch->quaternion (-> self control dir-targ) arg1 (-> self control dynam gravity-normal))
        )
    (case (-> arg0 angle)
      (('back 'air)
       (set! s5-0 #t)
       )
      (('up-forward)
       (set! (-> self control unknown-surface00) *smack-up-mods*)
       )
      (('front)
       (if (and (logtest? (-> arg0 mask) (attack-mask vector)) (!= (-> arg0 shove-back) 0.0))
           (forward-up-nopitch->quaternion
             (-> self control dir-targ)
             (vector-negate! (new 'stack-no-clear 'vector) arg1)
             (-> self control dynam gravity-normal)
             )
           )
       (set! s5-0 #t)
       )
      (('jump)
       (set! s5-0 #t)
       (set! (-> self control unknown-surface00) *forward-high-jump-mods*)
       )
      )
    s5-0
    )
  )

(defbehavior target-hit-setup-anim target ((arg0 attack-info))
  (case (-> arg0 angle)
    (('back)
     (when (not (ja-group? eichar-hit-from-back-ja))
       (ja-channel-push! 1 (seconds 0.075))
       (ja :group! eichar-hit-from-back-ja :num! min)
       )
     )
    (('up 'up-forward)
     (when (not (ja-group? eichar-hit-up-ja))
       (ja-channel-push! 1 (seconds 0.075))
       (ja :group! eichar-hit-up-ja :num! min)
       )
     )
    (('air 'jump)
     (ja-channel-push! 1 (seconds 0.05))
     (ja-no-eval :group! eichar-jump-ja :num! (seek!) :frame-num 0.0)
     (when (= (-> arg0 angle) 'air)
       (sound-play "smack-surface")
       (effect-control-method-10 (-> self skel effect) 'group-smack-surface (the-as float 0.0) 5)
       (effect-control-method-10 (-> self skel effect) 'group-smack-surface-dizzy (the-as float 0.0) 8)
       )
     )
    (('shove)
     (ja-channel-push! 1 (seconds 0.05))
     (ja-no-eval :group! eichar-smack-surface-ja :num! (seek!) :frame-num 0.0)
     (sound-play "smack-surface")
     )
    (else
      (when (not (ja-group? eichar-hit-from-front-ja))
        (ja-channel-push! 1 (seconds 0.075))
        (ja :group! eichar-hit-from-front-ja :num! min)
        )
      )
    )
  (none)
  )

(defbehavior target-hit-move target ((arg0 attack-info) (arg1 symbol) (arg2 (function none :behavior target)) (arg3 float))
  (local-vars (v1-40 symbol) (s2-1 object))
  (vector-identity! (-> self control transv))
  (let ((s3-0 (new-stack-vector0)))
    (let ((f0-1 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
      0.0
      (vector-! s3-0 (-> self control transv) (vector-float*! s3-0 (-> self control dynam gravity-normal) f0-1))
      )
    (let* ((f0-2 (vector-length s3-0))
           (f1-1 f0-2)
           (f2-1 (+ 2048.0 (sqrtf (* 491520.0 (-> arg0 shove-up)))))
           )
      (vector+!
        (-> self control transv)
        (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-1)
        (vector-float*! s3-0 s3-0 (/ f0-2 f1-1))
        )
      )
    )
  (let ((s3-1 (new 'stack-no-clear 'vector)))
    (set! (-> s3-1 quad) (-> self control trans quad))
    (let ((s1-1 (matrix-rotate-y! (new 'stack-no-clear 'matrix) (+ 32768.0 (vector-y-angle (-> arg0 vector)))))
          (f30-1 0.0)
          )
      (set-quaternion! (-> self control) (-> self control dir-targ))
      #t
      (let ((f28-1 (* 1.05 (/ (* -60.0 arg3) (* (the float (+ (-> (ja-group) data 0 length) -1)) (ja-step 0))))))
        (until v1-40
          (+! f30-1 (* (-> arg0 shove-back) f28-1 (-> *display* seconds-per-frame)))
          (set! s2-1 (target-hit-push s3-1 s1-1 f30-1 (* (-> arg0 shove-back) f28-1) arg0))
          (suspend)
          (ja :num! (seek!))
          (set! v1-40 (or (ja-done? 0) (and arg1 (logtest? (-> self control status) (cshape-moving-flags onsurf)))))
          )
        (while (and (or (not (logtest? (-> self control status) (cshape-moving-flags onsurf))) s2-1) (!= s2-1 'stuck))
          (arg2)
          (+! f30-1 (* (-> arg0 shove-back) f28-1 (-> *display* seconds-per-frame)))
          (set! s2-1 (target-hit-push s3-1 s1-1 f30-1 (* (-> arg0 shove-back) f28-1) arg0))
          (if (not s2-1)
              (logclear! (-> self state-flags) (state-flags being-attacked))
              )
          (suspend)
          )
        )
      )
    )
  0
  (none)
  )

(defstate target-hit (target)
  :event target-standard-event-handler
  :exit (behavior ()
    (let ((gp-0 (new-stack-vector0))
          (f30-0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
          )
      0.0
      (vector-! gp-0 (-> self control transv) (vector-float*! gp-0 (-> self control dynam gravity-normal) f30-0))
      (let* ((f1-0 (vector-length gp-0))
             (f0-3 f1-0)
             )
        (if (< 40960.0 f1-0)
            (set! f1-0 40960.0)
            )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f30-0)
          (vector-float*! gp-0 gp-0 (/ f1-0 f0-3))
          )
        )
      )
    (if (!= (-> self next-state name) 'target-death)
        (logclear! (-> self state-flags) (state-flags being-attacked dying))
        )
    (target-exit)
    (none)
    )
  :trans (behavior ()
    (when (= *cheat-mode* 'debug)
      (when (and (not *pause-lock*) (cpad-hold? (-> self control unknown-cpad-info00 number) r2))
        (pickup-collectable! (-> self fact-info-target) (pickup-type eco-green) (the-as float 1.0) (the-as handle #f))
        (go target-stance)
        )
      )
    (none)
    )
  :code (behavior ((arg0 symbol) (arg1 attack-info))
    (logclear! (-> self water flags) (water-flags wt16))
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (let ((gp-0 (-> self attack-info)))
      (let ((s5-0 (new 'stack-no-clear 'vector)))
        (let ((v1-4 gp-0))
          (set! (-> v1-4 attacker) (the-as handle #f))
          (set! (-> v1-4 mode) 'generic)
          (set! (-> v1-4 shove-back) 6144.0)
          (set! (-> v1-4 shove-up) 4915.2)
          (set! (-> v1-4 angle) #f)
          (set! (-> v1-4 trans quad) (-> self control trans quad))
          (set! (-> v1-4 control) 0.0)
          (set! (-> v1-4 invinc-time) (-> *TARGET-bank* hit-invulnerable-timeout))
          )
        (case arg0
          (('shove)
           (let ((v1-7 gp-0))
             (set! (-> v1-7 shove-back) (-> *TARGET-bank* smack-surface-dist))
             (set! (-> v1-7 shove-up) (-> *TARGET-bank* smack-surface-height))
             (set! (-> v1-7 angle) 'shove)
             )
           )
          )
        (combine! gp-0 arg1)
        (when (not (logtest? (-> gp-0 mask) (attack-mask vector)))
          (vector-z-quaternion! (-> gp-0 vector) (-> self control unknown-quaternion00))
          (vector-xz-normalize! (-> gp-0 vector) (- (fabs (-> gp-0 shove-back))))
          (set! (-> gp-0 vector y) (-> gp-0 shove-up))
          )
        (set! (-> s5-0 quad) (-> gp-0 vector quad))
        (let ((f0-10 (vector-dot
                       (vector-normalize-copy! (new 'stack-no-clear 'vector) s5-0 (the-as float 1.0))
                       (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control unknown-quaternion00))
                       )
                     )
              )
          (if (not (-> self attack-info angle))
              (set! (-> self attack-info angle) (if (>= 0.0 f0-10)
                                                    'front
                                                    'back
                                                    )
                    )
              )
          )
        (cond
          ((= arg0 'attack)
           (logior! (-> self state-flags) (state-flags being-attacked))
           (set! (-> self game hit-time) (-> *display* base-frame-counter))
           (case (-> gp-0 mode)
             (('endlessfall)
              (cond
                ((= (-> self game mode) 'debug)
                 (let ((s4-1 (new-stack-vector0)))
                   (set! (-> s4-1 quad) (-> self control last-known-safe-ground quad))
                   (ja-channel-set! 0)
                   (let ((s3-1 (-> *display* base-frame-counter)))
                     (until (>= (- (-> *display* base-frame-counter) s3-1) (seconds 1))
                       (suspend)
                       )
                     )
                   (move-to-point! (-> self control) s4-1)
                   )
                 (set! (-> (&-> (-> self control) unknown-qword00) 0) (-> self control trans quad))
                 (send-event *camera* 'teleport)
                 (go target-stance)
                 )
                (else
                  (pickup-collectable!
                    (-> self fact-info-target)
                    (pickup-type eco-green)
                    (the-as float -1000.0)
                    (the-as handle #f)
                    )
                  (go target-death (-> gp-0 mode))
                  )
                )
              )
             (('drown-death 'sharkey 'lava 'dark-eco-pool 'ogreboss-super-boulder 'melt 'instant-death)
              (pickup-collectable!
                (-> self fact-info-target)
                (pickup-type eco-green)
                (the-as float -1000.0)
                (the-as handle #f)
                )
              (if (= (-> self game mode) 'play)
                  (go target-death (-> gp-0 mode))
                  )
              )
             (('death)
              (pickup-collectable!
                (-> self fact-info-target)
                (pickup-type eco-green)
                (the-as float -1000.0)
                (the-as handle #f)
                )
              )
             (('plant-boss)
              (pickup-collectable!
                (-> self fact-info-target)
                (pickup-type eco-green)
                (- (-> *FACT-bank* health-single-inc))
                (the-as handle #f)
                )
              (if (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact-info-target health)))
                  (go target-death (-> gp-0 mode))
                  )
              )
             (else
               (pickup-collectable!
                 (-> self fact-info-target)
                 (pickup-type eco-green)
                 (- (-> *FACT-bank* health-single-inc))
                 (the-as handle #f)
                 )
               )
             )
           (target-hit-effect gp-0)
           )
          (else
            (case (-> gp-0 mode)
              (('burn 'burnup)
               (sound-play "get-burned")
               )
              )
            )
          )
        (set! (-> self control unknown-surface00) *smack-mods*)
        (target-hit-setup-anim gp-0)
        (target-hit-move gp-0 (target-hit-orient gp-0 s5-0) target-falling-anim-trans (the-as float 1.0))
        )
      (if (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact-info-target health)))
          (go target-death (-> gp-0 mode))
          )
      )
    (go target-hit-ground #f)
    (none)
    )
  :post target-post
  )

(define *death-spool-array*
  (new 'static 'boxed-array :type spool-anim
    (new 'static 'spool-anim :name "death-0181" :index 3 :parts 1 :command-list '())
    (new 'static 'spool-anim :name "death-0182" :index 4 :parts 1 :command-list '())
    (new 'static 'spool-anim :name "death-0184" :index 5 :parts 1 :command-list '())
    (new 'static 'spool-anim :name "death-0186" :index 6 :parts 1 :command-list '())
    (new 'static 'spool-anim :name "death-0187" :index 7 :parts 1 :command-list '())
    (new 'static 'spool-anim :name "death-0191" :index 8 :parts 1 :command-list '())
    (new 'static 'spool-anim :name "death-0193" :index 9 :parts 2 :command-list '())
    (new 'static 'spool-anim :name "death-0195" :index 10 :parts 1 :command-list '())
    (new 'static 'spool-anim :name "death-0197" :index 11 :parts 2 :command-list '())
    (new 'static 'spool-anim :name "death-0199" :index 12 :parts 2 :command-list '())
    (new 'static 'spool-anim :name "death-0202" :index 13 :parts 1 :command-list '())
    )
  )

(if (!= *kernel-boot-message* 'play)
    (set! (-> *death-spool-array* length) 3)
    )

(defun death-movie-remap ((arg0 int) (arg1 int))
  (let ((v1-0 (/ arg0 arg1)))
    (mod
      (if (not (logtest? v1-0 1))
          (logxor v1-0 arg0)
          (logand #xfffffff (- (logxor v1-0 arg0)))
          )
      arg1
      )
    )
  )

(defbehavior target-death-anim target ((arg0 spool-anim))
  (set! (-> self control unknown-surface00) *neutral-mods*)
  (ja-channel-push! 1 (seconds 0.1))
  (ja-no-eval :group! eichar-deatha-ja :num! (seek!) :frame-num 0.0)
  (until (ja-done? 0)
    (if arg0
        (spool-push *art-control* (-> arg0 name) 0 self (the-as float -99.0))
        )
    (send-event *camera* 'joystick 0.0 -1.0)
    (compute-alignment! (-> self align))
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (when (not (logtest? (-> self align flags) (align-flags disabled)))
        (vector-matrix*! s5-0 (the-as vector (-> self align delta)) (-> self control unknown-matrix01))
        (vector-float*! (-> self control transv) s5-0 (-> *display* frames-per-second))
        )
      )
    (suspend)
    (ja :num! (seek!))
    )
  0
  (none)
  )

(defstate target-death (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v1-0 event-type))
      (the-as object (cond
                       ((= v1-0 'end-mode)
                        (let ((v0-0 (the-as object #t)))
                          (set! (-> self control unknown-uint20) (the-as uint v0-0))
                          v0-0
                          )
                        )
                       ((= v1-0 'change-mode)
                        (case (-> event param 0)
                          (('grab)
                           #t
                           )
                          )
                        )
                       ((= v1-0 'notify)
                        (when (type-type? (-> proc type) pov-camera)
                          (case (-> event param 0)
                            (('die 'abort-request)
                             (set! (-> self control unknown-uint20) (the-as uint #t))
                             (the-as object (set-blackout-frames (seconds 0.2)))
                             )
                            )
                          )
                        )
                       ((= v1-0 'get-pickup)
                        #f
                        )
                       ((= v1-0 'touched)
                        #f
                        )
                       (else
                         (target-generic-event-handler proc arg1 event-type event)
                         )
                       )
              )
      )
    )
  :exit (behavior ()
    (logclear! (-> self state-flags) (state-flags being-attacked dying))
    (target-exit)
    (remove-setting! 'process-mask)
    (remove-setting! 'allow-progress)
    (restore-collide-with-as (-> self control))
    (set! (-> self control pat-ignore-mask) (new 'static 'pat-surface :noentity #x1))
    (set! (-> self control dynam gravity-max) (-> self control unknown-dynamics00 gravity-max))
    (set! (-> self control dynam gravity-length) (-> self control unknown-dynamics00 gravity-length))
    (none)
    )
  :trans (-> target-hit trans)
  :code (behavior ((arg0 symbol))
    (set! (-> self control unknown-uint20) (the-as uint #f))
    (set! (-> self control unknown-int21)
          (the-as int (send-event (handle->process (-> self attack-info attacker)) 'target 'die arg0))
          )
    (set! (-> self neck flex-blend) 0.0)
    (target-timed-invulnerable-off self)
    (set-setting! 'process-mask 'set 0.0 (process-mask enemy platform projectile death))
    (apply-settings *setting-control*)
    (set! (-> self control transv quad) (the-as uint128 0))
    (logior! (-> self state-flags) (state-flags dying))
    (case arg0
      (('none 'instant-death)
       )
      (('ogreboss-super-boulder)
       ;; PAL patch here
       (process-spawn
         part-tracker
         :init part-tracker-init
         (-> *part-group-id-table* 32)
         -1
         #f
         #f
         #f
         (-> self control trans)
         :to *entity-pool*
         )
       (set! (-> self post-hook) target-no-ja-move-post)
       (-> self attack-info attacker)
       (ja-channel-set! 0)
       (ja-post)
       (let ((gp-1 (-> *display* base-frame-counter)))
         (until (>= (- (-> *display* base-frame-counter) gp-1) (seconds 1))
           (suspend)
           )
         )
       )
      (('drown 'drown-death)
       (sound-play "death-drown")
       (logclear! (-> self water flags) (water-flags wt04))
       (clear-collide-with-as (-> self control))
       (set! (-> self control unknown-surface00) *dive-mods*)
       (set! (-> self control dynam gravity-max) 6144.0)
       (set! (-> self control dynam gravity-length) 6144.0)
       (ja-channel-push! 1 (seconds 0.1))
       (let ((f30-0 0.7)
             (gp-3 (-> self skel root-channel 0))
             )
         (set! (-> gp-3 frame-group) (the-as art-joint-anim eichar-swim-walk-to-down-ja))
         (set! (-> gp-3 param 0) (ja-aframe (the-as float 73.0) 0))
         (let ((f30-1 (seek f30-0 (the-as float 0.05) (* 1.5 (-> *display* seconds-per-frame)))))
           (set! (-> gp-3 param 1) f30-1)
           (set! (-> gp-3 frame-num) 0.0)
           (joint-control-channel-group! gp-3 (the-as art-joint-anim eichar-swim-walk-to-down-ja) num-func-seek!)
           (until (ja-done? 0)
             (suspend)
             (let ((gp-4 (-> self skel root-channel 0)))
               (set! (-> gp-4 param 0) (ja-aframe (the-as float 73.0) 0))
               (set! f30-1 (seek f30-1 (the-as float 0.05) (* 1.5 (-> *display* seconds-per-frame))))
               (set! (-> gp-4 param 1) f30-1)
               (joint-control-channel-group-eval! gp-4 (the-as art-joint-anim #f) num-func-seek!)
               )
             )
           )
         )
       )
      (('lava 'dark-eco-pool 'melt)
       (let ((s5-1 (handle->process (-> self attack-info attacker))))
         (when (if (and (nonzero? s5-1) (type-type? (-> s5-1 type) water-vol))
                   s5-1
                   )
           (logior! (-> self state-flags) (state-flags falling-into-pool-of-bad))
           (set! (-> self alt-cam-pos y) (+ 4096.0 (-> self water height)))
           )
         )
       (cond
         ((= arg0 'dark-eco-pool)
          (sound-play "death-darkeco")
          (process-spawn
            part-tracker
            :init part-tracker-init
            (-> *part-group-id-table* 31)
            -1
            #f
            #f
            #f
            (-> self control trans)
            :to *entity-pool*
            )
          )
         ((or (= arg0 'lava) (= arg0 'melt))
          (sound-play "death-melt")
          (process-spawn
            part-tracker
            :init part-tracker-init
            (-> *part-group-id-table* 32)
            -1
            #f
            #f
            #f
            (-> self control trans)
            :to *entity-pool*
            )
          )
         )
       (clear-collide-with-as (-> self control))
       (set! (-> self post-hook) target-no-ja-move-post)
       (ja-channel-set! 0)
       (ja-post)
       (let ((gp-9 (-> *display* base-frame-counter)))
         (until (>= (- (-> *display* base-frame-counter) gp-9) (seconds 2))
           (suspend)
           )
         )
       )
      (('endlessfall)
       (sound-play "death-fall")
       (camera-change-to (the-as string cam-endlessfall) 30 #f)
       (set! (-> self control pat-ignore-mask unknown-bit) 1)
       (logclear! (-> self water flags) (water-flags wt04))
       (let ((f30-2 (fmin -4096.0 (- (-> self control ground-impact-vel)))))
         (set! (-> self control unknown-uint20) (the-as uint f30-2))
         (let ((gp-11 (new-stack-vector0)))
           (let ((f0-14 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
             0.0
             (vector-! gp-11 (-> self control transv) (vector-float*! gp-11 (-> self control dynam gravity-normal) f0-14))
             )
           (let* ((f0-15 (vector-length gp-11))
                  (f1-6 f0-15)
                  )
             (vector+!
               (-> self control transv)
               (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f30-2)
               (vector-float*! gp-11 gp-11 (/ f0-15 f1-6))
               )
             )
           )
         )
       (set! (-> self trans-hook)
             (lambda :behavior target
               ()
               (vector-seek! (-> self draw color-mult) *zero-vector* (-> *display* seconds-per-frame))
               (let ((gp-0 (new-stack-vector0))
                     (f30-0 (the-as number (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
                     )
                 0.0
                 (vector-!
                   gp-0
                   (-> self control transv)
                   (vector-float*! gp-0 (-> self control dynam gravity-normal) (the-as float f30-0))
                   )
                 (let* ((f0-4 (vector-length gp-0))
                        (f1-0 f0-4)
                        )
                   (if (< (the-as float (-> self control unknown-uint20)) (the-as float f30-0))
                       (set! f30-0 (-> self control unknown-uint20))
                       )
                   (vector+!
                     (-> self control transv)
                     (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) (the-as float f30-0))
                     (vector-float*! gp-0 gp-0 (/ f0-4 f1-0))
                     )
                   )
                 )
               ((-> target-hit trans))
               (none)
               )
             )
       (target-falling-anim (seconds 0.1) (seconds 0.33))
       (ja-channel-push! 1 (seconds 0.3))
       (ja-no-eval :group! eichar-launch-jump-loop-ja :num! (loop! 0.5) :frame-num 0.0)
       (let ((gp-12 (-> *display* base-frame-counter)))
         (until (>= (- (-> *display* base-frame-counter) gp-12) (seconds 0.8))
           (ja :group! eichar-launch-jump-loop-ja :num! (loop! 0.5))
           (suspend)
           )
         )
       (camera-change-to (the-as string 'base) 0 #f)
       )
      (('target-hit-ground-hard)
       (set! (-> self control unknown-surface00) *neutral-mods*)
       (ja-channel-push! 1 (seconds 0.1))
       (ja-no-eval :group! eichar-death-painful-land-ja :num! (seek!) :frame-num 0.0)
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek!))
         )
       )
      (('sharkey)
       (send-event self 'dry)
       (set! (-> self post-hook) target-no-ja-move-post)
       (let ((gp-13 (-> self attack-info attacker)))
         (ja-channel-set! 0)
         (ja-post)
         (while (and (handle->process gp-13) (not (-> self control unknown-spoolanim00)))
           (send-event *camera* 'joystick 0.0 0.0)
           (suspend)
           )
         )
       )
      (('plant-boss)
       (set! (-> self trans-hook) #f)
       (let ((gp-14 (-> self attack-info attacker))
             (a1-44 (new 'stack-no-clear 'event-message-block))
             )
         (set! (-> a1-44 from) self)
         (set! (-> a1-44 num-params) 0)
         (set! (-> a1-44 message) 'joint)
         (let ((s5-5 (the-as int (send-event-function (handle->process gp-14) a1-44))))
           (send-event (ppointer->process (-> self sidekick)) 'matrix 'copy-parent)
           (set! (-> self post-hook) target-no-ja-move-post)
           (let ((a0-98 (-> self node-list data)))
             (set! (-> a0-98 0 param0) nothing)
             (set! (-> a0-98 0 param1) #f)
             (set! (-> a0-98 0 param2) #f)
             )
           (while (and (handle->process gp-14) (not (-> self control unknown-spoolanim00)) (-> self control unknown-int21))
             (let* ((v1-205 (-> (the-as process-drawable (handle->process gp-14)) node-list data s5-5 bone transform))
                    (a3-9 (-> self node-list data 0 bone transform))
                    (a0-106 (-> v1-205 vector 0 quad))
                    (a1-47 (-> v1-205 vector 1 quad))
                    (a2-26 (-> v1-205 vector 2 quad))
                    (v1-206 (-> v1-205 vector 3 quad))
                    )
               (set! (-> a3-9 vector 0 quad) a0-106)
               (set! (-> a3-9 vector 1 quad) a1-47)
               (set! (-> a3-9 vector 2 quad) a2-26)
               (set! (-> a3-9 vector 3 quad) v1-206)
               )
             (clone-anim-once gp-14 33 #f "")
             (suspend)
             0
             )
           )
         )
       )
      (('burn 'burnup)
       (process-spawn
         part-tracker
         :init part-tracker-init
         (-> *part-group-id-table* 708)
         -1
         #f
         #f
         #f
         (-> self control trans)
         :to *entity-pool*
         )
       (target-death-anim (the-as spool-anim #f))
       )
      (else
        (case arg0
          (('tar)
           (sound-play "death-drown")
           )
          )
        (+! (-> *game-info* death-movie-tick) 1)
        (if (= (death-movie-remap (+ (-> *game-info* death-movie-tick) -1) (-> *death-spool-array* length))
               (death-movie-remap (-> *game-info* death-movie-tick) (-> *death-spool-array* length))
               )
            (+! (-> *game-info* death-movie-tick) 1)
            )
        (let ((gp-18
                (-> *death-spool-array* (death-movie-remap (-> *game-info* death-movie-tick) (-> *death-spool-array* length)))
                )
              )
          (set-setting! 'allow-progress #f 0.0 0)
          (target-death-anim gp-18)
          (when (and (< (rand-vu-int-count (-> *game-info* death-movie-tick)) (* (-> *death-spool-array* length) 2))
                     (not (logtest? (-> self water flags) (water-flags wt09)))
                     (!= (-> self control ground-pat material) 9)
                     (!= (-> self control ground-pat material) 10)
                     )
            (iterate-process-tree
              *entity-pool*
              (lambda :behavior target
                ((arg0 process))
                (if (and (logtest? (process-mask enemy) (-> arg0 mask))
                         (type-type? (-> arg0 type) process-drawable)
                         (nonzero? (-> (the-as process-drawable arg0) root))
                         (< (vector-vector-distance (-> (the-as process-drawable arg0) root trans) (-> *target* control trans))
                            61440.0
                            )
                         )
                    (process-entity-status! arg0 (entity-perm-status bit-9) #t)
                    )
                )
              *null-kernel-context*
              )
            (set! (-> *ACTOR-bank* birth-max) 1000)
            (set! (-> self trans-hook) #f)
            (send-event (ppointer->process (-> self sidekick)) 'matrix 'play-anim)
            (send-event (ppointer->process (-> self sidekick)) 'shadow #f)
            (send-event self 'blend-shape #t)
            (let ((s5-8 (ppointer->handle
                          (process-spawn pov-camera (-> self control trans) *deathcam-sg* gp-18 4 self '() :to *target-pool*)
                          )
                        )
                  )
              (send-event (handle->process s5-8) 'music-movie-volume 0.0)
              (send-event (handle->process s5-8) 'sfx-movie-volume 50.0)
              (set! (-> self post-hook) target-no-ja-move-post)
              (while (not (-> self control unknown-spoolanim00))
                (spool-push *art-control* (-> gp-18 name) 0 self (the-as float -99.0))
                (clone-anim-once s5-8 33 #f "")
                (suspend)
                )
              (let ((a0-155 (handle->process s5-8)))
                (if a0-155
                    (deactivate a0-155)
                    )
                )
              )
            (send-event (ppointer->process (-> self sidekick)) 'shadow #t)
            (suspend)
            0
            )
          )
        )
      )
    (set! (-> self control transv quad) (the-as uint128 0))
    (initialize! (-> self game) 'dead (the-as game-save #f) (the-as string #f))
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (anim-loop)
    (none)
    )
  :post target-no-stick-post
  )
