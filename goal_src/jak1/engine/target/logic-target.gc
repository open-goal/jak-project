;;-*-Lisp-*-
(in-package goal)

;; name: logic-target.gc
;; name in dgo: logic-target
;; dgos: GAME, ENGINE
;; note: changed for high fps

;; target-start is modified due to changing the size of the stack in gkernel.gc

;; DECOMP BEGINS

(defbehavior build-conversions target ((arg0 vector))
  (surface-mult! (-> self control unknown-surface01) (-> self control unknown-surface00) (-> self control surf))
  (when (and (and (= (-> self fact-info-target eco-type) (pickup-type eco-blue))
                  (>= (-> self fact-info-target eco-level) 1.0)
                  )
             (or (= (-> self control unknown-surface00 name) 'run) (= (-> self control unknown-surface00 name) 'jump))
             )
    (set! (-> self control unknown-surface01 target-speed)
          (+ 20480.0 (-> self control unknown-surface01 target-speed))
          )
    (set! (-> self control unknown-surface01 transv-max)
          (+ 20480.0 (-> self control unknown-surface01 transv-max))
          )
    )
  (let ((s5-0 (new-stack-vector0)))
    (vector-z-quaternion! s5-0 (-> self control unknown-quaternion00))
    (when (logtest? (-> self control unknown-surface00 flags) (surface-flags dive))
      (vector-flatten! s5-0 s5-0 (-> self control dynam gravity-normal))
      (vector-normalize! s5-0 1.0)
      )
    (forward-up-nopitch->inv-matrix (-> self control unknown-matrix01) s5-0 (-> self control local-normal))
    )
  (matrix-transpose! (-> self control unknown-matrix00) (-> self control unknown-matrix01))
  (vector-matrix*! (-> self control unknown-vector00) arg0 (-> self control unknown-matrix00))
  (set! (-> self control unknown-vector51 quad) (-> self control unknown-vector50 quad))
  (let ((v0-7 (-> self control unknown-vector50)))
    (set! (-> v0-7 quad) (-> self control dynam gravity-normal quad))
    v0-7
    )
  )

(defbehavior vector-turn-to target ((arg0 vector))
  (let ((gp-0 forward-up-nopitch->quaternion)
        (s5-0 (-> self control dir-targ))
        (t9-0 vector-normalize!)
        (v1-1 (new-stack-vector0))
        )
    (set! (-> v1-1 quad) (-> arg0 quad))
    (gp-0 s5-0 (t9-0 v1-1 1.0) (vector-y-quaternion! (new-stack-vector0) (-> self control dir-targ)))
    )
  (set-quaternion! (-> self control) (-> self control dir-targ))
  (build-conversions (-> self control transv))
  )

(defbehavior reverse-conversions target ((arg0 vector))
  (set! (-> self control unknown-float01) (vector-xz-length (-> self control unknown-vector00)))
  (vector-matrix*! arg0 (-> self control unknown-vector00) (-> self control unknown-matrix01))
  (set! (-> self control old-status) (-> self control status))
  (none)
  )

(defun-debug draw-history ((arg0 control-info))
  (when (nonzero? *display-collide-history*)
    (when (cpad-pressed? 0 l3)
      (set! (-> arg0 history-length) (mod (+ (-> arg0 history-length) 1) 3))
      (if (cpad-hold? 0 l2)
          (set! (-> arg0 history-length) 1000)
          )
      )
    (let* ((v1-15 (-> arg0 history-length))
           (s5-0 (cond
                   ((zero? v1-15)
                    35
                    )
                   ((= v1-15 1)
                    39
                    )
                   ((= v1-15 2)
                    43
                    )
                   (else
                     256
                     )
                   )
                 )
           (v1-19 (-> arg0 history-data (-> arg0 unknown-halfword00)))
           (s1-0 (-> arg0 history-data (-> arg0 unknown-halfword00)))
           (s4-0 1)
           (s3-0 127)
           )
      (while (>= s3-0 s4-0)
        (let ((s2-0 (-> arg0 history-data (logand (+ (-> arg0 unknown-halfword00) s4-0) 127))))
          (add-debug-line
            (logtest? s5-0 2)
            (bucket-id debug-no-zbuf)
            (-> v1-19 trans)
            (-> s2-0 trans)
            (the-as rgba (+ #xffff00 (shl s4-0 24)))
            #f
            (the-as rgba -1)
            )
          (add-debug-vector
            (logtest? s5-0 4)
            (bucket-id debug-no-zbuf)
            (-> s2-0 trans)
            (-> s2-0 transv)
            (meters 0.000024414063)
            (the-as rgba (+ #x408040 (shl s4-0 24)))
            )
          (when (not (logtest? (-> s2-0 status) (cshape-moving-flags csmf08)))
            (add-debug-line
              (logtest? s5-0 1)
              (bucket-id debug-no-zbuf)
              (-> s1-0 intersect)
              (-> s2-0 intersect)
              (the-as rgba (+ #xffffff (shl s4-0 24)))
              #f
              (the-as rgba -1)
              )
            (let ((s1-1
                    (logand (the-as int (-> *pat-mode-info* (-> s2-0 pat mode) hilite-color)) (the-as uint #xffffffff00ffffff))
                    )
                  )
              (add-debug-vector
                (logtest? s5-0 32)
                (bucket-id debug-no-zbuf)
                (-> s2-0 intersect)
                (-> s2-0 surface-normal)
                (meters 1)
                (the-as rgba (+ s1-1 (shl s4-0 24)))
                )
              (add-debug-vector
                (logtest? s5-0 16)
                (bucket-id debug-no-zbuf)
                (-> s2-0 intersect)
                (-> s2-0 local-normal)
                (meters 1)
                (the-as rgba (+ s1-1 (shl s4-0 24)))
                )
              )
            (add-debug-vector
              (logtest? s5-0 8)
              (bucket-id debug-no-zbuf)
              (-> s2-0 trans)
              (-> s2-0 transv-out)
              (meters 0.000024414063)
              (the-as rgba (+ #x404080 (shl s4-0 24)))
              )
            (set! s1-0 s2-0)
            )
          (set! v1-19 s2-0)
          )
        (+! s4-0 1)
        )
      )
    #f
    )
  )

(defun-debug print-history ((arg0 control-info))
  (dotimes (s5-0 128)
    (let ((s4-0 (-> arg0 history-data (logand (+ (-> arg0 unknown-halfword00) s5-0) 127))))
      (let ((s3-0 (-> s4-0 reaction-flag)))
        (format
          #t
          "~6D ~8S #x~8X "
          (-> s4-0 time)
          (if (logtest? (-> s4-0 status) (cshape-moving-flags csmf08))
              "air"
              (-> *pat-mode-info* (-> s4-0 pat mode) name)
              )
          (-> s4-0 status)
          )
        (format
          #t
          "~C~C~C~C~C~C"
          (if (not (logtest? s3-0 (cshape-reaction-flags csrf00)))
              103
              87
              )
          (if (not (logtest? s3-0 (cshape-reaction-flags csrf01)))
              103
              87
              )
          (cond
            ((logtest? s3-0 (cshape-reaction-flags csrf11))
             71
             )
            ((not (logtest? s3-0 (cshape-reaction-flags csrf02)))
             103
             )
            (else
              87
              )
            )
          (cond
            ((logtest? s3-0 (cshape-reaction-flags csrf09))
             66
             )
            ((logtest? s3-0 (cshape-reaction-flags csrf03))
             76
             )
            (else
              99
              )
            )
          (if (not (logtest? s3-0 (cshape-reaction-flags csrf04)))
              110
              66
              )
          (if (not (logtest? s3-0 (cshape-reaction-flags csrf05)))
              103
              65
              )
          )
        (format
          #t
          "~C~C "
          (if (logtest? s3-0 (cshape-reaction-flags csrf06))
              78
              95
              )
          (cond
            ((logtest? s3-0 (cshape-reaction-flags csrf10))
             76
             )
            ((logtest? s3-0 (cshape-reaction-flags csrf08))
             67
             )
            ((logtest? s3-0 (cshape-reaction-flags csrf07))
             108
             )
            (else
              95
              )
            )
          )
        )
      (format #t "trans: ~6,,2m ~6,,2m ~6,,2m  " (-> s4-0 trans x) (-> s4-0 trans y) (-> s4-0 trans z))
      (format #t "int: ~6,,2m ~6,,2m ~6,,2m " (-> s4-0 intersect x) (-> s4-0 intersect y) (-> s4-0 intersect z))
      (format #t "vel: ~6,,2m ~6,,2m ~6,,2m " (-> s4-0 transv x) (-> s4-0 transv y) (-> s4-0 transv z))
      (format
        #t
        "vel-out: ~6,,2m ~6,,2m ~6,,2m "
        (-> s4-0 transv-out x)
        (-> s4-0 transv-out y)
        (-> s4-0 transv-out z)
        )
      (format
        #t
        "normal: ~6,,2f ~6,,2f ~6,,2f "
        (-> s4-0 surface-normal x)
        (-> s4-0 surface-normal y)
        (-> s4-0 surface-normal z)
        )
      )
    (format #t "~%")
    )
  0
  (none)
  )

;; WARN: Stack slot load at 160 mismatch: defined as size 4, got size 16
;; WARN: Stack slot load at 176 mismatch: defined as size 4, got size 16
;; WARN: Stack slot load at 160 mismatch: defined as size 4, got size 16
;; WARN: Stack slot load at 176 mismatch: defined as size 4, got size 16
(defun-debug target-print-stats ((arg0 target) (arg1 symbol))
  (local-vars
    (sv-64 string)
    (sv-80 string)
    (sv-96 string)
    (sv-112 string)
    (sv-128 string)
    (sv-144 string)
    (sv-160 float)
    (sv-176 float)
    )
  (when (and *display-ground-stats* arg0)
    (let ((s4-0 format)
          (s3-0 arg1)
          (s2-0 "~0kpoly:~6X  mode:~-8S  material:~-10S  event:~S~%")
          (s1-0 (-> arg0 control poly-pat))
          (s0-0 (pat-mode->string (-> arg0 control poly-pat)))
          )
      (set! sv-64 (pat-material->string (-> arg0 control poly-pat)))
      (let ((t1-0 (pat-event->string (-> arg0 control poly-pat))))
        (s4-0 s3-0 s2-0 s1-0 s0-0 sv-64 t1-0)
        )
      )
    (let ((s4-1 format)
          (s3-1 arg1)
          (s2-1 "~0kgrnd:~6X  mode:~-8S  material:~-10S  event:~S~%")
          (s1-1 (-> arg0 control ground-pat))
          (s0-1 (pat-mode->string (-> arg0 control ground-pat)))
          )
      (set! sv-80 (pat-material->string (-> arg0 control ground-pat)))
      (let ((t1-1 (pat-event->string (-> arg0 control ground-pat))))
        (s4-1 s3-1 s2-1 s1-1 s0-1 sv-80 t1-1)
        )
      )
    (let ((s4-2 format)
          (s3-2 arg1)
          (s2-2 "~0kwall:~6X  mode:~-8S  material:~-10S  event:~S~%")
          (s1-2 (-> arg0 control wall-pat))
          (s0-2 (pat-mode->string (-> arg0 control wall-pat)))
          )
      (set! sv-96 (pat-material->string (-> arg0 control wall-pat)))
      (let ((t1-2 (pat-event->string (-> arg0 control wall-pat))))
        (s4-2 s3-2 s2-2 s1-2 s0-2 sv-96 t1-2)
        )
      )
    )
  (when (and *stats-target* arg0)
    (format
      arg1
      "~0ks: ~M ~X/~X ~A ~A ~A~%"
      (-> arg0 control unknown-float01)
      (-> arg0 control status)
      (-> arg0 control prev-status)
      (-> arg0 state name)
      (-> arg0 control surf name)
      (-> arg0 control unknown-surface00 name)
      )
    (format
      arg1
      "~0k~9S ~9S ~9S ~9S ~9S ~9S~%"
      (if (logtest? (-> arg0 control status) (cshape-moving-flags onsurf))
          "on-surface"
          ""
          )
      (if (logtest? (-> arg0 control status) (cshape-moving-flags onground))
          "on-ground"
          ""
          )
      (if (logtest? (-> arg0 control status) (cshape-moving-flags tsurf))
          "t-surface"
          ""
          )
      (if (logtest? (-> arg0 control status) (cshape-moving-flags twall))
          "t-wall"
          ""
          )
      (if (logtest? (-> arg0 control status) (cshape-moving-flags t-act))
          "t-act"
          ""
          )
      (cond
        ((logtest? (-> arg0 control status) (cshape-moving-flags t-ciel))
         "t-ceil"
         )
        ((logtest? (-> arg0 control status) (cshape-moving-flags on-water))
         "on-water"
         )
        (else
          ""
          )
        )
      )
    (let ((v1-49 (handle->process (-> arg0 water volume))))
      (when v1-49
        (format
          arg1
          "in water ~A at ~M ~5S ~5S ~5S ~5S "
          (-> v1-49 name)
          (-> arg0 water height)
          (if (logtest? (-> arg0 water flags) (water-flags wt09))
              "water"
              ""
              )
          (if (logtest? (-> arg0 water flags) (water-flags wt10))
              "wade"
              ""
              )
          (if (logtest? (-> arg0 water flags) (water-flags wt11))
              "swim"
              ""
              )
          (if (logtest? (-> arg0 water flags) (water-flags wt12))
              "under"
              ""
              )
          )
        (format arg1 "~2S~%" (if (logtest? (-> arg0 water flags) (water-flags wt04))
                                 "sg"
                                 ""
                                 )
                )
        )
      )
    (format
      arg1
      "~0kan:~,,3f su:~,,3f ti:~,,3f to:~,,3f pa:~,,3f~%"
      (-> arg0 control surface-angle)
      (-> arg0 control unknown-float61)
      (-> arg0 control unknown-float62)
      (-> arg0 control touch-angle)
      (-> arg0 control poly-angle)
      )
    (let ((v1-74 (-> arg0 control trans)))
      (format arg1 "pos: ~6,,2m ~6,,2m ~6,,2m  " (-> v1-74 x) (-> v1-74 y) (-> v1-74 z))
      )
    (let ((s4-3 format)
          (s3-3 arg1)
          (s2-3 "~0kpol:~X/~S/~S/~S~%")
          (s1-3 (-> arg0 control poly-pat))
          (s0-3 (pat-mode->string (-> arg0 control poly-pat)))
          )
      (set! sv-112 (pat-material->string (-> arg0 control poly-pat)))
      (let ((t1-7 (pat-event->string (-> arg0 control poly-pat))))
        (s4-3 s3-3 s2-3 s1-3 s0-3 sv-112 t1-7)
        )
      )
    (let ((s4-4 format)
          (s3-4 arg1)
          (s2-4 "~0kcur:~X/~S/~S/~S   ")
          (s1-4 (-> arg0 control cur-pat))
          (s0-4 (pat-mode->string (-> arg0 control cur-pat)))
          )
      (set! sv-128 (pat-material->string (-> arg0 control cur-pat)))
      (let ((t1-8 (pat-event->string (-> arg0 control cur-pat))))
        (s4-4 s3-4 s2-4 s1-4 s0-4 sv-128 t1-8)
        )
      )
    (let ((s4-5 format)
          (s3-5 arg1)
          (s2-5 "~0kgnd:~X/~S/~S/~S~%")
          (s1-5 (-> arg0 control ground-pat))
          (s0-5 (pat-mode->string (-> arg0 control ground-pat)))
          )
      (set! sv-144 (pat-material->string (-> arg0 control ground-pat)))
      (let ((t1-9 (pat-event->string (-> arg0 control ground-pat))))
        (s4-5 s3-5 s2-5 s1-5 s0-5 sv-144 t1-9)
        )
      )
    (let ((s4-6 format)
          (s3-6 arg1)
          (s2-6 "~0kvel: x:~M  y:~M  z:~M   yv:~M  xzv:~M~%")
          (s1-6 (-> arg0 control transv x))
          (s0-6 (-> arg0 control transv y))
          )
      (set! sv-160 (-> arg0 control transv z))
      (set! sv-176 (vector-dot (-> arg0 control dynam gravity-normal) (-> arg0 control transv)))
      (let ((a0-36 (new-stack-vector0)))
        (let ((f0-17 (vector-dot (-> arg0 control dynam gravity-normal) (-> arg0 control transv))))
          0.0
          (vector-! a0-36 (-> arg0 control transv) (vector-float*! a0-36 (-> arg0 control dynam gravity-normal) f0-17))
          )
        (let ((f0-18 (vector-length a0-36)))
          f0-18
          (let ((t2-4 f0-18))
            (s4-6 s3-6 s2-6 s1-6 s0-6 sv-160 sv-176 t2-4)
            )
          )
        )
      )
    (format
      arg1
      "~0ky:~,,2M t:~d cy: ~,,2M my: ~,,2M impv:~,,2M "
      (-> arg0 control unknown-vector52 y)
      (- (-> *display* base-frame-counter) (-> arg0 control unknown-dword11))
      (- (-> arg0 control trans y) (-> arg0 control unknown-vector52 y))
      (- (-> arg0 control unknown-vector111 y) (-> arg0 control unknown-vector110 y))
      (-> arg0 control ground-impact-vel)
      )
    (format
      arg1
      "~0k~Tcd: ~,,2M md:~,,2M~%"
      (vector-xz-length (vector-! (new-stack-vector0) (-> arg0 control trans) (-> arg0 control unknown-vector52)))
      (vector-xz-length
        (vector-! (new-stack-vector0) (-> arg0 control unknown-vector111) (-> arg0 control unknown-vector110))
        )
      )
    (format
      arg1
      "~0kbend b:~F t:~F s:~F~%"
      (-> arg0 control unknown-float80)
      (-> arg0 control unknown-float81)
      (-> arg0 control unknown-float82)
      )
    (debug-print-channels (-> arg0 skel) arg1)
    )
  (draw-history (-> arg0 control))
  #f
  )

(defbehavior read-pad target ((arg0 vector))
  (when (!= (-> self control unknown-dword00) (-> *display* real-frame-counter))
    (set! (-> self control unknown-vector31 quad) (-> self control unknown-vector30 quad))
    (set! (-> self control unknown-float21) (-> self control unknown-float20))
    (set! (-> self control unknown-dword00) (the-as uint (-> *display* real-frame-counter)))
    )
  (set! (-> arg0 x) (sin (-> self control unknown-cpad-info00 stick0-dir)))
  (set! (-> arg0 y) 0.0)
  (set! (-> arg0 z) (cos (-> self control unknown-cpad-info00 stick0-dir)))
  (set! (-> arg0 w) 0.0)
  (set! (-> self control unknown-vector30 quad) (-> arg0 quad))
  (set! (-> self control unknown-float20) (-> self control unknown-cpad-info00 stick0-speed))
  (vector-matrix*! arg0 arg0 (matrix-local->world #t #f))
  )

(defun warp-vector-into-surface! ((arg0 vector) (arg1 vector) (arg2 vector))
  (let ((a2-2 (matrix-from-two-vectors! (new-stack-matrix0) (-> (matrix-local->world #t #f) vector 1) arg2)))
    (vector-matrix*! arg0 arg1 a2-2)
    )
  )

(defbehavior vector<-pad-in-surface! target ((arg0 vector) (arg1 symbol))
  (let ((a1-1 (read-pad (new-stack-vector0))))
    (warp-vector-into-surface! arg0 a1-1 (-> self control local-normal))
    )
  (if arg1
      (vector-float*! arg0 arg0 (-> self control unknown-float20))
      )
  arg0
  )

(defbehavior local-pad-angle target ()
  (let ((a0-1 (vector<-pad-in-surface! (new-stack-vector0) #f)))
    (vector-dot
      (vector-normalize! a0-1 1.0)
      (vector-z-quaternion! (new-stack-vector0) (-> self control unknown-quaternion00))
      )
    )
  )

(defbehavior turn-around? target ()
  (let* ((a0-1 (vector<-pad-in-surface! (new-stack-vector0) #f))
         (gp-0 (vector-normalize! a0-1 1.0))
         (t9-2 vector-normalize!)
         (a0-2 (new-stack-vector0))
         )
    (set! (-> a0-2 quad) (-> self control transv quad))
    (let ((f0-1 (vector-dot gp-0 (t9-2 a0-2 1.0)))
          (a1-3 (-> self control unknown-vector-array10))
          (f2-0 -1000.0)
          (f1-0 0.0)
          (a0-3 -1)
          (v1-6 (new 'static 'array uint64 1 #x0))
          )
      (countdown (a2-0 15)
        (let ((a3-2 (-> a1-3 a2-0 quad)))
          (set! (-> a1-3 (+ a2-0 1) quad) a3-2)
          )
        )
      (set! (-> a1-3 0 quad) (-> self control transv quad))
      (set! (-> a1-3 0 w) (-> self control unknown-float01))
      (dotimes (a2-6 16)
        (+! f1-0 (-> a1-3 a2-6 w))
        (when (< f2-0 (-> a1-3 a2-6 w))
          (set! a0-3 a2-6)
          (set! f2-0 (-> a1-3 a2-6 w))
          )
        )
      (let ((f1-1 (* 0.0625 f1-0)))
        (set! (-> self control unknown-int10) a0-3)
        (set! (-> self control unknown-float100) f1-1)
        (if (logtest? (-> self control unknown-surface01 flags) (surface-flags no-turn-around))
            (set! (-> v1-6 0) (the-as uint (-> *display* base-frame-counter)))
            )
        (and (>= (the-as uint (- (-> *display* base-frame-counter) (the-as int (-> v1-6 0)))) (the-as uint 300))
             (< f0-1 0.0)
             (< 32768.0 f1-1)
             (< 0.7 (-> self control unknown-float20))
             (>= (- (-> *display* base-frame-counter) (-> self control unknown-dword20)) (seconds 0.3))
             (>= (- (-> *display* base-frame-counter) (-> self control unknown-dword21)) (seconds 0.3))
             (logtest? (-> self control status) (cshape-moving-flags onsurf))
             (and (< 0.7 (-> self control surface-angle)) #t)
             )
        )
      )
    )
  )

(defbehavior target-move-dist target ((arg0 time-frame))
  (let ((s5-0 (new-stack-vector0))
        (f30-0 0.0)
        (gp-0 0)
        )
    (let* ((v1-0 127)
           (a1-6 (-> self control history-data (logand (+ (-> self control unknown-halfword00) v1-0) 127)))
           )
      (while (and (< (- (-> *display* base-frame-counter) (-> a1-6 time)) arg0) (> v1-0 0))
        (vector+! s5-0 s5-0 (-> a1-6 trans))
        (+! gp-0 1)
        (+! v1-0 -1)
        (set! a1-6 (-> self control history-data (logand (+ (-> self control unknown-halfword00) v1-0) 127)))
        )
      )
    (vector-float/! s5-0 s5-0 (the float gp-0))
    (let ((s4-0 (- 128 gp-0)))
      (while (< s4-0 128)
        (let ((v1-9 (-> self control history-data (logand (+ (-> self control unknown-halfword00) s4-0) 127))))
          (+! f30-0 (vector-vector-distance s5-0 (-> v1-9 trans)))
          )
        (+! s4-0 1)
        )
      )
    (/ f30-0 (the float gp-0))
    )
  )

(defbehavior turn-to-vector target ((arg0 vector) (arg1 float))
  (let ((gp-0 (new-stack-vector0)))
    (warp-vector-into-surface! gp-0 arg0 (-> self control local-normal))
    (set! (-> self control unknown-float13) (-> self control unknown-float12))
    (set! (-> self control unknown-float11) (-> self control unknown-float10))
    (set! (-> self control unknown-vector21 quad) (-> self control unknown-vector20 quad))
    (set! (-> self control unknown-vector23 quad) (-> self control unknown-vector22 quad))
    (vector-float*! (-> self control unknown-vector22) gp-0 arg1)
    (if (< 0.0 arg1)
        (warp-vector-into-surface! (-> self control unknown-vector20) arg0 *up-vector*)
        )
    (dotimes (v1-15 7)
      (set! (-> self control unknown-vector-array00 (+ v1-15 1) quad)
            (-> self control unknown-vector-array00 v1-15 quad)
            )
      )
    (set! (-> self control unknown-vector-array00 0 quad)
          (-> (vector-matrix*! gp-0 gp-0 (-> self control unknown-matrix00)) quad)
          )
    (let ((f0-6 (atan (-> gp-0 x) (-> gp-0 z))))
      (set! (-> self control unknown-float12) arg1)
      (set! (-> self control unknown-float10) f0-6)
      )
    (let ((f0-8 (* arg1 (-> self control unknown-surface01 target-speed))))
      (set! (-> self control unknown-vector01 quad) (-> (vector-normalize! gp-0 f0-8) quad))
      )
    )
  (let ((gp-1 (new-stack-vector0)))
    (vector-matrix*! gp-1 (-> self control unknown-vector01) (-> self control unknown-matrix01))
    (vector-float*! gp-1 gp-1 0.5)
    (vector+! gp-1 gp-1 (-> self control trans))
    (add-debug-text-sphere
      *display-target-marks*
      (bucket-id debug-no-zbuf)
      gp-1
      819.2
      "target"
      (new 'static 'rgba :r #xff :g #xff :a #x80)
      )
    )
  )

(defbehavior add-thrust target ()
  (let ((s5-0 (-> self control unknown-vector01))
        (gp-0 (-> self control unknown-vector00))
        )
    (let ((s4-0 (new 'stack-no-clear 'vector)))
      (set! (-> s4-0 quad) (-> self control unknown-vector01 quad))
      (let* ((a1-2 (vector-flatten!
                     (new 'stack-no-clear 'vector)
                     (vector-negate! (new-stack-vector0) (-> self control dynam gravity-normal))
                     (-> self control local-normal)
                     )
                   )
             (s1-0 (vector-matrix*! (new 'stack-no-clear 'vector) a1-2 (-> self control unknown-matrix00)))
             (s3-1 (vector-normalize-copy! (new 'stack-no-clear 'vector) s1-0 1.0))
             )
        (vector+float*! s5-0 s5-0 s1-0 (-> self control unknown-surface01 slide-factor))
        (let ((s2-1 (-> self control unknown-vector60)))
          (when (not (or (= (- 1.0 (-> self control unknown-surface01 slope-up-traction)) 0.0) (< (vector-length s1-0) 0.1)))
            (let* ((s1-1 (vector-matrix*! (new 'stack-no-clear 'vector) s2-1 (-> self control unknown-matrix00)))
                   (s2-2 (new-stack-vector0))
                   (f30-0 (vector-dot s1-1 s5-0))
                   )
              0.0
              (vector-! s2-2 s5-0 (vector-float*! s2-2 s1-1 f30-0))
              (let* ((f0-7 (vector-length s2-2))
                     (f1-3 f0-7)
                     )
                (if (< f30-0 0.0)
                    (set! f30-0 (* f30-0 (-> self control unknown-surface01 slope-up-traction)))
                    )
                (let ((f2-3 (+ f30-0 (-> self control unknown-surface01 slope-down-factor))))
                  (vector+! s5-0 (vector-float*! s5-0 s1-1 f2-3) (vector-float*! s2-2 s2-2 (/ f0-7 f1-3)))
                  )
                )
              )
            )
          )
        (let ((t9-8 vector-xz-normalize!)
              (a0-13 (new-stack-vector0))
              )
          (set! (-> a0-13 quad) (-> s5-0 quad))
          (let ((v1-31 (t9-8 a0-13 1.0)))
            (set! (-> v1-31 y) 0.0)
            (let ((f30-1 (vector-dot s3-1 v1-31))
                  (f0-11 (vector-xz-length s5-0))
                  )
              (if (< 0.0 f30-1)
                  (vector-xz-normalize! s5-0 (+ f0-11 (* f30-1 (-> self control unknown-surface01 slope-down-factor))))
                  (vector-xz-normalize! s5-0 (- f0-11 (* f30-1 f30-1 (-> self control unknown-surface01 slope-up-factor))))
                  )
              )
            )
          )
        )
      (let ((t9-12 vector-xz-normalize!)
            (a0-17 (new-stack-vector0))
            )
        (set! (-> a0-17 quad) (-> s5-0 quad))
        (let ((s3-2 (t9-12 a0-17 1.0)))
          (let ((t9-13 vector-xz-normalize!)
                (a0-18 (new-stack-vector0))
                )
            (set! (-> a0-18 quad) (-> gp-0 quad))
            (let ((v1-43 (t9-13 a0-18 1.0)))
              (set! (-> s3-2 y) 0.0)
              (set! (-> v1-43 y) 0.0)
              )
            )
          (let* ((f30-2 (-> s3-2 z))
                 (f30-4 (cond
                          ((>= (vector-xz-length gp-0) (vector-xz-length s5-0))
                           (* (-> self control unknown-surface01 fric)
                              (fmax 1.0 (/ (vector-xz-length gp-0) (-> self control unknown-surface01 nonlin-fric-dist)))
                              )
                           )
                          ((>= f30-2 0.0)
                           (+ (* f30-2 (-> self control unknown-surface01 seek0))
                              (* (- 1.0 f30-2) (-> self control unknown-surface01 seek90))
                              )
                           )
                          (else
                            (+ (* (fabs f30-2) (-> self control unknown-surface01 seek180))
                               (* (+ 1.0 f30-2) (-> self control unknown-surface01 seek90))
                               )
                            )
                          )
                        )
                 )
            (let* ((s2-3 (-> self control unknown-vector61))
                   (s3-3 (vector-matrix*! (new 'stack-no-clear 'vector) s2-3 (-> self control unknown-matrix00)))
                   )
              (if (< (-> s4-0 x) 0.0)
                  (set! (-> s3-3 x) (fmax (fmin 0.0 (-> s3-3 x)) (-> s4-0 x)))
                  (set! (-> s3-3 x) (fmax 0.0 (fmin (-> s3-3 x) (-> s4-0 x))))
                  )
              (if (< (-> s4-0 y) 0.0)
                  (set! (-> s3-3 y) (fmax (fmin 0.0 (-> s3-3 y)) (-> s4-0 y)))
                  (set! (-> s3-3 y) (fmax 0.0 (fmin (-> s3-3 y) (-> s4-0 y))))
                  )
              (if (< (-> s4-0 z) 0.0)
                  (set! (-> s3-3 z) (fmax (fmin 0.0 (-> s3-3 z)) (-> s4-0 z)))
                  (set! (-> s3-3 z) (fmax 0.0 (fmin (-> s3-3 z) (-> s4-0 z))))
                  )
              (if (< 0.2 (-> self control unknown-float70))
                  (vector-seek! s3-3 s4-0 (* 122880.0 (-> *display* seconds-per-frame)))
                  )
              (vector-matrix*! s2-3 s3-3 (-> self control unknown-matrix01))
              (let ((f28-2 (vector-vector-xz-distance s3-3 s4-0)))
                (when (and (not (logtest? (-> self control status) (cshape-moving-flags tsurf)))
                           (< (vector-xz-length gp-0) (vector-xz-length s3-3))
                           )
                  (let ((f0-50 (lerp-scale 163840.0 0.0 f28-2 0.0 20480.0)))
                    (if (and (< f28-2 20480.0) (< (-> s4-0 z) 0.0))
                        (set! f0-50 (* 2.0 f0-50))
                        )
                    (+! f30-4 f0-50)
                    )
                  )
                )
              )
            (if (and (not (logtest? (-> self control status) (cshape-moving-flags twall)))
                     (logtest? (-> self control old-status) (cshape-moving-flags twall))
                     (logtest? (-> self control unknown-surface00 flags) (surface-flags jump))
                     (< 0.0 (-> gp-0 y))
                     (< 0.0 (vector-dot
                              (-> self control dynam gravity-normal)
                              (vector-!
                                (new 'stack-no-clear 'vector)
                                (the-as vector (-> self control unknown-sphere-array00 1 prim-core))
                                (-> self control unknown-vector70)
                                )
                              )
                        )
                     )
                (set! (-> self control unknown-dword70) (-> *display* base-frame-counter))
                )
            (if (< (- (-> *display* base-frame-counter) (-> self control unknown-dword70)) (seconds 0.2))
                (set! f30-4 (+ 204800.0 f30-4))
                )
            (if (and (not (logtest? (-> self control status) (cshape-moving-flags twall)))
                     (and (logtest? (-> self control old-status) (cshape-moving-flags twall))
                          (logtest? (-> self control unknown-surface00 flags) (surface-flags jump))
                          (< 0.0 (-> gp-0 y))
                          (< (-> gp-0 z) 0.0)
                          )
                     )
                (set! (-> gp-0 z) 0.0)
                )
            (let ((s4-2 (vector-! (new-stack-vector0) s5-0 gp-0)))
              (let ((f30-5 (* f30-4 (-> *display* seconds-per-frame))))
                (set! (-> s4-2 y) 0.0)
                (if (< f30-5 (vector-xz-length s4-2))
                    (vector-xz-normalize! s4-2 f30-5)
                    )
                )
              (vector+! gp-0 gp-0 s4-2)
              )
            )
          )
        )
      )
    (set! (-> self control unknown-float02) (vector-length gp-0))
    )
  (let ((gp-1 (new-stack-vector0)))
    (vector-matrix*! gp-1 (-> self control unknown-vector00) (-> self control unknown-matrix01))
    (vector-float*! gp-1 gp-1 0.5)
    (vector+! gp-1 gp-1 (-> self control trans))
    (add-debug-text-sphere
      *display-target-marks*
      (bucket-id debug-no-zbuf)
      gp-1
      819.2
      "ltransv"
      (new 'static 'rgba :g #xff :a #x80)
      )
    (set! (-> gp-1 quad) (-> self control unknown-vector61 quad))
    (vector-float*! gp-1 gp-1 0.5)
    (vector+! gp-1 gp-1 (-> self control trans))
    (add-debug-text-sphere
      *display-target-marks*
      (bucket-id debug-no-zbuf)
      gp-1
      819.2
      "btransv"
      (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
      )
    )
  )

(defbehavior add-gravity target ()
  (let ((s5-0 (new-stack-vector0))
        (gp-0 (new-stack-vector0))
        )
    (compute-acc-due-to-gravity (-> self control) s5-0 (-> self control unknown-surface01 slip-factor))
    (vector-matrix*! gp-0 s5-0 (-> self control unknown-matrix00))
    (vector-v++! (-> self control unknown-vector00) gp-0)
    )
  (let* ((s5-1 (vector-matrix*!
                 (new-stack-vector0)
                 (-> self control dynam gravity-normal)
                 (-> self control unknown-matrix00)
                 )
               )
         (gp-1 (new-stack-vector0))
         (f30-0 (vector-dot s5-1 (-> self control unknown-vector00)))
         )
    0.0
    (vector-! gp-1 (-> self control unknown-vector00) (vector-float*! gp-1 s5-1 f30-0))
    (let* ((f0-4 (vector-length gp-1))
           (f1-0 f0-4)
           )
      (if (< f0-4 0.00004096)
          (set! f0-4 0.0)
          )
      (if (< f30-0 (- (-> self control dynam gravity-max)))
          (set! f30-0 (- (-> self control dynam gravity-max)))
          )
      (vector+!
        (-> self control unknown-vector00)
        (vector-float*! (-> self control unknown-vector00) s5-1 f30-0)
        (vector-float*! gp-1 gp-1 (/ f0-4 f1-0))
        )
      )
    )
  )

(defbehavior target-compute-slopes target ((arg0 vector))
  (let ((gp-0 (new-stack-vector0)))
    (let ((a1-0 (new-stack-vector0))
          (s5-0 (new 'stack-no-clear 'matrix))
          )
      (set! (-> a1-0 quad) (-> self control unknown-matrix01 vector 2 quad))
      (forward-up-nopitch->inv-matrix s5-0 a1-0 arg0)
      (set-vector! gp-0 0.0 0.0 1.0 1.0)
      (vector-matrix*! gp-0 gp-0 s5-0)
      (set! (-> self control unknown-float63) (- (vector-dot (-> self control surface-normal) gp-0)))
      (set! (-> self control unknown-float61) (- (vector-dot (-> self control local-normal) gp-0)))
      (set-vector! gp-0 1.0 0.0 0.0 1.0)
      (vector-matrix*! gp-0 gp-0 s5-0)
      )
    (set! (-> self control unknown-float64) (- (vector-dot (-> self control surface-normal) gp-0)))
    (set! (-> self control unknown-float62) (- (vector-dot (-> self control local-normal) gp-0)))
    )
  0
  )

(defbehavior do-rotations1 target ()
  (rotate-toward-orientation!
    (-> self control)
    (-> self control dir-targ)
    0.0
    (-> self control unknown-surface01 tiltv)
    )
  )

(defbehavior do-rotations2 target ()
  (let ((gp-0 (vector-z-quaternion! (new-stack-vector0) (-> self control dir-targ)))
        (s5-0
          (if (and (or (not (logtest? (logior (-> self control status) (-> self control old-status)) (cshape-moving-flags onsurf tsurf))
                            )
                       (< (- (-> *display* base-frame-counter) (-> self control unknown-dword20)) (seconds 0.5))
                       (!= (-> self next-state name) 'target-walk)
                       (< (- (-> *display* base-frame-counter) (-> self state-time)) (seconds 0.5))
                       (< (- (-> *display* base-frame-counter) (-> self control unknown-dword21)) (seconds 0.5))
                       (logtest? (-> self control unknown-surface01 flags) (surface-flags no-rotate-toward-transv))
                       (!= (-> self control unknown-float41) 0.0)
                       )
                   (not (logtest? (-> self control unknown-surface01 flags) (surface-flags always-rotate-toward-transv)))
                   )
              (-> self control unknown-vector20)
              (-> self control transv)
              )
          )
        )
    (let* ((s3-0 (-> self control unknown-vector02))
           (s4-0 (forward-up-nopitch->quaternion (new-stack-quaternion0) gp-0 s3-0))
           (s3-1 (forward-up-nopitch->quaternion (new-stack-quaternion0) s5-0 s3-0))
           (f0-2 (acos (vector-dot gp-0 s5-0)))
           (f1-2 (* (-> self control unknown-surface01 turnvv) (-> *display* seconds-per-frame)))
           )
      (quaternion-slerp! (-> self control dir-targ) s4-0 s3-1 (cond
                                                                ((>= 0.0 (-> self control unknown-float12))
                                                                 0.0
                                                                 )
                                                                ((< f0-2 f1-2)
                                                                 1.0
                                                                 )
                                                                (else
                                                                  (/ f1-2 f0-2)
                                                                  )
                                                                )
                         )
      )
    (add-debug-vector
      *display-target-marks*
      (bucket-id debug-no-zbuf)
      (-> self control trans)
      gp-0
      (meters 2)
      (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
      )
    (add-debug-vector
      *display-target-marks*
      (bucket-id debug-no-zbuf)
      (-> self control trans)
      s5-0
      (meters 2)
      (new 'static 'rgba :r #xff :a #x80)
      )
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id debug-no-zbuf)
    (-> self control trans)
    (-> self control unknown-matrix01 vector 2)
    (meters 2)
    (new 'static 'rgba :r #xff :b #xff :a #x80)
    )
  (rotate-toward-orientation!
    (-> self control)
    (-> self control dir-targ)
    (-> self control unknown-surface01 turnv)
    0.0
    )
  (quaternion-slerp!
    (-> self control quat)
    (-> self control unknown-quaternion00)
    (-> self control unknown-quaternion01)
    (-> self control unknown-float00)
    )
  (target-compute-slopes (-> self control dynam gravity-normal))
  )

(defbehavior level-setup target ()
  (let ((gp-0 (-> self current-level)))
    (set! (-> self current-level) (level-get-target-inside *level*))
    (if (and (-> self current-level) (>= (-> *level-task-data-remap* length) (-> self current-level info index)))
        (+! (-> *game-info* in-level-time (-> *level-task-data-remap* (+ (-> self current-level info index) -1)))
            (- (-> *display* base-frame-counter) (-> *display* old-base-frame-counter))
            )
        )
    (if (and (or (not gp-0) (!= (-> gp-0 name) (-> self current-level name))) (-> self current-level))
        (send-event self 'level-enter (-> self current-level name))
        )
    )
  0
  (none)
  )

(defbehavior flag-setup target ()
  (level-setup)
  (set! (-> self control unknown-vector10 quad) (-> self control transv quad))
  ((-> self control unknown-surface01 active-hook))
  (cond
    ((logtest? (-> self control status) (cshape-moving-flags onsurf))
     (set! (-> self control unknown-dword11) (-> *display* base-frame-counter))
     (set! (-> self control unknown-vector52 quad) (-> self control trans quad))
     (if (and (>= (-> self control coverage) 1.0)
              (not (logtest? (-> self control status) (cshape-moving-flags t-act on-water)))
              (logtest? (-> self control status) (cshape-moving-flags onground))
              )
         (set! (-> self control last-known-safe-ground quad) (-> self control trans quad))
         )
     ((-> self control unknown-surface01 touch-hook))
     )
    (else
      (let ((v1-25 (-> self control trans)))
        (when (logtest? (-> self control old-status) (cshape-moving-flags onsurf))
          (set! (-> self control unknown-vector110 quad) (-> self control unknown-vector52 quad))
          (set! (-> self control unknown-vector111 quad) (-> self control unknown-vector52 quad))
          )
        (set! (-> self control unknown-vector111 x) (-> v1-25 x))
        (set! (-> self control unknown-vector111 z) (-> v1-25 z))
        (if (< (vector-dot
                 (-> self control dynam gravity-normal)
                 (vector-! (new 'stack-no-clear 'vector) (-> self control unknown-vector111) v1-25)
                 )
               0.0
               )
            (set! (-> self control unknown-vector111 y) (-> v1-25 y))
            )
        )
      )
    )
  (when (and (cpad-pressed? (-> self control unknown-cpad-info00 number) triangle)
             (zero? (-> self control unknown-int40))
             (not (logtest? (-> *kernel-context* prevent-from-run) (process-mask movie)))
             )
    (if (and (= (-> self cam-user-mode) 'normal)
             (logtest? (-> self control unknown-surface00 flags) (surface-flags allow-look-around))
             (not (logtest? (-> self control root-prim prim-core action) 
                            (collide-action edgegrab-cam swingpole-active racer snowball tube flut)
                            )
                  )
             (-> *setting-control* current allow-look-around)
             (>= (- (-> *display* base-frame-counter) (-> self no-look-around-wait)) (seconds 0.05))
             (not (and (= (-> self control ground-pat material) (pat-material ice))
                       (< 4096.0 (-> self control unknown-float01))
                       )
                  )
             )
        (send-event self 'change-mode 'look-around)
        )
    )
  (when (and (= *cheat-mode* 'debug)
             (cpad-hold? (-> self control unknown-cpad-info00 number) r2)
             (not *pause-lock*)
             (not (logtest? (-> self state-flags) (state-flags grabbed first-person-mode)))
             )
    (if (!= (-> self next-state name) 'target-falling)
        (send-event self 'change-mode 'falling)
        )
    (let ((gp-0 (new-stack-vector0)))
      (let ((f0-8 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
        0.0
        (vector-! gp-0 (-> self control transv) (vector-float*! gp-0 (-> self control dynam gravity-normal) f0-8))
        )
      (let* ((f0-9 (vector-length gp-0))
             (f1-4 f0-9)
             (f2-0 0.0)
             )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-0)
          (vector-float*! gp-0 gp-0 (/ f0-9 f1-4))
          )
        )
      )
    (let ((gp-1 (new 'stack-no-clear 'vector)))
      (set! (-> gp-1 quad) (-> self control trans quad))
      (let ((s5-0 (new-stack-vector0))
            (f30-0 (vector-dot (-> self control dynam gravity-normal) gp-1))
            )
        0.0
        (vector-! s5-0 gp-1 (vector-float*! s5-0 (-> self control dynam gravity-normal) f30-0))
        (let* ((f0-14 (vector-length s5-0))
               (f1-5 f0-14)
               (f2-2 (+ 512.0 f30-0))
               )
          (vector+!
            gp-1
            (vector-float*! gp-1 (-> self control dynam gravity-normal) f2-2)
            (vector-float*! s5-0 s5-0 (/ f0-14 f1-5))
            )
          )
        )
      (move-to-point! (-> self control) gp-1)
      )
    (send-event *camera* 'reset-follow)
    (set! (-> self control surf) *standard-ground-surface*)
    )
  (let ((f0-17 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
    (if (and (or (logtest? (-> self control unknown-surface01 flags) (surface-flags allow-edge-grab))
                 (and (= (-> self next-state name) 'target-walk)
                      (not (logtest? (-> self control status) (cshape-moving-flags onsurf)))
                      )
                 )
             (< f0-17 0.0)
             (or (not (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control unknown-cpad-info00 number) r2)))
                 *pause-lock*
                 )
             (and (>= (vector-dot
                        (-> self control dynam gravity-normal)
                        (vector-! (new 'stack-no-clear 'vector) (-> self control trans) (-> self control shadow-pos))
                        )
                      9420.8
                      )
                  (not (logtest? (-> self control root-prim prim-core action) (collide-action racer flut)))
                  #t
                  )
             )
        (logior! (-> self control root-prim prim-core action) (collide-action edgegrab-possible))
        (logclear! (-> self control root-prim prim-core action) (collide-action edgegrab-possible))
        )
    )
  (let ((v1-146 (-> self current-level)))
    (if (and (>= (- (-> *display* base-frame-counter) (-> self control unknown-dword11)) (seconds 2))
             (and v1-146
                  (< (-> self control trans y) (-> v1-146 info bottom-height))
                  (not (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control unknown-cpad-info00 number) r2)))
                  )
             )
        (send-event self 'attack-invinc #f (static-attack-info ((mode 'endlessfall))))
        )
    )
  0
  (none)
  )

(defbehavior post-flag-setup target ()
  (if (logtest? (-> self control status) (cshape-moving-flags twall t-act))
      (set! (-> self control unknown-dword20) (-> *display* base-frame-counter))
      )
  (when (logtest? (-> self state-flags) (state-flags timed-invulnerable))
    ;; changed for high fps. This fixes the flicker speed when damaged
    (if (< (logand (- (-> *display* base-frame-counter) (-> self control unknown-dword80)) 3) (/ 1.0 (-> *display* time-adjust-ratio)))
        (logior! (-> self draw status) (draw-status hidden))
        (logclear! (-> self draw status) (draw-status hidden))
        )
    (if (>= (- (-> *display* base-frame-counter) (-> self control unknown-dword80)) (-> self control unknown-dword81))
        (target-timed-invulnerable-off self)
        )
    )
  (set! (-> self control unknown-symbol40) #f)
  0
  (none)
  )

(defbehavior bend-gravity target ()
  (set! (-> self control unknown-float82) (if (logtest? (-> self control status) (cshape-moving-flags onsurf))
                                              32.0
                                              2.0
                                              )
        )
  (let ((f0-2
          (if (and (logtest? (-> self control status) (cshape-moving-flags twall))
                   (not (logtest? (-> self control status) (cshape-moving-flags onsurf)))
                   )
              0.0
              (-> self control unknown-float81)
              )
          )
        )
    (seek!
      (-> self control unknown-float80)
      f0-2
      (* (-> self control unknown-float82) (-> *display* seconds-per-frame))
      )
    )
  (vector-deg-slerp
    (-> self control dynam gravity-normal)
    (-> self control unknown-dynamics00 gravity-normal)
    (-> self control ground-poly-normal)
    (-> self control unknown-float80)
    )
  (vector-float*!
    (-> self control dynam gravity)
    (-> self control dynam gravity-normal)
    (the-as float (-> self control dynam gravity-length))
    )
  (set! (-> self control dynam gravity-normal quad) (-> self control unknown-dynamics00 gravity-normal quad))
  (vector-float*!
    (-> self control dynam gravity)
    (-> self control dynam gravity-normal)
    (the-as float (-> self control dynam gravity-length))
    )
  (vector-deg-slerp
    (-> self control unknown-vector02)
    (-> self control unknown-dynamics00 gravity-normal)
    (-> self control ground-poly-normal)
    (-> self control unknown-float80)
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id debug-no-zbuf)
    (-> self control trans)
    (-> self control ground-poly-normal)
    (meters 2)
    (new 'static 'rgba :b #xff :a #x80)
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id debug-no-zbuf)
    (-> self control trans)
    (-> self control local-normal)
    (meters 2)
    (new 'static 'rgba :b #xff :a #x80)
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id debug-no-zbuf)
    (-> self control trans)
    (-> self control unknown-dynamics00 gravity-normal)
    (meters 2.5)
    (new 'static 'rgba :r #xff :a #x80)
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id debug-no-zbuf)
    (-> self control trans)
    (-> self control dynam gravity-normal)
    (meters 3)
    (new 'static 'rgba :r #xff :b #xff :a #x80)
    )
  )

(defbehavior target-compute-edge target ()
  (let ((s5-0 *edge-grab-info*))
    (if (not (edge-grab-info-method-9 s5-0))
        (send-event self 'end-mode)
        )
    (if *display-edge-collision-marks*
        (debug-draw s5-0)
        )
    (set! (-> self control ground-pat) (the-as pat-surface (-> s5-0 edge-tri-pat)))
    (vector-normalize!
      (vector-! (-> self control unknown-vector100) (the-as vector (-> s5-0 world-vertex)) (-> s5-0 world-vertex 1))
      1.0
      )
    (let ((gp-1 (vector-cross!
                  (-> self control unknown-vector101)
                  (-> self control unknown-vector100)
                  (-> self control dynam gravity-normal)
                  )
                )
          )
      (let ((s4-1 (vector-! (new-stack-vector0) (-> s5-0 center-hold) (-> self control unknown-vector90))))
        (set! (-> self control unknown-float110) (vector-length s4-1))
        (cond
          ((and (< 819.2 (-> self control unknown-float110))
                (>= (- (-> *display* base-frame-counter) (-> self control unknown-dword40)) (seconds 0.2))
                )
           (vector-normalize! s4-1 1228.8)
           (move-by-vector! (-> self control) s4-1)
           (vector-float*! (-> self control rider-last-move) s4-1 (-> *display* frames-per-second))
           (set! (-> self control rider-time) (-> *display* base-frame-counter))
           (if (and (>= (- (-> *display* base-frame-counter) (-> self control unknown-dword41)) (seconds 0.5))
                    (>= (- (-> *display* base-frame-counter) (-> self control unknown-dword40)) (seconds 0.5))
                    )
               (send-event self 'end-mode)
               )
           )
          (else
            (let ((a1-6 (new 'stack-no-clear 'vector)))
              (vector-! a1-6 (-> s5-0 center-hold) (-> self control unknown-vector91))
              (vector-float*! (-> self control rider-last-move) s4-1 (-> *display* frames-per-second))
              (set! (-> self control rider-time) (-> *display* base-frame-counter))
              (move-to-point! (-> self control) a1-6)
              )
            (set! (-> self control unknown-float110) 0.0)
            (set! (-> self control unknown-vector52 quad) (-> self control trans quad))
            (set! (-> self control unknown-dword40) (-> *display* base-frame-counter))
            )
          )
        )
      (forward-up-nopitch->quaternion (-> self control dir-targ) gp-1 (-> self control dynam gravity-normal))
      )
    )
  (set-quaternion! (-> self control) (-> self control dir-targ))
  (do-joint-math! self)
  (none)
  )

(defbehavior target-compute-edge-rider target ()
  (let ((gp-0 *edge-grab-info*))
    (if (not (edge-grab-info-method-9 gp-0))
        (send-event self 'end-mode)
        )
    (if *display-edge-collision-marks*
        (debug-draw gp-0)
        )
    (vector-normalize!
      (vector-! (-> self control unknown-vector100) (the-as vector (-> gp-0 world-vertex)) (-> gp-0 world-vertex 1))
      1.0
      )
    (vector-cross!
      (-> self control unknown-vector101)
      (-> self control unknown-vector100)
      (-> self control dynam gravity-normal)
      )
    (let ((a1-7 (vector-! (new-stack-vector0) (-> gp-0 center-hold) (-> gp-0 center-hold-old))))
      (vector-float*! (-> self control rider-last-move) a1-7 (-> *display* frames-per-second))
      (set! (-> self control rider-time) (-> *display* base-frame-counter))
      (move-by-vector! (-> self control) a1-7)
      )
    )
  (set! (-> self control unknown-float110) 0.0)
  (do-joint-math! self)
  (none)
  )

(defbehavior target-compute-pole target ()
  (let* ((s4-0 (handle->process (-> self control unknown-handle10)))
         (gp-0 (-> (the-as swingpole s4-0) dir))
         )
    (set! (-> self control unknown-vector100 quad) (-> gp-0 quad))
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (let ((s3-0 (vector+float*!
                    (new 'stack-no-clear 'vector)
                    (-> (the-as swingpole s4-0) root trans)
                    gp-0
                    (-> (the-as swingpole s4-0) edge-length)
                    )
                  )
            (s2-0 (vector+float*!
                    (new 'stack-no-clear 'vector)
                    (-> (the-as swingpole s4-0) root trans)
                    gp-0
                    (- (-> (the-as swingpole s4-0) edge-length))
                    )
                  )
            )
        (let ((v1-8 (new 'stack-no-clear 'vector)))
          (vector+! v1-8 s3-0 s2-0)
          (vector-float*! v1-8 v1-8 0.5)
          (set! (-> v1-8 y) (+ -6144.0 (-> v1-8 y)))
          (send-event *camera* 'ease-in 0.5 v1-8)
          )
        (vector-segment-distance-point! (-> self control unknown-vector90) s3-0 s2-0 s5-0)
        (when *display-edge-collision-marks*
          (add-debug-vector
            #t
            (bucket-id debug-no-zbuf)
            (-> (the-as swingpole s4-0) root trans)
            (the-as vector (&-> s4-0 stack 16))
            (meters 3)
            (new 'static 'rgba :r #xff :b #xff :a #x80)
            )
          (add-debug-sphere
            #t
            (bucket-id debug-no-zbuf)
            (-> (the-as swingpole s4-0) root trans)
            (-> (the-as swingpole s4-0) range)
            (new 'static 'rgba :r #xff :g #xff :a #x80)
            )
          (add-debug-sphere
            #t
            (bucket-id debug)
            (-> self control unknown-vector90)
            819.2
            (new 'static 'rgba :r #xff :a #x80)
            )
          (add-debug-sphere #t (bucket-id debug-no-zbuf) s3-0 819.2 (new 'static 'rgba :g #xff :a #x80))
          (add-debug-sphere #t (bucket-id debug-no-zbuf) s2-0 819.2 (new 'static 'rgba :g #xff :b #x40 :a #x80))
          (add-debug-sphere #t (bucket-id debug-no-zbuf) s5-0 819.2 (new 'static 'rgba :b #xff :a #x80))
          )
        )
      (let ((s4-2 (vector-! (new-stack-vector0) s5-0 (-> self control unknown-vector90))))
        (cond
          ((and (< 2457.6 (vector-length s4-2)) (not (-> self control unknown-int21)))
           (move-by-vector! (-> self control) (vector-normalize! s4-2 2457.6))
           )
          (else
            (set! (-> self control unknown-int21) (the-as int #t))
            (move-to-point!
              (-> self control)
              (vector-! (new 'stack-no-clear 'vector) s5-0 (-> self control unknown-vector91))
              )
            (set! (-> self control unknown-vector52 quad) (-> self control trans quad))
            )
          )
        )
      )
    (let ((s5-3 (vector-cross! (-> self control unknown-vector101) gp-0 (-> self control dynam gravity-normal))))
      (if (>= 0.0
              (vector-dot s5-3 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control unknown-quaternion00)))
              )
          (vector-negate! s5-3 s5-3)
          )
      (forward-up-nopitch->quaternion (-> self control dir-targ) s5-3 (-> self control dynam gravity-normal))
      )
    )
  (set-quaternion! (-> self control) (-> self control dir-targ))
  (do-joint-math! self)
  (update-transforms! (-> self control))
  (none)
  )

(defbehavior target-calc-camera-pos target ()
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    (cond
      ((and (= (-> self next-state name) 'target-clone-anim)
            (not (logtest? (-> self draw status) (draw-status hidden)))
            (begin
              (vector<-cspace! gp-0 (-> self node-list data 3))
              (set! (-> gp-0 y) (+ -5896.192 (-> gp-0 y)))
              (< (fabs (- (-> gp-0 y) (-> self control trans y))) 8192.0)
              )
            )
       (set! (-> (&-> (-> self control) unknown-qword00) 0) (-> gp-0 quad))
       )
      (else
        (let ((v1-11 (-> self water flags)))
          (cond
            ((and (logtest? v1-11 (water-flags wt09)) (logtest? v1-11 (water-flags wt11 wt12)))
             (vector<-cspace!
               (the-as vector (&-> (-> self control) unknown-qword00))
               (the-as cspace (-> self node-list data))
               )
             (if (not (and (logtest? (-> self water flags) (water-flags wt12))
                           (not (logtest? (-> self water flags) (water-flags wt04)))
                           )
                      )
                 (set! (-> self control unknown-float30) (- (-> self water base-height) (-> self water swim-height)))
                 )
             (&-> (-> self control) unknown-qword00)
             )
            ((and (logtest? (-> self water flags) (water-flags wt09)) (logtest? (water-flags wt18) (-> self water flags)))
             (vector<-cspace!
               (the-as vector (&-> (-> self control) unknown-qword00))
               (the-as cspace (-> self node-list data))
               )
             (set! (-> self control unknown-float30) (-> self water base-height))
             )
            ((logtest? (-> self control root-prim prim-core action) (collide-action racer))
             (set! (-> (&-> (-> self control) unknown-qword00) 0) (-> self control trans quad))
             )
            ((logtest? (-> self control root-prim prim-core action) (collide-action tube))
             (set! (-> (&-> (-> self control) unknown-qword00) 0) (-> self control shadow-pos quad))
             )
            ((logtest? (-> self draw status) (draw-status hidden no-anim))
             (set! (-> (&-> (-> self control) unknown-qword00) 0) (-> self control trans quad))
             )
            (else
              (vector<-cspace!
                (the-as vector (&-> (-> self control) unknown-qword00))
                (the-as cspace (-> self node-list data))
                )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defbehavior joint-points target ()
  (let ((v1-0 (-> self neck)))
    (set! (-> v1-0 blend) 0.0)
    )
  (cond
    ((logtest? (-> self control root-prim prim-core action) (collide-action racer tube))
     )
    ((logtest? (-> self water flags) (water-flags wt10))
     (let ((f30-0 (- (- (-> self control trans y) (- (-> self water height) (-> self water wade-height))))))
       (set! (-> *wade-surface* alignv)
             (lerp-scale 1.0 0.5 f30-0 0.0 (- (-> self water swim-height) (-> self water wade-height)))
             )
       (set! (-> *wade-surface* align-speed) (-> *wade-surface* alignv))
       (let ((f0-9 (lerp-scale 0.8 0.6 f30-0 0.0 (- (-> self water swim-height) (-> self water wade-height)))))
         (set! (-> *wade-surface* target-speed) f0-9)
         (set! (-> *wade-surface* transv-max) f0-9)
         )
       )
     (set! (-> self control surf) *wade-surface*)
     )
    ((logtest? (-> self water flags) (water-flags wt11))
     (set! (-> self control surf) *swim-surface*)
     )
    ((and (logtest? (-> self water flags) (water-flags wt09)) (logtest? (water-flags wt18) (-> self water flags)))
     (set! (-> self control surf) *quicksand-surface*)
     )
    )
  (let ((a2-2
          (matrix<-no-trans-transformq! (-> self control unknown-matrix02) (the-as transformq (-> self control trans)))
          )
        )
    (vector-matrix*! (-> self control unknown-vector80) (-> *TARGET-bank* head-offset) a2-2)
    )
  (vector<-cspace! (-> self control unknown-vector92) (-> self control unknown-cspace10 parent))
  (let ((gp-0 (new-stack-vector0))
        (s5-0 (new-stack-vector0))
        )
    (vector<-cspace! gp-0 (-> self control unknown-cspace00 parent))
    (vector<-cspace! s5-0 (the-as cspace (-> self control unknown-cspace00 joint)))
    (vector-average! (-> self control unknown-vector90) gp-0 s5-0)
    )
  (vector-! (-> self control unknown-vector91) (-> self control unknown-vector90) (-> self control trans))
  (cond
    ((logtest? (-> self control root-prim prim-core action) (collide-action edgegrab-cam))
     (target-compute-edge)
     )
    ((logtest? (-> self control root-prim prim-core action) (collide-action swingpole-active))
     (target-compute-pole)
     )
    )
  (target-calc-camera-pos)
  (when (logtest? (-> self state-flags) (state-flags remove-prevents))
    (logclear! (-> self state-flags) (state-flags prevent-attack prevent-duck remove-prevents))
    (set! (-> self control unknown-float41) 0.0)
    )
  (set! (-> self control unknown-int00) 0)
  0
  (none)
  )

(defbehavior target-real-post target ()
  (let ((gp-0 (the int (-> *display* time-ratio))))
    (set-time-ratios *display* 1.0)
    (countdown (s5-0 gp-0)
      (set! (-> self control unknown-int40) s5-0)
      (flag-setup)
      (if (< (-> self control unknown-float41) 0.0)
          (set! (-> self control unknown-float41) (- 1.0 (-> self control unknown-cpad-info00 stick0-speed)))
          )
      (build-conversions (-> self control transv))
      (do-rotations1)
      (let ((s4-0 (new-stack-vector0)))
        (read-pad s4-0)
        (let ((f30-0 (-> self control unknown-float20)))
          (if (and (< 0.0 f30-0)
                   (< 0.3 (-> self control unknown-float20))
                   (< (vector-dot (-> self control unknown-vector30) (-> self control unknown-vector31)) 0.2)
                   (< f30-0 0.7)
                   )
              (set! f30-0 0.0)
              )
          (when (!= (-> self control unknown-float41) 0.0)
            (let ((f0-12 (fmin 1.0 (-> self control unknown-float41))))
              (set! (-> self control unknown-float41) f0-12)
              (let ((a1-2 (vector-float*!
                            (new 'stack-no-clear 'vector)
                            (if (= f30-0 0.0)
                                *zero-vector*
                                s4-0
                                )
                            f30-0
                            )
                          )
                    (a2-1
                      (vector-float*!
                        (new 'stack-no-clear 'vector)
                        (-> self control unknown-vector40)
                        (-> self control unknown-float50)
                        )
                      )
                    )
                (vector-lerp! s4-0 a1-2 a2-1 f0-12)
                )
              )
            (set! f30-0 (vector-length s4-0))
            (vector-normalize! s4-0 1.0)
            )
          (turn-to-vector s4-0 f30-0)
          )
        )
      (add-thrust)
      (add-gravity)
      (do-rotations2)
      (reverse-conversions (-> self control transv))
      (if *debug-segment*
          (add-frame
            (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
            'draw
            (new 'static 'rgba :r #x40 :b #x40 :a #x80)
            )
          )
      (set! (-> self control reaction) target-collision-reaction)
      (fill-cache-integrate-and-collide!
        (-> self control)
        (-> self control transv)
        (-> self control root-prim collide-with)
        )
      (if (logtest? (-> self control root-prim prim-core action) (collide-action edgegrab-possible))
          (find-edge-grabs! *target* *collide-cache*)
          )
      (if *debug-segment*
          (add-frame
            (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
            'draw
            (new 'static 'rgba :r #x80 :g #x60 :b #x40 :a #x80)
            )
          )
      (bend-gravity)
      (post-flag-setup)
      )
    (set-time-ratios *display* (the float gp-0))
    )
  (if *debug-segment*
      (add-frame
        (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
        'draw
        (new 'static 'rgba :r #x40 :b #x40 :a #x80)
        )
      )
  (ja-post)
  (if *debug-segment*
      (add-frame
        (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
        'draw
        (new 'static 'rgba :r #x80 :a #x80)
        )
      )
  (joint-points)
  (do-target-shadow)
  (target-powerup-process)
  (none)
  )

(defbehavior target-post target ()
  (target-real-post)
  (none)
  )

(defbehavior target-swim-post target ()
  (let ((gp-0 (the int (-> *display* time-ratio))))
    (set-time-ratios *display* 1.0)
    (countdown (s5-0 gp-0)
      (set! (-> self control unknown-int40) s5-0)
      (flag-setup)
      (build-conversions (-> self control transv))
      (do-rotations1)
      (let ((s4-0 (new-stack-vector0)))
        (read-pad s4-0)
        (turn-to-vector s4-0 (-> self control unknown-float20))
        )
      (add-thrust)
      (add-gravity)
      (do-rotations2)
      (reverse-conversions (-> self control transv))
      (if *debug-segment*
          (add-frame
            (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
            'draw
            (new 'static 'rgba :r #x40 :b #x40 :a #x80)
            )
          )
      (fill-cache-integrate-and-collide!
        (-> self control)
        (-> self control transv)
        (-> self control root-prim collide-with)
        )
      (if (logtest? (-> self control root-prim prim-core action) (collide-action edgegrab-possible))
          (find-edge-grabs! *target* *collide-cache*)
          )
      (if *debug-segment*
          (add-frame
            (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
            'draw
            (new 'static 'rgba :r #x80 :g #x60 :b #x40 :a #x80)
            )
          )
      (post-flag-setup)
      )
    (set-time-ratios *display* (the float gp-0))
    )
  (if *debug-segment*
      (add-frame
        (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
        'draw
        (new 'static 'rgba :r #x40 :b #x40 :a #x80)
        )
      )
  (ja-post)
  (if *debug-segment*
      (add-frame
        (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
        'draw
        (new 'static 'rgba :r #x80 :a #x80)
        )
      )
  (joint-points)
  (do-target-shadow)
  (target-powerup-process)
  (none)
  )

(defbehavior target-no-stick-post target ()
  (let ((gp-0 (the int (-> *display* time-ratio))))
    (set-time-ratios *display* 1.0)
    (countdown (s5-0 gp-0)
      (set! (-> self control unknown-int40) s5-0)
      (flag-setup)
      (build-conversions (-> self control transv))
      (do-rotations1)
      (let ((s4-0 (new-stack-vector0)))
        (read-pad s4-0)
        (turn-to-vector s4-0 0.0)
        )
      (add-thrust)
      (add-gravity)
      (do-rotations2)
      (reverse-conversions (-> self control transv))
      (if *debug-segment*
          (add-frame
            (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
            'draw
            (new 'static 'rgba :r #x40 :b #x40 :a #x80)
            )
          )
      (fill-cache-integrate-and-collide!
        (-> self control)
        (-> self control transv)
        (-> self control root-prim collide-with)
        )
      (if (logtest? (-> self control root-prim prim-core action) (collide-action edgegrab-possible))
          (find-edge-grabs! *target* *collide-cache*)
          )
      (if *debug-segment*
          (add-frame
            (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
            'draw
            (new 'static 'rgba :r #x80 :g #x60 :b #x40 :a #x80)
            )
          )
      (bend-gravity)
      (post-flag-setup)
      )
    (set-time-ratios *display* (the float gp-0))
    )
  (if *debug-segment*
      (add-frame
        (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
        'draw
        (new 'static 'rgba :r #x40 :b #x40 :a #x80)
        )
      )
  (ja-post)
  (if *debug-segment*
      (add-frame
        (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
        'draw
        (new 'static 'rgba :r #x80 :a #x80)
        )
      )
  (joint-points)
  (do-target-shadow)
  (target-powerup-process)
  (none)
  )

(defbehavior target-no-move-post target ()
  (let ((gp-0 (the int (-> *display* time-ratio))))
    (set-time-ratios *display* 1.0)
    (countdown (s5-0 gp-0)
      (set! (-> self control unknown-int40) s5-0)
      (flag-setup)
      (build-conversions (-> self control transv))
      (do-rotations1)
      (do-rotations2)
      (reverse-conversions (-> self control transv))
      (vector-!
        (-> self control unknown-vector12)
        (-> self control unknown-vector11)
        (-> self control unknown-vector14)
        )
      (let ((a1-3 (new 'stack-no-clear 'overlaps-others-params)))
        (set! (-> a1-3 options) (the-as uint 1))
        (set! (-> a1-3 tlist) *touching-list*)
        (find-overlapping-shapes (-> self control) a1-3)
        )
      (post-flag-setup)
      )
    (set-time-ratios *display* (the float gp-0))
    )
  (if *debug-segment*
      (add-frame
        (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
        'draw
        (new 'static 'rgba :r #x40 :b #x40 :a #x80)
        )
      )
  (ja-post)
  (if *debug-segment*
      (add-frame
        (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
        'draw
        (new 'static 'rgba :r #x80 :a #x80)
        )
      )
  (joint-points)
  (do-target-shadow)
  (target-powerup-process)
  (none)
  )

(defbehavior target-slide-down-post target ()
  (let ((gp-0 (the int (-> *display* time-ratio))))
    (set-time-ratios *display* 1.0)
    (countdown (s5-0 gp-0)
      (set! (-> self control unknown-int40) s5-0)
      (flag-setup)
      (build-conversions (-> self control transv))
      (do-rotations1)
      (let ((s4-1
              (vector-flatten!
                (new-stack-vector0)
                (vector-negate! (new-stack-vector0) (-> self control dynam gravity-normal))
                (-> self control local-normal)
                )
              )
            )
        (let ((s3-1 (new-stack-vector0)))
          (new-stack-matrix0)
          (read-pad s3-1)
          (set! (-> self control unknown-surface01 slide-factor) 49152.0)
          (set! (-> self control unknown-surface01 bend-factor) 0.0)
          (turn-to-vector s3-1 (the-as float (/ (the int (-> self control unknown-float20)) 2)))
          )
        (set! (-> self control unknown-vector20 quad) (-> (vector-negate! s4-1 s4-1) quad))
        )
      (set! (-> self control unknown-float12) 1.0)
      (add-thrust)
      (add-gravity)
      (do-rotations2)
      (reverse-conversions (-> self control transv))
      (if *debug-segment*
          (add-frame
            (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
            'draw
            (new 'static 'rgba :r #x40 :b #x40 :a #x80)
            )
          )
      (fill-cache-integrate-and-collide!
        (-> self control)
        (-> self control transv)
        (-> self control root-prim collide-with)
        )
      (if (logtest? (-> self control root-prim prim-core action) (collide-action edgegrab-possible))
          (find-edge-grabs! *target* *collide-cache*)
          )
      (if *debug-segment*
          (add-frame
            (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
            'draw
            (new 'static 'rgba :r #x40 :a #x80)
            )
          )
      (bend-gravity)
      (post-flag-setup)
      )
    (set-time-ratios *display* (the float gp-0))
    )
  (if *debug-segment*
      (add-frame
        (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
        'draw
        (new 'static 'rgba :r #x40 :b #x40 :a #x80)
        )
      )
  (ja-post)
  (if *debug-segment*
      (add-frame
        (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
        'draw
        (new 'static 'rgba :r #x80 :a #x80)
        )
      )
  (joint-points)
  (do-target-shadow)
  (target-powerup-process)
  (none)
  )

(defbehavior target-no-ja-move-post target ()
  (vector-!
    (-> self control unknown-vector12)
    (-> self control unknown-vector11)
    (-> self control unknown-vector14)
    )
  (let ((a1-2 (new 'stack-no-clear 'overlaps-others-params)))
    (set! (-> a1-2 options) (the-as uint 1))
    (set! (-> a1-2 tlist) *touching-list*)
    (find-overlapping-shapes (-> self control) a1-2)
    )
  (target-calc-camera-pos)
  (do-target-shadow)
  (target-powerup-process)
  (none)
  )

(defbehavior reset-target-state target ((arg0 symbol))
  (when arg0
    (vector-identity! (-> self control scale))
    (quaternion-identity! (-> self control quat))
    (quaternion-identity! (-> self control unknown-quaternion00))
    (quaternion-identity! (-> self control dir-targ))
    (set! (-> self control transv quad) (the-as uint128 0))
    (set! (-> (&-> (-> self control) unknown-qword00) 0) (-> self control trans quad))
    )
  (target-exit)
  (target-timed-invulnerable-off self)
  (set! (-> self control status) (cshape-moving-flags))
  (set! (-> self control unknown-dynamics00) *standard-dynamics*)
  (set! (-> self control surf) *standard-ground-surface*)
  (set! (-> self control unknown-vector02 quad) (-> self control unknown-dynamics00 gravity-normal quad))
  (quaternion-identity! (-> self control unknown-quaternion01))
  (set! (-> self control unknown-float00) 0.0)
  (set! (-> self control unknown-dword11) (-> *display* base-frame-counter))
  (set! (-> self control unknown-float80) 0.0)
  (set! (-> self control unknown-float82) 32.0)
  (set! (-> self cam-user-mode) 'normal)
  (set! (-> self control unknown-handle10) (the-as handle #f))
  (set! (-> self control unknown-handle00) (the-as handle #f))
  (set! (-> self control unknown-dword82) 0)
  (buzz-stop! 0)
  self
  )

(defbehavior init-target target ((arg0 continue-point))
  (set-setting! 'allow-pause #f 0.0 0)
  (set-setting! 'allow-progress #f 0.0 0)
  (apply-settings *setting-control*)
  (if (not arg0)
      (set! arg0 (get-or-create-continue! *game-info*))
      )
  (set-continue! *game-info* arg0)
  (stack-size-set! (-> self main-thread) 1024)
  (logior! (-> self mask) (process-mask target))
  (set! (-> self state-hook) (the-as (function none :behavior target) nothing))
  (let ((s5-0 (new 'process 'control-info self (collide-list-enum player))))
    (set! (-> self control) s5-0)
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 max-iteration-count) (the-as uint 8))
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> s5-0 reaction) target-collision-reaction)
    (set! (-> s5-0 no-reaction) target-collision-no-reaction)
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 6) 1)))
      (set! (-> s4-0 prim-core collide-as) (collide-kind target))
      (set! (-> s4-0 collide-with)
            (collide-kind background cak-1 cak-2 cak-3 water powerup crate enemy wall-object ground-object mother-spider)
            )
      (set! (-> s4-0 prim-core offense) (collide-offense touch))
      (set! (-> s4-0 prim-core action) (collide-action solid rider-target))
      (set-root-prim! s5-0 s4-0)
      (let ((s3-0 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 6))))
        (set! (-> s3-0 prim-core action) (collide-action solid rider-target))
        (set! (-> s3-0 prim-core collide-as) (collide-kind target))
        (set! (-> s3-0 collide-with)
              (collide-kind background cak-1 cak-2 cak-3 water powerup crate enemy wall-object ground-object mother-spider)
              )
        (set! (-> s3-0 prim-core offense) (collide-offense touch))
        (append-prim s4-0 s3-0)
        (set! (-> s5-0 unknown-sphere-array00 0) s3-0)
        )
      (let ((s3-1 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 10))))
        (set! (-> s3-1 prim-core action) (collide-action solid))
        (set! (-> s3-1 prim-core collide-as) (collide-kind target))
        (set! (-> s3-1 collide-with)
              (collide-kind background cak-1 cak-2 cak-3 water powerup crate enemy wall-object ground-object mother-spider)
              )
        (set! (-> s3-1 prim-core offense) (collide-offense touch))
        (append-prim s4-0 s3-1)
        (set! (-> s5-0 unknown-sphere-array00 1) s3-1)
        )
      (let ((s3-2 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 18))))
        (set! (-> s3-2 prim-core action) (collide-action solid))
        (set! (-> s3-2 prim-core collide-as) (collide-kind target))
        (set! (-> s3-2 collide-with)
              (collide-kind background cak-1 cak-2 cak-3 water powerup crate enemy wall-object ground-object mother-spider)
              )
        (set! (-> s3-2 prim-core offense) (collide-offense touch))
        (append-prim s4-0 s3-2)
        (set! (-> s5-0 unknown-sphere-array00 2) s3-2)
        )
      (let ((s3-3 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 32))))
        (append-prim s4-0 s3-3)
        (set! (-> s5-0 unknown-sphere00) s3-3)
        )
      (let ((s3-4 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 64))))
        (append-prim s4-0 s3-4)
        (set! (-> s5-0 unknown-sphere01) s3-4)
        )
      (let ((s3-5 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 128))))
        (append-prim s4-0 s3-5)
        (set! (-> s5-0 unknown-sphere02) s3-5)
        )
      )
    )
  (target-collide-set! 'normal 0.0)
  (backup-collide-with-as (-> self control))
  (set! (-> self game) *game-info*)
  (move-to-point! (-> self control) (-> arg0 trans))
  (set! (-> (&-> (-> self control) unknown-qword00) 0) (-> arg0 trans quad))
  (set! (-> self control unknown-cpad-info00) (-> *cpad-list* cpads 0))
  (set! (-> self control unknown-surface01) (new 'process 'surface))
  (set! (-> self control unknown-surface01 name) 'current)
  (set! (-> self control unknown-surface01 active-hook) nothing)
  (set! (-> self control unknown-surface01 touch-hook) nothing)
  (initialize-skeleton self *jchar-sg* '())
  (set! (-> self draw origin-joint-index) (the-as uint 33))
  (set! (-> self draw shadow-joint-index) (the-as uint 33))
  (let ((v1-79 (-> self node-list data)))
    (set! (-> v1-79 0 param0) cspace<-transformq+trans!)
    (set! (-> v1-79 0 param1) (the-as basic (-> self control trans)))
    (set! (-> v1-79 0 param2) (the-as basic (-> self control unknown-vector12)))
    )
  (set! (-> self draw lod-set max-lod) 0)
  (logior! (-> self skel status) (janim-status inited eye))
  (set! (-> self draw shadow-ctrl) *target-shadow-control*)
  (set! (-> self control unknown-cspace00 parent) (-> self node-list data 42))
  (set! (-> self control unknown-cspace00 joint) (the-as joint (-> self node-list data 54)))
  (set! (-> self control unknown-cspace00 joint) (the-as joint (-> self node-list data 54)))
  (set! (-> self control unknown-cspace10 parent) (-> self node-list data 64))
  (set! (-> self neck) (new 'process 'joint-mod (joint-mod-handler-mode look-at) self 7))
  (set! (-> self fact-info-target)
        (new 'process 'fact-info-target self (pickup-type eco-pill-random) (-> *FACT-bank* default-pill-inc))
        )
  (set! (-> self sound) (new 'process 'ambient-sound 'none (-> self control trans)))
  (set! (-> self control unknown-soundid00) (new-sound-id))
  (if *debug-segment*
      (add-connection *debug-engine* self target-print-stats self *stdcon0* #f)
      )
  (activate-hud self)
  (set! (-> self fp-hud) (the-as handle #f))
  ;; PAL patch here
  (set! (-> self burn-proc) (the-as handle #f))
  (set! (-> self water) (new 'process 'water-control self 9 0.0 8192.0 2048.0))
  (set! (-> self water flags) (water-flags wt04 wt05 wt06 wt07 wt22))
  (reset-target-state #t)
  (set! (-> self control unknown-vector52 quad) (-> self control trans quad))
  (set! (-> self control unknown-vector52 y) (+ -819200.0 (-> self control unknown-vector52 y)))
  (set! (-> self align) (new 'process 'align-control self))
  (set! (-> self sidekick) (process-spawn sidekick :init init-sidekick :from *16k-dead-pool* :to self))
  (set! (-> self manipy) (the-as (pointer manipy) #f))
  (set! (-> self event-hook) target-generic-event-handler)
  (set! (-> self current-level) #f)
  (level-setup)
  (go target-continue arg0)
  (none)
  )

(defmethod deactivate target ((obj target))
  (set-zero! *camera-smush-control*)
  ((the-as (function process-drawable none) (find-parent-method target 10)) obj)
  (none)
  )

(defun stop ((arg0 symbol))
  (when *target*
    (kill-by-name 'target *active-pool*)
    (set! *target* #f)
    )
  (set! (-> *game-info* mode) arg0)
  0
  )

(defun start ((arg0 symbol) (arg1 continue-point))
  (set! (-> *level* border?) #f)
  (set! (-> *setting-control* default border-mode) #f)
  (stop arg0)
  (let ((v1-3 (process-spawn
                target
                :init init-target
                arg1
                :from *target-dead-pool*
                :to *target-pool*
                :stack *kernel-dram-stack*
                )
              )
        )
    (if v1-3
        (set! *target* (the-as target (-> v1-3 0 self)))
        (set! *target* #f)
        )
    )
  *target*
  )
