;;-*-Lisp-*-
(in-package goal)

;; name: collide-reaction-target.gc
;; name in dgo: collide-reaction-target
;; dgos: GAME, ENGINE

;; DECOMP BEGINS

(defun collide-shape-moving-angle-set! ((arg0 collide-shape-moving) (arg1 vector) (arg2 vector))
  (set! (-> arg0 surface-normal quad) (-> arg1 quad))
  (set! (-> arg0 surface-angle) (vector-dot arg1 (-> arg0 dynam gravity-normal)))
  (set! (-> arg0 poly-angle) (vector-dot (-> arg0 poly-normal) (-> arg0 dynam gravity-normal)))
  (set! (-> arg0 touch-angle)
        (fmax
          (-> arg0 touch-angle)
          (vector-dot arg1 (vector-normalize! (vector-negate! (new-stack-vector0) arg2) 1.0))
          )
        )
  0
  (none)
  )

(defun target-collision-low-coverage ((arg0 control-info)
                             (arg1 collide-shape-intersect)
                             (arg2 vector)
                             (arg3 (pointer uint32))
                             (arg4 (pointer uint64))
                             (arg5 (pointer symbol))
                             )
  (local-vars
    (sv-16 vector)
    (sv-20 (pointer uint32))
    (sv-24 (pointer uint64))
    (sv-28 (pointer symbol))
    (sv-32 uint)
    (sv-40 uint)
    (sv-48 symbol)
    (sv-52 vector)
    (sv-56 vector)
    (sv-160 vector)
    (sv-164 collide-tri-result)
    (sv-208 vector)
    (sv-212 vector)
    (sv-272 vector)
    (sv-276 vector)
    )
  (set! sv-16 arg2)
  (set! sv-20 arg3)
  (set! sv-24 arg4)
  (set! sv-28 arg5)
  (set! sv-32 (-> arg3 0))
  (set! sv-40 (-> arg4 0))
  (set! sv-48 (-> arg5 0))
  (set! sv-52 (-> arg0 unknown-vector60))
  (set! sv-56 (vector-cross! (-> arg0 unknown-vector-coverage-2) (-> arg0 poly-normal) sv-16))
  (vector-normalize! sv-56 1.0)
  (if (>= (fabs (vector-dot (-> arg0 dynam gravity-normal) sv-56)) 0.866)
      (set! sv-32 (logior sv-32 512))
      )
  (vector-cross! sv-52 sv-16 sv-56)
  (if (< 0.0 (vector-dot (-> arg0 dynam gravity-normal) sv-52))
      (vector-negate! sv-52 sv-52)
      )
  (vector-normalize! sv-52 1.0)
  (set! sv-160 (vector-flatten! (-> arg0 unknown-vector-coverage-3) sv-52 (-> arg0 dynam gravity-normal)))
  (set! sv-164 (new 'stack 'collide-tri-result))
  (vector-normalize! sv-160 1.0)
  (if (< (vector-dot sv-160 sv-16) 0.0)
      (vector-negate! sv-160 sv-160)
      )
  (set! (-> arg0 unknown-float-coverage-0) 4095996000.0)
  (set! (-> arg0 unknown-float-coverage-2) 4095996000.0)
  (set! sv-208 (vector+float*! (new 'stack-no-clear 'vector) (-> arg1 best-tri intersect) sv-160 2867.2))
  (set! sv-212 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> arg0 dynam gravity-normal) -20480.0))
  (vector+float*! sv-212 sv-212 sv-160 4096.0)
  (when (>= (probe-using-line-sphere *collide-cache* sv-208 sv-212 409.6 (-> arg1 best-from-prim collide-with) sv-164 (new 'static 'pat-surface :noentity #x1))
            0.0
            )
    (set! (-> arg0 unknown-float-coverage-0)
          (vector-dot
            (-> arg0 dynam gravity-normal)
            (vector-! (new 'stack-no-clear 'vector) (-> arg1 best-tri intersect) (-> sv-164 intersect))
            )
          )
    (set! (-> arg0 unknown-float-coverage-1) (the-as float (-> sv-164 pat)))
    (set! (-> arg0 unknown-vector-coverage-0 quad) (-> sv-164 normal quad))
    0
    )
  (set! sv-272 (vector+float*!
                 (new 'stack-no-clear 'vector)
                 (-> arg1 best-tri intersect)
                 (-> arg0 dynam gravity-normal)
                 819.2
                 )
        )
  (set! sv-276 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> arg0 dynam gravity-normal) -20480.0))
  (vector+float*! sv-272 sv-272 sv-160 -819.2)
  (vector+float*! sv-276 sv-276 sv-160 -4096.0)
  (when (>= (probe-using-line-sphere *collide-cache* sv-272 sv-276 409.6 (-> arg1 best-from-prim collide-with) sv-164 (new 'static 'pat-surface :noentity #x1))
            0.0
            )
    (set! (-> arg0 unknown-float-coverage-2) (vector-vector-distance sv-272 (-> sv-164 intersect)))
    (set! (-> arg0 unknown-u32-coverage-0) (the-as uint (-> sv-164 pat)))
    (set! (-> arg0 unknown-vector-coverage-1 quad) (-> sv-164 normal quad))
    0
    )
  (when (and (zero? (logand sv-32 512))
             (and (or (< (* 1.25 (-> arg1 best-from-prim local-sphere w)) (-> arg0 unknown-float-coverage-0))
                      (= (shr (shl (the-as int (-> arg0 unknown-float-coverage-1)) 58) 61) 1)
                      )
                  (and (< (-> arg0 unknown-float-coverage-2) (* 2.0 (-> arg1 best-from-prim local-sphere w)))
                       (zero? (shr (shl (-> arg0 unknown-u32-coverage-0) 58) 61))
                       )
                  )
             )
    (set! sv-32 (logior sv-32 128))
    (set! (-> arg0 unknown-dword-coverage) (the-as int (-> *display* base-frame-counter)))
    (set! sv-40 (logior sv-40 128))
    (set! (-> arg0 unknown-dword21) (-> *display* base-frame-counter))
    (let ((f30-0 (vector-dot sv-52 (-> arg0 unknown-vector22)))
          (f0-21 (if (logtest? sv-32 2)
                     (cos (- 16384.0 (acos (-> arg0 coverage))))
                     (-> arg0 coverage)
                     )
                 )
          (f1-11 (vector-dot
                   (-> arg0 dynam gravity-normal)
                   (vector-! (new 'stack-no-clear 'vector) (-> arg0 trans) (-> arg1 best-tri intersect))
                   )
                 )
          )
      (if (or (zero? (logand sv-32 32)) (< 0.5 f0-21))
          (set! sv-48 (the-as symbol #f))
          )
      (when (and (or (and (< f0-21 0.95) (>= f30-0 0.0))
                     (and (logtest? sv-32 32) (< f0-21 0.3))
                     (< f1-11 (* -0.25 (-> arg1 best-from-prim local-sphere w)))
                     )
                 (>= (vector-dot sv-52 sv-16) -0.000001)
                 )
        (set! (-> arg0 surf) *edge-surface*)
        (set! sv-32 (logior sv-32 1024))
        (set! sv-48 (the-as symbol #f))
        (when (logtest? sv-32 32)
          (set! sv-48 #t)
          (set! sv-32 (logior sv-32 4096))
          )
        )
      )
    )
  (if (< (-> arg0 surface-angle) 0.0)
      (set! sv-48 #t)
      )
  (when sv-48
    (cond
      ((and (or (= (-> arg0 poly-pat mode) (pat-mode ground))
                (and (logtest? sv-32 8)
                     (>= (* 1.25 (-> arg1 best-from-prim local-sphere w)) (-> arg0 unknown-float-coverage-0))
                     (zero? (shr (shl (the-as int (-> arg0 unknown-float-coverage-1)) 58) 61))
                     (< 0.3 (fabs (-> arg0 surface-angle)))
                     )
                )
            (zero? (logand sv-32 128))
            )
       (set! sv-32 (logior sv-32 64))
       (set! sv-40 (logior sv-40 128))
       (set! (-> arg0 unknown-dword21) (-> *display* base-frame-counter))
       (set! sv-48 (the-as symbol #f))
       )
      (#t
        (set! sv-32 (logior sv-32 64))
        (set! sv-40 (logior sv-40 128))
        (set! (-> arg0 unknown-dword21) (-> *display* base-frame-counter))
        )
      )
    )
  (set! (-> sv-24 0) sv-40)
  (set! (-> sv-20 0) sv-32)
  (set! (-> sv-28 0) sv-48)
  (the-as uint 0)
  )

(defun target-collision-reaction ((arg0 control-info) (arg1 collide-shape-intersect) (arg2 vector) (arg3 vector))
  (local-vars (sv-80 vector) (sv-84 vector) (sv-88 matrix) (sv-96 int) (sv-104 int) (sv-160 symbol))
  (set! sv-80 (new-stack-vector0))
  (set! sv-84 (new-stack-vector0))
  (let ((v1-2 (new 'stack-no-clear 'matrix)))
    (dotimes (a0-1 2)
      (set! (-> v1-2 vector a0-1 quad) (the-as uint128 0))
      )
    (set! sv-88 v1-2)
    )
  (set! sv-96 0)
  (set! sv-104 0)
  (set! (-> sv-88 vector 0 quad) (-> arg3 quad))
  (set! (-> sv-88 vector 1 quad) (-> arg3 quad))
  (let ((a1-3 (new 'stack-no-clear 'vector)))
    (vector-float*! a1-3 (-> arg1 move-vec) (-> arg1 best-u))
    (move-by-vector! arg0 a1-3)
    )
  (set-and-handle-pat! arg0 (-> arg1 best-tri pat))
  (if (= (-> arg0 poly-pat mode) (pat-mode wall))
      (set! sv-104 (logior sv-104 1))
      )
  (if (logtest? (-> arg0 unknown-surface00 flags) (surface-flags jump))
      (set! sv-104 (logior sv-104 32))
      )
  (let ((v1-23 (new 'stack-no-clear 'vector)))
    (set! (-> v1-23 quad) (-> arg1 best-from-prim prim-core world-sphere quad))
    (vector-! sv-80 v1-23 (-> arg1 best-tri intersect))
    )
  (vector-normalize! sv-80 1.0)
  (set! (-> arg0 coverage) (vector-dot sv-80 (-> arg1 best-tri normal)))
  (when (< (-> arg0 coverage) 0.0)
    (set! (-> arg0 coverage) 0.0)
    (vector-flatten! sv-80 sv-80 (-> arg1 best-tri normal))
    (vector-normalize! sv-80 1.0)
    )
  (if (< (-> arg0 coverage) 0.9999)
      (set! sv-104 (logior sv-104 24))
      )
  (let ((v1-33 (-> sv-80 quad)))
    (set! (-> sv-84 quad) v1-33)
    )
  (if (= (-> arg1 best-u) 0.0)
      (move-by-vector! arg0 (vector-normalize-copy! (new-stack-vector0) sv-84 3.0))
      )
  (set! (-> arg0 poly-normal quad) (-> arg1 best-tri normal quad))
  (collide-shape-moving-angle-set! arg0 sv-84 (the-as vector (-> sv-88 vector)))
  (if (< (-> arg0 poly-angle) -0.2)
      (set! sv-96 (logior sv-96 16))
      )
  (if (< (-> arg0 poly-angle) 0.0)
      (set! sv-96 (logior sv-96 #x4000))
      )
  (set! sv-160 (< (fabs (-> arg0 surface-angle)) (-> *pat-mode-info* (-> arg0 cur-pat mode) wall-angle)))
  (if (and sv-160 (and (= (-> arg0 unknown-surface00 mode) 'dive) (< 0.2 (fabs (-> arg0 surface-angle)))))
      (set! sv-160 (the-as symbol #f))
      )
  (if sv-160
      (set! sv-104 (logior sv-104 2))
      )
  (if (logtest? sv-104 8)
      (target-collision-low-coverage
        arg0
        arg1
        sv-84
        (the-as (pointer uint32) (& sv-104))
        (the-as (pointer uint64) (& sv-96))
        (& sv-160)
        )
      )
  (when (zero? (logand (-> arg0 prev-status) (cshape-moving-flags onsurf)))
    (set! (-> arg0 ground-impact-vel) (- (vector-dot (-> arg0 transv) (-> arg0 dynam gravity-normal))))
    (set! sv-96 (logior sv-96 2048))
    (when (not sv-160)
      (let ((f30-0 (- 1.0 (-> arg0 surf impact-fric))))
        (when (< f30-0 1.0)
          (let ((s3-1 (new-stack-vector0))
                (f28-0 (vector-dot (-> arg0 dynam gravity-normal) (the-as vector (-> sv-88 vector))))
                )
            0.0
            (vector-! s3-1 (the-as vector (-> sv-88 vector)) (vector-float*! s3-1 (-> arg0 dynam gravity-normal) f28-0))
            (let* ((f0-20 (vector-length s3-1))
                   (f1-9 f0-20)
                   )
              (if (< f28-0 0.0)
                  (set! f28-0 (* f28-0 f30-0))
                  )
              (vector+!
                (the-as vector (-> sv-88 vector))
                (vector-float*! (the-as vector (-> sv-88 vector)) (-> arg0 dynam gravity-normal) f28-0)
                (vector-float*! s3-1 s3-1 (/ f0-20 f1-9))
                )
              )
            )
          )
        )
      )
    )
  (set! sv-96 (logior sv-96 4))
  (cond
    ((-> arg1 best-to-prim)
     (set! sv-96 (logior sv-96 32))
     (set! (-> arg0 unknown-vector72 quad) (-> arg1 best-tri intersect quad))
     (set! (-> arg0 unknown-vector73 quad) (-> arg0 poly-normal quad))
     (set! (-> arg0 unknown-handle00) (process->handle (-> arg1 best-to-prim cshape process)))
     )
    ((= (-> arg0 poly-pat material) (pat-material waterbottom))
     )
    (else
      (set! sv-96 (logior sv-96 4096))
      )
    )
  (cond
    (sv-160
      (set! sv-104 (logior sv-104 4))
      (set! sv-96 (logior sv-96 8))
      (set! (-> arg0 cur-pat mode) 1)
      (set! (-> arg0 unknown-vector70 quad) (-> arg1 best-tri intersect quad))
      (set! (-> arg0 unknown-vector71 quad) (-> arg0 poly-normal quad))
      (set! (-> arg0 unknown-vector121 quad) (-> sv-84 quad))
      (set! (-> arg0 wall-pat) (-> arg1 best-tri pat))
      (-> arg0 history-data (logand (+ (-> arg0 unknown-halfword00) 127) 127))
      (cond
        (#f
          (sound-play "cursor-options")
          (set! sv-104 (logior sv-104 8192))
          (vector-reflect-flat-above! arg2 (the-as vector (-> sv-88 vector)) sv-84)
          )
        (else
          (vector-reflect-flat! arg2 (the-as vector (-> sv-88 vector)) sv-84)
          )
        )
      (cond
        ((not (and (>= (-> arg1 best-from-prim local-sphere w)
                       (vector-dot
                         (-> arg0 ground-poly-normal)
                         (vector-! (new 'stack-no-clear 'vector) (-> arg1 best-tri intersect) (-> arg0 ground-touch-point))
                         )
                       )
                   (and (< 0.0 (vector-dot (-> arg0 ground-poly-normal) arg2))
                        (< (- (-> *display* base-frame-counter) (-> arg0 unknown-dword10)) (seconds 0.3))
                        (zero? (logand sv-104 32))
                        )
                   )
              )
         )
        (else
          (set! sv-104 (logior sv-104 256))
          (set! sv-104 (logand -65 sv-104))
          (let ((s3-4 (vector-cross! (new 'stack-no-clear 'vector) (-> arg0 poly-normal) (-> arg0 ground-poly-normal))))
            (vector-normalize! s3-4 1.0)
            (vector-float*! arg2 s3-4 (vector-dot (the-as vector (-> sv-88 vector)) s3-4))
            )
          (vector+! arg2 arg2 (-> arg0 poly-normal))
          )
        )
      )
    (else
      (set! sv-96 (logior sv-96 1))
      (set! (-> arg0 cur-pat mode) 0)
      (if (= (-> arg1 best-from-prim prim-id) 6)
          (set! (-> arg0 local-normal quad) (-> sv-84 quad))
          )
      (vector-reflect-flat! arg2 (the-as vector (-> sv-88 vector)) sv-84)
      (vector+! arg2 arg2 sv-84)
      (set! (-> arg0 ground-touch-point w) 0.0)
      (when (not (or (logtest? sv-104 15) (nonzero? (-> arg0 poly-pat event))))
        (set! sv-96 (logior sv-96 2))
        (set! (-> arg0 ground-poly-normal quad) (-> arg0 poly-normal quad))
        (set! (-> arg0 unknown-vector53 quad) (-> sv-84 quad))
        (set! (-> arg0 unknown-float60) (vector-dot sv-84 (-> arg0 dynam gravity-normal)))
        (set! (-> arg0 unknown-dword10) (-> *display* base-frame-counter))
        (set! (-> arg0 ground-pat) (-> arg0 poly-pat))
        (set! (-> arg0 ground-touch-point quad) (-> arg1 best-tri intersect quad))
        (set! (-> arg0 unknown-vector55 quad) (-> arg1 best-from-prim prim-core world-sphere quad))
        (set! sv-104 (logior sv-104 2048))
        (if (= (-> arg0 poly-pat material) (pat-material waterbottom))
            (set! sv-96 (logior sv-96 1024))
            )
        )
      )
    )
  (logior! (-> arg0 status) sv-96)
  (set! (-> arg0 reaction-flag) (the-as cshape-reaction-flags sv-104))
  (update!
    (-> arg0 history-data (-> arg0 unknown-halfword00))
    arg0
    (-> arg1 best-tri intersect)
    (-> sv-88 vector 1)
    arg2
    )
  (set! (-> arg0 unknown-halfword00) (logand (+ (-> arg0 unknown-halfword00) 1) 127))
  (the-as cshape-moving-flags sv-96)
  )

(defun target-collision-no-reaction ((arg0 control-info) (arg1 collide-shape-intersect) (arg2 vector) (arg3 vector))
  (if (= (-> arg0 unknown-surface00 mode) 'air)
      (logior! (-> arg0 reaction-flag) (cshape-reaction-flags csrf05))
      )
  (let ((s5-0 (-> arg0 history-data (-> arg0 unknown-halfword00))))
    (update! s5-0 arg0 (-> arg0 trans) arg3 arg2)
    (logior! (-> s5-0 status) (cshape-moving-flags csmf08))
    )
  (set! (-> arg0 unknown-halfword00) (logand (+ (-> arg0 unknown-halfword00) 1) 127))
  0
  (none)
  )




