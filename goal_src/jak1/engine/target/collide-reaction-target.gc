;;-*-Lisp-*-
(in-package goal)
(bundles "ENGINE.CGO" "GAME.CGO")
(require "engine/collide/collide-shape.gc")

;; DECOMP BEGINS

(defun collide-shape-moving-angle-set! ((arg0 collide-shape-moving) (arg1 vector) (arg2 vector))
  (set! (-> arg0 surface-normal quad) (-> arg1 quad))
  (set! (-> arg0 surface-angle) (vector-dot arg1 (-> arg0 dynam gravity-normal)))
  (set! (-> arg0 poly-angle) (vector-dot (-> arg0 poly-normal) (-> arg0 dynam gravity-normal)))
  (set! (-> arg0 touch-angle)
        (fmax (-> arg0 touch-angle) (vector-dot arg1 (vector-normalize! (vector-negate! (new-stack-vector0) arg2) 1.0))))
  0
  (none))

(defun target-collision-low-coverage ((arg0 control-info)
        (arg1 collide-shape-intersect)
        (arg2 vector)
        (arg3 (pointer uint32))
        (arg4 (pointer uint64))
        (arg5 (pointer symbol)))
  (local-vars
    (sv-16 vector)
    (sv-20 (pointer uint32))
    (sv-24 (pointer uint64))
    (sv-28 (pointer symbol))
    (sv-32 uint)
    (sv-40 uint)
    (sv-48 symbol)
    (sv-52 vector)
    (sv-56 vector)
    (sv-160 vector)
    (sv-164 collide-tri-result)
    (sv-208 vector)
    (sv-212 vector)
    (sv-272 vector)
    (sv-276 vector))
  (set! sv-16 arg2)
  (set! sv-20 arg3)
  (set! sv-24 arg4)
  (set! sv-28 arg5)
  (set! sv-32 (-> arg3 0))
  (set! sv-40 (-> arg4 0))
  (set! sv-48 (-> arg5 0))
  (set! sv-52 (-> arg0 unknown-vector60))
  (set! sv-56 (vector-cross! (-> arg0 unknown-vector-coverage-2) (-> arg0 poly-normal) sv-16))
  (vector-normalize! sv-56 1.0)
  (if (>= (fabs (vector-dot (-> arg0 dynam gravity-normal) sv-56)) 0.866) (set! sv-32 (logior sv-32 512)))
  (vector-cross! sv-52 sv-16 sv-56)
  (if (< 0.0 (vector-dot (-> arg0 dynam gravity-normal) sv-52)) (vector-negate! sv-52 sv-52))
  (vector-normalize! sv-52 1.0)
  (set! sv-160 (vector-flatten! (-> arg0 unknown-vector-coverage-3) sv-52 (-> arg0 dynam gravity-normal)))
  (set! sv-164 (new 'stack 'collide-tri-result))
  (vector-normalize! sv-160 1.0)
  (if (< (vector-dot sv-160 sv-16) 0.0) (vector-negate! sv-160 sv-160))
  (set! (-> arg0 unknown-float-coverage-0) 4095996000.0)
  (set! (-> arg0 unknown-float-coverage-2) 4095996000.0)
  (set! sv-208 (vector+float*! (new 'stack-no-clear 'vector) (-> arg1 best-tri intersect) sv-160 2867.2))
  (set! sv-212 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> arg0 dynam gravity-normal) -20480.0))
  (vector+float*! sv-212 sv-212 sv-160 4096.0)
  (when (>= (probe-using-line-sphere *collide-cache*
                                     sv-208
                                     sv-212
                                     409.6
                                     (-> arg1 best-from-prim collide-with)
                                     sv-164
                                     (new 'static 'pat-surface :noentity #x1))
            0.0)
    (set! (-> arg0 unknown-float-coverage-0)
          (vector-dot (-> arg0 dynam gravity-normal)
                      (vector-! (new 'stack-no-clear 'vector) (-> arg1 best-tri intersect) (-> sv-164 intersect))))
    (set! (-> arg0 unknown-float-coverage-1) (the-as float (-> sv-164 pat)))
    (set! (-> arg0 unknown-vector-coverage-0 quad) (-> sv-164 normal quad))
    0)
  (set! sv-272
        (vector+float*! (new 'stack-no-clear 'vector) (-> arg1 best-tri intersect) (-> arg0 dynam gravity-normal) 819.2))
  (set! sv-276 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> arg0 dynam gravity-normal) -20480.0))
  (vector+float*! sv-272 sv-272 sv-160 -819.2)
  (vector+float*! sv-276 sv-276 sv-160 -4096.0)
  (when (>= (probe-using-line-sphere *collide-cache*
                                     sv-272
                                     sv-276
                                     409.6
                                     (-> arg1 best-from-prim collide-with)
                                     sv-164
                                     (new 'static 'pat-surface :noentity #x1))
            0.0)
    (set! (-> arg0 unknown-float-coverage-2) (vector-vector-distance sv-272 (-> sv-164 intersect)))
    (set! (-> arg0 unknown-u32-coverage-0) (the-as uint (-> sv-164 pat)))
    (set! (-> arg0 unknown-vector-coverage-1 quad) (-> sv-164 normal quad))
    0)
  (when (and (not (logtest? sv-32 512))
             (and (or (< (* 1.25 (-> arg1 best-from-prim local-sphere w)) (-> arg0 unknown-float-coverage-0))
                      (= (shr (shl (the-as int (-> arg0 unknown-float-coverage-1)) 58) 61) 1))
                  (and (< (-> arg0 unknown-float-coverage-2) (* 2.0 (-> arg1 best-from-prim local-sphere w)))
                       (zero? (shr (shl (-> arg0 unknown-u32-coverage-0) 58) 61)))))
    (set! sv-32 (logior sv-32 128))
    (set! (-> arg0 unknown-dword-coverage) (the-as int (current-time)))
    (set! sv-40 (logior sv-40 128))
    (set-time! (-> arg0 unknown-dword21))
    (let ((f30-0 (vector-dot sv-52 (-> arg0 unknown-vector22)))
          (f0-21 (if (logtest? sv-32 2) (cos (- 16384.0 (acos (-> arg0 coverage)))) (-> arg0 coverage)))
          (f1-11 (vector-dot (-> arg0 dynam gravity-normal)
                             (vector-! (new 'stack-no-clear 'vector) (-> arg0 trans) (-> arg1 best-tri intersect)))))
      (if (or (not (logtest? sv-32 32)) (< 0.5 f0-21)) (set! sv-48 (the-as symbol #f)))
      (when (and (or (and (< f0-21 0.95) (>= f30-0 0.0))
                     (and (logtest? sv-32 32) (< f0-21 0.3))
                     (< f1-11 (/ (-> arg1 best-from-prim local-sphere w) -4)))
                 (>= (vector-dot sv-52 sv-16) -0.000001))
        (set! (-> arg0 surf) *edge-surface*)
        (set! sv-32 (logior sv-32 1024))
        (set! sv-48 (the-as symbol #f))
        (when (logtest? sv-32 32)
          (set! sv-48 #t)
          (set! sv-32 (logior sv-32 4096))))))
  (if (< (-> arg0 surface-angle) 0.0) (set! sv-48 #t))
  (when sv-48
    (cond
      ((and (or (= (-> arg0 poly-pat mode) (pat-mode ground))
                (and (logtest? sv-32 8)
                     (>= (* 1.25 (-> arg1 best-from-prim local-sphere w)) (-> arg0 unknown-float-coverage-0))
                     (zero? (shr (shl (the-as int (-> arg0 unknown-float-coverage-1)) 58) 61))
                     (< 0.3 (fabs (-> arg0 surface-angle)))))
            (not (logtest? sv-32 128)))
       (set! sv-32 (logior sv-32 64))
       (set! sv-40 (logior sv-40 128))
       (set-time! (-> arg0 unknown-dword21))
       (set! sv-48 (the-as symbol #f)))
      (#t (set! sv-32 (logior sv-32 64)) (set! sv-40 (logior sv-40 128)) (set-time! (-> arg0 unknown-dword21)))))
  (set! (-> sv-24 0) sv-40)
  (set! (-> sv-20 0) sv-32)
  (set! (-> sv-28 0) sv-48)
  (the-as uint 0))

(defun target-collision-reaction ((arg0 control-info) (arg1 collide-shape-intersect) (arg2 vector) (arg3 vector))
  (local-vars (sv-80 vector) (sv-84 vector) (sv-88 matrix) (sv-96 int) (sv-104 int) (sv-160 symbol))
  (set! sv-80 (new-stack-vector0))
  (set! sv-84 (new-stack-vector0))
  (let ((v1-2 (new 'stack-no-clear 'matrix)))
    (dotimes (a0-1 2)
      (set! (-> v1-2 vector a0-1 quad) (the-as uint128 0)))
    (set! sv-88 v1-2))
  (set! sv-96 0)
  (set! sv-104 0)
  (set! (-> sv-88 vector 0 quad) (-> arg3 quad))
  (set! (-> sv-88 vector 1 quad) (-> arg3 quad))
  (let ((a1-3 (new 'stack-no-clear 'vector)))
    (vector-float*! a1-3 (-> arg1 move-vec) (-> arg1 best-u))
    (move-by-vector! arg0 a1-3))
  (set-and-handle-pat! arg0 (-> arg1 best-tri pat))
  (if (= (-> arg0 poly-pat mode) (pat-mode wall)) (set! sv-104 (logior sv-104 1)))
  (if (logtest? (-> arg0 unknown-surface00 flags) (surface-flags jump)) (set! sv-104 (logior sv-104 32)))
  (let ((v1-23 (new 'stack-no-clear 'vector)))
    (set! (-> v1-23 quad) (-> arg1 best-from-prim prim-core world-sphere quad))
    (vector-! sv-80 v1-23 (-> arg1 best-tri intersect)))
  (vector-normalize! sv-80 1.0)
  (set! (-> arg0 coverage) (vector-dot sv-80 (-> arg1 best-tri normal)))
  (when (< (-> arg0 coverage) 0.0)
    (set! (-> arg0 coverage) 0.0)
    (vector-flatten! sv-80 sv-80 (-> arg1 best-tri normal))
    (vector-normalize! sv-80 1.0))
  (if (< (-> arg0 coverage) 0.9999) (set! sv-104 (logior sv-104 24)))
  (let ((v1-33 (-> sv-80 quad))) (set! (-> sv-84 quad) v1-33))
  (if (= (-> arg1 best-u) 0.0) (move-by-vector! arg0 (vector-normalize-copy! (new-stack-vector0) sv-84 3.0)))
  (set! (-> arg0 poly-normal quad) (-> arg1 best-tri normal quad))
  (collide-shape-moving-angle-set! arg0 sv-84 (the-as vector (-> sv-88 vector)))
  (if (< (-> arg0 poly-angle) -0.2) (set! sv-96 (logior sv-96 16)))
  (if (< (-> arg0 poly-angle) 0.0) (set! sv-96 (logior sv-96 #x4000)))
  (set! sv-160 (< (fabs (-> arg0 surface-angle)) (-> *pat-mode-info* (-> arg0 cur-pat mode) wall-angle)))
  (if (and sv-160 (and (= (-> arg0 unknown-surface00 mode) 'dive) (< 0.2 (fabs (-> arg0 surface-angle)))))
    (set! sv-160 (the-as symbol #f)))
  (if sv-160 (set! sv-104 (logior sv-104 2)))
  (if (logtest? sv-104 8)
    (target-collision-low-coverage arg0
                                   arg1
                                   sv-84
                                   (the-as (pointer uint32) (& sv-104))
                                   (the-as (pointer uint64) (& sv-96))
                                   (& sv-160)))
  (when (not (logtest? (-> arg0 prev-status) (cshape-moving-flags onsurf)))
    (set! (-> arg0 ground-impact-vel) (- (vector-dot (-> arg0 transv) (-> arg0 dynam gravity-normal))))
    (set! sv-96 (logior sv-96 2048))
    (when (not sv-160)
      (let ((f30-0 (- 1.0 (-> arg0 surf impact-fric))))
        (when (< f30-0 1.0)
          (let ((s3-1 (new-stack-vector0))
                (f28-0 (vector-dot (-> arg0 dynam gravity-normal) (the-as vector (-> sv-88 vector)))))
            0.0
            (vector-! s3-1 (the-as vector (-> sv-88 vector)) (vector-float*! s3-1 (-> arg0 dynam gravity-normal) f28-0))
            (let* ((f0-20 (vector-length s3-1))
                   (f1-9 f0-20))
              (if (< f28-0 0.0) (set! f28-0 (* f28-0 f30-0)))
              (vector+! (the-as vector (-> sv-88 vector))
                        (vector-float*! (the-as vector (-> sv-88 vector)) (-> arg0 dynam gravity-normal) f28-0)
                        (vector-float*! s3-1 s3-1 (/ f0-20 f1-9)))))))))
  (set! sv-96 (logior sv-96 4))
  (cond
    ((-> arg1 best-to-prim)
     (set! sv-96 (logior sv-96 32))
     (set! (-> arg0 unknown-vector72 quad) (-> arg1 best-tri intersect quad))
     (set! (-> arg0 unknown-vector73 quad) (-> arg0 poly-normal quad))
     (set! (-> arg0 unknown-handle00) (process->handle (-> arg1 best-to-prim cshape process))))
    ((= (-> arg0 poly-pat material) (pat-material waterbottom)))
    (else (set! sv-96 (logior sv-96 4096))))
  (cond
    (sv-160
     (set! sv-104 (logior sv-104 4))
     (set! sv-96 (logior sv-96 8))
     (set! (-> arg0 cur-pat mode) 1)
     (set! (-> arg0 unknown-vector70 quad) (-> arg1 best-tri intersect quad))
     (set! (-> arg0 unknown-vector71 quad) (-> arg0 poly-normal quad))
     (set! (-> arg0 unknown-vector121 quad) (-> sv-84 quad))
     (set! (-> arg0 wall-pat) (-> arg1 best-tri pat))
     (-> arg0 history-data (logand (+ (-> arg0 unknown-halfword00) 127) 127))
     (cond
       (#f
        (sound-play "cursor-options")
        (set! sv-104 (logior sv-104 8192))
        (vector-reflect-flat-above! arg2 (the-as vector (-> sv-88 vector)) sv-84))
       (else (vector-reflect-flat! arg2 (the-as vector (-> sv-88 vector)) sv-84)))
     (cond
       ((not (and (>= (-> arg1 best-from-prim local-sphere w)
                      (vector-dot (-> arg0 ground-poly-normal)
                                  (vector-! (new 'stack-no-clear 'vector) (-> arg1 best-tri intersect) (-> arg0 ground-touch-point))))
                  (and (< 0.0 (vector-dot (-> arg0 ground-poly-normal) arg2))
                       (not (time-elapsed? (-> arg0 unknown-dword10) (seconds 0.3)))
                       (not (logtest? sv-104 32))))))
       (else
        (set! sv-104 (logior sv-104 256))
        (set! sv-104 (logand -65 sv-104))
        (let ((s3-4 (vector-cross! (new 'stack-no-clear 'vector) (-> arg0 poly-normal) (-> arg0 ground-poly-normal))))
          (vector-normalize! s3-4 1.0)
          (vector-float*! arg2 s3-4 (vector-dot (the-as vector (-> sv-88 vector)) s3-4)))
        (vector+! arg2 arg2 (-> arg0 poly-normal)))))
    (else
     (set! sv-96 (logior sv-96 1))
     (set! (-> arg0 cur-pat mode) 0)
     (if (= (-> arg1 best-from-prim prim-id) 6) (set! (-> arg0 local-normal quad) (-> sv-84 quad)))
     (vector-reflect-flat! arg2 (the-as vector (-> sv-88 vector)) sv-84)
     (vector+! arg2 arg2 sv-84)
     (set! (-> arg0 ground-touch-point w) 0.0)
     (when (not (or (logtest? sv-104 15) (nonzero? (-> arg0 poly-pat event))))
       (set! sv-96 (logior sv-96 2))
       (set! (-> arg0 ground-poly-normal quad) (-> arg0 poly-normal quad))
       (set! (-> arg0 unknown-vector53 quad) (-> sv-84 quad))
       (set! (-> arg0 unknown-float60) (vector-dot sv-84 (-> arg0 dynam gravity-normal)))
       (set-time! (-> arg0 unknown-dword10))
       (set! (-> arg0 ground-pat) (-> arg0 poly-pat))
       (set! (-> arg0 ground-touch-point quad) (-> arg1 best-tri intersect quad))
       (set! (-> arg0 unknown-vector55 quad) (-> arg1 best-from-prim prim-core world-sphere quad))
       (set! sv-104 (logior sv-104 2048))
       (if (= (-> arg0 poly-pat material) (pat-material waterbottom)) (set! sv-96 (logior sv-96 1024))))))
  (logior! (-> arg0 status) sv-96)
  (set! (-> arg0 reaction-flag) (the-as cshape-reaction-flags sv-104))
  (update! (-> arg0 history-data (-> arg0 unknown-halfword00)) arg0 (-> arg1 best-tri intersect) (-> sv-88 vector 1) arg2)
  (set! (-> arg0 unknown-halfword00) (logand (+ (-> arg0 unknown-halfword00) 1) 127))
  (the-as cshape-moving-flags sv-96))

(defun target-collision-no-reaction ((arg0 control-info) (arg1 collide-shape-intersect) (arg2 vector) (arg3 vector))
  (if (= (-> arg0 unknown-surface00 mode) 'air) (logior! (-> arg0 reaction-flag) (cshape-reaction-flags csrf05)))
  (let ((s5-0 (-> arg0 history-data (-> arg0 unknown-halfword00))))
    (update! s5-0 arg0 (-> arg0 trans) arg3 arg2)
    (logior! (-> s5-0 status) (cshape-moving-flags csmf08)))
  (set! (-> arg0 unknown-halfword00) (logand (+ (-> arg0 unknown-halfword00) 1) 127))
  0
  (none))
