;;-*-Lisp-*-
(in-package goal)

;; name: mood.gc
;; name in dgo: mood
;; dgos: GAME, ENGINE
;; note: modified for high fps

;; DECOMP BEGINS

(defun clear-mood-times ((arg0 mood-context))
  (dotimes (v1-0 8)
    (set! (-> arg0 times v1-0 w) 0.0)
    )
  #f
  )

(defun update-light-kit ((arg0 light-group) (arg1 light) (arg2 float))
  (set! (-> arg0 ambi color quad) (-> arg1 color quad))
  (set! (-> arg0 ambi levels x) (* (-> arg1 levels x) arg2))
  (none)
  )

(defun set-target-light-index ((arg0 int))
  (when *target*
    (set! (-> *target* draw light-index) (the-as uint arg0))
    (when (-> *target* sidekick)
      (set! (-> *target* sidekick 0 draw light-index) (the-as uint arg0))
      arg0
      )
    )
  )

;; WARN: Function may read a register that is not set: f31
(defun update-mood-itimes ((arg0 mood-context))
  (local-vars
    (r0-0 int)
    (r0-1 int)
    (r0-2 int)
    (v1-0 uint128)
    (v1-1 uint128)
    (v1-2 uint128)
    (v1-3 uint128)
    (a1-0 uint128)
    (a1-1 uint128)
    (a1-2 uint128)
    (a1-3 uint128)
    (a2-0 uint128)
    (a2-1 uint128)
    (a3-0 uint128)
    (a3-1 uint128)
    (t0-0 uint128)
    (t0-1 uint128)
    (t1-0 uint128)
    (t1-1 uint128)
    (t2-0 uint128)
    (t2-1 uint128)
    (t3-0 uint128)
    (t3-1 uint128)
    (f31-0 none)
    )
   ;; pc mood debug
   (with-pc
     (case *mood-override-debug*
        (('copy #t)
          (dotimes (mti 8)
              (set! (-> arg0 times mti w) (-> *mood-override-table* mti)))
          )
        (('mult)
          (dotimes (mti 8)
              (*! (-> arg0 times mti w) (-> *mood-override-table* mti)))
          )))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         )
    (nop!)
    (nop!)
    (.lvf vf1 (&-> arg0 times 0 quad))
    (nop!)
    (.lvf vf2 (&-> arg0 times 1 quad))
    (.mul.w.vf vf1 vf1 vf1 :mask #b111)
    (.lvf vf3 (&-> arg0 times 2 quad))
    (.mul.w.vf vf2 vf2 vf2 :mask #b111)
    (.lvf vf4 (&-> arg0 times 3 quad))
    (.mul.w.vf vf3 vf3 vf3 :mask #b111)
    (.lvf vf5 (&-> arg0 times 4 quad))
    (.mul.w.vf vf4 vf4 vf4 :mask #b111)
    (.lvf vf6 (&-> arg0 times 5 quad))
    (.mul.w.vf vf5 vf5 vf5 :mask #b111)
    (.lvf vf7 (&-> arg0 times 6 quad))
    (.mul.w.vf vf6 vf6 vf6 :mask #b111)
    (.lvf vf8 (&-> arg0 times 7 quad))
    (.mul.w.vf vf7 vf7 vf7 :mask #b111)
    (nop!)
    (.mul.w.vf vf8 vf8 vf8 :mask #b111)
    (nop!)
    (vftoi12.xyzw vf1 vf1)
    (nop!)
    (vftoi12.xyzw vf2 vf2)
    (nop!)
    (vftoi12.xyzw vf3 vf3)
    (nop!)
    (vftoi12.xyzw vf4 vf4)
    (nop!)
    (vftoi12.xyzw vf5 vf5)
    (nop!)
    (vftoi12.xyzw vf6 vf6)
    (nop!)
    (vftoi12.xyzw vf7 vf7)
    (nop!)
    (vftoi12.xyzw vf8 vf8)
    (nop!)
    (.mov v1-0 vf1)
    (nop!)
    (.mov a1-0 vf2)
    (nop!)
    (.mov a2-0 vf3)
    (.pw.sra v1-1 v1-0 6)
    (.mov a3-0 vf4)
    (.pw.sra a1-1 a1-0 6)
    (.mov t0-0 vf5)
    (.pw.sra a2-1 a2-0 6)
    (.mov t1-0 vf6)
    (.pw.sra a3-1 a3-0 6)
    (.mov t2-0 vf7)
    (.pw.sra t0-1 t0-0 6)
    (.mov t3-0 vf8)
    (.pw.sra t1-1 t1-0 6)
    (.pw.sra t2-1 t2-0 6)
    (.mov r0-0 f31-0)
    (.pw.sra t3-1 t3-0 6)
    (.mov r0-1 f31-0)
    (.ppach v1-2 a1-1 v1-1)
    (.mov r0-2 f31-0)
    (.ppach a1-2 a3-1 a2-1)
    (set! (-> arg0 itimes 0 quad) v1-2)
    (.ppach v1-3 t1-1 t0-1)
    (set! (-> arg0 itimes 1 quad) a1-2)
    (.ppach a1-3 t3-1 t2-1)
    (set! (-> arg0 itimes 2 quad) v1-3)
    (nop!)
    (set! (-> arg0 itimes 3 quad) a1-3)
    0
    (none)
    )
  )

(defun update-mood-prt-color ((arg0 mood-context))
  (let* ((v1-0 (-> arg0 light-group))
         (s4-0 (-> v1-0 0 ambi color))
         (s5-0 (new 'stack-no-clear 'vector))
         )
    (vector4-lerp! s5-0 (-> v1-0 0 dir0 color) (-> v1-0 0 dir1 color) (-> v1-0 0 dir1 levels x))
    (set! (-> arg0 current-prt-color x) (* 0.5 (+ (-> s4-0 x) (* 0.5 (+ (-> s4-0 x) (-> s5-0 x))))))
    (set! (-> arg0 current-prt-color y) (* 0.5 (+ (-> s4-0 y) (* 0.5 (+ (-> s4-0 y) (-> s5-0 y))))))
    (set! (-> arg0 current-prt-color z) (* 0.5 (+ (-> s4-0 z) (* 0.5 (+ (-> s4-0 z) (-> s5-0 z))))))
    (set! (-> arg0 current-prt-color w) (* 0.5 (+ (-> s4-0 w) (* 0.5 (+ (-> s4-0 w) (-> s5-0 w))))))
    )
  (let ((v0-1 (-> arg0 current-shadow-color)))
    (set! (-> v0-1 quad) (-> arg0 current-prt-color quad))
    v0-1
    )
  )

(defun update-mood-palette ((arg0 mood-context) (arg1 float) (arg2 int))
  (let ((v1-0 (-> arg0 light-group)))
    (set! (-> v1-0 0 dir0 levels x) 0.0)
    (set! (-> v1-0 0 dir1 levels x) 0.0)
    (set! (-> v1-0 0 dir2 levels x) 0.0)
    )
  0
  0
  0.0
  (let* ((s4-0 (-> arg0 light-group))
         (v1-3 (the int arg1))
         (f0-7 (- arg1 (the float v1-3)))
         (f1-3 (- 1.0 f0-7))
         (a0-2 (/ v1-3 24))
         (v1-7 (-> arg0 palette-interp hour (- v1-3 (* 24 a0-2))))
         (s3-0 (-> v1-7 snapshot1))
         (s2-0 (-> v1-7 snapshot2))
         (f30-0 (+ (* f1-3 (-> v1-7 morph-start)) (* f0-7 (-> v1-7 morph-end))))
         )
    (cond
      ((= s3-0 s2-0)
       (let ((v1-12 (-> arg0 mood-lights-table data s3-0)))
         (set! (-> arg0 times s3-0 w) 1.0)
         (set! (-> arg0 current-prt-color quad) (-> v1-12 prt-color quad))
         (set! (-> s4-0 0 ambi color quad) (-> v1-12 amb-color quad))
         (set! (-> s4-0 0 ambi levels x) 1.0)
         (set! (-> arg0 current-shadow quad) (-> v1-12 shadow quad))
         (let ((f0-14 (+ (* 2.0 (-> v1-12 lgt-color x)) (* 4.0 (-> v1-12 lgt-color y)) (-> v1-12 lgt-color z))))
           (set! (-> s4-0 0 dir0 direction quad) (-> v1-12 direction quad))
           (set! (-> s4-0 0 dir0 color quad) (-> v1-12 lgt-color quad))
           (set! (-> s4-0 0 dir0 levels x) 1.0)
           (set! (-> s4-0 0 dir0 levels y) f0-14)
           )
         )
       (set! (-> *time-of-day-context* light-masks-0 arg2) (the-as uint (ash 1 s3-0)))
       (set! (-> *time-of-day-context* light-masks-1 arg2) (the-as uint 0))
       (set! (-> *time-of-day-context* light-interp arg2) 0.0)
       )
      (else
        (let ((s0-0 (-> arg0 mood-lights-table data s3-0))
              (s1-0 (-> arg0 mood-lights-table data s2-0))
              )
          (let ((v1-29 (the int (+ 0.5 (* 64.0 f30-0)))))
            (set! (-> arg0 times s3-0 w) (* 0.015625 (the float (- 64 v1-29))))
            (set! (-> arg0 times s2-0 w) (* 0.015625 (the float v1-29)))
            )
          (vector4-lerp! (-> arg0 current-prt-color) (-> s0-0 prt-color) (-> s1-0 prt-color) f30-0)
          (vector4-lerp! (-> s4-0 0 ambi color) (-> s0-0 amb-color) (-> s1-0 amb-color) f30-0)
          (set! (-> s4-0 0 ambi levels x) 1.0)
          (vector4-lerp! (-> arg0 current-shadow) (-> s0-0 shadow) (-> s1-0 shadow) f30-0)
          (let ((f0-28
                  (* (+ (* 2.0 (-> s0-0 lgt-color x)) (* 4.0 (-> s0-0 lgt-color y)) (-> s0-0 lgt-color z)) (- 1.0 f30-0))
                  )
                (f1-26 (* (+ (* 2.0 (-> s1-0 lgt-color x)) (* 4.0 (-> s1-0 lgt-color y)) (-> s1-0 lgt-color z)) f30-0))
                )
            (set! (-> s4-0 0 dir0 direction quad) (-> s0-0 direction quad))
            (set! (-> s4-0 0 dir0 color quad) (-> s0-0 lgt-color quad))
            (set! (-> s4-0 0 dir0 levels x) (- 1.0 f30-0))
            (set! (-> s4-0 0 dir0 levels y) f0-28)
            (set! (-> s4-0 0 dir1 direction quad) (-> s1-0 direction quad))
            (set! (-> s4-0 0 dir1 color quad) (-> s1-0 lgt-color quad))
            (set! (-> s4-0 0 dir1 levels x) f30-0)
            (set! (-> s4-0 0 dir1 levels y) f1-26)
            )
          )
        (set! (-> *time-of-day-context* light-masks-0 arg2) (the-as uint (ash 1 s3-0)))
        (set! (-> *time-of-day-context* light-masks-1 arg2) (the-as uint (ash 1 s2-0)))
        (set! (-> *time-of-day-context* light-interp arg2) f30-0)
        )
      )
    (if (and (= (-> arg0 current-prt-color x) 0.0)
             (= (-> arg0 current-prt-color y) 0.0)
             (= (-> arg0 current-prt-color z) 0.0)
             )
        (update-mood-prt-color arg0)
        )
    f30-0
    )
  )

(defun update-mood-sky-texture ((arg0 mood-context) (arg1 float))
  (dotimes (v1-0 8)
    (set! (-> arg0 sky-times v1-0) 0.0)
    )
  0
  0
  0.0
  (let* ((v1-5 (the int arg1))
         (f0-5 (- arg1 (the float v1-5)))
         (f1-3 (- 1.0 f0-5))
         (a0-4 (/ v1-5 24))
         (v1-9 (-> arg0 sky-texture-interp hour (- v1-5 (* 24 a0-4))))
         (s5-0 (-> v1-9 snapshot1))
         (s4-0 (-> v1-9 snapshot2))
         (f30-0 (+ (* f1-3 (-> v1-9 morph-start)) (* f0-5 (-> v1-9 morph-end))))
         )
    (cond
      ((= s5-0 s4-0)
       (set! (-> arg0 sky-times s5-0) 1.0)
       (set! (-> arg0 current-sun sun-color quad) (-> arg0 mood-sun-table data s5-0 sun-color quad))
       (let ((v0-0 (-> arg0 current-sun env-color)))
         (set! (-> v0-0 quad)
               (-> (the-as (pointer uint128) (+ (the-as uint (-> arg0 mood-sun-table data 0 env-color)) (* s5-0 32))))
               )
         v0-0
         )
       )
      (else
        (set! (-> arg0 sky-times s5-0) (- 1.0 f30-0))
        (set! (-> arg0 sky-times s4-0) f30-0)
        (vector4-lerp!
          (the-as vector (-> arg0 current-sun))
          (the-as vector (-> arg0 mood-sun-table data s5-0))
          (the-as vector (-> arg0 mood-sun-table data s4-0))
          f30-0
          )
        (vector4-lerp!
          (-> arg0 current-sun env-color)
          (the-as vector (+ (the-as uint (-> arg0 mood-sun-table data 0 env-color)) (* s5-0 32)))
          (the-as vector (+ (the-as uint (-> arg0 mood-sun-table data 0 env-color)) (* s4-0 32)))
          f30-0
          )
        )
      )
    )
  )

(defun update-mood-fog ((arg0 mood-context) (arg1 float))
  0
  0
  0.0
  (let* ((v1-2 (the int arg1))
         (f0-4 (- arg1 (the float v1-2)))
         (f1-3 (- 1.0 f0-4))
         (a1-2 (/ v1-2 24))
         (a2-1 (-> arg0 fog-interp hour (- v1-2 (* 24 a1-2))))
         (a1-5 (-> a2-1 snapshot1))
         (v1-6 (-> a2-1 snapshot2))
         (f30-0 (+ (* f1-3 (-> a2-1 morph-start)) (* f0-4 (-> a2-1 morph-end))))
         (gp-0 (-> arg0 current-fog))
         (s5-0 (-> arg0 mood-fog-table data a1-5))
         (s4-0 (-> arg0 mood-fog-table data v1-6))
         )
    (vector4-lerp! (-> gp-0 fog-color) (-> s5-0 fog-color) (-> s4-0 fog-color) f30-0)
    (vector4-lerp! (-> gp-0 fog-dists) (-> s5-0 fog-dists) (-> s4-0 fog-dists) f30-0)
    (vector4-lerp! (-> gp-0 erase-color) (-> s5-0 erase-color) (-> s4-0 erase-color) f30-0)
    )
  )

(defun update-mood-quick ((arg0 mood-context) (arg1 int) (arg2 int) (arg3 int) (arg4 int))
  (let ((v1-0 (-> arg0 light-group)))
    (set! (-> arg0 current-fog fog-color quad) (-> arg0 mood-fog-table data arg1 fog-color quad))
    (set! (-> arg0 current-fog fog-dists quad)
          (-> (the-as (pointer uint128) (+ (the-as uint (-> arg0 mood-fog-table data 0 fog-dists)) (* 48 arg1))))
          )
    (set! (-> arg0 current-fog erase-color quad)
          (-> (the-as (pointer uint128) (+ (the-as uint (-> arg0 mood-fog-table data 0 erase-color)) (* 48 arg1))))
          )
    (set! (-> arg0 current-prt-color quad)
          (-> (the-as (pointer uint128) (+ (the-as uint (-> arg0 mood-lights-table data 0 prt-color)) (* 80 arg3))))
          )
    (set! (-> arg0 current-sun sun-color quad) (-> arg0 mood-sun-table data arg2 sun-color quad))
    (set! (-> arg0 current-sun env-color quad)
          (-> (the-as (pointer uint128) (+ (the-as uint (-> arg0 mood-sun-table data 0 env-color)) (* arg2 32))))
          )
    (set! (-> arg0 current-shadow quad)
          (-> (the-as (pointer uint128) (+ (the-as uint (-> arg0 mood-lights-table data 0 shadow)) (* 80 arg3))))
          )
    (let ((a1-11 (-> arg0 mood-lights-table data arg3)))
      (let ((f0-3 (+ (* 2.0 (-> a1-11 lgt-color x)) (* 4.0 (-> a1-11 lgt-color y)) (-> a1-11 lgt-color z))))
        (set! (-> v1-0 0 dir0 direction quad) (-> a1-11 direction quad))
        (set! (-> v1-0 0 dir0 color quad) (-> a1-11 lgt-color quad))
        (set! (-> v1-0 0 dir0 levels x) 1.0)
        (set! (-> v1-0 0 dir0 levels y) f0-3)
        )
      (set! (-> v1-0 0 dir1 levels x) 0.0)
      (set! (-> v1-0 0 dir2 levels x) 0.0)
      (set! (-> v1-0 0 ambi color quad) (-> a1-11 amb-color quad))
      )
    (set! (-> v1-0 0 ambi levels x) 1.0)
    )
  (set! (-> *time-of-day-context* light-masks-0 arg4) (the-as uint (ash 1 arg3)))
  (set! (-> *time-of-day-context* light-masks-1 arg4) (the-as uint 0))
  (set! (-> *time-of-day-context* light-interp arg4) 0.0)
  (if (and (= (-> arg0 current-prt-color x) 0.0)
           (= (-> arg0 current-prt-color y) 0.0)
           (= (-> arg0 current-prt-color z) 0.0)
           )
      (update-mood-prt-color arg0)
      )
  )

(defun update-mood-interp ((arg0 mood-context) (arg1 mood-context) (arg2 mood-context) (arg3 float))
  (local-vars (sv-16 light))
  (cond
    ((= arg3 0.0)
     (set! (-> arg0 current-fog fog-color quad) (-> arg1 current-fog fog-color quad))
     (set! (-> arg0 current-fog fog-dists quad) (-> arg1 current-fog fog-dists quad))
     (set! (-> arg0 current-fog erase-color quad) (-> arg1 current-fog erase-color quad))
     (set! (-> arg0 current-prt-color quad) (-> arg1 current-prt-color quad))
     (set! (-> arg0 current-sun sun-color quad) (-> arg1 current-sun sun-color quad))
     (set! (-> arg0 current-sun env-color quad) (-> arg1 current-sun env-color quad))
     (set! (-> arg0 current-shadow quad) (-> arg1 current-shadow quad))
     (set! (-> arg0 current-shadow-color quad) (-> arg1 current-shadow-color quad))
     (quad-copy! (the-as pointer (-> arg0 light-group)) (the-as pointer (-> arg1 light-group)) 12)
     )
    ((= arg3 1.0)
     (set! (-> arg0 current-fog fog-color quad) (-> arg2 current-fog fog-color quad))
     (set! (-> arg0 current-fog fog-dists quad) (-> arg2 current-fog fog-dists quad))
     (set! (-> arg0 current-fog erase-color quad) (-> arg2 current-fog erase-color quad))
     (set! (-> arg0 current-prt-color quad) (-> arg2 current-prt-color quad))
     (set! (-> arg0 current-sun sun-color quad) (-> arg2 current-sun sun-color quad))
     (set! (-> arg0 current-sun env-color quad) (-> arg2 current-sun env-color quad))
     (set! (-> arg0 current-shadow quad) (-> arg2 current-shadow quad))
     (set! (-> arg0 current-shadow-color quad) (-> arg2 current-shadow-color quad))
     (quad-copy! (the-as pointer (-> arg0 light-group)) (the-as pointer (-> arg2 light-group)) 12)
     )
    (else
      (vector4-lerp!
        (the-as vector (-> arg0 current-fog))
        (the-as vector (-> arg1 current-fog))
        (the-as vector (-> arg2 current-fog))
        arg3
        )
      (vector4-lerp!
        (-> arg0 current-fog fog-dists)
        (-> arg1 current-fog fog-dists)
        (-> arg2 current-fog fog-dists)
        arg3
        )
      (vector4-lerp!
        (-> arg0 current-fog erase-color)
        (-> arg1 current-fog erase-color)
        (-> arg2 current-fog erase-color)
        arg3
        )
      (vector4-lerp! (-> arg0 current-prt-color) (-> arg1 current-prt-color) (-> arg2 current-prt-color) arg3)
      (vector4-lerp!
        (the-as vector (-> arg0 current-sun))
        (the-as vector (-> arg1 current-sun))
        (the-as vector (-> arg2 current-sun))
        arg3
        )
      (vector4-lerp!
        (-> arg0 current-sun env-color)
        (-> arg1 current-sun env-color)
        (-> arg2 current-sun env-color)
        arg3
        )
      (vector4-lerp! (-> arg0 current-shadow) (-> arg1 current-shadow) (-> arg2 current-shadow) arg3)
      (vector4-lerp!
        (-> arg0 current-shadow-color)
        (-> arg1 current-shadow-color)
        (-> arg2 current-shadow-color)
        arg3
        )
      (dotimes (s2-0 3)
        (let ((s1-0 (-> arg0 light-group 0 lights s2-0)))
          (let ((s0-0 (-> arg1 light-group 0 lights s2-0)))
            (set! sv-16 (-> arg2 light-group 0 lights s2-0))
            (vector4-lerp! (-> s1-0 direction) (-> s0-0 direction) (-> sv-16 direction) arg3)
            (vector4-lerp! (-> s1-0 color) (-> s0-0 color) (-> sv-16 color) arg3)
            (vector4-lerp! (-> s1-0 levels) (-> s0-0 levels) (-> sv-16 levels) arg3)
            )
          (vector-normalize! (-> s1-0 direction) 1.0)
          )
        )
      (vector4-lerp!
        (-> arg0 light-group 0 ambi color)
        (-> arg1 light-group 0 ambi color)
        (-> arg2 light-group 0 ambi color)
        arg3
        )
      (vector4-lerp!
        (-> arg0 light-group 0 ambi levels)
        (-> arg1 light-group 0 ambi levels)
        (-> arg2 light-group 0 ambi levels)
        arg3
        )
      )
    )
  (none)
  )

(deftype flames-state (structure)
  ((index  uint8  :offset-assert   0)
   (time   uint8  :offset-assert   1)
   (length uint8  :offset-assert   2)
   (height uint8  :offset-assert   3)
   )
  :method-count-assert 9
  :size-assert         #x4
  :flag-assert         #x900000004
  )


(defun update-mood-flames ((arg0 mood-context) (arg1 int) (arg2 int) (arg3 int) (arg4 float) (arg5 float) (arg6 float))
  (let* ((s5-0 (the-as flames-state (&-> arg0 state arg3)))
         (s4-0 (+ (-> s5-0 index) arg1))
         (a0-1 (-> s5-0 time))
         (v1-2 (-> s5-0 length))
         (s0-0 (-> s5-0 height))
         )
    (dotimes (a3-1 arg2)
      (set! (-> arg0 times (+ arg1 a3-1) w) arg4)
      )
    (cond
      ((>= a0-1 v1-2)
       (set! (-> s5-0 index) (the-as uint (the int (rand-vu-float-range 0.0 (+ -0.01 (the float arg2))))))
       (set! (-> s5-0 time) (the-as uint 0))
       (set! (-> s5-0 length) (the-as uint (the int (* (rand-vu-float-range 7.0 15.0) arg6))))
       (set! (-> s5-0 height) (the-as uint (the int (rand-vu-float-range 0.0 255.0))))
       (set! (-> arg0 times s4-0 w) arg4)
       )
      (else
        (let ((f0-13 (sin (* 32768.0 (/ (the float a0-1) (the float v1-2))))))
          (set! (-> arg0 times s4-0 w) (+ (* (the float s0-0) f0-13 arg5) arg4))
          )
        (if (not (paused?))
            (+! (-> s5-0 time) 1)
            )
        )
      )
    )
  (none)
  )

(define *flash0*
  (new 'static 'boxed-array :type float 1.0 0.0 0.5 1.0 0.5 0.0 0.5 0.35 0.4 0.35 0.25 0.1 0.04)
  )

(define *flash1* (new 'static 'boxed-array :type float 1.0 0.8 0.0 1.0 0.5 1.0 0.4 0.2 0.1))

(define *flash2* (new 'static 'boxed-array :type float 1.0 0.9 0.8 0.7 0.0 0.0 1.0 0.0 1.0 0.5))

(define *flash3* (new 'static 'boxed-array :type float 0.5 0.0 1.0 0.9 1.0 0.8 0.3 0.0 0.0 0.5 0.1 0.5 0.35))

(define *flash4*
  (new 'static 'boxed-array :type float 1.0 0.0 1.0 0.0 1.0 0.9 0.8 0.7 0.6 0.5 0.4 0.3 0.2 0.5 0.4 0.3 0.2 0.1)
  )

(define *flash5* (new 'static 'boxed-array :type float
                   1.0
                   0.0
                   1.0
                   0.0
                   1.0
                   0.95
                   0.9
                   0.85
                   0.8
                   0.75
                   0.7
                   0.65
                   0.6
                   0.55
                   0.5
                   0.45
                   0.4
                   0.35
                   0.3
                   0.25
                   0.2
                   0.5
                   0.45
                   0.4
                   0.35
                   0.3
                   0.25
                   0.2
                   0.15
                   0.1
                   0.05
                   )
        )

(define *flash6*
  (new 'static 'boxed-array :type float 1.0 0.0 1.0 0.0 0.5 0.0 0.5 0.35 0.0 0.0 1.0 0.0 0.2 0.1)
  )

(define *flash7*
  (new 'static 'boxed-array :type float 1.0 0.8 0.3 0.0 0.6 0.5 0.4 0.3 0.2 0.5 0.4 0.3 0.2 0.1)
  )

(define *lightning-index* 0)

(define *lightning-time* 0)

(define *lightning-time2* 0)

(define *lightning-frame-done* #f)

(define *lightning-realtime-done* #f)

(define *thunder-id0* (new-sound-id))

(define *thunder-id1* (new-sound-id))

(define *thunder-id2* (new-sound-id))

(define *thunder-id* (new 'static 'sound-id))

(define *thunder-count* 0)

(deftype lightning-state (structure)
  ((val uint8  :offset-assert   0)
   )
  :pack-me
  :method-count-assert 9
  :size-assert         #x1
  :flag-assert         #x900000001
  )


(defun update-mood-lightning ((arg0 mood-context) (arg1 int) (arg2 int) (arg3 int) (arg4 int) (arg5 float) (arg6 symbol))
  (local-vars (a3-2 (array float)))
  (with-pp
    (set! (-> arg0 light-group 0 dir2 levels x) 0.0)
    (let* ((s4-0 (&-> arg0 state arg3))
           (a1-1 (+ *lightning-index* arg1))
           (v1-3 (+ *lightning-index* arg4))
           (a3-1 (-> s4-0 0))
           (a2-2 (/ *lightning-time* 2))
           )
      (cond
        ((zero? *lightning-time2*)
         (cond
           ((zero? a3-1)
            (set! a3-2 *flash0*)
            )
           ((= a3-1 1)
            (set! a3-2 *flash1*)
            )
           ((= a3-1 2)
            (set! a3-2 *flash2*)
            )
           ((= a3-1 3)
            (set! a3-2 *flash3*)
            )
           ((= a3-1 4)
            (set! a3-2 *flash4*)
            )
           ((= a3-1 5)
            (set! a3-2 *flash5*)
            )
           ((= a3-1 6)
            (set! a3-2 *flash6*)
            )
           (else
             (set! a3-2 *flash7*)
             )
           )
         (cond
           ((< a2-2 (-> a3-2 length))
            (let ((f0-1 (-> a3-2 a2-2)))
              (set! (-> arg0 sky-times a1-1) f0-1)
              (when (not arg6)
                (set! (-> arg0 times v1-3 w) f0-1)
                (when (not *lightning-realtime-done*)
                  (let* ((a1-11 (-> arg0 mood-lights-table data v1-3))
                         (v1-6 (-> arg0 light-group 0 dir2))
                         (f1-4 (* (+ (* 2.0 (-> a1-11 lgt-color x)) (* 4.0 (-> a1-11 lgt-color y)) (-> a1-11 lgt-color z)) f0-1))
                         )
                    (set! (-> v1-6 direction quad) (-> a1-11 direction quad))
                    (set! (-> v1-6 color quad) (-> a1-11 lgt-color quad))
                    (set! (-> v1-6 levels x) f0-1)
                    (set! (-> v1-6 levels y) f1-4)
                    )
                  (set! *lightning-realtime-done* #t)
                  )
                )
              )
            (if (not (or (paused?) *lightning-frame-done*))
                (set! *lightning-time* (+ *lightning-time* 1))
                )
            )
           (arg6
             (set! *lightning-time2* (the int (rand-vu-float-range 360.0 960.0)))
             )
           (else
             (set! *lightning-time2* (the int (rand-vu-float-range 180.0 480.0)))
             )
           )
         )
        (else
          (when (not (or (paused?) *lightning-frame-done*))
            (set! *lightning-time2* (+ *lightning-time2* -1))
            (when (zero? *lightning-time2*)
              (set! *lightning-index* (mod (+ *lightning-index* 1) arg2))
              (set! (-> s4-0 0) (logand (rand-uint31-gen *random-generator*) 7))
              (set! *lightning-time* 0)
              (let ((v1-24 *thunder-count*))
                (cond
                  ((zero? v1-24)
                   (set! *thunder-id* *thunder-id0*)
                   (set! *thunder-count* 1)
                   )
                  ((= v1-24 1)
                   (set! *thunder-id* *thunder-id1*)
                   (set! *thunder-count* 2)
                   )
                  (else
                    (set! *thunder-id* *thunder-id2*)
                    (set! *thunder-count* 0)
                    0
                    )
                  )
                )
              (when (>= (-> *math-camera* trans y) -81920.0)
                (if arg6
                    (sound-play
                      "thunder"
                      :id *thunder-id*
                      :vol (rand-vu-float-range 25.0 75.0)
                      :pitch (rand-vu-float-range -1.0 1.0)
                      )
                    (sound-play
                      "thunder"
                      :id *thunder-id*
                      :vol (rand-vu-float-range 200.0 400.0)
                      :pitch (rand-vu-float-range -1.0 1.0)
                      )
                    )
                )
              )
            )
          )
        )
      )
    (when (not *lightning-frame-done*)
      (let ((gp-3 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> gp-3 command) (sound-command set-param))
        (set! (-> gp-3 id) *thunder-id0*)
        (let ((a1-23 (camera-pos)))
          (let ((s5-3 pp))
            (when (= a1-23 #t)
              (if (and s5-3 (type-type? (-> s5-3 type) process-drawable) (nonzero? (-> (the-as process-drawable s5-3) root)))
                  (set! a1-23 (-> (the-as process-drawable s5-3) root trans))
                  (set! a1-23 (the-as vector #f))
                  )
              )
            )
          (sound-trans-convert (-> gp-3 parms trans) a1-23)
          )
        (set! (-> gp-3 parms mask) (sound-mask trans))
        (-> gp-3 id)
        )
      (let ((gp-4 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> gp-4 command) (sound-command set-param))
        (set! (-> gp-4 id) *thunder-id1*)
        (let ((a1-25 (camera-pos)))
          (let ((s5-4 pp))
            (when (= a1-25 #t)
              (if (and s5-4 (type-type? (-> s5-4 type) process-drawable) (nonzero? (-> (the-as process-drawable s5-4) root)))
                  (set! a1-25 (-> (the-as process-drawable s5-4) root trans))
                  (set! a1-25 (the-as vector #f))
                  )
              )
            )
          (sound-trans-convert (-> gp-4 parms trans) a1-25)
          )
        (set! (-> gp-4 parms mask) (sound-mask trans))
        (-> gp-4 id)
        )
      (let ((gp-5 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> gp-5 command) (sound-command set-param))
        (set! (-> gp-5 id) *thunder-id2*)
        (let ((a1-27 (camera-pos)))
          (let ((s5-5 pp))
            (when (= a1-27 #t)
              (if (and s5-5 (type-type? (-> s5-5 type) process-drawable) (nonzero? (-> (the-as process-drawable s5-5) root)))
                  (set! a1-27 (-> (the-as process-drawable s5-5) root trans))
                  (set! a1-27 (the-as vector #f))
                  )
              )
            )
          (sound-trans-convert (-> gp-5 parms trans) a1-27)
          )
        (set! (-> gp-5 parms mask) (sound-mask trans))
        (-> gp-5 id)
        )
      )
    (set! *lightning-frame-done* #t)
    (none)
    )
  )

(deftype light-time-state (structure)
  ((time uint8  :offset-assert   0)
   )
  :pack-me
  :method-count-assert 9
  :size-assert         #x1
  :flag-assert         #x900000001
  )


(deftype light-state (structure)
  ((fade uint8  :offset-assert   0)
   )
  :pack-me
  :method-count-assert 9
  :size-assert         #x1
  :flag-assert         #x900000001
  )


(defun update-mood-light ((arg0 mood-context) (arg1 int) (arg2 int) (arg3 int) (arg4 float) (arg5 float) (arg6 float) (arg7 int))
  (let* ((gp-0 (&-> arg0 state arg2))
         (f0-1 (the float (* (logand (+ (-> arg0 state arg3) arg7) 255) 512)))
         (f0-4 (+ arg4 (* (cos f0-1) arg5)))
         (f30-1 (* 0.003921569 (the float (-> gp-0 0))))
         )
    (cond
      ((or (< 19.0 arg6) (< arg6 7.0))
       (cond
         ((and (= f30-1 0.0) (= f0-4 (- arg4 arg5)))
          (set! (-> arg0 times arg1 w) f0-4)
          (set! (-> gp-0 0) (the-as uint 255))
          )
         ((= f30-1 1.0)
          (set! (-> arg0 times arg1 w) f0-4)
          )
         )
       )
      ((= f30-1 1.0)
       (cond
         ((= f0-4 (+ arg4 arg5))
          (set! (-> arg0 times arg1 w) f0-4)
          (set! (-> gp-0 0) (the-as uint 254))
          )
         (else
           (set! (-> arg0 times arg1 w) f0-4)
           )
         )
       )
      ((and (!= f30-1 1.0) (!= f30-1 0.0))
       (set! (-> arg0 times arg1 w) f30-1)
       (when (not (paused?))
         (if (< 0.75 f30-1)
             (+! (-> gp-0 0) -3)
             (+! (-> gp-0 0) -1)
             )
         )
       )
      (else
        (set! (-> arg0 state arg3) (the-as uint 0))
        0
        )
      )
    )
  (none)
  )

(deftype lava-state (structure)
  ((scale      float 4 :offset-assert   0)
   (time       uint8   :offset-assert  16)
   (last-index uint8   :offset-assert  17)
   )
  :pack-me
  :method-count-assert 9
  :size-assert         #x12
  :flag-assert         #x900000012
  )


(define *lava-time* (the-as float 0))

(defun update-mood-lava ((arg0 mood-context) (arg1 int) (arg2 int) (arg3 symbol))
  (let* ((s4-0 (the-as lava-state (&-> arg0 state arg2)))
         (s1-0 (-> s4-0 time))
         (s2-0 (-> s4-0 last-index))
         )
    (when (not (paused?))
      (set! (-> s4-0 time) (+ s1-0 4))
      (set! *lava-time* (+ *lava-time* (rand-vu-float-range 64.0 2048.0)))
      )
    (let ((s0-0 (-> arg0 light-group 0 dir2))
          (f0-4 (+ 0.875 (* 0.125 (sin *lava-time*))))
          )
      (set-vector! (-> s0-0 direction) 0.0 -1.0 0.0 0.0)
      (set-vector! (-> s0-0 color) 1.0 0.364 0.0 1.0)
      (set! (-> s0-0 levels x) f0-4)
      )
    (let ((s0-1 (shr s1-0 6))
          (f30-2 (* 0.015625 (the float (logand s1-0 63))))
          )
      (when (!= s0-1 s2-0)
        (set! (-> s4-0 scale s0-1) (the float (the int (rand-vu-float-range 128.0 255.0))))
        (set! (-> s4-0 last-index) s0-1)
        )
      (when arg3
        (let* ((v1-14 (logand (+ s0-1 -1) 3))
               (f1-11 (* 0.0078125 (-> s4-0 scale s0-1)))
               (f0-11 (* 0.0078125 (-> s4-0 scale v1-14)))
               )
          (set! (-> arg0 times (+ arg1 s0-1) w) (* f30-2 f1-11))
          (set! (-> arg0 times (+ arg1 v1-14) w) (* (- 1.0 f30-2) f0-11))
          )
        )
      )
    )
  (none)
  )

(defun update-mood-caustics ((arg0 mood-context) (arg1 int) (arg2 int))
  (let* ((a2-1 (-> arg0 state arg2))
         (v1-2 (logand (shr a2-1 3) 3))
         (f0-1 (* 0.125 (the float (logand a2-1 7))))
         )
    (let ((a2-4 (logand (+ v1-2 -1) 3)))
      (set! (-> arg0 times (+ arg1 a2-4) w) (- 1.0 f0-1))
      )
    (set! (-> arg0 times (+ arg1 v1-2) w) f0-1)
    )
  (none)
  )

(defun update-mood-default ((arg0 mood-context) (arg1 float) (arg2 int))
  (update-mood-fog arg0 arg1)
  (update-mood-sky-texture arg0 arg1)
  (clear-mood-times arg0)
  (update-mood-palette arg0 arg1 arg2)
  (update-mood-itimes arg0)
  0
  (none)
  )

(deftype misty-states (structure)
  ((flames flames-state     :inline :offset-assert   0)
   (light0 light-state      :inline :offset-assert   4)
   (light1 light-state      :inline :offset-assert   5)
   (time0  light-time-state :inline :offset-assert   6)
   (time1  light-time-state :inline :offset-assert   7)
   )
  :method-count-assert 9
  :size-assert         #x8
  :flag-assert         #x900000008
  )


(defun update-mood-misty ((arg0 mood-context) (arg1 float) (arg2 int))
  (update-mood-fog arg0 arg1)
  (update-mood-sky-texture arg0 arg1)
  (clear-mood-times arg0)
  (update-mood-palette arg0 arg1 arg2)
  (when *time-of-day-effects*
    (update-mood-flames arg0 2 4 0 0.333 0.001953125 1.0)
    (let* ((s4-1 (get-task-control (game-task misty-warehouse)))
           (s3-0 (target-pos 0))
           (a1-5 (new 'static 'vector :x -808960.0 :y 110592.0 :z 3928064.0))
           (f30-0 (vector-vector-xz-distance s3-0 a1-5))
           (s5-1 (get-reminder s4-1 0))
           )
      (cond
        ((or (logtest? s5-1 3) (and (< f30-0 180224.0) (< (-> s3-0 y) 118784.0)))
         (when (or (logtest? s5-1 1) (and (< f30-0 180224.0) (< (-> s3-0 y) 118784.0)))
           (update-mood-light arg0 6 4 6 0.875 0.25 20.0 32)
           (save-reminder s4-1 (logior s5-1 1) 0)
           (if (not (paused?))
               (+! (-> arg0 state 6) 1)
               )
           )
         (when (logtest? s5-1 2)
           (update-mood-light arg0 7 5 7 0.875 0.25 20.0 32)
           (if (not (paused?))
               (+! (-> arg0 state 7) 1)
               )
           )
         )
        (else
          (set! (-> arg0 state 6) (the-as uint 0))
          (set! (-> arg0 state 7) (the-as uint 0))
          (set! (-> arg0 state 4) (the-as uint 255))
          (set! (-> arg0 state 5) (the-as uint 255))
          )
        )
      )
    )
  (let ((s5-2 (-> arg0 light-group 1)))
    (update-light-kit s5-2 (-> arg0 light-group 0 ambi) 0.6)
    (set! (-> s5-2 dir0 levels x) (+ 1.0 (* 0.333 (-> arg0 times 2 w))))
    )
  (update-mood-itimes arg0)
  0
  (none)
  )

(deftype swamp-village2-states (structure)
  ((flames    flames-state    :inline :offset-assert   0)
   (lightning lightning-state :inline :offset-assert   4)
   )
  :method-count-assert 9
  :size-assert         #x5
  :flag-assert         #x900000005
  )


(defun update-mood-village2 ((arg0 mood-context) (arg1 float) (arg2 int))
  (update-mood-fog arg0 arg1)
  (update-mood-sky-texture arg0 arg1)
  (clear-mood-times arg0)
  (update-mood-palette arg0 arg1 arg2)
  (when *time-of-day-effects*
    (update-mood-flames arg0 4 4 0 0.333 0.001953125 1.0)
    (update-mood-lightning arg0 2 2 4 2 0.5 #f)
    )
  (let ((a0-7 (-> arg0 light-group 1)))
    (update-light-kit a0-7 (-> arg0 light-group 0 ambi) 0.9)
    )
  (let ((s5-1 (-> arg0 light-group 2)))
    (update-light-kit s5-1 (-> arg0 light-group 0 ambi) 1.0)
    (set! (-> s5-1 dir2 direction quad) (-> arg0 light-group 0 dir2 direction quad))
    (set! (-> s5-1 dir2 color quad) (-> arg0 light-group 0 dir2 color quad))
    (set! (-> s5-1 dir2 levels x) (-> arg0 light-group 0 dir2 levels x))
    )
  (let ((s5-2 (-> arg0 light-group 3)))
    (update-light-kit s5-2 (-> arg0 light-group 0 ambi) 1.0)
    (set! (-> s5-2 dir0 levels x) (+ 0.666 (* 0.333 (-> arg0 times 4 w))))
    )
  (let ((s5-3 (-> arg0 light-group 4)))
    (update-light-kit s5-3 (-> arg0 light-group 0 ambi) 1.0)
    (set! (-> s5-3 dir0 levels x) (+ 0.666 (* 0.333 (-> arg0 times 4 w))))
    )
  (let ((s5-4 (-> arg0 light-group 5)))
    (update-light-kit s5-4 (-> arg0 light-group 0 ambi) 0.5)
    (set! (-> s5-4 ambi color x) (+ 0.25 (-> s5-4 ambi color x)))
    (set! (-> s5-4 dir0 levels x) 1.0)
    )
  (let ((s5-5 (-> arg0 light-group 6))
        (s4-1 (new 'stack-no-clear 'vector))
        (s3-0 (target-joint-pos))
        )
    (update-light-kit s5-5 (-> arg0 light-group 0 ambi) 1.0)
    (set-vector! s4-1 1212416.0 110592.0 -6680576.0 0.0)
    (vector-! s4-1 s4-1 s3-0)
    (vector-normalize! s4-1 1.0)
    (set! (-> s5-5 dir0 direction quad) (-> s4-1 quad))
    (set! (-> s5-5 dir0 levels x) (+ 0.666 (* 0.333 (-> arg0 times 4 w))))
    (set-vector! s4-1 1384448.0 (-> s3-0 y) -6688768.0 0.0)
    (let ((f30-0 (vector-vector-distance s4-1 s3-0)))
      (vector-! s4-1 s4-1 s3-0)
      (vector-normalize! s4-1 1.0)
      (set! (-> s5-5 dir1 direction quad) (-> s4-1 quad))
      (when (< f30-0 180224.0)
        (new 'stack-no-clear 'vector)
        (let ((f2-3 (* 0.0000110973015 (+ -90112.0 f30-0))))
          (set! (-> s5-5 dir1 levels x) (- 1.0 (fmax 0.0 (fmin 1.0 f2-3))))
          )
        )
      )
    (set-vector! s4-1 1212416.0 (-> s3-0 y) -6680576.0 0.0)
    (let ((f0-26 (vector-vector-distance s4-1 s3-0)))
      (when (< f0-26 61440.0)
        (let ((a2-10 (new 'stack-no-clear 'vector))
              (f0-27 (* 0.000016276043 f0-26))
              )
          (set-vector! a2-10 1.0 0.5 0.0 1.0)
          (let ((f0-31 (* 0.5 (- 1.0 (fmax 0.0 (fmin 1.0 f0-27))))))
            (vector+float*! (-> s5-5 ambi color) (-> s5-5 ambi color) a2-10 f0-31)
            )
          )
        )
      )
    )
  (let ((s5-6 (new 'stack-no-clear 'vector))
        (s4-2 (target-joint-pos))
        )
    0.0
    (set-vector! s5-6 1570816.0 98304.0 -6322176.0 1.0)
    (let ((f0-37 (vector-vector-distance s5-6 s4-2)))
      (when (< f0-37 49152.0)
        (let ((f30-1 (* 0.000061035156 (+ -32768.0 f0-37))))
          (cond
            ((movie?)
             (set-target-light-index 1)
             (set! (-> *time-of-day-context* target-interp) 1.0)
             )
            (else
              (set-target-light-index 1)
              (set! (-> *time-of-day-context* target-interp) (- 1.0 (fmax 0.0 (fmin 1.0 f30-1))))
              )
            )
          )
        )
      )
    (set-vector! s5-6 1169408.0 61440.0 -6676480.0 1.0)
    (let ((f0-46 (vector-vector-distance s5-6 s4-2)))
      (when (< f0-46 167936.0)
        (let ((f30-2 (* 0.000024414063 (+ -126976.0 f0-46))))
          (cond
            ((movie?)
             (set-target-light-index 6)
             (set! (-> *time-of-day-context* target-interp) 1.0)
             )
            (else
              (set-target-light-index 6)
              (set! (-> *time-of-day-context* target-interp) (- 1.0 (fmax 0.0 (fmin 1.0 f30-2))))
              )
            )
          )
        )
      )
    )
  (update-mood-itimes arg0)
  0
  (none)
  )

(defun update-mood-swamp ((arg0 mood-context) (arg1 float) (arg2 int))
  (update-mood-fog arg0 arg1)
  (update-mood-sky-texture arg0 arg1)
  (clear-mood-times arg0)
  (update-mood-palette arg0 arg1 arg2)
  (when *time-of-day-effects*
    (update-mood-flames arg0 4 4 0 0.333 0.001953125 1.0)
    (update-mood-lightning arg0 2 2 4 2 0.5 #f)
    )
  (let ((f30-0 (fmax 0.0 (-> *math-camera* camera-rot vector 1 z))))
    (let ((a2-4 (new 'stack-no-clear 'vector)))
      (set-vector! a2-4 0.0 32.0 48.0 128.0)
      (vector4-lerp! (the-as vector (-> arg0 current-fog)) (the-as vector (-> arg0 current-fog)) a2-4 (* 0.5 f30-0))
      )
    (let ((f0-7 (-> arg0 current-fog fog-dists w))
          (f1-1 255.0)
          )
      (set! (-> arg0 current-fog fog-dists w) (+ f0-7 (* 0.666 f30-0 (- f1-1 f0-7))))
      )
    )
  (update-mood-itimes arg0)
  0
  (none)
  )

(deftype village1-states (structure)
  ((flames flames-state :inline :offset-assert   0)
   )
  :method-count-assert 9
  :size-assert         #x4
  :flag-assert         #x900000004
  )


(defun update-mood-village1 ((arg0 mood-context) (arg1 float) (arg2 int))
  (update-mood-fog arg0 arg1)
  (update-mood-sky-texture arg0 arg1)
  (clear-mood-times arg0)
  (update-mood-palette arg0 arg1 arg2)
  (if *time-of-day-effects*
      (update-mood-flames arg0 5 1 0 0.5 0.001953125 1.0)
      )
  (update-light-kit (-> arg0 light-group 1) (-> arg0 light-group 0 ambi) 1.0)
  (update-light-kit (-> arg0 light-group 2) (-> arg0 light-group 0 ambi) 1.0)
  (update-light-kit (-> arg0 light-group 3) (-> arg0 light-group 0 ambi) 1.0)
  (update-light-kit (-> arg0 light-group 4) (-> arg0 light-group 0 ambi) 1.0)
  (update-light-kit (-> arg0 light-group 5) (-> arg0 light-group 0 ambi) 1.0)
  (update-light-kit (-> arg0 light-group 6) (-> arg0 light-group 0 ambi) 1.0)
  (update-light-kit (-> arg0 light-group 7) (-> arg0 light-group 0 ambi) 1.0)
  (let ((s5-1 (new 'stack-no-clear 'vector))
        (s4-1 (target-joint-pos))
        )
    0.0
    (set-vector! s5-1 -524288.0 (-> s4-1 y) 856064.0 1.0)
    (let ((f0-5 (vector-vector-distance s5-1 s4-1)))
      (when (< f0-5 90112.0)
        (let ((f30-0 (* 0.000061035156 (+ -73728.0 f0-5))))
          (cond
            ((movie?)
             (set-target-light-index 1)
             (set! (-> *time-of-day-context* target-interp) 1.0)
             )
            (else
              (set-target-light-index 1)
              (set! (-> *time-of-day-context* target-interp) (- 1.0 (fmax 0.0 (fmin 1.0 f30-0))))
              )
            )
          )
        )
      )
    (set-vector! s5-1 -253952.0 (-> s4-1 y) -116736.0 1.0)
    (let ((f0-14 (vector-vector-distance s5-1 s4-1)))
      (when (< f0-14 69632.0)
        (let ((f30-1 (* 0.000061035156 (+ -53248.0 f0-14))))
          (cond
            ((movie?)
             (set-target-light-index 4)
             (set! (-> *time-of-day-context* target-interp) 1.0)
             )
            (else
              (set-target-light-index 4)
              (set! (-> *time-of-day-context* target-interp) (- 1.0 (fmax 0.0 (fmin 1.0 f30-1))))
              )
            )
          )
        )
      )
    (set-vector! s5-1 -518144.0 (-> s4-1 y) -73728.0 1.0)
    (let ((f0-23 (vector-vector-distance s5-1 s4-1)))
      (when (< f0-23 57344.0)
        (let ((f30-2 (* 0.000061035156 (+ -40960.0 f0-23))))
          (cond
            ((movie?)
             (set-target-light-index 3)
             (set! (-> *time-of-day-context* target-interp) 1.0)
             )
            (else
              (set-target-light-index 3)
              (set! (-> *time-of-day-context* target-interp) (- 1.0 (fmax 0.0 (fmin 1.0 f30-2))))
              )
            )
          )
        )
      )
    (set-vector! s5-1 -450560.0 (-> s4-1 y) 178176.0 1.0)
    (let ((f0-32 (vector-vector-distance s5-1 s4-1)))
      (when (< f0-32 81920.0)
        (let ((f30-3 (* 0.000061035156 (+ -65536.0 f0-32))))
          (cond
            ((movie?)
             (set-target-light-index 2)
             (set! (-> *time-of-day-context* target-interp) 1.0)
             )
            (else
              (set-target-light-index 2)
              (set! (-> *time-of-day-context* target-interp) (- 1.0 (fmax 0.0 (fmin 1.0 f30-3))))
              )
            )
          )
        )
      )
    (set-vector! s5-1 -239616.0 (-> s4-1 y) 131072.0 1.0)
    (let ((f0-41 (vector-vector-distance s5-1 s4-1)))
      (when (< f0-41 57344.0)
        (let ((f30-4 (* 0.000061035156 (+ -40960.0 f0-41))))
          (cond
            ((movie?)
             (set-target-light-index 5)
             (set! (-> *time-of-day-context* target-interp) 1.0)
             )
            (else
              (set-target-light-index 5)
              (set! (-> *time-of-day-context* target-interp) (- 1.0 (fmax 0.0 (fmin 1.0 f30-4))))
              )
            )
          )
        )
      )
    (set-vector! s5-1 -284672.0 (-> s4-1 y) 288768.0 1.0)
    (let ((f0-50 (vector-vector-distance s5-1 s4-1)))
      (when (< f0-50 77824.0)
        (let ((f30-5 (* 0.000061035156 (+ -61440.0 f0-50))))
          (set-target-light-index 6)
          (set! (-> *time-of-day-context* target-interp) (- 1.0 (fmax 0.0 (fmin 1.0 f30-5))))
          )
        )
      )
    (set-vector! s5-1 -83968.0 (-> s4-1 y) -305152.0 1.0)
    (let ((f0-58 (vector-vector-distance s5-1 s4-1)))
      (when (< f0-58 61440.0)
        (let ((f30-6 (* 0.000061035156 (+ -45056.0 f0-58))))
          (set-target-light-index 7)
          (set! (-> *time-of-day-context* target-interp) (- 1.0 (fmax 0.0 (fmin 1.0 f30-6))))
          )
        )
      )
    )
  (update-mood-itimes arg0)
  0
  (none)
  )

(deftype jungle-states (structure)
  ((light    light-state      :inline :offset-assert   0)
   (time     light-time-state :inline :offset-assert   1)
   (one-shot uint8                    :offset-assert   2)
   )
  :method-count-assert 9
  :size-assert         #x3
  :flag-assert         #x900000003
  )


(defun update-mood-jungle ((arg0 mood-context) (arg1 float) (arg2 int))
  (update-mood-fog arg0 arg1)
  (update-mood-sky-texture arg0 arg1)
  (clear-mood-times arg0)
  (update-mood-palette arg0 arg1 arg2)
  (when *time-of-day-effects*
    (cond
      ((task-complete? *game-info* (game-task jungle-eggtop))
       (update-mood-light arg0 5 0 1 0.875 0.25 20.0 32)
       (if (not (paused?))
           (+! (-> arg0 state 1) 1)
           )
       )
      (else
        (set! (-> arg0 state 1) (the-as uint 0))
        (set! (-> arg0 state 0) (the-as uint 255))
        )
      )
    )
  (update-mood-itimes arg0)
  0
  (none)
  )

(defun update-mood-jungleb-blue ((arg0 mood-context) (arg1 float) (arg2 int))
  (update-mood-light arg0 5 0 1 0.875 0.25 20.0 32)
  (+! (-> arg0 state 1) 1)
  (let ((v1-3 (-> arg0 mood-fog-table data)))
    (set! (-> v1-3 0 fog-color x) 0.0)
    (set! (-> v1-3 0 fog-color y) 16.0)
    (set! (-> v1-3 0 fog-color z) 64.0)
    (set! (-> v1-3 0 fog-color w) 128.0)
    )
  (set! (-> arg0 mood-fog-table data 0 fog-dists x) 196608.0)
  (set-vector! (-> arg0 mood-fog-table data 0 erase-color) 0.0 0.0 0.0 128.0)
  (let ((v1-8 (-> arg0 mood-sun-table data)))
    (set! (-> v1-8 0 sun-color x) 0.0)
    (set! (-> v1-8 0 sun-color y) 0.0)
    (set! (-> v1-8 0 sun-color z) 0.0)
    (set! (-> v1-8 0 sun-color w) 0.0)
    )
  (set-vector! (-> arg0 mood-sun-table data 0 env-color) 64.0 80.0 255.0 255.0)
  (let ((v1-12 (-> arg0 mood-lights-table data)))
    (set! (-> v1-12 0 direction x) 0.0)
    (set! (-> v1-12 0 direction y) -1.0)
    (set! (-> v1-12 0 direction z) 0.0)
    (set! (-> v1-12 0 direction w) 0.0)
    )
  (set-vector! (-> arg0 mood-lights-table data 0 lgt-color) 0.0 0.0 (* 1.5 (-> arg0 times 5 w)) 1.0)
  (set-vector! (-> arg0 mood-lights-table data 0 amb-color) 0.4 0.433 0.7 1.0)
  (set-vector!
    (-> arg0 mood-lights-table data 0 prt-color)
    0.2
    0.216
    (+ 0.35 (* 0.375 (-> arg0 times 5 w)))
    1.0
    )
  (set-vector! (-> arg0 mood-lights-table data 0 shadow) 0.0 -1.0 0.0 0.0)
  (none)
  )

(defun update-mood-jungleb ((arg0 mood-context) (arg1 float) (arg2 int))
  (update-mood-sky-texture arg0 arg1)
  (clear-mood-times arg0)
  (set! (-> arg0 times 0 w) 1.0)
  (when *time-of-day-effects*
    (let ((v1-3 (get-reminder (get-task-control (game-task jungle-eggtop)) 0))
          (s3-0 (-> arg0 state 2))
          )
      (cond
        ((and (= v1-3 2) (nonzero? s3-0))
         (if (< (the-as uint 60) s3-0)
             (set! (-> arg0 times 2 w) 2.0)
             (set! (-> arg0 times 2 w) (* 0.033333335 (the float s3-0)))
             )
         (if (not (paused?))
             (set! (-> arg0 state 2) (+ s3-0 -1))
             )
         (set! (-> arg0 times 1 w) 1.0)
         (update-mood-jungleb-blue arg0 arg1 arg2)
         )
        ((and (nonzero? v1-3) (!= s3-0 180))
         (set! (-> arg0 state 2) (the-as uint 0))
         (set! (-> arg0 times 1 w) 1.0)
         (update-mood-jungleb-blue arg0 arg1 arg2)
         )
        (else
          (set! (-> arg0 state 2) (the-as uint 180))
          (set! (-> arg0 state 1) (the-as uint 0))
          (set! (-> arg0 state 0) (the-as uint 255))
          (let ((v1-15 (-> arg0 mood-fog-table data)))
            (set! (-> v1-15 0 fog-color x) 0.0)
            (set! (-> v1-15 0 fog-color y) 0.0)
            (set! (-> v1-15 0 fog-color z) 0.0)
            (set! (-> v1-15 0 fog-color w) 128.0)
            )
          (set! (-> arg0 mood-fog-table data 0 fog-dists x) 98304.0)
          (set-vector! (-> arg0 mood-fog-table data 0 erase-color) 0.0 0.0 0.0 128.0)
          (let ((v1-20 (-> arg0 mood-sun-table data)))
            (set! (-> v1-20 0 sun-color x) 0.0)
            (set! (-> v1-20 0 sun-color y) 0.0)
            (set! (-> v1-20 0 sun-color z) 0.0)
            (set! (-> v1-20 0 sun-color w) 0.0)
            )
          (set-vector! (-> arg0 mood-sun-table data 0 env-color) 48.0 60.0 96.0 255.0)
          (let ((v1-24 (-> arg0 mood-lights-table data)))
            (set! (-> v1-24 0 direction x) 0.0)
            (set! (-> v1-24 0 direction y) 1.0)
            (set! (-> v1-24 0 direction z) 0.0)
            (set! (-> v1-24 0 direction w) 0.0)
            )
          (set-vector! (-> arg0 mood-lights-table data 0 lgt-color) 0.287 0.283 0.4 1.0)
          (set-vector! (-> arg0 mood-lights-table data 0 amb-color) 0.166125 0.2125 0.4 1.0)
          (set-vector! (-> arg0 mood-lights-table data 0 prt-color) 0.14235 0.1645 0.2875 1.0)
          (set-vector! (-> arg0 mood-lights-table data 0 shadow) 0.0 -1.0 0.0 0.0)
          )
        )
      )
    )
  (update-mood-quick arg0 0 0 0 arg2)
  (let ((s5-1 (-> arg0 light-group 1)))
    (quad-copy! (the-as pointer s5-1) (the-as pointer (-> arg0 light-group)) 12)
    (set! (-> s5-1 dir2 color quad) (the-as uint128 0))
    (set! (-> s5-1 dir2 levels x) 0.0)
    )
  (let ((s5-2 (-> arg0 light-group 2)))
    (quad-copy! (the-as pointer s5-2) (the-as pointer (-> arg0 light-group)) 12)
    (let ((v1-34 (-> s5-2 dir2)))
      (set! (-> v1-34 direction x) 0.0)
      (set! (-> v1-34 direction y) 1.0)
      (set! (-> v1-34 direction z) 0.0)
      (set! (-> v1-34 direction w) 0.0)
      )
    (set-vector! (-> s5-2 dir2 color) 0.0 0.5 0.75 1.0)
    (set! (-> s5-2 dir2 levels x) 1.0)
    )
  (let ((s4-1 (-> *jungle-mood* light-group 1))
        (s3-1 (-> arg0 light-group 3))
        )
    (let ((s5-3 (new 'stack-no-clear 'vector)))
      (quad-copy! (the-as pointer s3-1) (the-as pointer (-> arg0 light-group)) 12)
      (let ((v1-38 (-> s3-1 dir2)))
        (set! (-> v1-38 direction x) 0.0)
        (set! (-> v1-38 direction y) 1.0)
        (set! (-> v1-38 direction z) 0.0)
        (set! (-> v1-38 direction w) 0.0)
        )
      (set-vector! (-> s3-1 dir2 color) 0.4 0.25 0.1 1.0)
      (set! (-> s3-1 dir2 levels x) 1.0)
      (set-vector! s5-3 0.25 0.25 0.25 0.0)
      (vector+! (the-as vector (-> s3-1 ambi color)) (the-as vector (-> s3-1 ambi color)) s5-3)
      )
    (quad-copy! (the-as pointer s4-1) (the-as pointer s3-1) 12)
    )
  (let ((s5-4 (new 'stack-no-clear 'vector))
        (s4-2 (target-joint-pos))
        )
    (set-vector! s5-4 1482752.0 (-> s4-2 y) -985088.0 1.0)
    (let ((f0-70 (vector-vector-distance s5-4 s4-2)))
      (when (< f0-70 81920.0)
        (let ((f0-72 (* 0.000034877234 (+ -53248.0 f0-70)))
              (a2-8 (new 'stack-no-clear 'vector))
              (v1-45 (-> arg0 light-group))
              (a0-19 (-> *jungle-mood* light-group))
              (f2-3 (* 0.0000030517579 (+ 163840.0 (-> s4-2 y))))
              )
          (set! *teleport* #t)
          (let* ((f1-6 (- 1.0 (fmax 0.0 (fmin 1.0 f2-3))))
                 (f0-76 (* (- 1.0 (fmax 0.0 (fmin 1.0 f0-72))) f1-6))
                 )
            (let ((a1-13 (-> v1-45 0 dir2)))
              (set! (-> a1-13 direction x) 0.0)
              (set! (-> a1-13 direction y) 1.0)
              (set! (-> a1-13 direction z) 0.0)
              (set! (-> a1-13 direction w) 0.0)
              )
            (set-vector! (-> v1-45 0 dir2 color) 0.4 0.25 0.1 1.0)
            (set! (-> v1-45 0 dir2 levels x) f0-76)
            (let ((a1-15 (-> a0-19 0 dir2)))
              (set! (-> a1-15 direction x) 0.0)
              (set! (-> a1-15 direction y) 1.0)
              (set! (-> a1-15 direction z) 0.0)
              (set! (-> a1-15 direction w) 0.0)
              )
            (set-vector! (-> a0-19 0 dir2 color) 0.4 0.25 0.1 1.0)
            (set! (-> a0-19 0 dir2 levels x) f0-76)
            (set-vector! a2-8 0.25 0.25 0.25 0.0)
            (vector+! a2-8 a2-8 (the-as vector (-> v1-45 0 ambi color)))
            (vector4-lerp! (-> v1-45 0 ambi color) (-> v1-45 0 ambi color) a2-8 f0-76)
            )
          )
        )
      )
    (set-vector! s5-4 1146880.0 (-> s4-2 y) -1232896.0 1.0)
    (if (< (vector-vector-distance s5-4 s4-2) 10240.0)
        (set! *teleport* #t)
        )
    (set-vector! s5-4 1781760.0 -163840.0 -1038336.0 1.0)
    (let ((f0-86 (vector-vector-distance s5-4 s4-2)))
      (when (< f0-86 147456.0)
        (let ((f30-0 (* 0.000030517578 (+ -114688.0 f0-86))))
          (set-target-light-index 2)
          (set! (-> *time-of-day-context* target-interp) (- 1.0 (fmax 0.0 (fmin 1.0 f30-0))))
          )
        )
      )
    (set-vector! s5-4 1105920.0 -188416.0 -1204224.0 1.0)
    (let ((f0-94 (vector-vector-distance s5-4 s4-2)))
      (when (< f0-94 106496.0)
        (let ((f30-1 (* 0.000030517578 (+ -73728.0 f0-94))))
          (set-target-light-index 2)
          (set! (-> *time-of-day-context* target-interp) (- 1.0 (fmax 0.0 (fmin 1.0 f30-1))))
          )
        )
      )
    )
  (update-mood-itimes arg0)
  0
  (none)
  )

(deftype sunken-states (structure)
  ((light light-state      :inline :offset-assert   0)
   (time  light-time-state :inline :offset-assert   1)
   )
  :method-count-assert 9
  :size-assert         #x2
  :flag-assert         #x900000002
  )


(set! (-> *sunken-mood* state 0) (the-as uint 255))

(defun update-mood-sunken ((arg0 mood-context) (arg1 float) (arg2 int))
  (local-vars (sv-80 vector))
  (when (not (paused?))
    (update-mood-fog arg0 arg1)
    (update-mood-sky-texture arg0 arg1)
    (if (not (paused?))
        (+! (-> arg0 state 1) 1)
        )
    (let ((f30-0 (update-mood-palette arg0 arg1 arg2))
          (f28-0 (* -0.00000055486504 (-> *math-camera* trans y)))
          (s5-1 (-> arg0 light-group))
          )
      (when *time-of-day-effects*
        (update-mood-light arg0 2 0 1 0.875 0.25 20.0 32)
        (update-mood-caustics arg0 4 1)
        (set! (-> arg0 times 3 w) (-> *palette-fade-controls* control 3 fade))
        (let ((a1-6 (new 'static 'vector :x 0.192 :y 0.192 :z 0.24))
              (a2-4 (new 'static 'vector :x 0.124 :y 0.124 :z 0.156))
              (s4-1 (new 'static 'vector :x 0.192 :y 0.192 :z 0.24))
              (s3-0 (new 'static 'vector :x 0.181 :y 0.181 :z 0.226))
              )
          (let ((v1-8 (-> s5-1 0)))
            (set! (-> v1-8 dir0 direction x) 0.0)
            (set! (-> v1-8 dir0 direction y) 1.0)
            (set! (-> v1-8 dir0 direction z) 0.0)
            (set! (-> v1-8 dir0 direction w) 1.0)
            )
          (vector4-lerp! (-> s5-1 0 dir1 color) a1-6 a2-4 f28-0)
          (let ((v1-9 (-> s5-1 0 dir1)))
            (set! (-> v1-9 direction x) 0.0)
            (set! (-> v1-9 direction y) 1.0)
            (set! (-> v1-9 direction z) 0.0)
            (set! (-> v1-9 direction w) 1.0)
            )
          (vector4-lerp! (-> s5-1 0 dir0 color) s4-1 s3-0 f28-0)
          )
        (let ((a1-8 (new 'static 'vector :x 0.104 :y 0.587 :z 1.074))
              (a2-6 (new 'static 'vector :x 0.228 :y 0.3 :z 0.52))
              (s4-2 (new 'static 'vector :x 0.101 :y 0.392 :z 1.064))
              (s3-1 (new 'static 'vector :x 0.132 :y 0.22 :z 0.52))
              (s1-0 (new 'stack-no-clear 'vector))
              (s2-0 (new 'stack-no-clear 'vector))
              )
          (vector4-lerp! s1-0 a1-8 a2-6 f28-0)
          (vector4-lerp! s2-0 s4-2 s3-1 f28-0)
          (vector4-lerp! (-> s5-1 0 ambi color) s2-0 s1-0 f30-0)
          )
        (let ((s2-1 (new 'static 'vector :x 0.193 :y 0.432 :z 0.721))
              (s1-1 (new 'static 'vector :x 0.193 :y 0.338 :z 0.603))
              (s0-0 (new 'static 'vector :x 0.193 :y 0.336 :z 0.721))
              )
          (set! sv-80 (new 'static 'vector :x 0.215 :y 0.309 :z 0.674))
          (let ((s3-2 (new 'stack-no-clear 'vector))
                (s4-3 (new 'stack-no-clear 'vector))
                (f26-3 (+ 0.75
                          (* 0.0625 (cos (the float (* 4000 (/ (-> *display* time-factor) 5) (-> *display* integral-frame-counter))))) ;; changed for high fps
                          (* 0.0625 (cos (the float (shl (the int (* (/ (-> *display* time-factor) 5) (-> *display* integral-frame-counter))) 11)))) ;; changed for high fps
                          (* 0.125 (cos (the float (* 1500 (/ (-> *display* time-factor) 5) (-> *display* integral-frame-counter))))) ;; changed for high fps
                          )
                       )
                )
            (vector4-lerp! s3-2 s2-1 s1-1 f28-0)
            (let ((t9-16 vector4-lerp!)
                  (a0-19 s4-3)
                  (a3-7 f28-0)
                  )
              (t9-16 a0-19 s0-0 sv-80 a3-7)
              )
            (let ((v1-18 (-> s5-1 0 dir2)))
              (set! (-> v1-18 direction x) 0.0)
              (set! (-> v1-18 direction y) 0.999)
              (set! (-> v1-18 direction z) 0.011)
              (set! (-> v1-18 direction w) 1.0)
              )
            (vector4-lerp! (-> s5-1 0 dir2 color) s4-3 s3-2 f30-0)
            (set! (-> s5-1 0 dir2 levels x) f26-3)
            )
          )
        )
      )
    (update-mood-itimes arg0)
    )
  0
  (none)
  )

(deftype rolling-states (structure)
  ((light0    light-state      :inline :offset-assert   0)
   (light1    light-state      :inline :offset-assert   1)
   (light2    light-state      :inline :offset-assert   2)
   (light3    light-state      :inline :offset-assert   3)
   (time      light-time-state :inline :offset-assert   4)
   (lightning lightning-state  :inline :offset-assert   5)
   )
  :method-count-assert 9
  :size-assert         #x6
  :flag-assert         #x900000006
  )


(define *rolling-spheres-on* (new 'static 'inline-array vector 11
                               (new 'static 'vector :x -724992.0 :y 204800.0 :z -6635520.0 :w 24576.0)
                               (new 'static 'vector :x -692224.0 :y 204800.0 :z -6582272.0 :w 24576.0)
                               (new 'static 'vector :x -688128.0 :y 204800.0 :z -6520832.0 :w 24576.0)
                               (new 'static 'vector :x -712704.0 :y 204800.0 :z -6455296.0 :w 24576.0)
                               (new 'static 'vector :x -741376.0 :y 204800.0 :z -6369280.0 :w 24576.0)
                               (new 'static 'vector :x -774144.0 :y 204800.0 :z -6320128.0 :w 24576.0)
                               (new 'static 'vector :x -757760.0 :y 204800.0 :z -6234112.0 :w 24576.0)
                               (new 'static 'vector :x -696320.0 :y 204800.0 :z -6197248.0 :w 24576.0)
                               (new 'static 'vector :x -638976.0 :y 204800.0 :z -6164480.0 :w 24576.0)
                               (new 'static 'vector :x -749568.0 :y 110592.0 :z -6832128.0 :w 24576.0)
                               (new 'static 'vector :x -532480.0 :y 110592.0 :z -6017024.0 :w 24576.0)
                               )
        )

(define *rolling-spheres-light0* (new 'static 'vector :x -524288.0 :y 110592.0 :z -6356992.0 :w 24576.0))

(define *rolling-spheres-light1* (new 'static 'inline-array vector 4
                                   (new 'static 'vector :x -454656.0 :y 114688.0 :z -7081984.0 :w 81920.0)
                                   (new 'static 'vector :x -581632.0 :y 110592.0 :z -6410240.0 :w 24576.0)
                                   (new 'static 'vector :x -1265664.0 :y 106496.0 :z -6492160.0 :w 24576.0)
                                   (new 'static 'vector :x -1302528.0 :y 106496.0 :z -6434816.0 :w 24576.0)
                                   )
        )

(define *rolling-spheres-light2*
  (new 'static 'light-ellipse
    :matrix (new 'static 'matrix :vector (new 'static 'inline-array vector 4
                                   (new 'static 'vector :x -581632.0 :y 114688.0 :z -6479872.0 :w 24576.0)
                                   (new 'static 'vector :x -737280.0 :y 110592.0 :z -7159808.0 :w 24576.0)
                                   (new 'static 'vector :x -733184.0 :y 110592.0 :z -7266304.0 :w 24576.0)
                                   (new 'static 'vector :x -1363968.0 :y 110592.0 :z -6578176.0 :w 24576.0)
                                   )
                         )
    :color (new 'static 'rgbaf :x -1404928.0 :y 110592.0 :z -6541312.0 :w 24576.0)
    )
  )

(define *rolling-spheres-light3* (new 'static 'inline-array vector 2
                                   (new 'static 'vector :x -540672.0 :y 110592.0 :z -6549504.0 :w 24576.0)
                                   (new 'static 'vector :x -774144.0 :y 204800.0 :z -6275072.0 :w 24576.0)
                                   )
        )

(define *rolling-spheres-light4* (new 'static 'vector :x -688128.0 :y 217088.0 :z -5697536.0 :w 143360.0))

(defun update-mood-rolling ((arg0 mood-context) (arg1 float) (arg2 int))
  (update-mood-fog arg0 arg1)
  (update-mood-sky-texture arg0 arg1)
  (clear-mood-times arg0)
  (update-mood-palette arg0 arg1 arg2)
  (when *time-of-day-effects*
    (update-mood-light arg0 4 0 4 0.875 0.25 arg1 32)
    (update-mood-light arg0 5 1 4 0.875 0.25 arg1 0)
    (update-mood-light arg0 6 2 4 0.875 0.25 arg1 96)
    (update-mood-light arg0 7 3 4 0.875 0.25 arg1 64)
    (if (not (paused?))
        (+! (-> arg0 state 4) 1)
        )
    (update-mood-lightning arg0 2 2 5 2 0.5 #t)
    )
  (let ((a0-10 (-> arg0 light-group 1)))
    (update-light-kit a0-10 (-> arg0 light-group 0 ambi) 1.0)
    )
  (dotimes (s5-1 4)
    (let ((s4-1 (-> arg0 light-group (+ s5-1 2))))
      (update-light-kit s4-1 (-> arg0 light-group 0 ambi) 1.0)
      (set! (-> s4-1 dir0 levels x) (-> arg0 times (+ s5-1 4) w))
      )
    )
  (let ((s5-2 (-> arg0 light-group 6)))
    (update-light-kit s5-2 (-> arg0 light-group 0 ambi) 1.0)
    (set! (-> s5-2 dir0 levels x) (+ (* 0.25 (-> arg0 times 4 w))
                                     (* 0.25 (-> arg0 times 5 w))
                                     (* 0.25 (-> arg0 times 6 w))
                                     (* 0.25 (-> arg0 times 7 w))
                                     )
          )
    )
  (new 'stack-no-clear 'vector)
  (let ((s5-3 (target-joint-pos)))
    0.0
    (dotimes (s4-2 11)
      (let ((f0-7 (vector-vector-distance (-> *rolling-spheres-on* s4-2) s5-3)))
        (when (< f0-7 (-> *rolling-spheres-on* s4-2 w))
          (let ((f30-0 (/ (- f0-7 (* 0.5 (-> *rolling-spheres-on* s4-2 w))) (* 0.5 (-> *rolling-spheres-on* s4-2 w)))))
            (set-target-light-index 1)
            (set! (-> *time-of-day-context* target-interp) (- 1.0 (fmax 0.0 (fmin 1.0 f30-0))))
            )
          )
        )
      )
    (let ((f0-11 (vector-vector-distance (the-as vector (&-> *rolling-spheres-light0* x)) s5-3)))
      (when (< f0-11 (-> *rolling-spheres-light0* w))
        (let ((f30-1 (/ (- f0-11 (* 0.5 (-> *rolling-spheres-light0* w))) (* 0.5 (-> *rolling-spheres-light0* w)))))
          (set-target-light-index 2)
          (set! (-> *time-of-day-context* target-interp) (- 1.0 (fmax 0.0 (fmin 1.0 f30-1))))
          )
        )
      )
    (dotimes (s4-3 4)
      (let ((f0-15 (vector-vector-distance (-> *rolling-spheres-light1* s4-3) s5-3)))
        (when (< f0-15 (-> *rolling-spheres-light1* s4-3 w))
          (let ((f30-2
                  (/ (- f0-15 (* 0.5 (-> *rolling-spheres-light1* s4-3 w))) (* 0.5 (-> *rolling-spheres-light1* s4-3 w)))
                  )
                )
            (set-target-light-index 3)
            (set! (-> *time-of-day-context* target-interp) (- 1.0 (fmax 0.0 (fmin 1.0 f30-2))))
            )
          )
        )
      )
    (dotimes (s4-4 5)
      (let ((f0-19 (vector-vector-distance (the-as vector (+ (the-as uint *rolling-spheres-light2*) (* s4-4 16))) s5-3)))
        (when (< f0-19 (-> *rolling-spheres-light2* matrix vector s4-4 w))
          (let ((f30-3 (/ (- f0-19 (* 0.5 (-> *rolling-spheres-light2* matrix vector s4-4 w)))
                          (* 0.5 (-> *rolling-spheres-light2* matrix vector s4-4 w))
                          )
                       )
                )
            (set-target-light-index 4)
            (set! (-> *time-of-day-context* target-interp) (- 1.0 (fmax 0.0 (fmin 1.0 f30-3))))
            )
          )
        )
      )
    (dotimes (s4-5 2)
      (let ((f0-23 (vector-vector-distance (-> *rolling-spheres-light3* s4-5) s5-3)))
        (when (< f0-23 (-> *rolling-spheres-light3* s4-5 w))
          (let ((f30-4
                  (/ (- f0-23 (* 0.5 (-> *rolling-spheres-light3* s4-5 w))) (* 0.5 (-> *rolling-spheres-light3* s4-5 w)))
                  )
                )
            (set-target-light-index 5)
            (set! (-> *time-of-day-context* target-interp) (- 1.0 (fmax 0.0 (fmin 1.0 f30-4))))
            )
          )
        )
      )
    (let ((f0-27 (vector-vector-distance (the-as vector (&-> *rolling-spheres-light4* x)) s5-3)))
      (when (< f0-27 (-> *rolling-spheres-light4* w))
        (let ((f30-5 (/ (- f0-27 (* 0.5 (-> *rolling-spheres-light4* w))) (* 0.5 (-> *rolling-spheres-light4* w)))))
          (set-target-light-index 6)
          (set! (-> *time-of-day-context* target-interp) (- 1.0 (fmax 0.0 (fmin 1.0 f30-5))))
          )
        )
      )
    )
  (update-mood-itimes arg0)
  0
  (none)
  )

(deftype firecanyon-states (structure)
  ((lava lava-state :inline :offset-assert   0)
   )
  :method-count-assert 9
  :size-assert         #x12
  :flag-assert         #x900000012
  )


(defun update-mood-firecanyon ((arg0 mood-context) (arg1 float) (arg2 int))
  (update-mood-fog arg0 arg1)
  (update-mood-sky-texture arg0 arg1)
  (clear-mood-times arg0)
  (update-mood-palette arg0 arg1 arg2)
  (if *time-of-day-effects*
      (update-mood-lava arg0 4 0 #t)
      )
  (update-mood-itimes arg0)
  0
  (none)
  )

(deftype training-states (structure)
  ((light light-state      :inline :offset-assert   0)
   (time  light-time-state :inline :offset-assert   1)
   )
  :method-count-assert 9
  :size-assert         #x2
  :flag-assert         #x900000002
  )


(defun update-mood-training ((arg0 mood-context) (arg1 float) (arg2 int))
  (update-mood-fog arg0 arg1)
  (update-mood-sky-texture arg0 arg1)
  (clear-mood-times arg0)
  (update-mood-palette arg0 arg1 arg2)
  (when *time-of-day-effects*
    (update-mood-light arg0 5 0 1 0.875 0.25 arg1 32)
    (if (not (paused?))
        (+! (-> arg0 state 1) 1)
        )
    )
  (update-mood-itimes arg0)
  0
  (none)
  )

(deftype maincave-states (structure)
  ((flames flames-state :inline :offset-assert   0)
   )
  :method-count-assert 9
  :size-assert         #x4
  :flag-assert         #x900000004
  )


(defun update-mood-maincave ((arg0 mood-context) (arg1 float) (arg2 int))
  (when (not (paused?))
    (clear-mood-times arg0)
    (set! (-> arg0 times 0 w) 1.0)
    (update-mood-quick arg0 0 0 0 arg2)
    (when *time-of-day-effects*
      (update-mood-flames arg0 4 4 0 0.333 0.001953125 1.0)
      (set! (-> arg0 times 1 w) (-> *palette-fade-controls* control 1 fade))
      (set! (-> arg0 times 2 w) (-> *palette-fade-controls* control 2 fade))
      (set! (-> arg0 times 3 w) 1.0)
      (let ((a0-4 (new 'stack-no-clear 'vector))
            (a1-3 (-> *math-camera* trans))
            )
        (set-vector! a0-4 4417536.0 86016.0 -13250560.0 1.0)
        (let ((f0-8 (vector-vector-distance a0-4 a1-3)))
          (when (< f0-8 483328.0)
            (let ((f1-2 (* 0.0000048828124 (+ -278528.0 f0-8))))
              (set! (-> arg0 times 3 w) (fmax 0.0 (fmin 1.9 f1-2)))
              )
            )
          )
        )
      )
    (update-mood-itimes arg0)
    )
  0
  (none)
  )

(defun update-mood-darkcave ((arg0 mood-context) (arg1 float) (arg2 int))
  (when (not (paused?))
    (clear-mood-times arg0)
    (set! (-> arg0 times 0 w) 1.0)
    (set-vector! (-> arg0 mood-lights-table data 0 prt-color) 0.0 0.0 0.0 0.0)
    (when *time-of-day-effects*
      (let ((f30-0 0.0)
            (s4-0 (new 'stack-no-clear 'vector))
            )
        (let ((s3-0 (new 'stack-no-clear 'vector)))
          0.0
          0.0
          (set-vector! s4-0 0.0 -1.0 0.0 0.0)
          (let ((s2-0 1)
                (s1-0 7)
                )
            (while (>= s1-0 s2-0)
              (let ((f28-0 (-> *palette-fade-controls* control s2-0 fade)))
                (set! (-> arg0 times s2-0 w) f28-0)
                (vector-! s3-0 (the-as vector (-> *palette-fade-controls* control s2-0)) (-> *target* control trans))
                (let* ((f3-0 (vector-length s3-0))
                       (f28-1 (* f28-0 (fmax 0.0 (fmin 1.0 (- 1.0 (* 0.000012207031 f3-0))))))
                       )
                  (vector-normalize! s3-0 f28-1)
                  (if (< f30-0 f28-1)
                      (set! f30-0 f28-1)
                      )
                  )
                )
              (vector+! s4-0 s4-0 s3-0)
              (+! s2-0 1)
              )
            )
          )
        (let ((f0-14 (fmin 1.0 f30-0))
              (a2-1 (new 'static 'vector :y 1.0 :z 0.5 :w 1.0))
              (a1-8 (new 'static 'vector :x 0.3 :y 0.4 :z 0.5 :w 1.0))
              )
          (vector-lerp! (-> arg0 mood-lights-table data 0 amb-color) a1-8 a2-1 f0-14)
          )
        (set! (-> arg0 mood-lights-table data 0 prt-color quad) (-> arg0 mood-lights-table data 0 amb-color quad))
        (vector-normalize! s4-0 1.0)
        (let ((v1-21 (-> arg0 mood-lights-table data 0 shadow)))
          (set! (-> v1-21 x) (- (-> s4-0 x)))
          (set! (-> v1-21 y) (- (-> s4-0 y)))
          (set! (-> v1-21 z) (- (-> s4-0 z)))
          (when (< (-> s4-0 y) 0.9063)
            (let* ((f0-22 0.4226)
                   (f1-3 (-> v1-21 x))
                   (f1-5 (* f1-3 f1-3))
                   (f2-2 (-> v1-21 z))
                   (f0-23 (/ f0-22 (sqrtf (+ f1-5 (* f2-2 f2-2)))))
                   )
              (set! (-> v1-21 x) (* (-> v1-21 x) f0-23))
              (set! (-> v1-21 y) -0.9063)
              (set! (-> v1-21 z) (* (-> v1-21 z) f0-23))
              )
            )
          )
        )
      )
    (set! *teleport* #t)
    (update-mood-quick arg0 0 0 0 arg2)
    (set-vector! (-> arg0 current-shadow-color) 0.25 0.25 0.25 1.0)
    (update-mood-itimes arg0)
    )
  0
  (none)
  )

(deftype robocave-states (structure)
  ((flames flames-state :inline :offset-assert   0)
   )
  :method-count-assert 9
  :size-assert         #x4
  :flag-assert         #x900000004
  )


(defun update-mood-robocave ((arg0 mood-context) (arg1 float) (arg2 int))
  (clear-mood-times arg0)
  (set! (-> arg0 times 0 w) 1.0)
  (if *time-of-day-effects*
      (update-mood-flames arg0 4 4 0 0.333 0.001953125 1.0)
      )
  (update-mood-quick arg0 0 0 0 arg2)
  (update-mood-itimes arg0)
  0
  (none)
  )

(deftype snow-states (structure)
  ((flames   flames-state     :inline :offset-assert   0)
   (light    light-state      :inline :offset-assert   4)
   (time     light-time-state :inline :offset-assert   5)
   (one-shot uint8                    :offset-assert   6)
   (interp   float                    :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )


(defun update-mood-snow ((arg0 mood-context) (arg1 float) (arg2 int))
  (update-mood-fog arg0 arg1)
  (update-mood-sky-texture arg0 arg1)
  (clear-mood-times arg0)
  (update-mood-palette arg0 arg1 arg2)
  (when *time-of-day-effects*
    (update-mood-flames arg0 4 3 0 0.45 0.001953125 1.0)
    (let ((s5-1 (the-as snow-states (-> arg0 state))))
      (let ((v1-3 (get-reminder (get-task-control (game-task snow-eggtop)) 4))
            (s4-1 (-> s5-1 one-shot))
            )
        (cond
          ((and (= v1-3 2) (nonzero? s4-1))
           (if (< (the-as uint 60) s4-1)
               (set! (-> arg0 times 7 w) 2.0)
               (set! (-> arg0 times 7 w) (* 0.033333335 (the float s4-1)))
               )
           (if (not (paused?))
               (set! (-> s5-1 one-shot) (+ s4-1 -1))
               )
           )
          ((and (nonzero? v1-3) (!= s4-1 180))
           (set! (-> arg0 state 6) (the-as uint 0))
           (update-mood-light arg0 7 4 5 0.875 0.25 20.0 32)
           (if (not (paused?))
               (+! (-> arg0 state 5) 1)
               )
           )
          (else
            (set! (-> arg0 state 6) (the-as uint 180))
            (set! (-> arg0 state 5) (the-as uint 0))
            (set! (-> arg0 state 4) (the-as uint 255))
            )
          )
        )
      (let ((f30-0 (-> s5-1 interp)))
        (when (not (paused?))
          (let ((f0-4 (if *weather-off*
                          (+ 0.1 f30-0)
                          (+ -0.1 f30-0)
                          )
                      )
                )
            (set! f30-0 (fmax 0.0 (fmin 1.0 f0-4)))
            )
          (set! (-> s5-1 interp) f30-0)
          )
        (vector4-lerp!
          (-> arg0 current-sun env-color)
          (-> arg0 current-sun env-color)
          (-> arg0 mood-sun-table data 6 env-color)
          f30-0
          )
        )
      )
    )
  (update-mood-itimes arg0)
  0
  (none)
  )

(deftype village3-states (structure)
  ((flames    flames-state :inline :offset-assert   0)
   (scale     float                :offset-assert   4)
   (lava      lava-state   :inline :offset-assert   8)
   (lava-time float                :offset-assert  28)
   (time      uint8                :offset-assert  32)
   )
  :method-count-assert 9
  :size-assert         #x21
  :flag-assert         #x900000021
  )


(defun update-mood-village3 ((arg0 mood-context) (arg1 float) (arg2 int))
  (update-mood-fog arg0 arg1)
  (update-mood-sky-texture arg0 arg1)
  (clear-mood-times arg0)
  (update-mood-palette arg0 arg1 arg2)
  (when *time-of-day-effects*
    (update-mood-flames arg0 4 3 0 0.5 0.001953125 1.0)
    (let ((s3-0 (new 'stack-no-clear 'vector))
          (s2-0 (new 'stack-no-clear 'vector))
          (s4-0 (new 'stack-no-clear 'vector))
          (s5-1 (new 'stack-no-clear 'vector))
          )
      (let ((v1-3 (-> arg0 mood-lights-table data)))
        (set! (-> v1-3 0 direction x) -0.067)
        (set! (-> v1-3 0 direction y) 0.25)
        (set! (-> v1-3 0 direction z) 0.966)
        (set! (-> v1-3 0 direction w) 0.0)
        )
      (set-vector! (-> arg0 mood-lights-table data 0 lgt-color) 0.0 0.0 0.0 1.0)
      (set-vector! (-> arg0 mood-lights-table data 0 amb-color) 0.449 0.35 0.599 1.0)
      (let ((v1-9 (-> arg0 mood-lights-table data 1)))
        (set! (-> v1-9 direction x) 0.259)
        (set! (-> v1-9 direction y) 0.966)
        (set! (-> v1-9 direction z) 0.0)
        (set! (-> v1-9 direction w) 0.0)
        )
      (set-vector! (-> arg0 mood-lights-table data 1 lgt-color) 0.66 0.436 0.291 1.0)
      (set-vector! (-> arg0 mood-lights-table data 1 amb-color) 0.358 0.575 0.716 1.0)
      (let ((v1-15 (-> arg0 mood-lights-table data 2)))
        (set! (-> v1-15 direction x) -0.067)
        (set! (-> v1-15 direction y) 0.25)
        (set! (-> v1-15 direction z) -0.966)
        (set! (-> v1-15 direction w) 0.0)
        )
      (set-vector! (-> arg0 mood-lights-table data 2 lgt-color) 0.0 0.0 0.0 1.0)
      (set-vector! (-> arg0 mood-lights-table data 2 amb-color) 0.383 0.366 0.599 1.0)
      (let ((v1-21 (-> arg0 mood-lights-table data 3)))
        (set! (-> v1-21 direction x) 0.866)
        (set! (-> v1-21 direction y) 0.5)
        (set! (-> v1-21 direction z) 0.0)
        (set! (-> v1-21 direction w) 0.0)
        )
      (set-vector! (-> arg0 mood-lights-table data 3 lgt-color) 0.0 0.0 0.0 1.0)
      (set-vector! (-> arg0 mood-lights-table data 3 amb-color) 0.304 0.409 0.76 1.0)
      (let ((s0-0 (-> arg0 light-group 1)))
        (update-light-kit s0-0 (-> arg0 light-group 0 ambi) 1.25)
        (set! (-> s0-0 dir2 levels x) (+ 0.666 (* 0.333 (-> arg0 times 4 w))))
        )
      (let ((s0-1 (-> arg0 light-group 2)))
        (update-light-kit s0-1 (-> arg0 light-group 0 ambi) 1.25)
        (set! (-> s0-1 dir2 levels x) (+ 0.666 (* 0.333 (-> arg0 times 4 w))))
        )
      (let ((v1-28 (new 'static 'vector :x 4605890.5 :z -14253220.0 :w 1.0))
            (a0-8 (new 'stack-no-clear 'vector))
            )
        0.0
        (vector-! a0-8 (-> *target* control trans) v1-28)
        (set! (-> a0-8 y) 0.0)
        (let ((f0-54 (vector-length a0-8)))
          (set-vector! s3-0 0.19 0.128 0.128 1.0)
          (set-vector! s5-1 0.0 1.0 0.0 0.0)
          (set-vector! s4-0 0.31 0.372 0.372 0.0)
          (cond
            ((>= 532480.0 f0-54)
             (let* ((f1-18 (* 0.000008138021 (+ -409600.0 f0-54)))
                    (a1-9 (new 'static 'vector :x 0.66 :y 0.436 :z 0.291))
                    (a2-8 (new 'static 'vector :x 0.19 :y 0.128 :z 0.128))
                    (f30-0 (fmax 0.0 (fmin 1.0 f1-18)))
                    )
               (vector-lerp! s2-0 a1-9 a2-8 f30-0)
               (let ((s0-2 (the-as village3-states (-> arg0 state))))
                 (when (not (paused?))
                   (set! (-> s0-2 time) (the-as uint (the int (+ 4.0 arg1))))
                   (+! (-> s0-2 lava-time) (rand-vu-float-range 64.0 2048.0))
                   )
                 (-> arg0 mood-lights-table data 7)
                 (let* ((s1-1 (-> arg0 light-group 0 dir2))
                        (f1-21 (+ 0.875 (* 0.125 (sin (-> s0-2 lava-time)))))
                        (f0-66 (* 3.52 f1-21))
                        )
                   (set-vector! (-> s1-1 direction) 0.0 -1.0 0.0 0.0)
                   (set-vector! (-> s1-1 color) 1.0 0.38 0.0 1.0)
                   (set! (-> s1-1 levels x) (* f1-21 (- 1.0 f30-0)))
                   (set! (-> s1-1 levels y) (* f0-66 (- 1.0 f30-0)))
                   )
                 (let ((f30-1 (* 0.015625 (the float (logand (-> s0-2 time) 63)))))
                   (set! (-> s0-2 scale) (the float (the int (rand-vu-float-range 128.0 255.0))))
                   (set! (-> arg0 times 7 w) (* f30-1 (-> s0-2 scale)))
                   )
                 )
               )
             )
            (else
              (set-vector! s2-0 0.19 0.128 0.128 1.0)
              )
            )
          )
        )
      (let ((s1-2 (new 'stack-no-clear 'vector))
            (a1-12 (target-joint-pos))
            )
        0.0
        (set-vector! s1-2 4454400.0 196608.0 -14725120.0 1.0)
        (let ((f0-83 (vector-vector-distance s1-2 a1-12)))
          (when (< f0-83 122880.0)
            (let ((f30-2 (* 0.000016276043 (+ -61440.0 f0-83))))
              (set-target-light-index 2)
              (set! (-> *time-of-day-context* target-interp) (- 1.0 (fmax 0.0 (fmin 1.0 f30-2))))
              )
            )
          )
        )
      (let* ((f1-33 (* 0.0000044389203 (+ -184320.0 (-> *math-camera* trans y))))
             (f30-3 (fmax 0.0 (fmin 1.0 f1-33)))
             )
        (let ((v1-49 (-> arg0 light-group 0 dir2)))
          (set! (-> v1-49 levels x) (* (-> v1-49 levels x) (- 1.0 f30-3)))
          (set! (-> v1-49 levels y) (* (-> v1-49 levels y) (- 1.0 f30-3)))
          )
        (vector-lerp!
          (-> arg0 mood-lights-table data 0 lgt-color)
          s3-0
          (-> arg0 mood-lights-table data 0 lgt-color)
          f30-3
          )
        (vector-lerp!
          (-> arg0 mood-lights-table data 1 lgt-color)
          s2-0
          (-> arg0 mood-lights-table data 1 lgt-color)
          f30-3
          )
        (vector-lerp!
          (-> arg0 mood-lights-table data 2 lgt-color)
          s3-0
          (-> arg0 mood-lights-table data 2 lgt-color)
          f30-3
          )
        (vector-lerp!
          (-> arg0 mood-lights-table data 3 lgt-color)
          s3-0
          (-> arg0 mood-lights-table data 3 lgt-color)
          f30-3
          )
        (vector-lerp!
          (-> arg0 mood-lights-table data 0 amb-color)
          s4-0
          (-> arg0 mood-lights-table data 0 amb-color)
          f30-3
          )
        (vector-lerp!
          (-> arg0 mood-lights-table data 1 amb-color)
          s4-0
          (-> arg0 mood-lights-table data 1 amb-color)
          f30-3
          )
        (vector-lerp!
          (-> arg0 mood-lights-table data 2 amb-color)
          s4-0
          (-> arg0 mood-lights-table data 2 amb-color)
          f30-3
          )
        (vector-lerp!
          (-> arg0 mood-lights-table data 3 amb-color)
          s4-0
          (-> arg0 mood-lights-table data 3 amb-color)
          f30-3
          )
        (vector-lerp!
          (the-as vector (-> arg0 mood-lights-table data))
          s5-1
          (the-as vector (-> arg0 mood-lights-table data))
          f30-3
          )
        (vector-lerp!
          (the-as vector (-> arg0 mood-lights-table data 1))
          s5-1
          (the-as vector (-> arg0 mood-lights-table data 1))
          f30-3
          )
        (vector-lerp!
          (the-as vector (-> arg0 mood-lights-table data 2))
          s5-1
          (the-as vector (-> arg0 mood-lights-table data 2))
          f30-3
          )
        (vector-lerp!
          (the-as vector (-> arg0 mood-lights-table data 3))
          s5-1
          (the-as vector (-> arg0 mood-lights-table data 3))
          f30-3
          )
        )
      )
    )
  (update-mood-itimes arg0)
  0
  (none)
  )

(deftype lavatube-states (structure)
  ((lava  lava-state       :inline :offset-assert   0)
   (light light-state      :inline :offset-assert  18)
   (time  light-time-state :inline :offset-assert  19)
   )
  :method-count-assert 9
  :size-assert         #x14
  :flag-assert         #x900000014
  )


(set! (-> *lavatube-mood* state 18) (the-as uint 255))

(defun update-mood-lavatube ((arg0 mood-context) (arg1 float) (arg2 int))
  (clear-mood-times arg0)
  (set! (-> arg0 times 0 w) 1.0)
  (when *time-of-day-effects*
    (set! (-> arg0 times 2 w) (-> *palette-fade-controls* control 2 fade))
    (update-mood-light arg0 1 18 19 0.875 0.25 20.0 32)
    (if (not (paused?))
        (+! (-> arg0 some-byte) 1)
        )
    (update-mood-lava arg0 4 0 #t)
    )
  (update-mood-quick arg0 0 0 0 arg2)
  (update-mood-itimes arg0)
  0
  (none)
  )

(deftype ogre-states (structure)
  ((lava      lava-state      :inline :offset-assert   0)
   (lightning lightning-state :inline :offset-assert  18)
   (lava-time float                   :offset-assert  20)
   (lava-fade float                   :offset-assert  24)
   )
  :method-count-assert 9
  :size-assert         #x1c
  :flag-assert         #x90000001c
  )


(defun update-mood-ogre ((arg0 mood-context) (arg1 float) (arg2 int))
  (update-mood-fog arg0 arg1)
  (update-mood-sky-texture arg0 arg1)
  (clear-mood-times arg0)
  (update-mood-palette arg0 arg1 arg2)
  (when *time-of-day-effects*
    (let ((s4-0 (new 'stack-no-clear 'vector))
          (s3-0 (-> *math-camera* trans))
          )
      (set-vector! s4-0 868352.0 151552.0 -7720960.0 1.0)
      (let ((f30-0 (vector-vector-distance s4-0 s3-0)))
        (cond
          ((< f30-0 614400.0)
           (update-mood-palette *ogre2-mood* arg1 arg2)
           (let* ((f1-2 (* 0.0000048828124 (+ -409600.0 f30-0)))
                  (f30-1 (fmax 0.0 (fmin 1.0 f1-2)))
                  )
             (let ((s4-1 (the-as ogre-states (-> arg0 state))))
               (if (not (paused?))
                   (+! (-> s4-1 lava-time) (rand-vu-float-range 64.0 2048.0))
                   )
               (if (not (movie?))
                   (update-mood-lightning arg0 2 2 18 4 0.5 #f)
                   )
               (cond
                 ((or (nonzero? *lightning-time2*) (movie?))
                  (if (not (paused?))
                      (set! (-> s4-1 lava-fade) (+ 0.2 (-> s4-1 lava-fade)))
                      )
                  (if (< 1.0 (-> s4-1 lava-fade))
                      (set! (-> s4-1 lava-fade) 1.0)
                      )
                  (let* ((f28-1 (-> s4-1 lava-fade))
                         (s5-1 (-> arg0 light-group 0 dir2))
                         (f1-6 (+ 0.875 (* 0.125 (sin (-> s4-1 lava-time)))))
                         (f0-17 (* 3.52 f1-6))
                         )
                    (set-vector! (-> s5-1 direction) 0.0 -1.0 0.0 0.0)
                    (set-vector! (-> s5-1 color) 1.0 0.38 0.0 1.0)
                    (set! (-> s5-1 levels x) (* f1-6 (- 1.0 f30-1) f28-1))
                    (set! (-> s5-1 levels y) (* f0-17 (- 1.0 f30-1) f28-1))
                    )
                  )
                 (else
                   (set! (-> s4-1 lava-fade) 0.0)
                   )
                 )
               )
             (let ((s5-2 (-> arg0 light-group))
                   (s4-2 (-> *ogre2-mood* light-group))
                   )
               (cond
                 ((= f30-1 0.0)
                  (set! (-> s5-2 0 dir0 direction quad) (-> s4-2 0 dir0 direction quad))
                  (set! (-> s5-2 0 dir0 color quad) (-> s4-2 0 dir0 color quad))
                  (set! (-> s5-2 0 dir0 levels quad) (-> s4-2 0 dir0 levels quad))
                  (set! (-> s5-2 0 dir1 direction quad) (-> s4-2 0 dir1 direction quad))
                  (set! (-> s5-2 0 dir1 color quad) (-> s4-2 0 dir1 color quad))
                  (set! (-> s5-2 0 dir1 levels quad) (-> s4-2 0 dir1 levels quad))
                  (set! (-> s5-2 0 ambi direction quad) (-> s4-2 0 ambi direction quad))
                  (set! (-> s5-2 0 ambi color quad) (-> s4-2 0 ambi color quad))
                  (set! (-> s5-2 0 ambi levels quad) (-> s4-2 0 ambi levels quad))
                  (set! (-> arg0 current-shadow quad) (-> *ogre2-mood* current-shadow quad))
                  )
                 (else
                   (vector4-lerp! (the-as vector (-> s5-2 0)) (the-as vector (-> s4-2 0)) (the-as vector (-> s5-2 0)) f30-1)
                   (vector4-lerp! (-> s5-2 0 dir0 color) (-> s4-2 0 dir0 color) (-> s5-2 0 dir0 color) f30-1)
                   (vector4-lerp! (-> s5-2 0 dir0 levels) (-> s4-2 0 dir0 levels) (-> s5-2 0 dir0 levels) f30-1)
                   (vector4-lerp!
                     (the-as vector (-> s5-2 0 dir1))
                     (the-as vector (-> s4-2 0 dir1))
                     (the-as vector (-> s5-2 0 dir1))
                     f30-1
                     )
                   (vector4-lerp! (-> s5-2 0 dir1 color) (-> s4-2 0 dir1 color) (-> s5-2 0 dir1 color) f30-1)
                   (vector4-lerp! (-> s5-2 0 dir1 levels) (-> s4-2 0 dir1 levels) (-> s5-2 0 dir1 levels) f30-1)
                   (vector4-lerp!
                     (the-as vector (-> s5-2 0 ambi))
                     (the-as vector (-> s4-2 0 ambi))
                     (the-as vector (-> s5-2 0 ambi))
                     f30-1
                     )
                   (vector4-lerp! (-> s5-2 0 ambi color) (-> s4-2 0 ambi color) (-> s5-2 0 ambi color) f30-1)
                   (vector4-lerp! (-> s5-2 0 ambi levels) (-> s4-2 0 ambi levels) (-> s5-2 0 ambi levels) f30-1)
                   (vector4-lerp! (-> arg0 current-shadow) (-> *ogre2-mood* current-shadow) (-> arg0 current-shadow) f30-1)
                   )
                 )
               )
             )
           )
          (else
            (set-vector! s4-0 2973696.0 184320.0 -13414400.0 1.0)
            (let ((f30-2 (vector-vector-distance s4-0 s3-0)))
              (when (< f30-2 1298432.0)
                (update-mood-quick *ogre3-mood* 0 0 0 arg2)
                (let* ((f1-13 (* 0.0000048828124 (+ -1093632.0 f30-2)))
                       (f30-3 (fmax 0.0 (fmin 1.0 f1-13)))
                       (s5-3 (-> arg0 light-group))
                       (s4-3 (-> *ogre3-mood* light-group))
                       )
                  (cond
                    ((= f30-3 0.0)
                     (set! (-> s5-3 0 dir0 direction quad) (-> s4-3 0 dir0 direction quad))
                     (set! (-> s5-3 0 dir0 color quad) (-> s4-3 0 dir0 color quad))
                     (set! (-> s5-3 0 dir0 levels quad) (-> s4-3 0 dir0 levels quad))
                     (set! (-> s5-3 0 dir1 direction quad) (-> s4-3 0 dir1 direction quad))
                     (set! (-> s5-3 0 dir1 color quad) (-> s4-3 0 dir1 color quad))
                     (set! (-> s5-3 0 dir1 levels quad) (-> s4-3 0 dir1 levels quad))
                     (set! (-> s5-3 0 dir2 direction quad) (-> s4-3 0 dir2 direction quad))
                     (set! (-> s5-3 0 dir2 color quad) (-> s4-3 0 dir2 color quad))
                     (set! (-> s5-3 0 dir2 levels quad) (-> s4-3 0 dir2 levels quad))
                     (set! (-> s5-3 0 ambi direction quad) (-> s4-3 0 ambi direction quad))
                     (set! (-> s5-3 0 ambi color quad) (-> s4-3 0 ambi color quad))
                     (set! (-> s5-3 0 ambi levels quad) (-> s4-3 0 ambi levels quad))
                     (set! (-> arg0 current-shadow quad) (-> *ogre3-mood* current-shadow quad))
                     (set! (-> arg0 current-fog fog-color quad) (-> *ogre3-mood* current-fog fog-color quad))
                     (set! (-> arg0 current-fog fog-dists quad) (-> *ogre3-mood* current-fog fog-dists quad))
                     (set! (-> arg0 current-fog erase-color quad) (-> *ogre3-mood* current-fog erase-color quad))
                     )
                    (else
                      (vector4-lerp! (the-as vector (-> s5-3 0)) (the-as vector (-> s4-3 0)) (the-as vector (-> s5-3 0)) f30-3)
                      (vector4-lerp! (-> s5-3 0 dir0 color) (-> s4-3 0 dir0 color) (-> s5-3 0 dir0 color) f30-3)
                      (vector4-lerp! (-> s5-3 0 dir0 levels) (-> s4-3 0 dir0 levels) (-> s5-3 0 dir0 levels) f30-3)
                      (vector4-lerp!
                        (the-as vector (-> s5-3 0 dir1))
                        (the-as vector (-> s4-3 0 dir1))
                        (the-as vector (-> s5-3 0 dir1))
                        f30-3
                        )
                      (vector4-lerp! (-> s5-3 0 dir1 color) (-> s4-3 0 dir1 color) (-> s5-3 0 dir1 color) f30-3)
                      (vector4-lerp! (-> s5-3 0 dir1 levels) (-> s4-3 0 dir1 levels) (-> s5-3 0 dir1 levels) f30-3)
                      (vector4-lerp!
                        (the-as vector (-> s5-3 0 dir2))
                        (the-as vector (-> s4-3 0 dir2))
                        (the-as vector (-> s5-3 0 dir1))
                        f30-3
                        )
                      (vector4-lerp! (-> s5-3 0 dir2 color) (-> s4-3 0 dir2 color) (-> s5-3 0 dir1 color) f30-3)
                      (vector4-lerp! (-> s5-3 0 dir2 levels) (-> s4-3 0 dir2 levels) (-> s5-3 0 dir1 levels) f30-3)
                      (vector4-lerp!
                        (the-as vector (-> s5-3 0 ambi))
                        (the-as vector (-> s4-3 0 ambi))
                        (the-as vector (-> s5-3 0 ambi))
                        f30-3
                        )
                      (vector4-lerp! (-> s5-3 0 ambi color) (-> s4-3 0 ambi color) (-> s5-3 0 ambi color) f30-3)
                      (vector4-lerp! (-> s5-3 0 ambi levels) (-> s4-3 0 ambi levels) (-> s5-3 0 ambi levels) f30-3)
                      (vector4-lerp! (-> arg0 current-shadow) (-> *ogre3-mood* current-shadow) (-> arg0 current-shadow) f30-3)
                      (vector4-lerp!
                        (the-as vector (-> arg0 current-fog))
                        (the-as vector (-> *ogre3-mood* current-fog))
                        (the-as vector (-> arg0 current-fog))
                        f30-3
                        )
                      (vector4-lerp!
                        (-> arg0 current-fog fog-dists)
                        (-> *ogre3-mood* current-fog fog-dists)
                        (-> arg0 current-fog fog-dists)
                        f30-3
                        )
                      (vector4-lerp!
                        (-> arg0 current-fog erase-color)
                        (-> *ogre3-mood* current-fog erase-color)
                        (-> arg0 current-fog erase-color)
                        f30-3
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  (update-mood-itimes arg0)
  0
  (none)
  )

(deftype finalboss-states (structure)
  ((start-time  time-frame  :offset-assert   0)
   (secret-time time-frame  :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #x10
  :flag-assert         #x900000010
  )


(defun update-mood-finalboss ((arg0 mood-context) (arg1 float) (arg2 int))
  (clear-mood-times arg0)
  (set! (-> arg0 light-group 0 dir2 levels x) 0.0)
  (set! (-> *finalboss2-mood* light-group 0 dir2 levels x) 0.0)
  (let ((s4-0 (the-as finalboss-states (-> arg0 state))))
    (cond
      ((or (logtest? (get-reminder (get-task-control (game-task finalboss-movies)) 0) 1) (not *time-of-day-effects*))
       (when (and *target* (= (-> *target* next-state name) 'target-continue))
         (set! (-> s4-0 start-time) (+ (-> *display* base-frame-counter) (seconds -33.335)))
         (set! (-> s4-0 secret-time) (+ (-> *display* base-frame-counter) (seconds -33.335)))
         )
       (update-mood-fog arg0 arg1)
       (update-mood-sky-texture arg0 arg1)
       (update-mood-palette arg0 arg1 arg2)
       (dotimes (v1-18 8)
         (set! (-> *finalboss2-mood* sky-times v1-18) 0.0)
         )
       (set! (-> *finalboss2-mood* times 5 w) 1.0)
       (set! (-> *finalboss2-mood* sky-times 3) 1.0)
       (update-mood-quick *finalboss2-mood* 3 3 5 arg2)
       (when (= (-> *time-of-day-proc* 0 hour) 6)
         (let ((f30-0 (-> *palette-fade-controls* control 2 fade))
               (s3-1 (-> arg0 light-group))
               )
           (let ((s2-0 (-> arg0 mood-lights-table data 2)))
             (set! (-> arg0 times 2 w) f30-0)
             (vector+float*! (the-as vector (-> s3-1 0)) (the-as vector (-> s3-1 0)) (-> s2-0 direction) f30-0)
             (vector+float*! (-> s3-1 0 dir0 color) (-> s3-1 0 dir0 color) (-> s2-0 lgt-color) f30-0)
             )
           (vector-normalize! (the-as vector (-> s3-1 0)) 1.0)
           )
         )
       (let ((a0-17 (new 'stack-no-clear 'vector))
             (a1-10 (-> *math-camera* trans))
             )
         (set-vector! a0-17 12378112.0 1990656.0 -19873792.0 1.0)
         (let ((f0-9 (vector-vector-distance a0-17 a1-10)))
           (when (< f0-9 819200.0)
             (let* ((f2-1 (* 0.0000048828124 (+ -614400.0 f0-9)))
                    (f0-12 (- 1.0 (fmax 0.0 (fmin 1.0 f2-1))))
                    )
               (let ((v1-32 (-> *finalboss2-mood* light-group 0 dir2)))
                 (set! (-> v1-32 direction x) 0.0)
                 (set! (-> v1-32 direction y) -1.0)
                 (set! (-> v1-32 direction z) 0.0)
                 (set! (-> v1-32 direction w) 1.0)
                 )
               (set-vector! (-> *finalboss2-mood* light-group 0 dir2 color) 1.0 0.8 2.0 1.0)
               (set! (-> *finalboss2-mood* light-group 0 dir2 levels x) f0-12)
               )
             )
           )
         )
       (cond
         ((logtest? (get-reminder (get-task-control (game-task finalboss-movies)) 0) 2)
          (let* ((f1-14 (* 0.00055555557 (the float (- (-> *display* base-frame-counter) (-> s4-0 secret-time)))))
                 (f0-15 (fmax 0.0 (fmin 1.0 f1-14)))
                 (a0-21 (-> arg0 light-group))
                 )
            (let ((v1-43 (-> a0-21 0 dir2)))
              (set! (-> v1-43 direction x) -0.5768)
              (set! (-> v1-43 direction y) 0.1697)
              (set! (-> v1-43 direction z) -0.799)
              (set! (-> v1-43 direction w) 1.0)
              )
            (set-vector! (-> a0-21 0 dir2 color) 1.0 1.0 1.0 1.0)
            (set! (-> a0-21 0 dir2 levels x) f0-15)
            (let ((v1-45 (-> arg0 current-shadow)))
              (let ((a0-22 (-> a0-21 0 dir2)))
                (set! (-> v1-45 x) (- (-> a0-22 direction x)))
                (set! (-> v1-45 y) (- (-> a0-22 direction y)))
                (set! (-> v1-45 z) (- (-> a0-22 direction z)))
                (when (< (-> a0-22 direction y) 0.9063)
                  (let* ((f0-23 0.4226)
                         (f1-25 (-> v1-45 x))
                         (f1-27 (* f1-25 f1-25))
                         (f2-4 (-> v1-45 z))
                         (f0-24 (/ f0-23 (sqrtf (+ f1-27 (* f2-4 f2-4)))))
                         )
                    (set! (-> v1-45 x) (* (-> v1-45 x) f0-24))
                    (set! (-> v1-45 y) -0.9063)
                    (set! (-> v1-45 z) (* (-> v1-45 z) f0-24))
                    )
                  )
                )
              (set! (-> *default-shadow-settings* shadow-dir x) (-> v1-45 x))
              (set! (-> *default-shadow-settings* shadow-dir y) (-> v1-45 y))
              (set! (-> *default-shadow-settings* shadow-dir z) (-> v1-45 z))
              )
            )
          )
         (else
           (set! (-> s4-0 secret-time) (-> *display* base-frame-counter))
           )
         )
       (let* ((f1-36 (* 0.00019607843 (the float (- (-> *display* base-frame-counter) (-> s4-0 start-time)))))
              (f1-38 (fmax 0.0 (fmin 1.0 f1-36)))
              (f0-32 (fmax 0.0 (fmin 1.0 f1-38)))
              )
         (set! (-> *level* level arg2 info sun-fade) f0-32)
         (set! (-> arg0 num-stars) (* 85.0 f0-32))
         (dotimes (v1-56 8)
           (let ((f1-42 (-> *finalboss2-mood* times v1-56 w))
                 (f3-1 (-> arg0 times v1-56 w))
                 )
             (set! (-> arg0 times v1-56 w) (+ f1-42 (* f0-32 (- f3-1 f1-42))))
             )
           (let ((f1-45 (-> *finalboss2-mood* sky-times v1-56))
                 (f3-3 (-> arg0 sky-times v1-56))
                 )
             (set! (-> arg0 sky-times v1-56) (+ f1-45 (* f0-32 (- f3-3 f1-45))))
             )
           )
         (update-mood-interp arg0 *finalboss2-mood* arg0 f0-32)
         )
       )
      (else
        (set! (-> *level* level arg2 info sun-fade) 0.0)
        (set! (-> arg0 num-stars) 0.0)
        (set! (-> *time-of-day-proc* 0 hour) 6)
        (set! (-> *time-of-day-proc* 0 minute) 0)
        (set! (-> *time-of-day-proc* 0 second) 0)
        (set! (-> *time-of-day-proc* 0 frame) 0)
        (set! (-> s4-0 start-time) (-> *display* base-frame-counter))
        (dotimes (v1-72 8)
          (set! (-> arg0 sky-times v1-72) 0.0)
          )
        (set! (-> arg0 times 5 w) 1.0)
        (set! (-> arg0 sky-times 3) 1.0)
        (update-mood-quick arg0 3 3 5 arg2)
        (let ((f30-1 (-> *palette-fade-controls* control 2 fade))
              (s5-1 (-> arg0 light-group))
              )
          (let ((s4-1 (-> arg0 mood-lights-table data 2)))
            (set! (-> arg0 times 2 w) f30-1)
            (vector+float*! (the-as vector (-> s5-1 0)) (the-as vector (-> s5-1 0)) (-> s4-1 direction) f30-1)
            (vector+float*! (-> s5-1 0 dir0 color) (-> s5-1 0 dir0 color) (-> s4-1 lgt-color) f30-1)
            )
          (vector-normalize! (the-as vector (-> s5-1 0)) 1.0)
          )
        (let ((a0-57 (new 'stack-no-clear 'vector))
              (a1-19 (-> *math-camera* trans))
              )
          (set-vector! a0-57 12378112.0 1990656.0 -19873792.0 1.0)
          (let ((f0-42 (vector-vector-distance a0-57 a1-19)))
            (when (< f0-42 819200.0)
              (let* ((f2-14 (* 0.0000048828124 (+ -614400.0 f0-42)))
                     (v1-81 (-> arg0 light-group))
                     (f0-45 (- 1.0 (fmax 0.0 (fmin 1.0 f2-14))))
                     )
                (let ((a0-58 (-> v1-81 0 dir2)))
                  (set! (-> a0-58 direction x) 0.0)
                  (set! (-> a0-58 direction y) -1.0)
                  (set! (-> a0-58 direction z) 0.0)
                  (set! (-> a0-58 direction w) 1.0)
                  )
                (set-vector! (-> v1-81 0 dir2 color) 1.0 0.8 2.0 1.0)
                (set! (-> v1-81 0 dir2 levels x) f0-45)
                )
              )
            )
          )
        )
      )
    )
  (update-mood-itimes arg0)
  (none)
  )

(deftype citadel-states (structure)
  ((flames      flames-state     :inline :offset-assert   0)
   (light       light-state      :inline :offset-assert   4)
   (time        light-time-state :inline :offset-assert   5)
   (flicker-off uint8                    :offset-assert   6)
   (flicker-on  uint8                    :offset-assert   7)
   (shield-fade float                    :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )


(set! (-> *citadel-mood* state 4) (the-as uint 255))

(defun update-mood-citadel ((arg0 mood-context) (arg1 float) (arg2 int))
  (clear-mood-times arg0)
  (set! (-> arg0 times 0 w) 1.0)
  (update-mood-quick arg0 0 0 0 arg2)
  (when *time-of-day-effects*
    (set! (-> arg0 times 3 w) (-> *palette-fade-controls* control 3 fade))
    (update-mood-flames arg0 4 3 0 0.45 0.001953125 1.0)
    (update-mood-light arg0 1 4 5 0.875 0.25 20.0 32)
    (if (not (paused?))
        (+! (-> arg0 state 5) 1)
        )
    (let ((s5-1 (the-as (pointer number) (-> arg0 state))))
      (let ((f30-1 (+ 0.5 (* 0.5 (cos (the float (* (logand (+ (-> (the-as (pointer uint8) s5-1) 5) 32) 255) 512)))))))
        (cond
          ((movie?)
           )
          ((nonzero? (-> (the-as (pointer uint8) s5-1) 7))
           (set! (-> arg0 times 2 w) 1.0)
           (if (not (paused?))
               (+! (-> (the-as (pointer uint8) s5-1) 7) -1)
               )
           )
          ((nonzero? (-> (the-as (pointer uint8) s5-1) 6))
           (if (not (paused?))
               (+! (-> (the-as (pointer uint8) s5-1) 6) -1)
               )
           )
          (else
            (set! (-> (the-as (pointer uint8) s5-1) 7) (the-as uint (the int (rand-vu-float-range 2.0 20.0))))
            (if (zero? (the int (rand-vu-float-range 0.0 3.0)))
                (set! (-> (the-as (pointer uint8) s5-1) 6) (the-as uint (the int (rand-vu-float-range 2.0 120.0))))
                (set! (-> (the-as (pointer uint8) s5-1) 6) (the-as uint (the int (rand-vu-float-range 2.0 20.0))))
                )
            )
          )
        (let ((s3-0 (new 'stack-no-clear 'vector))
              (a2-4 (new 'stack-no-clear 'vector))
              (s4-0 (-> arg0 light-group))
              )
          (set-vector! s3-0 0.5 0.5 0.5 1.0)
          (set-vector! a2-4 0.75 0.725 0.5 1.0)
          (vector4-lerp! s3-0 s3-0 a2-4 f30-1)
          (let ((v1-25 (-> s4-0 0)))
            (set! (-> v1-25 dir0 direction x) 0.0)
            (set! (-> v1-25 dir0 direction y) 1.0)
            (set! (-> v1-25 dir0 direction z) 0.0)
            (set! (-> v1-25 dir0 direction w) 1.0)
            )
          (set! (-> s4-0 0 dir0 color quad) (-> s3-0 quad))
          (set! (-> s4-0 0 dir0 levels x) 1.0)
          )
        )
      (let ((s4-1 (new 'stack-no-clear 'vector))
            (a1-9 (target-joint-pos))
            )
        (set-vector! s4-1 11227136.0 (-> a1-9 y) -20164608.0 1.0)
        (let ((f0-32 (vector-vector-distance s4-1 a1-9)))
          (when (< f0-32 409600.0)
            (let* ((f1-2 (* 0.000048828126 (+ -389120.0 f0-32)))
                   (f2-2 (fmax 0.0 (fmin 1.0 f1-2)))
                   )
              (set! (-> arg0 current-fog fog-dists y) (* 4096.0 (+ 250.0 (* 300.0 f2-2))))
              )
            )
          )
        )
      (let ((a0-13 (new 'stack-no-clear 'vector))
            (a1-10 (-> *math-camera* trans))
            )
        (set-vector! a0-13 11427840.0 (-> a1-10 y) -19251200.0 1.0)
        (let ((f0-41 (vector-vector-distance a0-13 a1-10))
              (s4-2 (-> arg0 light-group))
              )
          (cond
            ((< f0-41 491520.0)
             (let* ((f2-5 (* 0.000012207031 (+ -409600.0 f0-41)))
                    (f30-2 (- 1.0 (fmax 0.0 (fmin 1.0 f2-5))))
                    (f28-4 (+ 0.5
                              (* 0.125 (cos (the float (* 4000 (/ (-> *display* time-factor) 5) (-> *display* integral-frame-counter))))) ;; changed for high fps
                              (* 0.125 (cos (the float (shl (the int (* (/ (-> *display* time-factor) 5) (-> *display* integral-frame-counter))) 11)))) ;; changed for high fps
                              (* 0.25 (cos (the float (* 1500 (/ (-> *display* time-factor) 5) (-> *display* integral-frame-counter))))) ;; changed for high fps
                              )
                           )
                    (s3-1 (new 'stack-no-clear 'vector))
                    )
               (let ((s2-0 (new 'stack-no-clear 'vector)))
                 (set-vector! s3-1 0.275 0.1 1.025 1.0)
                 (set-vector! s2-0 0.35 0.1 1.1 1.0)
                 (vector4-lerp! s2-0 s3-1 s2-0 f28-4)
                 (cond
                   ((= (-> *palette-fade-controls* control 7 fade) 1.0)
                    (set! (-> (the-as (pointer float) s5-1) 2) 1.0)
                    )
                   (else
                     (if (not (paused?))
                         (set! (-> (the-as (pointer float) s5-1) 2) (+ -0.1 (-> (the-as (pointer float) s5-1) 2)))
                         )
                     (set! (-> (the-as (pointer float) s5-1) 2) (fmax 0.0 (fmin 1.0 (-> (the-as (pointer float) s5-1) 2))))
                     )
                   )
                 (set-vector! s3-1 0.1 0.1 0.1 1.0)
                 (let ((f30-3 (* (-> (the-as (pointer float) s5-1) 2) f30-2)))
                   (vector4-lerp! s3-1 s3-1 s2-0 f30-3)
                   (set! (-> arg0 times 7 w) (* (+ 0.8 (* 0.1 f28-4)) f30-3))
                   )
                 )
               (let ((v1-49 (-> s4-2 0 dir1)))
                 (set! (-> v1-49 direction x) 0.0)
                 (set! (-> v1-49 direction y) -1.0)
                 (set! (-> v1-49 direction z) 0.0)
                 (set! (-> v1-49 direction w) 1.0)
                 )
               (set! (-> s4-2 0 dir1 color quad) (-> s3-1 quad))
               )
             (set! (-> s4-2 0 dir1 levels x) 1.0)
             )
            (else
              (let ((v1-52 (-> s4-2 0 dir1)))
                (set! (-> v1-52 direction x) 0.0)
                (set! (-> v1-52 direction y) -1.0)
                (set! (-> v1-52 direction z) 0.0)
                (set! (-> v1-52 direction w) 1.0)
                )
              (set-vector! (-> s4-2 0 dir1 color) 0.1 0.1 0.1 1.0)
              (set! (-> s4-2 0 dir1 levels x) 1.0)
              )
            )
          )
        )
      )
    (let ((s5-2 (new 'stack-no-clear 'vector))
          (a1-13 (target-joint-pos))
          )
      0.0
      (when (< 204800.0 (-> a1-13 y))
        (set-vector! s5-2 11440128.0 (-> a1-13 y) -19298304.0 1.0)
        (let ((f0-98 (vector-vector-distance s5-2 a1-13))
              (s5-3 (-> arg0 light-group))
              )
          (when (< f0-98 172032.0)
            (let* ((f1-19 (* 0.000061035156 (+ -155648.0 f0-98)))
                   (a1-14 (new 'stack-no-clear 'vector))
                   (f0-101 (fmax 0.0 (fmin 1.0 f1-19)))
                   )
              (set-vector! a1-14 0.5 0.5 0.5 1.0)
              (vector4-lerp! (-> s5-3 0 dir0 color) a1-14 (-> s5-3 0 dir0 color) f0-101)
              )
            (set! (-> s5-3 0 dir1 levels x) 0.0)
            )
          )
        )
      )
    )
  (update-mood-itimes arg0)
  (none)
  )




