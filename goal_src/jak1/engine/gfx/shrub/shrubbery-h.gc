;;-*-Lisp-*-
(in-package goal)
(bundles "ENGINE.CGO" "GAME.CGO")
(require "engine/math/vector-h.gc")
(require "engine/gfx/background/prototype-h.gc")
(require "engine/draw/drawable-tree-h.gc")
(require "engine/draw/drawable-inline-array-h.gc")

;; DECOMP BEGINS

(deftype billboard (drawable)
  ((flat adgif-shader :inline)))

(deftype shrub-view-data (structure)
  ((data           uint128 3)
   (texture-giftag gs-gif-tag :inline :overlay-at (-> data 0))
   (consts         vector :inline :overlay-at (-> data 1))
   (fog-clamp      vector :inline :overlay-at (-> data 2))
   (tex-start-ptr  int32 :overlay-at (-> data 1))
   (gifbufsum      float :overlay-at (-> data 1))
   (mtx-buf-ptr    int32 :overlay-at (-> consts y))
   (exp23          float :overlay-at mtx-buf-ptr)
   (fog-0          float :overlay-at (-> consts z))
   (fog-1          float :overlay-at (-> consts w))
   (fog-min        float :overlay-at (-> data 2))
   (fog-max        float :overlay-at (-> fog-clamp y))))

(deftype shrubbery (drawable)
  ((textures (inline-array adgif-shader) :overlay-at id)
   (header   qword :offset 8)
   (obj-qwc  uint8 :offset 12)
   (vtx-qwc  uint8 :offset 13)
   (col-qwc  uint8 :offset 14)
   (stq-qwc  uint8 :offset 15)
   (obj      uint32 :overlay-at (-> bsphere x))
   (vtx      uint32 :overlay-at (-> bsphere y))
   (col      uint32 :overlay-at (-> bsphere z))
   (stq      uint32 :overlay-at (-> bsphere w))))

(deftype instance-shrubbery (instance)
  ((color-indices uint32 :overlay-at error)
   (flat-normal   vector :inline)
   (flat-hwidth   float :overlay-at (-> flat-normal w))
   (color         uint32 :overlay-at color-indices)))

(deftype drawable-inline-array-instance-shrub (drawable-inline-array)
  ((data instance-shrubbery 1 :inline)
   (pad  uint32)))

(deftype drawable-tree-instance-shrub (drawable-tree)
  ((info         prototype-array-shrub-info :offset 8)
   (colors-added time-of-day-palette :offset 12)))

(deftype generic-shrub-fragment (drawable)
  ((textures (inline-array adgif-shader) :overlay-at id)
   (vtx-cnt  uint32 :offset 8)
   (cnt-qwc  uint8 :offset 12)
   (vtx-qwc  uint8 :offset 13)
   (col-qwc  uint8 :offset 14)
   (stq-qwc  uint8 :offset 15)
   (cnt      uint32 :overlay-at (-> bsphere x))
   (vtx      uint32 :overlay-at (-> bsphere y))
   (col      uint32 :overlay-at (-> bsphere z))
   (stq      uint32 :overlay-at (-> bsphere w))))

(deftype prototype-shrubbery (drawable-inline-array)
  ((data shrubbery 1 :inline)
   (pad  uint32)))

(deftype prototype-trans-shrubbery (prototype-shrubbery) ())

(deftype prototype-generic-shrub (drawable-group) ())

(deftype shrubbery-matrix (structure)
  ((mat   matrix :inline)
   (color qword :inline)))

(defun shrubbery-login-post-texture ((this shrubbery))
  "Copies adgif shader crap to somewhere"
  ;; total number of adgif shaders for this shrubbery object.
  (let* ((shader-count (-> this header data 0))
         ;; one destination to place the data.
         (dst (the-as qword (+ (the-as uint (-> this header)) (* (+ (-> this header data 1) 1) 16))))
         ;; the second destination to place the data
         (tex-dst (the-as qword (+ (the-as int dst) (* shader-count 64))))
         ;; the input data (adgif shaders, each is 0x50 bytes, or 5 quads)
         (src (the-as qword (-> this textures))))
    ;; iterate over all shaders
    (dotimes (a0-1 (the-as int shader-count))
      ;; copy the first quadword directly to the second destination
      (set! (-> tex-dst quad) (-> src quad))
      ;; advance dst and src
      (let ((text-dst2 (the-as qword (+ (the-as int tex-dst) 16)))
            (src-2 (the-as qword (&+ (the-as pointer src) 16))))
        ;; copy second quadword, but only the first three words
        (set! (-> dst vector4w x) (the-as int (-> src-2 data 0)))
        (set! (-> dst vector4w y) (the-as int (-> src-2 data 1)))
        (set! (-> dst vector4w z) (the-as int (-> src-2 data 2)))
        ;; advance dst and src
        (set! dst (the-as qword (+ (the-as int dst) 16)))
        (let ((src-3 (the-as qword (&+ (the-as pointer src-2) 16))))
          ;; copy 3rd, 4th, and 5th quadwords
          (dotimes (t0-4 3)
            (set! (-> dst quad) (-> src-3 quad))
            (set! dst (the-as qword (+ (the-as int dst) 16)))
            (set! src-3 (the-as qword (&+ (the-as pointer src-3) 16))))
          ;; more texture data (isn't this reading off of the end of the source?)
          (set! (-> text-dst2 quad) (-> src-3 quad))
          ;; advance to next source
          (set! tex-dst (the-as qword (+ (the-as int text-dst2) 16)))
          (set! src (the-as qword (&+ (the-as pointer src-3) 80)))))))
  (none))

(define *shrub-state* 0)

(deftype shrub-near-packet (structure)
  ((matrix-tmpl dma-packet :inline)
   (header-tmpl dma-packet :inline)
   (stq-tmpl    dma-packet :inline)
   (color-tmpl  dma-packet :inline)
   (vertex-tmpl dma-packet :inline)
   (mscal-tmpl  dma-packet :inline)
   (init-tmpl   dma-packet :inline)
   (init-data   uint32 8)))

(deftype instance-shrub-work (structure)
  ((dummy                     qword 3 :inline)
   (chaina                    qword 8 :inline)
   (chainb                    qword 8 :inline)
   (colors                    rgba 1024)
   (matrix-tmpl               qword 20 :inline)
   (count-tmpl                vector4w 20 :inline)
   (mscalf-tmpl               dma-packet :inline)
   (mscalf-ret-tmpl           dma-packet :inline)
   (adgif-tmpl                dma-gif-packet :inline)
   (billboard-tmpl            dma-gif-packet :inline)
   (billboard-const           vector :inline)
   (shrub-near-packets        shrub-near-packet 6 :inline)
   (dma-ref                   dma-packet :inline)
   (dma-end                   dma-packet :inline)
   (wind-const                vector :inline)
   (constants                 vector :inline)
   (color-constant            vector4w :inline)
   (hmge-d                    vector :inline)
   (hvdf-offset               vector :inline)
   (wind-force                vector :inline)
   (color                     vector :inline)
   (bb-color                  vector :inline)
   (min-dist                  vector :inline)
   (temp-vec                  vector :inline)
   (guard-plane               plane 4 :inline)
   (plane                     plane 4 :inline)
   (last                      uint32 4)
   (next                      uint32 4)
   (count                     uint16 4)
   (mod-count                 uint16 4)
   (wind-vectors              uint32)
   (instance-ptr              uint32)
   (chain-ptr                 uint32)
   (chain-ptr-next            uint32)
   (stack-ptr                 uint32)
   (bucket-ptr                uint32)
   (src-ptr                   uint32)
   (to-spr                    uint32)
   (from-spr                  uint32)
   (shrub-count               uint32)
   (node                      uint32 6 :offset 6428)
   (length                    uint32 6)
   (prototypes                uint32)
   (start-bank                uint8 20 :offset 6484)
   (buffer-index              uint32)
   (current-spr               uint32)
   (current-mem               uint32)
   (current-shrub-near-packet uint32)
   (dma-buffer                basic :offset 6524)
   (near-last                 uint32)
   (near-next                 uint32)
   (near-count                uint32)
   (last-shrubs               uint32)
   (chains                    uint32)
   (flags                     uint32)
   (paused                    basic)
   (node-count                uint32)
   (inst-count                uint32)
   (wait-from-spr             uint32)
   (wait-to-spr               uint32)))

(deftype instance-shrub-dma (structure)
  ((instancea uint128 325)
   (instanceb uint128 325)
   (outa      uint128 128)
   (outb      uint128 128)))

(define-extern *instance-shrub-work* instance-shrub-work)

(define-extern draw-drawable-tree-instance-shrub (function drawable-tree-instance-shrub level none))
