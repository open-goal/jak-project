;;-*-Lisp-*-
(in-package goal)

;; name: aligner.gc
;; name in dgo: aligner
;; dgos: GAME, ENGINE

;; DECOMP BEGINS

;; WARN: Unsupported inline assembly instruction kind - [lw ra, return-from-thread(s7)]
;; WARN: Unsupported inline assembly instruction kind - [jr ra]
(defmethod compute-alignment! align-control ((obj align-control))
  (local-vars (a0-9 symbol) (s7-0 none) (ra-0 int))
  (with-pp
    (let ((s5-0 (-> obj process skel active-channels)))
      (dotimes (s4-0 s5-0)
        (let* ((a0-3 (-> obj process skel channel s4-0))
               (v1-5 (-> a0-3 frame-group))
               (a0-4 (-> a0-3 command))
               (a1-0 'stack)
               (a2-0 (= a0-4 a1-0))
               )
          (cond
            ((or a2-0 (begin (set! a1-0 'stack1) (= a0-4 a1-0)))
             )
            (else
                                        ; TODO - support decompiling the return-from-thread
                                        ; TODO - properly decompile the `go`to
                                        ; (when (!= (-> v1-5 type) art-joint-anim)
                                        ;  (let
                                        ;   ((t9-0 (the-as (function object object object object) enter-state))
                                        ;    (a0-7 "align joint-anim")
                                        ;    )
                                        ;   (set! (-> pp next-state) process-drawable-art-error)
                                        ;   (t9-0 a0-7 (the-as none a1-0) a2-0)
                                        ;   )
                                        ;  (.lw ra-0 return-from-thread s7-0)
                                        ;  (.jr ra-0)
                                        ;  (nop!)
                                        ;  0
                                        ;  )
             0
             )
            )
          )
        )
      )
    (let* ((a0-8 (-> obj process skel root-channel 0))
           (v1-16 (-> a0-8 frame-group))
           (f0-0 (-> a0-8 frame-num))
           )
      (= (-> a0-8 num-func) num-func-loop!)
      (cond
        ((or (not v1-16) (!= (-> obj frame-group) v1-16))
         (set! a0-9 #t)
         )
        ((= (-> a0-8 num-func) num-func-loop!)
         (set! a0-9 (< (* (-> a0-8 param 0) (- f0-0 (-> obj frame-num))) 0.0))
         )
        (else
          (set! a0-9 (= f0-0 0.0))
          )
        )
      (if a0-9
          (logior! (-> obj flags) (align-flags disabled))
          (logclear! (-> obj flags) (align-flags disabled))
          )
      (set! (-> obj frame-group) v1-16)
      (set! (-> obj frame-num) f0-0)
      )
    (mem-copy! (the-as pointer (-> obj transform 1)) (the-as pointer (-> obj transform)) 48)
    (quaternion-copy! (the-as quaternion (-> obj transform 1 rot)) (-> obj align quat))
    (set! (-> obj transform 1 scale quad) (-> obj align scale quad))
    (let* ((a2-5 (-> obj matrix 1 vector))
           (a3-0 (-> obj matrix))
           (v1-19 (-> a3-0 0 vector 0 quad))
           (a0-18 (-> a3-0 0 vector 1 quad))
           (a1-12 (-> a3-0 0 vector 2 quad))
           (a3-1 (-> a3-0 0 vector 3 quad))
           )
      (set! (-> a2-5 0 quad) v1-19)
      (set! (-> a2-5 1 quad) a0-18)
      (set! (-> a2-5 2 quad) a1-12)
      (set! (-> a2-5 3 quad) a3-1)
      )
    (let ((s5-1 (-> obj process node-list data 1)))
      (cspace<-matrix-no-push-joint! s5-1 (-> obj process skel))
      (let* ((v1-23 (-> obj matrix))
             (a3-2 (-> s5-1 bone transform))
             (a0-21 (-> a3-2 vector 0 quad))
             (a1-14 (-> a3-2 vector 1 quad))
             (a2-6 (-> a3-2 vector 2 quad))
             (a3-3 (-> a3-2 vector 3 quad))
             )
        (set! (-> v1-23 0 vector 0 quad) a0-21)
        (set! (-> v1-23 0 vector 1 quad) a1-14)
        (set! (-> v1-23 0 vector 2 quad) a2-6)
        (set! (-> v1-23 0 vector 3 quad) a3-3)
        )
      (vector*! (the-as vector (-> obj transform)) (-> s5-1 bone transform vector 3) (-> obj process root scale))
      )
    (vector-!
      (the-as vector (-> obj delta))
      (the-as vector (-> obj transform))
      (the-as vector (-> obj transform 1))
      )
    (set-vector!
      (-> obj align scale)
      (vector-length (the-as vector (-> obj matrix)))
      (vector-length (-> obj matrix 0 vector 1))
      (vector-length (-> obj matrix 0 vector 2))
      1.0
      )
    (vector-! (-> obj delta scale) (-> obj align scale) (-> obj transform 1 scale))
    (let ((a2-8 (matrix-inv-scale! (new 'stack-no-clear 'matrix) (-> obj align scale))))
      (quaternion-normalize!
        (matrix->quaternion (-> obj align quat) (matrix*! a2-8 (the-as matrix (-> obj matrix)) a2-8))
        )
      )
    (let ((a1-24 (quaternion-inverse! (new 'stack-no-clear 'quaternion) (the-as quaternion (-> obj transform 1 rot)))))
      (quaternion-normalize! (quaternion*! (-> obj delta quat) a1-24 (-> obj align quat)))
      )
    (-> obj delta)
    )
  )

(defmethod first-transform align-control ((obj align-control))
  (the-as transform (-> obj transform))
  )

(defmethod snd-transform align-control ((obj align-control))
  (-> obj transform 1)
  )

(defmethod align! align-control ((obj align-control) (arg0 align-opts) (arg1 float) (arg2 float) (arg3 float))
  (when (zero? (logand (-> obj flags) (align-flags disabled)))
    (let* ((a0-1 (-> obj process))
           (t9-0 (method-of-object a0-1 apply-alignment))
           (v1-4 (-> obj delta))
           (t1-0 (new 'stack-no-clear 'vector))
           )
      (set! (-> t1-0 x) arg1)
      (set! (-> t1-0 y) arg2)
      (set! (-> t1-0 z) arg3)
      (set! (-> t1-0 w) 1.0)
      (t9-0 a0-1 arg0 v1-4 t1-0)
      )
    )
  (-> obj process root)
  )

(defmethod set-and-limit-velocity trsqv ((obj trsqv) (arg0 int) (arg1 vector) (arg2 float))
  (let ((gp-0 (-> obj transv)))
    (when (logtest? arg0 4)
      (set! (-> gp-0 x) (-> arg1 x))
      (set! (-> gp-0 z) (-> arg1 z))
      (let ((f0-4 (fmin (* (vector-xz-length arg1) (-> *display* frames-per-second)) arg2)))
        (vector-xz-normalize! gp-0 f0-4)
        )
      )
    )
  obj
  )

(defmethod align-vel-and-quat-only! align-control ((obj align-control) (arg0 align-opts) (arg1 vector) (arg2 int) (arg3 float) (arg4 float))
  (when (zero? (logand (-> obj flags) (align-flags disabled)))
    (let ((s5-0 (-> obj delta)))
      (let ((s3-0 (-> obj process root transv)))
        (if (logtest? arg0 (align-opts adjust-y-vel))
            (set! (-> s3-0 y) (* (-> s5-0 trans y) arg3 (-> *display* frames-per-second)))
            )
        (when (logtest? arg0 (align-opts adjust-xz-vel))
          (set! (-> s3-0 x) (-> arg1 x))
          (set! (-> s3-0 z) (-> arg1 z))
          (let ((f0-8 (* (fmin (vector-xz-length arg1) (* (vector-xz-length (-> s5-0 trans)) arg4))
                         (-> *display* frames-per-second)
                         )
                      )
                (t9-2 vector-xz-normalize!)
                )
            (set! (-> obj last-speed) f0-8)
            (t9-2 s3-0 f0-8)
            )
          )
        )
      (if (logtest? arg0 (align-opts adjust-quat))
          (quaternion-normalize! (quaternion*! (-> obj process root quat) (-> obj process root quat) (-> s5-0 quat)))
          )
      )
    )
  (-> obj process root)
  )



