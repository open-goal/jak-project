;;-*-Lisp-*-
(in-package goal)

;; name: math.gc
;; name in dgo: math
;; dgos: GAME, ENGINE

;; various math helpers

;; DECOMP BEGINS

(defun truncate ((arg0 float))
  (the float (the int arg0))
  )

(defun integral? ((arg0 float))
  (= (the float (the int arg0)) arg0)
  )

(defun fractional-part ((arg0 float))
  (- arg0 (the float (the int arg0)))
  )

(deftype rgba (uint32)
  ((r uint8 :offset   0 :size   8)
   (g uint8 :offset   8 :size   8)
   (b uint8 :offset  16 :size   8)
   (a uint8 :offset  24 :size   8)
   )
  )

(deftype xyzw (uint128)
  ()
  )

(deftype xyzwh (uint128)
  ()
  )

(defun log2 ((arg0 int))
  (+ (sar (the-as int (the float arg0)) 23) -127)
  )

(defun seek ((x float) (target float) (diff float))
  (let ((err (- target x)))
    (cond
      ((>= diff (fabs err))
       target
       )
      ((>= err 0.0)
       (+ x diff)
       )
      (else
        (- x diff)
        )
      )
    )
  )

(defun lerp ((minimum float) (maximum float) (amount float))
  (+ minimum (* amount (- maximum minimum)))
  )

(defun lerp-scale ((min-out float) (max-out float) (in float) (min-in float) (max-in float))
  (let ((scale (fmax 0.0 (fmin 1.0 (/ (- in min-in) (- max-in min-in))))))
    (+ (* (- 1.0 scale) min-out) (* scale max-out))
    )
  )

(defun lerp-clamp ((minimum float) (maximum float) (amount float))
  (cond
    ((>= 0.0 amount)
     minimum
     )
    ((>= amount 1.0)
     maximum
     )
    (else
      (+ (* (- 1.0 amount) minimum) (* amount maximum))
      )
    )
  )

(defun seekl ((arg0 int) (arg1 int) (arg2 int))
  (let* ((v1-0 (- arg1 arg0))
         (a3-0 (abs v1-0))
         )
    (cond
      ((>= arg2 a3-0)
       arg1
       )
      ((>= v1-0 0)
       (+ arg0 arg2)
       )
      (else
        (- arg0 arg2)
        )
      )
    )
  )

;; ERROR: Unsupported inline assembly instruction kind - [ctc2.i vi_R, a0]
;; ERROR: Unsupported inline assembly instruction kind - [cfc2.i v0, vi_R]
(defun rand-vu-init ((arg0 float))
  (local-vars (v0-0 int))
  (.ctc2.i vi_R arg0)
  (.cfc2.i v0-0 vi_R)
  (the-as float v0-0)
  )

(rand-vu-init 1.418091)

;; ERROR: Inline assembly instruction marked with TODO - [TODO.VRGET]
;; ERROR: Inline assembly instruction marked with TODO - [TODO.VRXOR]
;; ERROR: Inline assembly instruction marked with TODO - [TODO.VRNEXT]
(defun rand-vu ()
  (local-vars (v0-0 float))
  (rlet ((Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (TODO.VRGET vf1)
    (.sqrt.vf Q vf1 :ftf #b0)
    (.add.vf vf2 vf0 Q :mask #b1)
    (TODO.VRXOR vf2)
    (TODO.VRNEXT vf1)
    (.sub.w.vf vf1 vf1 vf0)
    (.mov v0-0 vf1)
    v0-0
    )
  )

;; ERROR: Inline assembly instruction marked with TODO - [TODO.VRGET]
(defun rand-vu-nostep ()
  (local-vars (v0-0 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         )
    (init-vf0-vector)
    (TODO.VRGET vf1)
    (.sub.w.vf vf1 vf1 vf0)
    (.mov v0-0 vf1)
    v0-0
    )
  )

(defun rand-vu-float-range ((arg0 float) (arg1 float))
  (+ arg0 (* (rand-vu) (- arg1 arg0)))
  )

(defun rand-vu-percent? ((arg0 float))
  (>= arg0 (rand-vu))
  )

(defun rand-vu-int-range ((first int) (second int))
  (if (< first second)
      (set! second (+ second 1))
      (set! first (+ first 1))
      )
  (let ((float-in-range (rand-vu-float-range (the float first) (the float second))))
    (if (< float-in-range 0.0)
        (set! float-in-range (+ -1.0 float-in-range))
        )
    (the int float-in-range)
    )
  )

(defun rand-vu-int-count ((arg0 int))
  (the int (* (rand-vu) (the float arg0)))
  )

(deftype random-generator (basic)
  ((seed  uint32)
   )
  )


(define *random-generator* (new 'global 'random-generator))

(set! (-> *random-generator* seed) (the-as uint #x666edd1e))

;; ERROR: function was not converted to expressions. Cannot decompile.
