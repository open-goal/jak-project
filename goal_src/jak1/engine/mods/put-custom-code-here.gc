;;-*-Lisp-*-
(in-package goal)

;; name: put-custom-code-here.gc
;; name in dgo: put-custom-code-here
;; dgos: TODO


;;;;;;;;;;;;;;;;;;;;;;;;;;
;; What is this file for.
;;;;;;;;;;;;;;;;;;;;;;;;;;

#| This file contains function defenitions that are pre placed in the mod base,
so if you place custom code inside of these functions, it will exectue based on
the name of the function, for example, if you place (set! (-> *game-info* fuel) (+ (-> *game-info* fuel) 1))
to the function named runs-on-orb-pickup, then jaks powercell count will increase each time you collect
an orb |#


;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Begin function defintions.
;;;;;;;;;;;;;;;;;;;;;;;;;;

(define *multiplayer-info* (new 'global 'multiplayer-info))
(define *registered-with-server?* #f)
(define *last-position-sync-time* (the-as time-frame #f))
(define *lobby-continue-point* "village1-hut")
(define *hider-continue-point* "jungle-start")
(define *seeker-continue-point* "beach-start")

(define *remote-targets* (new 'global 'boxed-array handle MAX_MULTIPLAYER_COUNT))

(defun start-extra-target ()
  (ppointer->handle (process-spawn
                target
                :init init-target
                  (-> *game-info* current-continue)
                :from *target-dead-pool*
                :to *target-pool*
                :stack *kernel-dram-stack*
                ))
  )

(defun get-target ((idx int))
  (if (= (-> *multiplayer-info* player_num) -1)
    (if (= idx 0)
      *target*
      (the-as target #f)
      )
    (if (= (-> *multiplayer-info* player_num) idx)
      *target*
      (if (and (-> *remote-targets* idx) (nonzero? (-> *remote-targets* idx)) (handle->process (-> *remote-targets* idx)))
        (the target (handle->process (-> *remote-targets* idx)))
        (the-as target #f)
        )
      )
    )
  )

(defun position-actor ((obj process-drawable) (p remote-player-info))
  ;; position
  (set! (-> obj root trans x) (-> p trans_x))
  (set! (-> obj root trans y) (-> p trans_y))
  (set! (-> obj root trans z) (-> p trans_z))
  ;; rotation
  (set! (-> obj root quat x)  (-> p quat_x))
  (set! (-> obj root quat y)  (-> p quat_y))
  (set! (-> obj root quat z)  (-> p quat_z))
  (set! (-> obj root quat w)  (-> p quat_w))

  ;; additional steps for rotation, state, etc
  (case (-> obj type)
    ((target)
      (let* ((t (the target obj))
             (local-seeker? (= (-> *multiplayer-info* players (-> *multiplayer-info* player_num) role) (mp-game-role seeker)))
             (remote-seeker? (= (-> p role) (mp-game-role seeker)))
             )
        ;; draw usernames if both players are seekers/hiders
        (when (= local-seeker? remote-seeker?)
          (add-debug-text-3d
                       #t
                       (bucket-id debug-no-zbuf)
                       (-> p username)
                       (-> t root trans)
                       (font-color white)
                       (new 'static 'vector2h :y 16)
                       )
          )

        ;; make invulnerable so they dont die
        (logior! (-> t state-flags) (state-flags invulnerable))

        ;; finalize rotation
        (quaternion-copy! (-> t control dir-targ) (-> t root quat))
          
        ;; sync target state
        (target-sync-state (-> p tgt_state) t)
        )
      )
    ((money)
      (let ((m (the money obj)))
        (vector-copy! (-> m base) (-> m root trans))
        (vector-copy! (-> m root-override root-prim world-sphere) (-> m root trans))
        )
      )
    )
    (none)
  )

(define *self-player-info* (the-as remote-player-info #f))
(define *game-state-change-time* (the-as time-frame #f))

(define *multiplayer-mode* 'jaks)
(defun-extern gmenu-1 (none) )
(define mod-on? #f)
;; (define *multiplayer-mode* 'orbs)
(defun runs-every-frame ()

  ;;display debug info menu if on
  (gmenu-1)

  ;; setup our own remote-player-info if we haven't yet
  (when (not *self-player-info*)
    (set! *self-player-info* (new 'global 'remote-player-info))
    (set! (-> *self-player-info* username) "zed") ;; TODO - pull this from settings I guess?
    (set! (-> *self-player-info* color) (tgt-color red)) ;; TODO - pull this from settings I guess?
    )

  ;; register with server if we haven't yet
  (when (and *target* (not *registered-with-server?*))
    (pc-http-register *multiplayer-info* *self-player-info*)
    (set! *registered-with-server?* #t)
    ;; wait a bit to ensure registration before syncing position
    (set! *last-position-sync-time* (+ (-> *display* base-frame-counter) (seconds 3.0)))
    )

  (when (and *target* (>= (-> *multiplayer-info* player_num) 0) (< (-> *multiplayer-info* player_num) MAX_MULTIPLAYER_COUNT))
    (when (!= (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state) (mp-tgt-state mp-tgt-invalid))
      ;; jump to lobby if we're in lobby state and not already there (e.g. joined in middle of game)
      (when (and (= (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state) (mp-tgt-state mp-tgt-lobby))
                  (not (string= (-> *game-info* current-continue name) *lobby-continue-point*))
                  )
        (start 'play (get-continue-by-name *game-info* *lobby-continue-point*))
        )

      (case (-> *multiplayer-info* state)
        (((mp-game-state mp-game-lobby))
          ;; jump to lobby if game is in lobby state and we're not already there
          (when (not (string= (-> *game-info* current-continue name) *lobby-continue-point*))
            (start 'play (get-continue-by-name *game-info* *lobby-continue-point*))
            (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state) (mp-tgt-state mp-tgt-lobby))
            )
          ;; TODO: show players and waiting/ready state
          ;; TODO: show press O to ready up text
          (when (cpad-pressed? 0 r2)
            (case (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state)
              (((mp-tgt-state mp-tgt-lobby))
                (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state) (mp-tgt-state mp-tgt-ready))
                )
              (((mp-tgt-state mp-tgt-ready))
                (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state) (mp-tgt-state mp-tgt-start))
                )
              )
            )
          )
        (((mp-game-state mp-game-starting-soon))
          ;; jump to lobby if game is in starting-soon state and we're not already there
          (when (not (string= (-> *game-info* current-continue name) *lobby-continue-point*))
            (start 'play (get-continue-by-name *game-info* *lobby-continue-point*))
            (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state) (mp-tgt-state mp-tgt-lobby))
            )
          (when (cpad-pressed? 0 r2)
            (case (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state)
              (((mp-tgt-state mp-tgt-lobby))
                (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state) (mp-tgt-state mp-tgt-ready))
                )
              )
            )
          ;; game was already started, so if we ready, move us to start
          (when (= (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state) (mp-tgt-state mp-tgt-ready))
            (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state) (mp-tgt-state mp-tgt-start))
            )
          ;; TODO: same as lobby, but also show timer
          )
        (((mp-game-state mp-game-play-hide))
          ;; TODO: show text for who's who (toggle?)
          ;; TODO: if seeker, blackout with timer
          (case (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state)
            (((mp-tgt-state mp-tgt-lobby))
              ;; TODO: allow for freecam
              )
            (((mp-tgt-state mp-tgt-ready) (mp-tgt-state mp-tgt-start))
              (case (-> *multiplayer-info* players (-> *multiplayer-info* player_num) role)
                (((mp-game-role hider))
                  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state) (mp-tgt-state mp-tgt-hider-start))
                  )
                (((mp-game-role seeker))
                  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state) (mp-tgt-state mp-tgt-seeker-wait))
                  )
                )
              )
            (((mp-tgt-state mp-tgt-hider-start))
              ;; TODO: spawn at ? checkpoint (based on toggle), show text and timer to controls, switch to hider-play
              (start 'play (get-continue-by-name *game-info* *hider-continue-point*))
              (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state) (mp-tgt-state mp-tgt-hider-play))
              )
            (((mp-tgt-state mp-tgt-hider-play))
              ;; TODO: timer and give controls
              )
            (((mp-tgt-state mp-tgt-seeker-wait))
              ;; TODO blackout with timer
              (set-blackout-frames (seconds 30))
              )
            )
          )
        (((mp-game-state mp-game-play-seek))
          ;; TODO: show alerts when hiders collected (server should set most recent case and then clear every 5s or so?)
          (case (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state)
            (((mp-tgt-state mp-tgt-lobby))
              ;; TODO: allow for freecam
              )
            (((mp-tgt-state mp-tgt-ready) (mp-tgt-state mp-tgt-start))
              ;; shouldn't happen?
              )
            (((mp-tgt-state mp-tgt-hider-start))
              ;; shouldn't happen?
              )
            (((mp-tgt-state mp-tgt-hider-play))
              ;; TODO: show text
              ;; TODO: optionally freeze
              (case (-> *multiplayer-info* players (-> *multiplayer-info* player_num) role)
                (((mp-game-role found))
                  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state) (mp-tgt-state mp-tgt-hider-found))
                  )
                )
              )
            (((mp-tgt-state mp-tgt-hider-found))
              ;; TODO: freeze inputs, timer then return to lobby 
              )
            (((mp-tgt-state mp-tgt-seeker-wait))
              ;; TODO: show text and timer to controls
              (start 'play (get-continue-by-name *game-info* *seeker-continue-point*))
              (set-blackout-frames 0)
              (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state) (mp-tgt-state mp-tgt-seeker-play))
              )
            (((mp-tgt-state mp-tgt-seeker-play))
              ;; TODO: option to give up
              ;; check for finding other players
              (dotimes (idx MAX_MULTIPLAYER_COUNT)
                (when (and (!= (-> *multiplayer-info* player_num) idx)
                           (!= (-> *multiplayer-info* players idx mp_state) (mp-tgt-state mp-tgt-invalid))
                           (!= (-> *multiplayer-info* players idx mp_state) (mp-tgt-state mp-tgt-hider-found))
                           (!= (-> *multiplayer-info* players idx mp_state) (mp-tgt-state mp-tgt-lobby))
                           (< (vector-vector-distance (-> *target* root trans) (-> (get-target idx) root trans)) (meters 2.0))
                           )
                  (pc-http-mark-found idx)
                  )
                )
              )
            )
          )
        (((mp-game-state mp-game-end))
          ;; TODO: show text about who won, stats, idfk
          )
        )
      )

    ;; if never synced positions, or its been X ms, request updated positions
    (when (or (not *last-position-sync-time*)
              (>= (- (-> *display* base-frame-counter) *last-position-sync-time*) (seconds 0.5)))
      ;; update last sync time
      (set! *last-position-sync-time* (-> *display* base-frame-counter))

      ;; update this player's position and send to server
      (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) username)   (-> *self-player-info* username))
      (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) color)      (-> *self-player-info* color))
      (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) trans_x)    (-> *target* root trans x))
      (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) trans_y)    (-> *target* root trans y))
      (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) trans_z)    (-> *target* root trans z))
      (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) quat_x)     (-> *target* root quat x))
      (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) quat_y)     (-> *target* root quat y))
      (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) quat_z)     (-> *target* root quat z))
      (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) quat_w)     (-> *target* root quat w))
      (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) tgt_state)  (-> *target* state name))

      ;; if first time, we need to change our state from invalid to lobby
      ;; this is also sort of like an "ack" back to the server to count you as fully joined
      (if (= (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state) (mp-tgt-state mp-tgt-invalid))
        (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state) (mp-tgt-state mp-tgt-lobby))
        )
      
      ;; send updated player info to server
      (pc-http-update)

      ;; request to get positions of other players from server (async)
      (pc-http-get)
      )

    (dotimes (idx MAX_MULTIPLAYER_COUNT)
      (when (!= (-> *multiplayer-info* player_num) idx)
        (when (!= (-> *multiplayer-info* players idx mp_state) (mp-tgt-state mp-tgt-invalid))
          ;; see if we need to spawn any remote targets
          (when (or (zero? (-> *remote-targets* idx)) (not (handle->process (-> *remote-targets* idx))))
            (case *multiplayer-mode*
              (('jaks)
                (set! (-> *remote-targets* idx) (start-extra-target))
                )
              (('orbs)
                (let ((vec (new 'stack-no-clear 'vector)))
                  (set! (-> vec x) 0.0)
                  (set! (-> vec y) -80920.0)  ;; spawn orbs 20m under 0,0,0 so nobody can collect them (nice try zed)
                  (set! (-> vec z) 0.0)
                  (set! (-> *remote-targets* idx) (ppointer->handle (birth-pickup-at-point-inner
                                                      vec
                                                      (pickup-type money)
                                                      (the-as float 1.0)
                                                      #t
                                                      *target*
                                                      (the-as fact-info #f)
                                                      #f  ;; no-bob
                                                    )))
                  )
                )
              )
            )
          ;; assume target spawned at this point 

          ;; position/color remote targets
          (let ((p (-> *multiplayer-info* players idx))
                (obj (the process-drawable (handle->process (-> *remote-targets* idx)))))
            (when obj
              (position-actor obj p)
              (if (= (-> p role) (mp-game-role seeker))
                (color-target obj (tgt-color holo)) ;; seekers are holo
                (color-target obj (-> p color)) ;; otherwise use player's choice
                )
              )
            )
          )
        )
      )

    ;; color ourselves
    (if (= (-> *multiplayer-info* players (-> *multiplayer-info* player_num) role) (mp-game-role seeker))
      (color-target *target* (tgt-color holo)) ;; seekers are holo
      (color-target *target* (-> *self-player-info* color)) ;; otherwise use player's choice
      )
    )
  (none)
  )

(defun runs-on-orb-pickup ((parent process-tree))
  (let* ((from-cache? (and parent (type-type? (-> parent type) orb-cache-top))))
    ;; Code here runs on ANY orb pickup


    (when from-cache?
      ;; Code here runs only if the orb was from an orb cache

      )

    (when (not from-cache?)
      ;; Code here runs only if the orb was NOT from an orb cache

      )
    )
  (none)
  )

(defun runs-on-fly-pickup ()
  ;; Code here runs on any scout fly pickup

  (none)
  )

(defun runs-on-cell-pickup ((cell-event symbol))
  (case cell-event
    (('pickup)      
      ;; Code here runs as soon as you pickup a powercell

      )
    (('cutscene-end)      
      ;; Code here runs at the end of any powercell cutscene

      )
    )

  (none)
  )

(defun runs-on-eco-pickup ((eco-type pickup-type) (parent process-tree))
  (let* ((from-vent? (and parent (type-type? (-> parent type) vent))))
    ;; Code here runs as soon as you pickup ANY eco

    (case eco-type
      (((pickup-type eco-yellow))      
        ;; Code here runs as soon as you pickup yellow eco

        )
      (((pickup-type eco-red))      
        ;; Code here runs as soon as you pickup red eco

        )
      (((pickup-type eco-blue))      
        ;; Code here runs as soon as you pickup blue eco

        )
      (((pickup-type eco-pill))      
        ;; Code here runs as soon as you pickup small green eco

        )
      (((pickup-type eco-green))      
        ;; Code here runs as soon as you pickup big green eco 

        )
      )
    
    (when from-vent?
      ;; Code here runs only if the eco was picked up from a vent

      )
    )

  (none)
  )

    (defun runs-on-jak-spawn ()
      ;; Code here runs every time jak spawns (loading a file new game or death)   


	
	 
	
  (none)
  )

(defun runs-on-jak-death ((death-event symbol))
  (case death-event
    (('dying)
      ;; Code here runs immediately every time jak dies, before any death animation or death cutscene
      
      )
    (('blackout)
      ;; Code here runs after jak dies (and any death cutscene finishes), during the blackout before he spawns

      )
    )
  
  (none)
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;
;; deprecated function defintions.
;;;;;;;;;;;;;;;;;;;;;;;;;;

#| these are no longer recommended/supported however we include them anyways to not break anyones mods.
|#
