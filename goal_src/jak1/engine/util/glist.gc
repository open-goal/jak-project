;;-*-Lisp-*-
(in-package goal)

;; name: glist.gc
;; name in dgo: glist
;; dgos: GAME, ENGINE


;; THIS FILE IS REALLY WEIRD PLEASE JUST LOOK AWAY

(declare-file (debug))

(defun-debug glst-num-elements ((list glst-list))
  "Return the number of elements on the list"
  (-> list numelem)
  )

(defun-debug glst-remove ((list glst-list) (node glst-node))
  "Remove the node from the list"

  (let ((prev (glst-prev node))
        (next (glst-next node)))
      (set! (-> prev next) next)
      (set! (-> next prev) prev)
        )

  (+! (-> list numelem) -1)
  node
  )

(defun-debug glst-remove-tail ((list glst-list))
  "Remove the last node from the list, if it is not also the first.
   Returns the deleted node, or #f otherwise"

  (let ((tail (glst-tail list)))
      (if (not (glst-start-of-list? (-> tail prev)))
        (glst-remove list tail)
        )
      )
  )

(defun-debug glst-remove-head ((list glst-list))
  "Remove the first node from the list, if it is not also the last.
   Returns the deleted node, or #f otherwise"

  (let ((head (glst-head list)))
      (if (not (glst-end-of-list? (-> head next)))
        (glst-remove list head)
        )
      )
  )

(defun-debug glst-insert-before ((list glst-list) (node glst-node) (new-node glst-node))
  "Insert a new node before node in the list.
   Returns the new node."

  (let ((prev (glst-prev node)))
      (set! (-> new-node prev) prev)
      (set! (-> new-node next) node)
      (set! (-> prev next) new-node)
      (set! (-> node prev) new-node)
      )

  (+! (-> list numelem) 1)
  new-node
  )

(defun-debug glst-insert-after ((list glst-list) (node glst-node) (new-node glst-node))
  "Insert a new node after node in the list.
   Returns the new node."

  (let ((next (glst-next node)))
      (set! (-> new-node next) next)
      (set! (-> new-node prev) node)
      (set! (-> next prev) new-node)
      (set! (-> node next) new-node)
      )

  (+! (-> list numelem) 1)
  new-node
  )

(defun-debug glst-add-tail ((list glst-list) (node glst-node))
  "Add a node to the end of the list"

  (glst-insert-before list (the-as glst-node (&-> list tail)) node)
  )

(defun-debug glst-add-head ((list glst-list) (node glst-node))
  "Add a node to the start of the list"

  (glst-insert-after list (the-as glst-node (&-> list head)) node)
  )

(defun-debug glst-init-list! ((list glst-list))
  "Init the list"

  (set! (-> list head) (the-as glst-node (&-> list tail)))
  (set! (-> list tail) #f)
  (set! (-> list tailpred) (the-as glst-node (&-> list head)))
  (set! (-> list numelem) 0)
  list
  )

(defmacro glst-iterate-list (list node &rest body)
  "Iterate through the list using node as the current node variable"

  `(let ((,node (glst-head ,list)))
      (while (not (glst-end-of-list? (-> ,node next)))
        ,@body
        (set! ,node (glst-next ,node))
        )
      )
  )

(defmacro glst-iterate-named-list (list node &rest body)
  "Iterate through the named node list using node as the current node variable"

  `(let ((,node (the glst-named-node (glst-head ,list))))
      (while (not (glst-end-of-list? (-> ,node next)))
        ,@body
        (set! ,node (the glst-named-node (glst-next ,node)))
        )
      )
  )

(defun-debug glst-find-node-by-name ((list glst-list) (name string))
  "Find the node in the list with the given name and return it. If it is not found, #f is returned instead"

  (glst-iterate-named-list list node
    (if (name= (-> node privname) name)
      (return node)
      )
    )
  (the-as glst-node #f)
  )

(defun-debug glst-get-node-by-index ((list glst-list) (n int))
  "Return the n-th node in the list, beginning at zero"

  (if (and (< n (glst-num-elements list)) (>= n 0))
    (let ((node (glst-head list)))
        (dotimes (index n)
          ;; (nop!) x4
          (set! node (glst-next node))
          )
        (return node)
        )
    )
  (the-as glst-node #f)
  )

(defun-debug glst-length-of-longest-name ((list glst-list))
  "Returns the length of longest name in a list of named nodes"

  (let ((max-len 0))
    (glst-iterate-named-list list node
      (let ((len (length (-> node privname))))
          (when (< max-len len)
            (set! max-len len)
            )
          )
      )
    max-len
    )
  )

(defun-debug glst-get-node-index ((list glst-list) (node glst-node))
  "Returns the index of the node in the list. If the node is not found on the list, returns -1"

  (let ((index 0))
    (glst-iterate-list list current-node
      (if (= current-node node) (return index))
      (+! index 1)
      )
    -1
    )
  )

