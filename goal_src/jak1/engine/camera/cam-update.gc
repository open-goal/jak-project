;;-*-Lisp-*-
(in-package goal)

;; name: cam-update.gc
;; name in dgo: cam-update
;; dgos: GAME, ENGINE

;; Once the camera's position and orientation has been calculated,
;; the camera and visibility outputs are updated in this file.

(defun plane-from-points ((arg0 (inline-array plane)) (arg1 vector) (arg2 vector) (arg3 vector) (arg4 int))
  "Get a plane that contains the 3 given points."
  (let ((s4-0 (new 'stack-no-clear 'vector)))
    (vector-cross! s4-0 arg1 arg2)
    (vector-normalize! s4-0 1.0)
    (set! (-> s4-0 w) (vector-dot s4-0 arg3))
    (set! (-> (&-> arg0 0 data arg4) 0) (-> s4-0 x))
    (set! (-> (&-> arg0 0 data arg4) 4) (-> s4-0 y))
    (set! (-> (&-> arg0 0 data arg4) 8) (-> s4-0 z))
    (set! (-> (&-> arg0 0 data arg4) 12) (-> s4-0 w))
    )
  (none)
  )

(defun set-point ((arg0 vector) (arg1 float) (arg2 float) (arg3 float))
  "Set a vector to an xyz point (sets w = 1.0)"
  (set! (-> arg0 x) arg1)
  (set! (-> arg0 y) arg2)
  (set! (-> arg0 z) arg3)
  (set! (-> arg0 w) 1.0)
  (none)
  )

(defun update-view-planes ((arg0 math-camera) (arg1 (inline-array plane)) (arg2 float))
  "Compute the frustum planes from the given camera."
  (local-vars (sv-240 vector))
  (when (not *artist-fix-frustum*)
    (let ((s5-0 (new 'stack 'view-frustum)))
      (let ((f30-0 (* arg2 (-> arg0 x-ratio) (-> arg0 d)))
            (f26-0 (* arg2 (-> arg0 y-ratio) (-> arg0 d)))
            (f28-0 (* arg2 (-> arg0 x-ratio) (-> arg0 f)))
            (f24-0 (* arg2 (-> arg0 y-ratio) (-> arg0 f)))
            )
        (set-point (-> s5-0 hither-top-left) (- f30-0) f26-0 (-> arg0 d))
        (set-point (-> s5-0 hither-top-right) f30-0 f26-0 (-> arg0 d))
        (set-point (-> s5-0 hither-bottom-left) (- f30-0) (- f26-0) (-> arg0 d))
        (set-point (-> s5-0 hither-bottom-right) f30-0 (- f26-0) (-> arg0 d))
        (set-point (-> s5-0 yon-top-left) (- f28-0) f24-0 (-> arg0 f))
        (set-point (-> s5-0 yon-top-right) f28-0 f24-0 (-> arg0 f))
        (set-point (-> s5-0 yon-bottom-left) (- f28-0) (- f24-0) (-> arg0 f))
        (set-point (-> s5-0 yon-bottom-right) f28-0 (- f24-0) (-> arg0 f))
        )
      (vector-matrix*! (-> s5-0 hither-top-left) (-> s5-0 hither-top-left) (-> arg0 inv-camera-rot))
      (vector-matrix*! (-> s5-0 hither-top-right) (-> s5-0 hither-top-right) (-> arg0 inv-camera-rot))
      (vector-matrix*! (-> s5-0 hither-bottom-left) (-> s5-0 hither-bottom-left) (-> arg0 inv-camera-rot))
      (vector-matrix*! (-> s5-0 hither-bottom-right) (-> s5-0 hither-bottom-right) (-> arg0 inv-camera-rot))
      (vector-matrix*! (-> s5-0 yon-top-left) (-> s5-0 yon-top-left) (-> arg0 inv-camera-rot))
      (vector-matrix*! (-> s5-0 yon-top-right) (-> s5-0 yon-top-right) (-> arg0 inv-camera-rot))
      (vector-matrix*! (-> s5-0 yon-bottom-left) (-> s5-0 yon-bottom-left) (-> arg0 inv-camera-rot))
      (vector-matrix*! (-> s5-0 yon-bottom-right) (-> s5-0 yon-bottom-right) (-> arg0 inv-camera-rot))
      (let ((s2-0 (new-stack-vector0))
            (s3-1 (new-stack-vector0))
            (s1-0 (new-stack-vector0))
            (s0-0 (new-stack-vector0))
            )
        (set! (-> (new 'stack-no-clear 'vector) quad) (the-as uint128 0))
        (set! sv-240 (new 'stack-no-clear 'vector))
        (set! (-> sv-240 quad) (the-as uint128 0))
        (let ((v1-5 (-> arg0 inv-camera-rot vector 3 quad)))
          (set! (-> sv-240 quad) v1-5)
          )
        (vector-! s2-0 (-> s5-0 yon-top-left) sv-240)
        (vector-! s3-1 (-> s5-0 yon-top-right) sv-240)
        (vector-! s1-0 (-> s5-0 yon-bottom-left) sv-240)
        (vector-! s0-0 (-> s5-0 yon-bottom-right) sv-240)
        (plane-from-points arg1 s2-0 s1-0 sv-240 0)
        (plane-from-points arg1 s0-0 s3-1 sv-240 1)
        (plane-from-points arg1 s3-1 s2-0 sv-240 2)
        (let ((t9-20 plane-from-points)
              (t0-3 3)
              )
          (t9-20 arg1 s1-0 s0-0 sv-240 t0-3)
          )
        )
      )
    )
  (none)
  )

;; if we should still attempt vis updates when outside of the bsp's boxes.
(define *update-leaf-when-outside-bsp* #t)

(defun update-visible ((arg0 math-camera))
  "Update occlusion visibility data for the camera position.
   Each level has a bsp. Each leaf of the bsp stores a list of visible objects.
   This is used to implement occlusion culling.
   The vis-bits of the level will be updated if needed."
  (local-vars (a0-16 symbol) (s3-0 level-vis-info) (s4-0 level-vis-info))
  (when (not *artist-fix-visible*)
    ;; first, determine which leaf of the bsp we are in (per level).
    (dotimes (s5-0 (-> *level* length))
      (let ((v1-4 (-> *level* level s5-0)))
        (when (= (-> v1-4 status) 'active)
          (if (and (nonzero? (-> v1-4 bsp nodes))
                   (or *update-leaf-when-outside-bsp* (-> v1-4 inside-boxes?))
                   )
              ;; will store in the bsp's current-leaf-idx.
              (bsp-camera-asm (-> v1-4 bsp) (-> arg0 trans))
              )
          )
        )
      )

    ;; do vis updates.
    (dotimes (gp-1 (-> *level* length))
      (let ((s5-1 (-> *level* level gp-1)))
        (when (= (-> s5-1 status) 'active)
          (let ((a2-0 (/ (+ (-> s5-1 bsp visible-list-length) 15) 16)))
            
            ;; start by setting all-visible to something truthy (either original, or #t)
            ;; below, we'll try to figure out a way to get vis data and set this back to #f.
            (set! (-> s5-1 all-visible?) (if (-> s5-1 all-visible?)
                                             (-> s5-1 all-visible?)
                                             #t
                                             )
                  )
            (cond
              ((or (not (-> s5-1 force-all-visible?)) (-> s5-1 inside-boxes?))
               ;; we are inside the level's bsp, we should attempt vis stuff.
               (cond
                 ((or *artist-all-visible* (zero? (-> s5-1 bsp nodes)))
                  ;; we have no bsp, or manual override all visible. Copy the all vis list
                  ;; to our vis string.
                  (quad-copy! (-> s5-1 vis-bits) (-> s5-1 bsp all-visible-list) a2-0)
                  )
                 ((begin
                    ;; our vis info
                    (set! s4-0 (-> s5-1 vis-info (-> s5-1 vis-self-index)))
                    ;; adj vis info (idx will be 7 if there's no adj right now, and will give us #f)
                    (set! s3-0 (-> s5-1 vis-info (-> s5-1 vis-adj-index)))
                    
                    (let ((v1-32 #f)) ;; should use self vis
                      (set! a0-16 #f) ;; should use adj vis
                      
                      ;; see if we want self vis
                      (when s4-0
                        (set! v1-32 (nonzero? (logand (shl #x8000 16) (-> s4-0 flags))))
                        
                        ;; not sure when this would happen, but make sure that our leaf
                        ;; index is in bounds (maybe if you use the wrong version of levels)
                        (if (< (-> s4-0 length) (-> s4-0 from-bsp current-leaf-idx))
                            (set! v1-32 #f)
                            )
                        )
                      
                      ;; see if we want adj vis.
                      (when s3-0
                        (set! a0-16 (nonzero? (logand (shl #x8000 16) (-> s3-0 flags))))
                        (if (< (-> s3-0 length) (-> s3-0 from-bsp current-leaf-idx))
                            (set! a0-16 #f)
                            )
                        )
                      v1-32 ;; this is the cond condition, and is if we want the self vis.
                      )
                    )
                  ;; want self.  clear all visible if we aren't loading.
                  (if (!= (-> s5-1 all-visible?) 'loading)
                      (set! (-> s5-1 all-visible?) #f)
                      )
                  (when (update-vis! s5-1 s4-0 (-> s4-0 ramdisk) (-> s4-0 string-block))
                    ;; success! Remove all other vis strings.
                    ;; if update vis failed (due to still loading, etc), keep previous.
                    (countdown (v1-40 8)
                      (let ((a0-22 (-> s5-1 vis-info v1-40)))
                        (when a0-22
                          (if (!= a0-22 s4-0)
                              (set! (-> a0-22 current-vis-string) (the-as uint -1))
                              )
                          )
                        )
                      )
                    ;; successful vis update, remove all-visible.
                    (set! (-> s5-1 all-visible?) #f)
                    )
                  )
                 ;; same case as above, but if we want to use the other vis.
                 (a0-16
                   (if (!= (-> s5-1 all-visible?) 'loading)
                       (set! (-> s5-1 all-visible?) #f)
                       )
                   (when
                     (update-vis! s5-1 s3-0 (-> s3-0 ramdisk) (-> s3-0 string-block))
                     (countdown (v1-50 8)
                       (let ((a0-27 (-> s5-1 vis-info v1-50)))
                         (when a0-27
                           (if (!= a0-27 s3-0)
                               (set! (-> a0-27 current-vis-string) (the-as uint -1))
                               )
                           )
                         )
                       )
                     (set! (-> s5-1 all-visible?) #f)
                     )
                   )
                 ((and (= (-> s5-1 all-visible?) 'loading) (-> *level* play?))
                  ;; if we're in between vis, then leave the old string.
                  )
                 (else
                   ;; couldn't find any vis, just make everything visible
                   (quad-copy! (-> s5-1 vis-bits) (-> s5-1 bsp all-visible-list) a2-0)
                   )
                 )
               )
              (else
                ;; outside boxes, and force all visible is set.
                (quad-copy! (-> s5-1 vis-bits) (-> s5-1 bsp all-visible-list) a2-0)
                )
              )
            )
          (if (and *stats-bsp* (= *master-mode* 'game))
              (format *stdcon* "~0kleaf-index = ~d~%" (-> s5-1 bsp current-leaf-idx))
              )
          )
        )
      )
    #f
    )
  )

(define *save-camera-inv-rot* (new 'global 'matrix))

(matrix-identity! *save-camera-inv-rot*)

(defun move-camera-from-pad ((arg0 math-camera))
  (let ((v1-0 *external-cam-mode*)
        (s5-0 0)
        )
    (cond
      ((= v1-0 'locked)
       (set! v1-0 #f)
       )
      ((= v1-0 'pad-1)
       (set! s5-0 1)
       )
      ((not *camera-combiner*)
       (set! v1-0 'pad-0)
       )
      )
    (when v1-0
      (let ((s4-1
              (vector-negate-in-place! (vector-normalize-copy! (new-stack-vector0) (-> *standard-dynamics* gravity) 1.0))
              )
            )
        (if (= (vector-length s4-1) 0.0)
            (set! (-> s4-1 y) -1.0)
            )
        (if (logtest? *external-cam-options* (external-cam-option allow-z))
            (set! s4-1 (the-as vector #f))
            )
        (cam-free-floating-move *save-camera-inv-rot* (-> arg0 trans) s4-1 s5-0)
        )
      )
    )
  (let* ((a2-2 (-> *math-camera* inv-camera-rot))
         (a3-1 *save-camera-inv-rot*)
         (v1-11 (-> a3-1 vector 0 quad))
         (a0-14 (-> a3-1 vector 1 quad))
         (a1-2 (-> a3-1 vector 2 quad))
         (a3-2 (-> a3-1 vector 3 quad))
         )
    (set! (-> a2-2 vector 0 quad) v1-11)
    (set! (-> a2-2 vector 1 quad) a0-14)
    (set! (-> a2-2 vector 2 quad) a1-2)
    (set! (-> a2-2 vector 3 quad) a3-2)
    )
  arg0
  )

;; PAL patch here (moved from cam-debug)
(defun external-cam-reset! ()
  (vector-reset! (-> *math-camera* trans))
  (matrix-identity! (-> *math-camera* inv-camera-rot))
  (when *camera-combiner*
    (let* ((v1-6 (-> *math-camera* inv-camera-rot))
           (a3-0 (-> *camera-combiner* inv-camera-rot))
           (a0-2 (-> a3-0 vector 0 quad))
           (a1-0 (-> a3-0 vector 1 quad))
           (a2-0 (-> a3-0 vector 2 quad))
           (a3-1 (-> a3-0 vector 3 quad))
           )
      (set! (-> v1-6 vector 0 quad) a0-2)
      (set! (-> v1-6 vector 1 quad) a1-0)
      (set! (-> v1-6 vector 2 quad) a2-0)
      (set! (-> v1-6 vector 3 quad) a3-1)
      )
    (set! (-> *math-camera* trans quad) (-> *camera-combiner* trans quad))
    )
  0
  (none)
  )

(define *start-timer* (the-as int #f))

(define *timer-value* 0)

(define *start-pos* (new 'global 'vector))

(defun update-camera ()
  (when *start-timer*
    (when (= *timer-value* 180)
      (format
        #t
        "Player pos = ~F ~F ~F~%"
        (-> *target* control trans x)
        (-> *target* control trans y)
        (-> *target* control trans z)
        )
      (set! (-> *start-pos* quad) (-> *target* control trans quad))
      )
    (when (= *timer-value* 480)
      (format
        #t
        "Player pos = ~F ~F ~F~%"
        (-> *target* control trans x)
        (-> *target* control trans y)
        (-> *target* control trans z)
        )
      (format
        #t
        "Dist = ~F~%"
        (* 0.00024414062 (vector-vector-xz-distance (-> *target* control trans) *start-pos*))
        )
      (set! *start-timer* (the-as int #f))
      )
    (if (< 179 *timer-value*)
        (format *stdcon* "~%~%Time = ~D~%" *timer-value*)
        )
    (set! *timer-value* (+ *timer-value* 1))
    )
  (when (not *start-timer*)
    (set! *timer-value* 0)
    0
    )
  (dotimes (gp-1 2)
    (let ((s5-1 (-> *level* level gp-1)))
      (when (!= (-> s5-1 status) 'inactive)
        (let ((a0-14 (new-stack-vector0)))
          (vector-! a0-14 (the-as vector (-> s5-1 info bsphere)) (-> *math-camera* trans))
          (set! (-> s5-1 level-distance) (fmax 0.0 (- (vector-length a0-14) (-> s5-1 info bsphere w))))
          )
        (when *display-level-spheres*
          (add-debug-sphere
            #t
            (bucket-id debug-no-zbuf)
            (-> s5-1 info bsphere)
            (-> s5-1 info bsphere w)
            (new 'static 'rgba :r #xff :a #x80)
            )
          (format
            *stdcon*
            "~f ~f ~f ~f~%"
            (* 0.00024414062 (-> s5-1 info bsphere x))
            (* 0.00024414062 (-> s5-1 info bsphere y))
            (* 0.00024414062 (-> s5-1 info bsphere z))
            (* 0.00024414062 (-> s5-1 info bsphere w))
            )
          )
        )
      )
    )
  (update-math-camera
    *math-camera*
    (-> *setting-control* current video-mode)
    (-> *setting-control* current aspect-ratio)
    )
  (update! *camera-smush-control*)
  (cond
    ((or (= *master-mode* 'pause) (= *master-mode* 'progress) *progress-process*)
     )
    ((>= *camera-look-through-other* 2)
     (set! *camera-look-through-other* 1)
     )
    ((and (= *camera-look-through-other* 1) (!= *master-mode* 'menu))
     (set! *camera-look-through-other* 0)
     0
     )
    )
  (cond
    (*external-cam-mode*
      (move-camera-from-pad *math-camera*)
      )
    ((nonzero? *camera-look-through-other*)
     (set! (-> *math-camera* fov) (-> *camera-other-fov* data))
     (set! (-> *math-camera* trans quad) (-> *camera-other-trans* quad))
     (+! (-> *math-camera* trans y) (get-no-update *camera-smush-control*))
     (let* ((a2-9 (-> *math-camera* inv-camera-rot))
            (a3-4 *camera-other-matrix*)
            (v1-86 (-> a3-4 vector 0 quad))
            (a0-29 (-> a3-4 vector 1 quad))
            (a1-10 (-> a3-4 vector 2 quad))
            (a3-5 (-> a3-4 vector 3 quad))
            )
       (set! (-> a2-9 vector 0 quad) v1-86)
       (set! (-> a2-9 vector 1 quad) a0-29)
       (set! (-> a2-9 vector 2 quad) a1-10)
       (set! (-> a2-9 vector 3 quad) a3-5)
       )
     (let* ((a2-10 *save-camera-inv-rot*)
            (a3-6 *camera-other-matrix*)
            (v1-87 (-> a3-6 vector 0 quad))
            (a0-30 (-> a3-6 vector 1 quad))
            (a1-11 (-> a3-6 vector 2 quad))
            (a3-7 (-> a3-6 vector 3 quad))
            )
       (set! (-> a2-10 vector 0 quad) v1-87)
       (set! (-> a2-10 vector 1 quad) a0-30)
       (set! (-> a2-10 vector 2 quad) a1-11)
       (set! (-> a2-10 vector 3 quad) a3-7)
       )
     )
    ((and *camera-combiner* (not *external-cam-mode*))
     (set! (-> *math-camera* fov) (-> *camera-combiner* fov))
     (set! (-> *math-camera* trans quad) (-> *camera-combiner* trans quad))
     (+! (-> *math-camera* trans y) (get-no-update *camera-smush-control*))
     (let* ((v1-100 (-> *math-camera* inv-camera-rot))
            (a3-8 (-> *camera-combiner* inv-camera-rot))
            (a0-36 (-> a3-8 vector 0 quad))
            (a1-12 (-> a3-8 vector 1 quad))
            (a2-11 (-> a3-8 vector 2 quad))
            (a3-9 (-> a3-8 vector 3 quad))
            )
       (set! (-> v1-100 vector 0 quad) a0-36)
       (set! (-> v1-100 vector 1 quad) a1-12)
       (set! (-> v1-100 vector 2 quad) a2-11)
       (set! (-> v1-100 vector 3 quad) a3-9)
       )
     (let* ((v1-101 *save-camera-inv-rot*)
            (a3-10 (-> *camera-combiner* inv-camera-rot))
            (a0-38 (-> a3-10 vector 0 quad))
            (a1-13 (-> a3-10 vector 1 quad))
            (a2-12 (-> a3-10 vector 2 quad))
            (a3-11 (-> a3-10 vector 3 quad))
            )
       (set! (-> v1-101 vector 0 quad) a0-38)
       (set! (-> v1-101 vector 1 quad) a1-13)
       (set! (-> v1-101 vector 2 quad) a2-12)
       (set! (-> v1-101 vector 3 quad) a3-11)
       )
     )
    (else
      (move-camera-from-pad *math-camera*)
      )
    )
  (matrix-transpose! (-> *math-camera* camera-rot) (-> *math-camera* inv-camera-rot))
  (cond
    (*camera-no-mip-correction*
      (set! (-> *math-camera* fov-correction-factor) 1.0)
      )
    (else
      (let ((f0-28 (fmin 11650.845 (-> *math-camera* fov))))
        (set! (-> *math-camera* fov-correction-factor) (* 0.00008583069 f0-28))
        )
      )
    )
  (if (< 0.0 (-> *math-camera* smooth-t))
      (set! (-> *math-camera* smooth-t) (- (-> *math-camera* smooth-t) (-> *math-camera* smooth-step)))
      )
  (cond
    ((< 0.0 (-> *math-camera* smooth-t))
     (let ((gp-2 (new-stack-quaternion0)))
       (matrix->quaternion gp-2 (-> *math-camera* inv-camera-rot))
       (quaternion-slerp! gp-2 gp-2 (-> *math-camera* inv-camera-rot-smooth-from) (-> *math-camera* smooth-t))
       (quaternion->matrix (-> *math-camera* inv-camera-rot-smooth) gp-2)
       )
     )
    (else
      (let* ((v1-124 (-> *math-camera* inv-camera-rot-smooth))
             (a3-13 (-> *math-camera* inv-camera-rot))
             (a0-45 (-> a3-13 vector 0 quad))
             (a1-18 (-> a3-13 vector 1 quad))
             (a2-14 (-> a3-13 vector 2 quad))
             (a3-14 (-> a3-13 vector 3 quad))
             )
        (set! (-> v1-124 vector 0 quad) a0-45)
        (set! (-> v1-124 vector 1 quad) a1-18)
        (set! (-> v1-124 vector 2 quad) a2-14)
        (set! (-> v1-124 vector 3 quad) a3-14)
        )
      )
    )
  (if (and (!= *master-mode* 'menu) *display-camera-info*)
      (format
        *stdcon*
        "cam pos ~M ~M ~M~%"
        (-> *math-camera* trans x)
        (-> *math-camera* trans y)
        (-> *math-camera* trans z)
        )
      )
  (when (zero? (-> *math-camera* reset))
    (let* ((v1-136 (-> *math-camera* prev-camera-temp))
           (a3-16 (-> *math-camera* camera-temp))
           (a0-50 (-> a3-16 vector 0 quad))
           (a1-20 (-> a3-16 vector 1 quad))
           (a2-16 (-> a3-16 vector 2 quad))
           (a3-17 (-> a3-16 vector 3 quad))
           )
      (set! (-> v1-136 vector 0 quad) a0-50)
      (set! (-> v1-136 vector 1 quad) a1-20)
      (set! (-> v1-136 vector 2 quad) a2-16)
      (set! (-> v1-136 vector 3 quad) a3-17)
      )
    )
  (let ((gp-3 (-> *math-camera* camera-temp))
        (s4-1 (-> *math-camera* camera-rot))
        (s5-2 (-> *math-camera* inv-camera-rot))
        (s3-0 (-> *math-camera* trans))
        )
    (let ((s2-0 (new-stack-vector0)))
      (set! (-> s2-0 x) (- (-> s3-0 x)))
      (set! (-> s2-0 y) (- (-> s3-0 y)))
      (set! (-> s2-0 z) (- (-> s3-0 z)))
      (set! (-> s2-0 w) 1.0)
      (vector-matrix*! s2-0 s2-0 s4-1)
      (set! (-> s4-1 vector 3 quad) (-> s2-0 quad))
      )
    (matrix*! gp-3 s4-1 (-> *math-camera* perspective))
    (set! (-> s5-2 vector 3 quad) (-> s3-0 quad))
    )
  (when (nonzero? (-> *math-camera* reset))
    (let* ((v1-148 (-> *math-camera* prev-camera-temp))
           (a3-18 (-> *math-camera* camera-temp))
           (a0-54 (-> a3-18 vector 0 quad))
           (a1-23 (-> a3-18 vector 1 quad))
           (a2-19 (-> a3-18 vector 2 quad))
           (a3-19 (-> a3-18 vector 3 quad))
           )
      (set! (-> v1-148 vector 0 quad) a0-54)
      (set! (-> v1-148 vector 1 quad) a1-23)
      (set! (-> v1-148 vector 2 quad) a2-19)
      (set! (-> v1-148 vector 3 quad) a3-19)
      )
    (set! (-> *math-camera* reset) 0)
    0
    )
  (let ((f0-45 (-> *math-camera* fog-min))
        (f1-10 (-> *math-camera* fog-max))
        )
    (let ((f2-0 (-> *math-camera* d)))
      (set! (-> *instance-tie-work* hmge-d x) f0-45)
      (set! (-> *instance-tie-work* hmge-d y) f1-10)
      (set! (-> *instance-tie-work* hmge-d z) (* 32.0 f2-0))
      (set! (-> *instance-tie-work* hmge-d w) (* f2-0 (-> *math-camera* hmge-scale w)))
      (let ((v1-160 (-> *math-camera* hvdf-off quad)))
        (set! (-> *instance-tie-work* hvdf-offset quad) v1-160)
        )
      (set! (-> *instance-shrub-work* hmge-d x) f0-45)
      (set! (-> *instance-shrub-work* hmge-d y) f1-10)
      (set! (-> *instance-shrub-work* hmge-d z) (* 3.0 f2-0))
      (set! (-> *instance-shrub-work* hmge-d w) (* f2-0 (-> *math-camera* hmge-scale w)))
      (set! (-> *instance-shrub-work* billboard-const x)
            (/ (-> *math-camera* x-pix) (* f2-0 (-> *math-camera* x-ratio)))
            )
      (set! (-> *instance-shrub-work* billboard-const y)
            (/ (-> *math-camera* y-pix) (* f2-0 (-> *math-camera* y-ratio)))
            )
      )
    (set! (-> *instance-shrub-work* billboard-const z) f0-45)
    (set! (-> *instance-shrub-work* billboard-const w) f1-10)
    )
  (set! (-> *instance-shrub-work* constants w) (the-as float (-> *math-camera* vis-gifs 0 fog0)))
  (let ((a0-56 (-> *math-camera* hvdf-off quad)))
    (set! (-> *instance-shrub-work* hvdf-offset quad) a0-56)
    )
  (update-view-planes *math-camera* (-> *math-camera* plane) 1.0)
  (update-view-planes *math-camera* (-> *math-camera* guard-plane) 4.0)
  (set! (-> *instance-shrub-work* guard-plane 0 quad) (-> *math-camera* guard-plane 0 quad))
  (set! (-> *instance-shrub-work* guard-plane 1 quad) (-> *math-camera* guard-plane 1 quad))
  (set! (-> *instance-shrub-work* guard-plane 2 quad) (-> *math-camera* guard-plane 2 quad))
  (set! (-> *instance-shrub-work* guard-plane 3 quad) (-> *math-camera* guard-plane 3 quad))
  (set! (-> *instance-tie-work* guard-plane 0 quad) (-> *math-camera* guard-plane 0 quad))
  (set! (-> *instance-tie-work* guard-plane 1 quad) (-> *math-camera* guard-plane 1 quad))
  (set! (-> *instance-tie-work* guard-plane 2 quad) (-> *math-camera* guard-plane 2 quad))
  (set! (-> *instance-tie-work* guard-plane 3 quad) (-> *math-camera* guard-plane 3 quad))
  (update-visible *math-camera*)
  (if (not (paused?))
      (update-wind *wind-work* *wind-scales*)
      )
  #f
  )




