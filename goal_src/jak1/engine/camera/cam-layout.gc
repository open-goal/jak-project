;;-*-Lisp-*-
(in-package goal)

;; name: cam-layout.gc
;; name in dgo: cam-layout
;; dgos: GAME, ENGINE

;; DECOMP BEGINS

;; this file is debug only
(declare-file (debug))

(define *camera-layout-blink* #f)

(deftype cam-layout-bank (basic)
  ((spline-t    float  :offset-assert   4)
   (spline-step float  :offset-assert   8)
   (intro-t     float  :offset-assert  12)
   (intro-step  float  :offset-assert  16)
   (debug-t     float  :offset-assert  20)
   (debug-step  float  :offset-assert  24)
   )
  :method-count-assert 9
  :size-assert         #x1c
  :flag-assert         #x90000001c
  )


(define *CAM_LAYOUT-bank* (new 'static 'cam-layout-bank
                            :spline-t 0.01
                            :spline-step 0.0016666667
                            :intro-t 0.01
                            :intro-step 0.0016666667
                            :debug-t 0.01
                            :debug-step 0.0033333334
                            )
        )

(define *camera-layout-message-ypos* 30)

(deftype clm-basic (basic)
  ()
  :method-count-assert 9
  :size-assert         #x4
  :flag-assert         #x900000004
  )


(deftype clm-item-action (structure)
  ((button      uint64  :offset-assert   0)
   (options     uint64  :offset-assert   8)
   (func        symbol  :offset-assert  16)
   (parm0       int32   :offset         20)
   (parm0-basic basic   :offset         20)
   (parm1-basic basic   :offset         24)
   (parm1       symbol  :offset         24)
   )
  :method-count-assert 9
  :size-assert         #x1c
  :flag-assert         #x90000001c
  )


(deftype clm-item (clm-basic)
  ((description   string                  :offset-assert   4)
   (button-symbol symbol                  :offset-assert   8)
   (action        clm-item-action :inline :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x2c
  :flag-assert         #x90000002c
  )


(deftype clm-list-item (basic)
  ((description     string                   :offset-assert   4)
   (track-val       symbol                   :offset-assert   8)
   (val-func        symbol                   :offset-assert  12)
   (val-parm0       int32                    :offset         16)
   (val-parm0-basic basic                    :offset         16)
   (val-parm1-basic basic                    :offset         20)
   (val-parm1       symbol                   :offset         20)
   (actions         (array clm-item-action)  :offset-assert  24)
   )
  :method-count-assert 9
  :size-assert         #x1c
  :flag-assert         #x90000001c
  )


(deftype clm-list (clm-basic)
  ((tracker       symbol                 :offset-assert   4)
   (cur-list-item int32                  :offset-assert   8)
   (items         (array clm-list-item)  :offset-assert  12)
   )
  :method-count-assert 9
  :size-assert         #x10
  :flag-assert         #x900000010
  )


(deftype clm (basic)
  ((title string             :offset-assert   4)
   (items (array clm-basic)  :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )


(define *volume-point-current* 0)

(define *volume-point* (new 'debug 'vector-array 1000))

(define *volume-normal-current* 0)

(define *volume-normal* (new 'debug 'vector-array 600))

(deftype volume-descriptor-array (inline-array-class)
  ((data plane-volume :inline :dynamic :offset  16)
   )
  :method-count-assert 9
  :size-assert         #x10
  :flag-assert         #x900000010
  )


(set! (-> volume-descriptor-array heap-base) (the-as uint 24))

(define *volume-descriptor-current* 0)

(define *volume-descriptor* (the-as vol-control (new 'debug 'volume-descriptor-array 100)))

(deftype cam-layout (process)
  ((cam-entity      entity-camera  :offset-assert 112)
   (num-entities    int32          :offset-assert 116)
   (cur-entity      int32          :offset-assert 120)
   (num-volumes     int32          :offset-assert 124)
   (cur-volume      int32          :offset-assert 128)
   (first-pvol      int32          :offset-assert 132)
   (first-cutoutvol int32          :offset-assert 136)
   (res-key         float          :offset-assert 140)
   )
  :heap-base #x200
  :method-count-assert 14
  :size-assert         #x90
  :flag-assert         #xe02000090
  (:states
    cam-layout-active
    )
  )


(defun cam-layout-print ((arg0 int) (arg1 int) (arg2 string))
  (let* ((s5-0 (-> *display* frames (-> *display* on-screen) frame debug-buf))
         (gp-0 (-> s5-0 base))
         )
    (draw-string-xy arg2 s5-0 arg0 arg1 (font-color white) (font-flags shadow kerning))
    (let ((a3-4 (-> s5-0 base)))
      (let ((v1-4 (the-as object (-> s5-0 base))))
        (set! (-> (the-as dma-packet v1-4) dma) (new 'static 'dma-tag :id (dma-tag-id next)))
        (set! (-> (the-as dma-packet v1-4) vif0) (new 'static 'vif-tag))
        (set! (-> (the-as dma-packet v1-4) vif1) (new 'static 'vif-tag))
        (set! (-> s5-0 base) (&+ (the-as pointer v1-4) 16))
        )
      (dma-bucket-insert-tag
        (-> *display* frames (-> *display* on-screen) frame bucket-group)
        (bucket-id debug)
        gp-0
        (the-as (pointer dma-tag) a3-4)
        )
      )
    )
  )

(defun cam-layout-intersect-dist ((arg0 vector) (arg1 vector) (arg2 vector))
  (let ((f0-1 (vector-dot arg1 arg0))
        (f1-1 (vector-dot arg2 arg0))
        )
    (the-as float (if (< 0.00001 (fabs f1-1))
                      (/ (- (-> arg0 w) f0-1) f1-1)
                      409600000.0
                      )
            )
    )
  )

(defbehavior cam-layout-entity-volume-info-create cam-layout ((arg0 entity-camera) (arg1 symbol))
  (local-vars
    (sv-16 res-tag)
    (sv-160 vector)
    (sv-164 float)
    (sv-168 int)
    (sv-176 vector)
    (sv-192 vector)
    (sv-208 vector)
    (sv-224 vector)
    (sv-240 vector)
    (sv-256 int)
    (sv-272 int)
    (sv-288 int)
    )
  (let ((s4-0 0))
    (loop
      (set! sv-16 (new 'static 'res-tag))
      (let ((s3-0 (the-as (inline-array vector) ((method-of-type res-lump get-property-data)
                                                 arg0
                                                 arg1
                                                 'exact
                                                 (the float s4-0)
                                                 (the-as pointer #f)
                                                 (& sv-16)
                                                 *res-static-buf*
                                                 )
                          )
                  )
            )
        (cond
          (s3-0
            (when (>= *volume-descriptor-current* 100)
              (format 0 "ERROR <GMJ>: camera editing out of volume descriptors~%")
              (return #f)
              )
            (let ((s2-0 (-> *volume-descriptor* pos-vol *volume-descriptor-current*)))
              (set! (-> s2-0 volume-type) arg1)
              (set! (-> s2-0 point-count) 0)
              (set! (-> s2-0 first-point) (the-as (pointer vector) (-> *volume-point* data *volume-point-current*)))
              (set! (-> s2-0 normal-count) 0)
              (set! (-> s2-0 first-normal) (the-as (pointer vector) (-> *volume-normal* data *volume-normal-current*)))
              (set! *volume-descriptor-current* (+ *volume-descriptor-current* 1))
              (+! (-> self num-volumes) 1)
              (dotimes (s1-0 (the-as int (-> sv-16 elt-count)))
                (set! sv-192 (new 'stack-no-clear 'vector))
                (set! (-> sv-192 quad) (the-as uint128 0))
                (set! sv-208 (new 'stack-no-clear 'vector))
                (set! (-> sv-208 quad) (the-as uint128 0))
                (set! sv-224 (new 'stack-no-clear 'vector))
                (set! (-> sv-224 quad) (the-as uint128 0))
                (set! sv-240 (new 'stack-no-clear 'vector))
                (set! (-> sv-240 quad) (the-as uint128 0))
                0.0
                0.0
                0.0
                (set! (-> (new 'stack-no-clear 'vector) quad) (the-as uint128 0))
                (let ((s0-0 (new-stack-vector0)))
                  (set! sv-256 0)
                  (set! sv-272 0)
                  (while (< sv-272 (the-as int (-> sv-16 elt-count)))
                    (when (!= s1-0 sv-272)
                      (vector-float*! sv-192 (-> s3-0 sv-272) (-> s3-0 sv-272 w))
                      (vector-cross! sv-208 (-> s3-0 sv-272) (-> s3-0 s1-0))
                      (vector-normalize! sv-208 (the-as float 1.0))
                      (vector-cross! sv-224 sv-208 (-> s3-0 sv-272))
                      (vector-normalize! sv-224 (the-as float 1.0))
                      (let ((f0-6 (cam-layout-intersect-dist (-> s3-0 s1-0) sv-192 sv-224)))
                        (when (!= f0-6 409600000.0)
                          (vector+float*! sv-240 sv-192 sv-224 f0-6)
                          (set! sv-160 (new-stack-vector0))
                          (set! sv-164 0.0)
                          (set! sv-168 0)
                          (set! sv-176 (new-stack-vector0))
                          (set! (-> sv-160 quad) (-> sv-240 quad))
                          (set! sv-288 0)
                          (while (< sv-288 (the-as int (-> sv-16 elt-count)))
                            (when (and (!= sv-288 s1-0) (!= sv-288 sv-272))
                              (let ((f30-0 (cam-layout-intersect-dist (-> s3-0 sv-288) sv-160 sv-208)))
                                (cond
                                  ((= f30-0 409600000.0)
                                   )
                                  ((zero? sv-168)
                                   (vector+float*! sv-160 sv-160 sv-208 f30-0)
                                   (set! (-> sv-176 quad) (-> s3-0 sv-288 quad))
                                   (set! sv-164 8192000.0)
                                   (set! sv-168 1)
                                   )
                                  ((begin (vector-float*! sv-240 sv-208 f30-0) (>= (vector-dot sv-240 sv-176) 0.0))
                                   )
                                  ((>= (vector-dot sv-240 (-> s3-0 sv-288)) 0.0)
                                   (when (< (fabs f30-0) (fabs sv-164))
                                     (set! sv-164 f30-0)
                                     (set! sv-168 (+ sv-168 1))
                                     )
                                   )
                                  (else
                                    (vector+float*! sv-160 sv-160 sv-208 f30-0)
                                    (set! (-> sv-176 quad) (-> s3-0 sv-288 quad))
                                    (set! sv-168 (+ sv-168 1))
                                    (if (< (fabs f30-0) (fabs sv-164))
                                        (set! sv-164 (- sv-164 f30-0))
                                        (set! sv-164 0.0)
                                        )
                                    )
                                  )
                                )
                              )
                            (set! sv-288 (+ sv-288 1))
                            )
                          (cond
                            ((zero? sv-168)
                             )
                            ((= sv-164 0.0)
                             )
                            (else
                              (dotimes (v1-87 (the-as int (-> sv-16 elt-count)))
                                (when (and (!= v1-87 s1-0) (!= v1-87 sv-272))
                                  (if (< 4096.0 (- (vector-dot sv-160 (-> s3-0 v1-87)) (-> s3-0 v1-87 w)))
                                      (goto cfg-47)
                                      )
                                  )
                                )
                              (vector+float*! sv-240 sv-160 sv-208 sv-164)
                              (cond
                                ((>= *volume-point-current* 999)
                                 (format 0 "ERROR <GMJ>: camera editing out of volume points~%")
                                 )
                                (else
                                  (set! (-> *volume-point* data *volume-point-current* quad) (-> sv-160 quad))
                                  (set! (-> *volume-point* data (+ *volume-point-current* 1) quad) (-> sv-240 quad))
                                  (set! *volume-point-current* (+ *volume-point-current* 2))
                                  (+! (-> s2-0 point-count) 2)
                                  )
                                )
                              (vector+! s0-0 s0-0 sv-160)
                              (vector+! s0-0 s0-0 sv-240)
                              (set! sv-256 (+ sv-256 2))
                              sv-256
                              )
                            )
                          )
                        )
                      )
                    (label cfg-47)
                    (set! sv-272 (+ sv-272 1))
                    )
                  (when (nonzero? sv-256)
                    (vector-float*! s0-0 s0-0 (/ 1.0 (the float sv-256)))
                    (cond
                      ((>= *volume-normal-current* 599)
                       (format 0 "ERROR <GMJ>: camera editing out of volume normals~%")
                       )
                      (else
                        (set! (-> *volume-normal* data *volume-normal-current* quad) (-> s0-0 quad))
                        (set! (-> *volume-normal* data (+ *volume-normal-current* 1) quad) (-> s3-0 s1-0 quad))
                        (set! *volume-normal-current* (+ *volume-normal-current* 2))
                        (set! (-> s2-0 normal-count) (+ (-> s2-0 normal-count) 2))
                        )
                      )
                    )
                  )
                )
              )
            )
          (else
            (return #f)
            )
          )
        )
      (+! s4-0 1)
      )
    )
  (the-as symbol #f)
  )

(defbehavior cam-layout-entity-volume-info cam-layout ()
  (dotimes (gp-0 (-> self num-volumes))
    (cond
      ((and (= gp-0 (-> self cur-volume))
            (= *camera-layout-blink* 'volume)
            (not (logtest? (-> *display* real-actual-frame-counter) 8))
            )
       )
      (else
        (let ((s5-0 (-> *volume-descriptor* pos-vol gp-0)))
          (let ((a0-7 (new 'static 'vector4w :w #x80)))
            (cond
              ((= (-> s5-0 volume-type) 'vol)
               (set! (-> a0-7 x) 0)
               (set! (-> a0-7 y) 192)
               (set! (-> a0-7 z) 0)
               0
               )
              ((= (-> s5-0 volume-type) 'pvol)
               (set! (-> a0-7 x) 128)
               (set! (-> a0-7 y) 128)
               (set! (-> a0-7 z) 128)
               )
              ((= (-> s5-0 volume-type) 'cutoutvol)
               (set! (-> a0-7 x) 192)
               (set! (-> a0-7 y) 0)
               (set! (-> a0-7 z) 0)
               0
               )
              )
            (camera-line-setup a0-7)
            )
          (let ((s4-0 (the-as object (-> s5-0 first-point))))
            (dotimes (s3-0 (/ (-> s5-0 point-count) 2))
              (camera-line-draw (the-as vector s4-0) (&+ (the-as vector s4-0) 16))
              (set! s4-0 (&-> (the-as (inline-array plane-volume) s4-0) 1 first-point))
              )
            )
          )
        )
      )
    )
  #f
  )

(defun v-slrp! ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 float))
  (let ((s2-0 (new-stack-vector0))
        (s1-0 (new-stack-vector0))
        (s0-0 (new-stack-vector0))
        )
    0.0
    0.0
    0.0
    0.0
    (cond
      ((< 1.0 arg3)
       (set! arg3 (the-as float 1.0))
       )
      ((< arg3 0.0)
       (set! arg3 (the-as float 0.0))
       )
      )
    (vector-normalize-copy! s2-0 arg1 (the-as float 1.0))
    (vector-normalize-copy! s1-0 arg2 (the-as float 1.0))
    (vector-cross! s0-0 s2-0 s1-0)
    (let* ((f30-0 (vector-length s0-0))
           (f28-0 (asin f30-0))
           )
      (vector-float*! arg0 arg1 (/ (sin (* (- 1.0 arg3) f28-0)) f30-0))
      (vector+float*! arg0 arg0 arg2 (/ (sin (* arg3 f28-0)) f30-0))
      )
    )
  )

(deftype interp-test-info (structure)
  ((from   vector   :inline :offset-assert   0)
   (to     vector   :inline :offset-assert  16)
   (origin vector   :inline :offset-assert  32)
   (color  vector4w         :offset-assert  48)
   (axis   vector           :offset-assert  52)
   (disp   string           :offset-assert  56)
   )
  :method-count-assert 9
  :size-assert         #x3c
  :flag-assert         #x90000003c
  )


(defun interp-test ((arg0 (function vector vector vector float vector float none)) (arg1 interp-test-info))
  (let ((s3-0 (new-stack-vector0))
        (gp-0 (new-stack-vector0))
        )
    (arg0 s3-0 (-> arg1 from) (-> arg1 to) (the-as float 0.0) (-> arg1 axis) (the-as float 65536.0))
    (vector+! s3-0 s3-0 (-> arg1 origin))
    (dotimes (s2-0 10)
      (set! (-> gp-0 quad) (-> s3-0 quad))
      (arg0 s3-0 (-> arg1 from) (-> arg1 to) (* 0.1 (+ 1.0 (the float s2-0))) (-> arg1 axis) (the-as float 65536.0))
      (vector+! s3-0 s3-0 (-> arg1 origin))
      (camera-line s3-0 gp-0 (-> arg1 color))
      )
    (arg0 gp-0 (-> arg1 from) (-> arg1 to) (-> *CAM_LAYOUT-bank* debug-t) (-> arg1 axis) (the-as float 65536.0))
    (format *stdcon* "~S  ~f~%" (-> arg1 disp) (vector-length gp-0))
    (vector+! gp-0 gp-0 (-> arg1 origin))
    (camera-line (-> arg1 origin) gp-0 (-> arg1 color))
    (camera-cross (new 'static 'vector :y 1024.0) (new 'static 'vector :z 1024.0) gp-0 (-> arg1 color) (meters 1))
    )
  )

(defun interp-test-deg ((arg0 (function vector vector vector vector float none)) (arg1 interp-test-info))
  (let ((s3-0 (new-stack-vector0))
        (gp-0 (new-stack-vector0))
        )
    (arg0 s3-0 (-> arg1 from) (-> arg1 to) (-> arg1 axis) (the-as float 0.0))
    (vector+! s3-0 s3-0 (-> arg1 origin))
    (dotimes (s2-0 10)
      (set! (-> gp-0 quad) (-> s3-0 quad))
      (arg0 s3-0 (-> arg1 from) (-> arg1 to) (-> arg1 axis) (* 182.04445 (* 18.0 (+ 1.0 (the float s2-0)))))
      (vector+! s3-0 s3-0 (-> arg1 origin))
      (camera-line s3-0 gp-0 (-> arg1 color))
      )
    (arg0 gp-0 (-> arg1 from) (-> arg1 to) (-> arg1 axis) (* 182.04445 (* 180.0 (-> *CAM_LAYOUT-bank* debug-t))))
    (format *stdcon* "~S  ~f~%" (-> arg1 disp) (vector-length gp-0))
    (vector+! gp-0 gp-0 (-> arg1 origin))
    (camera-line (-> arg1 origin) gp-0 (-> arg1 color))
    (camera-cross (new 'static 'vector :y 1024.0) (new 'static 'vector :z 1024.0) gp-0 (-> arg1 color) (meters 1))
    )
  )

(defun cam-layout-entity-info ((arg0 entity-actor))
  (if (not arg0)
      (return #f)
      )
  (let ((s5-0 (new-stack-matrix0))
        (s4-0 (new-stack-vector0))
        )
    (when (and (cam-slave-get-vector-with-offset arg0 s4-0 'trans)
               (or (!= *camera-layout-blink* 'camera) (logtest? (-> *display* real-actual-frame-counter) 8))
               )
      (cam-slave-get-rot arg0 s5-0)
      (camera-fov-frame
        s5-0
        s4-0
        (* 0.5 (cam-slave-get-fov arg0))
        (the-as float 0.75)
        (the-as float 1.0)
        (new 'static 'vector4w :z #xff :w #x80)
        )
      )
    )
  (let ((s5-1 (new-stack-vector0)))
    (if (and (cam-slave-get-vector-with-offset arg0 s5-1 'pivot)
             (or (!= *camera-layout-blink* 'pivot) (logtest? (-> *display* real-actual-frame-counter) 8))
             )
        (camera-cross
          (new 'static 'vector :y 1024.0)
          (new 'static 'vector :z 1024.0)
          s5-1
          (new 'static 'vector4w :x #x80 :w #x80)
          (meters 1)
          )
        )
    )
  (let ((s5-2 (new-stack-vector0)))
    (if (and (cam-slave-get-vector-with-offset arg0 s5-2 'align)
             (or (!= *camera-layout-blink* 'align) (logtest? (-> *display* real-actual-frame-counter) 8))
             )
        (camera-cross
          (new 'static 'vector :y 1024.0)
          (new 'static 'vector :z 1024.0)
          s5-2
          (new 'static 'vector4w :y #x80 :w #x80)
          (meters 1)
          )
        )
    )
  (let ((s5-3 (new-stack-vector0)))
    (if (and (cam-slave-get-vector-with-offset arg0 s5-3 'interesting)
             (or (!= *camera-layout-blink* 'interesting) (logtest? (-> *display* real-actual-frame-counter) 8))
             )
        (camera-cross
          (new 'static 'vector :y 1024.0)
          (new 'static 'vector :z 1024.0)
          s5-3
          (new 'static 'vector4w :x #x80 :z #x80 :w #x80)
          (meters 1)
          )
        )
    )
  (let ((s3-1 (new 'stack 'curve))
        (s2-0 (new-stack-vector0))
        (s5-4 (new-stack-vector0))
        (s4-1 (new-stack-vector0))
        )
    (when (and (get-curve-data! arg0 s3-1 'campath 'campath-k (the-as float -1000000000.0))
               (or (!= *camera-layout-blink* 'spline) (logtest? (-> *display* real-actual-frame-counter) 8))
               )
      (cond
        ((cam-slave-get-vector-with-offset arg0 s4-1 'pivot)
         (curve-get-pos! s5-4 (the-as float 0.0) s3-1)
         (vector-! s4-1 s4-1 s5-4)
         )
        (else
          (set! (-> s4-1 quad)
                (-> (the-as
                      vector
                      ((method-of-type res-lump get-property-struct)
                       arg0
                       'spline-offset
                       'interp
                       (the-as float -1000000000.0)
                       s4-1
                       (the-as (pointer res-tag) #f)
                       *res-static-buf*
                       )
                      )
                    quad
                    )
                )
          )
        )
      (curve-get-pos! s5-4 (the-as float 0.0) s3-1)
      (vector+! s5-4 s5-4 s4-1)
      (dotimes (s1-1 8)
        (set! (-> s2-0 quad) (-> s5-4 quad))
        (curve-get-pos! s5-4 (* 0.125 (the float (+ s1-1 1))) s3-1)
        (vector+! s5-4 s5-4 s4-1)
        (camera-line s2-0 s5-4 (new 'static 'vector4w :x #xff :y #xff :w #x80))
        )
      (curve-get-pos! s5-4 (-> *CAM_LAYOUT-bank* spline-t) s3-1)
      (vector+! s5-4 s5-4 s4-1)
      (camera-cross
        (new 'static 'vector :y 1024.0)
        (new 'static 'vector :z 1024.0)
        s5-4
        (new 'static 'vector4w :x #xff :y #xff :w #x80)
        (meters 1)
        )
      )
    )
  (let ((s3-2 (new 'stack 'curve))
        (s2-1 (new-stack-vector0))
        (s5-5 (new-stack-vector0))
        (s4-2 (new-stack-vector0))
        (s1-2 (new 'stack 'curve))
        )
    (when (and (get-curve-data! arg0 s3-2 'intro 'intro-k (the-as float -1000000000.0))
               (or (!= *camera-layout-blink* 'intro) (logtest? (-> *display* real-actual-frame-counter) 8))
               )
      (cond
        ((cam-slave-get-vector-with-offset arg0 s4-2 'pivot)
         (curve-get-pos! s5-5 (the-as float 1.0) s3-2)
         (vector-! s4-2 s4-2 s5-5)
         )
        ((get-curve-data! arg0 s1-2 'campath 'campath-k (the-as float -1000000000.0))
         (curve-get-pos! s4-2 (the-as float 0.0) s1-2)
         (curve-get-pos! s5-5 (the-as float 1.0) s3-2)
         (vector-! s4-2 s4-2 s5-5)
         )
        ((cam-slave-get-vector-with-offset arg0 s4-2 'trans)
         (curve-get-pos! s5-5 (the-as float 1.0) s3-2)
         (vector-! s4-2 s4-2 s5-5)
         )
        )
      (curve-get-pos! s5-5 (the-as float 0.0) s3-2)
      (vector+! s5-5 s5-5 s4-2)
      (dotimes (s1-3 8)
        (set! (-> s2-1 quad) (-> s5-5 quad))
        (curve-get-pos! s5-5 (* 0.125 (the float (+ s1-3 1))) s3-2)
        (vector+! s5-5 s5-5 s4-2)
        (camera-line s2-1 s5-5 (new 'static 'vector4w :z #xff :w #x80))
        )
      (curve-get-pos! s5-5 (-> *CAM_LAYOUT-bank* intro-t) s3-2)
      (vector+! s5-5 s5-5 s4-2)
      (camera-cross
        (new 'static 'vector :y 1024.0)
        (new 'static 'vector :z 1024.0)
        s5-5
        (new 'static 'vector4w :z #xff :w #x80)
        (meters 1)
        )
      (curve-get-pos! s5-5 (cam-slave-get-float arg0 'intro-exitValue (the-as float 0.0)) s3-2)
      (vector+! s5-5 s5-5 s4-2)
      (camera-cross
        (new 'static 'vector :y 1024.0)
        (new 'static 'vector :z 1024.0)
        s5-5
        (new 'static 'vector4w :z #xff :w #x80)
        (meters 1)
        )
      )
    )
  (let ((s2-3 (res-lump-data arg0 'campoints pointer :time (the-as float 1.0)))
        (v1-95 (res-lump-struct arg0 'campoints-offset structure :time (the-as float -1000000000.0)))
        (s4-3 (new 'stack-no-clear 'vector))
        (s3-3 (new 'stack-no-clear 'vector))
        (s5-6 (new 'static 'vector))
        )
    (when (and s2-3 (or (!= *camera-layout-blink* 'index) (logtest? (-> *display* real-actual-frame-counter) 8)))
      (cond
        (v1-95
          (vector+! s4-3 (the-as vector (&+ s2-3 0)) (the-as vector v1-95))
          (vector+! s3-3 (the-as vector (&+ s2-3 16)) (the-as vector v1-95))
          )
        (else
          (set! (-> s4-3 quad) (-> (the-as (pointer uint128) (&+ s2-3 0))))
          (set! (-> s3-3 quad) (-> (the-as (pointer uint128) (&+ s2-3 16))))
          )
        )
      (camera-line s4-3 s3-3 (new 'static 'vector4w :y #x80 :w #x80))
      (vector-lerp-clamp! s5-6 s4-3 s3-3 (-> *CAM_LAYOUT-bank* spline-t))
      (camera-cross
        (new 'static 'vector :y 1024.0)
        (new 'static 'vector :z 1024.0)
        s5-6
        (new 'static 'vector4w :x #xff :y #xff :w #x80)
        (meters 1)
        )
      )
    )
  (let ((s4-4 (res-lump-data arg0 'focalpull pointer :time (the-as float 1.0)))
        (s5-7 (new 'static 'vector))
        )
    (when (and s4-4 (or (!= *camera-layout-blink* 'focalpull) (logtest? (-> *display* real-actual-frame-counter) 8)))
      (camera-line
        (the-as vector (&+ s4-4 0))
        (the-as vector (&+ s4-4 16))
        (new 'static 'vector4w :y #xff :z #xff :w #x80)
        )
      (vector-lerp-clamp!
        s5-7
        (the-as vector (&+ s4-4 0))
        (the-as vector (&+ s4-4 16))
        (-> *CAM_LAYOUT-bank* spline-t)
        )
      (camera-cross
        (new 'static 'vector :y 1024.0)
        (new 'static 'vector :z 1024.0)
        s5-7
        (new 'static 'vector4w :y #xff :z #xff :w #x80)
        (meters 1)
        )
      )
    )
  (let ((s5-8 (new 'stack 'interp-test-info))
        (s4-5 (new-stack-vector0))
        )
    (when (and (cam-slave-get-vector-with-offset arg0 (-> s5-8 origin) 'pivot)
               (cam-slave-get-vector-with-offset arg0 (-> s5-8 to) 'align)
               (cam-slave-get-vector-with-offset arg0 (-> s5-8 from) 'trans)
               )
      (camera-line (-> s5-8 from) (-> s5-8 origin) (new 'static 'vector4w :x #x80 :y #x80 :z #x80 :w #x80))
      (camera-line (-> s5-8 to) (-> s5-8 origin) (new 'static 'vector4w :x #x80 :y #x80 :z #x80 :w #x80))
      (vector-! (-> s5-8 from) (-> s5-8 from) (-> s5-8 origin))
      (vector-! (-> s5-8 to) (-> s5-8 to) (-> s5-8 origin))
      (vector-cross! s4-5 (-> s5-8 from) (-> s5-8 to))
      (vector-normalize! s4-5 (the-as float 8192.0))
      (vector+! s4-5 s4-5 (-> s5-8 origin))
      (camera-line (-> s5-8 origin) s4-5 (new 'static 'vector4w :x #x80 :y #x80 :z #x80 :w #x80))
      (when (not (paused?))
        (+! (-> *CAM_LAYOUT-bank* debug-t) (-> *CAM_LAYOUT-bank* debug-step))
        (if (< 1.0 (-> *CAM_LAYOUT-bank* debug-t))
            (set! (-> *CAM_LAYOUT-bank* debug-t) 0.0)
            )
        )
      (set! (-> s5-8 axis) #f)
      (set! (-> s5-8 disp) "li")
      (set! (-> s5-8 color) (new 'static 'vector4w :x #xff :w #x80))
      (interp-test (the-as (function vector vector vector float vector float none) vector-lerp!) s5-8)
      (set! (-> s5-8 disp) "si")
      (set! (-> s5-8 color) (new 'static 'vector4w :y #xff :w #x80))
      (interp-test (the-as (function vector vector vector float vector float none) v-slrp!) s5-8)
      (set! (-> s5-8 disp) "si2")
      (set! (-> s5-8 color) (new 'static 'vector4w :z #xff :w #x80))
      (interp-test (the-as (function vector vector vector float vector float none) v-slrp2!) s5-8)
      (set! (-> s5-8 disp) "si3")
      (set! (-> s5-8 color) (new 'static 'vector4w :x #xff :z #xff :w #x80))
      (interp-test-deg (the-as (function vector vector vector vector float none) v-slrp3!) s5-8)
      (set! (-> s5-8 axis) (-> *camera* local-down))
      (set! (-> s5-8 disp) "si2d")
      (set! (-> s5-8 color) (new 'static 'vector4w :y #xff :z #xff :w #x80))
      (interp-test (the-as (function vector vector vector float vector float none) v-slrp2!) s5-8)
      (set! (-> s5-8 disp) "si3d")
      (set! (-> s5-8 color) (new 'static 'vector4w :x #xff :y #xff :w #x80))
      (interp-test-deg (the-as (function vector vector vector vector float none) v-slrp3!) s5-8)
      )
    )
  )

(defun clmf-button-test ()
  (cam-layout-print 16 *camera-layout-message-ypos* "button test")
  (set! *camera-layout-message-ypos* (+ *camera-layout-message-ypos* 8))
  (set! *camera-read-analog* #f)
  #f
  )

(defun clmf-bna ()
  (cam-layout-print 16 *camera-layout-message-ypos* "button not applicable")
  (set! *camera-layout-message-ypos* (+ *camera-layout-message-ypos* 8))
  (set! *camera-read-analog* #f)
  #t
  )

(defun clmf-implement ()
  (cam-layout-print 16 *camera-layout-message-ypos* "button not implemented yet")
  (set! *camera-layout-message-ypos* (+ *camera-layout-message-ypos* 8))
  (set! *camera-read-analog* #f)
  #t
  )

(defun clmf-input ((arg0 vector) (arg1 vector) (arg2 int))
  (vector-reset! arg0)
  (vector-reset! arg1)
  (cond
    ((cpad-hold? arg2 l3)
     (set! (-> arg0 z) (- (-> arg0 z) (analog-input
                                        (the-as int (-> *cpad-list* cpads arg2 rightx))
                                        (the-as float 128.0)
                                        (the-as float 48.0)
                                        (the-as float 110.0)
                                        (the-as float 1.0)
                                        )
                          )
           )
     )
    (else
      (set! (-> arg0 y) (- (-> arg0 y) (analog-input
                                         (the-as int (-> *cpad-list* cpads arg2 rightx))
                                         (the-as float 128.0)
                                         (the-as float 48.0)
                                         (the-as float 110.0)
                                         (the-as float 1.0)
                                         )
                           )
            )
      (+! (-> arg0 x) (analog-input
                        (the-as int (-> *cpad-list* cpads arg2 righty))
                        (the-as float 128.0)
                        (the-as float 48.0)
                        (the-as float 110.0)
                        (the-as float 1.0)
                        )
          )
      (set! (-> arg1 x) (- (-> arg1 x) (analog-input
                                         (the-as int (-> *cpad-list* cpads arg2 leftx))
                                         (the-as float 128.0)
                                         (the-as float 48.0)
                                         (the-as float 110.0)
                                         (the-as float 1.0)
                                         )
                           )
            )
      (when *camera-read-buttons*
        (if (cpad-hold? arg2 r1)
            (set! (-> arg1 y) (+ 0.5
                                 (analog-input
                                   (the-as int (-> *cpad-list* cpads arg2 abutton 9))
                                   (the-as float 0.0)
                                   (the-as float 32.0)
                                   (the-as float 230.0)
                                   (the-as float 0.5)
                                   )
                                 (-> arg1 y)
                                 )
                  )
            )
        )
      (when *camera-read-buttons*
        (if (cpad-hold? arg2 l1)
            (set! (-> arg1 y) (- (-> arg1 y) (+ 0.5 (analog-input
                                                      (the-as int (-> *cpad-list* cpads arg2 abutton 8))
                                                      (the-as float 0.0)
                                                      (the-as float 32.0)
                                                      (the-as float 230.0)
                                                      (the-as float 0.5)
                                                      )
                                                )
                                 )
                  )
            )
        )
      (set! (-> arg1 z) (- (-> arg1 z) (analog-input
                                         (the-as int (-> *cpad-list* cpads arg2 lefty))
                                         (the-as float 128.0)
                                         (the-as float 48.0)
                                         (the-as float 110.0)
                                         (the-as float 1.0)
                                         )
                           )
            )
      )
    )
  (let ((s5-1 (new-stack-matrix0)))
    (let ((a2-8 (new-stack-vector0)))
      (set! (-> a2-8 y) -1.0)
      (forward-down-nopitch->inv-matrix s5-1 (-> *math-camera* inv-camera-rot vector 2) a2-8)
      )
    (vector-matrix*! arg1 arg1 s5-1)
    )
  arg1
  )

(defbehavior clmf-pos-rot cam-layout ((arg0 symbol) (arg1 symbol))
  (local-vars (s2-0 structure) (s3-1 structure) (sv-192 matrix))
  (cam-layout-print 16 *camera-layout-message-ypos* "x/z pos: left stick, down: l1, up: r1")
  (set! *camera-layout-message-ypos* (+ *camera-layout-message-ypos* 8))
  (when (and arg1 (nonzero? arg1))
    (cam-layout-print 16 *camera-layout-message-ypos* "x/y rot: right stick")
    (set! *camera-layout-message-ypos* (+ *camera-layout-message-ypos* 8))
    (cam-layout-print 16 *camera-layout-message-ypos* "z rot: press left stick & move right")
    (set! *camera-layout-message-ypos* (+ *camera-layout-message-ypos* 8))
    )
  (let ((s5-0 (new-stack-vector0))
        (s4-0 (new-stack-vector0))
        )
    (set! s3-1
          (cond
            ((or (zero? arg0) (not arg0))
             #f
             )
            (else
              (if (not (res-lump-struct (-> self cam-entity) arg0 structure :time (the-as float -1000000000.0)))
                  (add-data!
                    (-> self cam-entity)
                    (new 'static 'res-tag :name arg0 :key-frame -1000000000.0 :elt-count #x1 :inlined? #x1 :elt-type vector)
                    (the-as pointer (new 'static 'vector))
                    )
                  )
              (set! s3-1 (res-lump-struct (-> self cam-entity) arg0 structure :time (the-as float -1000000000.0)))
              (when (and (not s3-1) (logtest? (-> *display* real-actual-frame-counter) 8))
                (clear *temp-string*)
                (format *temp-string* "ERROR <GMJ>: can't add ~A" 'vector)
                (cam-layout-print 120 100 *temp-string*)
                )
              s3-1
              )
            )
          )
    (set! s2-0
          (cond
            ((or (zero? arg1) (not arg1))
             #f
             )
            (else
              (if (not (res-lump-struct (-> self cam-entity) arg1 structure :time (the-as float -1000000000.0)))
                  (add-data!
                    (-> self cam-entity)
                    (new 'static 'res-tag :name arg1 :key-frame -1000000000.0 :elt-count #x1 :inlined? #x1 :elt-type quaternion)
                    (the-as pointer (quaternion-identity! (new 'static 'quaternion)))
                    )
                  )
              (set! s2-0 (res-lump-struct (-> self cam-entity) arg1 structure :time (the-as float -1000000000.0)))
              (when (and (not s2-0) (logtest? (-> *display* real-actual-frame-counter) 8))
                (clear *temp-string*)
                (format *temp-string* "ERROR <GMJ>: can't add ~A" 'quaternion)
                (cam-layout-print 120 100 *temp-string*)
                )
              s2-0
              )
            )
          )
    (let ((s1-1 (new 'stack-no-clear 'matrix)))
      (set! sv-192 (new 'stack-no-clear 'matrix))
      (let ((s0-1 (new 'stack-no-clear 'vector)))
        (if (not s3-1)
            (return #f)
            )
        (clmf-input s5-0 s4-0 0)
        (vector+float*! (the-as vector s3-1) (the-as vector s3-1) s4-0 (the-as float 409.6))
        (cond
          ((not arg1)
           (the-as quaternion #f)
           )
          ((zero? arg1)
           (the-as quaternion #f)
           )
          (else
            (cam-slave-get-rot (the-as entity-actor (-> self cam-entity)) sv-192)
            (vector-float*! s5-0 s5-0 100.0)
            (matrix-rotate-x! s1-1 (- (-> s5-0 x)))
            (matrix*! sv-192 s1-1 sv-192)
            (matrix-rotate-y! s1-1 (-> s5-0 y))
            (matrix*! sv-192 sv-192 s1-1)
            (matrix-rotate-z! s1-1 (- (-> s5-0 z)))
            (matrix*! sv-192 s1-1 sv-192)
            (matrix->quaternion (the-as quaternion s0-1) sv-192)
            (quaternion-inverse! (the-as quaternion s2-0) (the-as quaternion (-> self cam-entity connect)))
            (quaternion*! (the-as quaternion s2-0) (the-as quaternion s0-1) (the-as quaternion s2-0))
            (quaternion-normalize! (the-as quaternion s2-0))
            )
          )
        )
      )
    )
  (set! *camera-read-analog* #f)
  #t
  )

(defbehavior clmf-next-volume cam-layout ((arg0 int))
  (if (zero? (-> self num-volumes))
      (return #f)
      )
  (set! (-> self cur-volume) (mod (+ arg0 (-> self cur-volume)) (-> self num-volumes)))
  (while (< (-> self cur-volume) 0)
    (+! (-> self cur-volume) (-> self num-volumes))
    )
  #t
  )

(defun clmf-next-vol-dpad ()
  (local-vars (a0-1 int))
  (cam-layout-print 16 *camera-layout-message-ypos* "dpad selects volume")
  (set! *camera-layout-message-ypos* (+ *camera-layout-message-ypos* 8))
  (cond
    ((cpad-pressed? 0 down)
     (set! a0-1 1)
     )
    ((cpad-pressed? 0 right)
     (set! a0-1 1)
     )
    ((cpad-pressed? 0 up)
     (set! a0-1 -1)
     )
    ((cpad-pressed? 0 left)
     (set! a0-1 -1)
     )
    (else
      (set! a0-1 0)
      )
    )
  (clmf-next-volume a0-1)
  (set! *camera-read-analog* #f)
  #t
  )

(defun clmf-to-edit-cam ()
  (clmf-next-volume 0)
  (set! *clm* *clm-edit*)
  #t
  )

(define *last-cur-entity* -1)

(defbehavior clmf-next-entity cam-layout ((arg0 int))
  (let ((v1-0 (/ arg0 8)))
    (when (zero? (-> self num-entities))
      (set! (-> self cam-entity) #f)
      (return #f)
      )
    (if (= (- v1-0) (-> self num-entities))
        (set! v1-0 -1)
        )
    (if (= v1-0 (-> self num-entities))
        (set! v1-0 1)
        )
    (set! (-> self cur-entity) (mod (+ v1-0 (-> self cur-entity)) (-> self num-entities)))
    )
  (while (< (-> self cur-entity) 0)
    (+! (-> self cur-entity) (-> self num-entities))
    )
  (set! *last-cur-entity* (-> self cur-entity))
  (let ((v1-8 (-> self cur-entity))
        (a0-13 (-> *camera-engine* alive-list next0))
        )
    *camera-engine*
    (let ((a1-3 (-> a0-13 next0)))
      (while (!= a0-13 (-> *camera-engine* alive-list-end))
        (let ((a0-14 (-> (the-as connection a0-13) param1)))
          (cond
            ((zero? v1-8)
             (set! (-> self cam-entity) (the-as entity-camera a0-14))
             (set! *volume-descriptor-current* 0)
             (set! *volume-point-current* 0)
             (set! *volume-normal-current* 0)
             (set! (-> self num-volumes) 0)
             (cam-layout-entity-volume-info-create (-> self cam-entity) 'vol)
             (set! (-> self first-pvol) (-> self num-volumes))
             (cam-layout-entity-volume-info-create (-> self cam-entity) 'pvol)
             (set! (-> self first-cutoutvol) (-> self num-volumes))
             (cam-layout-entity-volume-info-create (-> self cam-entity) 'cutoutvol)
             (set! (-> *CAM_LAYOUT-bank* intro-step) (cam-slave-get-intro-step (-> self cam-entity)))
             (return #f)
             )
            (else
              (+! v1-8 -1)
              )
            )
          )
        (set! a0-13 a1-3)
        *camera-engine*
        (set! a1-3 (-> a1-3 next0))
        )
      )
    )
  #t
  )

(defbehavior clmf-to-vol-attr cam-layout ()
  (set! (-> self res-key) (the float (-> self cur-volume)))
  (set! *clm* *clm-vol-attr*)
  #t
  )

(defun clmf-to-spline-attr ()
  (set! *clm* *clm-spline-attr*)
  #t
  )

(defun clmf-to-intro-attr ()
  (set! *clm* *clm-intro-attr*)
  #t
  )

(defun clmf-to-index-attr ()
  (set! *clm* *clm-index-attr*)
  #t
  )

(defun clmf-to-focalpull-attr ()
  (set! *clm* *clm-focalpull-attr*)
  #t
  )

(defbehavior clmf-to-edit cam-layout ()
  (set! (-> self res-key) -1000000000.0)
  (set! *clm* *clm-edit*)
  #t
  )

(defun clmf-to-select ()
  (set! *camera-layout-blink* #f)
  (set! *clm* *clm-select*)
  #t
  )

(defbehavior clmf-look-through cam-layout ()
  (set! (-> *camera-other-fov* data) (cam-slave-get-fov (-> self cam-entity)))
  (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) *camera-other-trans* 'trans)
  (set! (-> *camera-other-root* quad) (-> *camera-other-trans* quad))
  (cam-slave-get-rot (the-as entity-actor (-> self cam-entity)) *camera-other-matrix*)
  (set! *camera-look-through-other* 10)
  (set! *camera-read-analog* #f)
  #f
  )

(defun fov->maya ((arg0 float))
  (the-as float (if (= arg0 0.0)
                    0.0
                    (/ 12.700255 (tan (* 0.5 arg0)))
                    )
          )
  )

(defun cam-layout-save-cam-rot ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((s3-0 (-> arg2 quat))
        (s5-0 (res-lump-struct arg2 'rot-offset vector :time (the-as float -1000000000.0)))
        )
    (if arg0
        (format #t "setup rot ~f ~f ~f ~f~%" (-> s3-0 x) (-> s3-0 y) (-> s3-0 z) (-> s3-0 w))
        )
    (the-as string (when s5-0
                     (if arg0
                         (format #t "rot offset ~f ~f ~f ~f~%" (-> s5-0 x) (-> s5-0 y) (-> s5-0 z) (-> s5-0 w))
                         )
                     (format
                       arg1
                       "  tag rot-offset             ~f ~f ~f ~f // vector (quaternion)~%"
                       (-> s5-0 x)
                       (-> s5-0 y)
                       (-> s5-0 z)
                       (-> s5-0 w)
                       )
                     )
            )
    )
  )

(defun cam-layout-save-cam-trans ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((s1-0 (-> arg2 trans))
        (s5-0 (method-of-type res-lump get-property-struct))
        (s2-0 arg2)
        )
    (format (clear *res-key-string*) "~S~S" 'trans '-offset)
    (let ((s5-1 (the-as vector (s5-0
                                 s2-0
                                 (string->symbol *res-key-string*)
                                 'interp
                                 (the-as float -1000000000.0)
                                 #f
                                 (the-as (pointer res-tag) #f)
                                 *res-static-buf*
                                 )
                        )
                )
          )
      (let ((s2-1 (res-lump-struct arg2 'translation_info vector :time (the-as float -1000000000.0)))
            (s3-1 (new-stack-vector0))
            )
        (if arg0
            (format #t "setup trans ~M ~M ~M (maya)~%" (-> s1-0 x) (-> s1-0 y) (-> s1-0 z))
            )
        (set! (-> s3-1 quad) (-> s1-0 quad))
        (when (the-as structure s5-1)
          (if arg0
              (format #t "offset ~M ~M ~M (added)~%" (-> s5-1 x) (-> s5-1 y) (-> s5-1 z))
              )
          (vector+! s3-1 s3-1 s5-1)
          )
        (when s2-1
          (if arg0
              (format #t "level-trans ~M ~M ~M (subtracted)~%" (-> s2-1 x) (-> s2-1 y) (-> s2-1 z))
              )
          (vector-! s3-1 s3-1 s2-1)
          )
        (set! s2-1 (the-as vector (or s5-1 s2-1)))
        (set! arg0 (and (the-as symbol s2-1) arg0))
        (if arg0
            (format #t "final trans ~M ~M ~M (maya)~%" (-> s3-1 x) (-> s3-1 y) (-> s3-1 z))
            )
        )
      (the-as string (if s5-1
                         (format
                           arg1
                           "  tag trans-offset           METERS(~M) METERS(~M) METERS(~M) 1.0 // vector~%"
                           (-> s5-1 x)
                           (-> s5-1 y)
                           (-> s5-1 z)
                           )
                         )
              )
      )
    )
  )

(defun cam-layout-save-pivot ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((s2-0 (res-lump-struct arg2 'pivot vector :time (the-as float -1000000000.0)))
        (s3-0 (method-of-type res-lump get-property-struct))
        )
    (format (clear *res-key-string*) "~S~S" 'pivot '-offset)
    (let ((s5-1 (the-as vector (s3-0
                                 arg2
                                 (string->symbol *res-key-string*)
                                 'interp
                                 (the-as float -1000000000.0)
                                 #f
                                 (the-as (pointer res-tag) #f)
                                 *res-static-buf*
                                 )
                        )
                )
          (s3-1 (new-stack-vector0))
          )
      (the-as string (when s2-0
                       (if s5-1
                           (vector+! s3-1 s2-0 s5-1)
                           (set! (-> s3-1 quad) (-> s2-0 quad))
                           )
                       (if arg0
                           (format #t "setup pivot ~M ~M ~M~%" (-> s2-0 x) (-> s2-0 y) (-> s2-0 z))
                           )
                       (when s5-1
                         (when arg0
                           (format #t "offset ~M ~M ~M~%" (-> s5-1 x) (-> s5-1 y) (-> s5-1 z))
                           (format #t "final pivot ~M ~M ~M~%" (-> s3-1 x) (-> s3-1 y) (-> s3-1 z))
                           )
                         (format
                           arg1
                           "  tag pivot-offset           METERS(~M) METERS(~M) METERS(~M) 1.0 // vector~%"
                           (-> s5-1 x)
                           (-> s5-1 y)
                           (-> s5-1 z)
                           )
                         )
                       )
              )
      )
    )
  )

(defun cam-layout-save-align ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((s2-0 (res-lump-struct arg2 'align vector :time (the-as float -1000000000.0)))
        (s3-0 (method-of-type res-lump get-property-struct))
        )
    (format (clear *res-key-string*) "~S~S" 'align '-offset)
    (let ((s5-1 (the-as vector (s3-0
                                 arg2
                                 (string->symbol *res-key-string*)
                                 'interp
                                 (the-as float -1000000000.0)
                                 #f
                                 (the-as (pointer res-tag) #f)
                                 *res-static-buf*
                                 )
                        )
                )
          (s3-1 (new-stack-vector0))
          )
      (the-as string (when s2-0
                       (if s5-1
                           (vector+! s3-1 s2-0 s5-1)
                           (set! (-> s3-1 quad) (-> s2-0 quad))
                           )
                       (if arg0
                           (format #t "setup align ~M ~M ~M~%" (-> s2-0 x) (-> s2-0 y) (-> s2-0 z))
                           )
                       (when s5-1
                         (when arg0
                           (format #t "offset ~M ~M ~M~%" (-> s5-1 x) (-> s5-1 y) (-> s5-1 z))
                           (format #t "final align ~M ~M ~M~%" (-> s3-1 x) (-> s3-1 y) (-> s3-1 z))
                           )
                         (format
                           arg1
                           "  tag align-offset           METERS(~M) METERS(~M) METERS(~M) 1.0 // vector~%"
                           (-> s5-1 x)
                           (-> s5-1 y)
                           (-> s5-1 z)
                           )
                         )
                       )
              )
      )
    )
  )

(defun cam-layout-save-interesting ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((s2-0 (res-lump-struct arg2 'interesting vector :time (the-as float -1000000000.0)))
        (s3-0 (method-of-type res-lump get-property-struct))
        )
    (format (clear *res-key-string*) "~S~S" 'interesting '-offset)
    (let ((s5-1 (the-as vector (s3-0
                                 arg2
                                 (string->symbol *res-key-string*)
                                 'interp
                                 (the-as float -1000000000.0)
                                 #f
                                 (the-as (pointer res-tag) #f)
                                 *res-static-buf*
                                 )
                        )
                )
          (s3-1 (new-stack-vector0))
          )
      (the-as string (when s2-0
                       (if s5-1
                           (vector+! s3-1 s2-0 s5-1)
                           (set! (-> s3-1 quad) (-> s2-0 quad))
                           )
                       (if arg0
                           (format #t "setup interesting ~M ~M ~M~%" (-> s2-0 x) (-> s2-0 y) (-> s2-0 z))
                           )
                       (when s5-1
                         (when arg0
                           (format #t "offset ~M ~M ~M~%" (-> s5-1 x) (-> s5-1 y) (-> s5-1 z))
                           (format #t "final interesting ~M ~M ~M~%" (-> s3-1 x) (-> s3-1 y) (-> s3-1 z))
                           )
                         (format
                           arg1
                           "  tag interesting-offset           METERS(~M) METERS(~M) METERS(~M) 1.0 // vector~%"
                           (-> s5-1 x)
                           (-> s5-1 y)
                           (-> s5-1 z)
                           )
                         )
                       )
              )
      )
    )
  )

(defun cam-layout-save-fov ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((f30-0 ((method-of-type res-lump get-property-value-float)
                arg2
                'fov
                'interp
                (the-as float -1000000000.0)
                (the-as float 0.0)
                (the-as (pointer res-tag) #f)
                *res-static-buf*
                )
               )
        (s3-0 (method-of-type res-lump get-property-value-float))
        )
    (format (clear *res-key-string*) "~S~S" 'fov '-offset)
    (let ((f28-0
            (s3-0
              arg2
              (string->symbol *res-key-string*)
              'interp
              (the-as float -1000000000.0)
              (the-as float 0.0)
              (the-as (pointer res-tag) #f)
              *res-static-buf*
              )
            )
          )
      (cond
        ((= f30-0 0.0)
         (if arg0
             (format #t "setup fov deg 0.0 (defaults to 64.0)~%")
             )
         (set! f30-0 11650.845)
         )
        (arg0
          (format #t "setup fov deg ~R (~f in maya)~%" f30-0 (fov->maya f30-0))
          )
        )
      (the-as
        string
        (when (!= f28-0 0.0)
          (when arg0
            (format #t "offset ~R~%" f28-0)
            (format #t "final ~R (~f in maya) ~%" (+ f30-0 f28-0) (fov->maya (+ f30-0 f28-0)))
            )
          (format arg1 "  tag fov-offset             DEG(~R)                           // float~%" f28-0)
          )
        )
      )
    )
  )

(defun cam-layout-save-focalpull ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((f30-0 ((method-of-type res-lump get-property-value-float)
                arg2
                'focalPull
                'interp
                (the-as float -1000000000.0)
                (the-as float 0.0)
                (the-as (pointer res-tag) #f)
                *res-static-buf*
                )
               )
        (s3-0 (method-of-type res-lump get-property-value-float))
        )
    (format (clear *res-key-string*) "~S~S" 'focalPull '-offset)
    (let ((f28-0
            (s3-0
              arg2
              (string->symbol *res-key-string*)
              'interp
              (the-as float -1000000000.0)
              (the-as float 0.0)
              (the-as (pointer res-tag) #f)
              *res-static-buf*
              )
            )
          )
      (if arg0
          (format #t "setup focalPull deg ~R (~f in maya)~%" f30-0 (fov->maya f30-0))
          )
      (the-as
        string
        (when (!= f28-0 0.0)
          (when arg0
            (format #t "offset ~R~%" f28-0)
            (format #t "final ~R (~f in maya) ~%" (+ f30-0 f28-0) (fov->maya (+ f30-0 f28-0)))
            )
          (format arg1 "  tag focalPull-offset       DEG(~R)                           // float~%" f28-0)
          )
        )
      )
    )
  )

(defun cam-layout-save-flags ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((s4-0 (res-lump-value arg2 'flags uint128 :time (the-as float -1000000000.0)))
        (s5-0 (method-of-type res-lump get-property-value))
        (s1-0 arg2)
        )
    (format (clear *res-key-string*) "~S~S" 'flags '-on)
    (let ((s5-1 (s5-0
                  s1-0
                  (string->symbol *res-key-string*)
                  'interp
                  (the-as float -1000000000.0)
                  (the-as uint128 0)
                  (the-as (pointer res-tag) #f)
                  *res-static-buf*
                  )
                )
          (s1-1 (method-of-type res-lump get-property-value))
          )
      (format (clear *res-key-string*) "~S~S" 'flags '-off)
      (let ((s3-1 (s1-1
                    arg2
                    (string->symbol *res-key-string*)
                    'interp
                    (the-as float -1000000000.0)
                    (the-as uint128 0)
                    (the-as (pointer res-tag) #f)
                    *res-static-buf*
                    )
                  )
            )
        (when arg0
          (format #t "setup flags ")
          (cam-slave-options->string (the-as cam-slave-options s4-0) #t)
          (format #t "~%")
          (format #t "forced on ")
          (cam-slave-options->string (the-as cam-slave-options s5-1) #t)
          (format #t "~%")
          (format #t "forced off ")
          (cam-slave-options->string (the-as cam-slave-options s3-1) #t)
          (format #t "~%")
          (let ((s4-1 (logclear (logior s4-0 s5-1) s3-1)))
            (format #t "final ")
            (cam-slave-options->string (the-as cam-slave-options s4-1) #t)
            )
          (format #t "~%")
          )
        (format arg1 "  tag flags-on               0x~X                              // int32~%" s5-1)
        (the-as string (format arg1 "  tag flags-off              0x~X                              // int32~%" s3-1))
        )
      )
    )
  )

(defun cam-layout-save-focalpull-flags ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((s4-0 (res-lump-value arg2 'focalpull-flags uint128 :time (the-as float -1000000000.0)))
        (s5-0 (method-of-type res-lump get-property-value))
        (s1-0 arg2)
        )
    (format (clear *res-key-string*) "~S~S" 'focalpull-flags '-on)
    (let ((s5-1 (s5-0
                  s1-0
                  (string->symbol *res-key-string*)
                  'interp
                  (the-as float -1000000000.0)
                  (the-as uint128 0)
                  (the-as (pointer res-tag) #f)
                  *res-static-buf*
                  )
                )
          (s1-1 (method-of-type res-lump get-property-value))
          )
      (format (clear *res-key-string*) "~S~S" 'focalpull-flags '-off)
      (let ((s3-1
              (s1-1
                arg2
                (string->symbol *res-key-string*)
                'interp
                (the-as float -1000000000.0)
                (the-as uint128 0)
                (the-as (pointer res-tag) #f)
                *res-static-buf*
                )
              )
            )
        (when arg0
          (format #t "setup focalpull-flags ")
          (cam-index-options->string (the-as cam-index-options s4-0) #t)
          (format #t "~%")
          (format #t "forced on ")
          (cam-index-options->string (the-as cam-index-options s5-1) #t)
          (format #t "~%")
          (format #t "forced off ")
          (cam-index-options->string (the-as cam-index-options s3-1) #t)
          (format #t "~%")
          (let ((s4-1 (logclear (logior s4-0 s5-1) s3-1)))
            (format #t "final ")
            (cam-index-options->string (the-as cam-index-options s4-1) #t)
            )
          (format #t "~%")
          )
        (format arg1 "  tag focalpull-flags-on               0x~X                              // int32~%" s5-1)
        (the-as
          string
          (format arg1 "  tag focalpull-flags-off              0x~X                              // int32~%" s3-1)
          )
        )
      )
    )
  )

(defun cam-layout-save-campoints-flags ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((s4-0 (res-lump-value arg2 'campoints-flags uint128 :time (the-as float -1000000000.0)))
        (s5-0 (method-of-type res-lump get-property-value))
        (s1-0 arg2)
        )
    (format (clear *res-key-string*) "~S~S" 'campoints-flags '-on)
    (let ((s5-1 (s5-0
                  s1-0
                  (string->symbol *res-key-string*)
                  'interp
                  (the-as float -1000000000.0)
                  (the-as uint128 0)
                  (the-as (pointer res-tag) #f)
                  *res-static-buf*
                  )
                )
          (s1-1 (method-of-type res-lump get-property-value))
          )
      (format (clear *res-key-string*) "~S~S" 'campoints-flags '-off)
      (let ((s3-1
              (s1-1
                arg2
                (string->symbol *res-key-string*)
                'interp
                (the-as float -1000000000.0)
                (the-as uint128 0)
                (the-as (pointer res-tag) #f)
                *res-static-buf*
                )
              )
            )
        (when arg0
          (format #t "setup campoints-flags ")
          (cam-index-options->string (the-as cam-index-options s4-0) #t)
          (format #t "~%")
          (format #t "forced on ")
          (cam-index-options->string (the-as cam-index-options s5-1) #t)
          (format #t "~%")
          (format #t "forced off ")
          (cam-index-options->string (the-as cam-index-options s3-1) #t)
          (format #t "~%")
          (let ((s4-1 (logclear (logior s4-0 s5-1) s3-1)))
            (format #t "final ")
            (cam-index-options->string (the-as cam-index-options s4-1) #t)
            )
          (format #t "~%")
          )
        (format arg1 "  tag campoints-flags-on               0x~X                              // int32~%" s5-1)
        (the-as
          string
          (format arg1 "  tag campoints-flags-off              0x~X                              // int32~%" s3-1)
          )
        )
      )
    )
  )

(defun cam-layout-save-introsplinetime ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((f30-0 ((method-of-type res-lump get-property-value-float)
                arg2
                'intro-time
                'interp
                (the-as float -1000000000.0)
                (the-as float 0.0)
                (the-as (pointer res-tag) #f)
                *res-static-buf*
                )
               )
        (s3-0 (method-of-type res-lump get-property-value-float))
        )
    (format (clear *res-key-string*) "~S~S" 'intro-time '-offset)
    (let ((f28-0
            (s3-0
              arg2
              (string->symbol *res-key-string*)
              'interp
              (the-as float -1000000000.0)
              (the-as float 0.0)
              (the-as (pointer res-tag) #f)
              *res-static-buf*
              )
            )
          )
      (cond
        ((= f30-0 0.0)
         (if arg0
             (format #t "setup intro-time 0.0 (defaults to 1 sec)~%")
             )
         (set! f30-0 1.0)
         )
        (arg0
          (format #t "setup intro-time ~f~%" f30-0)
          )
        )
      (the-as
        string
        (when (!= f28-0 0.0)
          (when arg0
            (format #t "offset ~f~%" f28-0)
            (format #t "final ~f~%" (+ f30-0 f28-0))
            )
          (format arg1 "  tag intro-time-offset      SECONDS(~f)                      // float~%" f28-0)
          )
        )
      )
    )
  )

(defun cam-layout-save-introsplineexitval ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((f30-0 ((method-of-type res-lump get-property-value-float)
                arg2
                'intro-exitValue
                'interp
                (the-as float -1000000000.0)
                (the-as float 0.0)
                (the-as (pointer res-tag) #f)
                *res-static-buf*
                )
               )
        (s3-0 (method-of-type res-lump get-property-value-float))
        )
    (format (clear *res-key-string*) "~S~S" 'intro-exitValue '-offset)
    (let ((f28-0
            (s3-0
              arg2
              (string->symbol *res-key-string*)
              'interp
              (the-as float -1000000000.0)
              (the-as float 0.0)
              (the-as (pointer res-tag) #f)
              *res-static-buf*
              )
            )
          )
      (when arg0
        (if (= f30-0 0.0)
            (format #t "setup intro-exitValue 0.0 (defaults to 0.5)~%")
            (format #t "setup intro-exitValue ~f~%" f30-0)
            )
        )
      (the-as
        string
        (when (!= f28-0 0.0)
          (when arg0
            (format #t "offset ~f~%" f28-0)
            (format #t "final ~f~%" (+ f30-0 f28-0))
            )
          (format arg1 "  tag intro-exitValue-offset ~f                               // float~%" f28-0)
          )
        )
      )
    )
  )

(defun cam-layout-save-interptime ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((f30-0 ((method-of-type res-lump get-property-value-float)
                arg2
                'interpTime
                'interp
                (the-as float -1000000000.0)
                (the-as float 0.0)
                (the-as (pointer res-tag) #f)
                *res-static-buf*
                )
               )
        (s3-0 (method-of-type res-lump get-property-value-float))
        )
    (format (clear *res-key-string*) "~S~S" 'interpTime '-offset)
    (let ((f28-0
            (s3-0
              arg2
              (string->symbol *res-key-string*)
              'interp
              (the-as float -1000000000.0)
              (the-as float 0.0)
              (the-as (pointer res-tag) #f)
              *res-static-buf*
              )
            )
          )
      (if arg0
          (format #t "setup interpTime ~f~%" f30-0)
          )
      (the-as
        string
        (when (!= f28-0 0.0)
          (when arg0
            (format #t "offset ~f~%" f28-0)
            (format #t "final ~f~%" (+ f30-0 f28-0))
            )
          (format arg1 "  tag interpTime-offset     SECONDS(~f)                      // float~%" f28-0)
          )
        )
      )
    )
  )

(defun cam-layout-save-splineoffset ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (the-as
    string
    (when (and (not (res-lump-struct arg2 'pivot structure :time (the-as float -1000000000.0)))
               (res-lump-struct arg2 'spline-offset structure :time (the-as float -1000000000.0))
               )
      (let ((s4-1 (res-lump-struct arg2 'spline-offset vector :time (the-as float -1000000000.0))))
        (when s4-1
          (if arg0
              (format #t "spline offset ~M ~M ~M~%" (-> s4-1 x) (-> s4-1 y) (-> s4-1 z))
              )
          (format
            arg1
            "  tag spline-offset          METERS(~M) METERS(~M) METERS(~M) 1.0  // vector~%"
            (-> s4-1 x)
            (-> s4-1 y)
            (-> s4-1 z)
            )
          )
        )
      )
    )
  )

(defun cam-layout-save-spline-follow-dist-offset ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (the-as string (when (and (not (res-lump-struct arg2 'pivot structure :time (the-as float -1000000000.0)))
                            ((method-of-type res-lump get-property-value-float)
                             arg2
                             'spline-follow-dist-offset
                             'interp
                             (the-as float -1000000000.0)
                             (the-as float #f)
                             (the-as (pointer res-tag) #f)
                             *res-static-buf*
                             )
                            )
                   (let ((f30-0 ((method-of-type res-lump get-property-value-float)
                                 arg2
                                 'spline-follow-dist-offset
                                 'interp
                                 (the-as float -1000000000.0)
                                 (the-as float 0.0)
                                 (the-as (pointer res-tag) #f)
                                 *res-static-buf*
                                 )
                                )
                         )
                     (when (the int f30-0)
                       (if arg0
                           (format #t "spline follow dist offset ~M~%" f30-0)
                           )
                       (format arg1 "  tag spline-follow-dist-offset          METERS(~M)~%" f30-0)
                       )
                     )
                   )
          )
  )

(defun cam-layout-save-campointsoffset ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((s5-0 (res-lump-struct arg2 'campoints-offset vector :time (the-as float -1000000000.0))))
    (the-as string (when s5-0
                     (if arg0
                         (format #t "index offset ~M ~M ~M~%" (-> s5-0 x) (-> s5-0 y) (-> s5-0 z))
                         )
                     (format
                       arg1
                       "  tag campoints-offset          METERS(~M) METERS(~M) METERS(~M) 1.0  // vector~%"
                       (-> s5-0 x)
                       (-> s5-0 y)
                       (-> s5-0 z)
                       )
                     )
            )
    )
  )

(defun cam-layout-save-tiltAdjust ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((f30-0 ((method-of-type res-lump get-property-value-float)
                arg2
                'tiltAdjust
                'interp
                (the-as float -1000000000.0)
                (the-as float 0.0)
                (the-as (pointer res-tag) #f)
                *res-static-buf*
                )
               )
        (s3-0 (method-of-type res-lump get-property-value-float))
        )
    (format (clear *res-key-string*) "~S~S" 'tiltAdjust '-offset)
    (let ((f28-0
            (s3-0
              arg2
              (string->symbol *res-key-string*)
              'interp
              (the-as float -1000000000.0)
              (the-as float 0.0)
              (the-as (pointer res-tag) #f)
              *res-static-buf*
              )
            )
          )
      (if arg0
          (format #t "setup tiltAdjust deg ~R~%" f30-0)
          )
      (the-as
        string
        (when (!= f28-0 0.0)
          (when arg0
            (format #t "offset ~R~%" f28-0)
            (format #t "final ~R~%" (+ f30-0 f28-0))
            )
          (format arg1 "  tag tiltAdjust-offset      DEG(~R)                           // float~%" f28-0)
          )
        )
      )
    )
  )

(defun cam-layout-save-stringMinLength ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((f30-0 ((method-of-type res-lump get-property-value-float)
                arg2
                'stringMinLength
                'interp
                (the-as float -1000000000.0)
                (the-as float 0.0)
                (the-as (pointer res-tag) #f)
                *res-static-buf*
                )
               )
        (s3-0 (method-of-type res-lump get-property-value-float))
        )
    (format (clear *res-key-string*) "~S~S" 'stringMinLength '-offset)
    (let ((f28-0
            (s3-0
              arg2
              (string->symbol *res-key-string*)
              'interp
              (the-as float -1000000000.0)
              (the-as float 0.0)
              (the-as (pointer res-tag) #f)
              *res-static-buf*
              )
            )
          )
      (if arg0
          (format #t "setup stringMinLength ~M~%" f30-0)
          )
      (the-as
        string
        (when (!= f28-0 0.0)
          (when arg0
            (format #t "offset ~M~%" f28-0)
            (format #t "final ~M~%" (+ f30-0 f28-0))
            )
          (format arg1 "  tag stringMinLength-offset METERS(~M)                            // float~%" f28-0)
          )
        )
      )
    )
  )

(defun cam-layout-save-stringMaxLength ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((f30-0 ((method-of-type res-lump get-property-value-float)
                arg2
                'stringMaxLength
                'interp
                (the-as float -1000000000.0)
                (the-as float 0.0)
                (the-as (pointer res-tag) #f)
                *res-static-buf*
                )
               )
        (s3-0 (method-of-type res-lump get-property-value-float))
        )
    (format (clear *res-key-string*) "~S~S" 'stringMaxLength '-offset)
    (let ((f28-0
            (s3-0
              arg2
              (string->symbol *res-key-string*)
              'interp
              (the-as float -1000000000.0)
              (the-as float 0.0)
              (the-as (pointer res-tag) #f)
              *res-static-buf*
              )
            )
          )
      (if arg0
          (format #t "setup stringMaxLength ~M~%" f30-0)
          )
      (the-as
        string
        (when (!= f28-0 0.0)
          (when arg0
            (format #t "offset ~M~%" f28-0)
            (format #t "final ~M~%" (+ f30-0 f28-0))
            )
          (format arg1 "  tag stringMaxLength-offset METERS(~M)                            // float~%" f28-0)
          )
        )
      )
    )
  )

(defun cam-layout-save-stringMinHeight ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((f30-0 ((method-of-type res-lump get-property-value-float)
                arg2
                'stringMinHeight
                'interp
                (the-as float -1000000000.0)
                (the-as float 0.0)
                (the-as (pointer res-tag) #f)
                *res-static-buf*
                )
               )
        (s3-0 (method-of-type res-lump get-property-value-float))
        )
    (format (clear *res-key-string*) "~S~S" 'stringMinHeight '-offset)
    (let ((f28-0
            (s3-0
              arg2
              (string->symbol *res-key-string*)
              'interp
              (the-as float -1000000000.0)
              (the-as float 0.0)
              (the-as (pointer res-tag) #f)
              *res-static-buf*
              )
            )
          )
      (if arg0
          (format #t "setup stringMinHeight ~M~%" f30-0)
          )
      (the-as
        string
        (when (!= f28-0 0.0)
          (when arg0
            (format #t "offset ~M~%" f28-0)
            (format #t "final ~M~%" (+ f30-0 f28-0))
            )
          (format arg1 "  tag stringMinHeight-offset METERS(~M)                            // float~%" f28-0)
          )
        )
      )
    )
  )

(defun cam-layout-save-stringMaxHeight ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((f30-0 ((method-of-type res-lump get-property-value-float)
                arg2
                'stringMaxHeight
                'interp
                (the-as float -1000000000.0)
                (the-as float 0.0)
                (the-as (pointer res-tag) #f)
                *res-static-buf*
                )
               )
        (s3-0 (method-of-type res-lump get-property-value-float))
        )
    (format (clear *res-key-string*) "~S~S" 'stringMaxHeight '-offset)
    (let ((f28-0
            (s3-0
              arg2
              (string->symbol *res-key-string*)
              'interp
              (the-as float -1000000000.0)
              (the-as float 0.0)
              (the-as (pointer res-tag) #f)
              *res-static-buf*
              )
            )
          )
      (if arg0
          (format #t "setup stringMaxHeight ~M~%" f30-0)
          )
      (the-as
        string
        (when (!= f28-0 0.0)
          (when arg0
            (format #t "offset ~M~%" f28-0)
            (format #t "final ~M~%" (+ f30-0 f28-0))
            )
          (format arg1 "  tag stringMaxHeight-offset METERS(~M)                            // float~%" f28-0)
          )
        )
      )
    )
  )

(defun cam-layout-save-stringCliffHeight ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((f30-0 ((method-of-type res-lump get-property-value-float)
                arg2
                'stringCliffHeight
                'interp
                (the-as float -1000000000.0)
                (the-as float 0.0)
                (the-as (pointer res-tag) #f)
                *res-static-buf*
                )
               )
        (s3-0 (method-of-type res-lump get-property-value-float))
        )
    (format (clear *res-key-string*) "~S~S" 'stringCliffHeight '-offset)
    (let ((f28-0
            (s3-0
              arg2
              (string->symbol *res-key-string*)
              'interp
              (the-as float -1000000000.0)
              (the-as float 0.0)
              (the-as (pointer res-tag) #f)
              *res-static-buf*
              )
            )
          )
      (if arg0
          (format #t "setup stringCliffHeight ~M~%" f30-0)
          )
      (the-as
        string
        (when (!= f28-0 0.0)
          (when arg0
            (format #t "offset ~M~%" f28-0)
            (format #t "final ~M~%" (+ f30-0 f28-0))
            )
          (format arg1 "  tag stringCliffHeight-offset METERS(~M)                            // float~%" f28-0)
          )
        )
      )
    )
  )

(defun cam-layout-save-maxAngle ((arg0 symbol) (arg1 string) (arg2 entity-actor))
  (let ((f30-0 ((method-of-type res-lump get-property-value-float)
                arg2
                'maxAngle
                'interp
                (the-as float -1000000000.0)
                (the-as float 0.0)
                (the-as (pointer res-tag) #f)
                *res-static-buf*
                )
               )
        (s3-0 (method-of-type res-lump get-property-value-float))
        )
    (format (clear *res-key-string*) "~S~S" 'maxAngle '-offset)
    (let ((f28-0 (s3-0
                   arg2
                   (string->symbol *res-key-string*)
                   'interp
                   (the-as float -1000000000.0)
                   (the-as float 0.0)
                   (the-as (pointer res-tag) #f)
                   *res-static-buf*
                   )
                 )
          )
      (if arg0
          (format #t "setup maxAngle ~R~%" f30-0)
          )
      (the-as string (when (!= f28-0 0.0)
                       (when arg0
                         (format #t "offset ~R~%" f28-0)
                         (format #t "final ~R~%" (+ f30-0 f28-0))
                         )
                       (format arg1 "  tag maxAngle-offset DEG(~R)                            // float~%" f28-0)
                       )
              )
      )
    )
  )

(defbehavior clmf-save-single cam-layout ((arg0 entity-camera) (arg1 symbol) (arg2 symbol))
  (clear *temp-string*)
  (if arg2
      (format
        *temp-string*
        "dd_next/caminfo/~s.cam"
        (res-lump-struct arg0 'name structure :time (the-as float -1000000000.0))
        )
      (format *temp-string* "dd_next/caminfo/garbage")
      )
  (let ((s4-2 (new 'stack 'file-stream *temp-string* 'write)))
    (if arg1
        (format
          #t
          "---------camera '~S'------------~%"
          (res-lump-struct arg0 'name structure :time (the-as float -1000000000.0))
          )
        )
    (format s4-2 "#include /next/config_data/standard.m2d~%")
    (format s4-2 "camera ~s {~%" (res-lump-struct arg0 'name structure :time (the-as float -1000000000.0)))
    (cam-layout-save-cam-rot arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-cam-trans arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-pivot arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-align arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-interesting arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-fov arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-focalpull arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-flags arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-introsplinetime arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-introsplineexitval arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-interptime arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-splineoffset arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-spline-follow-dist-offset arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-campointsoffset arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-tiltAdjust arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-stringMinLength arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-stringMaxLength arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-stringMinHeight arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-stringMaxHeight arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-stringCliffHeight arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-maxAngle arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-campoints-flags arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (cam-layout-save-focalpull-flags arg1 (the-as string s4-2) (the-as entity-actor arg0))
    (format s4-2 "}~%")
    (file-stream-close s4-2)
    )
  )

(defbehavior clmf-save-one cam-layout ((arg0 symbol))
  (let ((s5-1 (logtest? (the-as int arg0) 8))
        (gp-1 (logtest? (the-as int arg0) 16))
        )
    (if s5-1
        (format #t "~%~%~%=================================~%")
        )
    (clmf-save-single (-> self cam-entity) s5-1 gp-1)
    (if s5-1
        (format #t "===============================~%~%~%~%")
        )
    (if gp-1
        (format
          #t
          "'~S' save completed~%"
          (res-lump-struct (-> self cam-entity) 'name structure :time (the-as float -1000000000.0))
          )
        )
    )
  #t
  )

(defbehavior clmf-save-all cam-layout ((arg0 symbol))
  (let ((s5-1 (logtest? (the-as int arg0) 8))
        (gp-1 (logtest? (the-as int arg0) 16))
        )
    (if s5-1
        (format #t "~%~%~%=================================~%")
        )
    (let ((v1-5 (-> *camera-engine* alive-list next0)))
      *camera-engine*
      (let ((s4-0 (-> v1-5 next0)))
        (while (!= v1-5 (-> *camera-engine* alive-list-end))
          (let ((a0-4 (-> (the-as connection v1-5) param1)))
            (clmf-save-single (the-as entity-camera a0-4) s5-1 gp-1)
            )
          (set! v1-5 s4-0)
          *camera-engine*
          (set! s4-0 (-> s4-0 next0))
          )
        )
      )
    (if s5-1
        (format #t "===============================~%~%~%~%")
        )
    (if gp-1
        (format #t "camera save all completed~%")
        )
    )
  #t
  )

(deftype clmf-cam-flag-toggle-info (structure)
  ((key       float  :offset-assert   0)
   (force-on  int32  :offset-assert   4)
   (force-off int32  :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )


(defbehavior clmf-cam-flag-toggle cam-layout ((arg0 int) (arg1 int))
  (let ((s4-0 (/ arg0 8))
        (gp-0 (new 'stack 'clmf-cam-flag-toggle-info))
        )
    (set! (-> gp-0 key) (-> self res-key))
    (cond
      ((and (= arg1 'vol-flags) (>= (-> self res-key) (the float (-> self first-cutoutvol))))
       (set! (-> gp-0 key) (- (-> gp-0 key) (the float (-> self first-cutoutvol))))
       (set! arg1 (the-as int 'cutoutvol-flags))
       )
      ((and (= arg1 'vol-flags) (>= (-> self res-key) (the float (-> self first-pvol))))
       (set! (-> gp-0 key) (- (-> gp-0 key) (the float (-> self first-pvol))))
       (set! arg1 (the-as int 'pvol-flags))
       )
      )
    (let ((s3-0 (method-of-type res-lump get-property-value))
          (s2-0 (-> self cam-entity))
          )
      (format (clear *res-key-string*) "~S~S" (the-as object arg1) '-on)
      (set! (-> gp-0 force-on) (the-as int (s3-0
                                             s2-0
                                             (string->symbol *res-key-string*)
                                             'exact
                                             (-> gp-0 key)
                                             (the-as uint128 0)
                                             (the-as (pointer res-tag) #f)
                                             *res-static-buf*
                                             )
                                       )
            )
      )
    (let ((s3-1 (method-of-type res-lump get-property-value))
          (s2-1 (-> self cam-entity))
          )
      (format (clear *res-key-string*) "~S~S" (the-as object arg1) '-off)
      (set! (-> gp-0 force-off) (the-as int (s3-1
                                              s2-1
                                              (string->symbol *res-key-string*)
                                              'exact
                                              (-> gp-0 key)
                                              (the-as uint128 0)
                                              (the-as (pointer res-tag) #f)
                                              *res-static-buf*
                                              )
                                        )
            )
      )
    (cond
      ((logtest? (-> gp-0 force-off) s4-0)
       (logclear! (-> gp-0 force-off) s4-0)
       (logior! (-> gp-0 force-on) s4-0)
       (let* ((s4-1 (-> self cam-entity))
              (s3-2 (method-of-object s4-1 add-32bit-data!))
              (s2-2 (logior (shl #x10000 32) (shr (shl (the-as int int32) 32) 32)))
              (s1-2 (shl (the-as int (-> gp-0 key)) 32))
              )
         (format (clear *res-key-string*) "~S~S" (the-as object arg1) '-off)
         (s3-2
           s4-1
           (the-as
             res-tag
             (make-u128 s2-2 (logior s1-2 (shr (shl (the-as int (string->symbol *res-key-string*)) 32) 32)))
             )
           (-> gp-0 force-off)
           )
         )
       (let* ((s4-2 (-> self cam-entity))
              (s3-3 (method-of-object s4-2 add-32bit-data!))
              (s2-3 (logior (shl #x10000 32) (shr (shl (the-as int int32) 32) 32)))
              (s1-3 (shl (the-as int (-> gp-0 key)) 32))
              )
         (format (clear *res-key-string*) "~S~S" (the-as object arg1) '-on)
         (s3-3
           s4-2
           (the-as
             res-tag
             (make-u128 s2-3 (logior s1-3 (shr (shl (the-as int (string->symbol *res-key-string*)) 32) 32)))
             )
           (-> gp-0 force-on)
           )
         )
       )
      ((logtest? (-> gp-0 force-on) s4-0)
       (logclear! (-> gp-0 force-on) s4-0)
       (let* ((s4-3 (-> self cam-entity))
              (s3-4 (method-of-object s4-3 add-32bit-data!))
              (s2-4 (logior (shl #x10000 32) (shr (shl (the-as int int32) 32) 32)))
              (s1-4 (shl (the-as int (-> gp-0 key)) 32))
              )
         (format (clear *res-key-string*) "~S~S" (the-as object arg1) '-on)
         (s3-4
           s4-3
           (the-as
             res-tag
             (make-u128 s2-4 (logior s1-4 (shr (shl (the-as int (string->symbol *res-key-string*)) 32) 32)))
             )
           (-> gp-0 force-on)
           )
         )
       )
      (else
        (logior! (-> gp-0 force-off) s4-0)
        (let* ((s4-4 (-> self cam-entity))
               (s3-5 (method-of-object s4-4 add-32bit-data!))
               (s2-5 (logior (shl #x10000 32) (shr (shl (the-as int int32) 32) 32)))
               (s1-5 (shl (the-as int (-> gp-0 key)) 32))
               )
          (format (clear *res-key-string*) "~S~S" (the-as object arg1) '-off)
          (s3-5
            s4-4
            (the-as
              res-tag
              (make-u128 s2-5 (logior s1-5 (shr (shl (the-as int (string->symbol *res-key-string*)) 32) 32)))
              )
            (-> gp-0 force-off)
            )
          )
        )
      )
    )
  #t
  )

(defbehavior clmf-cam-flag cam-layout ((arg0 string) (arg1 uint) (arg2 uint))
  (let ((s5-0 (/ (the-as int arg1) 8))
        (f30-0 (-> self res-key))
        )
    (cond
      ((and (= arg2 'vol-flags) (>= (-> self res-key) (the float (-> self first-cutoutvol))))
       (set! f30-0 (- f30-0 (the float (-> self first-cutoutvol))))
       (set! arg2 (the-as uint 'cutoutvol-flags))
       )
      ((and (= arg2 'vol-flags) (>= (-> self res-key) (the float (-> self first-pvol))))
       (set! f30-0 (- f30-0 (the float (-> self first-pvol))))
       (set! arg2 (the-as uint 'pvol-flags))
       )
      )
    (let ((s3-0 (method-of-type res-lump get-property-value))
          (s2-0 (-> self cam-entity))
          )
      (format (clear *res-key-string*) "~S~S" (the-as object arg2) '-off)
      (cond
        ((logtest? (s3-0
                     s2-0
                     (string->symbol *res-key-string*)
                     'exact
                     f30-0
                     (the-as uint128 0)
                     (the-as (pointer res-tag) #f)
                     *res-static-buf*
                     )
                   s5-0
                   )
         (format arg0 ": off")
         )
        ((let ((s3-1 (method-of-type res-lump get-property-value))
               (s2-1 (-> self cam-entity))
               )
           (format (clear *res-key-string*) "~S~S" (the-as object arg2) '-on)
           (logtest? (s3-1
                       s2-1
                       (string->symbol *res-key-string*)
                       'exact
                       f30-0
                       (the-as uint128 0)
                       (the-as (pointer res-tag) #f)
                       *res-static-buf*
                       )
                     s5-0
                     )
           )
         (format arg0 ": on")
         )
        ((not (logtest? ((method-of-type res-lump get-property-value)
                         (-> self cam-entity)
                         (the-as symbol arg2)
                         'exact
                         f30-0
                         (the-as uint128 0)
                         (the-as (pointer res-tag) #f)
                         *res-static-buf*
                         )
                        s5-0
                        )
              )
         (format arg0 ": off(maya)")
         )
        (else
          (format arg0 ": on(maya)")
          )
        )
      )
    )
  #t
  )

(defbehavior clmf-cam-float-adjust cam-layout ((arg0 symbol) (arg1 (pointer float)))
  (cam-layout-print 16 *camera-layout-message-ypos* "left stick adjusts value")
  (set! *camera-layout-message-ypos* (+ *camera-layout-message-ypos* 8))
  (let ((f30-0 ((method-of-type res-lump get-property-value-float)
                (-> self cam-entity)
                arg0
                'interp
                (the-as float -1000000000.0)
                (the-as float 0.0)
                (the-as (pointer res-tag) #f)
                *res-static-buf*
                )
               )
        (f0-0 (-> arg1 0))
        )
    (if (= f0-0 0.0)
        (set! f0-0 1.0)
        )
    (let ((f0-2
            (+ f30-0
               (analog-input
                 (the-as int (-> *cpad-list* cpads 0 leftx))
                 (the-as float 128.0)
                 (the-as float 48.0)
                 (the-as float 110.0)
                 f0-0
                 )
               )
            )
          )
      (add-32bit-data!
        (-> self cam-entity)
        (new 'static 'res-tag :name arg0 :key-frame -1000000000.0 :elt-count #x1 :elt-type float)
        f0-2
        )
      )
    )
  (set! *camera-read-analog* #f)
  #t
  )

(defbehavior clmf-cam-meters cam-layout ((arg0 meters) (arg1 symbol))
  (let ((f0-0 (cam-slave-get-float (-> self cam-entity) arg1 (the-as float 0.0))))
    (format arg0 ": ~M" f0-0)
    )
  #t
  )

(defbehavior clmf-cam-fov cam-layout ((arg0 degrees) (arg1 symbol))
  (format arg0 ": ~R" (cam-slave-get-fov (-> self cam-entity)))
  #t
  )

(defbehavior clmf-cam-deg cam-layout ((arg0 degrees) (arg1 symbol))
  (format arg0 ": ~R" (cam-slave-get-float (-> self cam-entity) arg1 (the-as float 0.0)))
  #t
  )

(defbehavior clmf-cam-intro-time cam-layout ((arg0 float) (arg1 symbol))
  (let ((f30-0 (cam-slave-get-intro-step (-> self cam-entity))))
    (format arg0 ": ~f" (/ 0.016666668 f30-0))
    (set! (-> *CAM_LAYOUT-bank* intro-step) f30-0)
    )
  #t
  )

(defbehavior clmf-cam-interp-time cam-layout ((arg0 float) (arg1 symbol))
  (format arg0 ": ~f" (cam-slave-get-interp-time (-> self cam-entity)))
  #t
  )

(defbehavior clmf-cam-float cam-layout ((arg0 float) (arg1 symbol))
  (format arg0 ": ~f" (cam-slave-get-float (-> self cam-entity) arg1 (the-as float 0.0)))
  #t
  )

(defbehavior clmf-cam-string cam-layout ((arg0 string) (arg1 symbol))
  (local-vars (sv-16 res-tag))
  (format arg0 ":")
  (set! sv-16 (new 'static 'res-tag))
  (let ((s5-1 (res-lump-data (-> self cam-entity) arg1 pointer :tag-ptr (& sv-16) :time (the-as float -1000000000.0)))
        )
    (when s5-1
      (dotimes (s4-0 (the-as int (-> sv-16 elt-count)))
        (format arg0 " ~S" (-> (the-as (pointer uint32) (&+ s5-1 (* s4-0 4)))))
        )
      )
    )
  #t
  )

(define *clm-focalpull-attr*
  (new 'static 'clm
    :title "---focalpull attributes--"
    :items (new 'static 'boxed-array :type clm-basic
      (new 'static 'clm-item
        :description "    ok"
        :button-symbol 'square
        :action (new 'static 'clm-item-action :button #x8000 :options #x1 :func '*clm-edit*)
        )
      (new 'static 'clm-item
        :description "adjust"
        :button-symbol 'x
        :action (new 'static 'clm-item-action :button #x4000 :func #f)
        )
      (new 'static 'clm-list
        :tracker #f
        :items (new 'static 'boxed-array :type clm-list-item
          (new 'static 'clm-list-item
            :description "radial    "
            :track-val #f
            :val-func 'clmf-cam-flag
            :val-parm0 16
            :val-parm1-basic 'focalpull-flags
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action
                :button #x4000
                :options #x1
                :func 'clmf-cam-flag-toggle
                :parm0 16
                :parm1-basic 'focalpull-flags
                )
              )
            )
          (new 'static 'clm-list-item
            :description "spherical "
            :track-val #f
            :val-func 'clmf-cam-flag
            :val-parm0 8
            :val-parm1-basic 'focalpull-flags
            :actions (new 'static 'boxed-array :type clm-item-action (new 'static 'clm-item-action
                                                              :button #x4000
                                                              :options #x1
                                                              :func 'clmf-cam-flag-toggle
                                                              :parm0 8
                                                              :parm1-basic 'focalpull-flags
                                                              )
                                                            )
            )
          )
        )
      )
    )
  )

(define *clm-index-attr*
  (new 'static 'clm
    :title "---index attributes--"
    :items (new 'static 'boxed-array :type clm-basic
      (new 'static 'clm-item
        :description "    ok"
        :button-symbol 'square
        :action (new 'static 'clm-item-action :button #x8000 :options #x1 :func '*clm-edit*)
        )
      (new 'static 'clm-item
        :description "adjust"
        :button-symbol 'x
        :action (new 'static 'clm-item-action :button #x4000 :func #f)
        )
      (new 'static 'clm-list
        :tracker #f
        :items (new 'static 'boxed-array :type clm-list-item
          (new 'static 'clm-list-item
            :description "radial    "
            :track-val #f
            :val-func 'clmf-cam-flag
            :val-parm0 16
            :val-parm1-basic 'campoints-flags
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action
                :button #x4000
                :options #x1
                :func 'clmf-cam-flag-toggle
                :parm0 16
                :parm1-basic 'campoints-flags
                )
              )
            )
          (new 'static 'clm-list-item
            :description "spherical "
            :track-val #f
            :val-func 'clmf-cam-flag
            :val-parm0 8
            :val-parm1-basic 'campoints-flags
            :actions (new 'static 'boxed-array :type clm-item-action (new 'static 'clm-item-action
                                                              :button #x4000
                                                              :options #x1
                                                              :func 'clmf-cam-flag-toggle
                                                              :parm0 8
                                                              :parm1-basic 'campoints-flags
                                                              )
                                                            )
            )
          )
        )
      )
    )
  )

(define *clm-intro-attr*
  (new 'static 'clm
    :title "---intro attributes--"
    :items (new 'static 'boxed-array :type clm-basic
      (new 'static 'clm-item
        :description "    ok"
        :button-symbol 'square
        :action (new 'static 'clm-item-action :button #x8000 :options #x1 :func '*clm-edit*)
        )
      (new 'static 'clm-item
        :description "adjust"
        :button-symbol 'x
        :action (new 'static 'clm-item-action :button #x4000 :func #f)
        )
      (new 'static 'clm-list
        :tracker #f
        :items (new 'static 'boxed-array :type clm-list-item
          (new 'static 'clm-list-item
            :description "time     "
            :track-val #f
            :val-func 'clmf-cam-intro-time
            :val-parm0-basic 'intro-time
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action
                :button #x4000
                :func 'clmf-cam-float-adjust
                :parm0-basic 'intro-time-offset
                :parm1-basic (new 'static 'bfloat :data 0.01)
                )
              )
            )
          (new 'static 'clm-list-item
            :description "exitValue"
            :track-val #f
            :val-func 'clmf-cam-float
            :val-parm0-basic 'intro-exitValue
            :actions (new 'static 'boxed-array :type clm-item-action (new 'static 'clm-item-action
                                                              :button #x4000
                                                              :func 'clmf-cam-float-adjust
                                                              :parm0-basic 'intro-exitValue-offset
                                                              :parm1-basic (new 'static 'bfloat :data 0.001)
                                                              )
                                                            )
            )
          )
        )
      )
    )
  )

(define *clm-spline-attr*
  (new 'static 'clm
    :title "---spline attributes--"
    :items (new 'static 'boxed-array :type clm-basic
      (new 'static 'clm-item
        :description "    ok"
        :button-symbol 'square
        :action (new 'static 'clm-item-action :button #x8000 :options #x1 :func '*clm-edit*)
        )
      (new 'static 'clm-item
        :description "adjust"
        :button-symbol 'x
        :action (new 'static 'clm-item-action :button #x4000 :func #f)
        )
      (new 'static 'clm-list
        :tracker #f
        :items (new 'static 'boxed-array :type clm-list-item
          (new 'static 'clm-list-item
            :description "followDist"
            :track-val #f
            :val-func 'clmf-cam-meters
            :val-parm0-basic 'spline-follow-dist
            :actions (new 'static 'boxed-array :type clm-item-action (new 'static 'clm-item-action
                                                              :button #x4000
                                                              :func 'clmf-cam-float-adjust
                                                              :parm0-basic 'spline-follow-dist-offset
                                                              :parm1-basic (new 'static 'bfloat :data 409.6)
                                                              )
                                                            )
            )
          )
        )
      )
    )
  )

(define *clm-vol-attr*
  (new 'static 'clm
    :title "---volume attributes--"
    :items (new 'static 'boxed-array :type clm-basic
      (new 'static 'clm-item
        :description "    ok"
        :button-symbol 'square
        :action (new 'static 'clm-item-action :button #x8000 :options #x1 :func '*clm-edit*)
        )
      (new 'static 'clm-item
        :description "adjust"
        :button-symbol 'x
        :action (new 'static 'clm-item-action :button #x4000 :func #f)
        )
      (new 'static 'clm-list
        :tracker #f
        :items (new 'static 'boxed-array :type clm-list-item
          (new 'static 'clm-list-item
            :description "airSwitch"
            :track-val #f
            :val-func 'clmf-cam-flag
            :val-parm0 8
            :val-parm1-basic 'vol-flags
            :actions (new 'static 'boxed-array :type clm-item-action (new 'static 'clm-item-action
                                                              :button #x4000
                                                              :options #x1
                                                              :func 'clmf-cam-flag-toggle
                                                              :parm0 8
                                                              :parm1-basic 'vol-flags
                                                              )
                                                            )
            )
          )
        )
      )
    )
  )

(define *clm-cam-attr*
  (new 'static 'clm
    :title "---camera attributes--"
    :items (new 'static 'boxed-array :type clm-basic
      (new 'static 'clm-item
        :description "    ok"
        :button-symbol 'square
        :action (new 'static 'clm-item-action :button #x8000 :options #x1 :func '*clm-edit*)
        )
      (new 'static 'clm-item
        :description "adjust"
        :button-symbol 'x
        :action (new 'static 'clm-item-action :button #x4000 :func #f)
        )
      (new 'static 'clm-list
        :tracker #f
        :items (new 'static 'boxed-array :type clm-list-item
          (new 'static 'clm-list-item
            :description "drag       "
            :track-val #f
            :val-func 'clmf-cam-flag
            :val-parm0 #x400
            :val-parm1-basic 'flags
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action
                :button #x4000
                :options #x1
                :func 'clmf-cam-flag-toggle
                :parm0 #x400
                :parm1-basic 'flags
                )
              )
            )
          (new 'static 'clm-list-item
            :description "fov        "
            :track-val #f
            :val-func 'clmf-cam-fov
            :val-parm0-basic 'fov
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action
                :button #x4000
                :func 'clmf-cam-float-adjust
                :parm0-basic 'fov-offset
                :parm1-basic (new 'static 'bfloat :data 91.022224)
                )
              )
            )
          (new 'static 'clm-list-item
            :description "focalPull  "
            :track-val #f
            :val-func 'clmf-cam-deg
            :val-parm0-basic 'focalPull
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action
                :button #x4000
                :func 'clmf-cam-float-adjust
                :parm0-basic 'focalPull-offset
                :parm1-basic (new 'static 'bfloat :data 91.022224)
                )
              )
            )
          (new 'static 'clm-list-item
            :description "interpTime "
            :track-val #f
            :val-func 'clmf-cam-interp-time
            :val-parm0-basic 'interpTime
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action
                :button #x4000
                :func 'clmf-cam-float-adjust
                :parm0-basic 'interpTime-offset
                :parm1-basic (new 'static 'bfloat :data 0.01)
                )
              )
            )
          (new 'static 'clm-list-item
            :description "sameSide   "
            :track-val #f
            :val-func 'clmf-cam-flag
            :val-parm0 16
            :val-parm1-basic 'flags
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action
                :button #x4000
                :options #x1
                :func 'clmf-cam-flag-toggle
                :parm0 16
                :parm1-basic 'flags
                )
              )
            )
          (new 'static 'clm-list-item
            :description "spherical  "
            :track-val #f
            :val-func 'clmf-cam-flag
            :val-parm0 32
            :val-parm1-basic 'flags
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action
                :button #x4000
                :options #x1
                :func 'clmf-cam-flag-toggle
                :parm0 32
                :parm1-basic 'flags
                )
              )
            )
          (new 'static 'clm-list-item
            :description "MinLength  "
            :track-val #f
            :val-func 'clmf-cam-meters
            :val-parm0-basic 'stringMinLength
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action
                :button #x4000
                :func 'clmf-cam-float-adjust
                :parm0-basic 'stringMinLength-offset
                :parm1-basic (new 'static 'bfloat :data 409.6)
                )
              )
            )
          (new 'static 'clm-list-item
            :description "MaxLength  "
            :track-val #f
            :val-func 'clmf-cam-meters
            :val-parm0-basic 'stringMaxLength
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action
                :button #x4000
                :func 'clmf-cam-float-adjust
                :parm0-basic 'stringMaxLength-offset
                :parm1-basic (new 'static 'bfloat :data 409.6)
                )
              )
            )
          (new 'static 'clm-list-item
            :description "MinHeight  "
            :track-val #f
            :val-func 'clmf-cam-meters
            :val-parm0-basic 'stringMinHeight
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action
                :button #x4000
                :func 'clmf-cam-float-adjust
                :parm0-basic 'stringMinHeight-offset
                :parm1-basic (new 'static 'bfloat :data 409.6)
                )
              )
            )
          (new 'static 'clm-list-item
            :description "MaxHeight  "
            :track-val #f
            :val-func 'clmf-cam-meters
            :val-parm0-basic 'stringMaxHeight
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action
                :button #x4000
                :func 'clmf-cam-float-adjust
                :parm0-basic 'stringMaxHeight-offset
                :parm1-basic (new 'static 'bfloat :data 409.6)
                )
              )
            )
          (new 'static 'clm-list-item
            :description "cliffHeight"
            :track-val #f
            :val-func 'clmf-cam-meters
            :val-parm0-basic 'stringCliffHeight
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action
                :button #x4000
                :func 'clmf-cam-float-adjust
                :parm0-basic 'stringCliffHeight-offset
                :parm1-basic (new 'static 'bfloat :data 409.6)
                )
              )
            )
          (new 'static 'clm-list-item
            :description "alternates "
            :track-val #f
            :val-func 'clmf-cam-string
            :val-parm0-basic 'alternates
            :actions (new 'static 'boxed-array :type clm-item-action)
            )
          (new 'static 'clm-list-item
            :description "maxAngle   "
            :track-val #f
            :val-func 'clmf-cam-deg
            :val-parm0-basic 'maxAngle
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action
                :button #x4000
                :func 'clmf-cam-float-adjust
                :parm0-basic 'maxAngle-offset
                :parm1-basic (new 'static 'bfloat :data 91.022224)
                )
              )
            )
          (new 'static 'clm-list-item
            :description "shrinkAngle"
            :track-val #f
            :val-func 'clmf-cam-flag
            :val-parm0 #x4000
            :val-parm1-basic 'flags
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action
                :button #x4000
                :options #x1
                :func 'clmf-cam-flag-toggle
                :parm0 #x4000
                :parm1-basic 'flags
                )
              )
            )
          (new 'static 'clm-list-item
            :description "noRotate   "
            :track-val #f
            :val-func 'clmf-cam-flag
            :val-parm0 #x40000
            :val-parm1-basic 'flags
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action
                :button #x4000
                :options #x1
                :func 'clmf-cam-flag-toggle
                :parm0 #x40000
                :parm1-basic 'flags
                )
              )
            )
          (new 'static 'clm-list-item
            :description "tiltAdjust "
            :track-val #f
            :val-func 'clmf-cam-deg
            :val-parm0-basic 'tiltAdjust
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action
                :button #x4000
                :func 'clmf-cam-float-adjust
                :parm0-basic 'tiltAdjust-offset
                :parm1-basic (new 'static 'bfloat :data 91.022224)
                )
              )
            )
          (new 'static 'clm-list-item
            :description "stickyAngle"
            :track-val #f
            :val-func 'clmf-cam-flag
            :val-parm0 #x80000
            :val-parm1-basic 'flags
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action
                :button #x4000
                :options #x1
                :func 'clmf-cam-flag-toggle
                :parm0 #x80000
                :parm1-basic 'flags
                )
              )
            )
          (new 'static 'clm-list-item
            :description "airExit"
            :track-val #f
            :val-func 'clmf-cam-flag
            :val-parm0 #x100000
            :val-parm1-basic 'flags
            :actions (new 'static 'boxed-array :type clm-item-action (new 'static 'clm-item-action
                                                              :button #x4000
                                                              :options #x1
                                                              :func 'clmf-cam-flag-toggle
                                                              :parm0 #x100000
                                                              :parm1-basic 'flags
                                                              )
                                                            )
            )
          )
        )
      )
    )
  )

(define *clm-cam-lookthrough*
  (new 'static 'clm
    :title "---cam-lookthrough---"
    :items (new 'static 'boxed-array :type clm-basic
      (new 'static 'clm-item
        :description "       "
        :button-symbol 'x
        :action (new 'static 'clm-item-action :button #x4000 :options #x4 :func 'clmf-look-through)
        )
      (new 'static 'clm-item
        :description "     ok"
        :button-symbol 'square
        :action (new 'static 'clm-item-action :button #x8000 :options #x1 :func 'clmf-to-edit)
        )
      (new 'static 'clm-item
        :description "pos/rot"
        :button-symbol 'x
        :action (new 'static 'clm-item-action
          :button #x4000
          :options #x8
          :func 'clmf-pos-rot
          :parm0-basic 'trans-offset
          :parm1-basic 'rot-offset
          )
        )
      (new 'static 'clm-item
        :description " adjust"
        :button-symbol 'x
        :action (new 'static 'clm-item-action :button #x4000 :func #f)
        )
      (new 'static 'clm-list
        :tracker #f
        :items (new 'static 'boxed-array :type clm-list-item
          (new 'static 'clm-list-item
            :description "fov"
            :track-val #f
            :val-func 'clmf-cam-fov
            :val-parm0-basic 'fov
            :actions (new 'static 'boxed-array :type clm-item-action (new 'static 'clm-item-action
                                                              :button #x4000
                                                              :func 'clmf-cam-float-adjust
                                                              :parm0-basic 'fov-offset
                                                              :parm1-basic (new 'static 'bfloat :data 91.022224)
                                                              )
                                                            )
            )
          )
        )
      )
    )
  )

(define *clm-edit*
  (new 'static 'clm
    :title "---edit---"
    :items (new 'static 'boxed-array :type clm-basic
      (new 'static 'clm-item
        :description "        ok"
        :button-symbol 'square
        :action (new 'static 'clm-item-action :button #x8000 :options #x1 :func 'clmf-to-select)
        )
      (new 'static 'clm-item
        :description "attributes"
        :button-symbol 'x
        :action (new 'static 'clm-item-action :button #x4000 :options #x1 :func #f)
        )
      (new 'static 'clm-item
        :description " edit part"
        :button-symbol 'circle
        :action (new 'static 'clm-item-action :button #x2000 :options #x1 :func #f)
        )
      (new 'static 'clm-item
        :description "scale/next"
        :button-symbol 'r2
        :action (new 'static 'clm-item-action :button #x200 :func #f)
        )
      (new 'static 'clm-item
        :description "   pos/rot"
        :button-symbol 'l2
        :action (new 'static 'clm-item-action :button #x100 :func #f)
        )
      (new 'static 'clm-list
        :tracker '*camera-layout-blink*
        :items (new 'static 'boxed-array :type clm-list-item
          (new 'static 'clm-list-item
            :description "camera   "
            :track-val 'camera
            :val-func #f
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action :button #x4000 :options #x1 :func '*clm-cam-attr*)
              (new 'static 'clm-item-action :button #x2000 :func '*clm-cam-lookthrough*)
              (new 'static 'clm-item-action :button #x200 :func 'clmf-bna)
              (new 'static 'clm-item-action
                :button #x100
                :func 'clmf-pos-rot
                :parm0-basic 'trans-offset
                :parm1-basic 'rot-offset
                )
              )
            )
          (new 'static 'clm-list-item
            :description "volume   "
            :track-val 'volume
            :val-func #f
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action :button #x4000 :options #x1 :func 'clmf-to-vol-attr)
              (new 'static 'clm-item-action :button #x2000 :func 'clmf-implement)
              (new 'static 'clm-item-action :button #x200 :func 'clmf-next-vol-dpad)
              (new 'static 'clm-item-action :button #x100 :func 'clmf-implement)
              )
            )
          (new 'static 'clm-list-item
            :description "align    "
            :track-val 'align
            :val-func #f
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action :button #x4000 :func 'clmf-bna)
              (new 'static 'clm-item-action :button #x2000 :func 'clmf-bna)
              (new 'static 'clm-item-action :button #x200 :func 'clmf-bna)
              (new 'static 'clm-item-action :button #x100 :func 'clmf-pos-rot :parm0-basic 'align-offset :parm1-basic #f)
              )
            )
          (new 'static 'clm-list-item
            :description "pivot    "
            :track-val 'pivot
            :val-func #f
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action :button #x4000 :func 'clmf-bna)
              (new 'static 'clm-item-action :button #x2000 :func 'clmf-bna)
              (new 'static 'clm-item-action :button #x200 :func 'clmf-bna)
              (new 'static 'clm-item-action :button #x100 :func 'clmf-pos-rot :parm0-basic 'pivot-offset :parm1-basic #f)
              )
            )
          (new 'static 'clm-list-item
            :description "interesting"
            :track-val 'interesting
            :val-func #f
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action :button #x4000 :func 'clmf-bna)
              (new 'static 'clm-item-action :button #x2000 :func 'clmf-bna)
              (new 'static 'clm-item-action :button #x200 :func 'clmf-bna)
              (new 'static 'clm-item-action
                :button #x100
                :func 'clmf-pos-rot
                :parm0-basic 'interesting-offset
                :parm1-basic #f
                )
              )
            )
          (new 'static 'clm-list-item
            :description "spline   "
            :track-val 'spline
            :val-func #f
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action :button #x4000 :func 'clmf-to-spline-attr)
              (new 'static 'clm-item-action :button #x2000 :func 'clmf-implement)
              (new 'static 'clm-item-action :button #x200 :func 'clmf-implement)
              (new 'static 'clm-item-action :button #x100 :func 'clmf-pos-rot :parm0-basic 'spline-offset :parm1-basic #f)
              )
            )
          (new 'static 'clm-list-item
            :description "intro    "
            :track-val 'intro
            :val-func #f
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action :button #x4000 :options #x1 :func 'clmf-to-intro-attr)
              (new 'static 'clm-item-action :button #x2000 :func 'clmf-implement)
              (new 'static 'clm-item-action :button #x200 :func 'clmf-implement)
              (new 'static 'clm-item-action :button #x100 :func 'clmf-implement)
              )
            )
          (new 'static 'clm-list-item
            :description "index    "
            :track-val 'index
            :val-func #f
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action :button #x4000 :options #x1 :func 'clmf-to-index-attr)
              (new 'static 'clm-item-action :button #x2000 :func 'clmf-implement)
              (new 'static 'clm-item-action :button #x200 :func 'clmf-implement)
              (new 'static 'clm-item-action :button #x100 :func 'clmf-pos-rot :parm0-basic 'campoints-offset)
              )
            )
          (new 'static 'clm-list-item
            :description "focalpull"
            :track-val 'focalpull
            :val-func #f
            :actions (new 'static 'boxed-array :type clm-item-action
              (new 'static 'clm-item-action :button #x4000 :options #x1 :func 'clmf-to-focalpull-attr)
              (new 'static 'clm-item-action :button #x2000 :func 'clmf-implement)
              (new 'static 'clm-item-action :button #x200 :func 'clmf-implement)
              (new 'static 'clm-item-action :button #x100 :func 'clmf-implement)
              )
            )
          )
        )
      )
    )
  )

(define *clm-save-all*
  (new 'static 'clm
    :title "---save all?---"
    :items (new 'static 'boxed-array :type clm-basic
      (new 'static 'clm-item
        :description " save all"
        :button-symbol 'x
        :action (new 'static 'clm-item-action :button #x4000 :options #x1 :func 'clmf-save-all :parm0 16)
        )
      (new 'static 'clm-item
        :description "print all"
        :button-symbol 'square
        :action (new 'static 'clm-item-action :button #x8000 :options #x1 :func 'clmf-save-all :parm0 8)
        )
      (new 'static 'clm-item
        :description "     done"
        :button-symbol 'triangle
        :action (new 'static 'clm-item-action :button #x1000 :options #x1 :func 'clmf-to-select)
        )
      )
    )
  )

(define *clm-save-one*
  (new 'static 'clm
    :title "---single save?---"
    :items (new 'static 'boxed-array :type clm-basic
      (new 'static 'clm-item
        :description " single save"
        :button-symbol 'x
        :action (new 'static 'clm-item-action :button #x4000 :options #x1 :func 'clmf-save-one :parm0 16)
        )
      (new 'static 'clm-item
        :description "single print"
        :button-symbol 'square
        :action (new 'static 'clm-item-action :button #x8000 :options #x1 :func 'clmf-save-one :parm0 8)
        )
      (new 'static 'clm-item
        :description "        done"
        :button-symbol 'triangle
        :action (new 'static 'clm-item-action :button #x1000 :options #x1 :func 'clmf-to-select)
        )
      )
    )
  )

(define *clm-select*
  (new 'static 'clm
    :title "---camera---"
    :items (new 'static 'boxed-array :type clm-basic
      (new 'static 'clm-item
        :description "    edit"
        :button-symbol 'x
        :action (new 'static 'clm-item-action :button #x4000 :options #x3 :func 'clmf-to-edit-cam)
        )
      (new 'static 'clm-item
        :description "save one"
        :button-symbol 'triangle
        :action (new 'static 'clm-item-action :button #x1000 :options #x3 :func '*clm-save-one*)
        )
      (new 'static 'clm-item
        :description "    next"
        :button-symbol 'down
        :action (new 'static 'clm-item-action :button #x40 :options #x3 :func 'clmf-next-entity :parm0 8)
        )
      (new 'static 'clm-item
        :description "    prev"
        :button-symbol 'up
        :action (new 'static 'clm-item-action :button #x10 :options #x3 :func 'clmf-next-entity :parm0 -8)
        )
      (new 'static 'clm-item
        :description "  next 5"
        :button-symbol 'right
        :action (new 'static 'clm-item-action :button #x20 :options #x3 :func 'clmf-next-entity :parm0 40)
        )
      (new 'static 'clm-item
        :description "  prev 5"
        :button-symbol 'left
        :action (new 'static 'clm-item-action :button #x80 :options #x3 :func 'clmf-next-entity :parm0 -40)
        )
      )
    )
  )

(define *clm* *clm-select*)

(defbehavior cam-layout-do-action cam-layout ((arg0 clm-item-action))
  (let ((s5-0 (-> arg0 func value)))
    (cond
      ((not s5-0)
       #f
       )
      ((zero? s5-0)
       #f
       )
      ((and (not (-> self cam-entity)) (logtest? (-> arg0 options) 2))
       #f
       )
      ((and (logtest? (-> arg0 options) 8) (logtest? (-> *cpad-list* cpads 0 button0-abs 0) (-> arg0 button)))
       #f
       )
      ((and (not (logtest? (-> arg0 options) 12))
            (logtest? (-> arg0 options) 1)
            (not (logtest? (-> *cpad-list* cpads 0 button0-rel 0) (-> arg0 button)))
            )
       #f
       )
      ((and (not (logtest? (-> arg0 options) 13))
            (not (logtest? (-> *cpad-list* cpads 0 button0-abs 0) (-> arg0 button)))
            )
       #f
       )
      ((type-type? (-> (the-as basic s5-0) type) clm)
       (set! *clm* (the-as clm s5-0))
       #t
       )
      ((type-type? (-> (the-as basic s5-0) type) function)
       ((the-as (function object symbol symbol) s5-0) (-> arg0 parm0) (the-as symbol (-> arg0 parm1-basic)))
       )
      )
    )
  )

(defbehavior cam-layout-function-call cam-layout ((arg0 symbol) (arg1 string) (arg2 int) (arg3 basic))
  (let ((gp-0 (-> arg0 value)))
    (cond
      ((not gp-0)
       )
      ((zero? gp-0)
       )
      ((type-type? (-> (the-as basic gp-0) type) function)
       ((the-as (function string int basic none) gp-0) arg1 arg2 arg3)
       )
      )
    )
  #f
  )

(defbehavior cam-layout-do-menu cam-layout ((arg0 clm))
  (set! *camera-layout-message-ypos* 30)
  (+! (-> *CAM_LAYOUT-bank* spline-t) (-> *CAM_LAYOUT-bank* spline-step))
  (if (< 1.01 (-> *CAM_LAYOUT-bank* spline-t))
      (set! (-> *CAM_LAYOUT-bank* spline-t) -0.09)
      )
  (+! (-> *CAM_LAYOUT-bank* intro-t) (-> *CAM_LAYOUT-bank* intro-step))
  (if (< 1.01 (-> *CAM_LAYOUT-bank* intro-t))
      (set! (-> *CAM_LAYOUT-bank* intro-t) -0.09)
      )
  (let ((s5-0 30))
    (let ((s4-0 (cam-state-from-entity (-> self cam-entity))))
      (set! *camera-read-analog* #t)
      (let ((s3-0 (-> self cam-entity)))
        (clear *temp-string*)
        (if s3-0
            (format *temp-string* "\"~S\"~%" (res-lump-struct s3-0 'name structure :time (the-as float -1000000000.0)))
            )
        )
      (if (not s4-0)
          (format *temp-string* "no cameras in this level")
          (format *temp-string* "~S" (-> s4-0 name))
          )
      )
    (cam-layout-print 320 s5-0 *temp-string*)
    (let ((s5-1 (+ s5-0 16)))
      (clear *temp-string*)
      (format *temp-string* "~S~%" (-> arg0 title))
      (cam-layout-print 320 s5-1 *temp-string*)
      (let ((s4-1 (+ s5-1 8)))
        (dotimes (s5-2 (-> arg0 items length))
          (cond
            ((type-type? (-> arg0 items s5-2 type) clm-list)
             (clear *temp-string*)
             (format *temp-string* "------------")
             (cam-layout-print 320 s4-1 *temp-string*)
             (let ((s4-2 (+ s4-1 8)))
               (let ((s3-1 (the-as clm-list (-> arg0 items s5-2))))
                 (dotimes (s2-1 (-> s3-1 items length))
                   (clear *temp-string*)
                   (format
                     *temp-string*
                     "~S~S"
                     (if (= s2-1 (-> s3-1 cur-list-item))
                         "> "
                         "  "
                         )
                     (-> s3-1 items s2-1 description)
                     )
                   (cam-layout-function-call
                     (-> s3-1 items s2-1 val-func)
                     *temp-string*
                     (-> s3-1 items s2-1 val-parm0)
                     (-> s3-1 items s2-1 val-parm1-basic)
                     )
                   (cam-layout-print 320 s4-2 *temp-string*)
                   (+! s4-2 8)
                   )
                 )
               (clear *temp-string*)
               (format *temp-string* "------------")
               (cam-layout-print 320 s4-2 *temp-string*)
               (set! s4-1 (+ s4-2 8))
               )
             )
            ((and (not (-> self cam-entity)) (logtest? (-> (the-as clm-item (-> arg0 items s5-2)) action options) 2))
             )
            ((logtest? (-> (the-as clm-item (-> arg0 items s5-2)) action options) 4)
             )
            (else
              (let ((s3-2 (-> arg0 items s5-2)))
                (clear *temp-string*)
                (format
                  *temp-string*
                  "~S: ~A~%"
                  (-> (the-as clm-item s3-2) description)
                  (if (logtest? (-> (the-as clm-item (-> arg0 items s5-2)) action options) 8)
                      'default
                      (-> (the-as clm-item s3-2) button-symbol)
                      )
                  )
                )
              (cam-layout-print 320 s4-1 *temp-string*)
              (+! s4-1 8)
              )
            )
          )
        )
      )
    )
  (if (= *master-mode* 'menu)
      (goto cfg-65)
      )
  (dotimes (s5-3 (-> arg0 items length))
    (cond
      ((type-type? (-> arg0 items s5-3 type) clm-list)
       (let ((s4-3 (-> arg0 items s5-3))
             (s3-3 0)
             )
         (if (-> (the-as clm-list s4-3) tracker)
             (set! (-> (the-as clm-list s4-3) tracker value)
                   (-> (the-as clm-list s4-3) items (-> (the-as clm-list s4-3) cur-list-item) track-val)
                   )
             )
         (dotimes (s2-2 (-> (the-as clm-list s4-3) items (-> (the-as clm-list s4-3) cur-list-item) actions length))
           (if (cam-layout-do-action
                 (-> (the-as clm-list s4-3) items (-> (the-as clm-list s4-3) cur-list-item) actions s2-2)
                 )
               (goto cfg-65)
               )
           )
         (cond
           ((cpad-pressed? 0 down)
            (set! s3-3 1)
            )
           ((cpad-pressed? 0 right)
            (set! s3-3 1)
            )
           ((cpad-pressed? 0 up)
            (set! s3-3 -1)
            )
           ((cpad-pressed? 0 left)
            (set! s3-3 -1)
            )
           )
         (when (nonzero? s3-3)
           (set! (-> (the-as clm-list s4-3) cur-list-item)
                 (mod (+ (-> (the-as clm-list s4-3) cur-list-item) s3-3) (-> (the-as clm-list s4-3) items length))
                 )
           (while (< (-> (the-as clm-list s4-3) cur-list-item) 0)
             (+! (-> (the-as clm-list s4-3) cur-list-item) (-> (the-as clm-list s4-3) items length))
             )
           (goto cfg-65)
           )
         )
       )
      ((cam-layout-do-action (-> (the-as clm-item (-> arg0 items s5-3)) action))
       (goto cfg-65)
       )
      )
    )
  (label cfg-65)
  (none)
  )

(defstate cam-layout-active (cam-layout)
  :code (behavior ()
    (loop
      (cam-layout-entity-info (the-as entity-actor (-> self cam-entity)))
      (cam-layout-entity-volume-info)
      (cam-layout-do-menu *clm*)
      (suspend)
      )
    (none)
    )
  )

(defbehavior cam-layout-init cam-layout ()
  (set! (-> self res-key) -1000000000.0)
  (set! (-> self num-entities) 0)
  (let ((v1-2 (-> *camera-engine* alive-list next0)))
    *camera-engine*
    (let ((a0-2 (-> v1-2 next0)))
      (while (!= v1-2 (-> *camera-engine* alive-list-end))
        (-> (the-as connection v1-2) param1)
        (+! (-> self num-entities) 1)
        (set! v1-2 a0-2)
        *camera-engine*
        (set! a0-2 (-> a0-2 next0))
        )
      )
    )
  (set! (-> self cur-entity) *last-cur-entity*)
  (clmf-next-entity 0)
  (set! *clm* *clm-select*)
  (go cam-layout-active)
  (none)
  )

(defun cam-layout-stop ()
  (set! *cam-layout* #f)
  (kill-by-name 'cam-layout *active-pool*)
  )

(defun cam-layout-start ()
  (let ((a0-1 (new 'global 'file-stream "dd_next/caminfo/garbage" 'read)))
    (file-stream-close a0-1)
    )
  (cond
    ((not *cam-layout*)
     (let ((v1-4 (process-spawn-function cam-layout cam-layout-init :from *camera-dead-pool*)))
       (cond
         (v1-4
           (logclear! (-> v1-4 0 mask) (process-mask pause menu))
           (set! *cam-layout* #t)
           (set! *camera-layout-blink* #f)
           )
         (else
           (format 0 "ERROR <GMJ>: no process available to start cam editing mode~%")
           )
         )
       )
     )
    (else
      (format 0 "ERROR <GMJ>: cam editing mode already started~%")
      )
    )
  *cam-layout*
  (none)
  )

(defun cam-layout-restart ()
  (cam-layout-stop)
  (cam-layout-start)
  (none)
  )
