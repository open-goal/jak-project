;;-*-Lisp-*-
(in-package goal)

;; name: camera.gc
;; name in dgo: camera
;; dgos: GAME, ENGINE


;; DECOMP BEGINS

(define *cam-res-string* (new 'global 'string 64 (the-as string #f)))

(defun cam-slave-get-vector-with-offset ((arg0 entity-actor) (arg1 vector) (arg2 symbol))
  (local-vars (s3-0 structure))
  (cond
    ((= arg2 'trans)
     (set! s3-0 (-> arg0 trans))
     )
    ((= arg2 'rot)
     (set! s3-0 (-> arg0 quat))
     )
    (else
      (set! s3-0 (res-lump-struct arg0 arg2 structure))
      )
    )
  (let ((s2-0 (method-of-type res-lump get-property-struct)))
    (format (clear *res-key-string*) "~S~S" arg2 '-offset)
    (let ((a0-6 (s2-0
                  arg0
                  (string->symbol *res-key-string*)
                  'interp
                  -1000000000.0
                  #f
                  (the-as (pointer res-tag) #f)
                  *res-static-buf*
                  )
                )
          )
      (cond
        ((and s3-0 a0-6)
         (vector+! arg1 (the-as vector s3-0) (the-as vector a0-6))
         #t
         )
        ((the-as vector s3-0)
         (set! (-> arg1 quad) (-> (the-as vector s3-0) quad))
         #t
         )
        (else
          #f
          )
        )
      )
    )
  )

(defun cam-slave-get-flags ((arg0 entity) (arg1 symbol))
  (let ((gp-0 (res-lump-value arg0 arg1 uint128))
        (s3-0 (method-of-type res-lump get-property-value))
        (s2-0 arg0)
        )
    (format (clear *res-key-string*) "~S~S" arg1 '-on)
    (let ((s3-1 (s3-0
                  s2-0
                  (string->symbol *res-key-string*)
                  'interp
                  -1000000000.0
                  (the-as uint128 0)
                  (the-as (pointer res-tag) #f)
                  *res-static-buf*
                  )
                )
          (s2-1 (method-of-type res-lump get-property-value))
          )
      (format (clear *res-key-string*) "~S~S" arg1 '-off)
      (let ((v1-3 (s2-1
                    arg0
                    (string->symbol *res-key-string*)
                    'interp
                    -1000000000.0
                    (the-as uint128 0)
                    (the-as (pointer res-tag) #f)
                    *res-static-buf*
                    )
                  )
            )
        (logclear (logior gp-0 s3-1) v1-3)
        )
      )
    )
  )

(defun cam-slave-get-float ((arg0 entity) (arg1 symbol) (arg2 float))
  (let ((f30-0 (res-lump-float arg0 arg1 :default arg2))
        (s4-0 (method-of-type res-lump get-property-value-float))
        )
    (format (clear *res-key-string*) "~S~S" arg1 '-offset)
    (+ f30-0 (s4-0
               arg0
               (string->symbol *res-key-string*)
               'interp
               -1000000000.0
               0.0
               (the-as (pointer res-tag) #f)
               *res-static-buf*
               )
       )
    )
  )

(defun cam-slave-get-fov ((arg0 entity))
  (let ((f30-0 (res-lump-float arg0 'fov))
        (s5-0 (method-of-type res-lump get-property-value-float))
        )
    (format (clear *res-key-string*) "~S~S" 'fov '-offset)
    (let ((f0-0 (s5-0
                  arg0
                  (string->symbol *res-key-string*)
                  'interp
                  -1000000000.0
                  0.0
                  (the-as (pointer res-tag) #f)
                  *res-static-buf*
                  )
                )
          )
      (if (= f30-0 0.0)
          (+ 11650.845 f0-0)
          (+ f30-0 f0-0)
          )
      )
    )
  )

(defun cam-slave-get-intro-step ((arg0 entity))
  (let ((f30-0 (res-lump-float arg0 'intro-time))
        (s5-0 (method-of-type res-lump get-property-value-float))
        )
    (format (clear *res-key-string*) "~S~S" 'intro-time '-offset)
    (let ((f0-1 (+ f30-0 (s5-0
                           arg0
                           (string->symbol *res-key-string*)
                           'interp
                           -1000000000.0
                           0.0
                           (the-as (pointer res-tag) #f)
                           *res-static-buf*
                           )
                   )
                )
          )
      (if (>= 0.0 f0-1)
          0.004166667
          (/ 0.016666668 f0-1)
          )
      )
    )
  )

(defun cam-slave-get-interp-time ((arg0 entity))
  (let ((f30-0 (res-lump-float arg0 'interpTime))
        (s5-0 (method-of-type res-lump get-property-value-float))
        )
    (format (clear *res-key-string*) "~S~S" 'interpTime '-offset)
    (let ((f0-1 (+ f30-0 (s5-0
                           arg0
                           (string->symbol *res-key-string*)
                           'interp
                           -1000000000.0
                           0.0
                           (the-as (pointer res-tag) #f)
                           *res-static-buf*
                           )
                   )
                )
          )
      (if (>= 0.001 f0-1)
          (set! f0-1 0.0)
          )
      f0-1
      )
    )
  )

(defun cam-slave-get-rot ((arg0 entity-actor) (arg1 matrix))
  (let ((s4-0 (method-of-type res-lump get-property-struct))
        (s3-0 arg0)
        )
    (format (clear *res-key-string*) "~S~S" 'rot '-offset)
    (let ((a1-3 (s4-0
                  s3-0
                  (string->symbol *res-key-string*)
                  'interp
                  -1000000000.0
                  #f
                  (the-as (pointer res-tag) #f)
                  *res-static-buf*
                  )
                )
          )
      (cond
        (a1-3
          (let ((s4-1 (new 'stack-no-clear 'quaternion)))
            (quaternion*! s4-1 (the-as quaternion a1-3) (-> arg0 quat))
            (quaternion-normalize! s4-1)
            (quaternion->matrix arg1 s4-1)
            )
          )
        (else
          (quaternion->matrix arg1 (-> arg0 quat))
          )
        )
      )
    )
  arg1
  )

(defun cam-state-from-entity ((arg0 entity))
  (let ((s5-0 (new 'stack 'curve)))
    (the-as state (cond
                    ((not arg0)
                     (the-as (state camera-slave) #f)
                     )
                    ((res-lump-struct arg0 'pivot structure)
                     cam-circular
                     )
                    ((res-lump-struct arg0 'align structure)
                     cam-standoff-read-entity
                     )
                    ((get-curve-data! arg0 s5-0 'campath 'campath-k -1000000000.0)
                     cam-spline
                     )
                    ((< 0.0 (cam-slave-get-float arg0 'stringMaxLength 0.0))
                     *camera-base-mode*
                     )
                    (else
                      cam-fixed-read-entity
                      )
                    )
            )
    )
  )

(defun parameter-ease-none ((arg0 object))
  arg0
  )

(defun parameter-ease-clamp ((arg0 float))
  (cond
    ((>= arg0 1.0)
     (set! arg0 1.0)
     )
    ((>= 0.0 arg0)
     (set! arg0 0.0)
     )
    )
  arg0
  )

(defun parameter-ease-lerp-clamp ((arg0 float))
  (cond
    ((>= arg0 1.0)
     1.0
     )
    ((>= 0.0 arg0)
     0.0
     )
    ((>= 0.25 arg0)
     (* 0.5 arg0)
     )
    ((>= arg0 0.75)
     (- 1.0 (* 0.5 (- 1.0 arg0)))
     )
    (else
      (+ 0.125 (* 1.5 (+ -0.25 arg0)))
      )
    )
  )

(defun parameter-ease-sqrt-clamp ((arg0 float))
  (cond
    ((>= arg0 1.0)
     1.0
     )
    ((>= 0.0 arg0)
     0.0
     )
    ((>= 0.5 arg0)
     (* 0.5 (- 1.0 (sqrtf (- 1.0 (* 2.0 arg0)))))
     )
    (else
      (* 0.5 (+ 1.0 (sqrtf (+ -1.0 (* 2.0 arg0)))))
      )
    )
  )

(defun fourth-power ((arg0 float))
  (let ((f0-2 (* arg0 arg0)))
    (* f0-2 f0-2)
    )
  )

(defun third-power ((arg0 float))
  (* arg0 arg0 arg0)
  )

(defun parameter-ease-sqr-clamp ((arg0 float))
  (cond
    ((>= arg0 1.0)
     1.0
     )
    ((>= 0.0 arg0)
     0.0
     )
    ((>= 0.5 arg0)
     (let ((f0-3 0.5)
           (f1-4 (* 2.0 arg0))
           )
       (* f0-3 (* f1-4 f1-4))
       )
     )
    (else
      (let ((f0-5 1.0)
            (f1-7 0.5)
            (f2-2 (* 2.0 (- 1.0 arg0)))
            )
        (- f0-5 (* f1-7 (* f2-2 f2-2)))
        )
      )
    )
  )

(defun parameter-ease-sin-clamp ((arg0 float))
  (cond
    ((>= arg0 1.0)
     1.0
     )
    ((>= 0.0 arg0)
     0.0
     )
    (else
      (+ 0.5 (* 0.5 (sin (* 182.04445 (+ -90.0 (* 180.0 arg0))))))
      )
    )
  )

(defmethod cam-index-method-9 ((this cam-index) (arg0 symbol) (arg1 entity) (arg2 vector) (arg3 curve))
  (local-vars (sv-32 (function _varargs_ object)))
  (format (clear *cam-res-string*) "~S-flags" arg0)
  (set! (-> this flags) (the-as cam-index-options (cam-slave-get-flags arg1 (string->symbol *res-key-string*))))
  (let ((s3-2 (res-lump-data arg1 arg0 pointer))
        (s0-1 (method-of-type res-lump get-property-struct))
        )
    (set! sv-32 format)
    (let ((a0-7 (clear *res-key-string*))
          (a1-4 "~S~S")
          (a3-2 '-offset)
          )
      (sv-32 a0-7 a1-4 arg0 a3-2)
      )
    (let ((v0-8 (s0-1
                  arg1
                  (string->symbol *res-key-string*)
                  'interp
                  -1000000000.0
                  #f
                  (the-as (pointer res-tag) #f)
                  *res-static-buf*
                  )
                )
          )
      (cond
        (s3-2
          (cond
            (v0-8
              (vector+! (the-as vector (-> this vec)) (the-as vector (&+ s3-2 0)) (the-as vector v0-8))
              (vector+! (-> this vec 1) (the-as vector (&+ s3-2 16)) (the-as vector v0-8))
              )
            (else
              (set! (-> this vec 0 quad) (-> (the-as (pointer uint128) (&+ s3-2 0))))
              (set! (-> this vec 1 quad) (-> (the-as (pointer uint128) (&+ s3-2 16))))
              )
            )
          )
        (arg3
          (set! (-> this vec 0 quad) (-> arg3 cverts 0 quad))
          (set! (-> this vec 1 quad) (-> arg3 cverts (+ (-> arg3 num-cverts) -1) quad))
          )
        (else
          (return #f)
          )
        )
      )
    )
  (let ((s4-1 (new-stack-vector0)))
    0.0
    (cond
      ((logtest? (-> this flags) (cam-index-options SPHERICAL))
       (vector-! s4-1 (-> this vec 1) arg2)
       (set! (-> this vec 1 w) (vector-length s4-1))
       (vector-! s4-1 (the-as vector (-> this vec)) arg2)
       (set! (-> this vec 1 x) (vector-length s4-1))
       (set! (-> this vec 1 w) (- (-> this vec 1 w) (-> this vec 1 x)))
       (set! (-> this vec 0 quad) (-> arg2 quad))
       )
      ((logtest? (-> this flags) (cam-index-options RADIAL))
       (vector-! s4-1 (-> this vec 1) arg2)
       (set! (-> this vec 1 w) (vector-length s4-1))
       (vector-! s4-1 (the-as vector (-> this vec)) arg2)
       (set! (-> this vec 1 x) (vector-length s4-1))
       (set! (-> this vec 1 w) (- (-> this vec 1 w) (-> this vec 1 x)))
       (set! (-> this vec 0 quad) (-> arg2 quad))
       )
      (else
        (vector-! (-> this vec 1) (-> this vec 1) (the-as vector (-> this vec)))
        (set! (-> this vec 1 w) (vector-normalize-ret-len! (-> this vec 1) 1.0))
        )
      )
    )
  #t
  )

(defmethod cam-index-method-10 ((this cam-index) (arg0 vector))
  (let ((s5-0 (new-stack-vector0)))
    0.0
    (vector-! s5-0 arg0 (the-as vector (-> this vec)))
    (cond
      ((logtest? (-> this flags) (cam-index-options SPHERICAL))
       (vector-flatten! s5-0 s5-0 (-> *camera* local-down))
       (/ (- (vector-length s5-0) (-> this vec 1 x)) (-> this vec 1 w))
       )
      ((logtest? (-> this flags) (cam-index-options RADIAL))
       (/ (- (vector-length s5-0) (-> this vec 1 x)) (-> this vec 1 w))
       )
      (else
        (/ (vector-dot s5-0 (-> this vec 1)) (-> this vec 1 w))
        )
      )
    )
  )

(defmethod tracking-spline-method-10 ((this tracking-spline) (arg0 vector))
  (set! (-> this point 0 position quad) (-> arg0 quad))
  (set! (-> this point 0 next) -134250495)
  (set! (-> this summed-len) 0.0)
  (set! (-> this free-point) 1)
  (set! (-> this used-point) 0)
  (set! (-> this partial-point) 0.0)
  (set! (-> this end-point) 0)
  (set! (-> this next-to-last-point) -134250495)
  (set! (-> this max-move) 0.0)
  (set! (-> this sample-len) 0.0)
  (set! (-> this used-count) 1)
  (set! (-> this old-position quad) (-> arg0 quad))
  (let ((v1-6 1))
    (while (!= v1-6 31)
      (set! (-> this point v1-6 next) (+ v1-6 1))
      (+! v1-6 1)
      )
    (set! (-> this point v1-6 next) -134250495)
    )
  0
  (none)
  )

(defmethod tracking-spline-method-13 ((this tracking-spline) (arg0 int))
  (let ((v1-3 (-> this point arg0 next)))
    (cond
      ((= v1-3 -134250495)
       )
      ((= (-> this point v1-3 next) -134250495)
       )
      (else
        (set! (-> this point arg0 next) (-> this point v1-3 next))
        (set! (-> this summed-len) (- (-> this summed-len) (-> this point v1-3 tp-length)))
        (set! (-> this point v1-3 next) (-> this free-point))
        (set! (-> this free-point) v1-3)
        (+! (-> this point v1-3 incarnation) 1)
        (let ((v1-11 (-> this point arg0 next)))
          (set! (-> this summed-len) (- (-> this summed-len) (-> this point arg0 tp-length)))
          (vector-!
            (the-as vector (+ (the-as uint (-> this point 0 direction)) (* 48 arg0)))
            (the-as vector (-> this point v1-11))
            (the-as vector (-> this point arg0))
            )
          )
        (set! (-> this point arg0 tp-length)
              (vector-normalize-ret-len! (the-as vector (+ (the-as uint (-> this point 0 direction)) (* 48 arg0))) 1.0)
              )
        (+! (-> this summed-len) (-> this point arg0 tp-length))
        (+! (-> this used-count) -1)
        )
      )
    )
  0
  (none)
  )

(defmethod tracking-spline-method-14 ((this tracking-spline) (arg0 tracking-spline-sampler))
  (let ((v1-0 (-> this used-point)))
    (set! (-> this partial-point) (-> arg0 partial-pt))
    (when (= (-> this next-to-last-point) v1-0)
      (set! (-> this summed-len) (-> this point v1-0 tp-length))
      (if (= (-> arg0 cur-pt) (-> this end-point))
          (set! (-> this partial-point) 0.99999)
          )
      )
    (when (!= (-> arg0 cur-pt) v1-0)
      (while (and (!= (-> this point v1-0 next) (-> arg0 cur-pt))
                  (!= (-> this point v1-0 next) (-> this next-to-last-point))
                  )
        (set! (-> this summed-len) (- (-> this summed-len) (-> this point v1-0 tp-length)))
        (+! (-> this point v1-0 incarnation) 1)
        (+! (-> this used-count) -1)
        (set! v1-0 (-> this point v1-0 next))
        )
      (set! (-> this summed-len) (- (-> this summed-len) (-> this point v1-0 tp-length)))
      (+! (-> this point v1-0 incarnation) 1)
      (+! (-> this used-count) -1)
      (set! (-> this point v1-0 next) (-> this free-point))
      (set! (-> this free-point) (-> this used-point))
      (set! (-> this used-point) (-> arg0 cur-pt))
      (cond
        ((= (-> arg0 cur-pt) (-> this end-point))
         (set! (-> this partial-point) 0.0)
         (set! (-> this summed-len) 0.0)
         )
        ((= (-> arg0 cur-pt) (-> this next-to-last-point))
         (set! (-> this summed-len) (-> this point (-> this next-to-last-point) tp-length))
         )
        )
      )
    )
  0
  (none)
  )

(defmethod tracking-spline-method-15 ((this tracking-spline))
  (let ((s5-0 (new 'stack-no-clear 'tracking-spline-sampler)))
    (let ((a2-0 (new 'stack-no-clear 'tracking-point)))
      (set! (-> s5-0 cur-pt) (-> this used-point))
      (set! (-> s5-0 partial-pt) (-> this partial-point))
      (tracking-spline-method-19 this (-> this sample-len) (the-as vector a2-0) s5-0)
      )
    (if (or (= (-> s5-0 cur-pt) (-> this end-point))
            (= (-> s5-0 cur-pt) (-> this next-to-last-point))
            (= (-> this point (-> s5-0 cur-pt) next) (-> this next-to-last-point))
            )
        (set! (-> s5-0 cur-pt) (-> this used-point))
        )
    (let ((v1-15 (-> this point (-> s5-0 cur-pt) next)))
      (when (!= v1-15 -134250495)
        (let ((a0-14 (-> this point v1-15 next))
              (a1-1 v1-15)
              (f0-2 -2.0)
              )
          0.0
          (while (not (or (= a0-14 -134250495) (= a0-14 (-> this end-point))))
            (let ((f1-2 (vector-dot
                          (the-as vector (+ (the-as uint (-> this point 0 direction)) (* 48 v1-15)))
                          (the-as vector (+ (the-as uint (the-as vector (-> this point 0 direction))) (* 48 a0-14)))
                          )
                        )
                  )
              (when (>= f1-2 f0-2)
                (set! f0-2 f1-2)
                (set! a1-1 v1-15)
                )
              )
            (set! v1-15 a0-14)
            (set! a0-14 (-> this point v1-15 next))
            )
          (if (< -2.0 f0-2)
              (tracking-spline-method-13 this a1-1)
              )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod tracking-spline-method-16 ((this tracking-spline) (arg0 float))
  (let ((s4-0 (new 'stack-no-clear 'tracking-spline-sampler)))
    (let ((a2-0 (new 'stack-no-clear 'vector)))
      (set! (-> s4-0 cur-pt) (-> this used-point))
      (set! (-> s4-0 partial-pt) (-> this partial-point))
      (tracking-spline-method-19 this (-> this sample-len) a2-0 s4-0)
      )
    (let ((s4-1 (-> this point (-> s4-0 cur-pt) next)))
      (when (!= s4-1 -134250495)
        (let ((v1-11 (-> this point s4-1 next)))
          (while (not (or (= v1-11 -134250495)
                          (= (-> this point v1-11 next) -134250495)
                          (= (-> this point v1-11 next) (-> this end-point))
                          (= (-> this point v1-11 next) (-> this next-to-last-point))
                          )
                      )
            (if (< (* (-> this point s4-1 tp-length)
                      (+ 1.0 (vector-dot
                               (the-as vector (+ (the-as uint (-> this point 0 direction)) (* 48 s4-1)))
                               (the-as vector (+ (the-as uint (the-as vector (-> this point 0 direction))) (* 48 v1-11)))
                               )
                         )
                      )
                   arg0
                   )
                (tracking-spline-method-13 this s4-1)
                (set! s4-1 v1-11)
                )
            (set! v1-11 (-> this point s4-1 next))
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod tracking-spline-method-17 ((this tracking-spline) (arg0 vector) (arg1 float) (arg2 float) (arg3 symbol))
  (let ((s3-0 (-> this free-point))
        (s2-0 (-> this end-point))
        )
    (vector-!
      (the-as vector (+ (the-as uint (-> this point 0 direction)) (* 48 s2-0)))
      arg0
      (the-as vector (-> this point s2-0))
      )
    (set! (-> this point s2-0 tp-length)
          (vector-normalize-ret-len! (the-as vector (+ (the-as uint (-> this point 0 direction)) (* 48 s2-0))) 1.0)
          )
    (if (< (-> this point s2-0 tp-length) arg1)
        (return 0)
        )
    (when (and arg3 (= s3-0 -134250495))
      (tracking-spline-method-15 this)
      (set! s3-0 (-> this free-point))
      )
    (cond
      ((= s3-0 -134250495)
       (format 0 "ERROR <GMJ>: pos spline overflow~%")
       )
      (else
        (+! (-> this summed-len) (-> this point s2-0 tp-length))
        (set! (-> this free-point) (-> this point s3-0 next))
        (set! (-> this point s2-0 next) s3-0)
        (set! (-> this end-point) s3-0)
        (set! (-> this next-to-last-point) s2-0)
        (set! (-> this point s3-0 next) -134250495)
        (set! (-> this point s3-0 position quad) (-> arg0 quad))
        (+! (-> this used-count) 1)
        (if (< 0.0 arg2)
            (tracking-spline-method-16 this arg2)
            )
        )
      )
    )
  0
  )

(defmethod tracking-spline-method-18 ((this tracking-spline) (arg0 float) (arg1 vector) (arg2 tracking-spline-sampler))
  (local-vars (f0-4 float))
  (when (not arg2)
    (set! arg2 (new 'stack-no-clear 'tracking-spline-sampler))
    (set! (-> arg2 cur-pt) (-> this used-point))
    (set! (-> arg2 partial-pt) (-> this partial-point))
    )
  0.0
  (loop
    (cond
      ((= (-> arg2 cur-pt) (-> this end-point))
       (set! (-> arg2 partial-pt) 0.0)
       (vector+! arg1 arg1 (the-as vector (-> this point (-> arg2 cur-pt))))
       (return arg1)
       )
      ((begin (set! f0-4 (+ (-> arg2 partial-pt) (/ arg0 (-> this point (-> arg2 cur-pt) tp-length)))) (< f0-4 1.0))
       (set! (-> arg2 partial-pt) f0-4)
       (let ((s5-0 (new 'stack-no-clear 'tracking-spline-sampler)))
         (let ((a2-5 (-> this point (-> arg2 cur-pt) next)))
           (vector-lerp!
             (the-as vector s5-0)
             (the-as vector (-> this point (-> arg2 cur-pt)))
             (the-as vector (-> this point a2-5))
             f0-4
             )
           )
         (vector+! arg1 arg1 (the-as vector s5-0))
         )
       (return arg1)
       )
      (else
        (let ((f0-7 (* (- 1.0 (-> arg2 partial-pt)) (-> this point (-> arg2 cur-pt) tp-length))))
          (set! arg0 (- arg0 f0-7))
          )
        (set! (-> arg2 partial-pt) 0.0)
        (set! (-> arg2 cur-pt) (-> this point (-> arg2 cur-pt) next))
        )
      )
    )
  (the-as vector #f)
  )

(defmethod tracking-spline-method-19 ((this tracking-spline) (arg0 float) (arg1 vector) (arg2 tracking-spline-sampler))
  (vector-reset! arg1)
  (tracking-spline-method-18 this arg0 arg1 arg2)
  arg1
  )

(defmethod tracking-spline-method-20 ((this tracking-spline) (arg0 vector) (arg1 int))
  (let ((s3-0 (new 'stack-no-clear 'vector)))
    (vector-!
      s3-0
      (the-as vector (-> this point (-> this used-point)))
      (the-as vector (-> this point (-> this end-point)))
      )
    (let* ((f0-0 (vector-length s3-0))
           (f1-1 (* 0.33333334 (- 1.5 (* 0.00024414062 f0-0))))
           )
      0.0
      (let* ((f1-2 (fmax 0.0 f1-1))
             (f30-0 (+ 0.3 f1-2))
             (f0-1 (cond
                     ((< (-> *CAMERA-bank* min-detectable-velocity) (-> this summed-len))
                      (vector-float*! s3-0 s3-0 (/ 1.0 f0-0))
                      (/ f0-0 (-> this summed-len))
                      )
                     (else
                       (vector-reset! s3-0)
                       0.0
                       )
                     )
                   )
             (f0-2 (+ -0.2 f0-1))
             (f1-9 (* 2.0 f0-2))
             (f28-0 (fmin 1.0 (fmax 0.05 f1-9)))
             (v1-8 (-> this used-point))
             (s2-0 (new 'stack-no-clear 'vector))
             )
        (while (and (!= v1-8 (-> this end-point)) (!= v1-8 (-> this next-to-last-point)) (!= v1-8 arg1))
          (let ((s1-0 (-> this point v1-8 next)))
            (vector-!
              s2-0
              (the-as vector (+ (the-as uint (-> this point 0 direction)) (* 48 s1-0)))
              (the-as vector (+ (the-as uint (-> this point 0 direction)) (* 48 v1-8)))
              )
            (let* ((f0-4 (vector-normalize-ret-len! s2-0 1.0))
                   (f0-5 (* 0.5 f0-4))
                   (f26-0 (* (fmin 1.0 f0-5) f30-0 (vector-dot arg0 s2-0)))
                   )
              (let ((f2-7 (vector-dot s2-0 s3-0)))
                (cond
                  ((>= 0.0 f2-7)
                   )
                  (else
                    (set! f26-0 (* f26-0 (fmax 0.0 (- 0.75 (fabs (* f28-0 f2-7))))))
                    )
                  )
                )
              (cond
                ((< f26-0 0.0)
                 (if (and *debug-segment* *display-camera-marks*)
                     (camera-line-rel-len
                       (the-as vector (-> this point s1-0))
                       s2-0
                       (* -40.96 f26-0)
                       (the-as vector4w (new 'static 'inline-array qword 1
                                          (new 'static 'qword :data (new 'static 'array uint32 4 #xff #xff #x0 #x80))
                                          )
                               )
                       )
                     )
                 (vector--float*! arg0 arg0 s2-0 f26-0)
                 )
                ((and *debug-segment* *display-camera-marks*)
                 (camera-line-rel-len
                   (the-as vector (-> this point s1-0))
                   s2-0
                   (* 40.96 f26-0)
                   (the-as vector4w (new 'static 'inline-array qword 1
                                      (new 'static 'qword :data (new 'static 'array uint32 4 #x80 #x80 #x0 #x80))
                                      )
                           )
                   )
                 )
                )
              )
            (set! v1-8 s1-0)
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod tracking-spline-method-21 ((this tracking-spline) (arg0 vector) (arg1 float) (arg2 float))
  (let ((v1-0 (-> this used-point))
        (f0-0 (-> this partial-point))
        )
    (let ((f1-0 (-> this summed-len)))
      0.0
      0.0
      (let* ((f1-1 (- f1-0 (* f0-0 (-> this point v1-0 tp-length))))
             (f2-5 (* 0.1 f1-1))
             (f2-8 (* (fmin arg1 (- f2-5 (-> this max-move))) (-> *display* time-adjust-ratio)))
             )
        (set! (-> this max-move) (fmin arg2 (+ (-> this max-move) f2-8)))
        )
      )
    (set! (-> this max-move) (fmax 0.4096 (-> this max-move)))
    (let ((f1-8 (-> this summed-len)))
      0.0
      (let* ((f2-14 (- f1-8 (* f0-0 (-> this point v1-0 tp-length))))
             (f2-16 (fmin 204.8 (- f2-14 (-> this sample-len))))
             )
        (set! (-> this sample-len) (fmin 16384.0 (+ (-> this sample-len) f2-16)))
        )
      )
    (let ((s4-0 (new 'stack-no-clear 'tracking-spline-sampler)))
      (set! (-> s4-0 cur-pt) v1-0)
      (set! (-> s4-0 partial-pt) f0-0)
      (tracking-spline-method-19 this (* (-> this max-move) (-> *display* time-adjust-ratio)) arg0 s4-0)
      (tracking-spline-method-14 this s4-0)
      (dotimes (s3-0 63)
        (tracking-spline-method-18 this (* 0.015625 (-> this sample-len)) arg0 s4-0)
        )
      (vector-float*! arg0 arg0 0.015625)
      (let ((a2-3 (-> s4-0 cur-pt)))
        (set! (-> this debug-last-point) a2-3)
        (let ((s4-1 (new 'stack-no-clear 'vector)))
          (set! (-> this debug-old-position quad) (-> this old-position quad))
          (set! (-> this debug-out-position quad) (-> arg0 quad))
          (vector-! s4-1 arg0 (-> this old-position))
          (tracking-spline-method-20 this s4-1 a2-3)
          (vector+! arg0 (-> this old-position) s4-1)
          )
        )
      )
    )
  (set! (-> this old-position quad) (-> arg0 quad))
  arg0
  )

(defmethod tracking-spline-method-22 ((this tracking-spline) (arg0 float))
  (when (< arg0 (-> this summed-len))
    (let ((s5-0 (new 'stack-no-clear 'tracking-spline-sampler)))
      (let ((a2-0 (new 'stack-no-clear 'vector)))
        (set! (-> s5-0 cur-pt) (-> this used-point))
        (set! (-> s5-0 partial-pt) 0.0)
        (tracking-spline-method-19 this (- (-> this summed-len) arg0) a2-0 s5-0)
        )
      (tracking-spline-method-14 this s5-0)
      )
    )
  0
  (none)
  )

(defmethod tracking-spline-method-9 ((this tracking-spline))
  (let ((v1-0 (-> this used-point))
        (s4-0 0)
        (s5-0 0)
        )
    (while (!= v1-0 -134250495)
      (set! s5-0 (logior s5-0 (ash 1 v1-0)))
      (+! s4-0 1)
      (set! v1-0 (-> this point v1-0 next))
      )
    (when (!= s4-0 (-> this used-count))
      (if *debug-segment*
          (format 0 "ERROR<GMJ>: tracking spline used count ~D actual ~D~%" (-> this used-count) s4-0)
          )
      (set! (-> this used-count) s4-0)
      )
    (let ((v1-9 (-> this free-point))
          (a3-1 0)
          )
      (while (!= v1-9 -134250495)
        (+! a3-1 1)
        (set! v1-9 (-> this point v1-9 next))
        )
      (when (!= a3-1 (- 32 (-> this used-count)))
        (if *debug-segment*
            (format 0 "ERROR<GMJ>: tracking spline free count ~D actual ~D~%" (- 32 (-> this used-count)) a3-1)
            )
        (set! (-> this free-point) -134250495)
        (dotimes (v1-21 32)
          (when (not (logtest? s5-0 1))
            (set! (-> this point v1-21 next) (-> this free-point))
            (set! (-> this free-point) v1-21)
            )
          (set! s5-0 (shr s5-0 1))
          )
        )
      )
    )
  0
  (none)
  )

(defbehavior cam-slave-init-vars camera-slave ()
  (cond
    (*camera*
      (set! (-> self options) (-> *camera* slave-options))
      (set! (-> self change-event-from) (the-as (pointer process-drawable) (-> *camera* changer)))
      )
    (else
      (set! (-> self options) (the-as uint 0))
      (set! (-> self change-event-from) (the-as (pointer process-drawable) #f))
      )
    )
  (cond
    (*camera-combiner*
      (set! (-> self trans quad) (-> *camera-combiner* trans quad))
      (let* ((v1-9 (-> self tracking))
             (a3-0 (-> *camera-combiner* inv-camera-rot))
             (a0-1 (-> a3-0 vector 0 quad))
             (a1-0 (-> a3-0 vector 1 quad))
             (a2-0 (-> a3-0 vector 2 quad))
             (a3-1 (-> a3-0 vector 3 quad))
             )
        (set! (-> v1-9 inv-mat vector 0 quad) a0-1)
        (set! (-> v1-9 inv-mat vector 1 quad) a1-0)
        (set! (-> v1-9 inv-mat vector 2 quad) a2-0)
        (set! (-> v1-9 inv-mat vector 3 quad) a3-1)
        )
      (when *camera-init-mat*
        (let* ((a2-1 (-> self tracking))
               (a3-2 *camera-init-mat*)
               (v1-12 (-> a3-2 vector 0 quad))
               (a0-2 (-> a3-2 vector 1 quad))
               (a1-1 (-> a3-2 vector 2 quad))
               (a3-3 (-> a3-2 vector 3 quad))
               )
          (set! (-> a2-1 inv-mat vector 0 quad) v1-12)
          (set! (-> a2-1 inv-mat vector 1 quad) a0-2)
          (set! (-> a2-1 inv-mat vector 2 quad) a1-1)
          (set! (-> a2-1 inv-mat vector 3 quad) a3-3)
          )
        )
      (set! (-> self fov) (-> *camera-combiner* fov))
      (set! (-> self velocity quad) (-> *camera-combiner* velocity quad))
      )
    (else
      (vector-reset! (-> self trans))
      (matrix-identity! (the-as matrix (-> self tracking)))
      (set! (-> self fov) 11650.845)
      (vector-reset! (-> self velocity))
      )
    )
  (set! (-> self time-dist-too-far) (the-as uint 0))
  (set! (-> self intro-t) 1.0)
  (set! (-> self intro-t-step) 0.0)
  (set! (-> self spline-exists) #f)
  (set! (-> self los-state) (slave-los-state none))
  (set! (-> self enter-has-run) #f)
  (set! (-> self cam-entity) #f)
  (set! (-> self tracking no-follow) #f)
  (init-cam-float-seeker
    (-> self tracking tilt-adjust)
    (-> *CAMERA-bank* default-tilt-adjust)
    9.102222
    91.022224
    0.25
    )
  (set! (-> self tracking follow-blend) 1.0)
  (set! (-> self have-phony-joystick) #f)
  (set! (-> self string-val-locked) #f)
  (init-cam-float-seeker (-> self tracking point-of-interest-blend) 0.0 0.005 0.02 0.125)
  (init-cam-float-seeker (-> self tracking underwater-blend) 0.0 0.007 0.03 0.125)
  (set! (-> self tracking use-point-of-interest) #f)
  (tracking-spline-method-10 (-> self position-spline) (-> self trans))
  (none)
  )

(defun cam-slave-go ((arg0 state))
  (with-pp
    (cam-slave-init-vars)
    (let ((t9-1 (the-as (function object) enter-state)))
      (set! (-> pp next-state) arg0)
      (t9-1)
      )
    0
    (none)
    )
  )

(defbehavior cam-slave-init camera-slave ((arg0 state) (arg1 entity))
  (stack-size-set! (-> self main-thread) 512)
  (change-to-last-brother self)
  (if (and (nonzero? camera-slave-debug) *debug-segment*)
      (add-connection *debug-engine* self camera-slave-debug self #f #f)
      )
  (cam-slave-init-vars)
  (let ((v1-7 'cam-voicebox)
        (a0-4 (the-as basic (-> arg0 name)))
        )
    (cond
      ((= (the-as symbol a0-4) v1-7)
       )
      (arg1
        (set! (-> self cam-entity) arg1)
        )
      (else
        (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-3 from) self)
          (set! (-> a1-3 num-params) 1)
          (set! (-> a1-3 message) 'slave-activated)
          (set! (-> a1-3 param 0) (the-as uint self))
          (let ((t9-4 send-event-function))
            (set! a0-4 *camera*)
            (t9-4 (the-as camera-master a0-4) a1-3)
            )
          )
        )
      )
    (let ((t9-5 (the-as (function object object) (-> arg0 enter))))
      (if t9-5
          (t9-5 (the-as symbol a0-4))
          )
      )
    (set! (-> self enter-has-run) #t)
    (set! (-> self event-hook) (-> arg0 event))
    (let ((t9-6 (the-as (function object object) enter-state)))
      (set! (-> self next-state) arg0)
      (t9-6 (the-as symbol a0-4))
      )
    )
  0
  (none)
  )

(defbehavior cam-standard-event-handler camera-slave ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('go)
     (let ((v1-1 (-> arg3 param 0))
           (t9-0 (the-as (function object) enter-state))
           )
       (set! (-> self next-state) (the-as state v1-1))
       (t9-0)
       )
     )
    (('change-state 'change-state-no-go)
     (let ((s5-0 (the-as object (-> arg3 param 0))))
       (cam-slave-init-vars)
       (let ((t9-2 (the-as (function object) (-> (the-as state s5-0) enter))))
         (if t9-2
             (t9-2)
             )
         )
       (set! (-> self enter-has-run) #t)
       (set! (-> self event-hook) (-> (the-as state s5-0) event))
       (when (= arg2 'change-state)
         (let ((t9-3 (the-as (function object) enter-state)))
           (set! (-> self next-state) (the-as state s5-0))
           (t9-3)
           )
         )
       )
     )
    (('point-of-interest)
     (cond
       ((-> arg3 param 0)
        (set! (-> self tracking use-point-of-interest) #t)
        (set! (-> self tracking point-of-interest quad) (-> (the-as vector (-> arg3 param 0)) quad))
        (set! (-> self tracking point-of-interest-blend target) 1.0)
        )
       (else
         (set! (-> self tracking use-point-of-interest) #f)
         (set! (-> self tracking point-of-interest-blend target) 0.0)
         )
       )
     )
    (('teleport)
     (cam-calc-follow! (-> self tracking) (-> self trans) #f)
     (slave-set-rotation! (-> self tracking) (-> self trans) (the-as float (-> self options)) (-> self fov) #f)
     )
    )
  )

(defbehavior cam-curve-pos camera-slave ((arg0 vector) (arg1 vector) (arg2 curve) (arg3 symbol))
  (let ((s5-0 (new-stack-vector0)))
    0.0
    (let ((s2-0 (new-stack-vector0)))
      (if arg1
          (set! (-> arg1 w) 0.0)
          )
      (when (< (-> self intro-t) 1.0)
        (+! (-> self intro-t) (* (-> self intro-t-step) (-> *display* time-adjust-ratio)))
        (if (< 1.0 (-> self intro-t))
            (set! (-> self intro-t) 1.0)
            )
        (curve-get-pos! s5-0 (parameter-ease-sin-clamp (-> self intro-t)) (-> self intro-curve))
        (vector+! s5-0 s5-0 (-> self intro-offset))
        (vector+! arg0 arg0 s5-0)
        (cond
          ((not arg1)
           )
          ((< (-> self intro-t) 0.5)
           (curve-get-pos! s2-0 (+ 0.0001 (parameter-ease-sin-clamp (-> self intro-t))) (-> self intro-curve))
           (vector+! s2-0 s2-0 (-> self intro-offset))
           (vector-! arg1 s2-0 s5-0)
           (set! (-> arg1 w) 1.0)
           )
          (else
            (curve-get-pos! s2-0 (+ -0.0001 (parameter-ease-sin-clamp (-> self intro-t))) (-> self intro-curve))
            (vector+! s2-0 s2-0 (-> self intro-offset))
            (vector-! arg1 s5-0 s2-0)
            (set! (-> arg1 w) 1.0)
            )
          )
        )
      )
    (cond
      ((not (-> self spline-exists))
       )
      ((= (-> self spline-follow-dist) 0.0)
       (let ((f0-18 (if arg3
                        (cam-index-method-10 (-> self index) (-> self tracking follow-pt))
                        (cam-index-method-10 (-> self index) (-> *camera* tpos-curr-adj))
                        )
                    )
             )
         (curve-get-pos! s5-0 f0-18 (-> self spline-curve))
         )
       (vector+! s5-0 s5-0 (-> self spline-offset))
       (vector+! arg0 arg0 s5-0)
       )
      (else
        (let ((s3-1 (new 'stack-no-clear 'vector)))
          (curve-length (-> self spline-curve))
          (if arg3
              (set! (-> s3-1 quad) (-> self tracking follow-pt quad))
              (set! (-> s3-1 quad) (-> *camera* tpos-curr-adj quad))
              )
          (set! (-> self spline-tt)
                (curve-closest-point (-> self spline-curve) s3-1 (-> self spline-tt) 1024.0 10 (-> self spline-follow-dist))
                )
          )
        (curve-get-pos! s5-0 (-> self spline-tt) (-> self spline-curve))
        (vector+! s5-0 s5-0 (-> self spline-offset))
        (vector+! arg0 arg0 s5-0)
        )
      )
    )
  arg0
  )

(defbehavior cam-curve-setup camera-slave ((arg0 vector))
  (when (get-curve-data! (-> self cam-entity) (-> self spline-curve) 'campath 'campath-k -1000000000.0)
    (curve-get-pos! (-> self spline-offset) 0.0 (-> self spline-curve))
    (vector-negate! (-> self spline-offset) (-> self spline-offset))
    (cam-index-method-9 (-> self index) 'campoints (-> self cam-entity) arg0 (-> self spline-curve))
    (set! (-> self spline-exists) #t)
    )
  (cond
    ((get-curve-data! (-> self cam-entity) (-> self intro-curve) 'intro 'intro-k -1000000000.0)
     (curve-get-pos! (-> self intro-offset) 1.0 (-> self intro-curve))
     (vector-negate! (-> self intro-offset) (-> self intro-offset))
     (set! (-> self intro-t) 0.0)
     (set! (-> self intro-t-step) (cam-slave-get-intro-step (-> self cam-entity)))
     (set! (-> self outro-exit-value) (cam-slave-get-float (-> self cam-entity) 'intro-exitValue 0.0))
     (if (= (-> self outro-exit-value) 0.0)
         (set! (-> self outro-exit-value) 0.5)
         )
     )
    (else
      (set! (-> self intro-t) 1.0)
      (set! (-> self intro-t-step) 0.0)
      )
    )
  (if (nonzero? (-> *camera* no-intro))
      (set! (-> self intro-t) 1.0)
      )
  0
  (none)
  )

(defun cam-calc-follow! ((arg0 cam-rotation-tracker) (arg1 vector) (arg2 symbol))
  (cond
    (arg2
      (update! (-> arg0 tilt-adjust) 0.0)
      (update! (-> arg0 point-of-interest-blend) 0.0)
      (update! (-> arg0 underwater-blend) 0.0)
      )
    (else
      (jump-to-target! (-> arg0 tilt-adjust) 0.0)
      (jump-to-target! (-> arg0 point-of-interest-blend) 0.0)
      (jump-to-target! (-> arg0 underwater-blend) 0.0)
      )
    )
  (cond
    ((send-event *camera* 'slave-option? #x4000)
     (let ((s3-0 (new 'stack-no-clear 'vector))
           (s2-0 (new 'stack-no-clear 'vector))
           (f30-0 (vector-vector-distance (-> *camera* tpos-curr-adj) (-> *camera* tpos-old-adj)))
           (s5-1 (new 'stack-no-clear 'vector))
           )
       (vector-flatten! s3-0 (-> *camera* tgt-face-mat vector 2) (-> *camera* local-down))
       (vector-normalize! s3-0 1.0)
       (vector-! s2-0 (-> *camera* tpos-curr-adj) arg1)
       (vector-flatten! s2-0 s2-0 (-> *camera* local-down))
       (vector-normalize! s2-0 1.0)
       (vector-float*! s5-1 (-> *camera* tgt-face-mat vector 2) 32768.0)
       (let* ((f30-1 (lerp-clamp 0.7 0.4 (parameter-ease-sin-clamp (* 0.00081380206 (+ -409.6 f30-0)))))
              (f0-4 (acos (vector-dot s2-0 s3-0)))
              (f28-0 (fmax 1820.4445 f0-4))
              )
         (if (< f28-0 8192.0)
             (vector-float*!
               s5-1
               s5-1
               (+ f30-1
                  (* (/ (- 1.0 f30-1) (- 1.0 (cos 32768.0))) (+ (- (cos 32768.0)) (cos (* 5.142857 (- 8192.0 f28-0)))))
                  )
               )
             )
         )
       (cond
         ((< (-> *camera* ease-t) 1.0)
          )
         ((< (-> arg0 follow-blend) 1.0)
          (let* ((f0-18 (-> arg0 follow-blend))
                 (f0-19 (* f0-18 f0-18))
                 (f0-20 (* f0-19 f0-19))
                 )
            (vector-! s5-1 s5-1 (-> arg0 follow-off))
            (vector-float*! s5-1 s5-1 f0-20)
            )
          (+! (-> arg0 follow-blend) (* 0.016666668 (-> *display* time-adjust-ratio)))
          (vector+! (-> arg0 follow-off) (-> arg0 follow-off) s5-1)
          )
         (else
           (set! (-> arg0 follow-off quad) (-> s5-1 quad))
           )
         )
       )
     (vector+! (-> arg0 follow-pt) (-> *camera* tpos-curr-adj) (-> arg0 follow-off))
     (vector--float*!
       (-> arg0 follow-pt)
       (-> arg0 follow-pt)
       (-> *camera* local-down)
       (+ 12288.0 (-> *camera* target-height))
       )
     )
    (else
      0.0
      (let ((s3-2 (new-stack-vector0)))
        (set! (-> arg0 follow-blend) 0.0)
        (cond
          ((-> arg0 no-follow)
           (vector-reset! s3-2)
           )
          (else
            (vector-! s3-2 (-> *camera* tpos-curr-adj) arg1)
            (vector-normalize! s3-2 1.0)
            (let* ((f0-28 (vector-dot (-> *camera* tgt-rot-mat vector 2) s3-2))
                   (f30-2 (cond
                            ((< f0-28 0.0)
                             1.0
                             )
                            (else
                              (let* ((f0-29 (* f0-28 f0-28))
                                     (f0-30 (- 1.0 f0-29))
                                     )
                                (* f0-30 (* f0-30 f0-30))
                                )
                              )
                            )
                          )
                   )
              (vector-! s3-2 arg1 (-> *camera* tpos-curr-adj))
              (vector-flatten! s3-2 s3-2 (-> *camera* local-down))
              (let* ((f0-33 (* 0.000022194603 (+ -20480.0 (vector-length s3-2))))
                     (f0-34 (fmin 1.0 f0-33))
                     (f0-35 (fmax 0.0 f0-34))
                     )
                (vector-float*! s3-2 (-> *camera* tgt-rot-mat vector 2) (* (lerp 2048.0 8192.0 f0-35) f30-2))
                )
              )
            )
          )
        (if arg2
            (vector-seek-3d-smooth! (-> arg0 follow-off) s3-2 (* 20480.0 (seconds-per-frame)) 0.05)
            (set! (-> arg0 follow-off quad) (-> s3-2 quad))
            )
        )
      (vector+! (-> arg0 follow-pt) (-> *camera* tpos-curr-adj) (-> arg0 follow-off))
      (vector--float*! (-> arg0 follow-pt) (-> arg0 follow-pt) (-> *camera* local-down) (-> *camera* target-height))
      )
    )
  (-> arg0 follow-pt)
  )

(defun mat-remove-z-rot ((arg0 matrix) (arg1 vector))
  (let ((s4-0 (new-stack-vector0)))
    0.0
    0.0
    (let ((s5-0 (new-stack-matrix0)))
      (vector-negate! s4-0 arg1)
      (vector-flatten! s4-0 s4-0 (-> arg0 vector 2))
      (vector-normalize! s4-0 1.0)
      (let ((f30-0 (vector-dot (-> arg0 vector 1) s4-0)))
        (when (< f30-0 0.99999)
          (vector-cross! s4-0 (-> arg0 vector 1) s4-0)
          (let ((f0-4 (vector-length s4-0)))
            (if (< 0.0 (vector-dot s4-0 (-> arg0 vector 2)))
                (set! f0-4 (- f0-4))
                )
            (matrix-axis-sin-cos! s5-0 (-> arg0 vector 2) f0-4 f30-0)
            )
          (matrix*! arg0 arg0 s5-0)
          )
        )
      )
    )
  arg0
  )

(defun slave-matrix-blend-2 ((arg0 matrix) (arg1 float) (arg2 vector) (arg3 matrix))
  (let ((s1-0 (new-stack-vector0))
        (s4-0 (new-stack-quaternion0))
        )
    (let ((s2-0 (new-stack-quaternion0))
          (gp-0 (new-stack-quaternion0))
          )
      0.0
      (let* ((f0-1 (cond
                     ((logtest? (the-as int arg1) 4)
                      (vector-length arg2)
                      )
                     (else
                       (vector-flatten! s1-0 arg2 (-> *camera* local-down))
                       (vector-length s1-0)
                       )
                     )
                   )
             (f0-3 (* 0.00048828125 (+ -1024.0 f0-1)))
             )
        (cond
          ((< f0-3 0.0)
           (set! f0-3 0.0)
           )
          ((< 1.0 f0-3)
           (set! f0-3 1.0)
           )
          )
        (let ((f30-0 (* 364.0889 (-> *display* time-adjust-ratio) f0-3)))
          (matrix->quaternion s4-0 arg0)
          (matrix->quaternion s2-0 arg3)
          (quaternion-conjugate! gp-0 s4-0)
          (quaternion*! gp-0 gp-0 s2-0)
          (quaternion-normalize! gp-0)
          (if (< (-> gp-0 w) 0.0)
              (quaternion-negate! gp-0 gp-0)
              )
          (let ((f28-0 (acos (-> gp-0 w))))
            (if (< (* 0.25 (-> *display* time-adjust-ratio) f28-0) f30-0)
                (set! f30-0 (* 0.25 (-> *display* time-adjust-ratio) f28-0))
                )
            (cond
              ((< (-> gp-0 w) 0.9999999)
               (quaternion-float*! gp-0 gp-0 (/ (sin f30-0) (sin f28-0)))
               (set! (-> gp-0 w) (cos f30-0))
               )
              (else
                (quaternion-identity! gp-0)
                )
              )
            )
          )
        )
      (quaternion*! s4-0 s4-0 gp-0)
      )
    (quaternion-normalize! s4-0)
    (quaternion->matrix arg0 s4-0)
    )
  )

(defun vector-into-frustum-nosmooth! ((arg0 matrix) (arg1 vector) (arg2 float))
  (local-vars (sv-112 (inline-array vector)) (sv-128 vector) (sv-144 vector) (sv-160 vector) (sv-176 vector))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (new-stack-matrix0)))
      (let ((s3-0 (new-stack-vector0))
            (s2-0 (new-stack-vector0))
            )
        0.0
        0.0
        (let ((f30-0 1.0)
              (s4-0 #t)
              )
          (vector-! s3-0 (-> *camera* tpos-curr) arg1)
          (vector-flatten! s3-0 s3-0 (-> arg0 vector 1))
          (vector-normalize! s3-0 1.0)
          (let ((f28-0 (vector-dot s3-0 (the-as vector (-> arg0 vector)))))
            (set! sv-128 s2-0)
            (set! sv-112 (-> arg0 vector))
            (let ((f0-6 (* 0.8 (tan (* 0.5 arg2)))))
              (.lvf vf1 (&-> sv-112 0 quad))
              (let ((v1-6 f0-6))
                (.mov vf2 v1-6)
                )
              )
            (.add.x.vf vf1 vf0 vf0 :mask #b1000)
            (.mul.x.vf vf1 vf1 vf2 :mask #b111)
            (.svf (&-> sv-128 quad) vf1)
            (vector+! s2-0 s2-0 (-> arg0 vector 2))
            (vector-normalize! s2-0 1.0)
            (let ((f0-8 (vector-dot s2-0 (the-as vector (-> arg0 vector)))))
              (when (< f0-8 (fabs f28-0))
                (if (< f28-0 0.0)
                    (vector--float*! s2-0 s2-0 (the-as vector (-> arg0 vector)) (* 2.0 f0-8))
                    )
                (matrix-from-two-vectors! s5-0 s2-0 s3-0)
                (vector-matrix*! (-> arg0 vector 2) (-> arg0 vector 2) s5-0)
                (vector-cross! (the-as vector (-> arg0 vector)) (-> arg0 vector 1) (-> arg0 vector 2))
                )
              )
            )
          (vector-! s3-0 (-> *camera* tpos-curr) (-> *camera* pitch-off))
          (vector-! s3-0 s3-0 arg1)
          (vector--float*! s3-0 s3-0 (-> *camera* local-down) (-> *camera* foot-offset))
          (vector-flatten! s3-0 s3-0 (the-as vector (-> arg0 vector)))
          (vector-normalize! s3-0 1.0)
          (let ((f28-1 (vector-dot s3-0 (-> arg0 vector 1))))
            (set! sv-160 s2-0)
            (set! sv-144 (-> arg0 vector 1))
            (let ((f0-15 (* 0.525 (tan (* 0.5 arg2)))))
              (.lvf vf1 (&-> sv-144 quad))
              (let ((v1-23 f0-15))
                (.mov vf2 v1-23)
                )
              )
            (.add.x.vf vf1 vf0 vf0 :mask #b1000)
            (.mul.x.vf vf1 vf1 vf2 :mask #b111)
            (.svf (&-> sv-160 quad) vf1)
            (vector+! s2-0 s2-0 (-> arg0 vector 2))
            (vector-normalize! s2-0 1.0)
            (let ((f0-17 (vector-dot s2-0 (-> arg0 vector 1))))
              (when (and (< f28-1 0.0) (< f0-17 (- f28-1)))
                (vector--float*! s2-0 s2-0 (-> arg0 vector 1) (* 2.0 f0-17))
                (set! f30-0 (vector-dot s2-0 s3-0))
                )
              )
            )
          (vector-! s3-0 (-> *camera* tpos-curr) (-> *camera* pitch-off))
          (vector-! s3-0 s3-0 arg1)
          (vector--float*! s3-0 s3-0 (-> *camera* local-down) (-> *camera* head-offset))
          (vector-flatten! s3-0 s3-0 (the-as vector (-> arg0 vector)))
          (vector-normalize! s3-0 1.0)
          (let ((f28-2 (vector-dot s3-0 (-> arg0 vector 1))))
            (let ((s0-1 s2-0))
              (set! sv-176 (-> arg0 vector 1))
              (let ((f0-25 (* 0.525 (tan (* 0.5 arg2)))))
                (vector-float*! s0-1 sv-176 f0-25)
                )
              )
            (vector+! s2-0 s2-0 (-> arg0 vector 2))
            (vector-normalize! s2-0 1.0)
            (let ((f0-27 (vector-dot s2-0 (-> arg0 vector 1))))
              (cond
                ((and (< 0.0 f28-2) (< f0-27 f28-2))
                 (set! f30-0 (vector-dot s2-0 s3-0))
                 (set! s4-0 #f)
                 )
                ((< f30-0 0.0)
                 (let ((f0-32 (- (vector-dot s2-0 s3-0))))
                   (if (< f0-32 f30-0)
                       (set! f30-0 f0-32)
                       )
                   )
                 )
                )
              )
            )
          (let ((f0-34 (if s4-0
                           (- (acos f30-0))
                           (acos f30-0)
                           )
                       )
                )
            (matrix-axis-angle! s5-0 (the-as vector (-> arg0 vector)) f0-34)
            )
          )
        )
      (vector-matrix*! (-> arg0 vector 2) (-> arg0 vector 2) s5-0)
      )
    (vector-cross! (-> arg0 vector 1) (-> arg0 vector 2) (the-as vector (-> arg0 vector)))
    )
  )

;; ERROR: Unsupported inline assembly instruction kind - [mula.s f0, f3]
;; ERROR: Unsupported inline assembly instruction kind - [madda.s f1, f4]
;; ERROR: Unsupported inline assembly instruction kind - [madd.s f0, f2, f5]
(defun slave-set-rotation! ((arg0 cam-rotation-tracker) (arg1 vector) (arg2 float) (arg3 float) (arg4 symbol))
  (local-vars
    (f0-8 float)
    (sv-192 vector)
    (sv-208 vector)
    (sv-224 matrix)
    (sv-240 (function matrix vector float vector))
    (sv-256 matrix)
    )
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (let ((s1-0 (new-stack-vector0))
          (s5-0 (new-stack-matrix0))
          )
      (let ((f30-0 (-> arg0 tilt-adjust value)))
        (cond
          ((< 0.0001 (-> arg0 point-of-interest-blend value))
           (set! sv-192 (new 'stack-no-clear 'vector))
           0.0
           (vector-! s1-0 (-> arg0 follow-pt) arg1)
           (let ((f28-0 (vector-length s1-0)))
             (vector-! sv-192 (-> arg0 point-of-interest) arg1)
             (vector-normalize! sv-192 (* f28-0 (-> arg0 point-of-interest-blend value)))
             (let ((v1-3 s1-0))
               (let ((a0-5 s1-0))
                 (.mov.vf vf6 vf0 :mask #b1000)
                 (.lvf vf4 (&-> a0-5 quad))
                 )
               (.lvf vf5 (&-> sv-192 quad))
               (.add.vf vf6 vf4 vf5 :mask #b111)
               (.svf (&-> v1-3 quad) vf6)
               )
             (vector-normalize! s1-0 f28-0)
             )
           )
          (else
            (vector-! s1-0 (-> arg0 follow-pt) arg1)
            )
          )
        (forward-down->inv-matrix s5-0 s1-0 (-> *camera* local-down))
        (when (!= f30-0 0.0)
          0.0
          0.0
          (set! sv-224 (new 'stack-no-clear 'matrix))
          (set! sv-208 (new 'stack-no-clear 'vector))
          (vector-normalize-copy! sv-208 s1-0 1.0)
          (let* ((v1-11 (-> *camera* local-down))
                 (f0-7 (-> sv-208 x))
                 (f1-1 (-> sv-208 y))
                 (f2-0 (-> sv-208 z))
                 (f3-0 (-> v1-11 x))
                 (f4-0 (-> v1-11 y))
                 (f5-0 (-> v1-11 z))
                 )
            ;; og:preserve-this inlined vector-dot
            ; (.mula.s f0-7 f3-0)
            ; (.madda.s f1-1 f4-0)
            ; (.madd.s f0-8 f2-0 f5-0)
            (set! f0-8 (+ (* f0-7 f3-0) (* f1-1 f4-0) (* f2-0 f5-0)))
            )
          (let* ((f28-1 f0-8)
                 (f0-10 (acos (fabs f28-1)))
                 )
            (cond
              ((< 0.0 f30-0)
               (set! f30-0 (if (< 0.0 f28-1)
                               (fmin f30-0 (fmax 0.0 (+ -2730.6667 f0-10)))
                               (fmin f30-0 (fmax 0.0 (- 32768.0 (+ 2730.6667 f0-10))))
                               )
                     )
               )
              ((< f30-0 0.0)
               (set! f30-0 (if (< 0.0 f28-1)
                               (fmax f30-0 (- (fmax 0.0 (- 32768.0 (+ 2730.6667 f0-10)))))
                               (fmax f30-0 (- (fmax 0.0 (+ -2730.6667 f0-10))))
                               )
                     )
               )
              )
            )
          (matrix-rotate-x! sv-224 f30-0)
          (let ((t9-7 matrix*!)
                (a0-16 s5-0)
                (a2-3 s5-0)
                )
            (t9-7 a0-16 sv-224 a2-3)
            )
          )
        )
      (if (and (= (-> *camera* under-water) 2) *target* (!= (-> *target* next-state name) 'target-swim-up))
          (set! (-> arg0 underwater-blend target) 1.0)
          (set! (-> arg0 underwater-blend target) 0.0)
          )
      (set! sv-240 vector-into-frustum-nosmooth!)
      (set! sv-256 s5-0)
      (let ((a2-5 (lerp-clamp arg3 (* 0.25 arg3) (-> arg0 underwater-blend value))))
        (sv-240 sv-256 arg1 a2-5)
        )
      (cond
        (arg4
          (slave-matrix-blend-2 (-> arg0 inv-mat) arg2 s1-0 s5-0)
          )
        (else
          (let* ((v1-31 (-> arg0 inv-mat))
                 (a3-2 s5-0)
                 (a0-22 (-> a3-2 vector 0 quad))
                 (a1-16 (-> a3-2 vector 1 quad))
                 (a2-7 (-> a3-2 vector 2 quad))
                 (a3-3 (-> a3-2 vector 3 quad))
                 )
            (set! (-> v1-31 vector 0 quad) a0-22)
            (set! (-> v1-31 vector 1 quad) a1-16)
            (set! (-> v1-31 vector 2 quad) a2-7)
            (set! (-> v1-31 vector 3 quad) a3-3)
            )
          )
        )
      )
    (mat-remove-z-rot (-> arg0 inv-mat) (-> *camera* local-down))
    0
    (none)
    )
  )

;; ERROR: Unsupported inline assembly instruction kind - [mula.s f0, f3]
;; ERROR: Unsupported inline assembly instruction kind - [madda.s f1, f4]
;; ERROR: Unsupported inline assembly instruction kind - [madd.s f0, f2, f5]
(defun v-slrp2! ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 float) (arg4 vector) (arg5 float))
  (local-vars
    (f0-10 float)
    (f28-0 float)
    (f30-0 float)
    (sv-144 float)
    (sv-160 vector)
    (sv-176 matrix)
    (sv-192 vector)
    )
  (set! sv-144 arg5)
  (let ((s0-0 (new-stack-vector0)))
    (set! sv-160 (new 'stack-no-clear 'vector))
    (set! (-> sv-160 quad) (the-as uint128 0))
    1.0
    1.0
    (let ((s3-0 (new-stack-vector0)))
      0.0
      1.0
      (set! sv-176 (new 'stack-no-clear 'matrix))
      (set! (-> sv-176 vector 0 quad) (the-as uint128 0))
      (set! (-> sv-176 vector 1 quad) (the-as uint128 0))
      (set! (-> sv-176 vector 2 quad) (the-as uint128 0))
      (set! (-> sv-176 vector 3 quad) (the-as uint128 0))
      (cond
        ((< 1.0 arg3)
         (set! arg3 1.0)
         )
        ((< arg3 0.0)
         (set! arg3 0.0)
         )
        )
      (cond
        (arg4
          (vector-flatten! s0-0 arg1 arg4)
          (vector-flatten! sv-160 arg2 arg4)
          (set! f30-0 (vector-normalize-ret-len! s0-0 1.0))
          (set! f28-0 (vector-normalize-ret-len! sv-160 1.0))
          (vector-normalize! (vector-cross! s3-0 sv-160 s0-0) 1.0)
          (let ((f26-0 (vector-dot arg4 s3-0)))
            (vector-normalize-copy! s3-0 arg4 1.0)
            (if (< f26-0 0.0)
                (vector-negate! s3-0 s3-0)
                )
            )
          )
        (else
          (set! (-> s0-0 quad) (-> arg1 quad))
          (set! (-> sv-160 quad) (-> arg2 quad))
          (set! f30-0 (vector-normalize-ret-len! s0-0 1.0))
          (set! f28-0 (vector-normalize-ret-len! sv-160 1.0))
          (vector-normalize! (vector-cross! s3-0 arg2 arg1) 1.0)
          )
        )
      (let ((t9-10 acos))
        (let* ((v1-18 s0-0)
               (f0-9 (-> v1-18 x))
               (f1-2 (-> v1-18 y))
               (f2-0 (-> v1-18 z))
               (f3-0 (-> sv-160 x))
               (f4-0 (-> sv-160 y))
               (f5-0 (-> sv-160 z))
               )
          ;; og:preserve-this inlined vector-dot
          ; (.mula.s f0-9 f3-0)
          ; (.madda.s f1-2 f4-0)
          ; (.madd.s f0-10 f2-0 f5-0)
          (set! f0-10 (+ (* f2-0 f5-0) (* f1-2 f4-0) (* f0-9 f3-0))) 
          )
        (let* ((f1-3 (t9-10 f0-10))
               (f0-12 (* arg3 f1-3))
               )
          (when (< sv-144 f0-12)
            (set! f0-12 sv-144)
            (set! arg3 (/ sv-144 f1-3))
            )
          (let* ((f0-13 (cos f0-12))
                 (t9-12 matrix-axis-sin-cos!)
                 (a0-20 sv-176)
                 (a1-13 s3-0)
                 (f1-5 1.0)
                 (f2-3 f0-13)
                 )
            (t9-12 a0-20 a1-13 (sqrtf (- f1-5 (* f2-3 f2-3))) f0-13)
            )
          )
        )
      (vector-matrix*! arg0 s0-0 sv-176)
      (let ((s0-1 vector-normalize!))
        (set! sv-192 arg0)
        (let ((a1-16 (lerp f30-0 f28-0 arg3)))
          (s0-1 sv-192 a1-16)
          )
        )
      (when arg4
        (vector+float*! arg0 arg0 s3-0 (vector-dot arg1 s3-0))
        (vector+float*! arg0 arg0 s3-0 (* arg3 (vector-dot (vector-! (new-stack-vector0) arg2 arg1) s3-0)))
        )
      )
    )
  arg0
  )

;; ERROR: Unsupported inline assembly instruction kind - [mula.s f0, f3]
;; ERROR: Unsupported inline assembly instruction kind - [madda.s f1, f4]
;; ERROR: Unsupported inline assembly instruction kind - [madd.s f0, f2, f5]
(defun v-slrp3! ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 vector) (arg4 float))
  (local-vars (f0-7 float) (f26-0 float) (f28-0 float) (sv-144 float) (sv-160 vector))
  (set! sv-144 arg4)
  (let ((s1-0 (new-stack-vector0)))
    (set! sv-160 (new 'stack-no-clear 'vector))
    (set! (-> sv-160 quad) (the-as uint128 0))
    0.0
    0.0
    (let ((s3-0 (new-stack-vector0))
          (f30-0 1.0)
          )
      0.0
      (let ((s0-0 (new-stack-matrix0)))
        (cond
          (arg3
            (vector-flatten! s1-0 arg1 arg3)
            (vector-flatten! sv-160 arg2 arg3)
            (set! f28-0 (vector-normalize-ret-len! s1-0 1.0))
            (set! f26-0 (vector-normalize-ret-len! sv-160 1.0))
            (vector-normalize! (vector-cross! s3-0 sv-160 s1-0) 1.0)
            (let ((f24-0 (vector-dot arg3 s3-0)))
              (vector-normalize-copy! s3-0 arg3 1.0)
              (if (< f24-0 0.0)
                  (vector-negate! s3-0 s3-0)
                  )
              )
            )
          (else
            (set! (-> s1-0 quad) (-> arg1 quad))
            (set! (-> sv-160 quad) (-> arg2 quad))
            (set! f28-0 (vector-normalize-ret-len! s1-0 1.0))
            (set! f26-0 (vector-normalize-ret-len! sv-160 1.0))
            (vector-normalize! (vector-cross! s3-0 arg2 arg1) 1.0)
            )
          )
        (let ((t9-10 acos))
          (let* ((v1-9 s1-0)
                 (f0-6 (-> v1-9 x))
                 (f1-0 (-> v1-9 y))
                 (f2-0 (-> v1-9 z))
                 (f3-0 (-> sv-160 x))
                 (f4-0 (-> sv-160 y))
                 (f5-0 (-> sv-160 z))
                 )
            ;; og:preserve-this inlined vector-dot
            ; (.mula.s f0-6 f3-0)
            ; (.madda.s f1-0 f4-0)
            ; (.madd.s f0-7 f2-0 f5-0)
            (set! f0-7 (+ (* f0-6 f3-0) (* f1-0 f4-0) (* f2-0 f5-0)))
            )
          (let ((f0-8 (t9-10 f0-7)))
            (when (< sv-144 f0-8)
              (set! f30-0 (/ sv-144 f0-8))
              (set! f0-8 sv-144)
              )
            (let* ((f0-9 (cos f0-8))
                   (t9-12 matrix-axis-sin-cos!)
                   (a0-20 s0-0)
                   (a1-13 s3-0)
                   (f1-3 1.0)
                   (f2-1 f0-9)
                   )
              (t9-12 a0-20 a1-13 (sqrtf (- f1-3 (* f2-1 f2-1))) f0-9)
              )
            )
          )
        (vector-matrix*! arg0 s1-0 s0-0)
        )
      (vector-normalize! arg0 (lerp f28-0 f26-0 f30-0))
      (when arg3
        (vector+float*! arg0 arg0 s3-0 (vector-dot arg1 s3-0))
        (vector+float*! arg0 arg0 s3-0 (* f30-0 (vector-dot (vector-! (new-stack-vector0) arg2 arg1) s3-0)))
        )
      )
    )
  arg0
  )
