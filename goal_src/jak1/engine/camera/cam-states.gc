;;-*-Lisp-*-
(in-package goal)

;; name: cam-states.gc
;; name in dgo: cam-states
;; dgos: GAME, ENGINE
;; note: changed for high fps


;; DECOMP BEGINS

(defstate cam-fixed (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('teleport)
       #f
       )
      (else
        (cam-standard-event-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self saved-pt quad) (-> self trans quad))
      (set! (-> self blend-from-type) (the-as uint 1))
      (set! (-> self blend-to-type) (the-as uint 0))
      0
      )
    (none)
    )
  :code (behavior ()
    (loop
      (when (not (paused?))
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (set! (-> self trans quad) (-> self saved-pt quad))
          (cam-curve-pos (-> self trans) gp-0 (the-as curve #f) #f)
          (when (!= (-> gp-0 w) 0.0)
            (vector-normalize! gp-0 (the-as float 1.0))
            (forward-down->inv-matrix (the-as matrix (-> self tracking)) gp-0 (-> *camera* local-down))
            )
          )
        )
      (suspend)
      )
    (none)
    )
  )

(defstate cam-fixed-read-entity (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('teleport)
       #f
       )
      (else
        (cam-standard-event-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (cond
      ((-> self enter-has-run)
       )
      ((-> self cam-entity)
       (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) (-> self trans) 'trans)
       (cam-slave-get-rot (the-as entity-actor (-> self cam-entity)) (the-as matrix (-> self tracking)))
       (set! (-> self fov) (cam-slave-get-fov (-> self cam-entity)))
       (cam-curve-setup (-> self trans))
       ((-> cam-fixed enter))
       )
      (else
        (format #t "ERROR <GMJ>: cam-fixed-read-entity enter without entity~%")
        )
      )
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (if (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) gp-0 'interesting)
          (send-event *camera* 'point-of-interest gp-0)
          )
      )
    (go cam-fixed)
    (none)
    )
  :code (behavior ()
    (loop
      (format *stdcon* "ERROR <GMJ>: stayed in cam-fixed-read-entity~%")
      (suspend)
      )
    (none)
    )
  )

(defstate cam-pov (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('teleport)
       #f
       )
      (else
        (cam-standard-event-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self blend-from-type) (the-as uint 1))
      (set! (-> self blend-to-type) (the-as uint 1))
      )
    (none)
    )
  :trans (behavior ()
    (when (not (handle->process (-> *camera* pov-handle)))
      (set! (-> self blend-from-type) (the-as uint 0))
      (cam-slave-go cam-fixed)
      )
    (none)
    )
  :code (behavior ()
    (loop
      (when (not (paused?))
        (vector<-cspace!
          (-> self trans)
          (-> (the-as pov-camera (-> *camera* pov-handle process 0)) node-list data (-> *camera* pov-bone))
          )
        (let* ((v1-5 (-> self tracking))
               (a3-0 (-> (the-as pov-camera (-> *camera* pov-handle process 0))
                         node-list
                         data
                         (-> *camera* pov-bone)
                         bone
                         transform
                         )
                     )
               (a0-8 (-> a3-0 vector 0 quad))
               (a1-9 (-> a3-0 vector 1 quad))
               (a2-0 (-> a3-0 vector 2 quad))
               (a3-1 (-> a3-0 vector 3 quad))
               )
          (set! (-> v1-5 inv-mat vector 0 quad) a0-8)
          (set! (-> v1-5 inv-mat vector 1 quad) a1-9)
          (set! (-> v1-5 inv-mat vector 2 quad) a2-0)
          (set! (-> v1-5 inv-mat vector 3 quad) a3-1)
          )
        (vector-reset! (-> self tracking inv-mat vector 3))
        )
      (suspend)
      )
    (none)
    )
  )

(defstate cam-pov180 (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('teleport)
       #f
       )
      (else
        (cam-standard-event-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self blend-from-type) (the-as uint 1))
      (set! (-> self blend-to-type) (the-as uint 1))
      )
    (none)
    )
  :trans (behavior ()
    (when (not (handle->process (-> *camera* pov-handle)))
      (set! (-> self blend-from-type) (the-as uint 0))
      (cam-slave-go cam-fixed)
      )
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'vector))
          (s5-0 (new 'stack-no-clear 'vector))
          (s4-0 #t)
          )
      (vector<-cspace!
        gp-0
        (-> (the-as pov-camera (-> *camera* pov-handle process 0)) node-list data (-> *camera* pov-bone))
        )
      (let ((v1-11 (-> (the-as pov-camera (-> *camera* pov-handle process 0))
                       node-list
                       data
                       (-> *camera* pov-bone)
                       bone
                       transform
                       )
                   )
            )
        (vector-normalize-copy! s5-0 (-> v1-11 vector 2) (the-as float 1.0))
        )
      (loop
        (when (not (paused?))
          (let ((s0-0
                  (-> (the-as pov-camera (-> *camera* pov-handle process 0))
                      node-list
                      data
                      (-> *camera* pov-bone)
                      bone
                      transform
                      )
                  )
                (s1-0
                  (-> (the-as pov-camera (-> *camera* pov-handle process 0)) node-list data (-> *camera* pov-bone) bone scale)
                  )
                (s3-0 (new 'stack-no-clear 'vector))
                )
            (let ((s2-0 (new 'stack-no-clear 'vector)))
              (vector<-cspace!
                s2-0
                (-> (the-as pov-camera (-> *camera* pov-handle process 0)) node-list data (-> *camera* pov-bone))
                )
              (vector-normalize-copy! s3-0 (-> s0-0 vector 2) (the-as float 1.0))
              (set! s4-0
                    (cond
                      ((and (< (vector-vector-distance s2-0 gp-0) 40960.0) (< (cos (the-as float 3640.889)) (vector-dot s5-0 s3-0)))
                       (set! (-> self trans quad) (-> s2-0 quad))
                       (vector-negate! (the-as vector (-> self tracking)) (the-as vector (-> s0-0 vector)))
                       (set! (-> self tracking inv-mat vector 1 quad) (-> s0-0 vector 1 quad))
                       (vector-negate! (-> self tracking inv-mat vector 2) (-> s0-0 vector 2))
                       (set! (-> self fov) (* 2.0 (atan (/ 12.700255 (* 20.3 (-> s1-0 x))) (the-as float 1.0))))
                       (vector-float*! (the-as vector (-> self tracking)) (the-as vector (-> self tracking)) (/ 1.0 (-> s1-0 x)))
                       (vector-reset! (-> self tracking inv-mat vector 3))
                       (if s4-0
                           (set! s4-0 #f)
                           )
                       s4-0
                       )
                      (else
                        #t
                        )
                      )
                    )
              (set! (-> gp-0 quad) (-> s2-0 quad))
              )
            (set! (-> s5-0 quad) (-> s3-0 quad))
            )
          )
        (suspend)
        )
      )
    (none)
    )
  )

(defstate cam-pov-track (camera-slave)
  :event cam-standard-event-handler
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self blend-from-type) (the-as uint 2))
      (set! (-> self blend-to-type) (the-as uint 2))
      )
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (if (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) gp-0 'interesting)
          (send-event *camera* 'point-of-interest gp-0)
          )
      )
    (none)
    )
  :trans (behavior ()
    (if (or (not (handle->process (-> *camera* pov-handle))) (not (logtest? (-> *camera* master-options) 2)))
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (loop
      (if (not (paused?))
          (vector<-cspace!
            (-> self trans)
            (-> (the-as pov-camera (-> *camera* pov-handle process 0)) node-list data (-> *camera* pov-bone))
            )
          )
      (suspend)
      )
    (none)
    )
  )

(defbehavior cam-standoff-calc-trans camera-slave ()
  (if (-> self tracking no-follow)
      (vector+! (-> self trans) (-> *camera* tpos-curr-adj) (-> self pivot-pt))
      (vector+! (-> self trans) (-> self tracking follow-pt) (-> self pivot-pt))
      )
  )

(defstate cam-standoff (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('set-standoff-dist)
       (vector-normalize! (-> self pivot-pt) (the-as float (-> event param 0)))
       (cam-standoff-calc-trans)
       )
      (('set-standoff-height)
       (vector-flatten! (-> self pivot-pt) (-> self pivot-pt) (-> *camera* local-down))
       (vector--float*!
         (-> self pivot-pt)
         (-> self pivot-pt)
         (-> *camera* local-down)
         (the-as float (-> event param 0))
         )
       (cam-standoff-calc-trans)
       )
      (else
        (cam-standard-event-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (vector-! (-> self pivot-pt) (-> self trans) (-> *camera* tpos-curr-adj))
      (cond
        ((logtest? (-> self options) #x8000)
         (set! (-> self blend-from-type) (the-as uint 0))
         (set! (-> self blend-to-type) (the-as uint 0))
         0
         )
        (else
          (set! (-> self blend-from-type) (the-as uint 2))
          (set! (-> self blend-to-type) (the-as uint 2))
          )
        )
      )
    (cam-calc-follow! (-> self tracking) (-> self trans) #f)
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) 2))
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (loop
      (when (not (paused?))
        (cam-calc-follow! (-> self tracking) (-> self trans) #t)
        (cam-standoff-calc-trans)
        )
      (suspend)
      )
    (none)
    )
  )

(defstate cam-standoff-read-entity (camera-slave)
  :event cam-standard-event-handler
  :enter (behavior ()
    (cond
      ((-> self enter-has-run)
       )
      ((-> self cam-entity)
       (let ((gp-0 (new-stack-vector0))
             (s5-0 (new-stack-vector0))
             )
         (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) gp-0 'trans)
         (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) s5-0 'align)
         (vector-! (-> self pivot-pt) gp-0 s5-0)
         )
       (vector+! (-> self trans) (-> *camera* tpos-curr-adj) (-> self pivot-pt))
       (set! (-> self fov) (cam-slave-get-fov (-> self cam-entity)))
       (logior! (-> self options) (cam-slave-get-flags (-> self cam-entity) 'flags))
       (if (logtest? (-> self options) #x8000)
           (cam-slave-get-rot (the-as entity-actor (-> self cam-entity)) (the-as matrix (-> self tracking)))
           (set! (-> self tracking tilt-adjust target)
                 (cam-slave-get-float (-> self cam-entity) 'tiltAdjust (-> *CAMERA-bank* default-tilt-adjust))
                 )
           )
       ((-> cam-standoff enter))
       )
      (else
        (format #t "ERROR <GMJ>: cam-standoff-read-entity enter without entity~%")
        )
      )
    (let ((gp-2 (new 'stack-no-clear 'vector)))
      (if (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) gp-2 'interesting)
          (send-event *camera* 'point-of-interest gp-2)
          )
      )
    (go cam-standoff)
    (none)
    )
  :code (behavior ()
    (loop
      (format *stdcon* "ERROR <GMJ>: stayed in cam-standoff-read-entity~%")
      (suspend)
      )
    (none)
    )
  )

(deftype cam-eye-bank (basic)
  ((rot-speed   float  :offset-assert   4)
   (max-degrees float  :offset-assert   8)
   (max-fov     float  :offset-assert  12)
   (min-fov     float  :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x14
  :flag-assert         #x900000014
  )


(define *CAM_EYE-bank*
  (new 'static 'cam-eye-bank :rot-speed 364.0889 :max-degrees 12743.111 :max-fov 11650.845 :min-fov 6189.511)
  )

;; main first-person camera
;; note: modified for high fps
(defstate cam-eye (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('teleport)
       #f
       )
      (else
        (cam-standard-event-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (let ((v1-3 (vector-float*! (new-stack-vector0) (-> *camera* local-down) (+ 1024.0 (-> *camera* target-height)))))
        (vector-! (-> self trans) (-> *camera* tpos-curr) v1-3)
        )
      (set! (-> self blend-from-type) (the-as uint 0))
      (set! (-> self blend-to-type) (the-as uint 0))
      0
      )
    (set! (-> self fov) 11650.845)
    (none)
    )
  :exit (behavior ()
    (if (and *target*
             (logtest? (-> *camera* master-options) 2)
             (logtest? (-> *target* state-flags) (state-flags first-person-mode))
             )
        (send-event *target* 'end-mode)
        )
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) 2))
        (go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (-> *display* base-frame-counter)))
      (loop
        (when (not (paused?))
          (let ((s4-0 (vector-reset! (new-stack-vector0)))
                (s5-0 (new-stack-matrix0))
                )
            (when *camera-read-analog*
              (let ((f30-0 (analog-input-horizontal-first   ;; changed for pc port
                             (the-as int (+ (-> *cpad-list* cpads 0 rightx) -256 (-> *cpad-list* cpads 0 leftx)))
                             (the-as float 0.0)
                             (the-as float 48.0)
                             (the-as float 110.0)
                             (the-as float -1.0)
                             )
                           )
                    (f0-0 (analog-input-vertical-first   ;; changed for pc port
                            (the-as int (+ (-> *cpad-list* cpads 0 righty) -256 (-> *cpad-list* cpads 0 lefty)))
                            (the-as float 0.0)
                            (the-as float 48.0)
                            (the-as float 110.0)
                            (the-as float -1.0)
                            )
                          )
                    )
                (set! (-> s4-0 y) (- (-> s4-0 y) (* (- f30-0) (* (-> *display* time-adjust-ratio) (-> *CAM_EYE-bank* rot-speed))))) ;; changed for high fps
                (set! (-> s4-0 x) (- (-> s4-0 x) (* (- f0-0) (* (-> *display* time-adjust-ratio) (-> *CAM_EYE-bank* rot-speed))))) ;; changed for high fps
                )
              )
            (cond
              ((< (* (-> *display* time-adjust-ratio) (-> *CAM_EYE-bank* rot-speed)) (-> s4-0 x)) ;; changed for high fps
               (set! (-> s4-0 x) (* (-> *display* time-adjust-ratio) (-> *CAM_EYE-bank* rot-speed))) ;; changed for high fps
               )
              ((< (-> s4-0 x) (- (* (-> *display* time-adjust-ratio) (-> *CAM_EYE-bank* rot-speed)))) ;; changed for high fps
               (set! (-> s4-0 x) (- (* (-> *display* time-adjust-ratio) (-> *CAM_EYE-bank* rot-speed)))) ;; changed for high fps
               )
              )
            (cond
              ((< (* (-> *display* time-adjust-ratio) (-> *CAM_EYE-bank* rot-speed)) (-> s4-0 y)) ;; changed for high fps
               (set! (-> s4-0 y) (* (-> *display* time-adjust-ratio) (-> *CAM_EYE-bank* rot-speed))) ;; changed for high fps
               )
              ((< (-> s4-0 y) (- (* (-> *display* time-adjust-ratio) (-> *CAM_EYE-bank* rot-speed)))) ;; changed for high fps
               (set! (-> s4-0 y) (- (* (-> *display* time-adjust-ratio) (-> *CAM_EYE-bank* rot-speed)))) ;; changed for high fps
               )
              )
            (cond
              ((and (= (-> s4-0 x) 0.0) (= (-> s4-0 y) 0.0))
               (set! gp-0 (-> *display* base-frame-counter))
               )
              (else
                (let ((v1-44 (min 10 (max 1 (- (-> *display* base-frame-counter) gp-0)))))
                  (vector-float*! s4-0 s4-0 (* 0.1 (the float v1-44)))
                  )
                )
              )
            (matrix-axis-angle! s5-0 (-> *camera* local-down) (-> s4-0 y))
            (matrix*! (the-as matrix (-> self tracking)) (the-as matrix (-> self tracking)) s5-0)
            (when (not (logtest? (-> self options) 8))
              (if (< (vector-dot (-> self tracking inv-mat vector 1) (-> *camera* local-down)) 0.0)
                  (forward-down->inv-matrix
                    (the-as matrix (-> self tracking))
                    (-> self tracking inv-mat vector 2)
                    (-> *camera* local-down)
                    )
                  (forward-down->inv-matrix
                    (the-as matrix (-> self tracking))
                    (-> self tracking inv-mat vector 2)
                    (vector-negate! (new-stack-vector0) (-> *camera* local-down))
                    )
                  )
              )
            (matrix-axis-angle! s5-0 (the-as vector (-> self tracking)) (- (-> s4-0 x)))
            (matrix*! (the-as matrix (-> self tracking)) (the-as matrix (-> self tracking)) s5-0)
            )
          (when (not (logtest? (-> self options) 8))
            (let ((f30-1 (vector-dot (-> *camera* local-down) (-> self tracking inv-mat vector 2))))
              (set! (-> (new 'stack-no-clear 'vector) quad) (the-as uint128 0))
              (when (< (sin (-> *CAM_EYE-bank* max-degrees)) (fabs f30-1))
                (vector--float*!
                  (-> self tracking inv-mat vector 2)
                  (-> self tracking inv-mat vector 2)
                  (-> *camera* local-down)
                  f30-1
                  )
                (vector-normalize! (-> self tracking inv-mat vector 2) (cos (-> *CAM_EYE-bank* max-degrees)))
                (if (< f30-1 0.0)
                    (vector--float*!
                      (-> self tracking inv-mat vector 2)
                      (-> self tracking inv-mat vector 2)
                      (-> *camera* local-down)
                      (sin (-> *CAM_EYE-bank* max-degrees))
                      )
                    (vector+float*!
                      (-> self tracking inv-mat vector 2)
                      (-> self tracking inv-mat vector 2)
                      (-> *camera* local-down)
                      (sin (-> *CAM_EYE-bank* max-degrees))
                      )
                    )
                (vector-cross!
                  (-> self tracking inv-mat vector 1)
                  (-> self tracking inv-mat vector 2)
                  (the-as vector (-> self tracking))
                  )
                (set! (-> self tracking inv-mat vector 1 w) 0.0)
                )
              )
            )
          )
        (let ((v1-76 (vector-float*! (new-stack-vector0) (-> *camera* local-down) (+ 1024.0 (-> *camera* target-height)))))
          (vector-! (-> self trans) (-> *camera* tpos-curr) v1-76)
          )
        (suspend)
        )
      )
    (none)
    )
  )

(deftype cam-billy-bank (basic)
  ((rot-speed    float  :offset-assert   4)
   (tilt-degrees float  :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )


(define *CAM_BILLY-bank* (new 'static 'cam-billy-bank :rot-speed 364.0889 :tilt-degrees -1820.4445))

;; first person camera for rat game
(defstate cam-billy (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('teleport)
       #f
       )
      (else
        (cam-standard-event-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (let ((v1-3 (vector-float*! (new-stack-vector0) (-> *camera* local-down) (-> *camera* target-height))))
        (vector-! (-> self trans) (-> *camera* tpos-curr) v1-3)
        )
      (set! (-> self blend-from-type) (the-as uint 0))
      (set! (-> self blend-to-type) (the-as uint 0))
      0
      )
    (set! (-> self fov) 9830.4)
    (matrix-rotate-y! (the-as matrix (-> self tracking)) (the-as float -32768.0))
    (none)
    )
  :exit (behavior ()
    '()
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) 2))
        (go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (loop
      (when (not (paused?))
        (let ((s5-0 (vector-reset! (new-stack-vector0)))
              (s4-0 (vector-reset! (new-stack-vector0)))
              (s3-0 (vector-reset! (new-stack-vector0)))
              (s2-0 (new-stack-vector0))
              (gp-0 (new-stack-matrix0))
              )
          0.0
          (when *camera-read-analog*
            (let ((f1-0
                    (analog-input-horizontal-first   ;; changed for pc port
                      (the-as int (+ (-> *cpad-list* cpads 0 rightx) -256 (-> *cpad-list* cpads 0 leftx)))
                      (the-as float 0.0)
                      (the-as float 48.0)
                      (the-as float 110.0)
                      (the-as float -1.0)
                      )
                    )
                  )
              (set! (-> s5-0 y) (- (-> s5-0 y) (* (- f1-0) (* (-> *display* time-adjust-ratio) (-> *CAM_BILLY-bank* rot-speed))))) ;; changed for high fps
              )
            )
          (cond
            ((< (* (-> *display* time-adjust-ratio) (-> *CAM_BILLY-bank* rot-speed)) (-> s5-0 y)) ;; changed for high fps
             (set! (-> s5-0 y) (* (-> *display* time-adjust-ratio) (-> *CAM_BILLY-bank* rot-speed))) ;; changed for high fps
             )
            ((< (-> s5-0 y) (- (* (-> *display* time-adjust-ratio) (-> *CAM_BILLY-bank* rot-speed)))) ;; changed for high fps
             (set! (-> s5-0 y) (- (* (-> *display* time-adjust-ratio) (-> *CAM_BILLY-bank* rot-speed)))) ;; changed for high fps
             )
            )
          (set! (-> s3-0 x) (sin (the-as float 37319.11)))
          (set! (-> s3-0 z) (cos (the-as float 37319.11)))
          (set! (-> s4-0 x) (-> s3-0 z))
          (set! (-> s4-0 z) (- (-> s3-0 x)))
          (vector-flatten! s2-0 (-> self tracking inv-mat vector 2) (-> *camera* local-down))
          (vector-normalize! s2-0 (the-as float 1.0))
          (let ((f0-14 (acos (vector-dot (-> self tracking inv-mat vector 2) s3-0))))
            (if (< (vector-dot (-> self tracking inv-mat vector 2) s4-0) 0.0)
                (set! f0-14 (- f0-14))
                )
            (let ((f0-18 (cond
                           ((and (< 0.0 f0-14) (< 0.0 (-> s5-0 y)))
                            (fmin (-> s5-0 y) (fmax 0.0 (* 0.5 (- 10922.667 f0-14))))
                            )
                           ((and (< f0-14 0.0) (< (-> s5-0 y) 0.0))
                            (fmax (-> s5-0 y) (fmin 0.0 (* 0.5 (- -10922.667 f0-14))))
                            )
                           (else
                             (-> s5-0 y)
                             )
                           )
                         )
                  )
              (matrix-axis-angle! gp-0 (-> *camera* local-down) f0-18)
              )
            )
          (vector-matrix*! (-> self tracking inv-mat vector 2) (-> self tracking inv-mat vector 2) gp-0)
          )
        (set! (-> self tracking inv-mat vector 2 y) 0.0)
        (vector-normalize! (-> self tracking inv-mat vector 2) (cos (-> *CAM_BILLY-bank* tilt-degrees)))
        (set! (-> self tracking inv-mat vector 2 y) (sin (-> *CAM_BILLY-bank* tilt-degrees)))
        (vector-cross!
          (the-as vector (-> self tracking))
          (-> self tracking inv-mat vector 2)
          (-> *camera* local-down)
          )
        (vector-normalize! (the-as vector (-> self tracking)) (the-as float 1.0))
        (vector-cross!
          (-> self tracking inv-mat vector 1)
          (-> self tracking inv-mat vector 2)
          (the-as vector (-> self tracking))
          )
        )
      (vector--float*! (-> self trans) (-> *camera* tpos-curr) (-> *camera* local-down) (-> *camera* target-height))
      (suspend)
      )
    (none)
    )
  )

(defstate cam-spline (camera-slave)
  :event cam-standard-event-handler
  :enter (behavior ()
    (cond
      ((-> self enter-has-run)
       )
      ((-> self cam-entity)
       (let ((gp-0 (new-stack-vector0)))
         (set! (-> self fov) (cam-slave-get-fov (-> self cam-entity)))
         (logior! (-> self options) (cam-slave-get-flags (-> self cam-entity) 'flags))
         (if (logtest? (-> self options) #x8000)
             (cam-slave-get-rot (the-as entity-actor (-> self cam-entity)) (the-as matrix (-> self tracking)))
             (set! (-> self tracking tilt-adjust target)
                   (cam-slave-get-float (-> self cam-entity) 'tiltAdjust (-> *CAMERA-bank* default-tilt-adjust))
                   )
             )
         (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) gp-0 'trans)
         (cam-curve-setup gp-0)
         )
       (vector-negate! (-> self saved-pt) (-> self spline-offset))
       (let ((a0-8 (res-lump-struct (-> self cam-entity) 'spline-offset structure :time (the-as float -1000000000.0))))
         (if a0-8
             (vector+! (-> self spline-offset) (-> self spline-offset) (the-as vector a0-8))
             )
         )
       (set! (-> self trans quad) (-> self saved-pt quad))
       (cam-calc-follow! (-> self tracking) (-> self trans) #f)
       (set! (-> self spline-follow-dist)
             (cam-slave-get-float (-> self cam-entity) 'spline-follow-dist (the-as float 0.0))
             )
       (cond
         ((< 0.0 (-> self spline-follow-dist))
          (let ((s5-1 (new 'stack-no-clear 'vector))
                (gp-1 (new 'stack-no-clear 'vector))
                )
            (curve-get-pos! s5-1 (the-as float 0.0) (-> self spline-curve))
            (curve-get-pos! gp-1 (the-as float 1.0) (-> self spline-curve))
            (if (< (vector-vector-distance-squared s5-1 (-> self tracking follow-pt))
                   (vector-vector-distance-squared gp-1 (-> self tracking follow-pt))
                   )
                (set! (-> self spline-follow-dist) (- (-> self spline-follow-dist)))
                )
            )
          (set! (-> self spline-tt) (curve-closest-point
                                      (-> self spline-curve)
                                      (-> self tracking follow-pt)
                                      (the-as float 0.5)
                                      (the-as float -4096.0)
                                      10
                                      (-> self spline-follow-dist)
                                      )
                )
          )
         (else
           (set! (-> self spline-follow-dist) 0.0)
           )
         )
       (cam-curve-pos (-> self trans) (the-as vector #f) (the-as curve #f) #t)
       (cond
         ((logtest? (-> self options) #x8000)
          (set! (-> self blend-from-type) (the-as uint 0))
          (set! (-> self blend-to-type) (the-as uint 0))
          0
          )
         (else
           (set! (-> self blend-from-type) (the-as uint 2))
           (set! (-> self blend-to-type) (the-as uint 2))
           )
         )
       )
      (else
        (format #t "ERROR <GMJ>: cam-spline enter without entity~%")
        )
      )
    (let ((gp-2 (new 'stack-no-clear 'vector)))
      (if (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) gp-2 'interesting)
          (send-event *camera* 'point-of-interest gp-2)
          )
      )
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) 2))
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (loop
      (when (not (paused?))
        (cam-calc-follow! (-> self tracking) (-> self trans) #t)
        (new 'stack 'curve)
        (set! (-> self trans quad) (-> self saved-pt quad))
        (cam-curve-pos (-> self trans) (the-as vector #f) (the-as curve #f) #t)
        )
      (suspend)
      )
    (none)
    )
  )

(defstate cam-decel (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('teleport)
       #f
       )
      (else
        (cam-standard-event-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (if (not (-> self enter-has-run))
        (set! (-> self saved-pt quad) (-> self trans quad))
        )
    (none)
    )
  :code (behavior ()
    (loop
      (when (not (paused?))
        (let ((s5-0 (new-stack-vector0))
              (gp-0 (new-stack-vector0))
              )
          (when (!= (-> *camera* outro-t-step) 0.0)
            (curve-get-pos! s5-0 (parameter-ease-sin-clamp (-> *camera* outro-t)) (-> *camera* outro-curve))
            (+! (-> *camera* outro-t) (* (-> *camera* outro-t-step) (-> *display* time-adjust-ratio)))
            (curve-get-pos! gp-0 (parameter-ease-sin-clamp (-> *camera* outro-t)) (-> *camera* outro-curve))
            (vector-! gp-0 gp-0 s5-0)
            (cond
              ((or (and (< (-> *camera* outro-t-step) 0.0) (>= (-> *camera* outro-exit-value) (-> *camera* outro-t)))
                   (and (< 0.0 (-> *camera* outro-t-step)) (>= (-> *camera* outro-t) (-> *camera* outro-exit-value)))
                   )
               (set! (-> *camera* outro-t) (-> *camera* outro-exit-value))
               (set! (-> *camera* outro-t-step) 0.0)
               (vector+! (-> self velocity) (-> self velocity) gp-0)
               (send-event *camera* 'outro-done)
               )
              (else
                (vector+! (-> self trans) (-> self trans) gp-0)
                )
              )
            )
          )
        (vector-float*! (-> self velocity) (-> self velocity) 0.9)
        (vector+! (-> self trans) (-> self trans) (-> self velocity))
        )
      (suspend)
      )
    (none)
    )
  )

(defstate cam-endlessfall (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('teleport)
       #f
       )
      (else
        (cam-standard-event-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self blend-from-type) (the-as uint 2))
      (set! (-> self blend-to-type) (the-as uint 2))
      )
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'cam-vector-seeker))
          (f30-0 (-> self velocity y))
          )
      (let ((s4-0 (new 'stack-no-clear 'vector))
            (s5-0 (new 'stack-no-clear 'vector))
            )
        (set! (-> s4-0 quad) (-> self trans quad))
        (set! (-> s4-0 y) 0.0)
        (set! (-> s5-0 quad) (-> self velocity quad))
        (set! (-> s5-0 y) 0.0)
        (init! gp-0 s4-0 (the-as float 81.92) (fmax 819.2 (vector-length s5-0)) (the-as float 0.75))
        (set! (-> gp-0 vel quad) (-> s5-0 quad))
        )
      (loop
        (when (not (paused?))
          (set! (-> gp-0 target x) (-> (target-pos 0) x))
          (set! (-> gp-0 target z) (-> (target-pos 0) z))
          (update! gp-0 (the-as vector #f))
          (when (< 819.2 (-> gp-0 max-vel))
            (set! (-> gp-0 max-vel) (* 0.9 (-> gp-0 max-vel)))
            (if (< (-> gp-0 max-vel) 819.2)
                (set! (-> gp-0 max-vel) 819.2)
                )
            )
          (set! f30-0 (* 0.9 f30-0))
          (+! (-> self trans y) f30-0)
          (set! (-> self trans x) (-> gp-0 value x))
          (set! (-> self trans z) (-> gp-0 value z))
          )
        (suspend)
        )
      )
    (none)
    )
  )

;; third person cam used to focus on various entities
(defbehavior cam-circular-position-into-max-angle camera-slave ((arg0 vector) (arg1 vector) (arg2 float))
  (let* ((f30-0 (vector-normalize-ret-len! arg0 (the-as float 1.0)))
         (f26-0 (vector-normalize-ret-len! arg1 (the-as float 1.0)))
         (f0-1 (vector-dot arg0 arg1))
         (f28-0 (acos f0-1))
         (s3-0 (new 'stack-no-clear 'matrix))
         )
    (when *camera-read-analog*
      (let ((f24-0 (analog-input-horizontal-third   ;; changed for pc port
                     (the-as int (-> *cpad-list* cpads 0 rightx))
                     (the-as float 128.0)
                     (the-as float 32.0)
                     (the-as float 110.0)
                     (* 8192.0 (-> *display* seconds-per-frame))
                     )
                   )
            (f1-2 (analog-input-vertical-third   ;; changed for pc port
                    (the-as int (-> *cpad-list* cpads 0 righty))
                    (the-as float 128.0)
                    (the-as float 32.0)
                    (the-as float 110.0)
                    (* 8192.0 (-> *display* seconds-per-frame))
                    )
                  )
            (s2-0 (new-stack-matrix0))
            )
        (let ((v1-20 (new 'stack-no-clear 'vector)))
          0.0
          (if (< (-> self pivot-rad) f30-0)
              (set! f24-0 (- f24-0))
              )
          (vector-cross! v1-20 arg1 arg0)
          (let ((f0-9 (vector-dot v1-20 (-> *camera* local-down))))
            (if (< f1-2 0.0)
                (set! f1-2 (fmax f1-2 (* -0.15 f28-0)))
                )
            (if (< f0-9 0.0)
                (set! f1-2 (- f1-2))
                )
            (let* ((f1-3 (+ f24-0 f1-2))
                   (f1-5
                     (fmin (* 8192.0 (-> *display* seconds-per-frame)) (fmax (* -8192.0 (-> *display* seconds-per-frame)) f1-3))
                     )
                   )
              (cond
                ((and (< 0.0 f1-5) (< 0.0 f0-9) (< (-> self max-angle-curr) f28-0))
                 (set! f1-5 0.0)
                 )
                ((and (< 0.0 f1-5) (< 0.0 f0-9))
                 (set! f1-5 (fmin f1-5 (* 0.15 (- (-> self max-angle-curr) f28-0))))
                 )
                ((and (< f1-5 0.0) (< f0-9 0.0) (< (-> self max-angle-curr) f28-0))
                 (set! f1-5 0.0)
                 )
                ((and (< f1-5 0.0) (< f0-9 0.0))
                 (set! f1-5 (fmax f1-5 (* 0.15 (- f28-0 (-> self max-angle-curr)))))
                 )
                )
              (matrix-axis-angle! s2-0 (-> *camera* local-down) f1-5)
              )
            )
          )
        (vector-matrix*! arg1 arg1 s2-0)
        )
      (let ((f0-15 (vector-dot arg0 arg1)))
        (set! f28-0 (acos f0-15))
        )
      )
    (cond
      ((< (-> self max-angle-curr) f28-0)
       (matrix-from-two-vectors-max-angle!
         s3-0
         arg1
         arg0
         (* (fmin 1.0 (* arg2 (-> *display* time-adjust-ratio))) (- f28-0 (-> self max-angle-curr)))
         )
       (vector-matrix*! arg0 arg1 s3-0)
       )
      ((and (logtest? (-> self options) 2)
            (or (and (>= f26-0 (+ -8192.0 f30-0)) (>= f30-0 (+ -8192.0 (-> self pivot-rad))))
                (and (>= (+ 8192.0 f30-0) f26-0) (>= (+ 8192.0 (-> self pivot-rad)) f30-0))
                )
            )
       (let ((s2-1 (new 'stack-no-clear 'vector)))
         (vector-cross! s2-1 arg1 arg0)
         (vector-normalize! s2-1 (the-as float 1.0))
         (matrix-axis-angle!
           s3-0
           s2-1
           (* (fmin 1.0 (* arg2 (-> *display* time-adjust-ratio))) (- (-> self max-angle-curr) f28-0))
           )
         )
       (vector-matrix*! arg0 arg1 s3-0)
       )
      (else
        (set! (-> arg0 quad) (-> arg1 quad))
        (if (logtest? (-> self options) 2048)
            (set! (-> self max-angle-curr) f28-0)
            )
        )
      )
    )
  (vector-normalize! arg0 (-> self pivot-rad))
  )

(defbehavior cam-circular-position camera-slave ((arg0 symbol))
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (if (logtest? (-> self options) 130)
          (vector-! gp-0 (-> self circular-follow) (-> self pivot-pt))
          (vector-! gp-0 (-> self pivot-pt) (-> self circular-follow))
          )
      (vector-! s5-0 (-> self trans) (-> self pivot-pt))
      (when (not (logtest? (-> self options) 4))
        (vector-flatten! gp-0 gp-0 (-> *camera* local-down))
        (vector-flatten! s5-0 s5-0 (-> *camera* local-down))
        )
      (cond
        ((logtest? (-> self options) 128)
         (let ((f0-1 (- (vector-length gp-0) (-> self pivot-rad))))
           (if (>= 0.0 f0-1)
               (vector-reset! gp-0)
               (vector-normalize! gp-0 f0-1)
               )
           )
         )
        ((not arg0)
         (set! (-> self max-angle-curr) (-> self max-angle-offset))
         (cam-circular-position-into-max-angle gp-0 s5-0 (the-as float 1.0))
         )
        (else
          (cam-circular-position-into-max-angle gp-0 s5-0 (the-as float 0.05))
          )
        )
      )
    (vector+! (-> self trans) gp-0 (-> self pivot-pt))
    )
  )

(defbehavior cam-circular-code camera-slave ()
  (set! (-> self pivot-pt quad) (-> self saved-pt quad))
  (cam-curve-pos (-> self pivot-pt) (the-as vector #f) (the-as curve #f) #f)
  (let ((a2-1 (new-stack-vector0)))
    (vector-! a2-1 (-> *camera* tpos-curr-adj) (-> self pivot-pt))
    (vector-! (-> self circular-follow) (-> self circular-follow) (-> self pivot-pt))
    (if (logtest? (-> self options) 4)
        (v-slrp3!
          (-> self circular-follow)
          (-> self circular-follow)
          a2-1
          (the-as vector #f)
          (* 182.04445 (-> *display* time-adjust-ratio))
          )
        (v-slrp3!
          (-> self circular-follow)
          (-> self circular-follow)
          a2-1
          (-> *camera* local-down)
          (* 182.04445 (-> *display* time-adjust-ratio))
          )
        )
    )
  (vector+! (-> self circular-follow) (-> self circular-follow) (-> self pivot-pt))
  (cam-circular-position #t)
  (if (!= (-> self fov1) 0.0)
      (set! (-> self fov)
            (lerp-clamp
              (-> self fov0)
              (-> self fov1)
              (parameter-ease-sin-clamp (cam-index-method-10 (-> self fov-index) (-> *camera* tpos-curr-adj)))
              )
            )
      )
  )

(defstate cam-circular (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('teleport)
       #f
       )
      (('outro-done)
       (set! (-> self trans quad) (-> *camera-combiner* trans quad))
       (cam-circular-position #f)
       )
      (else
        (cam-standard-event-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (cond
      ((-> self enter-has-run)
       )
      (else
        (let ((gp-0 (new-stack-vector0)))
          (set! (-> (new 'stack-no-clear 'vector) quad) (the-as uint128 0))
          (set! (-> self view-off-param) 1.0)
          (set! (-> self circular-follow quad) (-> *camera* tpos-curr-adj quad))
          (set! (-> self max-angle-offset) 0.0)
          (cond
            ((-> self cam-entity)
             (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) (-> self saved-pt) 'pivot)
             (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) gp-0 'trans)
             (set! (-> self pivot-rad) (vector-length (vector-! gp-0 gp-0 (-> self saved-pt))))
             (logior! (-> self options) (cam-slave-get-flags (-> self cam-entity) 'flags))
             (set! (-> self fov) (cam-slave-get-fov (-> self cam-entity)))
             (set! (-> self tracking tilt-adjust target)
                   (cam-slave-get-float (-> self cam-entity) 'tiltAdjust (-> *CAMERA-bank* default-tilt-adjust))
                   )
             (set! (-> self max-angle-offset) (cam-slave-get-float (-> self cam-entity) 'maxAngle (the-as float 0.0)))
             (if (< (-> self max-angle-offset) 0.0)
                 (set! (-> self max-angle-offset) 0.0)
                 )
             (set! (-> self fov1) (cam-slave-get-float (-> self cam-entity) 'focalPull (the-as float 0.0)))
             (cond
               ((and (!= (-> self fov1) 0.0)
                     (cam-index-method-9 (-> self fov-index) 'focalpull (-> self cam-entity) (-> self saved-pt) (the-as curve #f))
                     )
                (set! (-> self fov0) (-> self fov))
                (set! (-> self fov) (lerp-clamp
                                      (-> self fov0)
                                      (-> self fov1)
                                      (cam-index-method-10 (-> self fov-index) (-> *camera* tpos-curr-adj))
                                      )
                      )
                )
               (else
                 (set! (-> self fov1) 0.0)
                 )
               )
             (cam-curve-setup (-> self saved-pt))
             (set! (-> self pivot-pt quad) (-> self saved-pt quad))
             (cam-curve-pos (-> self pivot-pt) (the-as vector #f) (the-as curve #f) #f)
             )
            ((logtest? (-> self options) 128)
             (vector-! (-> self pivot-pt) (-> *camera* tpos-curr-adj) (-> self trans))
             (vector-flatten! (-> self pivot-pt) (-> self pivot-pt) (-> *camera* local-down))
             (set! (-> self pivot-rad) (vector-length (-> self pivot-pt)))
             (set! (-> self pivot-pt quad) (-> self trans quad))
             (set! (-> self saved-pt quad) (-> self pivot-pt quad))
             )
            (else
              (vector-! (-> self pivot-pt) (-> *camera* tpos-curr-adj) (-> self trans))
              (vector-float*! (-> self pivot-pt) (-> self pivot-pt) 0.5)
              (vector-flatten! (-> self pivot-pt) (-> self pivot-pt) (-> *camera* local-down))
              (set! (-> self pivot-rad) (vector-length (-> self pivot-pt)))
              (vector+! (-> self pivot-pt) (-> self trans) (-> self pivot-pt))
              (set! (-> self saved-pt quad) (-> self pivot-pt quad))
              )
            )
          )
        (cam-circular-position #f)
        (set! (-> self blend-from-type) (the-as uint 2))
        (set! (-> self blend-to-type) (the-as uint 2))
        )
      )
    (let ((gp-3 (new 'stack-no-clear 'vector)))
      (if (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) gp-3 'interesting)
          (send-event *camera* 'point-of-interest gp-3)
          )
      )
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) 2))
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (loop
      (if (not (paused?))
          (cam-circular-code)
          )
      (suspend)
      )
    (none)
    )
  )

(defstate cam-lookat (camera-slave)
  :event cam-standard-event-handler
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self blend-from-type) (the-as uint 2))
      (set! (-> self blend-to-type) (the-as uint 2))
      )
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) 2))
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (loop
      (suspend)
      )
    (none)
    )
  )

(deftype cam-string-bank (basic)
  ((los-coll-rad  meters  :offset-assert   4)
   (los-coll-rad2 meters  :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )


(define *CAM_STRING-bank* (new 'static 'cam-string-bank :los-coll-rad (meters 1) :los-coll-rad2 (meters 0.5)))

(defun cam-string-find-position-rel! ((arg0 vector))
  (let ((s5-0 (new 'stack-no-clear 'vector))
        (s4-0 (new 'stack-no-clear 'vector))
        (s3-0 (new 'stack-no-clear 'collide-tri-result))
        (f30-0 0.0)
        (s2-0 (new 'stack-no-clear 'matrix))
        )
    (vector-flatten! s5-0 (-> *camera-combiner* inv-camera-rot vector 2) (-> *camera* local-down))
    (if (= (vector-normalize-ret-len! s5-0 (- (+ 1024.0 (-> *CAMERA-bank* default-string-min-z)))) 0.0)
        (set! (-> s5-0 z) (+ 1024.0 (-> *CAMERA-bank* default-string-min-z)))
        )
    (vector--float*! s5-0 s5-0 (-> *camera* local-down) (-> *CAMERA-bank* default-string-min-y))
    (set! (-> arg0 quad) (-> s5-0 quad))
    (loop
      (vector--float*! s4-0 arg0 (-> *camera* local-down) (-> *camera* target-height))
      (if (< (fill-and-probe-using-line-sphere
               *collide-cache*
               (-> *camera* tpos-curr-adj)
               arg0
               (the-as float 409.6)
               (collide-kind background cak-3 wall-object ground-object cak-14)
               (the-as process #f)
               s3-0
               (new 'static 'pat-surface :nocamera #x1)
               )
             0.0
             )
          (return #t)
          )
      (set! f30-0 (cond
                    ((>= -32768.0 f30-0)
                     (format #t "cam-string didn't find a spot~%")
                     (set! (-> arg0 quad) (-> s5-0 quad))
                     (return #f)
                     f30-0
                     )
                    ((< 0.0 f30-0)
                     (- f30-0)
                     )
                    (else
                      (- 5461.3335 f30-0)
                      )
                    )
            )
      (matrix-axis-angle! s2-0 (-> *camera* local-down) f30-0)
      (vector-matrix*! arg0 s5-0 s2-0)
      )
    )
  (the-as symbol #f)
  )

(defbehavior cam-string-set-position-rel! camera-slave ((arg0 vector))
  (vector-flatten! (-> self view-flat) arg0 (-> *camera* local-down))
  (set! (-> self min-z-override) (vector-length (-> self view-flat)))
  (vector+! (-> self desired-pos) arg0 (-> *camera* tpos-curr-adj))
  (set! (-> self string-trans quad) (-> self desired-pos quad))
  (tracking-spline-method-10 (-> self position-spline) (-> self desired-pos))
  (vector-reset! (-> self velocity))
  (let ((v0-3 (logand -4097 (-> self options))))
    (set! (-> self options) v0-3)
    (the-as int v0-3)
    )
  )

(defun string-push-help ()
  (the-as float 409.6)
  )

(defun-debug cam-draw-collide-cache ((arg0 collide-cache))
  (let ((gp-0 (-> arg0 tris)))
    (countdown (s5-0 (-> arg0 num-tris))
      (let ((t1-0 #x40000080))
        (add-debug-flat-triangle
          #t
          (bucket-id debug-no-zbuf)
          (the-as vector (-> gp-0 0))
          (-> gp-0 0 vertex 1)
          (-> gp-0 0 vertex 2)
          (the-as rgba t1-0)
          )
        )
      (set! gp-0 (the-as (inline-array collide-cache-tri) (-> gp-0 1)))
      )
    )
  0
  (none)
  )

(deftype los-dist (structure)
  ((par-dist  float  :offset-assert   0)
   (lat-dist  float  :offset-assert   4)
   (vert-dist float  :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )


(deftype collide-los-dist-info (structure)
  ((min-par float  :offset-assert   0)
   (max-par float  :offset-assert   4)
   (min-lat float  :offset-assert   8)
   (max-lat float  :offset-assert  12)
   (min-vp  float  :offset-assert  16)
   (max-vp  float  :offset-assert  20)
   (min-vn  float  :offset-assert  24)
   (max-vn  float  :offset-assert  28)
   (count   int32  :offset-assert  32)
   )
  :method-count-assert 9
  :size-assert         #x24
  :flag-assert         #x900000024
  )


(defun dist-info-init ((arg0 collide-los-dist-info))
  (set! (-> arg0 min-par) 1.0)
  (set! (-> arg0 max-par) 0.0)
  (set! (-> arg0 count) 0)
  0
  (none)
  )

(defun dist-info-valid? ((arg0 collide-los-dist-info))
  (>= (-> arg0 max-par) (-> arg0 min-par))
  )

(defun dist-info-append ((arg0 collide-los-dist-info) (arg1 vector))
  (cond
    ((dist-info-valid? arg0)
     (if (< (-> arg1 x) (-> arg0 min-par))
         (set! (-> arg0 min-par) (-> arg1 x))
         )
     (if (< (-> arg0 max-par) (-> arg1 x))
         (set! (-> arg0 max-par) (-> arg1 x))
         )
     (if (< (-> arg1 y) (-> arg0 min-lat))
         (set! (-> arg0 min-lat) (-> arg1 y))
         )
     (if (< (-> arg0 max-lat) (-> arg1 y))
         (set! (-> arg0 max-lat) (-> arg1 y))
         )
     (cond
       ((< (-> arg1 y) 0.0)
        (if (< (-> arg1 z) (-> arg0 min-vn))
            (set! (-> arg0 min-vn) (-> arg1 z))
            )
        (if (< (-> arg0 max-vn) (-> arg1 z))
            (set! (-> arg0 max-vn) (-> arg1 z))
            )
        )
       (else
         (if (< (-> arg1 z) (-> arg0 min-vp))
             (set! (-> arg0 min-vp) (-> arg1 z))
             )
         (if (< (-> arg0 max-vp) (-> arg1 z))
             (set! (-> arg0 max-vp) (-> arg1 z))
             )
         )
       )
     )
    (else
      (set! (-> arg0 min-par) (-> arg1 x))
      (set! (-> arg0 max-par) (-> arg1 x))
      (set! (-> arg0 min-lat) (-> arg1 y))
      (set! (-> arg0 max-lat) (-> arg1 y))
      (set! (-> arg0 min-vp) 0.0)
      (set! (-> arg0 max-vp) 0.0)
      (set! (-> arg0 min-vn) 0.0)
      (set! (-> arg0 max-vn) 0.0)
      (cond
        ((< (-> arg1 y) 0.0)
         (set! (-> arg0 min-vn) (-> arg1 z))
         (set! (-> arg0 max-vn) (-> arg1 z))
         )
        (else
          (set! (-> arg0 min-vp) (-> arg1 z))
          (set! (-> arg0 max-vp) (-> arg1 z))
          )
        )
      )
    )
  (+! (-> arg0 count) 1)
  (none)
  )

(defun dist-info-print ((arg0 collide-los-dist-info) (arg1 string))
  (cond
    ((dist-info-valid? arg0)
     (format
       *stdcon*
       "~S ~2,D mn ~,,2M mx ~,,2M mnl ~,,2M mxl ~,,2M~%"
       arg1
       (-> arg0 count)
       (-> arg0 min-par)
       (-> arg0 max-par)
       (-> arg0 min-lat)
       (-> arg0 max-lat)
       )
     (format
       *stdcon*
       "   mnvp ~,,2M mxvp ~,,2M mnvn ~,,2M mxvn ~,,2M~%"
       (-> arg0 min-vp)
       (-> arg0 max-vp)
       (-> arg0 min-vn)
       (-> arg0 max-vn)
       )
     )
    (else
      (format *stdcon* "~S invalid~%" arg1)
      )
    )
  )

(deftype collide-los-result (structure)
  ((lateral       vector                :inline :offset-assert   0)
   (cw            collide-los-dist-info :inline :offset-assert  16)
   (ccw           collide-los-dist-info :inline :offset-assert  64)
   (straddle      collide-los-dist-info :inline :offset-assert 112)
   (lateral-valid symbol                        :offset-assert 148)
   )
  :method-count-assert 9
  :size-assert         #x98
  :flag-assert         #x900000098
  )


(defun los-cw-ccw ((arg0 (inline-array collide-cache-tri))
          (arg1 vector)
          (arg2 vector)
          (arg3 float)
          (arg4 clip-travel-vector-to-mesh-return-info)
          (arg5 vector)
          (arg6 float)
          )
  (local-vars (sv-128 float) (sv-144 vector) (sv-160 vector) (sv-176 vector) (sv-192 vector) (sv-208 int))
  (with-pp
    (set! sv-128 arg3)
    (let ((gp-0 arg4))
      (set! sv-144 arg5)
      (let ((s4-0 arg6))
        (set! sv-160 (new 'stack-no-clear 'vector))
        (set! sv-176 (new 'stack-no-clear 'vector))
        (let ((s5-0 (new 'stack-no-clear 'matrix)))
          (set! sv-192 (new 'stack-no-clear 'vector))
          (let ((f30-0 0.0)
                (s0-0 #f)
                )
            (set! sv-208 0)
            (while (< sv-208 4)
              (cond
                ((= sv-208 3)
                 (vector-! sv-160 sv-144 (the-as vector (&-> pp stack 368)))
                 (set! (-> s5-0 vector sv-208 z) 0.0)
                 )
                (else
                  (vector-! sv-160 sv-144 (-> arg0 0 vertex sv-208))
                  (set! (-> s5-0 vector sv-208 z) (vector-dot sv-160 (-> *camera* local-down)))
                  (vector-! sv-160 (-> arg0 0 vertex sv-208) (the-as vector (&-> pp stack 368)))
                  )
                )
              (vector-flatten! sv-160 sv-160 (-> *camera* local-down))
              (vector-cross! sv-176 sv-160 arg2)
              (let ((f28-0 (vector-dot sv-176 (-> *camera* local-down))))
                (cond
                  ((< (* f28-0 f30-0) 0.0)
                   (set! s0-0 #t)
                   )
                  ((!= f28-0 0.0)
                   (set! f30-0 f28-0)
                   )
                  )
                (set! (-> s5-0 vector sv-208 x) (vector-dot sv-160 arg2))
                (cond
                  ((= sv-208 3)
                   (vector-! sv-192 sv-144 (the-as vector (&-> pp stack 368)))
                   (vector-flatten! sv-192 sv-192 arg1)
                   )
                  (else
                    (vector--float*! sv-192 sv-160 arg2 (-> s5-0 vector sv-208 x))
                    )
                  )
                (if (< f28-0 0.0)
                    (set! (-> s5-0 vector sv-208 y) (- (vector-length sv-192)))
                    (set! (-> s5-0 vector sv-208 y) (vector-length sv-192))
                    )
                )
              (set! (-> s5-0 vector sv-208 x) (- sv-128 (-> s5-0 vector sv-208 x)))
              (set! sv-208 (+ sv-208 1))
              )
            (cond
              ((and s0-0 (!= s4-0 -100000000.0))
               (dotimes (s4-1 4)
                 (dist-info-append
                   (the-as collide-los-dist-info (-> gp-0 vert-0))
                   (the-as vector (+ (the-as uint s5-0) (* s4-1 16)))
                   )
                 )
               #f
               )
              ((< (-> s5-0 vector 3 y) 0.0)
               (dotimes (s4-2 4)
                 (when (>= (-> s5-0 vector 3 y) (-> s5-0 vector s4-2 y))
                   (set! (-> s5-0 vector s4-2 y) (- (-> s5-0 vector s4-2 y)))
                   (dist-info-append
                     (the-as collide-los-dist-info (-> gp-0 next-normal))
                     (the-as vector (+ (the-as uint s5-0) (* s4-2 16)))
                     )
                   )
                 )
               #f
               )
              (else
                (dotimes (s4-3 4)
                  (if (>= (-> s5-0 vector s4-3 y) (-> s5-0 vector 3 y))
                      (dist-info-append
                        (the-as collide-los-dist-info (-> gp-0 intersection))
                        (the-as vector (+ (the-as uint s5-0) (* s4-3 16)))
                        )
                      )
                  )
                #f
                )
              )
            )
          )
        )
      )
    )
  )

(defun cam-los-spline-collide ((arg0 vector) (arg1 vector) (arg2 pat-surface))
  (let ((s5-0 (new 'stack-no-clear 'vector))
        (s4-0 *collide-cache*)
        (f30-0 2.0)
        )
    0.0
    (vector-! s5-0 arg1 arg0)
    (fill-using-line-sphere
      s4-0
      arg0
      s5-0
      (-> *CAM_STRING-bank* los-coll-rad2)
      (collide-kind background cak-3 wall-object ground-object cak-14)
      (the-as process-drawable #f)
      arg2
      )
    (let* ((f0-2 (vector-length s5-0))
           (f28-0
             (cond
               ((< f0-2 (-> *CAMERA-bank* min-detectable-velocity))
                0.0
                )
               (else
                 (let* ((f0-3 (/ (* 3.0 (- (-> *CAM_STRING-bank* los-coll-rad2) (-> *CAMERA-bank* collide-move-rad))) f0-2))
                        (f0-4 (- 1.0 f0-3))
                        )
                   (fmin 1.0 (fmax 0.0 f0-4))
                   )
                 )
               )
             )
           (s3-0 (-> s4-0 tris))
           (s2-0 (new 'stack-no-clear 'vector))
           (s1-0 (new 'stack-no-clear 'vector))
           )
      (countdown (s4-1 (-> s4-0 num-tris))
        (let ((f0-7 (moving-sphere-triangle-intersect arg0 s5-0 (-> *CAM_STRING-bank* los-coll-rad2) (-> s3-0 0) s2-0 s1-0))
              )
          (cond
            ((or (< f0-7 0.0) (< f28-0 f0-7))
             )
            ((< f0-7 f30-0)
             (set! f30-0 f0-7)
             )
            )
          )
        (set! s3-0 (the-as (inline-array collide-cache-tri) (-> s3-0 1)))
        )
      )
    (if (= f30-0 2.0)
        (set! f30-0 -1.0)
        )
    f30-0
    )
  )

(defbehavior cam-los-setup-lateral camera-slave ((arg0 clip-travel-vector-to-mesh-return-info) (arg1 vector) (arg2 vector))
  (cond
    ((dist-info-valid? (the-as collide-los-dist-info (-> arg0 vert-0)))
     (let ((f30-0 (-> arg0 vert-0 z))
           (f28-0 (-> arg0 vert-0 w))
           )
       (if (dist-info-valid? (the-as collide-los-dist-info (-> arg0 intersection)))
           (set! f28-0 (fmax f28-0 (-> arg0 intersection w)))
           )
       (if (dist-info-valid? (the-as collide-los-dist-info (-> arg0 next-normal)))
           (set! f30-0 (fmin f30-0 (- (-> arg0 next-normal w))))
           )
       (cond
         ((= (-> self los-state) (slave-los-state ccw))
          (if *display-cam-los-debug*
              (format *stdcon* "straddle stick ccw~%")
              )
          (vector-normalize! arg1 (+ f28-0 (-> *CAM_STRING-bank* los-coll-rad)))
          )
         ((= (-> self los-state) (slave-los-state cw))
          (if *display-cam-los-debug*
              (format *stdcon* "straddle stick cw~%")
              )
          (vector-normalize! arg1 (- f30-0 (-> *CAM_STRING-bank* los-coll-rad)))
          )
         ((and (or (< 0.01 (-> arg0 vert-1 y))
                   (and (dist-info-valid? (the-as collide-los-dist-info (-> arg0 next-normal)))
                        (< 0.01 (the-as float (-> arg0 gap-poly)))
                        )
                   )
               (or (< (-> arg0 vert-1 x) -0.01)
                   (and (dist-info-valid? (the-as collide-los-dist-info (-> arg0 next-normal)))
                        (< (the-as float (-> arg0 poly)) -0.01)
                        )
                   )
               (and (dist-info-valid? (the-as collide-los-dist-info (-> arg0 intersection)))
                    (or (< (-> arg0 boundary-normal y) 0.01) (< -0.01 (-> arg0 boundary-normal x)))
                    )
               )
          (when (not (dist-info-valid? (the-as collide-los-dist-info (-> arg0 next-normal))))
            )
          (if (not (dist-info-valid? (the-as collide-los-dist-info (-> arg0 intersection))))
              (format #t "s diag ccw invalid cw~%")
              )
          (if *display-cam-los-debug*
              (format *stdcon* "straddle diagonal ccw~%")
              )
          (set! (-> self los-state) (slave-los-state ccw))
          (vector-normalize! arg1 (+ f28-0 (-> *CAM_STRING-bank* los-coll-rad)))
          )
         ((and (or (< 0.01 (-> arg0 vert-1 w))
                   (and (dist-info-valid? (the-as collide-los-dist-info (-> arg0 intersection)))
                        (< 0.01 (-> arg0 boundary-normal y))
                        )
                   )
               (or (< (-> arg0 vert-1 z) -0.01)
                   (and (dist-info-valid? (the-as collide-los-dist-info (-> arg0 intersection)))
                        (< (-> arg0 boundary-normal x) -0.01)
                        )
                   )
               (and (dist-info-valid? (the-as collide-los-dist-info (-> arg0 next-normal)))
                    (or (< (the-as float (-> arg0 gap-poly)) 0.01) (< -0.01 (the-as float (-> arg0 poly))))
                    )
               )
          (if (not (dist-info-valid? (the-as collide-los-dist-info (-> arg0 next-normal))))
              (format #t "s diag cw invalid ccw~%")
              )
          (when (not (dist-info-valid? (the-as collide-los-dist-info (-> arg0 intersection))))
            )
          (if *display-cam-los-debug*
              (format *stdcon* "straddle diagonal cw~%")
              )
          (set! (-> self los-state) (slave-los-state cw))
          (vector-normalize! arg1 (- f30-0 (-> *CAM_STRING-bank* los-coll-rad)))
          )
         ((< f28-0 (- f30-0))
          (if *display-cam-los-debug*
              (format *stdcon* "straddle ccw~%")
              )
          (set! (-> self los-state) (slave-los-state ccw))
          (vector-normalize! arg1 (+ f28-0 (-> *CAM_STRING-bank* los-coll-rad)))
          )
         (else
           (if *display-cam-los-debug*
               (format *stdcon* "straddle cw~%")
               )
           (set! (-> self los-state) (slave-los-state cw))
           (vector-normalize! arg1 (- f30-0 (-> *CAM_STRING-bank* los-coll-rad)))
           )
         )
       )
     )
    ((and (dist-info-valid? (the-as collide-los-dist-info (-> arg0 intersection)))
          (dist-info-valid? (the-as collide-los-dist-info (-> arg0 next-normal)))
          (< 0.01 (the-as float (-> arg0 gap-poly)))
          (< (the-as float (-> arg0 poly)) -0.01)
          (or (< (-> arg0 boundary-normal y) 0.01) (< -0.01 (-> arg0 boundary-normal x)))
          )
     (if *display-cam-los-debug*
         (format *stdcon* "diagonal ccw~%")
         )
     (set! (-> self los-state) (slave-los-state ccw))
     (vector-normalize! arg1 (- (-> *CAM_STRING-bank* los-coll-rad) (-> arg0 next-normal z)))
     )
    ((and (dist-info-valid? (the-as collide-los-dist-info (-> arg0 intersection)))
          (dist-info-valid? (the-as collide-los-dist-info (-> arg0 next-normal)))
          (< 0.01 (-> arg0 boundary-normal y))
          (< (-> arg0 boundary-normal x) -0.01)
          (or (< (the-as float (-> arg0 gap-poly)) 0.01) (< -0.01 (the-as float (-> arg0 poly))))
          )
     (if *display-cam-los-debug*
         (format *stdcon* "diagonal cw~%")
         )
     (set! (-> self los-state) (slave-los-state cw))
     (vector-normalize! arg1 (- (-> arg0 intersection z) (-> *CAM_STRING-bank* los-coll-rad)))
     )
    ((and (dist-info-valid? (the-as collide-los-dist-info (-> arg0 intersection)))
          (dist-info-valid? (the-as collide-los-dist-info (-> arg0 next-normal)))
          )
     (set! (-> self los-state) (slave-los-state between))
     (vector-normalize! arg1 (the-as float 0.0001))
     )
    ((dist-info-valid? (the-as collide-los-dist-info (-> arg0 intersection)))
     (if *display-cam-los-debug*
         (format *stdcon* "regular cw~%")
         )
     (set! (-> self los-state) (slave-los-state cw))
     (vector-normalize! arg1 (- (-> arg0 intersection z) (-> *CAM_STRING-bank* los-coll-rad)))
     )
    ((dist-info-valid? (the-as collide-los-dist-info (-> arg0 next-normal)))
     (if *display-cam-los-debug*
         (format *stdcon* "regular ccw~%")
         )
     (set! (-> self los-state) (slave-los-state ccw))
     (vector-normalize! arg1 (- (-> *CAM_STRING-bank* los-coll-rad) (-> arg0 next-normal z)))
     )
    (else
      (set! (-> self los-state) (slave-los-state none))
      (vector-reset! arg1)
      )
    )
  (cond
    ((= (vector-length arg1) 0.0)
     (set! (-> arg0 vert-next y) (the-as float #f))
     #f
     )
    (else
      (vector-! (the-as vector (&-> arg0 found-boundary)) arg1 arg2)
      (vector-normalize! (the-as vector (&-> arg0 found-boundary)) (the-as float 1.0))
      (let ((v0-45 #t))
        (set! (-> arg0 vert-next y) (the-as float v0-45))
        v0-45
        )
      )
    )
  )

;; ERROR: Unsupported inline assembly instruction kind - [mula.s f2, f5]
;; ERROR: Unsupported inline assembly instruction kind - [madda.s f3, f6]
;; ERROR: Unsupported inline assembly instruction kind - [madd.s f2, f4, f7]
(defbehavior cam-los-collide camera-slave ((arg0 vector) (arg1 vector) (arg2 clip-travel-vector-to-mesh-return-info) (arg3 pat-surface))
  (local-vars (s1-3 int) (s2-2 int) (f2-1 float) (sv-224 vector) (sv-240 vector))
  (dist-info-init (the-as collide-los-dist-info (-> arg2 intersection)))
  (dist-info-init (the-as collide-los-dist-info (-> arg2 next-normal)))
  (dist-info-init (the-as collide-los-dist-info (-> arg2 vert-0)))
  (let ((s4-0 (new 'stack-no-clear 'vector))
        (s2-0 (new 'stack-no-clear 'vector))
        )
    (vector-normalize-copy! s2-0 arg1 (the-as float 1.0))
    (vector-flatten! s4-0 arg1 (-> *camera* local-down))
    (let ((s0-0 *collide-cache*)
          (f26-0 (vector-length arg1))
          (f30-0 (vector-normalize-ret-len! s4-0 (the-as float 1.0)))
          )
      (fill-using-line-sphere
        s0-0
        arg0
        arg1
        (-> *CAM_STRING-bank* los-coll-rad)
        (collide-kind background cak-3 wall-object ground-object cak-14)
        (the-as process-drawable #f)
        arg3
        )
      (let ((s1-1 (-> s0-0 tris))
            (f28-0 (/ 2048.0 f26-0))
            (f26-1 (/ (+ -8192.0 f26-0) f26-0))
            )
        (if (< f26-1 0.0)
            (set! f26-1 0.0)
            )
        (if (< 1.0 f28-0)
            (set! f28-0 1.0)
            )
        (countdown (s0-1 (-> s0-0 num-tris))
          (set! sv-240 (new 'stack-no-clear 'vector))
          (set! sv-224 (new 'stack-no-clear 'vector))
          (let ((f0-7
                  (moving-sphere-triangle-intersect arg0 arg1 (-> *CAM_STRING-bank* los-coll-rad) (-> s1-1 0) sv-240 sv-224)
                  )
                )
            (cond
              ((or (< f0-7 0.0) (< 1.0 f0-7))
               )
              ((let ((f1-2 0.0))
                 (let* ((v1-21 arg1)
                        (f2-0 (-> v1-21 x))
                        (f3-0 (-> v1-21 y))
                        (f4-0 (-> v1-21 z))
                        (f5-0 (-> sv-224 x))
                        (f6-0 (-> sv-224 y))
                        (f7-0 (-> sv-224 z))
                        )
                   ; (.mula.s f2-0 f5-0)
                   ; (.madda.s f3-0 f6-0)
                   ; (.madd.s f2-1 f4-0 f7-0)
                   (set! f2-1 (+ (* f2-0 f5-0) (* f3-0 f6-0) (* f4-0 f7-0)))
                   )
                 (< f1-2 f2-1)
                 )
               (when (< f28-0 f0-7)
                 (let* ((t1-2 (new 'stack-no-clear 'vector))
                        (t0-2 (new 'stack-no-clear 'vector))
                        (f24-0
                          (moving-sphere-triangle-intersect arg0 arg1 (-> *CAM_STRING-bank* los-coll-rad2) (-> s1-1 0) t0-2 t1-2)
                          )
                        )
                   (los-cw-ccw s1-1 s2-0 s4-0 f30-0 arg2 sv-240 f24-0)
                   (when *debug-segment*
                     (cond
                       ((= f24-0 -100000000.0)
                        (let ((t9-11 cam-debug-add-los-tri)
                              (a0-13 s1-1)
                              (a2-7 (new 'static 'vector :x (the-as float #x80) :w (the-as float #x80)))
                              )
                          (t9-11 a0-13 sv-240 a2-7)
                          )
                        )
                       (else
                         (cam-debug-add-los-tri
                           s1-1
                           sv-240
                           (new 'static 'vector :x (the-as float #x80) :y (the-as float #x80) :w (the-as float #x80))
                           )
                         )
                       )
                     )
                   )
                 )
               )
              ((< f0-7 f26-1)
               (let* ((t1-4 (new 'stack-no-clear 'vector))
                      (t0-4 (new 'stack-no-clear 'vector))
                      (f24-1
                        (moving-sphere-triangle-intersect arg0 arg1 (-> *CAM_STRING-bank* los-coll-rad2) (-> s1-1 0) t0-4 t1-4)
                        )
                      )
                 (los-cw-ccw s1-1 s2-0 s4-0 f30-0 arg2 sv-240 f24-1)
                 (when *debug-segment*
                   (if (= f24-1 -100000000.0)
                       (cam-debug-add-los-tri s1-1 sv-240 (new 'static 'vector :y (the-as float #x80) :w (the-as float #x80)))
                       (cam-debug-add-los-tri s1-1 sv-240 (new 'static 'vector :z (the-as float #x80) :w (the-as float #x80)))
                       )
                   )
                 )
               )
              )
            )
          (set! s1-1 (the-as (inline-array collide-cache-tri) (-> s1-1 1)))
          )
        )
      )
    )
  (let ((s4-1 (new 'stack-no-clear 'vector)))
    0.0
    (vector-cross! s4-1 arg1 (-> *camera* local-down))
    (cond
      ((!= (-> self los-tgt-spline-pt-incarnation)
           (-> *camera* target-spline point (-> self los-tgt-spline-pt) incarnation)
           )
       (when *display-cam-los-debug*
         (format *stdcon* "emergency point jump~%")
         (format 0 "emergency point jump~%")
         )
       (set! (-> self los-tgt-spline-pt) (-> *camera* target-spline used-point))
       (set! (-> self los-tgt-spline-pt-incarnation)
             (-> *camera* target-spline point (-> self los-tgt-spline-pt) incarnation)
             )
       (logior! (-> self options) 4096)
       (set! (-> self good-point quad)
             (-> *camera* target-spline point (-> *camera* target-spline used-point) position quad)
             )
       (set! (-> self los-last-pos quad) (-> self good-point quad))
       (when *debug-segment*
         (let ((a1-22 (new 'stack-no-clear 'vector)))
           (vector-! a1-22 (-> self good-point) (-> self string-trans))
           (cam-collision-record-save (-> self string-trans) a1-22 -3 'jump self)
           )
         )
       (set! (-> self desired-pos quad) (-> self good-point quad))
       (set! (-> self string-trans quad) (-> self good-point quad))
       (vector-! (-> self view-flat) (-> self string-trans) (-> *camera* tpos-curr-adj))
       (vector-flatten! (-> self view-flat) (-> self view-flat) (-> *camera* local-down))
       (vector-reset! (-> self velocity))
       (let ((f0-11 (vector-length (-> self view-flat))))
         (if (< f0-11 (-> self min-z-override))
             (set! (-> self min-z-override) f0-11)
             )
         )
       )
      (else
        (let ((f30-1
                (cam-los-spline-collide
                  (the-as vector (+ (the-as uint (-> *camera* target-spline)) (* 48 (-> *camera* target-spline end-point))))
                  arg0
                  (new 'static 'pat-surface :nocamera #x1 :nolineofsight #x1)
                  )
                )
              )
          (cond
            ((< f30-1 0.0)
             (if *display-cam-los-debug*
                 (format *stdcon* "good ~f~%" f30-1)
                 )
             (set! (-> self los-tgt-spline-pt) (-> *camera* target-spline end-point))
             (set! (-> self los-tgt-spline-pt-incarnation)
                   (-> *camera* target-spline point (-> self los-tgt-spline-pt) incarnation)
                   )
             (set! (-> self los-last-pos quad) (-> arg0 quad))
             )
            ((begin
               (if *display-cam-los-debug*
                   (format
                     *stdcon*
                     "looking vel ~M u ~f pt ~D"
                     (vector-length (-> self velocity))
                     f30-1
                     (-> self los-tgt-spline-pt)
                     )
                   )
               (set! s2-2 (-> self los-tgt-spline-pt))
               (set! s1-3 -134250495)
               (while (and (!= s2-2 -134250495)
                           (begin
                             (set! f30-1
                                   (cam-los-spline-collide
                                     (the-as vector (+ (the-as uint (-> *camera* target-spline)) (* 48 s2-2)))
                                     arg0
                                     (new 'static 'pat-surface :nocamera #x1 :nolineofsight #x1)
                                     )
                                   )
                             (< f30-1 0.0)
                             )
                           )
                 (set! s1-3 s2-2)
                 (set! s2-2 (-> *camera* target-spline point s2-2 next))
                 )
               (and (= s2-2 (-> *camera* target-spline used-point))
                    (!= (-> *camera* target-spline point s2-2 next) -134250495)
                    )
               )
             (when *display-cam-los-debug*
               (format 0 "looking at used point~%")
               (format *stdcon* " at used point~%")
               )
             (set! (-> self los-tgt-spline-pt) (-> *camera* target-spline point s2-2 next))
             (set! (-> self los-tgt-spline-pt-incarnation)
                   (-> *camera* target-spline point (-> self los-tgt-spline-pt) incarnation)
                   )
             (logior! (-> self options) 4096)
             (set! (-> self good-point quad) (-> *camera* target-spline point s2-2 position quad))
             (set! (-> self los-last-pos quad) (-> self good-point quad))
             (when *debug-segment*
               (let ((a1-38 (new 'stack-no-clear 'vector)))
                 (vector-! a1-38 (-> self good-point) (-> self string-trans))
                 (cam-collision-record-save (-> self string-trans) a1-38 -3 'jump self)
                 )
               )
             (set! (-> self desired-pos quad) (-> self good-point quad))
             (set! (-> self string-trans quad) (-> self good-point quad))
             (vector-! (-> self view-flat) (-> self string-trans) (-> *camera* tpos-curr-adj))
             (vector-flatten! (-> self view-flat) (-> self view-flat) (-> *camera* local-down))
             (vector-reset! (-> self velocity))
             (let ((f0-14 (vector-length (-> self view-flat))))
               (if (< f0-14 (-> self min-z-override))
                   (set! (-> self min-z-override) f0-14)
                   )
               )
             )
            ((!= s1-3 -134250495)
             (if *display-cam-los-debug*
                 (format *stdcon* " ok~%")
                 )
             (set! (-> self los-tgt-spline-pt) s1-3)
             (set! (-> self los-tgt-spline-pt-incarnation)
                   (-> *camera* target-spline point (-> self los-tgt-spline-pt) incarnation)
                   )
             (set! (-> self los-last-pos quad) (-> arg0 quad))
             )
            (else
              (if *display-cam-los-debug*
                  (format *stdcon* "~%failed u ~f cur ~D seen ~D tgt-pt ~D~%" f30-1 s2-2 s1-3 (-> self los-tgt-spline-pt))
                  )
              (let ((s3-1 (new 'stack-no-clear 'vector)))
                0.0
                (vector-!
                  s3-1
                  (-> self los-last-pos)
                  (the-as vector (+ (the-as uint (-> *camera* target-spline)) (* 48 (-> self los-tgt-spline-pt))))
                  )
                (let ((f28-1 (vector-length s3-1)))
                  (if (= f28-1 0.0)
                      (set! f28-1 0.4096)
                      )
                  (let ((f30-2 (cond
                                 ((and (= (-> self string-vel-dir) 6)
                                       (< (-> *CAMERA-bank* min-detectable-velocity) (vector-length (-> self velocity)))
                                       )
                                  (fmin 1.0 (+ 0.001 f30-1))
                                  )
                                 ((= (-> self string-vel-dir) 6)
                                  (fmin 0.9999 f30-1)
                                  )
                                 (else
                                   (fmax 0.001 (+ -0.001 f30-1))
                                   )
                                 )
                               )
                        )
                    (let ((s2-3 (new 'stack-no-clear 'vector)))
                      (vector-!
                        s2-3
                        (-> *camera* tpos-curr-adj)
                        (the-as vector (+ (the-as uint (-> *camera* target-spline)) (* 48 (-> self los-tgt-spline-pt))))
                        )
                      (vector-flatten! s2-3 s2-3 (-> *camera* local-down))
                      (cond
                        ((and (< (fabs (- (-> self desired-pos y) (-> self trans y))) 8192.0)
                              (< f28-1 (+ 1024.0 (-> self string-min-val z)))
                              (< (vector-length s2-3) 8192.0)
                              )
                         (set! f30-2 0.0)
                         )
                        ((< f28-1 (+ 1024.0 (-> self string-min-val z)))
                         )
                        ((< (* f28-1 f30-2) (-> self string-min-val z))
                         (set! f30-2 (/ (-> self string-min-val z) f28-1))
                         )
                        )
                      )
                    (when (< 0.0 f30-2)
                      (vector-! s3-1 (-> *camera* tpos-curr) (-> *camera* tpos-old))
                      (vector-!
                        (-> self good-point)
                        (-> self los-last-pos)
                        (the-as vector (+ (the-as uint (-> *camera* target-spline)) (* 48 (-> self los-tgt-spline-pt))))
                        )
                      (vector-float*! (-> self good-point) (-> self good-point) f30-2)
                      (vector+!
                        (-> self good-point)
                        (-> self good-point)
                        (the-as vector (+ (the-as uint (-> *camera* target-spline)) (* 48 (-> self los-tgt-spline-pt))))
                        )
                      (set! (-> self los-last-pos quad) (-> self good-point quad))
                      (when *display-cam-los-debug*
                        (format 0 "going because u(~f) > 0 frame ~D~%" f30-2 (-> *display* base-frame-counter))
                        (format *stdcon* " going because u(~f) > 0 frame ~D~%" f30-2 (-> *display* base-frame-counter))
                        )
                      (logior! (-> self options) 4096)
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    (if *display-cam-los-debug*
        (format
          *stdcon*
          "los-last ~M ~M ~M~%"
          (-> self los-last-pos x)
          (-> self los-last-pos y)
          (-> self los-last-pos z)
          )
        )
    (cam-los-setup-lateral arg2 s4-1 arg1)
    )
  (cond
    ((not (logtest? (-> self options) 1024))
     )
    ((= (-> self string-vel-dir) 5)
     )
    ((and (= (-> self string-vel-dir) 2) (= (-> self los-state) (slave-los-state cw)))
     )
    ((and (= (-> self string-vel-dir) 1) (= (-> self los-state) (slave-los-state ccw)))
     )
    )
  (when *display-cam-los-debug*
    (format *stdcon* "state ~S" (slave-los-state->string (-> self los-state)))
    (cond
      ((zero? (-> self string-vel-dir))
       (format *stdcon* " vzero")
       )
      ((= (-> self string-vel-dir) 2)
       (format *stdcon* " vcw")
       )
      ((= (-> self string-vel-dir) 1)
       (format *stdcon* " vccw")
       )
      ((= (-> self string-vel-dir) 3)
       (format *stdcon* " up")
       )
      ((= (-> self string-vel-dir) 4)
       (format *stdcon* " down")
       )
      ((= (-> self string-vel-dir) 6)
       (format *stdcon* " long")
       )
      ((= (-> self string-vel-dir) 5)
       (format *stdcon* " short")
       )
      )
    (format *stdcon* "~%")
    )
  (when *display-cam-los-info*
    (dist-info-print (the-as collide-los-dist-info (-> arg2 intersection)) "cw   ")
    (dist-info-print (the-as collide-los-dist-info (-> arg2 next-normal)) "ccw  ")
    (dist-info-print (the-as collide-los-dist-info (-> arg2 vert-0)) "strdl")
    )
  (the-as symbol 0)
  )

(defbehavior cam-string-follow camera-slave ()
  (let ((f30-0 (vector-length (-> self view-flat))))
    (cond
      ((logtest? #x10000 (-> self options))
       (let ((gp-0 (new 'stack-no-clear 'vector)))
         (let ((s5-0 (new 'stack-no-clear 'vector)))
           (vector-cross! s5-0 (-> self view-flat) (-> *camera* local-down))
           (vector-normalize! s5-0 (the-as float 1.0))
           (vector-! gp-0 (-> *camera* tpos-curr-adj) (-> *camera* tpos-old-adj))
           (vector-flatten! gp-0 gp-0 s5-0)
           )
         (if (< (vector-dot gp-0 (-> self view-flat)) 0.0)
             (vector-! (-> self view-flat) (-> self view-flat) gp-0)
             )
         )
       )
      (else
        (let ((v1-9 (new 'stack-no-clear 'vector)))
          (vector-! v1-9 (-> *camera* tpos-curr-adj) (-> *camera* tpos-old-adj))
          (vector-! (-> self view-flat) (-> self view-flat) v1-9)
          )
        )
      )
    (vector-flatten! (-> self view-flat) (-> self view-flat) (-> *camera* local-down))
    (let* ((f28-0 (vector-length (-> self view-flat)))
           (f0-3 (fmin (-> *camera* string-push-z) (-> self view-off z)))
           (f26-0 (-> self view-off z))
           (f0-4 (fmin f0-3 (-> self min-z-override)))
           )
      (cond
        ((logtest? (-> self options) #x4000)
         (let ((a0-17 (new-stack-vector0)))
           0.0
           (vector-! a0-17 (-> *camera* tpos-curr-adj) (-> *camera* tpos-old-adj))
           (let ((f0-6 (vector-length a0-17)))
             (set! f0-4 (lerp-clamp
                          (the-as float 28672.0)
                          (the-as float 32768.0)
                          (parameter-ease-sin-clamp (* 0.00081380206 (+ -409.6 f0-6)))
                          )
                   )
             )
           )
         (set! f26-0 f0-4)
         (+! (-> self fov) (fmax -91.022224 (fmin 91.022224 (* 0.1 (- 17294.223 (-> self fov))))))
         )
        (else
          (+! (-> self fov) (fmax -182.04445 (fmin 182.04445 (* 0.1 (- 11650.845 (-> self fov))))))
          )
        )
      (cond
        ((< f28-0 f0-4)
         (vector-normalize! (-> self view-flat) f0-4)
         )
        ((and (< f30-0 f28-0)
              (or (= (-> self los-state) (slave-los-state ccw)) (= (-> self los-state) (slave-los-state cw)))
              )
         (vector-normalize! (-> self view-flat) f30-0)
         )
        ((< f26-0 f28-0)
         (vector-normalize! (-> self view-flat) f26-0)
         (set! (-> self min-z-override) f26-0)
         f26-0
         )
        (else
          (set! (-> self min-z-override) f28-0)
          f28-0
          )
        )
      )
    )
  )

(defbehavior cam-string-line-of-sight camera-slave ()
  (let ((gp-0 (new 'stack-no-clear 'clip-travel-vector-to-mesh-return-info))
        (s5-0 (new 'stack-no-clear 'vector))
        )
    (new 'stack-no-clear 'vector)
    (let ((f30-0 (vector-length (-> self view-flat))))
      (vector--float*! s5-0 (-> *camera* tpos-curr) (-> *camera* local-down) (-> *camera* target-height))
      (vector-! s5-0 s5-0 (-> self string-trans))
      (cam-los-collide (-> self string-trans) s5-0 gp-0 (new 'static 'pat-surface :nocamera #x1 :nolineofsight #x1))
      (when (-> gp-0 vert-next y)
        (when (or (= (-> self los-state) (slave-los-state ccw)) (= (-> self los-state) (slave-los-state cw)))
          (let ((a0-6 (new 'stack-no-clear 'vector)))
            (vector-! a0-6 (-> *camera* tpos-curr) (-> *camera* tpos-old))
            (if (and (< (-> self string-min-val z) f30-0) (< (-> *CAMERA-bank* min-detectable-velocity) (vector-length a0-6)))
                (set! f30-0 (+ -204.8 f30-0))
                )
            )
          )
        (if (< f30-0 (fmin (-> self string-min-val z) (-> self min-z-override)))
            (set! f30-0 (fmin (-> self string-min-val z) (-> self min-z-override)))
            )
        (if (< f30-0 (-> self min-z-override))
            (set! (-> self min-z-override) f30-0)
            )
        (let ((s4-0 (new 'stack-no-clear 'vector))
              (s5-1 (new 'stack-no-clear 'vector))
              (s3-0 (new 'stack-no-clear 'matrix))
              )
          0.0
          (vector-flatten! s4-0 (the-as vector (&-> gp-0 found-boundary)) (-> *camera* local-down))
          (vector-normalize! s4-0 (the-as float 1.0))
          (vector-normalize-copy! s5-1 (-> self view-flat) (the-as float 1.0))
          (let ((f0-12 (lerp-clamp
                         (the-as float 418.7022)
                         (the-as float 364.0889)
                         (/ (- f30-0 (-> self string-min-val z)) (- (-> self string-max-val z) (-> self string-min-val z)))
                         )
                       )
                )
            (matrix-from-two-vectors-max-angle-partial! s3-0 s5-1 s4-0 f0-12 (the-as float 0.5))
            )
          (vector-matrix*! (-> self view-flat) (-> self view-flat) s3-0)
          )
        (vector-normalize! (-> self view-flat) f30-0)
        )
      )
    )
  )

(defun cam-dist-analog-input ((arg0 int) (arg1 float))
  (let ((f0-0 0.0))
    (cond
      ((< arg0 28)
       (set! f0-0 (- (fmin arg1 (* 0.083333336 (- 28.0 (the float arg0)) arg1))))
       )
      ((< 160 arg0)
       (set! f0-0 (fmin arg1 (* 0.0125 (+ -160.0 (the float arg0)) arg1)))
       )
    )
    ;; changed for pc port, only used for Third-Person Vertical camera
    (#if PC_PORT
      (* (if (-> *pc-settings* third-camera-v-inverted?) 1.0 -1.0) f0-0)
      f0-0
    )
  )
)

;; main third-person camera
(defbehavior cam-string-joystick camera-slave ()
  (set! (-> self options) (logand -257 (-> self options)))
  (let ((f28-0 (cam-dist-analog-input (the-as int (-> *cpad-list* cpads 0 righty)) (the-as float 0.05)))
        (f0-2 (/ (- (vector-length (-> self view-flat)) (-> self string-min-val z))
                 (- (-> self string-max-val z) (-> self string-min-val z))
                 )
              )
        (f30-0 (-> self view-off-param))
        )
    (if (-> self have-phony-joystick)
        (set! f28-0 (* 0.05 (-> self phony-joystick-y)))
        )
    (if (and (-> *camera* being-attacked)
             (< (- (-> *display* base-frame-counter) (-> *camera* attack-start)) (seconds 0.25))
             )
        (set! f28-0 0.05)
        )
    (if (!= f28-0 0.0)
        (logior! (-> self options) 256)
        )
    (let ((f26-0 (fmin 1.0 f0-2)))
      (let ((f0-3 f26-0))
        (when (< f26-0 0.0)
          (let ((f0-6
                  (/ (- (-> self string-min-val z) (vector-length (-> self view-flat))) (* 0.5 (-> self string-min-val z)))
                  )
                )
            (set! f0-3 (fmin 0.75 f0-6))
            )
          )
        (let ((f1-10 (-> self string-min-val y))
              (f2-3 (-> self string-max-val y))
              )
          (set! (-> self view-off y) (lerp f1-10 f2-3 f0-3))
          )
        )
      (when (< f26-0 0.0)
        (let ((v1-28 (new 'stack-no-clear 'vector)))
          (vector-! v1-28 (-> self string-trans) (-> *camera* tpos-curr-adj))
          (let ((f0-12 (- (- (vector-dot v1-28 (-> *camera* local-down))) (-> *camera* target-height))))
            (set! (-> self view-off y) (fmin (-> *camera* stringCliffHeight) (fmax f0-12 (-> self view-off y))))
            )
          )
        )
      (let ((f0-16 (fmax 0.0 f26-0)))
        (cond
          ((logtest? (-> self options) #x4000)
           )
          ((not *camera-read-analog*)
           )
          ((and (>= 0.0 f28-0) (>= 0.0 f0-16))
           )
          ((and (>= f28-0 0.0) (>= f0-16 1.0))
           )
          ((and (< 0.0 f28-0)
                (or (= (-> self los-state) (slave-los-state ccw)) (= (-> self los-state) (slave-los-state cw)))
                )
           )
          ((< (* 0.05 (- 1.0 f0-16)) f28-0)
           (let ((f0-17 (+ f0-16 (* 0.05 (- 1.0 f0-16)))))
             (set! (-> self view-off-param) (fmax (-> self view-off-param) f0-17))
             (vector-normalize! (-> self view-flat) (lerp (-> self string-min-val z) (-> self string-max-val z) f0-17))
             )
           )
          ((< f28-0 (* 0.05 (- f0-16)))
           (set! (-> self view-off-param) (+ f0-16 (* 0.05 (- f0-16))))
           )
          ((< 0.0 f28-0)
           (let ((f0-19 (+ f0-16 (* f28-0 (-> *display* time-adjust-ratio)))))
             (set! (-> self view-off-param) (fmax (-> self view-off-param) f0-19))
             (vector-normalize! (-> self view-flat) (lerp (-> self string-min-val z) (-> self string-max-val z) f0-19))
             )
           )
          ((< f28-0 0.0)
           (set! (-> self view-off-param) (+ f0-16 (* f28-0 (-> *display* time-adjust-ratio))))
           )
          )
        )
      )
    (if (= f28-0 0.0)
        (set! (-> self view-off z) (-> self string-max-val z))
        (set! (-> self view-off z)
              (lerp (-> self string-min-val z) (-> self string-max-val z) (-> self view-off-param))
              )
        )
    (if (-> *camera* being-attacked)
        (set! (-> self view-off-param) f30-0)
        )
    )
  (when *camera-read-analog*
    (let ((f0-29 (analog-input-horizontal-third   ;; changed for pc port
                   (the-as int (-> *cpad-list* cpads 0 rightx))
                   (the-as float 128.0)
                   (the-as float 32.0)
                   (the-as float 110.0)
                   (* 21845.334 (-> *display* seconds-per-frame))
                   )
                 )
          (s4-0 (new-stack-matrix0))
          (gp-2 (new-stack-vector0))
          (s5-2 (new-stack-vector0))
          )
      (if (-> self have-phony-joystick)
          (set! f0-29 (* 21845.334 (-> self phony-joystick-x) (-> *display* seconds-per-frame)))
          )
      (cond
        ((and (= (-> self los-state) (slave-los-state ccw)) (< 0.0 f0-29))
         (let ((f0-34
                 (fmax (-> self string-min-val z) (fmin (-> self string-max-val z) (vector-length (-> self view-flat))))
                 )
               )
           (set! f0-29 (* 21845.334 (+ 0.1 (/ (-> self string-min-val z) f0-34)) (-> *display* seconds-per-frame)))
           )
         )
        ((and (= (-> self los-state) (slave-los-state cw)) (< f0-29 0.0))
         (let ((f0-40
                 (fmax (-> self string-min-val z) (fmin (-> self string-max-val z) (vector-length (-> self view-flat))))
                 )
               )
           (set! f0-29 (* -21845.334 (+ 0.1 (/ (-> self string-min-val z) f0-40)) (-> *display* seconds-per-frame)))
           )
         )
        )
      (cond
        ((!= f0-29 0.0)
         (logior! (-> self options) 256)
         (matrix-axis-angle! s4-0 (-> *camera* local-down) f0-29)
         (vector-matrix*! (-> self view-flat) (-> self view-flat) s4-0)
         )
        ((logtest? (-> self options) 1)
         (vector-normalize-copy! gp-2 (-> self view-flat) (the-as float 1.0))
         (vector-flatten! s5-2 (-> *camera* tgt-rot-mat vector 2) (-> *camera* local-down))
         (vector-normalize! s5-2 (the-as float -1.0))
         (matrix-from-two-vectors-max-angle-partial!
           s4-0
           gp-2
           s5-2
           (* 10922.667 (-> *display* seconds-per-frame))
           (the-as float 0.05)
           )
         (vector-matrix*! (-> self view-flat) (-> self view-flat) s4-0)
         )
        )
      (when (logtest? (-> self options) #x4000)
        (vector-normalize-copy! gp-2 (-> self view-flat) (the-as float 1.0))
        (vector-flatten! s5-2 (-> *camera* tgt-rot-mat vector 2) (-> *camera* local-down))
        (vector-normalize! s5-2 (the-as float -1.0))
        (let ((f0-47 (acos (vector-dot s5-2 gp-2))))
          (when (and (< 8192.0 f0-47) (< f0-47 32585.955))
            (matrix-from-two-vectors-max-angle! s4-0 gp-2 s5-2 (fmin 546.13336 (* 0.5 (+ -8192.0 f0-47))))
            (vector-matrix*! (-> self view-flat) (-> self view-flat) s4-0)
            )
          )
        )
      )
    )
  )

(defbehavior cam-string-find-hidden camera-slave ()
  (let ((s4-0 (new 'stack-no-clear 'collide-tri-result))
        (s5-0 (new 'stack-no-clear 'vector))
        (gp-0 (new 'stack-no-clear 'vector))
        )
    (vector--float*! s5-0 (-> *camera* tpos-curr-adj) (-> *camera* local-down) (-> *camera* target-height))
    (vector-! s5-0 s5-0 (-> self string-trans))
    (cond
      ((< (fill-and-probe-using-line-sphere
            *collide-cache*
            (-> self string-trans)
            s5-0
            (the-as float 40.96)
            (collide-kind background cak-3 wall-object ground-object cak-14)
            (the-as process #f)
            s4-0
            (new 'static 'pat-surface :nocamera #x1)
            )
          0.0
          )
       (set! (-> self time-dist-too-far) (the-as uint 0))
       0
       )
      ((< (-> self time-dist-too-far) (the-as uint 600))
       (+! (-> self time-dist-too-far) 1)
       )
      ((cam-string-find-position-rel! gp-0)
       (cam-string-set-position-rel! gp-0)
       (set! (-> self time-dist-too-far) (the-as uint 0))
       0
       )
      (else
        (format 0 "camera position search failed~%")
        (set! (-> self time-dist-too-far) (the-as uint 0))
        0
        )
      )
    )
  (none)
  )

;; WARN: Stack slot load at 240 mismatch: defined as size 4, got size 16
;; WARN: Stack slot load at 256 mismatch: defined as size 4, got size 16
;; WARN: Stack slot load at 240 mismatch: defined as size 4, got size 16
;; WARN: Stack slot load at 256 mismatch: defined as size 4, got size 16
;; WARN: Stack slot load at 240 mismatch: defined as size 4, got size 16
;; WARN: Stack slot load at 256 mismatch: defined as size 4, got size 16
(defbehavior cam-string-move camera-slave ()
  (local-vars (sv-240 float) (sv-256 float))
  (vector-! (-> self velocity) (-> self desired-pos) (-> self string-trans))
  (if *display-cam-los-debug*
      (format *stdcon* "vel ~M~%" (vector-length (-> self velocity)))
      )
  (let ((s5-1 (new 'stack-no-clear 'vector))
        (s4-1 (new 'stack-no-clear 'vector))
        (gp-1 (new 'stack-no-clear 'vector))
        (s3-0 (new 'stack-no-clear 'vector))
        )
    (vector-! s3-0 (-> *camera* tpos-curr-adj) (-> *camera* tpos-old-adj))
    (vector+float*! s5-1 (-> self velocity) s3-0 (the-as float 0.5))
    (vector-normalize! s5-1 (the-as float 1.0))
    (vector-normalize-copy! s4-1 (-> self view-flat) (the-as float 1.0))
    (vector-cross! gp-1 s4-1 s5-1)
    (cond
      ((and (< (vector-length (-> self velocity)) (-> *CAMERA-bank* min-detectable-velocity))
            (< (vector-length s3-0) (-> *CAMERA-bank* min-detectable-velocity))
            )
       (set! (-> self string-vel-dir) (the-as uint 0))
       0
       )
      ((< (cos (the-as float 5461.3335)) (vector-dot (-> *camera* local-down) s5-1))
       (set! (-> self string-vel-dir) (the-as uint 4))
       )
      ((< (vector-dot (-> *camera* local-down) s5-1) (- (cos (the-as float 5461.3335))))
       (set! (-> self string-vel-dir) (the-as uint 3))
       )
      ((< (cos (the-as float 5461.3335)) (vector-dot s4-1 s5-1))
       (set! (-> self string-vel-dir) (the-as uint 6))
       )
      ((< (vector-dot s4-1 s5-1) (- (cos (the-as float 5461.3335))))
       (set! (-> self string-vel-dir) (the-as uint 5))
       )
      ((< (vector-dot (-> *camera* local-down) gp-1) 0.0)
       (set! (-> self string-vel-dir) (the-as uint 1))
       )
      (else
        (set! (-> self string-vel-dir) (the-as uint 2))
        )
      )
    )
  0.0
  (let ((f30-2 1.0)
        (s5-2 (new-stack-vector0))
        (gp-2 0)
        )
    (let ((s4-2 (new 'stack-no-clear 'collide-tri-result))
          (s3-1 (new 'stack-no-clear 'vector))
          )
      (when *debug-segment*
        (if (>= (-> *CAMERA-bank* min-detectable-velocity) (vector-length (-> self velocity)))
            (cam-collision-record-save (-> self string-trans) (-> self velocity) -1 'no-hit self)
            )
        )
      (while (and (< 0.01 f30-2)
                  (and (< (-> *CAMERA-bank* min-detectable-velocity) (vector-length (-> self velocity))) (< gp-2 4))
                  )
        (vector-float*! s5-2 (-> self velocity) f30-2)
        (if *debug-segment*
            (cam-collision-record-save (-> self string-trans) s5-2 gp-2 'normal self)
            )
        (let ((f28-1 (if (logtest? (-> self options) 32)
                         (fill-and-probe-using-line-sphere
                           *collide-cache*
                           (-> self string-trans)
                           s5-2
                           (-> *CAMERA-bank* collide-move-rad)
                           (collide-kind background cak-3 wall-object ground-object cak-14)
                           (the-as process #f)
                           s4-2
                           (new 'static 'pat-surface :nocamera #x1)
                           )
                         -100000000.0
                         )
                     )
              )
          (when *display-cam-los-debug*
            (let ((s2-0 format)
                  (s1-0 *stdcon*)
                  (s0-0 "vp ~f vr ~f r ~f ta ~f~%")
                  )
              (set! sv-240 (vector-length s5-2))
              (set! sv-256 f30-2)
              (let ((t0-3 (/ (vector-length s5-2) f30-2))
                    (t1-1 f28-1)
                    )
                (s2-0 s1-0 s0-0 sv-240 sv-256 t0-3 t1-1)
                )
              )
            )
          (cond
            ((>= f28-1 0.0)
             (let* ((f1-7 (fmax 0.01 (/ 40.96 (vector-length s5-2))))
                    (f0-24 (fmax 0.0 (- f28-1 f1-7)))
                    )
               (vector+float*! (-> self string-trans) (-> self string-trans) s5-2 f0-24)
               )
             (vector-! s3-1 (-> self string-trans) (-> s4-2 intersect))
             (vector-normalize! s3-1 (the-as float 1.0))
             (vector-flatten! (-> self velocity) (-> self velocity) s3-1)
             (set! f30-2 (- f30-2 (* f30-2 f28-1)))
             (+! gp-2 1)
             )
            (else
              (vector+! (-> self string-trans) (-> self string-trans) s5-2)
              (set! f30-2 0.0)
              )
            )
          )
        )
      )
    (cond
      ((zero? gp-2)
       (set! (-> self options) (logand -1025 (-> self options)))
       (if *display-cam-los-debug*
           (format *stdcon* "not blocked~%")
           )
       )
      (else
        (logior! (-> self options) 1024)
        (if *display-cam-los-debug*
            (format *stdcon* "blocked ~D ~f~%" gp-2 f30-2)
            )
        (let ((gp-3 (new-stack-vector0))
              (f30-3 (vector-length (-> self view-flat)))
              )
          (vector-! gp-3 (-> self string-trans) (-> *camera* tpos-curr-adj))
          (vector-flatten! gp-3 gp-3 (-> *camera* local-down))
          (let ((f28-3 (vector-length gp-3)))
            (cond
              ((< f28-3 f30-3)
               (vector-normalize-copy! (-> self view-flat) gp-3 f28-3)
               (set! (-> self min-z-override) f28-3)
               f28-3
               )
              (else
                (vector-normalize-copy! (-> self view-flat) gp-3 f30-3)
                )
              )
            )
          )
        )
      )
    )
  (when *display-cam-los-debug*
    (let ((a0-43 (new-stack-vector0)))
      (vector-! a0-43 (-> self desired-pos) (-> self string-trans))
      (format *stdcon* "vel ~M~%" (vector-length a0-43))
      )
    )
  )

(defbehavior cam-string-code camera-slave ()
  (if *debug-segment*
      (cam-debug-reset-coll-tri)
      )
  (cam-string-follow)
  (if (logtest? (-> self options) 512)
      (cam-string-line-of-sight)
      )
  (if (not (paused?))
      (cam-string-joystick)
      )
  (let ((gp-0 (new-stack-vector0)))
    (vector--float*!
      gp-0
      (-> self view-flat)
      (-> *camera* local-down)
      (+ (-> *camera* target-height) (-> self view-off y))
      )
    (vector+! (-> self desired-pos) (-> *camera* tpos-curr-adj) gp-0)
    )
  (if (logtest? (-> self options) 64)
      (cam-string-find-hidden)
      )
  (cond
    ((logtest? (-> self options) 4096)
     (when *debug-segment*
       (let ((a1-1 (new 'stack-no-clear 'vector)))
         (vector-! a1-1 (-> self good-point) (-> self string-trans))
         (cam-collision-record-save (-> self string-trans) a1-1 -2 'jump self)
         )
       )
     (set! (-> self options) (logand -4097 (-> self options)))
     (set! (-> self desired-pos quad) (-> self good-point quad))
     (cam-string-move)
     (vector-! (-> self view-flat) (-> self string-trans) (-> *camera* tpos-curr-adj))
     (vector-flatten! (-> self view-flat) (-> self view-flat) (-> *camera* local-down))
     (let ((f0-2 (vector-length (-> self view-flat))))
       (if (< f0-2 (-> self min-z-override))
           (set! (-> self min-z-override) f0-2)
           )
       )
     )
    (else
      (cam-string-move)
      )
    )
  (tracking-spline-method-17
    (-> self position-spline)
    (-> self string-trans)
    (the-as float 0.04096)
    (the-as float 4096.0)
    #t
    )
  (cond
    ((and (logtest? (-> self options) #x4000) (logtest? (-> self options) 256))
     (tracking-spline-method-21
       (-> self position-spline)
       (-> self trans)
       (the-as float 102.4)
       (the-as float 4096.0)
       )
     )
    ((logtest? (-> self options) #x4000)
     (tracking-spline-method-21
       (-> self position-spline)
       (-> self trans)
       (the-as float 40.96)
       (the-as float 4096.0)
       )
     )
    ((logtest? (-> self options) 256)
     (tracking-spline-method-21
       (-> self position-spline)
       (-> self trans)
       (the-as float 102.4)
       (the-as float 2457.6)
       )
     )
    (else
      (tracking-spline-method-21
        (-> self position-spline)
        (-> self trans)
        (the-as float 20.48)
        (the-as float 2457.6)
        )
      )
    )
  )

(defbehavior set-string-parms camera-slave ()
  (when (not (-> self string-val-locked))
    (set! (-> self string-min-val quad) (-> *camera* string-min value quad))
    (let ((v0-0 (-> self string-max-val)))
      (set! (-> v0-0 quad) (-> *camera* string-max value quad))
      v0-0
      )
    )
  )

(defstate cam-string (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('teleport)
       (let ((gp-0 (new-stack-vector0)))
         (cam-string-find-position-rel! gp-0)
         (cam-string-set-position-rel! gp-0)
         )
       )
      (('joystick)
       (set! (-> self phony-joystick-x) (the-as float (-> event param 0)))
       (set! (-> self phony-joystick-y) (the-as float (-> event param 1)))
       (let ((v0-1 (the-as object #t)))
         (set! (-> self have-phony-joystick) (the-as symbol v0-1))
         v0-1
         )
       )
      (('set-dist)
       (cond
         ((-> event param 0)
          (set! (-> self string-val-locked) #t)
          (set! (-> self string-min-val quad) (-> (the-as vector (-> event param 0)) quad))
          (set! (-> self string-max-val quad) (-> (the-as vector (-> event param 1)) quad))
          (set! (-> self string-max-val x) (fmax (-> self string-max-val x) (-> self string-min-val x)))
          (set! (-> self string-max-val y) (fmax (-> self string-max-val y) (-> self string-min-val y)))
          (set! (-> self string-max-val z) (fmax (-> self string-max-val z) (-> self string-min-val z)))
          )
         (else
           (set! (-> self string-val-locked) #f)
           #f
           )
         )
       )
      (('blocked-side?)
       (-> self los-state)
       )
      (else
        (cam-standard-event-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set-string-parms)
      (set! *camera-base-mode* cam-string)
      (set! (-> self string-vel-dir) (the-as uint 0))
      (set! (-> self fov) 11650.845)
      (set! (-> self los-tgt-spline-pt) (-> *camera* target-spline end-point))
      (set! (-> self los-tgt-spline-pt-incarnation)
            (-> *camera* target-spline point (-> self los-tgt-spline-pt) incarnation)
            )
      (set! (-> self min-z-override) (-> self string-max-val z))
      (if (!= (-> *camera* outro-t-step) 0.0)
          (set! (-> self min-z-override) (-> self string-min-val z))
          )
      (let ((gp-0 (new-stack-vector0)))
        0.0
        (set! (-> self view-off-param) (-> *camera* view-off-param-save))
        (set! (-> self view-off x) 0.0)
        (let ((f0-7 (-> self string-min-val y))
              (f1-1 (-> self string-max-val y))
              )
          (set! (-> self view-off y) (lerp f0-7 f1-1 (-> self view-off-param)))
          )
        (set! (-> self view-off z)
              (lerp (-> self string-min-val z) (-> self string-max-val z) (-> self view-off-param))
              )
        (let ((f30-0 (cond
                       ((!= (-> *camera* outro-t-step) 0.0)
                        (curve-get-pos! gp-0 (-> *camera* outro-exit-value) (-> *camera* outro-curve))
                        (vector-! gp-0 gp-0 (-> *camera* tpos-curr-adj))
                        (vector-flatten! (-> self view-flat) gp-0 (-> *camera* local-down))
                        (vector-length (-> self view-flat))
                        )
                       (else
                         (vector-flatten! (-> self view-flat) (-> self tracking inv-mat vector 2) (-> *camera* local-down))
                         (vector-negate! (-> self view-flat) (-> self view-flat))
                         0.0
                         )
                       )
                     )
              )
          (let ((f1-4 (fmin (-> *camera* string-push-z) (-> self min-z-override)))
                (f0-17 (-> self view-off z))
                )
            (cond
              ((< f30-0 f1-4)
               (set! f30-0 f1-4)
               )
              ((< f0-17 f30-0)
               (set! f30-0 f0-17)
               )
              )
            )
          (vector-normalize! (-> self view-flat) f30-0)
          (let ((f30-1 (/ (- f30-0 (-> self string-min-val z)) (- (-> self string-max-val z) (-> self string-min-val z)))))
            (if (< 1.0 f30-1)
                (set! f30-1 1.0)
                )
            (if (< f30-1 0.0)
                (set! f30-1 0.0)
                )
            (let ((f0-22 (-> self string-min-val y))
                  (f1-7 (-> self string-max-val y))
                  )
              (set! (-> self view-off y) (lerp f0-22 f1-7 f30-1))
              )
            (set! (-> self view-off z) (lerp (-> self string-min-val z) (-> self string-max-val z) f30-1))
            )
          )
        )
      (vector--float*!
        (-> self desired-pos)
        (-> self view-flat)
        (-> *camera* local-down)
        (+ (-> *camera* target-height) (-> self view-off y))
        )
      (vector+! (-> self desired-pos) (-> self desired-pos) (-> *camera* tpos-curr-adj))
      (set! (-> self string-trans quad) (-> self desired-pos quad))
      (vector-reset! (-> self velocity))
      (let ((s4-0 (new 'stack-no-clear 'collide-tri-result))
            (s5-0 (new 'stack-no-clear 'vector))
            (gp-1 (new 'stack-no-clear 'vector))
            )
        (vector--float*! s5-0 (-> *camera* tpos-curr-adj) (-> *camera* local-down) (-> *camera* target-height))
        (vector-! gp-1 (-> self string-trans) s5-0)
        (let ((f0-31 (fill-and-probe-using-line-sphere
                       *collide-cache*
                       s5-0
                       gp-1
                       (-> *CAMERA-bank* collide-move-rad)
                       (collide-kind background cak-3 wall-object ground-object cak-14)
                       (the-as process #f)
                       s4-0
                       (new 'static 'pat-surface :nocamera #x1 :nolineofsight #x1)
                       )
                     )
              )
          (when (and (< 0.0 f0-31) (< f0-31 1.0))
            (vector-float*! gp-1 gp-1 f0-31)
            (vector-flatten! (-> self view-flat) gp-1 (-> *camera* local-down))
            (let ((f0-32 (vector-length (-> self view-flat))))
              (cond
                ((< f0-32 8192.0)
                 (let ((gp-2 (new-stack-vector0)))
                   (cam-string-find-position-rel! gp-2)
                   (cam-string-set-position-rel! gp-2)
                   )
                 )
                (else
                  (if (< f0-32 (-> self min-z-override))
                      (set! (-> self min-z-override) f0-32)
                      )
                  (let ((f30-2 (/ (- f0-32 (-> self string-min-val z)) (- (-> self string-max-val z) (-> self string-min-val z)))))
                    (if (< 1.0 f30-2)
                        (set! f30-2 1.0)
                        )
                    (if (< f30-2 0.0)
                        (set! f30-2 0.0)
                        )
                    (let ((f0-36 (-> self string-min-val y))
                          (f1-16 (-> self string-max-val y))
                          )
                      (set! (-> self view-off y) (lerp f0-36 f1-16 f30-2))
                      )
                    (set! (-> self view-off z) (lerp (-> self string-min-val z) (-> self string-max-val z) f30-2))
                    )
                  (vector--float*!
                    (-> self desired-pos)
                    (-> self view-flat)
                    (-> *camera* local-down)
                    (+ (-> *camera* target-height) (-> self view-off y))
                    )
                  (vector+! (-> self desired-pos) (-> self desired-pos) (-> *camera* tpos-curr-adj))
                  (set! (-> self string-trans quad) (-> self desired-pos quad))
                  (vector-reset! (-> self velocity))
                  )
                )
              )
            )
          )
        )
      (set! (-> self trans quad) (-> self string-trans quad))
      (set! (-> self los-last-pos quad) (-> self string-trans quad))
      (tracking-spline-method-10 (-> self position-spline) (-> self string-trans))
      (set! (-> self blend-from-type) (the-as uint 2))
      (set! (-> self blend-to-type) (the-as uint 2))
      )
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) 2))
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (loop
      (when (not (paused?))
        (set-string-parms)
        (cam-string-code)
        (tracking-spline-method-9 (-> self position-spline))
        (set! (-> self have-phony-joystick) #f)
        )
      (suspend)
      )
    (none)
    )
  )

(deftype cam-stick-bank (basic)
  ((max-z meters  :offset-assert   4)
   (min-z meters  :offset-assert   8)
   (max-y meters  :offset-assert  12)
   (min-y meters  :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x14
  :flag-assert         #x900000014
  )


(define *CAM_STICK-bank*
  (new 'static 'cam-stick-bank :max-z (meters 30) :min-z (meters 5) :max-y (meters 15) :min-y (meters 2))
  )

(defbehavior cam-stick-code camera-slave ()
  (cam-calc-follow! (-> self tracking) (-> self trans) #t)
  (let ((gp-0 (new-stack-vector0)))
    (vector-flatten! (-> self view-flat) (-> self view-flat) (-> *camera* local-down))
    (vector-normalize! (-> self view-flat) (-> self view-off z))
    (vector-! gp-0 (-> self view-flat) (vector-float*! gp-0 (-> *camera* local-down) (-> self view-off y)))
    (vector+! (-> self desired-pos) (-> self tracking follow-pt) gp-0)
    )
  (let ((v1-3 (new-stack-vector0))
        (gp-1 (new-stack-vector0))
        )
    (vector-! v1-3 (-> self desired-pos) (-> self trans))
    (vector-float*! v1-3 v1-3 0.2)
    (vector-! gp-1 v1-3 (-> self velocity))
    (if (< 409.6 (vector-length gp-1))
        (vector-normalize! gp-1 (the-as float 409.6))
        )
    (vector+! (-> self velocity) (-> self velocity) gp-1)
    )
  0.0
  (let ((f30-1 1.0)
        (gp-2 (new-stack-vector0))
        (s5-0 (new-stack-vector0))
        (s4-0 4)
        (s2-0 0)
        )
    (let ((s3-0 (new 'stack-no-clear 'collide-tri-result)))
      (while (and (< 0.01 f30-1)
                  (and (< (-> *CAMERA-bank* min-detectable-velocity) (vector-length (-> self velocity))) (> s4-0 0))
                  )
        (+! s4-0 -1)
        (vector-float*! gp-2 (-> self velocity) f30-1)
        (let ((f28-0 (if (logtest? (-> self options) 32)
                         (fill-and-probe-using-line-sphere
                           *collide-cache*
                           (-> self trans)
                           gp-2
                           (-> *CAMERA-bank* collide-move-rad)
                           (collide-kind background cak-3 wall-object ground-object cak-14)
                           (the-as process #f)
                           s3-0
                           (new 'static 'pat-surface :nocamera #x1)
                           )
                         -100000000.0
                         )
                     )
              )
          (cond
            ((>= f28-0 0.0)
             (vector+float*! (-> self trans) (-> self trans) gp-2 f28-0)
             (set! (-> s5-0 quad) (-> s3-0 normal quad))
             (vector-flatten! (-> self velocity) (-> self velocity) s5-0)
             (set! f30-1 (- f30-1 (* f30-1 f28-0)))
             (set! s2-0 1)
             )
            (else
              (vector+! (-> self trans) (-> self trans) gp-2)
              (set! f30-1 0.0)
              )
            )
          )
        )
      )
    (when (nonzero? s2-0)
      0
      (let ((gp-3 (new-stack-vector0)))
        0.0
        (vector-! gp-3 (-> self trans) (-> self tracking follow-pt))
        (vector-flatten! gp-3 gp-3 (-> *camera* local-down))
        (let ((f0-14 (/ (- (vector-length gp-3) (-> *CAM_STICK-bank* min-z))
                        (- (-> *CAM_STICK-bank* max-z) (-> *CAM_STICK-bank* min-z))
                        )
                     )
              )
          (cond
            ((< f0-14 0.0)
             (set! f0-14 0.0)
             )
            ((< 1.0 f0-14)
             (set! f0-14 1.0)
             )
            )
          (cond
            ((< (- f0-14 (-> self view-off-param)) -0.001)
             (set! (-> self view-off-param) f0-14)
             )
            ((< 0.001 (- f0-14 (-> self view-off-param)))
             (vector-normalize-copy! (-> self view-flat) gp-3 (-> self view-off z))
             )
            )
          )
        )
      )
    )
  (slave-set-rotation! (-> self tracking) (-> self trans) (the-as float (-> self options)) (-> self fov) #t)
  (none)
  )

;; third person camera (in debug menu, and fishermans-boat-player-control w/o autopilot?)
(defstate cam-stick (camera-slave)
  :event cam-standard-event-handler
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self view-off-param) (-> *camera* view-off-param-save))
      (set! (-> self view-off x) 0.0)
      (set! (-> self view-off y)
            (lerp (-> *CAM_STICK-bank* min-y) (-> *CAM_STICK-bank* max-y) (-> self view-off-param))
            )
      (set! (-> self view-off z)
            (lerp (-> *CAM_STICK-bank* min-z) (-> *CAM_STICK-bank* max-z) (-> self view-off-param))
            )
      (cam-calc-follow! (-> self tracking) (-> self trans) #f)
      (vector-flatten! (-> self view-flat) (-> self tracking inv-mat vector 2) (-> *camera* local-down))
      (vector-negate! (-> self view-flat) (-> self view-flat))
      (vector-normalize! (-> self view-flat) (-> self view-off z))
      (vector--float*! (-> self desired-pos) (-> self view-flat) (-> *camera* local-down) (-> self view-off y))
      (vector+! (-> self desired-pos) (-> self desired-pos) (-> self tracking follow-pt))
      (set! (-> self trans quad) (-> self desired-pos quad))
      (vector-reset! (-> self velocity))
      (set! (-> self blend-from-type) (the-as uint 2))
      (set! (-> self blend-to-type) (the-as uint 2))
      (slave-set-rotation! (-> self tracking) (-> self trans) (the-as float (-> self options)) (-> self fov) #f)
      )
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) 2))
        (cam-slave-go cam-free-floating)
        )
    (when (not (paused?))
      (when *camera-read-analog*
        (let ((f0-0
                (analog-input-vertical-third   ;; changed for pc port
                  (the-as int (-> *cpad-list* cpads 0 righty))
                  (the-as float 128.0)
                  (the-as float 32.0)
                  (the-as float 110.0)
                  (the-as float 0.05)
                  )
                )
              )
          (cond
            ((< (* 0.05 (- 1.0 (-> self view-off-param))) f0-0)
             (+! (-> self view-off-param) (* 0.05 (- 1.0 (-> self view-off-param))))
             )
            ((< f0-0 (* 0.05 (- (-> self view-off-param))))
             (+! (-> self view-off-param) (* 0.05 (- (-> self view-off-param))))
             )
            (else
              (+! (-> self view-off-param) f0-0)
              )
            )
          )
        )
      (set! (-> self view-off y)
            (lerp (-> *CAM_STICK-bank* min-y) (-> *CAM_STICK-bank* max-y) (-> self view-off-param))
            )
      (set! (-> self view-off z)
            (lerp (-> *CAM_STICK-bank* min-z) (-> *CAM_STICK-bank* max-z) (-> self view-off-param))
            )
      (when *camera-read-analog*
        (let ((f0-16 (analog-input-horizontal-third   ;; changed for pc port
                       (the-as int (-> *cpad-list* cpads 0 rightx))
                       (the-as float 128.0)
                       (the-as float 32.0)
                       (the-as float 110.0)
                       (* 21845.334 (-> *display* seconds-per-frame))
                       )
                     )
              (gp-0 (new-stack-matrix0))
              (s3-0 (new-stack-vector0))
              (s5-0 (new-stack-vector0))
              (s4-0 (new-stack-vector0))
              )
          (cond
            ((!= f0-16 0.0)
             (matrix-axis-angle! gp-0 (-> *camera* local-down) f0-16)
             (vector-matrix*! (-> self view-flat) (-> self view-flat) gp-0)
             )
            ((logtest? (-> self options) 1)
             (set-vector! s5-0 0.0 0.0 1.0 1.0)
             (vector-normalize-copy! s5-0 (-> self view-flat) (the-as float 1.0))
             (set! (-> s3-0 quad) (-> *camera* tgt-rot-mat vector 2 quad))
             (vector-flatten! s3-0 s3-0 (-> *camera* local-down))
             (vector-negate! s3-0 s3-0)
             (set! (-> s4-0 quad) (-> s5-0 quad))
             (vector-normalize-copy! s4-0 s3-0 (the-as float 1.0))
             (matrix-from-two-vectors-max-angle-partial!
               gp-0
               s5-0
               s4-0
               (* 10922.667 (-> *display* seconds-per-frame))
               (the-as float 0.05)
               )
             (vector-matrix*! (-> self view-flat) (-> self view-flat) gp-0)
             )
            )
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (loop
      (if (not (paused?))
          (cam-stick-code)
          )
      (suspend)
      )
    (none)
    )
  )

(deftype cam-bike-bank (basic)
  ((max-z meters  :offset-assert   4)
   (min-z meters  :offset-assert   8)
   (max-y meters  :offset-assert  12)
   (min-y meters  :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x14
  :flag-assert         #x900000014
  )


(define *CAM_BIKE-bank*
  (new 'static 'cam-bike-bank :max-z (meters 6) :min-z (meters 10) :max-y (meters 3) :min-y (meters 5))
  )

(defbehavior cam-calc-bike-follow! camera-slave ((arg0 cam-rotation-tracker) (arg1 vector) (arg2 symbol))
  (vector-float*! (-> arg0 follow-off) (-> *camera* tgt-face-mat vector 2) 155648.0)
  (vector+! (-> arg0 follow-pt) (-> *camera* tpos-curr-adj) (-> arg0 follow-off))
  (vector--float*!
    (-> arg0 follow-pt)
    (-> arg0 follow-pt)
    (-> *camera* local-down)
    (+ 12288.0 (-> *camera* target-height))
    )
  (-> arg0 follow-pt)
  )

(defbehavior cam-bike-code camera-slave ()
  (let ((s4-0 (new-stack-matrix0)))
    (let ((gp-0 (new-stack-vector0))
          (s5-0 (new-stack-vector0))
          )
      (vector-normalize-copy! gp-0 (-> self view-flat) (the-as float 1.0))
      (vector-flatten! s5-0 (-> *camera* tgt-rot-mat vector 2) (-> *camera* local-down))
      (vector-normalize! s5-0 (the-as float -1.0))
      (matrix-from-two-vectors-partial-linear! s4-0 gp-0 s5-0 (the-as float 0.2))
      )
    (vector-matrix*! (-> self view-flat) (-> self view-flat) s4-0)
    )
  (let ((gp-1 (new-stack-vector0)))
    0.0
    (vector-! gp-1 (-> *camera* tpos-curr-adj) (-> *camera* tpos-old-adj))
    (let ((f30-0 (vector-length gp-1)))
      (set! (-> self view-off z) (lerp-clamp
                                   (-> *CAM_BIKE-bank* max-z)
                                   (-> *CAM_BIKE-bank* min-z)
                                   (parameter-ease-sin-clamp (* 0.00081380206 (+ -409.6 f30-0)))
                                   )
            )
      (set! (-> self view-off y) (lerp-clamp
                                   (-> *CAM_BIKE-bank* max-y)
                                   (-> *CAM_BIKE-bank* min-y)
                                   (parameter-ease-sin-clamp (* 0.00081380206 (+ -409.6 f30-0)))
                                   )
            )
      )
    (vector-flatten! (-> self view-flat) (-> self view-flat) (-> *camera* local-down))
    (vector-normalize! (-> self view-flat) (-> self view-off z))
    (vector-! gp-1 (-> self view-flat) (vector-float*! gp-1 (-> *camera* local-down) (-> self view-off y)))
    (vector+! (-> self desired-pos) (-> *camera* tpos-curr-adj) gp-1)
    )
  (let ((v1-20 (new-stack-vector0))
        (gp-2 (new-stack-vector0))
        )
    (vector-! v1-20 (-> self desired-pos) (-> self trans))
    (vector-float*! v1-20 v1-20 0.2)
    (vector-! gp-2 v1-20 (-> self velocity))
    (if (< 409.6 (vector-length gp-2))
        (vector-normalize! gp-2 (the-as float 409.6))
        )
    (vector+! (-> self velocity) (-> self velocity) gp-2)
    )
  0.0
  (let ((f30-2 1.0)
        (gp-3 (new-stack-vector0))
        (s5-3 4)
        (s4-3 (new 'stack-no-clear 'collide-tri-result))
        )
    (while (and (< 0.01 f30-2)
                (and (< (-> *CAMERA-bank* min-detectable-velocity) (vector-length (-> self velocity))) (> s5-3 0))
                )
      (+! s5-3 -1)
      (vector-float*! gp-3 (-> self velocity) f30-2)
      (let ((f28-0 (if (logtest? (-> self options) 32)
                       (fill-and-probe-using-line-sphere
                         *collide-cache*
                         (-> self trans)
                         gp-3
                         (the-as float 4096.0)
                         (collide-kind background cak-3 wall-object ground-object cak-14)
                         (the-as process #f)
                         s4-3
                         (new 'static 'pat-surface :nocamera #x1)
                         )
                       -100000000.0
                       )
                   )
            )
        (cond
          ((>= f28-0 0.0)
           (vector+float*! (-> self trans) (-> self trans) gp-3 f28-0)
           (vector-flatten! (-> self velocity) (-> self velocity) (-> s4-3 normal))
           (set! f30-2 (- f30-2 (* f30-2 f28-0)))
           (let ((s3-2 (new-stack-vector0)))
             (vector-! s3-2 (-> self trans) (-> *camera* tpos-curr-adj))
             (vector-flatten! s3-2 s3-2 (-> *camera* local-down))
             (vector-normalize-copy! (-> self view-flat) s3-2 (-> self view-off z))
             )
           )
          (else
            (vector+! (-> self trans) (-> self trans) gp-3)
            (set! f30-2 0.0)
            )
          )
        )
      )
    )
  (cam-calc-bike-follow! (-> self tracking) (-> self trans) #t)
  (slave-set-rotation! (-> self tracking) (-> self trans) (the-as float (-> self options)) (-> self fov) #t)
  (none)
  )

(defstate cam-bike (camera-slave)
  :event cam-standard-event-handler
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> *camera* foot-offset) 4096.0)
      (set! (-> *camera* head-offset) 16384.0)
      (set! (-> self view-off x) 0.0)
      (set! (-> self view-off y) (-> *CAM_BIKE-bank* max-y))
      (set! (-> self view-off z) (-> *CAM_BIKE-bank* max-z))
      (vector-flatten! (-> self view-flat) (-> self tracking inv-mat vector 2) (-> *camera* local-down))
      (vector-negate! (-> self view-flat) (-> self view-flat))
      (vector-normalize! (-> self view-flat) (-> self view-off z))
      (vector--float*! (-> self desired-pos) (-> self view-flat) (-> *camera* local-down) (-> self view-off y))
      (vector+! (-> self desired-pos) (-> self desired-pos) (-> *camera* tpos-curr-adj))
      (set! (-> self trans quad) (-> self desired-pos quad))
      (vector-reset! (-> self velocity))
      (set! (-> self blend-from-type) (the-as uint 0))
      (set! (-> self blend-to-type) (the-as uint 1))
      (cam-calc-bike-follow! (-> self tracking) (-> self trans) #f)
      (slave-set-rotation! (-> self tracking) (-> self trans) (the-as float (-> self options)) (-> self fov) #f)
      )
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) 2))
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (loop
      (if (not (paused?))
          (cam-bike-code)
          )
      (suspend)
      )
    (none)
    )
  )

(define *camera-base-mode* cam-string)
