;;-*-Lisp-*-
(in-package goal)

;; name: generic-obs.gc
;; name in dgo: generic-obs
;; dgos: GAME, ENGINE
;; note: changed for high fps

(define-extern convert-to-hud-object (function process-drawable hud none :behavior process-drawable))

;; TODO - temporary

(define-extern process-drawable-from-entity! (function process-drawable entity-actor none))

(declare-type beach-part part-spawner)

(define-extern beach-part-grotto-1 (state beach-part))

(defmacro manipy-spawn (trans entity skel arg &key (from *default-dead-pool*) &key (to *default-pool*) &key (name #f) &key (stack-size #x4000) &key (stack *scratch-memory-top*))
  `(process-spawn manipy :init manipy-init ,trans ,entity ,skel ,arg :from ,from :to ,to :name ,name :stack-size ,stack-size :stack ,stack)
  )

;; DECOMP BEGINS

(defbehavior clone-anim-once process-drawable ((arg0 handle) (arg1 int) (arg2 symbol) (arg3 string))
  (logclear! (-> self skel status) (janim-status spool))
  (let ((s5-0 (handle->process arg0)))
    (if (the-as process-drawable s5-0)
        (joint-control-copy! (-> self skel) (-> (the-as process-drawable s5-0) skel))
        )
    (cond
      ((and (the-as process-drawable s5-0) (joint-control-remap!
                                             (-> self skel)
                                             (-> self draw art-group)
                                             (-> (the-as process-drawable s5-0) draw art-group)
                                             '()
                                             0
                                             arg3
                                             )
            )
       (when arg2
         (let* ((s4-1 (-> self root))
                (a0-7 (if (and (nonzero? s4-1) (type-type? (-> s4-1 type) collide-shape))
                          (the-as collide-shape s4-1)
                          )
                      )
                )
           (if a0-7
               (move-to-point! a0-7 (-> (the-as process-drawable s5-0) root trans))
               (set! (-> self root trans quad) (-> (the-as process-drawable s5-0) root trans quad))
               )
           )
         (quaternion-copy! (-> self root quat) (-> (the-as process-drawable s5-0) root quat))
         )
       (if (logtest? (-> (the-as process-drawable s5-0) skel status) (janim-status spool))
           (logior! (-> self skel status) (janim-status spool))
           )
       (logclear! (-> self draw status) (draw-status hidden no-anim))
       (if (not (-> self skel root-channel 0 frame-group))
           (logior! (-> self draw status) (draw-status no-anim))
           )
       (let* ((s5-1 self)
              (v1-37 (if (and (nonzero? s5-1) (type-type? (-> s5-1 type) manipy))
                         s5-1
                         )
                     )
              )
         (if (and manipy (not (-> (the-as manipy v1-37) draw?)))
             (logior! (-> self draw status) (draw-status no-anim))
             )
         )
       (do-joint-math! self)
       (let ((a0-22 (-> self skel effect)))
         (if a0-22
             (effect-control-method-9 a0-22)
             )
         )
       (if (logtest? (-> self skel status) (janim-status blerc blerc-done))
           (merc-blend-shape self)
           )
       (if (logtest? (-> self skel status) (janim-status eye-done eye))
           (merc-eye-anim self)
           )
       )
      (else
        (logior! (-> self draw status) (draw-status hidden))
        (ja-post)
        )
      )
    )
  (if (>= arg1 0)
      (vector<-cspace! (-> self draw origin) (-> self node-list data arg1))
      )
  0
  (none)
  )

(defbehavior clone-anim process-drawable ((arg0 handle) (arg1 int) (arg2 symbol) (arg3 string))
  (ja-post)
  (while (handle->process arg0)
    (clone-anim-once arg0 arg1 #t arg3)
    (suspend)
    )
  (logclear! (-> self skel status) (janim-status spool))
  0
  (none)
  )

(defstate swingpole-stance (swingpole)
  :code (behavior ()
    (loop
      (when (and *target*
                 (< (vector-vector-distance (-> self root trans) (-> *target* control unknown-vector90)) (-> self range))
                 (logtest? (-> *target* control root-prim prim-core action) (collide-action edgegrab-possible))
                 (< (-> *target* control unknown-vector90 y) (+ (-> self root trans y) (* 0.5 (-> self range))))
                 )
        (if (send-event *target* 'pole-grab self)
            (go swingpole-active)
            )
        )
      (suspend)
      )
    (none)
    )
  )

(defstate swingpole-active (swingpole)
  :code (behavior ()
    (suspend)
    (while (and *target* (= (handle->process (-> *target* control unknown-handle10)) self))
      (suspend)
      )
    (let ((gp-0 (-> *display* base-frame-counter)))
      (until (>= (- (-> *display* base-frame-counter) gp-0) (seconds 0.5))
        (suspend)
        )
      )
    (go swingpole-stance)
    (none)
    )
  )

(defmethod init-from-entity! swingpole ((obj swingpole) (arg0 entity-actor))
  "Copy defaults from the entity."
  (stack-size-set! (-> obj main-thread) 128)
  (logior! (-> obj mask) (process-mask actor-pause))
  (set! (-> obj root) (new 'process 'trsq))
  (set! (-> obj root trans quad) (-> arg0 extra trans quad))
  (quaternion-copy! (-> obj root quat) (-> arg0 quat))
  (vector-identity! (-> obj root scale))
  (vector-y-quaternion! (-> obj dir) (-> obj root quat))
  (set! (-> obj dir y) 0.0)
  (vector-normalize! (-> obj dir) 1.0)
  (set! (-> obj range) 12288.0)
  (set! (-> obj edge-length) 8192.0)
  (go swingpole-stance)
  (none)
  )

(defstate die (process-hidden)
  :virtual #t
  :code (the-as (function none :behavior process-hidden) nothing)
  )

(defmethod init-from-entity! process-hidden ((obj process-hidden) (arg0 entity-actor))
  "Copy defaults from the entity."
  (process-entity-status! obj (entity-perm-status dead) #t)
  (go (method-of-object obj die))
  (none)
  )

(deftype target-start (process-hidden)
  ()
  :method-count-assert 15
  :size-assert         #x70
  :flag-assert         #xf00000070
  )


(deftype camera-start (process-hidden)
  ()
  :method-count-assert 15
  :size-assert         #x70
  :flag-assert         #xf00000070
  )


(defstate manipy-idle (manipy)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (local-vars (v0-0 object))
    (let ((v1-0 event-type))
      (the-as
        object
        (cond
          ((= v1-0 'attackable)
           (cond
             ((-> event param 0)
              (set! v0-0 (logior (process-mask attackable) (-> self mask)))
              (set! (-> self mask) (the-as process-mask v0-0))
              )
             (else
               (set! v0-0 (logclear (-> self mask) (process-mask attackable)))
               (set! (-> self mask) (the-as process-mask v0-0))
               )
             )
           v0-0
           )
          ((= v1-0 'blend-shape)
           (cond
             ((-> event param 0)
              (set! v0-0 (logior (-> self skel status) (janim-status blerc eye)))
              (set! (-> self skel status) (the-as janim-status v0-0))
              )
             (else
               (set! v0-0 (logclear (-> self skel status) (janim-status blerc eye)))
               (set! (-> self skel status) (the-as janim-status v0-0))
               )
             )
           v0-0
           )
          ((= v1-0 'shadow)
           (cond
             ((-> event param 0)
              (set! v0-0 (-> self shadow-backup))
              (set! (-> self draw shadow) (the-as shadow-geo v0-0))
              v0-0
              )
             (else
               (set! (-> self draw shadow) #f)
               #f
               )
             )
           )
          ((= v1-0 'trans-hook)
           (set! v0-0 (-> event param 0))
           (set! (-> self new-trans-hook) (the-as (function none) v0-0))
           v0-0
           )
          ((= v1-0 'post-hook)
           (set! v0-0 (-> event param 0))
           (set! (-> self new-post-hook) (the-as (function none) v0-0))
           v0-0
           )
          ((= v1-0 'eval)
           (the-as object ((the-as (function manipy none) (-> event param 0)) self))
           )
          ((= v1-0 'become-hud-object)
           (the-as object (convert-to-hud-object self (the-as hud (-> event param 0))))
           )
          ((= v1-0 'event-hook)
           (set! v0-0 (-> event param 0))
           (set! (-> self cur-event-hook) (the-as (function none) v0-0))
           v0-0
           )
          ((= v1-0 'art-joint-anim)
           (set! (-> self new-joint-anim)
                 (the-as
                   art-joint-anim
                   (lookup-art (-> self draw art-group) (the-as string (-> event param 0)) art-joint-anim)
                   )
                 )
           (set! v0-0 (-> event param 1))
           (set! (-> self new-joint-anim-blend) (the-as uint v0-0))
           v0-0
           )
          ((= v1-0 'anim-mode)
           (when (nonzero? (-> self skel))
             (set! (-> self anim-mode) (the-as symbol (-> event param 0)))
             (if (= (-> self anim-mode) 'clone-anim)
                 (ja-post)
                 )
             (-> self anim-mode)
             )
           )
          ((or (= v1-0 'origin-joint-index) (= v1-0 'center-joint))
           (set! (-> self draw origin-joint-index) (-> event param 0))
           (set! v0-0 (-> event param 0))
           (set! (-> self draw shadow-joint-index) (the-as uint v0-0))
           v0-0
           )
          ((= v1-0 'max-vis-dist)
           (set! (-> self draw lod-set lod (-> self draw lod-set max-lod) dist) (the-as float (-> event param 0)))
           )
          ((= v1-0 'grab)
           (set! (-> self cur-grab-handle) (process->handle (the-as process (-> event param 0))))
           (let ((v1-30 (handle->process (-> self cur-grab-handle))))
             (when v1-30
               (set! v0-0 (-> self old-grab-pos))
               (set! (-> (the-as vector v0-0) quad) (-> (the-as process-drawable v1-30) root trans quad))
               v0-0
               )
             )
           )
          ((= v1-0 'target)
           (set! v0-0 (process->handle (the-as process (-> event param 0))))
           (set! (-> self cur-target-handle) (the-as handle v0-0))
           v0-0
           )
          ((= v1-0 'trans)
           (cond
             ((type-type? (-> self root type) collide-shape)
              (the-as object (move-to-point! (the-as collide-shape (-> self root)) (the-as vector (-> event param 0))))
              )
             (else
               (set! v0-0 (-> self root trans))
               (set! (-> (the-as vector v0-0) quad) (-> (the-as vector (-> event param 0)) quad))
               v0-0
               )
             )
           )
          ((= v1-0 'rot)
           (let ((s5-0 (new 'stack-no-clear 'matrix)))
             (matrix-rotate-y! s5-0 (the-as float (-> event param 0)))
             (matrix->quaternion (-> self root quat) s5-0)
             )
           )
          ((= v1-0 'rot-quat)
           (quaternion-copy! (-> self root quat) (the-as quaternion (-> event param 0)))
           )
          ((= v1-0 'clone-copy-trans)
           (set! v0-0 (-> event param 0))
           (set! (-> self clone-copy-trans) (the-as symbol v0-0))
           v0-0
           )
          ((= v1-0 'release)
           (set! (-> self cur-grab-handle) (the-as handle #f))
           #f
           )
          ((= v1-0 'draw)
           (set! (-> self draw?) (the-as symbol (-> event param 0)))
           (cond
             ((-> event param 0)
              (let ((v1-47 (logtest? (-> self draw status) (draw-status hidden))))
                (logclear! (-> self draw status) (draw-status hidden))
                (when v1-47
                  (cond
                    ((nonzero? (-> self skel))
                     (let ((gp-1 (-> self skel status)))
                       (logior! (-> self skel status) (janim-status inited))
                       (set! v0-0 (the-as object (ja-post)))
                       (set! (-> self skel status) gp-1)
                       )
                     v0-0
                     )
                    (else
                      (the-as object (ja-post))
                      )
                    )
                  )
                )
              )
             (else
               (set! v0-0 (logior (-> self draw status) (draw-status hidden)))
               (set! (-> self draw status) (the-as draw-status v0-0))
               v0-0
               )
             )
           )
          ((= v1-0 'query)
           (case (-> event param 0)
             (('grab)
              (handle->process (-> self cur-grab-handle))
              )
             (('done)
              (case (-> self anim-mode)
                (('play1 'play)
                 (>= (ja-frame-num 0) (the float (+ (-> (ja-group) data 0 length) -2)))
                 )
                )
              )
             )
           )
          ((= v1-0 'set-frame-num)
           (let ((v1-73 (-> self skel root-channel 0)))
             (set! (-> v1-73 num-func) num-func-identity)
             (set! (-> v1-73 frame-num) (the-as float (-> event param 0)))
             )
           )
          (else
            (if (-> self cur-event-hook)
                (the-as object ((-> self cur-event-hook)))
                )
            )
          )
        )
      )
    )
  :trans (behavior ()
    (if (!= (-> self cur-trans-hook) (-> self new-trans-hook))
        (set! (-> self cur-trans-hook) (-> self new-trans-hook))
        )
    (if (!= (-> self cur-post-hook) (-> self new-post-hook))
        (set! (-> self cur-post-hook) (-> self new-post-hook))
        )
    (when (and (-> self new-joint-anim)
               (nonzero? (-> self skel))
               (and (!= (ja-group) (-> self new-joint-anim)) (!= (-> self anim-mode) 'clone-anim))
               )
      (ja-channel-push! 1 (the-as time-frame (-> self new-joint-anim-blend)))
      (ja :group! (-> self new-joint-anim) :num! min)
      )
    (let ((v1-20 (handle->process (-> self cur-grab-handle))))
      (when v1-20
        (let ((gp-1 (-> (the-as process-drawable v1-20) root trans)))
          (if (type-type? (-> self root type) collide-shape)
              (move-by-vector!
                (the-as collide-shape (-> self root))
                (vector-! (new 'stack-no-clear 'vector) gp-1 (-> self old-grab-pos))
                )
              (vector+!
                (-> self root trans)
                (-> self root trans)
                (vector-! (new 'stack-no-clear 'vector) gp-1 (-> self old-grab-pos))
                )
              )
          (set! (-> self old-grab-pos quad) (-> gp-1 quad))
          )
        )
      )
    ((-> self cur-trans-hook))
    (none)
    )
  :code (behavior ()
    (logclear! (-> self mask) (process-mask heap-shrunk))
    (loop
      ((-> self cur-post-hook))
      (if (!= (-> self anim-mode) 'clone-anim)
          (ja-post)
          )
      (suspend)
      (case (-> self anim-mode)
        (('loop)
         (ja :num! (loop!))
         )
        (('play)
         (ja :num! (seek!))
         )
        (('copy-parent)
         (ja :num-func num-func-identity
             :frame-num (-> (the-as process-drawable (ppointer->process (-> self parent))) skel root-channel 0 frame-num)
             )
         )
        (('clone-parent)
         (let ((gp-0 (ppointer->process (-> self parent))))
           (set! (-> self post-hook) #f)
           (joint-control-copy! (-> self skel) (-> (the-as process-drawable gp-0) skel))
           (joint-control-remap!
             (-> self skel)
             (-> self draw art-group)
             (-> (the-as process-drawable gp-0) draw art-group)
             '()
             0
             ""
             )
           )
         (do-joint-math! self)
         )
        (('clone-anim)
         (clone-anim-once
           (if (handle->process (-> self cur-target-handle))
               (the-as handle (-> self cur-target-handle))
               (ppointer->handle (-> self parent))
               )
           (the-as int (-> self draw origin-joint-index))
           (-> self clone-copy-trans)
           ""
           )
         )
        (('still)
         )
        (('play1)
         (ja :num! (seek!))
         (if (ja-done? 0)
             (deactivate self)
             )
         )
        )
      )
    (none)
    )
  )

(defbehavior manipy-init manipy ((arg0 vector) (arg1 entity-actor) (arg2 skeleton-group) (arg3 vector))
  (stack-size-set! (-> self main-thread) 256) ;; from 128
  (logior! (-> self mask) (process-mask heap-shrunk))
  (set! (-> self entity) arg1)
  (cond
    ((= arg3 'collide-shape-moving)
     (let ((s4-1 (new 'process 'collide-shape-moving self (collide-list-enum hit-by-player))))
       (set! (-> s4-1 dynam) (copy *standard-dynamics* 'process))
       (set! (-> s4-1 reaction) default-collision-reaction)
       (set! (-> s4-1 no-reaction)
             (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
             )
       (let ((s3-1 (new 'process 'collide-shape-prim-sphere s4-1 (the-as uint 0))))
         (set-vector! (-> s3-1 local-sphere) 0.0 0.0 0.0 4096.0)
         (set-root-prim! s4-1 s3-1)
         )
       (set! (-> s4-1 nav-radius) (* 0.75 (-> s4-1 root-prim local-sphere w)))
       (backup-collide-with-as s4-1)
       (set! (-> self root) s4-1)
       )
     )
    (arg3
      (let ((s4-2 (new 'process 'collide-shape self (collide-list-enum hit-by-player))))
        (let ((s2-0 (new 'process 'collide-shape-prim-sphere s4-2 (the-as uint 0))))
          (set! (-> s2-0 prim-core collide-as) (collide-kind powerup blue-eco-suck))
          (set! (-> s2-0 collide-with) (collide-kind target))
          (set-vector! (-> s2-0 local-sphere) (-> arg3 x) (-> arg3 y) (-> arg3 z) (-> arg3 w))
          (set-root-prim! s4-2 s2-0)
          )
        (set! (-> s4-2 nav-radius) (* 0.75 (-> s4-2 root-prim local-sphere w)))
        (backup-collide-with-as s4-2)
        (set! (-> self root) s4-2)
        )
      )
    (else
      (set! (-> self root) (new 'process 'trsqv))
      )
    )
  (set! (-> self root trans quad) (-> arg0 quad))
  (initialize-skeleton self arg2 '())
  (if (type-type? (-> self root type) collide-shape)
      (update-transforms! (the-as collide-shape (-> self root)))
      )
  (set! (-> self shadow-backup) (-> self draw shadow))
  (set! (-> self new-trans-hook) nothing)
  (set! (-> self cur-trans-hook) nothing)
  (set! (-> self new-post-hook) nothing)
  (set! (-> self cur-post-hook) nothing)
  (set! (-> self cur-event-hook) #f)
  (set! (-> self cur-grab-handle) (the-as handle #f))
  (set! (-> self cur-target-handle) (the-as handle #f))
  (set! (-> self clone-copy-trans) #t)
  (set! (-> self draw?) #t)
  (cond
    ((nonzero? (-> self skel))
     (set! (-> self new-joint-anim) (ja-group))
     (set! (-> self anim-mode) 'loop)
     (#when PC_PORT
       (set! (-> self skel postbind-function) process-drawable-joint-callback-pc))
     )
    (else
      (set! (-> self anim-mode) 'still)
      )
    )
  (set! (-> self event-hook) (-> manipy-idle event))
  (go manipy-idle)
  (none)
  )

(defmethod deactivate part-tracker ((obj part-tracker))
  (if (nonzero? (-> obj part))
      (kill-and-free-particles (-> obj part))
      )
  ((method-of-type process deactivate) obj)
  (none)
  )

(defbehavior part-tracker-notify part-tracker ()
  (let ((gp-0 (new 'stack-no-clear 'event-message-block)))
    (set! (-> gp-0 from) self)
    (set! (-> gp-0 num-params) 1)
    (set! (-> gp-0 message) 'notify)
    (set! (-> gp-0 param 0) (the-as uint 'die))
    (let ((s5-0 send-event-function)
          (s4-0 (ppointer->process (-> self parent)))
          )
      (s5-0
        (if (and (nonzero? s4-0) (type-type? (-> s4-0 type) process))
            s4-0
            )
        gp-0
        )
      )
    )
  )

(defstate part-tracker-process (part-tracker)
  :code (behavior ()
    (set! (-> self start-time) (-> *display* base-frame-counter))
    (while (< (- (-> *display* base-frame-counter) (-> self start-time)) (-> self duration))
      (let ((gp-0 (handle->process (-> self target))))
        (when gp-0
          (if (and gp-0 (type-type? (-> gp-0 type) process-drawable) (nonzero? (-> (the-as process-drawable gp-0) root)))
              (vector+! (-> self root trans) (-> (the-as process-drawable gp-0) root trans) (-> self offset))
              )
          )
        )
      (let ((gp-1 (-> self root trans)))
        (if (-> self callback)
            ((-> self callback) self)
            )
        (spawn (-> self part) gp-1)
        )
      (suspend)
      )
    (let ((gp-2 (-> *display* base-frame-counter)))
      (until (>= (- (-> *display* base-frame-counter) gp-2) (-> self linger-duration))
        (if (-> self linger-callback)
            ((-> self linger-callback) self)
            )
        (suspend)
        )
      )
    (if (-> self linger-callback)
        ((-> self linger-callback) self)
        )
    (part-tracker-notify)
    (suspend)
    0
    (none)
    )
  )

(defbehavior part-tracker-init part-tracker ((arg0 sparticle-launch-group)
                                   (arg1 time-frame)
                                   (arg2 (function part-tracker none))
                                   (arg3 (pointer process-drawable))
                                   (arg4 process)
                                   (arg5 collide-prim-core)
                                   )
  (stack-size-set! (-> self main-thread) 128)
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> arg5 world-sphere quad))
  (set! (-> self offset quad) (-> arg5 world-sphere quad))
  (set! (-> self callback) (the-as (function part-tracker vector) arg2))
  (set! (-> self linger-callback) #f)
  (set! (-> self userdata) (the-as uint arg3))
  (set! (-> self target) (process->handle arg4))
  (set! arg1 (cond
               ((> arg1 0)
                (empty)
                arg1
                )
               (else
                 (the-as time-frame (-> arg0 duration))
                 )
               )
        )
  (set! (-> self duration) (the-as time-frame arg1))
  (set! (-> self linger-duration) (the-as time-frame (-> arg0 linger-duration)))
  (set! (-> self part) (create-launch-control arg0 self))
  (go part-tracker-process)
  (none)
  )

;; WARN: disable def twice: 68. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
;; WARN: disable def twice: 82. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
;; WARN: disable def twice: 96. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
;; WARN: disable def twice: 110. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defbehavior command-get-process camera-tracker ((arg0 object) (arg1 process))
  (the-as process (cond
                    ((null? arg0)
                     arg1
                     )
                    ((type-type? (rtype-of arg0) process)
                     (the-as process arg0)
                     )
                    ((= arg0 'target)
                     *target*
                     )
                    ((= arg0 'sidekick)
                     (when *target*
                       (let ((v1-6 (-> *target* sidekick)))
                         (if v1-6
                             (the-as process (-> v1-6 0 self))
                             )
                         )
                       )
                     )
                    ((= arg0 'parent)
                     (let ((v1-9 (-> self parent)))
                       (if v1-9
                           (the-as process (-> v1-9 0 self))
                           )
                       )
                     )
                    ((= arg0 'camera)
                     *camera*
                     )
                    ((type-type? (rtype-of arg0) string)
                     (process-by-ename (the-as string arg0))
                     )
                    ((type-type? (-> self type) camera-tracker)
                     (let ((v1-13 self))
                       (cond
                         ((= arg0 'work)
                          (handle->process (-> v1-13 work-process))
                          )
                         ((= arg0 'grab)
                          (handle->process (-> v1-13 grab-target))
                          )
                         ((= arg0 'look-at)
                          (handle->process (-> v1-13 look-at-target))
                          )
                         ((= arg0 'pov)
                          (handle->process (-> v1-13 pov-target))
                          )
                         ((= arg0 'anim)
                          (handle->process (-> v1-13 anim-process))
                          )
                         (else
                           arg1
                           )
                         )
                       )
                     )
                    (else
                      arg1
                      )
                    )
          )
  )

(defun command-get-camera ((arg0 object) (arg1 state))
  (cond
    ((null? arg0)
     arg1
     )
    ((= arg0 'base)
     *camera-base-mode*
     )
    ((= arg0 'string)
     cam-string
     )
    ((= arg0 'fixed)
     cam-fixed
     )
    ((type-type? (rtype-of arg0) symbol)
     (the-as state (-> (the-as symbol arg0) value))
     )
    ((type-type? (rtype-of arg0) string)
     (the-as state arg0)
     )
    ((type-type? (rtype-of arg0) state)
     (the-as state arg0)
     )
    (else
      arg1
      )
    )
  )

(defun command-get-trans ((arg0 object) (arg1 vector))
  (cond
    ((null? arg0)
     arg1
     )
    ((= arg0 'null)
     *null-vector*
     )
    ((= arg0 'target)
     (target-pos 0)
     )
    ((pair? arg0)
     (let ((s4-0 (command-get-process (car arg0) *target*))
           (v1-4 (command-get-int (car (cdr arg0)) 0))
           )
       (cond
         (s4-0
           (-> (the-as target s4-0) node-list data v1-4 bone transform vector 3)
           )
         (else
           arg1
           )
         )
       )
     )
    (else
      arg1
      )
    )
  )

(defbehavior process-grab? camera-tracker ((arg0 process))
  (let ((gp-0 (command-get-process arg0 *target*)))
    (the-as symbol (when gp-0
                     (if (type-type? (-> self type) camera-tracker)
                         (set! (-> self grab-target) (process->handle gp-0))
                         )
                     (send-event gp-0 'change-mode 'grab)
                     )
            )
    )
  )

(defbehavior process-release? process ((arg0 process))
  (let ((gp-0 (command-get-process arg0 *target*)))
    (the-as symbol (if (and gp-0 (send-event gp-0 'query 'mode) 'target-grab)
                       (send-event gp-0 'end-mode)
                       #t
                       )
            )
    )
  )

(defun camera-change-to ((arg0 string) (arg1 int) (arg2 symbol))
  (let ((gp-0 (command-get-camera arg0 *camera-base-mode*)))
    (cond
      ((not gp-0)
       #f
       )
      ((type-type? (rtype-of gp-0) string)
       (send-event *camera* 'change-to-entity-by-name gp-0)
       #t
       )
      ((type-type? (rtype-of gp-0) state)
       (send-event *camera* 'change-state gp-0 arg1)
       (if arg2
           (send-event *camera* 'blend-from-as-fixed)
           )
       #t
       )
      )
    )
  )

(defbehavior camera-look-at camera-tracker ((arg0 pair) (arg1 uint))
  (let ((gp-0 (command-get-process arg0 *target*)))
    (when gp-0
      (if (type-type? (-> self type) camera-tracker)
          (set! (-> self look-at-target) (process->handle gp-0))
          )
      (send-event *camera* 'change-target gp-0 arg1)
      )
    gp-0
    )
  )

(defun ja-anim-done? ((arg0 process))
  (with-pp
    (let ((gp-0 (command-get-process arg0 *target*)))
      (the-as
        symbol
        (when gp-0
          (cond
            ((type-type? (-> gp-0 type) manipy)
             (send-event gp-0 'query 'done)
             )
            ((type-type? (-> gp-0 type) process-drawable)
             (when (not (logtest? (-> (the-as process-drawable gp-0) skel status) (janim-status done)))
               (let ((s5-0 pp))
                 (set! pp gp-0)
                 (let ((v0-1 (the-as object (ja-done? 0))))
                   (set! pp s5-0)
                   v0-1
                   )
                 )
               )
             )
            )
          )
        )
      )
    )
  )

(defbehavior camera-pov-from camera-tracker ((arg0 pair) (arg1 uint))
  (let ((gp-0 (command-get-process arg0 *target*)))
    (when gp-0
      (if (type-type? (-> self type) camera-tracker)
          (set! (-> self pov-target) (process->handle gp-0))
          )
      (when (= arg1 -10)
        (set! arg1 (the-as uint 0))
        (when (> (-> (the-as process-drawable gp-0) skel active-channels) 0)
          (let ((v1-11 (lookup-art (-> (the-as process-drawable gp-0) draw jgeo) "camera" (the-as type #f))))
            (if v1-11
                (set! arg1 (the-as uint (+ (-> v1-11 number) 1)))
                )
            )
          )
        )
      (send-event *camera* 'change-pov gp-0 arg1)
      )
    gp-0
    )
  )

(defbehavior camera-anim camera-tracker ((arg0 symbol) (arg1 basic) (arg2 entity))
  (set! (-> self anim-process) (the-as handle #f))
  (let* ((s2-0 (get-process *default-dead-pool* manipy #x4000))
         (gp-0 (when s2-0
                 (let ((t9-1 (method-of-type manipy activate)))
                   (t9-1 (the-as manipy s2-0) self 'manipy (the-as pointer #x70004000))
                   )
                 ((the-as (function process function object object object object object) run-function-in-process)
                  s2-0
                  manipy-init
                  arg2
                  #f
                  arg0
                  #f
                  )
                 (-> s2-0 ppointer)
                 )
               )
         )
    (when gp-0
      (send-event (-> gp-0 0 self) 'anim-mode 'play1)
      (send-event (-> gp-0 0 self) 'art-joint-anim arg1)
      (set! (-> self anim-process) (ppointer->handle gp-0))
      )
    gp-0
    )
  )

(defmethod eval camera-tracker ((obj camera-tracker) (arg0 pair))
  (with-pp
    (let ((gp-0 (the-as object #f)))
      (cond
        ((null? arg0)
         )
        ((pair? arg0)
         (let ((a2-0 (car arg0))
               (s4-0 (cdr arg0))
               )
           (case a2-0
             (('print)
              (set! gp-0 (car s4-0))
              (if (pair? gp-0)
                  (set! gp-0 (eval obj (the-as pair gp-0)))
                  )
              (format #t "~A MESSAGE (~D): ~A~%" obj (-> *display* base-frame-counter) gp-0)
              )
             (('while)
              (let ((s3-0 (car s4-0)))
                (while (eval obj (the-as pair s3-0))
                  (let* ((s2-0 (cdr s4-0)) (a1-3 (car s2-0))) (while (not (null? s2-0))
                                                                (set! gp-0 (eval obj (the-as pair a1-3)))
                                                                (set! s2-0 (cdr s2-0))
                                                                (set! a1-3 (car s2-0))
                                                                )
                        )
                  )
                )
              )
             (('until)
              (let ((s3-1 (car s4-0)))
                (while (not (eval obj (the-as pair s3-1)))
                  (let* ((s2-1 (cdr s4-0))
                         (a1-5 (car s2-1))
                         )
                    (while (not (null? s2-1))
                      (set! gp-0 (eval obj (the-as pair a1-5)))
                      (set! s2-1 (cdr s2-1))
                      (set! a1-5 (car s2-1))
                      )
                    )
                  )
                )
              )
             (('not)
              (set! gp-0 (not (eval obj (the-as pair (car s4-0)))))
              )
             (('wait-for 'wait 'suspend)
              (let ((s5-1 (command-get-time (car s4-0) 1))
                    (s4-1 (-> *display* base-frame-counter))
                    )
                (until (>= (- (-> *display* base-frame-counter) s4-1) s5-1)
                  (suspend)
                  )
                )
              )
             (('message?)
              (when (= (-> obj message) (car s4-0))
                (set! gp-0 (-> obj message))
                (set! (-> obj message) #f)
                )
              )
             (('send-event)
              (let ((s5-2 (command-get-process (car s4-0) *target*))
                    (s3-2 (car (cdr s4-0)))
                    (s4-2 (cdr (cdr s4-0)))
                    )
                (when (and s5-2 (not (null? s3-2)))
                  (let ((gp-1 (new 'stack-no-clear 'event-message-block)))
                    (set! (-> gp-1 from) pp)
                    (let ((a0-22 s4-2))
                      (set! (-> gp-1 num-params) ((method-of-type (rtype-of a0-22) length) a0-22))
                      )
                    (set! (-> gp-1 message) (the-as symbol s3-2))
                    (set! (-> gp-1 param 0) (the-as uint (command-get-param (car s4-2) #f)))
                    (set! (-> gp-1 param 1) (the-as uint (command-get-param (car (cdr s4-2)) #f)))
                    (set! (-> gp-1 param 2) (the-as uint (command-get-param (car (cdr (cdr s4-2))) #f)))
                    (set! gp-0 (send-event-function s5-2 gp-1))
                    )
                  )
                )
              )
             (('eval)
              (let ((s4-3 (car s4-0)))
                (if (and s4-3 (type-type? (-> (the-as basic s4-3) type) function))
                    (set! gp-0 ((the-as (function camera-tracker symbol) s4-3) obj))
                    )
                )
              )
             (('work-set!)
              (set! gp-0 (process->handle (eval obj (the-as pair (car s4-0)))))
              (set! (-> obj work-process) (the-as handle gp-0))
              )
             (('grab)
              (let ((a0-38 (command-get-process (car s4-0) *target*)))
                (set! gp-0 (process-grab? a0-38))
                )
              )
             (('release)
              (set! gp-0 (process-release? (handle->process (-> obj grab-target))))
              )
             (('alive?)
              (set! gp-0 (command-get-process (car s4-0) *target*))
              )
             (('draw)
              (set! gp-0 (command-get-process (car s4-0) *target*))
              (when (the-as target gp-0)
                (if (car (cdr s4-0))
                    (logclear! (-> (the-as target gp-0) skel status) (janim-status drawn))
                    (logior! (-> (the-as target gp-0) skel status) (janim-status drawn))
                    )
                )
              )
             (('camera-change-to 'camera)
              (set! gp-0 (camera-change-to (the-as string (car s4-0)) (command-get-time (car (cdr s4-0)) 0) #f))
              )
             (('intro-done?)
              (let ((a1-25 (new 'stack-no-clear 'event-message-block)))
                (set! (-> a1-25 from) pp)
                (set! (-> a1-25 num-params) 0)
                (set! (-> a1-25 message) 'intro-done?)
                (set! gp-0 (send-event-function *camera* a1-25))
                )
              )
             (('camera-look-at 'look-at)
              (set! gp-0 (camera-look-at (the-as pair (car s4-0)) (the-as uint (command-get-int (car (cdr s4-0)) 0))))
              )
             (('pov)
              (set! gp-0 (camera-pov-from (the-as pair (car s4-0)) (the-as uint (command-get-int (car (cdr s4-0)) 0))))
              )
             (('camera-anim)
              (let ((s2-2 (car s4-0))
                    (s3-3 (car (cdr s4-0)))
                    (s4-4 (command-get-trans (car (cdr (cdr s4-0))) *null-vector*))
                    (s1-0 string->symbol)
                    )
                (format (clear *temp-string*) "*~S-sg*" s2-2)
                (let ((s2-3 (-> (s1-0 *temp-string*) value)))
                  (when (type-type? (rtype-of s2-3) skeleton-group)
                    (set! (-> obj anim-process) (the-as handle #f))
                    (let ((s1-1 (get-process *default-dead-pool* manipy #x4000)))
                      (set! gp-0 (when s1-1
                                   (let ((t9-35 (method-of-type manipy activate)))
                                     (t9-35 (the-as manipy s1-1) obj 'manipy (the-as pointer #x70004000))
                                     )
                                   (run-now-in-process s1-1 manipy-init s4-4 #f s2-3 #f)
                                   (-> s1-1 ppointer)
                                   )
                            )
                      )
                    (send-event (-> (the-as (pointer process) gp-0) 0 self) 'anim-mode 'play1)
                    (send-event (-> (the-as (pointer process) gp-0) 0 self) 'art-joint-anim s3-3)
                    (set! (-> obj anim-process) (ppointer->handle (the-as (pointer process) gp-0)))
                    )
                  )
                )
              )
             (else
               (format 0 "ERROR: camera-tracker does not know script line command ~A.~%" a2-0)
               )
             )
           )
         )
        (else
          (format 0 "ERROR: camera-tracker requires a pair as a script line, not ~A.~%" arg0)
          )
        )
      (the-as process gp-0)
      )
    )
  )

(defstate camera-tracker-process (camera-tracker)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (local-vars (v0-0 uint))
    (the-as object (case event-type
                     (('message)
                      (set! v0-0 (-> event param 0))
                      (set! (-> self message) (the-as basic v0-0))
                      v0-0
                      )
                     (('mask)
                      (set! v0-0 (-> event param 0))
                      (set! (-> self mask-to-clear) (the-as process-mask v0-0))
                      v0-0
                      )
                     (('border)
                      (set! v0-0 (-> event param 0))
                      (set! (-> self border-value) (the-as basic v0-0))
                      v0-0
                      )
                     )
            )
    )
  :enter (behavior ()
    (if (-> self entity)
        (set-or-clear-status! (-> self entity) (entity-perm-status bit-3) #t)
        )
    (if (not (-> self border-value))
        (add-setting! 'border-mode (-> self border-value) 0.0 0)
        )
    (add-setting! 'process-mask 'set 0.0 (-> self mask-to-clear))
    (add-setting! 'movie (process->ppointer self) 0.0 0)
    (hide-hud-quick)
    (none)
    )
  :exit (behavior ()
    (if (-> self entity)
        (set-or-clear-status! (-> self entity) (entity-perm-status bit-3) #f)
        )
    (send-event *camera* 'clear-entity)
    (none)
    )
  :code (behavior ()
    (cond
      ((-> self script-func)
       ((-> self script-func))
       )
      (else
        (while (not (null? (-> self script-line)))
          (eval self (the-as pair (-> self script-line car)))
          (set! (-> self script-line) (the-as pair (-> self script-line cdr)))
          )
        )
      )
    (remove-setting! 'process-mask)
    (send-event *camera* 'clear-entity)
    (suspend)
    (suspend)
    (suspend)
    0
    (none)
    )
  )

(defbehavior camera-tracker-init camera-tracker ((arg0 object))
  (stack-size-set! (-> self main-thread) 512)
  (logclear! (-> self mask) (process-mask actor-pause movie enemy platform projectile))
  (set! (-> self mask-to-clear) (process-mask movie enemy platform projectile))
  (set! (-> self grab-target) (the-as handle #f))
  (set! (-> self grab-event) 'grab)
  (set! (-> self release-event) 'end-mode)
  (set! (-> self look-at-target) (the-as handle #f))
  (set! (-> self pov-target) (the-as handle #f))
  (set! (-> self callback) #f)
  (set! (-> self userdata) #f)
  (set! (-> self start-time) (-> *display* base-frame-counter))
  (set! (-> self script) '())
  (set! (-> self script-line) '())
  (set! (-> self script-func) #f)
  (set! (-> self message) #f)
  (set! (-> self border-value) #f)
  (cond
    ((pair? arg0)
     (set! (-> self script) (the-as pair arg0))
     (set! (-> self script-line) (the-as pair arg0))
     )
    ((type-type? (rtype-of arg0) function)
     (set! (-> self script-func) (the-as (function none) arg0))
     )
    (else
      (format 0 "ERROR: camera-tracker requires a pair as a script, not ~A.~%" arg0)
      )
    )
  (let* ((gp-1 (ppointer->process (-> self parent)))
         (v1-17 (if (and (nonzero? gp-1) (type-type? (-> gp-1 type) process))
                    gp-1
                    )
                )
         )
    (if v1-17
        (set! (-> self entity) (-> (the-as process v1-17) entity))
        )
    )
  (set! (-> self event-hook) (-> camera-tracker-process event))
  (go camera-tracker-process)
  )

(deftype med-res-level (process-drawable)
  ((level     symbol  :offset-assert 176)
   (part-mode basic   :offset-assert 180)
   (index     int32   :offset-assert 184)
   )
  :heap-base #x50
  :method-count-assert 20
  :size-assert         #xbc
  :flag-assert         #x14005000bc
  (:states
    med-res-level-idle
    )
  )


(defstate med-res-level-idle (med-res-level)
  :code (behavior ()
    (local-vars (v1-37 float))
    (rlet ((vf0 :class vf)
           (vf16 :class vf)
           (vf17 :class vf)
           )
      (init-vf0-vector)
      (loop
        (let ((a0-1 (level-get *level* (-> self level)))
              (v1-3 (-> *game-info* current-continue level))
              )
          (cond
            ((and a0-1 (or (= (-> a0-1 display?) 'special) (= (-> a0-1 display?) 'special-vis)))
             (logclear! (-> self draw status) (draw-status hidden))
             (if (nonzero? (-> self skel))
                 (ja :num! (loop!))
                 )
             )
            ((or (and a0-1 (= (-> a0-1 status) 'active)) (= v1-3 'firecanyon))
             (logior! (-> self draw status) (draw-status hidden))
             )
            ((and (= (-> self level) 'firecanyon) (< (-> (camera-pos) y) 327680.0))
             (logior! (-> self draw status) (draw-status hidden))
             )
            (else
              (logclear! (-> self draw status) (draw-status hidden))
              (if (nonzero? (-> self part))
                  (spawn (-> self part) (-> self root trans))
                  )
              (if (nonzero? (-> self skel))
                  (ja :num! (loop!))
                  )
              )
            )
          )
        (when (not (logtest? (-> self draw status) (draw-status hidden)))
          (let ((v1-36 (-> self draw))
                (a0-18 (new 'stack-no-clear 'vector))
                )
            (.lvf vf16 (&-> v1-36 origin quad))
            (.lvf vf17 (&-> v1-36 bounds quad))
            (.mul.x.vf vf16 vf16 vf0 :mask #b1000)
            (.add.vf vf16 vf16 vf17)
            (.svf (&-> a0-18 quad) vf16)
            )
          (.mov v1-37 vf16)
          )
        (suspend)
        (init-vf0-vector)
        )
      (none)
      )
    )
  :post (the-as (function none :behavior med-res-level) ja-post)
  )

(define *lev-string* (new 'global 'string 64 (the-as string #f)))

(defmethod init-from-entity! med-res-level ((obj med-res-level) (arg0 entity-actor))
  (local-vars (sv-16 res-tag))
  (stack-size-set! (-> obj main-thread) 128)
  "#f"
  (let ((s4-0 (the-as (pointer sparticle-launch-group) #f)))
    (set! sv-16 (new 'static 'res-tag))
    (let* ((s3-0 (res-lump-data arg0 'art-name (pointer symbol) :tag-ptr (& sv-16)))
           (s2-0 (-> s3-0 0))
           )
      (cond
        ((not s3-0)
         )
        ((part-group-pointer? (the-as pointer s2-0))
         (set! s4-0 (the-as (pointer sparticle-launch-group) (-> s3-0 0)))
         )
        ((= (-> s2-0 type) string)
         (set! s4-0 (lookup-part-group-pointer-by-name (the-as string s2-0)))
         (if s4-0
             (set! (-> s3-0 0) (the-as symbol s4-0))
             )
         )
        ((= (-> s2-0 type) symbol)
         (let ((a0-7 (symbol->string s2-0)))
           (set! s4-0 (lookup-part-group-pointer-by-name a0-7))
           )
         (if s4-0
             (set! (-> s3-0 0) (the-as symbol s4-0))
             )
         )
        )
      )
    (when (the-as object s4-0)
      (let ((a0-8 (-> s4-0 0)))
        (if (and (nonzero? a0-8) (= (-> a0-8 type) sparticle-launch-group))
            (set! (-> obj part) (create-launch-control a0-8 obj))
            )
        )
      )
    )
  (process-entity-status! obj (entity-perm-status bit-7) #t)
  (let ((s4-1 (res-lump-struct (-> obj entity) 'level structure))
        (s3-1 (res-lump-value (-> obj entity) 'index uint128))
        )
    (when s4-1
      (set! (-> obj level) (the-as symbol s4-1))
      (set! (-> obj index) (the-as int s3-1))
      (set! (-> obj root) (new 'process 'trsqv))
      (process-drawable-from-entity! obj arg0)
      (logclear! (-> obj mask) (process-mask actor-pause))
      (format (clear *lev-string*) "med-res-~S~S" s4-1 (if (zero? s3-1)
                                                           ""
                                                           (* s3-1 8)
                                                           )
              )
      (initialize-skeleton-by-name obj *lev-string* '())
      (logior! (-> obj draw status) (draw-status do-not-check-distance))
      (if (nonzero? (-> obj draw))
          (go med-res-level-idle)
          )
      )
    )
  (none)
  )

(defmethod is-visible? part-spawner ((obj part-spawner))
  (sphere<-vector+r! (-> obj world-sphere) (-> obj root trans) (-> obj radius))
  (sphere-in-view-frustum? (-> obj world-sphere))
  )

(defstate part-spawner-active (part-spawner)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('stop)
       (process-entity-status! self (entity-perm-status complete) #t)
       (set! (-> self enable) #f)
       #t
       )
      (('start)
       (process-entity-status! self (entity-perm-status complete) #f)
       (set! (-> self enable) #t)
       #t
       )
      (('trans)
       (let ((v0-1 (the-as object (-> (the-as vector (-> event param 0)) quad))))
         (set! (-> self root trans quad) (the-as uint128 v0-1))
         v0-1
         )
       )
      )
    )
  :code (behavior ()
    (loop
      (when (-> self enable)
        (spawn (-> self part) (-> self root trans))
        (if (nonzero? (-> self sound))
            (update! (-> self sound))
            )
        )
      (suspend)
      )
    (none)
    )
  )

(defmethod init-from-entity! part-spawner ((obj part-spawner) (arg0 entity-actor))
  (local-vars (sv-16 res-tag))
  (stack-size-set! (-> obj main-thread) 128)
  (set! (-> obj mask) (logior (process-mask ambient) (-> obj mask)))
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (logclear! (-> obj mask) (process-mask actor-pause))
  (set! (-> obj radius) 12288.0)
  (set! (-> obj enable)
        (not (and (-> obj entity) (logtest? (-> obj entity extra perm status) (entity-perm-status complete))))
        )
  (set! (-> obj sound) (new 'process 'ambient-sound (-> obj entity) (-> obj root trans)))
  (let ((s4-0 (the-as object "#f")))
    (let ((s3-0 (the-as (pointer sparticle-launch-group) #f)))
      (set! sv-16 (new 'static 'res-tag))
      (let* ((s5-1 (res-lump-data arg0 'art-name (pointer (pointer sparticle-launch-group)) :tag-ptr (& sv-16)))
             (s2-0 (-> s5-1 0))
             )
        (cond
          ((part-group-pointer? s2-0)
           (set! s3-0 (-> s5-1 0))
           )
          ((= (-> s2-0 -1) string)
           (when (string= (the-as string s2-0) "group-beach-grotto-1")
             (set! (-> obj radius) 61440.0)
             (go beach-part-grotto-1)
             )
           (set! s4-0 s2-0)
           (set! s3-0 (lookup-part-group-pointer-by-name (the-as string s4-0)))
           (if s3-0
               (set! (-> s5-1 0) s3-0)
               )
           )
          ((= (-> s2-0 -1) symbol)
           (set! s4-0 (symbol->string (the-as symbol s2-0)))
           (set! s3-0 (lookup-part-group-pointer-by-name (the-as string s4-0)))
           (if s3-0
               (set! (-> s5-1 0) s3-0)
               )
           )
          (else
            (go process-drawable-art-error (the-as string s2-0))
            )
          )
        )
      (set! (-> obj mode) s3-0)
      (when s3-0
        (let ((a0-19 (-> s3-0 0)))
          (when (and (nonzero? a0-19) (= (-> a0-19 type) sparticle-launch-group))
            (set! (-> obj part) (create-launch-control a0-19 obj))
            (go part-spawner-active)
            )
          )
        )
      )
    (go process-drawable-art-error (the-as string s4-0))
    )
  (none)
  )

(deftype launcher (process-drawable)
  ((root-override   collide-shape         :offset        112)
   (spring-height   meters                :offset-assert 176)
   (camera          state                 :offset-assert 180)
   (active-distance float                 :offset-assert 184)
   (seek-time       time-frame            :offset-assert 192)
   (dest            vector        :inline :offset-assert 208)
   (sound-id        sound-id              :offset-assert 224)
   )
  :heap-base #x80
  :method-count-assert 20
  :size-assert         #xe4
  :flag-assert         #x14008000e4
  (:states
    launcher-active
    launcher-deactivated
    launcher-idle
    )
  )


(defpartgroup group-beach-launcher
  :id 37
  :bounds (static-bspherem 0 3 0 5)
  :parts ((sp-item 45 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 46 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 47 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 48 :fade-after (meters 50) :falloff-to (meters 80))
    (sp-item 49 :fade-after (meters 70) :falloff-to (meters 100))
    )
  )

(defpart 45
  :init-specs ((:num 1.5)
    (:x (meters 1.5))
    (:y (meters -0.5))
    (:rot-x 5)
    (:r 4096.0)
    (:g 2867.2)
    (:b 3276.8)
    (:vel-y (meters 0.026666667))
    (:timer (seconds 0.9))
    (:flags (aux-list))
    (:next-time (seconds 0.6))
    (:next-launcher 50)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 50
  :init-specs ((:fade-b -4.551111))
  )

(defpart 46
  :init-specs ((:texture (new 'static 'texture-id :index #xf :page #x2))
    (:num 1.0)
    (:x (meters 0) (meters 1.8))
    (:scale-x (meters 0.2))
    (:rot-x (degrees 90))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 2.5) (meters 2.5))
    (:r 0.0 1 128.0)
    (:g 64.0 196.0)
    (:b 128.0 128.0)
    (:a 128.0)
    (:scalevel-x (meters -0.0025))
    (:scalevel-y (meters 0.24414062) (meters 0.48828125))
    (:timer (seconds 0.27))
    (:flags (bit3))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 47
  :init-specs ((:texture (new 'static 'texture-id :index #xf :page #x2))
    (:num 2.0)
    (:x (meters 1.8) (meters 1))
    (:scale-x (meters 0.2))
    (:rot-x (degrees 90))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.5) (meters 1))
    (:r 0.0 1 128.0)
    (:g 64.0 196.0)
    (:b 128.0 128.0)
    (:a 128.0)
    (:scalevel-x (meters -0.0025))
    (:scalevel-y (meters 0.048828125) (meters 0.09765625))
    (:timer (seconds 0.27))
    (:flags (bit3))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 48
  :init-specs ((:texture (new 'static 'texture-id :index #x17 :page #x2))
    (:num 1.5)
    (:x (meters 2.9) (meters 2.5))
    (:y (meters -0.5))
    (:scale-x (meters 0.3) (meters 0.4))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.1) (meters 0.1))
    (:r 10.0 6.0)
    (:g 64.0 128.0)
    (:b 10.0 6.0)
    (:a 80.0)
    (:vel-x (meters -0.011666667) (meters -0.0033333334))
    (:vel-y (meters 0))
    (:rotvel-z (degrees -1.2) 1 (degrees 2.4))
    (:fade-a -0.2)
    (:accel-y (meters 0.0016666667))
    (:friction 0.996)
    (:timer (seconds 0.6) (seconds 0.397))
    (:flags (bit2))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 49
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 0.5)
    (:x (meters 2.9) (meters 2.5))
    (:y (meters -0.5))
    (:scale-x (meters 2) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 32.0 32.0)
    (:g 32.0 32.0)
    (:b 10.0 5.0)
    (:a 0.0)
    (:vel-x (meters -0.011666667) (meters -0.0033333334))
    (:vel-y (meters 0))
    (:rotvel-z (degrees -1.2) 1 (degrees 2.4))
    (:fade-a 0.6)
    (:accel-y (meters 0.0016666667))
    (:friction 0.996)
    (:timer (seconds 0.9))
    (:flags (bit2 bit3))
    (:next-time (seconds 0.15))
    (:next-launcher 51)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 51
  :init-specs ((:fade-a -0.18))
  )

(defpartgroup group-jungle-launcher
  :id 38
  :bounds (static-bspherem 0 3 0 5)
  :parts ((sp-item 45 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 52 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 53 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 54 :fade-after (meters 70) :falloff-to (meters 100))
    )
  )

(defpart 52
  :init-specs ((:texture (new 'static 'texture-id :index #xf :page #x2))
    (:num 1.0)
    (:x (meters 0) (meters 1.4))
    (:scale-x (meters 0.2))
    (:rot-x (degrees 90))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 2.5) (meters 2.5))
    (:r 0.0 1 128.0)
    (:g 64.0 196.0)
    (:b 128.0 128.0)
    (:a 128.0)
    (:scalevel-x (meters -0.0025))
    (:scalevel-y (meters 0.24414062) (meters 0.48828125))
    (:timer (seconds 0.27))
    (:flags (bit3))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 53
  :init-specs ((:texture (new 'static 'texture-id :index #xf :page #x2))
    (:num 2.0)
    (:x (meters 1.4) (meters 0.9))
    (:scale-x (meters 0.2))
    (:rot-x (degrees 90))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.5) (meters 1))
    (:r 0.0 1 128.0)
    (:g 64.0 196.0)
    (:b 128.0 128.0)
    (:a 128.0)
    (:scalevel-x (meters -0.0025))
    (:scalevel-y (meters 0.048828125) (meters 0.09765625))
    (:timer (seconds 0.27))
    (:flags (bit3))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 54
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 0.5)
    (:x (meters 2.9) (meters 2.5))
    (:y (meters -0.5))
    (:scale-x (meters 2) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 64.0 32.0)
    (:g 32.0 32.0)
    (:b 10.0 5.0)
    (:a 0.0)
    (:vel-x (meters -0.011666667) (meters -0.0033333334))
    (:vel-y (meters 0))
    (:rotvel-z (degrees -1.2) 1 (degrees 2.4))
    (:fade-a 0.6)
    (:accel-y (meters 0.0016666667))
    (:friction 0.996)
    (:timer (seconds 0.9))
    (:flags (bit2 bit3))
    (:next-time (seconds 0.15))
    (:next-launcher 51)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpartgroup group-swamp-launcher
  :id 39
  :bounds (static-bspherem 0 3 0 5)
  :parts ((sp-item 45 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 46 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 47 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 55 :fade-after (meters 70) :falloff-to (meters 100))
    )
  )

(defpart 55
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 0.5)
    (:x (meters 2.9) (meters 2.5))
    (:y (meters -0.5))
    (:scale-x (meters 2) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 16.0 16.0)
    (:g 16.0 16.0)
    (:b 5.0 2.5)
    (:a 0.0)
    (:vel-x (meters -0.011666667) (meters -0.0033333334))
    (:vel-y (meters 0))
    (:rotvel-z (degrees -1.2) 1 (degrees 2.4))
    (:fade-a 0.6)
    (:accel-y (meters 0.0016666667))
    (:friction 0.996)
    (:timer (seconds 0.9))
    (:flags (bit2))
    (:next-time (seconds 0.15))
    (:next-launcher 51)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defbehavior cam-launcher-joystick camera-slave ()
  (when *camera-read-analog*
    (let ((s5-0 (new-stack-matrix0))
          (gp-0 (vector-reset! (new 'stack-no-clear 'vector)))
          )
      (let* ((f0-0 (analog-input-horizontal-third (the-as int (+ (-> *cpad-list* cpads 0 rightx) -128)) 0.0 48.0 110.0 -1.0))   ;; changed for pc port
             (f1-1 (* -546.13336 f0-0))
             (f0-2 (fmin 546.13336 (fmax -546.13336 f1-1)))
             )
        (matrix-axis-angle! s5-0 (-> *camera* local-down) f0-2)
        )
      (vector-! gp-0 (-> self trans) (-> *camera* tpos-curr))
      (vector-matrix*! gp-0 gp-0 s5-0)
      (vector+! (-> self trans) gp-0 (-> *camera* tpos-curr))
      )
    )
  )

(defstate cam-launcher-shortfall (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('teleport)
       #f
       )
      (else
        (cam-standard-event-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (let ((gp-0 (new 'stack-no-clear 'vector)))
        (vector--float*! (-> self trans) (-> *camera* tpos-curr) (-> *camera* local-down) 28672.0)
        (vector-flatten! gp-0 (-> self tracking inv-mat vector 2) (-> *camera* local-down))
        (vector-normalize! gp-0 1.0)
        (set! (-> self pivot-pt quad) (-> gp-0 quad))
        (vector+float*! gp-0 gp-0 (-> *camera* local-down) 1000.0)
        (vector-normalize-copy! (-> self tracking inv-mat vector 2) gp-0 1.0)
        )
      (vector-cross!
        (-> self tracking inv-mat vector 1)
        (-> self tracking inv-mat vector 2)
        (the-as vector (-> self tracking))
        )
      (set! (-> self blend-from-type) (the-as uint 0))
      (set! (-> self blend-to-type) (the-as uint 0))
      0
      )
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) 2))
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (-> *display* base-frame-counter)))
      (loop
        (when (not (paused?))
          (vector--float*! (-> self trans) (-> *camera* tpos-curr) (-> *camera* local-down) 28672.0)
          (send-event *camera* 'teleport)
          (if (and (-> *camera* on-ground) (>= (- (-> *display* base-frame-counter) gp-0) (seconds 1)))
              (send-event *camera* 'change-state *camera-base-mode* (seconds 0.5))
              )
          )
        (suspend)
        )
      )
    (none)
    )
  )

;; blue eco launcher cam (not used for enclosed launchers like in jungle temple)
(defbehavior cam-launcher-long-joystick camera-slave ()
  (when *camera-read-analog*
    (let ((gp-0 (new-stack-matrix0)))
      (let* ((f0-0 (analog-input-horizontal-third (the-as int (+ (-> *cpad-list* cpads 0 rightx) -128)) 0.0 48.0 110.0 -1.0))   ;; changed for pc port
             (f1-1 (* -546.13336 f0-0))
             (f0-2 (fmin 546.13336 (fmax -546.13336 f1-1)))
             )
        (matrix-axis-angle! gp-0 (-> *camera* local-down) (* DISPLAY_FPS_RATIO f0-2)) ;; changed for high fps
        )
      (vector-matrix*! (-> self view-flat) (-> self view-flat) gp-0)
      )
    (vector-normalize! (-> self view-flat) 4096.0)
    )
  )

(defstate cam-launcher-longfall (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('teleport)
       #f
       )
      (else
        (cam-standard-event-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (new 'stack-no-clear 'vector)
      (vector-negate! (-> self view-flat) (-> self tracking inv-mat vector 2))
      (vector-normalize! (-> self view-flat) 4096.0)
      (vector--float*! (-> self trans) (-> *camera* tpos-curr) (-> *camera* local-down) 28672.0)
      (vector+! (-> self trans) (-> self trans) (-> self view-flat))
      (set! (-> self blend-from-type) (the-as uint 0))
      (set! (-> self blend-to-type) (the-as uint 0))
      (cam-calc-follow! (-> self tracking) (-> self trans) #f)
      (slave-set-rotation! (-> self tracking) (-> self trans) (the-as float (-> self options)) (-> self fov) #f)
      )
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) 2))
        (cam-slave-go cam-free-floating)
        )
    (cam-launcher-long-joystick)
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (-> *display* base-frame-counter)))
      (loop
        (when (not (paused?))
          (let ((s4-0 (new 'stack-no-clear 'vector))
                (s5-0 (new 'stack-no-clear 'vector))
                )
            0.0
            0.0
            0.0
            (send-event *camera* 'teleport)
            (let* ((f0-4 (vector-dot (-> self velocity) (-> *camera* local-down)))
                   (f30-0 (* 0.975 f0-4))
                   )
              (vector--float*! s4-0 (-> *camera* tpos-curr) (-> *camera* local-down) 28672.0)
              (vector-! s4-0 s4-0 (-> self trans))
              (let ((f28-0 (vector-dot s4-0 (-> *camera* local-down))))
                (vector--float*! s5-0 s4-0 (-> *camera* local-down) f28-0)
                (cond
                  ((< f28-0 f30-0)
                   (set! f30-0 f28-0)
                   )
                  ((< 20480.0 f28-0)
                   (let ((f28-1 (+ -20480.0 f28-0)))
                     (let ((f0-8 (lerp f30-0 f28-1 0.005)))
                       (if (< f30-0 f0-8)
                           (set! f30-0 f0-8)
                           )
                       )
                     (if (< (* 0.09 f28-1) f30-0)
                         (set! f30-0 (* 0.09 f28-1))
                         )
                     )
                   )
                  )
                )
              (vector+float*! (-> self velocity) s5-0 (-> *camera* local-down) f30-0)
              )
            )
          (vector+! (-> self trans) (-> self trans) (-> self velocity))
          (set! (-> self trans x) (-> *camera* tpos-curr x))
          (set! (-> self trans z) (-> *camera* tpos-curr z))
          (vector+! (-> self trans) (-> self trans) (-> self view-flat))
          (if (and (-> *camera* on-ground) (>= (- (-> *display* base-frame-counter) gp-0) (seconds 1)))
              (send-event *camera* 'change-state *camera-base-mode* (seconds 0.5))
              )
          )
        (vector-reset! (-> self tracking follow-off))
        (vector+! (-> self tracking follow-pt) (-> *camera* tpos-curr-adj) (-> self tracking follow-off))
        (vector--float*!
          (-> self tracking follow-pt)
          (-> self tracking follow-pt)
          (-> *camera* local-down)
          (-> *camera* target-height)
          )
        (slave-set-rotation! (-> self tracking) (-> self trans) (the-as float (-> self options)) (-> self fov) #f)
        (suspend)
        )
      )
    (none)
    )
  )

(defstate launcher-idle (launcher)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('instant-death)
       (go launcher-deactivated)
       )
      (('trans)
       (move-to-point! (-> self root-override) (the-as vector (-> event param 0)))
       (update-transforms! (-> self root-override))
       )
      )
    )
  :trans (behavior ()
    (when (and *target* (>= (-> self active-distance)
                            (vector-vector-distance (-> self root-override trans) (-> *target* control trans))
                            )
               )
      (cond
        ((send-event *target* 'query 'powerup (pickup-type eco-blue))
         (go launcher-active)
         )
        (else
          (let ((gp-0 'target-launch))
            (if (= (send-event *target* 'query 'mode) gp-0)
                (send-event *target* 'end-mode)
                )
            )
          )
        )
      (if (and (and *target* (>= 32768.0 (vector-vector-distance (-> self root-override trans) (-> *target* control trans))))
               (not (send-event *target* 'query 'powerup (pickup-type eco-blue)))
               )
          (level-hint-spawn
            (text-id sidekick-hint-launcher)
            "sksp0035"
            (the-as entity #f)
            *entity-pool*
            (game-task none)
            )
          )
      )
    (none)
    )
  :code (the-as (function none :behavior launcher) anim-loop)
  )

(defstate launcher-active (launcher)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (when (or (= event-type 'touch) (= event-type 'attack))
      (set! (-> self state-time) (-> *display* base-frame-counter))
      (send-event proc 'launch (-> self spring-height) (-> self camera) (-> self dest) (-> self seek-time))
      )
    (cond
      ((= event-type 'instant-death)
       (go launcher-deactivated)
       )
      ((= event-type 'trans)
       (move-to-point! (-> self root-override) (the-as vector (-> event param 0)))
       (update-transforms! (-> self root-override))
       )
      )
    )
  :exit (behavior ()
    (let ((v1-0 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-0 command) (sound-command set-param))
      (set! (-> v1-0 id) (-> self sound-id))
      (set! (-> v1-0 parms volume) -4)
      (set! (-> v1-0 auto-time) 120)
      (set! (-> v1-0 auto-from) 2)
      (set! (-> v1-0 parms mask) (sound-mask volume time))
      (-> v1-0 id)
      )
    (none)
    )
  :trans (behavior ()
    (if (or (or (not *target*) (< (-> self active-distance)
                                  (vector-vector-distance (-> self root-override trans) (-> *target* control trans))
                                  )
                )
            (not (send-event *target* 'query 'powerup (pickup-type eco-blue)))
            )
        (go launcher-idle)
        )
    (spawn (-> self part) (-> self root-override trans))
    (sound-play "launch-idle" :id (-> self sound-id))
    (if (and (and *target* (>= (+ 2867.2 (-> self root-override root-prim prim-core world-sphere w))
                               (vector-vector-distance (-> self root-override trans) (-> *target* control trans))
                               )
                  )
             (< (- (-> *display* base-frame-counter) (-> self state-time)) (seconds 0.5))
             )
        (send-event *target* 'launch (-> self spring-height) (-> self camera) (-> self dest) (-> self seek-time))
        )
    (none)
    )
  :code (behavior ()
    (sound-play "launch-start")
    (anim-loop)
    (none)
    )
  )

(defstate launcher-deactivated (launcher)
  :code (the-as (function none :behavior launcher) anim-loop)
  )

(defmethod init-from-entity! launcher ((obj launcher) (arg0 entity-actor))
  (stack-size-set! (-> obj main-thread) 128)
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 12288.0)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) 13926.4)
    (backup-collide-with-as s4-0)
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (update-transforms! (-> obj root-override))
  (set! (-> obj active-distance) 409600.0)
  (set! (-> obj spring-height) (res-lump-float arg0 'spring-height :default 163840.0))
  (let ((s4-1 (res-lump-value arg0 'mode uint128)))
    (let ((v1-18 (-> obj entity extra level name)))
      (set! (-> obj part) (create-launch-control
                            (cond
                              ((= v1-18 'beach)
                               (-> *part-group-id-table* 37)
                               )
                              ((= v1-18 'swamp)
                               (-> *part-group-id-table* 39)
                               )
                              (else
                                (-> *part-group-id-table* 38)
                                )
                              )
                            obj
                            )
            )
      )
    (let ((v1-24 (logand (the-as int s4-1) 255)))
      (cond
        ((= (the-as uint v1-24) 1)
         (set! (-> obj camera) cam-launcher-longfall)
         )
        ((= (the-as uint v1-24) 2)
         (set! (-> obj camera) #f)
         )
        (else
          (set! (-> obj camera) cam-launcher-shortfall)
          )
        )
      )
    )
  (let ((v1-29 (res-lump-struct arg0 'alt-vector vector)))
    (when v1-29
      (set-vector! (-> obj dest) (-> v1-29 x) (-> v1-29 y) (-> v1-29 z) 1.0)
      (set! (-> obj seek-time) (the-as time-frame (the int (* 300.0 (-> v1-29 w)))))
      )
    )
  (set! (-> obj sound-id) (new-sound-id))
  (nav-mesh-connect obj (-> obj root-override) (the-as nav-control #f))
  (go launcher-idle)
  (none)
  )

(defbehavior launcher-init-by-other launcher ((arg0 vector) (arg1 float) (arg2 int) (arg3 float))
  (stack-size-set! (-> self main-thread) 128)
  (let ((s2-0 (new 'process 'collide-shape self (collide-list-enum hit-by-player))))
    (let ((s1-0 (new 'process 'collide-shape-prim-sphere s2-0 (the-as uint 0))))
      (set! (-> s1-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s1-0 collide-with) (collide-kind target))
      (set-vector! (-> s1-0 local-sphere) 0.0 0.0 0.0 12288.0)
      (set-root-prim! s2-0 s1-0)
      )
    (set! (-> s2-0 nav-radius) (* 0.75 (-> s2-0 root-prim local-sphere w)))
    (backup-collide-with-as s2-0)
    (set! (-> self root-override) s2-0)
    )
  (set! (-> self root-override trans quad) (-> arg0 quad))
  (set-vector! (-> self root-override scale) 1.0 1.0 1.0 1.0)
  (set-vector! (-> self root-override quat) 0.0 0.0 0.0 1.0)
  (update-transforms! (-> self root-override))
  (set! (-> self spring-height) arg1)
  (set! (-> self active-distance) arg3)
  (let ((v1-23 (-> self entity extra level name)))
    (set! (-> self part) (create-launch-control
                           (cond
                             ((= v1-23 'beach)
                              (-> *part-group-id-table* 37)
                              )
                             ((= v1-23 'swamp)
                              (-> *part-group-id-table* 39)
                              )
                             (else
                               (-> *part-group-id-table* 38)
                               )
                             )
                           self
                           )
          )
    )
  (case (logand arg2 255)
    ((1)
     (set! (-> self camera) cam-launcher-longfall)
     )
    ((2)
     (set! (-> self camera) #f)
     )
    (else
      (set! (-> self camera) cam-launcher-shortfall)
      )
    )
  (let ((v1-34 (res-lump-struct (-> self entity) 'alt-vector vector)))
    (when v1-34
      (set-vector! (-> self dest) (-> v1-34 x) (-> v1-34 y) (-> v1-34 z) 1.0)
      (set! (-> self seek-time) (the-as time-frame (the int (* 300.0 (-> v1-34 w)))))
      )
    )
  (set! (-> self sound-id) (new-sound-id))
  (go launcher-idle)
  (none)
  )

(defstate touch-tracker-idle (touch-tracker)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (local-vars (v0-0 object))
    (the-as object (case event-type
                     (('touched)
                      (let ((v1-1 (ppointer->process (-> self parent))))
                        (when (!= v1-1 proc)
                          (cond
                            ((= (-> self event) 'attack)
                             (cond
                               ((= (-> proc type) target)
                                (send-event
                                  proc
                                  (-> self event)
                                  :from (the-as process v1-1)
                                  #f
                                  (static-attack-info ((mode (the-as symbol (-> self event-mode)))))
                                  )
                                )
                               ((= (-> v1-1 type) target)
                                (send-event
                                  proc
                                  (-> self event)
                                  :from (the-as process v1-1)
                                  #f
                                  (-> self event-mode)
                                  (-> *target* control unknown-dword50)
                                  (-> *target* control unknown-dword51)
                                  )
                                )
                               (else
                                 (let ((a1-5 (new 'stack-no-clear 'event-message-block)))
                                   (set! (-> a1-5 from) (the-as process v1-1))
                                   (set! (-> a1-5 num-params) 4)
                                   (set! (-> a1-5 message) (-> self event))
                                   (set! (-> a1-5 param 0) (the-as uint #f))
                                   (set! (-> a1-5 param 1) (the-as uint (-> self event-mode)))
                                   (let ((v1-19 (+ *global-attack-id* 1)))
                                     (set! *global-attack-id* v1-19)
                                     (set! (-> a1-5 param 2) (the-as uint v1-19))
                                     )
                                   (set! (-> a1-5 param 3) (the-as uint 0))
                                   (send-event-function proc a1-5)
                                   )
                                 )
                               )
                             )
                            ((-> self event)
                             (send-event proc (-> self event) :from (the-as process v1-1))
                             )
                            (else
                              (let ((t0-5 (new 'stack-no-clear 'event-message-block)))
                                (set! (-> t0-5 from) proc)
                                (set! (-> t0-5 num-params) arg1)
                                (set! (-> t0-5 message) event-type)
                                (set! (-> t0-5 param 0) (-> event param 0))
                                (set! (-> t0-5 param 1) (-> event param 1))
                                (set! (-> t0-5 param 2) (-> event param 2))
                                (set! (-> t0-5 param 3) (-> event param 3))
                                (set! (-> t0-5 param 4) (-> event param 4))
                                (set! (-> t0-5 param 5) (-> event param 5))
                                (set! (-> t0-5 param 6) (-> event param 6))
                                (send-event-function v1-1 t0-5)
                                )
                              )
                            )
                          )
                        )
                      )
                     (('target)
                      (set! v0-0 (process->handle (the-as process (-> event param 0))))
                      (set! (-> self target) (the-as handle v0-0))
                      v0-0
                      )
                     (('event)
                      (set! (-> self event) (the-as symbol (-> event param 0)))
                      (set! v0-0 (-> event param 1))
                      (set! (-> self event-mode) (the-as basic v0-0))
                      v0-0
                      )
                     (('exit)
                      (set! v0-0 (-> event param 0))
                      (set! (-> self run-function) (the-as (function object) v0-0))
                      v0-0
                      )
                     (('eval)
                      (the-as object ((the-as (function touch-tracker none) (-> event param 0)) self))
                      )
                     (('function)
                      (set! v0-0 (-> event param 0))
                      (set! (-> self callback) (the-as (function touch-tracker none) v0-0))
                      v0-0
                      )
                     )
            )
    )
  :code (behavior ()
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (while ((-> self run-function))
      (let* ((gp-0 (handle->process (-> self target)))
             (a0-4 (if (and (nonzero? gp-0) (type-type? (-> gp-0 type) process-drawable))
                       gp-0
                       )
                   )
             )
        (when a0-4
          (let* ((gp-1 (-> (the-as process-drawable a0-4) root))
                 (a0-6 (if (and (nonzero? gp-1) (type-type? (-> gp-1 type) collide-shape))
                           gp-1
                           )
                       )
                 )
            (if a0-6
                (set! (-> self root-override trans quad)
                      (-> (the-as collide-shape a0-6) root-prim prim-core world-sphere quad)
                      )
                )
            )
          )
        )
      (if (-> self callback)
          ((-> self callback) self)
          )
      (update-transforms! (-> self root-override))
      (let ((a1-3 (new 'stack-no-clear 'touching-shapes-entry)))
        (set! (-> a1-3 cshape1) (the-as collide-shape 2))
        (set! (-> a1-3 cshape2) (the-as collide-shape *touching-list*))
        (find-overlapping-shapes (-> self root-override) (the-as overlaps-others-params a1-3))
        )
      (suspend)
      )
    (clear-collide-with-as (-> self root-override))
    (suspend)
    0
    (none)
    )
  )

(defbehavior touch-tracker-init touch-tracker ((arg0 vector) (arg1 float) (arg2 time-frame))
  (let ((s4-0 (new 'process 'collide-shape-moving self (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((s2-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> s2-0 prim-core collide-as) (collide-kind target enemy))
      (set! (-> s2-0 collide-with) (collide-kind cak-1 cak-2 cak-3 powerup crate enemy wall-object ground-object))
      (set! (-> s2-0 prim-core offense) (collide-offense indestructible))
      (set-vector! (-> s2-0 local-sphere) 0.0 0.0 0.0 arg1)
      (set-root-prim! s4-0 s2-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> s4-0 event-self) 'touched)
    (set! (-> self root-override) s4-0)
    )
  (set! (-> self root-override trans quad) (-> arg0 quad))
  (set! (-> self duration) arg2)
  (set! (-> self target) (the-as handle #f))
  (set! (-> self event) #f)
  (set! (-> self callback) #f)
  (set! (-> self run-function)
        (lambda :behavior touch-tracker
          ()
          (< (- (-> *display* base-frame-counter) (-> self state-time)) (-> self duration))
          )
        )
  (set! (-> self event-hook) (-> touch-tracker-idle event))
  (go touch-tracker-idle)
  (none)
  )

(defun process-drawable-random-point! ((arg0 process-drawable) (arg1 vector))
  (let ((v1-1 (-> arg0 node-list length))
        (s4-0 (-> arg0 root))
        )
    (cond
      ((>= v1-1 7)
       (let ((v1-2 (rand-vu-int-range 3 (+ v1-1 -1))))
         (vector<-cspace! arg1 (-> arg0 node-list data v1-2))
         )
       )
      ((and (nonzero? s4-0) (type-type? (-> s4-0 type) collide-shape))
       (vector+!
         arg1
         (the-as vector (-> (the-as collide-shape s4-0) root-prim prim-core))
         (rand-vu-sphere-point! arg1 (-> (the-as collide-shape s4-0) root-prim prim-core world-sphere w))
         )
       )
      (else
        (vector+! arg1 (-> arg0 root trans) (rand-vu-sphere-point! arg1 (-> arg0 draw bounds w)))
        )
      )
    )
  arg1
  )

(defun process-drawable-pair-random-point! ((arg0 process-drawable) (arg1 process-drawable) (arg2 vector) (arg3 float))
  (let ((s4-0 (new-stack-vector0))
        (s3-0 (new-stack-vector0))
        )
    (process-drawable-random-point! arg0 s4-0)
    (process-drawable-random-point! arg1 s3-0)
    (vector-lerp! arg2 s4-0 s3-0 arg3)
    )
  )

(define *particle-quat* (new 'static 'quaternion :w 1.0))

(defun birth-func-set-quat ((arg0 int) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  (local-vars (a0-2 float) (a0-3 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((a0-1 arg2)
          (v1-0 *particle-quat*)
          )
      (cond
        ((< (-> v1-0 w) 0.0)
         (.lvf vf1 (&-> a0-1 conerot quad))
         (.lvf vf2 (&-> v1-0 vec quad))
         (.sub.vf vf1 vf0 vf2 :mask #b111)
         (.svf (&-> a0-1 conerot quad) vf1)
         (.mov a0-2 vf1)
         )
        (else
          (.lvf vf1 (&-> a0-1 conerot quad))
          (.lvf vf2 (&-> v1-0 vec quad))
          (.add.vf vf1 vf0 vf2 :mask #b111)
          (.svf (&-> a0-1 conerot quad) vf1)
          (.mov a0-3 vf1)
          )
        )
      )
    0
    (none)
    )
  )

(defpart 2528
  :init-specs ((:texture (new 'static 'texture-id :index #xc :page #x2))
    (:birth-func 'birth-func-set-quat)
    (:num 1.0)
    (:scale-x (meters 2) (meters 0.5))
    (:scale-y (meters 5.6))
    (:r 0.0 44.0)
    (:g 0.0 64.0)
    (:b 128.0 32.0)
    (:a 128.0)
    (:timer (seconds 0.017))
    (:flags (bit2 bit3 bit14 left-multiply-quat))
    )
  )

(defun draw-eco-beam ((arg0 vector) (arg1 vector))
  (when (line-in-view-frustum? arg0 arg1)
    (let ((s2-1 (vector-! (new 'stack-no-clear 'vector) arg1 arg0))
          (gp-1 (new 'stack-no-clear 'vector))
          (s4-0 (new 'stack-no-clear 'vector))
          (s5-0 (new 'stack-no-clear 'quaternion))
          )
      (vector+*! gp-1 arg0 s2-1 0.5)
      (vector-normalize-copy! s4-0 s2-1 1.0)
      (set! (-> *part-id-table* 2528 init-specs 4 initial-valuef) (vector-length s2-1))
      (forward-up->quaternion s5-0 s4-0 *y-vector*)
      (dotimes (s4-1 3)
        (quaternion-rotate-local-z! s5-0 s5-0 10922.667)
        (quaternion-copy! *particle-quat* s5-0)
        (launch-particles :system *sp-particle-system-3d* (-> *part-id-table* 2528) gp-1)
        )
      )
    )
  0
  (none)
  )
