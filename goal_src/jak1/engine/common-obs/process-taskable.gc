;;-*-Lisp-*-
(in-package goal)

;; name: process-taskable.gc
;; name in dgo: process-taskable
;; dgos: GAME, ENGINE

(defmacro is-nan-hack (flt)
  `(and (< 0.0 ,flt) (< ,flt 0.0))
  )

(defmacro less-than-hack (a b)
  `(if (is-nan-hack ,a)
       #f
       (< ,a ,b)
       )
  )

;; DECOMP BEGINS

(defmethod process-taskable-method-52 process-taskable ((obj process-taskable))
  (let ((v1-1 (-> obj draw shadow-ctrl)))
    (when v1-1
      (let ((a0-1 v1-1))
        (set! (-> a0-1 settings bot-plane w) (- -12288.0))
        )
      0
      (set! (-> v1-1 settings top-plane w) (- 4096.0))
      0
      )
    )
  (none)
  )

(defmethod init! gui-query ((obj gui-query) (arg0 string) (arg1 int) (arg2 int) (arg3 int) (arg4 symbol) (arg5 string))
  (set! (-> obj x-position) arg1)
  (set! (-> obj y-position) arg2)
  (set! (-> obj message-space) arg3)
  (set! (-> obj only-allow-cancel) arg4)
  (set! (-> obj message) arg0)
  (set! (-> obj decision) 'undecided)
  (set! (-> obj no-msg) arg5)
  0
  (none)
  )

(defmethod get-response gui-query ((obj gui-query))
  (kill-current-level-hint '() '(sidekick voicebox stinger) 'exit)
  (level-hint-surpress!)
  (hide-hud)
  (when (hud-hidden?)
    (when (-> obj message)
      (let ((a1-2 (new
                    'stack
                    'font-context
                    *font-default-matrix*
                    (-> obj x-position)
                    (-> obj y-position)
                    0.0
                    (font-color default)
                    (font-flags shadow kerning)
                    )
                  )
            )
        (let ((v1-4 a1-2))
          (set! (-> v1-4 width) (the float (- 512 (-> obj x-position))))
          )
        (let ((v1-5 a1-2))
          (set! (-> v1-5 height) (the float 40))
          )
        (let ((v1-6 a1-2))
          (set! (-> v1-6 scale) 0.9)
          )
        (set! (-> a1-2 flags) (font-flags shadow kerning left large))
        (print-game-text (-> obj message) a1-2 #f 128 22)
        )
      )
    ;; PAL patch here
    (cond
      ((-> obj only-allow-cancel)
       (when (-> obj no-msg)
         (clear *temp-string*)
         (format *temp-string* "; = ~S" (-> obj no-msg))
         (let ((a1-5 (new
                       'stack
                       'font-context
                       *font-default-matrix*
                       (-> obj x-position)
                       (+ (-> obj y-position) 5 (-> obj message-space))
                       0.0
                       (font-color default)
                       (font-flags shadow kerning)
                       )
                     )
               )
           (let ((v1-15 a1-5))
             (set! (-> v1-15 width) (the float 400))
             )
           (let ((v1-16 a1-5))
             (set! (-> v1-16 height) (the float 100))
             )
           (set! (-> a1-5 flags) (font-flags shadow kerning large))
           (print-game-text *temp-string* a1-5 #f 128 22)
           )
         )
       )
      (else
        (let ((s5-0 (new
                      'stack
                      'font-context
                      *font-default-matrix*
                      (-> obj x-position)
                      (+ (-> obj y-position) 5 (-> obj message-space))
                      0.0
                      (font-color default)
                      (font-flags shadow kerning)
                      )
                    )
              )
          (let ((v1-22 s5-0))
            (set! (-> v1-22 width) (the float 400))
            )
          (let ((v1-23 s5-0))
            (set! (-> v1-23 height) (the float 100))
            )
          (set! (-> s5-0 flags) (font-flags shadow kerning large))
          (print-game-text (lookup-text! *common-text* (text-id confirm) #f) s5-0 #f 128 22)
          )
        )
      )
    (cond
      ((!= (-> obj decision) 'undecided)
       )
      ((and (cpad-pressed? 0 x) (not (-> obj only-allow-cancel)))
       (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons x))
       (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons x))
       (set! (-> obj decision) 'yes)
       )
      ((cpad-pressed? 0 triangle)
       (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
       (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
       (set! (-> obj decision) 'no)
       )
      )
    )
  (-> obj decision)
  )

(defmethod relocate process-taskable ((obj process-taskable) (arg0 int))
  (the-as process-taskable ((method-of-type process-drawable relocate) obj arg0))
  )

(defmethod process-taskable-method-46 process-taskable ((obj process-taskable))
  (when (nonzero? (-> obj sound-flava))
    (let ((s5-1 (vector-!
                  (new 'stack-no-clear 'vector)
                  (target-pos 0)
                  (the-as vector (-> obj root-override root-prim prim-core))
                  )
                )
          )
      (set! (-> s5-1 y) (* 4.0 (-> s5-1 y)))
      (cond
        ;; s5-1 can be nan on the first frame after something spawns
        ((less-than-hack (vector-length s5-1) 102400.0)
         (when (not (-> obj have-flava))
           (set! (-> obj have-flava) #t)
           (set-setting! 'sound-flava #f 20.0 (-> obj sound-flava))
           )
         )
        ((-> obj have-flava)
         (remove-setting! 'sound-flava)
         (set! (-> obj have-flava) #f)
         )
        )
      )
    )
  (when (-> obj music)
    (let ((s5-3 (vector-!
                  (new 'stack-no-clear 'vector)
                  (target-pos 0)
                  (the-as vector (-> obj root-override root-prim prim-core))
                  )
                )
          )
      (set! (-> s5-3 y) (* 4.0 (-> s5-3 y)))
      (cond
        ((< (vector-length s5-3) 102400.0)
         (when (not (-> obj have-music))
           (set! (-> obj have-music) #t)
           (set-setting! 'music (-> obj music) 0.0 0)
           )
         )
        ((-> obj have-music)
         (remove-setting! 'music)
         (set! (-> obj have-music) #f)
         )
        )
      )
    )
  0
  (none)
  )

(defmethod get-art-elem process-taskable ((obj process-taskable))
  (the-as art-element (if (> (-> obj skel active-channels) 0)
                          (-> obj skel root-channel 0 frame-group)
                          )
          )
  )

(defmethod play-anim! process-taskable ((obj process-taskable) (arg0 symbol))
  (the-as basic #f)
  )

(defmethod process-taskable-method-33 process-taskable ((obj process-taskable))
  (let ((s5-0 (play-anim! obj #f)))
    (if (type-type? (-> s5-0 type) spool-anim)
        (spool-push *art-control* (-> (the-as spool-anim s5-0) name) 0 obj -99.0)
        )
    )
  0
  (none)
  )

(defmethod close-anim-file! process-taskable ((obj process-taskable))
  (let* ((gp-0 (play-anim! obj #f))
         (v1-2 (if (and (nonzero? gp-0) (type-type? (-> gp-0 type) spool-anim))
                   gp-0
                   )
               )
         )
    (if v1-2
        (file-status *art-control* (-> (the-as spool-anim v1-2) name) 0)
        )
    )
  )

(defmethod get-accept-anim process-taskable ((obj process-taskable) (arg0 symbol))
  (the-as spool-anim #f)
  )

(defmethod push-accept-anim process-taskable ((obj process-taskable))
  (let ((s5-0 (get-accept-anim obj #f)))
    (if (type-type? (-> s5-0 type) spool-anim)
        (spool-push *art-control* (-> s5-0 name) 0 obj -99.0)
        )
    )
  0
  (none)
  )

(defmethod get-reject-anim process-taskable ((obj process-taskable) (arg0 symbol))
  (the-as spool-anim #f)
  )

(defmethod push-reject-anim process-taskable ((obj process-taskable))
  (let ((s5-0 (get-reject-anim obj #f)))
    (if (type-type? (-> s5-0 type) spool-anim)
        (spool-push *art-control* (-> s5-0 name) 0 obj -99.0)
        )
    )
  0
  (none)
  )

(defmethod process-taskable-method-38 process-taskable ((obj process-taskable))
  (if (nonzero? (-> obj cell-for-task))
      (go (method-of-object obj give-cell))
      )
  (go (method-of-object obj release))
  (none)
  )

(defbehavior process-taskable-anim-loop process-taskable ()
  (when (!= (ja-group) (get-art-elem self))
    (ja-channel-push! 1 (seconds 0.2))
    (ja :group! (get-art-elem self))
    )
  (loop
    (suspend)
    (ja :num! (loop!))
    (if (= (-> self next-state name) 'idle)
        (process-taskable-method-43 self)
        )
    )
  (the-as none 0)
  (none)
  )

(defstate release (process-taskable)
  :virtual #t
  :trans (behavior ()
    (when (process-release? *target*)
      (send-event *target* 'trans 'restore (-> self old-target-pos))
      (if (should-display? self)
          (go-virtual idle)
          (go-virtual hidden)
          )
      )
    (process-taskable-method-33 self)
    ((-> self cur-trans-hook))
    (none)
    )
  :code process-taskable-anim-loop
  :post (the-as (function none :behavior process-taskable) ja-post)
  )

(defstate give-cell (process-taskable)
  :virtual #t
  :trans (behavior ()
    (cond
      ((nonzero? (-> self cell-for-task))
       (let ((gp-0 (handle->process (-> self cell-x))))
         (when gp-0
           (send-event *target* 'trans 'reset)
           (send-event gp-0 'pickup (target-pos 0))
           (go-virtual idle)
           )
         )
       (format #t "ERROR<GMJ>: ~S no cell spawned~%" (-> self name))
       (send-event *target* 'get-pickup 6 (the float (-> self cell-for-task)))
       )
      (else
        (format
          #t
          "ERROR<GMJ>: ~S got into give-cell with give-cell == #f task = ~S~%"
          (-> self name)
          (game-task->string (current-task (-> self tasks)))
          )
        )
      )
    (go-virtual release)
    (process-taskable-method-33 self)
    ((-> self cur-trans-hook))
    (none)
    )
  :code process-taskable-anim-loop
  :post (the-as (function none :behavior process-taskable) ja-post)
  )

(defstate lose (process-taskable)
  :virtual #t
  :enter (behavior ()
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (none)
    )
  :trans (behavior ()
    (if (and (>= (- (-> *display* base-frame-counter) (-> self state-time)) (seconds 5))
             (or (not *target*)
                 (< 20480.0 (vector-vector-distance (-> self root-override trans) (-> *target* control trans)))
                 )
             )
        (go-virtual idle)
        )
    ((-> self cur-trans-hook))
    (none)
    )
  :code process-taskable-anim-loop
  :post (the-as (function none :behavior process-taskable) ja-post)
  )

(defstate enter-playing (process-taskable)
  :virtual #t
  :code process-taskable-anim-loop
  :post (the-as (function none :behavior process-taskable) ja-post)
  )

(defbehavior process-taskable-play-anim-enter process-taskable ()
  (init! (-> self query) (the-as string #f) 40 150 25 #t (the-as string #f))
  (logior! (-> self skel status) (janim-status blerc))
  (set! (-> self camera)
        (ppointer->handle (process-spawn othercam self (-> self cam-joint-index) #f #t :to self))
        )
  (set! (-> self cell-for-task) (game-task none))
  (set! (-> self skippable) #f)
  (set! (-> self blend-on-exit) #f)
  (set! (-> self will-talk) #f)
  #f
  )

(defbehavior process-taskable-play-anim-exit process-taskable ()
  (logclear! (-> self skel status) (janim-status blerc))
  (let ((a0-4 (handle->process (-> self camera))))
    (if a0-4
        (deactivate a0-4)
        )
    )
  (set! (-> self last-talk) (-> *display* game-frame-counter))
  (process-taskable-method-52 self)
  (none)
  )

(defbehavior process-taskable-play-anim-trans process-taskable ()
  (if (nonzero? *camera-look-through-other*)
      (set! *camera-look-through-other* 2)
      )
  (set-letterbox-frames (seconds 0.017))
  (draw-npc-shadow self)
  (none)
  )

(defbehavior process-taskable-play-anim-code process-taskable ((arg0 art-joint-anim) (arg1 basic))
  (when (nonzero? (-> self cell-for-task))
    (if (name= (-> self state name) "play-anim")
        (set! (-> self cell-x) (ppointer->handle (process-spawn
                                                   fuel-cell
                                                   :init fuel-cell-init-as-clone
                                                   (process->handle self)
                                                   (-> self cell-for-task)
                                                   :to self
                                                   )
                                                 )
              )
        (format #t "ERROR<GMJ>: ~S ~S trying to give cell on release~%" (-> self name) (-> self state name))
        )
    )
  (cond
    ((and arg1 (type-type? (-> arg1 type) spool-anim))
     (when *target*
       (while (not (send-event *target* 'clone-anim self))
         (spool-push *art-control* (-> (the-as spool-anim arg1) name) 0 self -99.0)
         (format #t "WARNING: ~A stall on not cloning.~%" (-> self name))
         (suspend)
         )
       (send-event (ppointer->process (-> *target* sidekick)) 'matrix 'play-anim)
       (send-event *target* 'blend-shape #t)
       )
     (add-setting! 'music-volume 'rel (-> *setting-control* current music-volume-movie) 0)
     (add-setting! 'sfx-volume 'rel (-> *setting-control* current sfx-volume-movie) 0)
     (add-setting! 'ambient-volume 'rel (-> *setting-control* current ambient-volume-movie) 0)
     (if (-> self blend-on-exit)
         (set! (-> self blend-on-exit) arg0)
         )
     ;; allow cutscene skipping on pc port
     ;; save a sort of timestamp just so we know if it took at least 1 frame
     (#when PC_PORT
        (define *play-anim-time* (current-time)))
     (if (#if PC_PORT
              (= (-> *pc-settings* skip-movies?) #t)
              (and *debug-segment* *cheat-mode*))
         (ja-play-spooled-anim
           (the-as spool-anim arg1)
           arg0
           (-> self blend-on-exit)
           (lambda ((arg0 process-taskable)) (= (get-response (-> arg0 query)) 'no))
           )
         (ja-play-spooled-anim
           (the-as spool-anim arg1)
           arg0
           (-> self blend-on-exit)
           (the-as (function process-drawable symbol) false-func)
           )
         )
     (#when PC_PORT
        (if (= (current-time) *play-anim-time*) (suspend)))
     (remove-setting! 'music-volume)
     (remove-setting! 'sfx-volume)
     (remove-setting! 'ambient-volume)
     (send-event *target* 'blend-shape #f)
     )
    (else
      (when (not arg1)
        (format #t "ERROR<GMJ>: ~S ~S got #f from anim picker~%" (-> self name) (-> self state name))
        (set! arg1 (ja-group))
        )
      (when (not (type-type? (-> arg1 type) art-joint-anim))
        (format
          0
          "ERROR<GMJ>: ~S ~S anim picker didn't return spool-anim or joint-art-anim (probably need to override it)~%"
          (-> self name)
          (-> self state name)
          )
        (set! arg1 (ja-group))
        )
      (format #t "~S ~S anim ~S~%" (-> self name) (-> self state name) (-> (the-as art-joint-anim arg1) name))
      (ja-channel-push! 1 (seconds 0.2))
      (set! (-> self skel root-channel 0 frame-group) (the-as art-joint-anim arg1))
      (when (< (ja-num-frames 0) 3)
        (suspend)
        (suspend)
        0
        )
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (if (and *debug-segment* (= (get-response (-> self query)) 'no))
            (ja :num-func num-func-identity :frame-num max)
            )
        (suspend)
        (ja :num! (seek!))
        )
      #f
      )
    )
  )

(defstate play-accept (process-taskable)
  :virtual #t
  :enter (the-as (function none :behavior process-taskable) process-taskable-play-anim-enter)
  :exit process-taskable-play-anim-exit
  :trans (behavior ()
    (process-taskable-play-anim-trans)
    ((-> self cur-trans-hook))
    (none)
    )
  :code (behavior ()
    (process-taskable-play-anim-code (the-as art-joint-anim (get-art-elem self)) (get-accept-anim self #t))
    (while (not (process-release? *target*))
      (suspend)
      )
    (go-virtual enter-playing)
    (none)
    )
  :post (the-as (function none :behavior process-taskable) ja-post)
  )

(defstate play-reject (process-taskable)
  :virtual #t
  :enter (the-as (function none :behavior process-taskable) process-taskable-play-anim-enter)
  :exit process-taskable-play-anim-exit
  :trans (behavior ()
    (process-taskable-play-anim-trans)
    ((-> self cur-trans-hook))
    (none)
    )
  :code (behavior ()
    (process-taskable-play-anim-code (the-as art-joint-anim (get-art-elem self)) (get-reject-anim self #t))
    (go-virtual release)
    (none)
    )
  :post (the-as (function none :behavior process-taskable) ja-post)
  )

(defstate query (process-taskable)
  :virtual #t
  :enter (behavior ()
    (init!
      (-> self query)
      (lookup-text! *common-text* (text-id confirm-play) #f)
      40
      150
      25
      #f
      (lookup-text! *common-text* (text-id quit) #f)
      )
    (none)
    )
  :exit process-taskable-play-anim-exit
  :trans (behavior ()
    (case (current-status (-> self tasks))
      (((task-status need-reminder-a))
       (case (get-response (-> self query))
         (('yes)
          (go-virtual play-accept)
          )
         (('no)
          (go-virtual play-reject)
          )
         )
       (push-accept-anim self)
       )
      (else
        (let ((gp-0 (get-response (-> self query))))
          (cond
            ((and (= gp-0 'yes) (process-release? *target*))
             (go-virtual enter-playing)
             )
            ((= gp-0 'no)
             (go-virtual play-reject)
             )
            )
          )
        )
      )
    (push-reject-anim self)
    (set! *camera-look-through-other* 2)
    ((-> self cur-trans-hook))
    (none)
    )
  :code process-taskable-anim-loop
  :post (the-as (function none :behavior process-taskable) ja-post)
  )

(defstate play-anim (process-taskable)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('shadow)
       (cond
         ((-> event param 0)
          (let ((v0-0 (the-as object (-> self shadow-backup))))
            (set! (-> self draw shadow) (the-as shadow-geo v0-0))
            v0-0
            )
          )
         (else
           (set! (-> self draw shadow) #f)
           #f
           )
         )
       )
      (('shadow-min-max)
       (let ((v1-5 (-> self draw shadow-ctrl)))
         (let ((a0-4 v1-5))
           (set! (-> a0-4 settings bot-plane w) (- (the-as float (-> event param 0))))
           )
         0
         (set! (-> v1-5 settings top-plane w) (- (the-as float (-> event param 1))))
         )
       0
       )
      )
    )
  :enter (the-as (function none :behavior process-taskable) process-taskable-play-anim-enter)
  :exit process-taskable-play-anim-exit
  :trans (behavior ()
    (process-taskable-play-anim-trans)
    (let ((a3-0 (handle->process (-> self cell-x))))
      (if a3-0
          (spool-push *art-control* (-> self fuel-cell-anim name) 0 a3-0 -99.0)
          )
      )
    ((-> self cur-trans-hook))
    (none)
    )
  :code (behavior ()
    (process-taskable-play-anim-code (the-as art-joint-anim (get-art-elem self)) (play-anim! self #t))
    (process-taskable-method-38 self)
    (none)
    )
  :post (the-as (function none :behavior process-taskable) ja-post)
  )

(defbehavior process-taskable-clean-up-after-talking process-taskable ()
  (logclear! (-> self draw status) (draw-status hidden))
  (logclear! (-> self skel status) (janim-status inited))
  (remove-setting! 'border-mode)
  (remove-setting! 'talking)
  (none)
  )

(defmethod should-display? process-taskable ((obj process-taskable))
  #t
  )

(defbehavior process-taskable-hide-handler process-taskable ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('clone)
     (go-virtual be-clone (the-as handle (-> arg3 param 0)))
     )
    (('play-anim)
     (logclear! (-> self mask) (process-mask actor-pause))
     (set! (-> self been-kicked) #t)
     (go-virtual idle)
     )
    (('hidden-other)
     (go-virtual hidden-other)
     )
    )
  (none)
  )

(defbehavior process-taskable-hide-enter process-taskable ()
  (set! (-> self state-time) (-> *display* base-frame-counter))
  (let ((v1-3 (-> self draw shadow-ctrl)))
    (logior! (-> v1-3 settings flags) (shadow-flags disable-draw))
    )
  0
  (process-taskable-clean-up-after-talking)
  (clear-collide-with-as (-> self root-override))
  (ja-channel-set! 0)
  (the-as int (ja-post))
  )

(defbehavior process-taskable-hide-exit process-taskable ((arg0 symbol))
  (cond
    (arg0
      (process-entity-status! self (entity-perm-status bit-3) #f)
      )
    (else
      (ja-channel-set! 1)
      (ja :group! (get-art-elem self))
      (restore-collide-with-as (-> self root-override))
      (process-entity-status! self (entity-perm-status bit-3) #t)
      (let ((v1-7 (-> self draw shadow-ctrl)))
        (logclear! (-> v1-7 settings flags) (shadow-flags disable-draw))
        )
      0
      )
    )
  (none)
  )

(defstate hidden (process-taskable)
  :virtual #t
  :event (the-as
    (function process int symbol event-message-block object :behavior process-taskable)
    process-taskable-hide-handler
    )
  :enter (the-as (function none :behavior process-taskable) process-taskable-hide-enter)
  :exit (behavior ()
    (process-taskable-hide-exit (= (-> self next-state name) 'hidden))
    (none)
    )
  :trans (behavior ()
    (if (>= (- (-> *display* base-frame-counter) (-> self state-time)) (seconds 1))
        (process-entity-status! self (entity-perm-status bit-3) #f)
        )
    (if (or (-> self been-kicked) (should-display? self))
        (go-virtual idle)
        )
    (none)
    )
  :code (the-as (function none :behavior process-taskable) anim-loop)
  )

;; WARN: disable def twice: 4. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod process-taskable-method-50 process-taskable ((obj process-taskable))
  (if *target*
      (or (not *target*)
          (< 245760.0 (vector-vector-distance (-> obj root-override trans) (-> *target* control trans)))
          )
      (< 60397978000.0
         (vector-vector-distance-squared (the-as vector (-> obj root-override root-prim prim-core)) (camera-pos))
         )
      )
  )

(defstate hidden-other (process-taskable)
  :virtual #t
  :event (the-as
    (function process int symbol event-message-block object :behavior process-taskable)
    process-taskable-hide-handler
    )
  :enter (the-as (function none :behavior process-taskable) process-taskable-hide-enter)
  :exit (behavior ()
    (process-taskable-hide-exit (= (-> self next-state name) 'hidden-other))
    (none)
    )
  :trans (behavior ()
    (if (>= (- (-> *display* base-frame-counter) (-> self state-time)) (seconds 1))
        (process-entity-status! self (entity-perm-status bit-3) #f)
        )
    (cond
      ((-> self been-kicked)
       (go-virtual idle)
       )
      ((process-taskable-method-50 self)
       (if (should-display? self)
           (go-virtual idle)
           (go-virtual hidden)
           )
       )
      )
    (none)
    )
  :code (the-as (function none :behavior process-taskable) anim-loop)
  )

(defstate be-clone (process-taskable)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as shadow-geo (case event-type
                         (('shadow)
                          (the-as shadow-geo (cond
                                               ((-> event param 0)
                                                (let ((v0-0 (-> self shadow-backup)))
                                                  (set! (-> self draw shadow) v0-0)
                                                  v0-0
                                                  )
                                                )
                                               (else
                                                 (set! (-> self draw shadow) #f)
                                                 (the-as shadow-geo #f)
                                                 )
                                               )
                                  )
                          )
                         (('shadow-min-max)
                          (let ((v1-5 (-> self draw shadow-ctrl)))
                            (let ((a0-5 v1-5))
                              (set! (-> a0-5 settings bot-plane w) (- (the-as float (-> event param 0))))
                              )
                            0
                            (set! (-> v1-5 settings top-plane w) (- (the-as float (-> event param 1))))
                            )
                          (the-as shadow-geo 0)
                          )
                         (('end-mode)
                          (the-as shadow-geo (if (should-display? self)
                                                 (the-as shadow-geo (go-virtual idle))
                                                 (the-as shadow-geo (go-virtual hidden))
                                                 )
                                  )
                          )
                         )
            )
    )
  :enter (behavior ((arg0 handle))
    (logior! (-> self skel status) (janim-status blerc))
    (logclear! (-> self mask) (process-mask actor-pause))
    (set-vector! (-> self draw bounds) 0.0 (-> self draw-bounds-y-offset) 0.0 (-> self draw bounds w))
    (none)
    )
  :exit (behavior ()
    (logclear! (-> self skel status) (janim-status blerc spool))
    (logior! (-> self mask) (process-mask actor-pause))
    (let ((v1-6 (-> self entity extra trans)))
      (if v1-6
          (set! (-> self root-override trans quad) (-> v1-6 quad))
          )
      )
    (ja-channel-set! 0)
    (none)
    )
  :trans (behavior ()
    (draw-npc-shadow self)
    ((-> self cur-trans-hook))
    (none)
    )
  :code (behavior ((arg0 handle))
    (clone-anim arg0 (-> self center-joint-index) #t "")
    (format #t "ERROR<GMJ>: handle invalid while ~S is cloning~%" (-> self name))
    (go-virtual hidden)
    (none)
    )
  )

(defmethod target-above-threshold? process-taskable ((obj process-taskable))
  #t
  )

(defstate idle (process-taskable)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as
      object
      (case event-type
        (('attack)
         (the-as
           symbol
           (if (-> self bounce-away)
               (the-as
                 symbol
                 (send-event proc 'shove #f (static-attack-info ((shove-back (meters 3)) (shove-up (meters 1)))))
                 )
               )
           )
         )
        (('touch)
         (the-as symbol (send-shove-back
                          (-> self root-override)
                          proc
                          (the-as touching-shapes-entry (-> event param 0))
                          0.7
                          6144.0
                          16384.0
                          )
                 )
         )
        (('clone)
         (the-as symbol (go-virtual be-clone (the-as handle (-> event param 0))))
         )
        (('play-anim)
         (logclear! (-> self mask) (process-mask actor-pause))
         (let ((v0-0 #t))
           (set! (-> self been-kicked) v0-0)
           v0-0
           )
         )
        (('hidden-other)
         (the-as symbol (go-virtual hidden-other))
         )
        )
      )
    )
  :enter (behavior ()
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (process-taskable-clean-up-after-talking)
    (none)
    )
  :exit (behavior ()
    (cond
      ((or (= (-> self next-state name) 'dead-state) (= (-> self next-state name) 'idle))
       (process-entity-status! self (entity-perm-status bit-3) #f)
       )
      (else
        (kill-current-level-hint '() '() 'exit)
        (logior! (-> self skel status) (janim-status inited))
        (logclear! (-> self mask) (process-mask actor-pause))
        (process-entity-status! self (entity-perm-status bit-3) #t)
        (set-setting! 'border-mode #f 0.0 0)
        (set-setting! 'talking (process->ppointer self) 0.0 0)
        (apply-settings *setting-control*)
        )
      )
    (none)
    )
  :trans (behavior ()
    (when (>= (- (-> *display* base-frame-counter) (-> self state-time)) (seconds 0.2))
      (logior! (-> self mask) (process-mask actor-pause))
      (process-entity-status! self (entity-perm-status bit-3) #f)
      )
    (cond
      ((not *target*)
       )
      ((not (-> self will-talk))
       (if (>= (- (-> *display* game-frame-counter) (-> self last-talk)) (seconds 10))
           (set! (-> self will-talk) #t)
           )
       )
      ((begin
         (process-taskable-method-46 self)
         (and (not (and (logtest? (-> *target* control unknown-surface00 flags) (surface-flags jump))
                        (not (logtest? (-> *target* control status) (cshape-moving-flags onsurf)))
                        )
                   )
              (< (-> (target-pos 0) y) (+ 8192.0 (-> self root-override root-prim prim-core world-sphere y)))
              (less-than-hack (vector-vector-distance (target-pos 0) (the-as vector (-> self root-override root-prim prim-core)))
                 32768.0
                 )
              (= (-> *level* loading-level) (-> *level* level-default))
              (not (movie?))
              (not (level-hint-displayed?))
              (none-reserved? *art-control*)
              (not *progress-process*)
              (and (not (handle->process (-> *game-info* other-camera-handle))) (close-anim-file! self))
              )
         )
       (first-any (-> self tasks) #t)
       (when (target-above-threshold? self)
         (case (current-status (-> self tasks))
           (((task-status need-hint)
             (task-status need-introduction)
             (task-status need-reminder)
             (task-status need-reminder-a)
             (task-status need-reward-speech)
             )
            (kill-current-level-hint '() '(sidekick voicebox ambient) 'exit)
            (level-hint-surpress!)
            (hide-hud)
            (when (and (hud-hidden?) (can-grab-display? self))
              (let ((gp-1
                      (new 'stack 'font-context *font-default-matrix* 32 140 0.0 (font-color default) (font-flags shadow kerning))
                      )
                    )
                (let ((v1-57 gp-1))
                  (set! (-> v1-57 width) (the float 440))
                  )
                (let ((v1-58 gp-1))
                  (set! (-> v1-58 height) (the float 60))
                  )
                (let ((v1-59 gp-1))
                  (set! (-> v1-59 scale) 0.9)
                  )
                (set! (-> gp-1 flags) (font-flags shadow kerning left large))
                (print-game-text (lookup-text! *common-text* (-> self talk-message) #f) gp-1 #f 128 22)
                )
              (when (and (cpad-pressed? 0 circle) (process-grab? *target*))
                (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons circle))
                (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons circle))
                (send-event *target* 'trans 'save (-> self old-target-pos))
                (go-virtual play-anim)
                )
              )
            )
           )
         )
       )
      )
    (if (= (-> *level* loading-level) (-> *level* level-default))
        (process-taskable-method-33 self)
        )
    (draw-npc-shadow self)
    (when (and (-> self been-kicked) (and (not *progress-process*)
                                          (process-grab? *target*)
                                          (not (handle->process (-> *game-info* other-camera-handle)))
                                          )
               )
      (set! (-> self been-kicked) #f)
      (send-event *target* 'trans 'save (-> self old-target-pos))
      (go-virtual play-anim)
      )
    ((-> self cur-trans-hook))
    (none)
    )
  :code process-taskable-anim-loop
  :post (behavior ()
    (when *target*
      (when (!= (-> self neck-joint-index) -1)
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (vector<-cspace! gp-0 (-> self node-list data (-> self neck-joint-index)))
          (if *target*
              (look-at-enemy! (-> *target* neck) gp-0 'nothing self)
              )
          )
        )
      )
    (transform-post)
    (none)
    )
  )

(defmethod initialize-collision process-taskable ((obj process-taskable) (arg0 int) (arg1 vector))
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) arg0)
      (set-vector! (-> s4-0 local-sphere) (-> arg1 x) (-> arg1 y) (-> arg1 z) (-> arg1 w))
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

(defmethod process-taskable-method-40 process-taskable ((obj process-taskable) (arg0 object) (arg1 skeleton-group) (arg2 int) (arg3 int) (arg4 vector) (arg5 int))
  (stack-size-set! (-> obj main-thread) 512)
  (initialize-collision obj arg2 arg4)
  (process-drawable-from-entity! obj (the-as entity-actor arg0))
  (initialize-skeleton obj arg1 '())
  (set! (-> obj shadow-backup) (-> obj draw shadow))
  (logior! (-> obj skel status) (janim-status eye))
  (#when PC_PORT
    (set! (-> obj skel postbind-function) process-drawable-joint-callback-pc))
  (set! (-> obj root-override pause-adjust-distance) -122880.0)
  (set! (-> obj fuel-cell-anim) (fuel-cell-pick-anim obj))
  (set! (-> obj draw origin-joint-index) (the-as uint arg2))
  (set! (-> obj draw shadow-joint-index) (the-as uint arg2))
  (set! (-> obj center-joint-index) arg2)
  (set! (-> obj draw-bounds-y-offset) (-> obj draw bounds y))
  (set! (-> obj have-flava) #f)
  (set! (-> obj music) #f)
  (set! (-> obj have-music) #f)
  (set! (-> obj cam-joint-index) arg3)
  (set! (-> obj cell-x) (the-as handle #f))
  (set! (-> obj cell-for-task) (game-task none))
  (set! (-> obj camera) (the-as handle #f))
  (set! (-> obj will-talk) #t)
  (set! (-> obj talk-message) (text-id press-to-talk))
  (set! (-> obj last-talk) 0)
  (set! (-> obj bounce-away) #t)
  (set! (-> obj been-kicked) #f)
  (set! (-> obj neck-joint-index) arg5)
  (set! (-> obj cur-trans-hook) nothing)
  (ambient-control-method-9 (-> obj ambient))
  (set! (-> obj event-hook) (-> (method-of-object obj idle) event))
  (set! (-> obj draw shadow-ctrl) (new 'process 'shadow-control 0.0 0.0 614400.0 (the-as float 60) 245760.0))
  (process-taskable-method-52 obj)
  0
  (none)
  )

(defmethod process-taskable-method-42 process-taskable ((obj process-taskable))
  (cond
    ((not (should-display? obj))
     (go (method-of-object obj hidden))
     )
    ((= (current-status (-> obj tasks)) (task-status need-resolution))
     (go (method-of-object obj give-cell))
     )
    (else
      (go (method-of-object obj idle))
      )
    )
  (none)
  )

(defmethod process-taskable-method-43 process-taskable ((obj process-taskable))
  (the-as symbol 0)
  )

(defmethod ambient-control-method-9 ambient-control ((obj ambient-control))
  (set! (-> obj last-ambient-time) (-> *display* game-frame-counter))
  0
  (none)
  )

(defmethod ambient-control-method-10 ambient-control ((obj ambient-control) (arg0 vector) (arg1 time-frame) (arg2 float) (arg3 process-drawable))
  (when (< (- (-> *display* game-frame-counter) (-> obj last-ambient-time)) arg1)
    (set! arg0 (the-as vector #f))
    (goto cfg-6)
    )
  (vector-for-ambient arg3 arg0)
  (when (< arg2 (vector-length arg0))
    (set! arg0 (the-as vector #f))
    (goto cfg-6)
    )
  (label cfg-6)
  arg0
  )

(defmethod play-ambient ambient-control ((obj ambient-control) (arg0 string) (arg1 symbol) (arg2 vector))
  (when (and (not (string= arg0 (-> obj last-ambient)))
             (or arg1 (can-hint-be-played? (text-id one) (the-as entity #f) (the-as string #f)))
             (= (-> *level* loading-level) (-> *level* level-default))
             (ambient-hint-spawn arg0 arg2 *entity-pool* 'ambient)
             )
    (set! (-> obj last-ambient-time) (-> *display* game-frame-counter))
    (set! (-> obj last-ambient) arg0)
    (return #t)
    )
  #f
  )

(defun vector-for-ambient ((arg0 process-drawable) (arg1 vector))
  (if *target*
      (vector-! arg1 (target-pos 0) (-> arg0 root trans))
      (vector-! arg1 (camera-pos) (-> arg0 root trans))
      )
  arg1
  )

(defun othercam-calc ((arg0 float))
  (set! (-> *camera-other-fov* data) (* 2.0 (atan (/ 14.941477 (* 20.3 arg0)) 1.0)))
  (none)
  )

(defstate othercam-running (othercam)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (local-vars (v0-0 object))
    (case event-type
      (('die)
       (set! v0-0 #t)
       (set! (-> self die?) (the-as symbol v0-0))
       v0-0
       )
      (('joint)
       (let ((t9-0 type-type?)
             (v1-1 (-> event param 0))
             )
         (cond
           ((t9-0 (rtype-of v1-1) string)
            (let ((v1-8 (lookup-art
                          (-> (the-as process-taskable (-> self hand process 0)) draw jgeo)
                          (the-as string (-> event param 0))
                          (the-as type #f)
                          )
                        )
                  )
              (when v1-8
                (set! v0-0 (+ (-> v1-8 number) 1))
                (set! (-> self cam-joint-index) (the-as int v0-0))
                v0-0
                )
              )
            )
           ((not (logtest? (-> event param 0) 7))
            (set! v0-0 (-> event param 0))
            (set! (-> self cam-joint-index) (the-as int v0-0))
            v0-0
            )
           )
         )
       )
      (('mask)
       (set! v0-0 (-> event param 0))
       (set! (-> self mask-to-clear) (the-as process-mask v0-0))
       v0-0
       )
      )
    )
  :enter (behavior ()
    (hide-hud-quick)
    (case (-> self spooling?)
      (('logo)
       )
      (else
        (add-setting! 'process-mask 'set 0.0 (-> self mask-to-clear))
        (add-setting! 'movie (process->ppointer self) 0.0 0)
        (if (not (-> self border-value))
            (add-setting! 'border-mode (-> self border-value) 0.0 0)
            )
        )
      )
    (set! (-> self had-valid-frame) #f)
    (let ((gp-0 (-> self hand process 0)))
      (vector<-cspace!
        (-> self old-pos)
        (-> (the-as process-taskable gp-0) node-list data (-> self cam-joint-index))
        )
      (let ((v1-19 (-> (the-as process-taskable gp-0) node-list data (-> self cam-joint-index) bone transform)))
        (vector-normalize-copy! (-> self old-mat-z) (-> v1-19 vector 2) -1.0)
        )
      )
    (apply-settings *setting-control*)
    (none)
    )
  :exit (behavior ()
    (remove-setting! 'process-mask)
    (apply-settings *setting-control*)
    (none)
    )
  :code (behavior ()
    (loop
      (let ((s2-0 (-> self hand process 0)))
        (when (not s2-0)
          (format #t "ERROR<GMJ>: othercam parent invalid~%")
          (deactivate self)
          )
        (set! (-> *camera-other-root* quad) (-> (the-as process-taskable s2-0) root-override trans quad))
        (let ((s4-0 (-> (the-as process-taskable s2-0) node-list data (-> self cam-joint-index) bone transform))
              (s3-0 (-> (the-as process-taskable s2-0) node-list data (-> self cam-joint-index) bone scale))
              (gp-0 (new 'stack-no-clear 'vector))
              (s5-0 (new 'stack-no-clear 'vector))
              (s1-0 (or (!= (-> self spooling?) #t)
                        (logtest? (-> (the-as process-taskable s2-0) skel status) (janim-status spool))
                        )
                    )
              )
          (vector<-cspace! s5-0 (-> (the-as process-taskable s2-0) node-list data (-> self cam-joint-index)))
          (vector-normalize-copy! gp-0 (-> s4-0 vector 2) -1.0)
          (when s1-0
            (when (not (-> self had-valid-frame))
              (set! (-> self had-valid-frame) #t)
              (set! (-> self old-pos quad) (-> s5-0 quad))
              (set! (-> self old-mat-z quad) (-> gp-0 quad))
              )
            (when #t
              (set! (-> *camera-other-trans* quad) (-> s5-0 quad))
              (vector-normalize-copy!
                (the-as vector (-> *camera-other-matrix* vector))
                (the-as vector (-> s4-0 vector))
                -1.0
                )
              (set! (-> *camera-other-matrix* vector 0 w) 0.0)
              (vector-normalize-copy! (-> *camera-other-matrix* vector 1) (-> s4-0 vector 1) 1.0)
              (set! (-> *camera-other-matrix* vector 1 w) 0.0)
              (vector-normalize-copy! (-> *camera-other-matrix* vector 2) (-> s4-0 vector 2) -1.0)
              (set! (-> *camera-other-matrix* vector 2 w) 0.0)
              (vector-reset! (-> *camera-other-matrix* vector 3))
              (othercam-calc (-> s3-0 x))
              )
            (set! *camera-look-through-other* 2)
            (set! (-> self old-pos quad) (-> s5-0 quad))
            (set! (-> self old-mat-z quad) (-> gp-0 quad))
            )
          )
        )
      (suspend)
      (let ((a0-25 (-> self hand process 0)))
        (when (or (-> self die?) (and (not (-> self survive-anim-end?)) (ja-anim-done? a0-25)))
          (let ((gp-1 (-> *display* base-frame-counter)))
            (while (and (< (- (-> *display* base-frame-counter) gp-1) (seconds 60))
                        (or (and (-> self entity) (not (is-object-visible? (-> self entity extra level) (-> self entity extra vis-id))))
                            (< 81920.0 (vector-vector-distance (camera-pos) (-> *math-camera* trans)))
                            )
                        )
              (suspend)
              )
            )
          (deactivate self)
          )
        )
      )
    (none)
    )
  )

(defbehavior othercam-init-by-other othercam ((arg0 process-taskable) (arg1 symbol) (arg2 symbol) (arg3 symbol))
  (set! (-> self spooling?) arg3)
  (case (-> self spooling?)
    (('logo)
     )
    (else
      (set! (-> *game-info* other-camera-handle) (process->handle self))
      )
    )
  (set! (-> self hand) (process->handle arg0))
  (set! (-> self cam-joint-index) (the-as int arg1))
  (logclear! (-> self mask) (process-mask pause menu actor-pause))
  (set! (-> self border-value) #f)
  (set! (-> self die?) #f)
  (set! (-> self survive-anim-end?) arg2)
  (set! (-> self mask-to-clear) (process-mask movie enemy platform projectile))
  (set! (-> self event-hook) (-> othercam-running event))
  (go othercam-running)
  0
  (none)
  )

(defmethod draw-npc-shadow process-taskable ((obj process-taskable))
  (let ((gp-0 (-> obj draw shadow-ctrl)))
    (cond
      ((and (-> obj draw shadow)
            (zero? (-> obj draw cur-lod))
            (logtest? (-> obj draw status) (draw-status was-drawn))
            )
       (collide-to-find-planes gp-0 (-> obj draw origin) -4096.0 4096.0 32768.0)
       (update-direction-from-time-of-day gp-0)
       )
      (else
        (let ((v1-10 gp-0))
          (logior! (-> v1-10 settings flags) (shadow-flags disable-draw))
          )
        0
        )
      )
    )
  (none)
  )
