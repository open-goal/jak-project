;;-*-Lisp-*-
(in-package goal)

;; name: plat-button.gc
;; name in dgo: plat-button
;; dgos: GAME, COMMON, L1

;; DECOMP BEGINS

(deftype plat-button (process-drawable)
  ((root-override           collide-shape-moving         :offset        112)
   (go-back-if-lost-player? symbol                       :offset-assert 176)
   (grab-player?            symbol                       :offset-assert 180)
   (should-grab-player?     symbol                       :offset-assert 184)
   (path-pos                float                        :offset-assert 188)
   (bidirectional?          symbol                       :offset-assert 192)
   (allow-auto-kill         symbol                       :offset-assert 196)
   (sound-id                sound-id                     :offset-assert 200)
   (trans-off               vector               :inline :offset-assert 208)
   (spawn-pos               vector               :inline :offset-assert 224)
   )
  :heap-base #x80
  :method-count-assert 33
  :size-assert         #xf0
  :flag-assert         #x21008000f0
  (:methods
    (plat-button-at-end () _type_ :state 20)
    (plat-button-idle () _type_ :state 21)
    (plat-button-pressed () _type_ :state 22)
    (plat-button-move-downward () _type_ :state 23)
    (plat-button-move-upward () _type_ :state 24)
    (plat-button-teleport-to-other-end () _type_ :state 25)
    (can-activate? (_type_) symbol 26)
    (plat-button-method-27 (_type_) none 27)
    (plat-button-method-28 (_type_) collide-shape-moving 28)
    (can-target-move? (_type_) none 29)
    (should-teleport? (_type_) symbol 30)
    (plat-button-method-31 (_type_) none 31)
    (plat-button-method-32 (_type_) none 32)
    )
  )


(defskelgroup *plat-button-sg* plat-button plat-button-geo-jg plat-button-pressed-ja
              ((plat-button-geo-mg (meters 999999)))
              :bounds (static-spherem 0 -1 0 6.6)
              )

(defmethod should-teleport? plat-button ((this plat-button))
  #f
  )

(defmethod can-activate? plat-button ((this plat-button))
  (or (= (-> this path-pos) 0.0) (and (-> this bidirectional?) (= (-> this path-pos) 1.0)))
  )

(defstate plat-button-idle (plat-button)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch)
       (when (can-activate? self)
         (if (and ((method-of-type touching-shapes-entry prims-touching?)
                   (the-as touching-shapes-entry (-> block param 0))
                   (-> self root-override)
                   (the-as uint 1)
                   )
                  (or (not (-> self should-grab-player?)) (set! (-> self grab-player?) (process-grab? *target*)))
                  )
             (go-virtual plat-button-pressed)
             )
         )
       )
      )
    )
  :code (behavior ()
    (let ((gp-0 (can-activate? self)))
      (if gp-0
          (ja-no-eval :num! (seek! 0.0))
          (ja-no-eval :num! (seek!))
          )
      (loop
        (if (should-teleport? self)
            (go-virtual plat-button-teleport-to-other-end)
            )
        (let ((s5-0 (can-activate? self)))
          (when (!= s5-0 gp-0)
            (set! gp-0 s5-0)
            (if s5-0
                (ja-no-eval :num! (seek! 0.0))
                (ja-no-eval :num! (seek!))
                )
            )
          (when (not (ja-done? 0))
            (rider-trans)
            (if s5-0
                (ja :num! (seek! 0.0))
                (ja :num! (seek!))
                )
            (rider-post)
            )
          )
        (suspend)
        )
      )
    )
  )

(defstate plat-button-teleport-to-other-end (plat-button)
  :virtual #t
  :code (behavior ()
    (let ((f0-0 1.0))
      (if (>= (-> self path-pos) 0.5)
          (set! f0-0 0.0)
          )
      (set! (-> self path-pos) f0-0)
      (let ((gp-0 (new 'stack-no-clear 'vector)))
        (eval-path-curve! (-> self path) gp-0 f0-0 'interp)
        (vector+! gp-0 gp-0 (-> self trans-off))
        (move-to-point! (-> self root-override) gp-0)
        )
      )
    (ja-post)
    (go-virtual plat-button-idle)
    )
  )

(defstate plat-button-pressed (plat-button)
  :virtual #t
  :trans rider-trans
  :code (behavior ()
    (ja-no-eval :num! (seek!))
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (set! (-> self go-back-if-lost-player?) #t)
    (process-entity-status! self (entity-perm-status complete) #t)
    (if (= (-> self path-pos) 0.0)
        (go-virtual plat-button-move-downward)
        (go-virtual plat-button-move-upward)
        )
    )
  :post rider-post
  )

(defbehavior plat-button-camera-on plat-button ()
  (let ((v1-1 (res-lump-struct (-> self entity) 'camera-name structure)))
    (if v1-1
        (send-event *camera* 'change-to-entity-by-name v1-1)
        )
    )
  0
  (none)
  )

(defbehavior plat-button-camera-off plat-button ()
  (send-event *camera* 'clear-entity)
  0
  (none)
  )

(defstate plat-button-move-downward (plat-button)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (when (or (= message 'touch) (= message 'attack))
      (set-time! (-> self state-time))
      #f
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    (process-entity-status! self (entity-perm-status bit-3) #t)
    (plat-button-camera-on)
    (set-setting! 'allow-look-around #f 0.0 0)
    )
  :exit (behavior ()
    (plat-button-camera-off)
    (remove-setting! 'allow-look-around)
    )
  :trans (behavior ()
    (if (= (-> self path-pos) 1.0)
        (go-virtual plat-button-at-end)
        )
    (rider-trans)
    (when (-> self go-back-if-lost-player?)
      (when (or (not *target*)
                (and (time-elapsed? (-> self state-time) (seconds 4))
                     (not (and (logtest? (-> *target* control unknown-surface00 flags) (surface-flags jump))
                               (not (logtest? (-> *target* control status) (cshape-moving-flags onsurf)))
                               )
                          )
                     )
                )
        (set! (-> self go-back-if-lost-player?) #f)
        (go-virtual plat-button-move-upward)
        )
      )
    (let ((f0-4 (seek-with-smooth (-> self path-pos) 1.0 (* 0.1 (seconds-per-frame)) 0.25 0.001)))
      (set! (-> self path-pos) f0-4)
      (let ((gp-0 (new 'stack-no-clear 'vector)))
        (eval-path-curve! (-> self path) gp-0 f0-4 'interp)
        (vector+! gp-0 gp-0 (-> self trans-off))
        (move-to-point! (-> self root-override) gp-0)
        )
      )
    (sound-play "elev-loop" :id (-> self sound-id))
    (let ((gp-1 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> gp-1 command) (sound-command set-param))
      (set! (-> gp-1 id) (-> self sound-id))
      (let ((a1-6 (-> self root-override trans)))
        (let ((s5-0 self))
          (when (= a1-6 #t)
            (if (and s5-0 (type-type? (-> s5-0 type) process-drawable) (nonzero? (-> s5-0 root-override)))
                (set! a1-6 (-> s5-0 root-override trans))
                (set! a1-6 (the-as vector #f))
                )
            )
          )
        (sound-trans-convert (-> gp-1 parms trans) a1-6)
        )
      (set! (-> gp-1 parms mask) (sound-mask trans))
      (-> gp-1 id)
      )
    (if (and (-> self grab-player?) (< 0.2 (-> self path-pos)))
        (set! (-> self grab-player?) (not (process-release? *target*)))
        )
    )
  :code anim-loop
  :post rider-post
  )

(defstate plat-button-move-upward (plat-button)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (when (or (= message 'touch) (= message 'attack))
      (set-time! (-> self state-time))
      #f
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    (process-entity-status! self (entity-perm-status bit-3) #t)
    (plat-button-camera-on)
    (set-setting! 'allow-look-around #f 0.0 0)
    )
  :exit (behavior ()
    (plat-button-camera-off)
    (remove-setting! 'allow-look-around)
    )
  :trans (behavior ()
    (if (= (-> self path-pos) 0.0)
        (go-virtual plat-button-at-end)
        )
    (rider-trans)
    (when (-> self go-back-if-lost-player?)
      (when (or (not *target*)
                (and (time-elapsed? (-> self state-time) (seconds 4))
                     (not (and (logtest? (-> *target* control unknown-surface00 flags) (surface-flags jump))
                               (not (logtest? (-> *target* control status) (cshape-moving-flags onsurf)))
                               )
                          )
                     )
                )
        (set! (-> self go-back-if-lost-player?) #f)
        (go-virtual plat-button-move-downward)
        )
      )
    (let ((f0-4 (seek-with-smooth (-> self path-pos) 0.0 (* 0.1 (seconds-per-frame)) 0.25 0.001)))
      (set! (-> self path-pos) f0-4)
      (let ((gp-0 (new 'stack-no-clear 'vector)))
        (eval-path-curve! (-> self path) gp-0 f0-4 'interp)
        (vector+! gp-0 gp-0 (-> self trans-off))
        (move-to-point! (-> self root-override) gp-0)
        )
      )
    (sound-play "elev-loop" :id (-> self sound-id))
    (let ((gp-1 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> gp-1 command) (sound-command set-param))
      (set! (-> gp-1 id) (-> self sound-id))
      (let ((a1-6 (-> self root-override trans)))
        (let ((s5-0 self))
          (when (= a1-6 #t)
            (if (and s5-0 (type-type? (-> s5-0 type) process-drawable) (nonzero? (-> s5-0 root-override)))
                (set! a1-6 (-> s5-0 root-override trans))
                (set! a1-6 (the-as vector #f))
                )
            )
          )
        (sound-trans-convert (-> gp-1 parms trans) a1-6)
        )
      (set! (-> gp-1 parms mask) (sound-mask trans))
      (-> gp-1 id)
      )
    (if (and (-> self grab-player?) (< (-> self path-pos) 0.8))
        (set! (-> self grab-player?) (not (process-release? *target*)))
        )
    )
  :code anim-loop
  :post rider-post
  )

(defstate plat-button-at-end (plat-button)
  :virtual #t
  :code (behavior ()
    (if (-> self allow-auto-kill)
        (process-entity-status! self (entity-perm-status bit-3) #f)
        )
    (sound-stop (-> self sound-id))
    (sound-play "elev-land")
    (loop
      (if (or (not *target*)
              (< 268435460.0 (vector-vector-xz-distance-squared (-> self root-override trans) (target-pos 0)))
              )
          (go-virtual plat-button-idle)
          )
      (suspend)
      )
    )
  )

(defmethod plat-button-method-28 plat-button ((this plat-button))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s5-0 1)
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 -4096.0 0.0 27033.6)
      (set-root-prim! s5-0 s4-0)
      (let ((s3-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 1))))
        (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
        (set! (-> s3-0 collide-with) (collide-kind target))
        (set! (-> s3-0 prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
        (set! (-> s3-0 transform-index) 4)
        (set-vector! (-> s3-0 local-sphere) 0.0 -3072.0 0.0 7372.8)
        (append-prim s4-0 s3-0)
        )
      (let ((s3-1 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 2))))
        (set! (-> s3-1 prim-core collide-as) (collide-kind ground-object))
        (set! (-> s3-1 collide-with) (collide-kind target))
        (set! (-> s3-1 prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> s3-1 prim-core offense) (collide-offense indestructible))
        (set! (-> s3-1 transform-index) 3)
        (set-vector! (-> s3-1 local-sphere) 0.0 -4096.0 0.0 27033.6)
        (append-prim s4-0 s3-1)
        )
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> this root-override) s5-0)
    s5-0
    )
  )

(defmethod can-target-move? plat-button ((this plat-button))
  0
  (none)
  )

(defmethod plat-button-method-27 plat-button ((this plat-button))
  (ja-channel-set! 1)
  (cond
    ((can-activate? this)
     (let ((s5-0 (-> this skel root-channel 0)))
       (joint-control-channel-group-eval!
         s5-0
         (the-as art-joint-anim (-> this draw art-group data 2))
         num-func-identity
         )
       (set! (-> s5-0 frame-num) 0.0)
       )
     )
    (else
      (let ((s5-1 (-> this skel root-channel 0)))
        (joint-control-channel-group-eval!
          s5-1
          (the-as art-joint-anim (-> this draw art-group data 2))
          num-func-identity
          )
        (set! (-> s5-1 frame-num)
              (the float (+ (-> (the-as art-joint-anim (-> this draw art-group data 2)) data 0 length) -1))
              )
        )
      )
    )
  (ja-post)
  (update-transforms! (-> this root-override))
  (none)
  )

(defmethod plat-button-method-31 plat-button ((this plat-button))
  (initialize-skeleton this *plat-button-sg* '())
  0
  (none)
  )

(defmethod plat-button-method-32 plat-button ((this plat-button))
  (go (method-of-object this plat-button-idle))
  0
  (none)
  )

(defmethod init-from-entity! plat-button ((this plat-button) (arg0 entity-actor))
  (set! (-> this go-back-if-lost-player?) #f)
  (set! (-> this grab-player?) #f)
  (set! (-> this should-grab-player?) #f)
  (set! (-> this trans-off quad) (-> (the-as vector ((method-of-type res-lump get-property-struct)
                                                     arg0
                                                     'trans-offset
                                                     'interp
                                                     -1000000000.0
                                                     *null-vector*
                                                     (the-as (pointer res-tag) #f)
                                                     *res-static-buf*
                                                     )
                                             )
                                     quad
                                     )
        )
  (set! (-> this bidirectional?) (nonzero? (res-lump-value arg0 'bidirectional uint128)))
  (plat-button-method-28 this)
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (plat-button-method-31 this)
  (logior! (-> this skel status) (janim-status inited))
  (set! (-> this spawn-pos quad) (-> this root-override trans quad))
  (set! (-> this path) (new 'process 'curve-control this 'path -1000000000.0))
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (set! (-> this path-pos) 0.0)
  (let ((s5-1 (-> this root-override trans)))
    (eval-path-curve! (-> this path) s5-1 (-> this path-pos) 'interp)
    (vector+! s5-1 s5-1 (-> this trans-off))
    )
  (set! (-> this sound-id) (new-sound-id))
  (set! (-> this allow-auto-kill) #t)
  (can-target-move? this)
  (plat-button-method-27 this)
  (plat-button-method-32 this)
  (none)
  )
