;;-*-Lisp-*-
(in-package goal)
(bundles "GAME.CGO")
(require "engine/common-obs/generic-obs.gc")
(require "engine/geometry/path.gc")

;; DECOMP BEGINS

(deftype plat-button (process-drawable)
  ((root                    collide-shape-moving :override)
   (go-back-if-lost-player? symbol)
   (grab-player?            symbol)
   (should-grab-player?     symbol)
   (path-pos                float)
   (bidirectional?          symbol)
   (allow-auto-kill         symbol)
   (sound-id                sound-id)
   (trans-off               vector :inline)
   (spawn-pos               vector :inline))
  (:state-methods
   plat-button-at-end
   plat-button-idle
   plat-button-pressed
   plat-button-move-downward
   plat-button-move-upward
   plat-button-teleport-to-other-end)
  (:methods
   (can-activate? (_type_) symbol)
   (plat-button-method-27 (_type_) none)
   (plat-button-method-28 (_type_) collide-shape-moving)
   (can-target-move? (_type_) none)
   (should-teleport? (_type_) symbol)
   (plat-button-method-31 (_type_) none)
   (plat-button-method-32 (_type_) none)))

(defskelgroup *plat-button-sg*
  plat-button
  plat-button-geo-jg
  plat-button-pressed-ja
  ((plat-button-geo-mg (meters 999999)))
  :bounds (static-spherem 0 -1 0 6.6))

(defmethod should-teleport? ((this plat-button))
  #f)

(defmethod can-activate? ((this plat-button))
  (or (= (-> this path-pos) 0.0) (and (-> this bidirectional?) (= (-> this path-pos) 1.0))))

(defstate plat-button-idle (plat-button)
  :virtual #t
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('touch)
         (when (can-activate? self)
           (if (and ((method-of-type touching-shapes-entry prims-touching?)
                     (the-as touching-shapes-entry (-> block param 0))
                     (-> self root)
                     (the-as uint 1))
                    (or (not (-> self should-grab-player?)) (set! (-> self grab-player?) (process-grab? *target*))))
             (go-virtual plat-button-pressed))))))
  :code
    (behavior ()
      (let ((gp-0 (can-activate? self)))
        (if gp-0 (ja-no-eval :num! (seek! 0.0)) (ja-no-eval :num! (seek!)))
        (loop
          (if (should-teleport? self) (go-virtual plat-button-teleport-to-other-end))
          (let ((s5-0 (can-activate? self)))
            (when (!= s5-0 gp-0)
              (set! gp-0 s5-0)
              (if s5-0 (ja-no-eval :num! (seek! 0.0)) (ja-no-eval :num! (seek!))))
            (when (not (ja-done? 0))
              (rider-trans)
              (if s5-0 (ja :num! (seek! 0.0)) (ja :num! (seek!)))
              (rider-post)))
          (suspend)))))

(defstate plat-button-teleport-to-other-end (plat-button)
  :virtual #t
  :code
    (behavior ()
      (let ((f0-0 1.0))
        (if (>= (-> self path-pos) 0.5) (set! f0-0 0.0))
        (set! (-> self path-pos) f0-0)
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (eval-path-curve! (-> self path) gp-0 f0-0 'interp)
          (vector+! gp-0 gp-0 (-> self trans-off))
          (move-to-point! (-> self root) gp-0)))
      (ja-post)
      (go-virtual plat-button-idle)))

(defstate plat-button-pressed (plat-button)
  :virtual #t
  :trans rider-trans
  :code
    (behavior ()
      (ja-no-eval :num! (seek!))
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!)))
      (set! (-> self go-back-if-lost-player?) #t)
      (process-entity-status! self (entity-perm-status complete) #t)
      (if (= (-> self path-pos) 0.0) (go-virtual plat-button-move-downward) (go-virtual plat-button-move-upward)))
  :post rider-post)

(defbehavior plat-button-camera-on plat-button ()
  (let ((v1-1 (res-lump-struct (-> self entity) 'camera-name structure)))
    (if v1-1 (send-event *camera* 'change-to-entity-by-name v1-1)))
  0
  (none))

(defbehavior plat-button-camera-off plat-button ()
  (send-event *camera* 'clear-entity)
  0
  (none))

(defstate plat-button-move-downward (plat-button)
  :virtual #t
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (when (or (= message 'touch) (= message 'attack))
        (set-time! (-> self state-time))
        #f))
  :enter
    (behavior ()
      (set-time! (-> self state-time))
      (process-entity-status! self (entity-perm-status bit-3) #t)
      (plat-button-camera-on)
      (set-setting! 'allow-look-around #f 0.0 0))
  :exit
    (behavior ()
      (plat-button-camera-off)
      (remove-setting! 'allow-look-around))
  :trans
    (behavior ()
      (if (= (-> self path-pos) 1.0) (go-virtual plat-button-at-end))
      (rider-trans)
      (when (-> self go-back-if-lost-player?)
        (when (or (not *target*)
                  (and (time-elapsed? (-> self state-time) (seconds 4))
                       (not (and (logtest? (-> *target* control unknown-surface00 flags) (surface-flags jump))
                                 (not (logtest? (-> *target* control status) (cshape-moving-flags onsurf)))))))
          (set! (-> self go-back-if-lost-player?) #f)
          (go-virtual plat-button-move-upward)))
      (let ((f0-4 (seek-with-smooth (-> self path-pos) 1.0 (* 0.1 (seconds-per-frame)) 0.25 0.001)))
        (set! (-> self path-pos) f0-4)
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (eval-path-curve! (-> self path) gp-0 f0-4 'interp)
          (vector+! gp-0 gp-0 (-> self trans-off))
          (move-to-point! (-> self root) gp-0)))
      (sound-play "elev-loop" :id (-> self sound-id))
      (let ((gp-1 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> gp-1 command) (sound-command set-param))
        (set! (-> gp-1 id) (-> self sound-id))
        (let ((a1-6 (-> self root trans)))
          (let ((s5-0 self))
            (when (= a1-6 #t)
              (if (and s5-0 (type-type? (-> s5-0 type) process-drawable) (nonzero? (-> s5-0 root)))
                (set! a1-6 (-> s5-0 root trans))
                (set! a1-6 (the-as vector #f)))))
          (sound-trans-convert (-> gp-1 parms trans) a1-6))
        (set! (-> gp-1 parms mask) (sound-mask trans))
        (-> gp-1 id))
      (if (and (-> self grab-player?) (< 0.2 (-> self path-pos))) (set! (-> self grab-player?) (not (process-release? *target*)))))
  :code anim-loop
  :post rider-post)

(defstate plat-button-move-upward (plat-button)
  :virtual #t
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (when (or (= message 'touch) (= message 'attack))
        (set-time! (-> self state-time))
        #f))
  :enter
    (behavior ()
      (set-time! (-> self state-time))
      (process-entity-status! self (entity-perm-status bit-3) #t)
      (plat-button-camera-on)
      (set-setting! 'allow-look-around #f 0.0 0))
  :exit
    (behavior ()
      (plat-button-camera-off)
      (remove-setting! 'allow-look-around))
  :trans
    (behavior ()
      (if (= (-> self path-pos) 0.0) (go-virtual plat-button-at-end))
      (rider-trans)
      (when (-> self go-back-if-lost-player?)
        (when (or (not *target*)
                  (and (time-elapsed? (-> self state-time) (seconds 4))
                       (not (and (logtest? (-> *target* control unknown-surface00 flags) (surface-flags jump))
                                 (not (logtest? (-> *target* control status) (cshape-moving-flags onsurf)))))))
          (set! (-> self go-back-if-lost-player?) #f)
          (go-virtual plat-button-move-downward)))
      (let ((f0-4 (seek-with-smooth (-> self path-pos) 0.0 (* 0.1 (seconds-per-frame)) 0.25 0.001)))
        (set! (-> self path-pos) f0-4)
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (eval-path-curve! (-> self path) gp-0 f0-4 'interp)
          (vector+! gp-0 gp-0 (-> self trans-off))
          (move-to-point! (-> self root) gp-0)))
      (sound-play "elev-loop" :id (-> self sound-id))
      (let ((gp-1 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> gp-1 command) (sound-command set-param))
        (set! (-> gp-1 id) (-> self sound-id))
        (let ((a1-6 (-> self root trans)))
          (let ((s5-0 self))
            (when (= a1-6 #t)
              (if (and s5-0 (type-type? (-> s5-0 type) process-drawable) (nonzero? (-> s5-0 root)))
                (set! a1-6 (-> s5-0 root trans))
                (set! a1-6 (the-as vector #f)))))
          (sound-trans-convert (-> gp-1 parms trans) a1-6))
        (set! (-> gp-1 parms mask) (sound-mask trans))
        (-> gp-1 id))
      (if (and (-> self grab-player?) (< (-> self path-pos) 0.8)) (set! (-> self grab-player?) (not (process-release? *target*)))))
  :code anim-loop
  :post rider-post)

(defstate plat-button-at-end (plat-button)
  :virtual #t
  :code
    (behavior ()
      (if (-> self allow-auto-kill) (process-entity-status! self (entity-perm-status bit-3) #f))
      (sound-stop (-> self sound-id))
      (sound-play "elev-land")
      (loop
        (if (or (not *target*) (< 268435460.0 (vector-vector-xz-distance-squared (-> self root trans) (target-pos 0))))
          (go-virtual plat-button-idle))
        (suspend))))

(defmethod plat-button-method-28 ((this plat-button))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction) (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (alloc-riders s5-0 1)
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 -4096.0 0.0 27033.6)
      (set-root-prim! s5-0 s4-0)
      (let ((s3-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 1))))
        (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
        (set! (-> s3-0 collide-with) (collide-kind target))
        (set! (-> s3-0 prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
        (set! (-> s3-0 transform-index) 4)
        (set-vector! (-> s3-0 local-sphere) 0.0 -3072.0 0.0 7372.8)
        (append-prim s4-0 s3-0))
      (let ((s3-1 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 2))))
        (set! (-> s3-1 prim-core collide-as) (collide-kind ground-object))
        (set! (-> s3-1 collide-with) (collide-kind target))
        (set! (-> s3-1 prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> s3-1 prim-core offense) (collide-offense indestructible))
        (set! (-> s3-1 transform-index) 3)
        (set-vector! (-> s3-1 local-sphere) 0.0 -4096.0 0.0 27033.6)
        (append-prim s4-0 s3-1)))
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> this root) s5-0)
    s5-0))

(defmethod can-target-move? ((this plat-button))
  0
  (none))

(defmethod plat-button-method-27 ((this plat-button))
  (ja-channel-set! 1)
  (cond
    ((can-activate? this)
     (let ((s5-0 (-> this skel root-channel 0)))
       (joint-control-channel-group-eval! s5-0 (the-as art-joint-anim (-> this draw art-group data 2)) num-func-identity)
       (set! (-> s5-0 frame-num) 0.0)))
    (else
     (let ((s5-1 (-> this skel root-channel 0)))
       (joint-control-channel-group-eval! s5-1 (the-as art-joint-anim (-> this draw art-group data 2)) num-func-identity)
       (set! (-> s5-1 frame-num) (the float (+ (-> (the-as art-joint-anim (-> this draw art-group data 2)) data 0 length) -1))))))
  (ja-post)
  (update-transforms! (-> this root))
  (none))

(defmethod plat-button-method-31 ((this plat-button))
  (initialize-skeleton this *plat-button-sg* '())
  0
  (none))

(defmethod plat-button-method-32 ((this plat-button))
  (go (method-of-object this plat-button-idle))
  0
  (none))

(defmethod init-from-entity! ((this plat-button) (arg0 entity-actor))
  (set! (-> this go-back-if-lost-player?) #f)
  (set! (-> this grab-player?) #f)
  (set! (-> this should-grab-player?) #f)
  (set! (-> this trans-off quad)
        (-> (the-as vector
                    ((method-of-type res-lump get-property-struct)
                     arg0
                     'trans-offset
                     'interp
                     -1000000000.0
                     *null-vector*
                     (the-as (pointer res-tag) #f)
                     *res-static-buf*))
            quad))
  (set! (-> this bidirectional?) (nonzero? (res-lump-value arg0 'bidirectional uint128)))
  (plat-button-method-28 this)
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (plat-button-method-31 this)
  (logior! (-> this skel status) (janim-status inited))
  (set! (-> this spawn-pos quad) (-> this root trans quad))
  (set! (-> this path) (new 'process 'curve-control this 'path -1000000000.0))
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (set! (-> this path-pos) 0.0)
  (let ((s5-1 (-> this root trans)))
    (eval-path-curve! (-> this path) s5-1 (-> this path-pos) 'interp)
    (vector+! s5-1 s5-1 (-> this trans-off)))
  (set! (-> this sound-id) (new-sound-id))
  (set! (-> this allow-auto-kill) #t)
  (can-target-move? this)
  (plat-button-method-27 this)
  (plat-button-method-32 this)
  (none))
