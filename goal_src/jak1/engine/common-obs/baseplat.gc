;;-*-Lisp-*-
(in-package goal)
(bundles "GAME.CGO")
(require "engine/common-obs/generic-obs.gc")
(require "engine/game/projectiles.gc")
(defenum eco-door-flags
  :bitfield #t
  :type int32
  (ecdf00)
  (ecdf01)
  (auto-close)
  (one-way)
  (ecdf04)
  (ecdf05)
  (ecdf06)
  (ecdf07)
  (ecdf08)
  (ecdf09)
  (ecdf10)
  (ecdf11)
  (ecdf12)
  (ecdf13)
  (ecdf14)
  (ecdf15)
  (ecdf16)
  (ecdf17)
  (ecdf18)
  (ecdf19)
  (ecdf20)
  (ecdf21)
  (ecdf22)
  (ecdf23)
  (ecdf24)
  (ecdf25)
  (ecdf26)
  (ecdf27)
  (ecdf28)
  (ecdf29)
  (ecdf30)
  (ecdf31))

;; DECOMP BEGINS

(deftype baseplat (process-drawable)
  ((root      collide-shape-moving :override)
   (smush     smush-control :inline)
   (basetrans vector :inline)
   (bouncing  symbol))
  (:methods
   (baseplat-method-20 (_type_) none)
   (baseplat-method-21 (_type_) none)
   (baseplat-method-22 (_type_) none)
   (get-unlit-skel (_type_) skeleton-group)
   (baseplat-method-24 (_type_) none)
   (baseplat-method-25 (_type_) sparticle-launch-group)
   (baseplat-method-26 (_type_) none)))

(defmethod baseplat-method-21 ((this baseplat))
  (logior! (-> this skel status) (janim-status inited))
  (set! (-> this basetrans quad) (-> this root trans quad))
  (set! (-> this bouncing) #f)
  0
  (none))

(defmethod baseplat-method-22 ((this baseplat))
  (activate! (-> this smush) -1.0 60 150 1.0 1.0)
  (set! (-> this bouncing) #t)
  (logclear! (-> this mask) (process-mask sleep))
  (logclear! (-> this mask) (process-mask sleep-code))
  0
  (none))

(defbehavior plat-code baseplat ()
  (transform-post)
  (suspend)
  (transform-post)
  (suspend)
  (loop
    (when (not (-> self bouncing))
      (logior! (-> self mask) (process-mask sleep))
      (suspend)
      0)
    (while (-> self bouncing)
      (suspend)))
  (none))

(defbehavior plat-trans baseplat ()
  (rider-trans)
  (cond
    ((-> self bouncing)
     (let ((gp-0 (new 'stack-no-clear 'vector)))
       (set! (-> gp-0 quad) (-> self basetrans quad))
       (+! (-> gp-0 y) (* 819.2 (update! (-> self smush))))
       (move-to-point! (-> self root) gp-0))
     (if (not (!= (-> self smush amp) 0.0)) (set! (-> self bouncing) #f)))
    (else (move-to-point! (-> self root) (-> self basetrans))))
  (none))

(defbehavior plat-post baseplat ()
  (baseplat-method-20 self)
  (rider-post)
  (none))

(defmethod baseplat-method-25 ((this baseplat))
  (the-as sparticle-launch-group 0))

(defmethod baseplat-method-20 ((this baseplat))
  (if (nonzero? (-> this part)) (spawn (-> this part) (-> this root trans)))
  (none))

(defbehavior plat-event baseplat ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('bonk) (baseplat-method-22 self))))

(deftype eco-door (process-drawable)
  ((root           collide-shape :override)
   (speed          float)
   (open-distance  float)
   (close-distance float)
   (out-dir        vector :inline)
   (open-sound     sound-name)
   (close-sound    sound-name)
   (state-actor    entity-actor)
   (flags          eco-door-flags)
   (locked         symbol)
   (auto-close     symbol)
   (one-way        symbol))
  (:state-methods
   door-closed
   door-opening
   door-open
   door-closing)
  (:methods
   (eco-door-method-24 (_type_) none)
   (eco-door-method-25 (_type_) none)
   (eco-door-method-26 (_type_) none)))

(defbehavior eco-door-event-handler eco-door ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('trigger)
     (set! (-> self locked) (not (-> self locked)))
     (cond
       ((-> self locked) (if (= (-> self next-state name) 'door-closed) (sound-play "door-lock")))
       (else (sound-play "door-unlock")))
     #t)))

eco-door-event-handler

(defstate door-closed (eco-door)
  :virtual #t
  :event eco-door-event-handler
  :code
    (behavior ()
      (ja :num-func num-func-identity :frame-num 0.0)
      (suspend)
      (update-transforms! (-> self root))
      (ja-post)
      (loop
        (when (and *target* (>= (-> self open-distance) (vector-vector-distance (-> self root trans) (-> *target* control trans))))
          (eco-door-method-26 self)
          (if (and (not (-> self locked))
                   (or (and (-> self entity) (logtest? (-> self entity extra perm status) (entity-perm-status complete)))
                       (send-event *target* 'query 'powerup (pickup-type eco-blue))
                       (and (-> self one-way) (< (vector4-dot (-> self out-dir) (target-pos 0)) -8192.0))))
            (go-virtual door-opening))
          (level-hint-spawn (text-id zero) (the-as string #f) (-> self entity) *entity-pool* (game-task none)))
        (suspend))))

(defstate door-opening (eco-door)
  :virtual #t
  :event eco-door-event-handler
  :code
    (behavior ()
      (let ((gp-0 (and (not (and (-> self entity) (logtest? (-> self entity extra perm status) (entity-perm-status complete))))
                       (send-event *target* 'query 'powerup (pickup-type eco-blue)))))
        (if gp-0 (sound-play "blue-eco-on" :position (the-as symbol (-> self root trans))))
        (sound-play-by-name (-> self open-sound) (new-sound-id) 1024 0 0 (sound-group sfx) #t)
        (clear-collide-with-as (-> self root))
        (until (ja-done? 0)
          (ja :num! (seek! max (-> self speed)))
          (if (and gp-0 (rand-vu-percent? 0.5)) (spawn-projectile-blue *target*))
          (suspend)))
      (go-virtual door-open))
  :post transform-post)

(defstate door-open (eco-door)
  :virtual #t
  :event eco-door-event-handler
  :code
    (behavior ()
      (set-time! (-> self state-time))
      (process-entity-status! self (entity-perm-status complete) #t)
      (clear-collide-with-as (-> self root))
      (ja :num-func num-func-identity :frame-num max)
      (logior! (-> self draw status) (draw-status hidden))
      (suspend)
      (update-transforms! (-> self root))
      (ja-post)
      (loop
        (let ((f30-0 (vector4-dot (-> self out-dir) (target-pos 0)))
              (f28-0 (vector4-dot (-> self out-dir) (camera-pos))))
          (when (and (-> self auto-close)
                     (or (not *target*)
                         (< (-> self close-distance) (vector-vector-distance (-> self root trans) (-> *target* control trans)))))
            (if (and (>= (* f30-0 f28-0) 0.0) (< 16384.0 (fabs f28-0))) (go-virtual door-closing))))
        (suspend))))

(defstate door-closing (eco-door)
  :virtual #t
  :event eco-door-event-handler
  :code
    (behavior ()
      (restore-collide-with-as (-> self root))
      (logclear! (-> self draw status) (draw-status hidden))
      (let ((gp-0 (new 'stack 'overlaps-others-params)))
        (set! (-> gp-0 options) (the-as uint 1))
        (set! (-> gp-0 tlist) #f)
        (while (find-overlapping-shapes (-> self root) gp-0)
          (suspend)))
      (sound-play-by-name (-> self close-sound) (new-sound-id) 1024 0 0 (sound-group sfx) #t)
      (until (ja-done? 0)
        (ja :num! (seek! 0.0 (-> self speed)))
        (suspend))
      (if (-> self locked) (sound-play "door-lock"))
      (go-virtual door-closed))
  :post transform-post)

(defmethod eco-door-method-26 ((this eco-door))
  (when (-> this state-actor)
    (if (logtest? (-> this state-actor extra perm status) (entity-perm-status complete))
      (set! (-> this locked) (logtest? (-> this flags) (eco-door-flags ecdf01)))
      (set! (-> this locked) (logtest? (-> this flags) (eco-door-flags ecdf00)))))
  0
  (none))

(defmethod eco-door-method-24 ((this eco-door))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind wall-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 16384.0)
      (set-root-prim! s5-0 s4-0))
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> this root) s5-0))
  0
  (none))

(defmethod eco-door-method-25 ((this eco-door))
  0
  (none))

(defmethod init-from-entity! ((this eco-door) (arg0 entity-actor))
  (eco-door-method-24 this)
  (process-drawable-from-entity! this arg0)
  (let ((f0-0 (res-lump-float (-> this entity) 'scale :default 1.0)))
    (set-vector! (-> this root scale) f0-0 f0-0 f0-0 1.0))
  (set! (-> this open-distance) 32768.0)
  (set! (-> this close-distance) 49152.0)
  (set! (-> this speed) 1.0)
  (set! (-> this state-actor) #f)
  (let ((v1-5 (entity-actor-lookup arg0 'state-actor 0))) (if v1-5 (set! (-> this state-actor) v1-5)))
  (set! (-> this locked) #f)
  (set! (-> this flags) (res-lump-value arg0 'flags eco-door-flags))
  (eco-door-method-26 this)
  (set! (-> this auto-close) (logtest? (-> this flags) (eco-door-flags auto-close)))
  (set! (-> this one-way) (logtest? (-> this flags) (eco-door-flags one-way)))
  (vector-z-quaternion! (-> this out-dir) (-> this root quat))
  (set! (-> this out-dir w) (- (vector-dot (-> this out-dir) (-> this root trans))))
  (update-transforms! (-> this root))
  (eco-door-method-25 this)
  (if (and (not (-> this auto-close))
           (-> this entity)
           (logtest? (-> this entity extra perm status) (entity-perm-status complete)))
    (go (method-of-object this door-open))
    (go (method-of-object this door-closed)))
  (none))
