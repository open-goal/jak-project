;;-*-Lisp-*-
(in-package goal)

;; name: collide-edge-grab.gc
;; name in dgo: collide-edge-grab
;; dgos: GAME, ENGINE

(defmethod find-edge-grabs! target ((obj target) (arg0 collide-cache))
  "Main edge grabbing method.
   Will populate *edge-grab-info* and send *target* an 'edge-grab event if successful."
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (let ((gp-0 *collide-edge-work*))
      ;; reset the edge work...
      (set! (-> gp-0 num-verts) (the-as uint 0))
      (set! (-> gp-0 num-edges) (the-as uint 0))
      (set! (-> gp-0 num-tris) (the-as uint 0))

      (let ((v1-0 (-> obj control)))
        (set! (-> gp-0 ccache) arg0)
        (.lvf vf1 (&-> gp-0 local-cache-fill-box min quad))
        (.lvf vf2 (&-> gp-0 local-cache-fill-box max quad))
        (set! (-> gp-0 cshape) v1-0)
        (.lvf vf3 (&-> v1-0 trans quad))
        )
      ;; translate the cache filling box
      (.add.vf vf1 vf1 vf3 :mask #b111)
      (.add.vf vf2 vf2 vf3 :mask #b111)
      (.svf (&-> gp-0 cache-fill-box min quad) vf1)
      (.svf (&-> gp-0 cache-fill-box max quad) vf2)
      ;; translate the reach box
      (.lvf vf4 (&-> gp-0 local-within-reach-box min quad))
      (.lvf vf5 (&-> gp-0 local-within-reach-box max quad))
      (.add.vf vf4 vf4 vf3 :mask #b111)
      (.add.vf vf5 vf5 vf3 :mask #b111)
      ;; and also provide an integer version of the box.
      (.ftoi.vf vf6 vf4)
      (.ftoi.vf vf7 vf5)
      (.svf (&-> gp-0 within-reach-box min quad) vf4)
      (.svf (&-> gp-0 within-reach-box max quad) vf5)
      (.svf (&-> gp-0 within-reach-box4w min quad) vf6)
      (.svf (&-> gp-0 within-reach-box4w max quad) vf7)

      ;; Fill the collide cache!
      (fill-using-bounding-box
        arg0
        (-> gp-0 cache-fill-box)
        (-> obj control root-prim collide-with)
        obj
        (new 'static 'pat-surface :skip #x1 :noentity #x1)
        )

      ;; Filter out tris that can't be grabbed
      (find-grabbable-tris! gp-0)
      (when (nonzero? (-> gp-0 num-tris))
        ;; Find edges that we might be able to grab
        (find-grabbable-edges! gp-0)
        (when (nonzero? (-> gp-0 num-edges))
          ;;
          (set! (-> gp-0 search-pt quad) (-> *target* control unknown-vector90 quad))
          ;; for the search, we either use the direction of the stick, or the heading of target.
          (when (!= (-> *cpad-list* cpads (-> *target* control unknown-cpad-info00 number) stick0-speed) 0.0)
            ;; use stick
            (set! (-> gp-0 search-dir-vec quad) (-> *target* control unknown-vector20 quad))
            (search-for-edges gp-0 (-> gp-0 hold-list))
            (when (find-best-grab! gp-0 (-> gp-0 hold-list) *edge-grab-info*)
              (send-event *target* 'edge-grab)
              (return (the-as object #f))
              )
            )
          ;; use target's heading
          (vector-z-quaternion! (-> gp-0 search-dir-vec) (-> *target* control unknown-quaternion00))
          (search-for-edges gp-0 (-> gp-0 hold-list))
          (if (find-best-grab! gp-0 (-> gp-0 hold-list) *edge-grab-info*)
              (send-event *target* 'edge-grab)
              )
          0
          )
        )
      )
    0
    )
  )

(defmethod search-for-edges collide-edge-work ((obj collide-edge-work) (arg0 collide-edge-hold-list))
  "Iterate through edges, adding them to the collide-edge-hold-list, if they are good"
  ;; reset edge list.
  (set! (-> arg0 num-allocs) (the-as uint 0))
  (set! (-> arg0 num-attempts) (the-as uint 0))
  (set! (-> arg0 head) #f)
  (let ((s4-0 (the-as collide-edge-hold-item (-> arg0 items)))
        (s3-0 (the-as collide-edge-edge (-> obj edges)))
        )
    ;; loop over edges
    (countdown (s2-0 (-> obj num-edges))
      (when (not (-> s3-0 ignore))
        ;; find the grab point
        (compute-center-point! obj s3-0 (-> s4-0 center-pt))
        ;; add if needed.
        (when (should-add-to-list? obj s4-0 s3-0)
          (add-to-list! arg0 s4-0)
          (+! (-> arg0 num-allocs) 1)
          (when (= (-> arg0 num-allocs) 32)
            (format 0 "ERROR: Reached limit of edge grab hold items!~%")
            (return #f)
            )
          (&+! s4-0 48)
          )
        )
      (&+! s3-0 48)
      )
    )
  #f
  )

;; add to list.
(defmethod-mips2c "(method 10 collide-edge-hold-list)" 10 collide-edge-hold-list)

(deftype pbhp-stack-vars (structure)
  ((edge        collide-edge-edge         :offset-assert   0)
   (allocated   basic                     :offset-assert   4)
   (neg-hold-pt vector            :inline :offset-assert  16)
   (split-vec   vector            :inline :offset-assert  32)
   )
  :method-count-assert 9
  :size-assert         #x30
  :flag-assert         #x900000030
  )


(defmethod-mips2c "(method 18 collide-edge-work)" 18 collide-edge-work)

(defmethod check-grab-for-collisions collide-edge-work ((obj collide-edge-work) (arg0 collide-edge-hold-item) (arg1 edge-grab-info))
  (local-vars (sv-144 (function vector vector vector float vector)) (sv-160 vector) (sv-176 vector))
  (let* ((s3-0 (-> arg0 edge))
         (s1-0 (-> s3-0 etri ctri))
         (s4-0 (-> s1-0 prim-index))
         )
    (let ((s0-0 (new 'stack-no-clear 'vector)))
      (vector+*! s0-0 (-> arg0 center-pt) (-> s3-0 edge-vec-norm) 1105.92)
      (let ((f0-0 (dummy-14 obj (-> arg1 right-hand-hold) s0-0 (the-as int s4-0))))
        (if (< 491.52 f0-0)
            (return #f)
            )
        )
      (set! sv-144 vector+*!)
      (set! sv-160 s0-0)
      (set! sv-176 (-> arg0 center-pt))
      (let ((a2-3 (vector-negate! (new 'stack-no-clear 'vector) (-> s3-0 edge-vec-norm)))
            (a3-2 1105.92)
            )
        (sv-144 sv-160 sv-176 a2-3 a3-2)
        )
      (let ((f0-1 (dummy-14 obj (-> arg1 left-hand-hold) s0-0 (the-as int s4-0))))
        (if (< 491.52 f0-1)
            (return #f)
            )
        )
      )
    (set! (-> arg1 tri-vertex 0 quad) (-> s1-0 vertex 0 quad))
    (set! (-> arg1 world-vertex 4 quad) (-> s1-0 vertex 1 quad))
    (set! (-> arg1 world-vertex 5 quad) (-> s1-0 vertex 2 quad))
    (set! (-> arg1 edge-tri-pat) (the-as uint (-> s1-0 pat)))
    (set! (-> arg1 center-hold quad) (-> arg0 center-pt quad))
    (set! (-> arg1 world-vertex 0 quad) (-> s3-0 vertex-ptr 0 0 quad))
    (set! (-> arg1 world-vertex 1 quad) (-> s3-0 vertex-ptr 1 0 quad))
    (set! (-> arg1 hanging-matrix vector 1 quad) (-> *target* control dynam gravity-normal quad))
    (vector-normalize!
      (vector-! (-> arg1 hanging-matrix vector 2) (-> arg1 world-vertex 1) (the-as vector (-> arg1 world-vertex)))
      1.0
      )
    (vector-normalize!
      (vector-cross!
        (the-as vector (-> arg1 hanging-matrix))
        (-> arg1 hanging-matrix vector 2)
        (-> arg1 hanging-matrix vector 1)
        )
      1.0
      )
    (vector-cross!
      (-> arg1 hanging-matrix vector 2)
      (the-as vector (-> arg1 hanging-matrix))
      (-> arg1 hanging-matrix vector 1)
      )
    (set! (-> arg1 hanging-matrix vector 3 quad) (-> arg1 center-hold quad))
    (transform-vectors! (-> arg1 hanging-matrix) (-> obj world-player-spheres) (-> obj local-player-spheres) 12)
    (let ((a1-13 (new 'stack-no-clear 'collide-using-spheres-params)))
      (set! (-> a1-13 spheres) (-> obj world-player-spheres))
      (set! (-> a1-13 num-spheres) (the-as uint 12))
      (set! (-> a1-13 collide-with) (-> obj cshape root-prim collide-with))
      (set! (-> a1-13 proc) #f)
      (set! (-> a1-13 ignore-pat) (new 'static 'pat-surface :noentity #x1))
      (set! (-> a1-13 solid-only) #t)
      (if (probe-using-spheres (-> obj ccache) a1-13)
          (return #f)
          )
      )
    (let* ((v1-36 (the-as object (-> obj ccache prims s4-0 prim)))
           (a0-35 (-> (the-as collide-shape-prim v1-36) cshape))
           )
      (cond
        (a0-35
          (set! (-> arg1 actor-cshape-prim-offset) (- (the-as int v1-36) (the-as int (-> a0-35 process))))
          (set! (-> arg1 actor-handle) (process->handle (-> a0-35 process)))
          (let ((a1-19
                  (-> a0-35 process node-list data (-> (the-as collide-shape-prim v1-36) transform-index) bone transform)
                  )
                (s5-1 (new 'stack-no-clear 'matrix))
                )
            (matrix-4x4-inverse! s5-1 a1-19)
            (dotimes (s4-1 6)
              (vector-matrix*! (-> arg1 local-vertex s4-1) (-> arg1 world-vertex s4-1) s5-1)
              )
            )
          )
        (else
          (set! (-> arg1 actor-cshape-prim-offset) 0)
          (set! (-> arg1 actor-handle) (the-as handle #f))
          )
        )
      )
    )
  #t
  )

(defmethod dummy-9 edge-grab-info ((obj edge-grab-info))
  (local-vars (v0-0 symbol) (v1-14 int))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (the-as object #f)))
      (set! (-> obj center-hold-old quad) (-> obj center-hold quad))
      (let ((v1-1 (-> obj actor-cshape-prim-offset)))
        (when (nonzero? v1-1)
          (let ((a0-5 (handle->process (-> obj actor-handle))))
            (if (not (the-as process a0-5))
                (return #f)
                )
            (set! s5-0 (+ (the-as int a0-5) v1-1))
            (if (zero? (-> (the-as collide-shape-prim s5-0) prim-core collide-as))
                (return #f)
                )
            (let ((s4-0
                    (-> (the-as process-drawable a0-5)
                        node-list
                        data
                        (-> (the-as collide-shape-prim s5-0) transform-index)
                        bone
                        transform
                        )
                    )
                  )
              (dotimes (s3-0 6)
                (vector-matrix*! (-> obj world-vertex s3-0) (-> obj local-vertex s3-0) s4-0)
                )
              )
            )
          (.lvf vf1 (&-> obj world-vertex 3 quad))
          (.lvf vf2 (&-> obj world-vertex 4 quad))
          (.lvf vf3 (&-> obj world-vertex 5 quad))
          (.sub.vf vf4 vf2 vf1)
          (.sub.vf vf5 vf3 vf1)
          (.outer.product.a.vf acc vf4 vf5)
          (.outer.product.b.vf vf6 vf5 vf4 acc)
          (.mul.vf vf7 vf6 vf6)
          (.mul.x.vf acc vf0 vf7 :mask #b1000)
          (.add.mul.y.vf acc vf0 vf7 acc :mask #b1000)
          (.add.mul.z.vf vf7 vf0 vf7 acc :mask #b1000)
          (.isqrt.vf Q vf0 vf7 :fsf #b11 :ftf #b11)
          (let ((f1-0 0.707))
            (.wait.vf)
            (nop!)
            (.mul.vf vf6 vf6 Q :mask #b111)
            (.mov v1-14 vf6)
            (b! (>= (the-as float (sar (the-as int v1-14) 32)) f1-0) cfg-17)
            )
          (set! v0-0 #f)
          (b! #t cfg-27 :delay (nop!))
          (label cfg-17)
          (set! (-> obj hanging-matrix vector 1 quad) (-> *target* control dynam gravity-normal quad))
          (vector-normalize!
            (vector-! (-> obj hanging-matrix vector 2) (-> obj world-vertex 1) (the-as vector (-> obj world-vertex)))
            1.0
            )
          (vector-normalize!
            (vector-cross!
              (the-as vector (-> obj hanging-matrix))
              (-> obj hanging-matrix vector 2)
              (-> obj hanging-matrix vector 1)
              )
            1.0
            )
          (vector-cross!
            (-> obj hanging-matrix vector 2)
            (the-as vector (-> obj hanging-matrix))
            (-> obj hanging-matrix vector 1)
            )
          (set! (-> obj hanging-matrix vector 3 quad) (-> obj center-hold quad))
          (let ((v1-21 *collide-edge-work*))
            (transform-vectors!
              (-> obj hanging-matrix)
              (-> v1-21 world-player-spheres)
              (-> v1-21 local-player-spheres)
              12
              )
            )
          )
        )
      (let ((v1-22 *collide-edge-work*)
            (a1-14 (new 'stack-no-clear 'collide-using-spheres-params))
            )
        (let ((a0-24 'target-edge-grab-jump))
          (b! (!= (-> *target* next-state name) a0-24) cfg-20 :delay (nop!))
          )
        (set! (-> a1-14 spheres) (-> v1-22 world-player-leap-up-spheres))
        (set! (-> a1-14 num-spheres) (the-as uint 6))
        (set! (-> a1-14 collide-with) (-> v1-22 cshape root-prim collide-with))
        (set! (-> a1-14 proc) #f)
        (set! (-> a1-14 ignore-pat) (new 'static 'pat-surface :noentity #x1))
        (set! (-> a1-14 solid-only) #t)
        (b! #t cfg-21 :delay (nop!))
        (label cfg-20)
        (set! (-> a1-14 spheres) (-> v1-22 world-player-spheres))
        (set! (-> a1-14 num-spheres) (the-as uint 6))
        (set! (-> a1-14 collide-with) (-> v1-22 cshape root-prim collide-with))
        (set! (-> a1-14 proc) #f)
        (set! (-> a1-14 ignore-pat) (new 'static 'pat-surface :noentity #x1))
        (set! (-> a1-14 solid-only) #t)
        (label cfg-21)
        (b! (not (fill-and-probe-using-spheres *collide-cache* a1-14)) cfg-24)
        )
      (set! v0-0 #f)
      (b! #t cfg-27 :delay (nop!))
      (the-as none 0)
      (label cfg-24)
      (b! (not (the-as int s5-0)) cfg-26)
      (let ((v1-40 (-> (the-as collide-shape-prim s5-0) cshape)))
        (send-event (-> v1-40 process) 'edge-grabbed obj)
        )
      )
    (label cfg-26)
    (set! v0-0 #t)
    (label cfg-27)
    v0-0
    )
  )


(defmethod-mips2c "(method 16 collide-edge-work)" 16 collide-edge-work)
(defmethod-mips2c "(method 15 collide-edge-work)" 15 collide-edge-work)

(defmethod dummy-14 collide-edge-work ((obj collide-edge-work) (arg0 vector) (arg1 vector) (arg2 int))
  (let ((f30-0 -1.0))
    (let ((s2-0 (new 'stack-no-clear 'vector)))
      (dotimes (s1-0 (the-as int (-> obj num-edges)))
        (let ((v1-3 (-> obj edges s1-0)))
          (when (not (-> v1-3 ignore))
            (when (= (-> v1-3 etri ctri prim-index) arg2)
              (let ((f0-0 (vector-segment-distance-point! arg1 (-> v1-3 vertex-ptr 0 0) (-> v1-3 vertex-ptr 1 0) s2-0)))
                (when (or (< f30-0 0.0) (< f0-0 f30-0))
                  (set! f30-0 f0-0)
                  (set! (-> arg0 quad) (-> s2-0 quad))
                  )
                )
              )
            )
          )
        )
      )
    f30-0
    )
  )

;; 17 cew
(defmethod should-add-to-list? collide-edge-work ((obj collide-edge-work) (arg0 collide-edge-hold-item) (arg1 collide-edge-edge))
  (local-vars
    (r0-0 uint128)
    (v1-1 uint128)
    (v1-2 uint128)
    (v1-4 float)
    (v1-5 float)
    (v1-6 float)
    (a3-1 uint128)
    (t0-0 uint128)
    (t1-1 uint128)
    )
  (rlet ((Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (nop!)
    (nop!)
    (.lvf vf1 (&-> arg0 center-pt quad))
    (nop!)
    (let ((a3-0 (-> obj within-reach-box4w min quad)))
      (nop!)
      (let ((t1-0 (-> obj within-reach-box4w max quad)))
        (.ftoi.vf vf2 vf1)
        (let ((v1-0 (-> obj cshape)))
          (.mov t0-0 vf2)
          (.lvf vf3 (&-> arg1 outward quad))
          (.pcgtw t1-1 t0-0 t1-0)
          (.lvf vf4 (&-> obj outward-offset quad))
          (.pcgtw a3-1 a3-0 t0-0)
          (.lvf vf5 (&-> v1-0 trans quad))
          )
        )
      )
    (.por v1-1 t1-1 a3-1)
    (let ((f0-0 (-> obj max-dist-sqrd-to-outward-pt)))
      (.ppach v1-2 r0-0 v1-1)
      (let ((f1-0 (-> obj max-dir-cosa-delta)))
        (b! (nonzero? (shl (the-as int v1-2) 16)) cfg-4 :delay (.lvf vf6 (&-> obj search-dir-vec quad)))
        (.mul.x.vf vf10 vf3 vf4)
        (.lvf vf11 (&-> obj search-pt quad))
        (.add.vf vf10 vf10 vf1)
        (.sub.vf vf7 vf5 vf10)
        (.mul.vf vf7 vf7 vf7)
        (.add.z.vf vf7 vf7 vf7 :mask #b1)
        (.mov v1-4 vf7)
        (b! (< f0-0 v1-4) cfg-4)
        (.sub.vf vf8 vf1 vf5)
        (.mul.vf vf7 vf8 vf8)
        (.add.z.vf vf7 vf7 vf7 :mask #b1)
        (.isqrt.vf Q vf0 vf7 :fsf #b11 :ftf #b0)
        (nop!)
        (.wait.vf)
        (nop!)
        (.mul.vf vf8 vf8 Q :mask #b101)
        (.mul.vf vf9 vf8 vf6)
        (.add.z.vf vf9 vf9 vf9 :mask #b1)
        (.mov v1-5 vf9)
        (b! (< v1-5 f1-0) cfg-4)
        )
      )
    (.sub.vf vf7 vf11 vf1)
    (.svf (&-> arg0 center-pt quad) vf1)
    (.mul.vf vf7 vf7 vf7)
    (set! (-> arg0 split) 0)
    (.svf (&-> arg0 outward-pt quad) vf10)
    (.add.z.vf vf7 vf7 vf7 :mask #b1)
    (set! (-> arg0 edge) arg1)
    (.mov v1-6 vf7)
    (set! (-> arg0 rating) v1-6)
    (let ((v0-0 #t))
      (b! #t cfg-6 :delay (nop!))
      (label cfg-4)
      (set! v0-0 #f)
      (b! #t cfg-6 :delay (nop!))
      (set! v0-0 (the-as symbol 0))
      (label cfg-6)
      v0-0
      )
    )
  )

(defmethod compute-center-point! collide-edge-work ((obj collide-edge-work) (arg0 collide-edge-edge) (arg1 vector))
  (local-vars (v0-0 float) (v1-1 float) (v1-2 float) (v1-3 float))
  (rlet ((Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (.mov.vf vf7 vf0)
    (.lvf vf1 (&-> obj search-pt quad))
    (let ((f0-0 0.0))
      (let ((v1-0 (-> arg0 vertex-ptr 0))
            (a0-1 (-> arg0 vertex-ptr 1))
            )
        (.lvf vf2 (&-> v1-0 0 quad))
        (.lvf vf3 (&-> a0-1 0 quad))
        )
      (.sub.vf vf4 vf1 vf2)
      (.sub.vf vf5 vf3 vf2)
      (.mul.vf vf6 vf5 vf5)
      (.add.z.vf vf6 vf6 vf6 :mask #b1)
      (.sqrt.vf Q vf6 :ftf #b0)
      (nop!)
      (.wait.vf)
      (nop!)
      (.add.vf vf6 vf0 Q :mask #b1)
      (.nop.vf)
      (.mov v1-1 vf6)
      (let ((f1-0 v1-1))
        (.div.vf Q vf0 vf6 :fsf #b11 :ftf #b0)
        (.wait.vf)
        (nop!)
        (.add.vf vf8 vf0 Q :mask #b1)
        (.mul.x.vf vf9 vf5 vf8)
        (.mov v1-2 vf8)
        (.mul.vf vf10 vf9 vf4)
        (.add.z.vf vf10 vf10 vf10 :mask #b1)
        (let ((f2-0 v1-2))
          (.mov v1-3 vf10)
          (let ((f3-0 v1-3))
            (b! (< f3-0 f0-0) cfg-4 :likely-delay (set! f3-0 f0-0))
            (b! (< f1-0 f3-0) cfg-4 :likely-delay (set! f3-0 f1-0))
            (label cfg-4)
            (let ((v1-4 (* f3-0 f2-0)))
              (.mov vf11 v1-4)
              )
            )
          )
        )
      )
    (.mul.x.vf vf7 vf5 vf11 :mask #b111)
    (.add.vf vf7 vf7 vf2 :mask #b111)
    (.svf (&-> arg1 quad) vf7)
    (.mov v0-0 vf7)
    v0-0
    )
  )


(defmethod debug-draw edge-grab-info ((obj edge-grab-info))
  (add-debug-line
    #t
    (bucket-id debug-no-zbuf)
    (the-as vector (-> obj world-vertex))
    (-> obj world-vertex 1)
    (new 'static 'rgba :r #xff :a #x60)
    #f
    (the-as rgba -1)
    )
  (add-debug-sphere
    #t
    (bucket-id debug-no-zbuf)
    (-> obj center-hold)
    204.8
    (new 'static 'rgba :r #xff :g #xff :a #x80)
    )
  (add-debug-sphere
    #t
    (bucket-id debug-no-zbuf)
    (-> obj left-hand-hold)
    204.8
    (new 'static 'rgba :r #xff :g #xff :a #x60)
    )
  (add-debug-sphere
    #t
    (bucket-id debug-no-zbuf)
    (-> obj right-hand-hold)
    204.8
    (new 'static 'rgba :r #xff :g #xff :a #x60)
    )
  (add-debug-outline-triangle
    #t
    (bucket-id debug-no-zbuf)
    (the-as vector (-> obj tri-vertex))
    (-> obj world-vertex 4)
    (-> obj world-vertex 5)
    (new 'static 'rgba :r #xff :a #x30)
    )
  (the-as symbol (cond
                   ((nonzero? (-> obj actor-cshape-prim-offset))
                    (if (handle->process (-> obj actor-handle))
                        (format *stdcon* "grab: ~A~%" (-> obj actor-handle process 0 name))
                        (format *stdcon* "grab: invalid handle~%")
                        )
                    )
                   (else
                     (format *stdcon* "grab: ground~%")
                     )
                   )
          )
  )

(defmethod debug-draw-edges collide-edge-work ((obj collide-edge-work))
  (let ((gp-0 0))
    (dotimes (s4-0 (the-as int (-> obj num-edges)))
      (let* ((s3-0 (-> obj edges s4-0))
             (a2-0 (-> s3-0 vertex-ptr 0 0))
             (a3-0 (-> s3-0 vertex-ptr 1 0))
             (s2-0 (new 'stack-no-clear 'vector))
             )
        (vector+! s2-0 a2-0 a3-0)
        (vector-float*! s2-0 s2-0 0.5)
        (cond
          ((-> s3-0 ignore)
           (add-debug-line
             #t
             (bucket-id debug-no-zbuf)
             a2-0
             a3-0
             (new 'static 'rgba :r #x7f :g #x7f :b #x7f :a #x50)
             #f
             (the-as rgba -1)
             )
           (+! gp-0 1)
           )
          (else
            (add-debug-line
              #t
              (bucket-id debug-no-zbuf)
              a2-0
              a3-0
              (new 'static 'rgba :r #xff :g #xff :b #xff :a #x60)
              #f
              (the-as rgba -1)
              )
            (add-debug-vector
              #t
              (bucket-id debug-no-zbuf)
              s2-0
              (-> s3-0 outward)
              (meters 0.3)
              (new 'static 'rgba :r #xff :a #x80)
              )
            )
          )
        )
      )
    (format *stdcon* "found ~D edges (and ~D ignored)~%" (- (-> obj num-edges) (the-as uint gp-0)) gp-0)
    )
  )


(defmethod debug-draw-sphere collide-edge-work ((obj collide-edge-work))
  (dotimes (s5-0 (the-as int (-> obj num-verts)))
    (let ((a2-0 (-> obj verts s5-0)))
      (add-debug-sphere #t (bucket-id debug-no-zbuf) a2-0 819.2 (new 'static 'rgba :r #xff :g #xff :a #x80))
      )
    )
  #f
  )

(defmethod debug-draw collide-edge-hold-list ((obj collide-edge-hold-list))
  (let ((s4-0 (-> obj head))
        (s5-0 0)
        )
    (let ((s3-0 (new 'stack-no-clear 'vector))
          (s2-0 #t)
          )
      (set! (-> s3-0 quad) (-> *target* control unknown-vector90 quad))
      (while s4-0
        (+! s5-0 1)
        (set! (-> s3-0 y) (-> s4-0 center-pt y))
        (add-debug-sphere #t (bucket-id debug-no-zbuf) s3-0 409.6 (new 'static 'rgba :a #x80))
        (cond
          (s2-0
            (set! s2-0 #f)
            (add-debug-sphere
              #t
              (bucket-id debug-no-zbuf)
              (-> s4-0 center-pt)
              614.4
              (new 'static 'rgba :r #xff :g #xff :a #x80)
              )
            (add-debug-sphere #t (bucket-id debug-no-zbuf) (-> s4-0 outward-pt) 409.6 (new 'static 'rgba :r #xff :a #x80))
            )
          (else
            (add-debug-sphere
              #t
              (bucket-id debug-no-zbuf)
              (-> s4-0 center-pt)
              614.4
              (new 'static 'rgba :r #x7f :g #x7f :a #x40)
              )
            (add-debug-sphere #t (bucket-id debug-no-zbuf) (-> s4-0 outward-pt) 409.6 (new 'static 'rgba :r #x7f :a #x40))
            )
          )
        (set! s4-0 (-> s4-0 next))
        )
      )
    (format *stdcon* "hold list has ~D item(s)~%" s5-0)
    )
  (dotimes (s5-1 (the-as int (-> obj num-attempts)))
    (add-debug-sphere
      #t
      (bucket-id debug-no-zbuf)
      (the-as vector (-> obj attempts s5-1))
      409.6
      (new 'static 'rgba :a #x40)
      )
    )
  (format *stdcon* "hold list has ~D attempt(s)~%" (-> obj num-attempts))
  )

(defmethod debug-draw-tris collide-edge-work ((obj collide-edge-work))
  (dotimes (s5-0 (the-as int (-> obj num-tris)))
    (let* ((v1-3 (-> obj tris s5-0 ctri))
           (t1-0 (copy-and-set-field (-> *pat-mode-info* (-> v1-3 pat mode) color) a 64))
           )
      (add-debug-outline-triangle
        #t
        (bucket-id debug-no-zbuf)
        (the-as vector (-> v1-3 vertex))
        (-> v1-3 vertex 1)
        (-> v1-3 vertex 2)
        t1-0
        )
      )
    )
  (none)
  )

;; failed to figure out what this is:
(let
  ((v1-1
    (new 'static 'surface
     :name '*rotate-surface*
     :turnv 1.0
     :turnvv 1.0
     :tiltv 1.0
     :tiltvv 1.0
     :transv-max 1.0
     :target-speed 1.0
     :seek0 153600.0
     :seek90 153600.0
     :seek180 256000.0
     :fric 153600.0
     :nonlin-fric-dist 5120.0
     :slip-factor 1.0
     :slope-down-factor 10240.0
     :slope-slip-angle 8192.0
     :impact-fric 1.0
     :bend-factor 0.8
     :bend-speed 4.0
     :alignv 1.0
     :slope-up-traction 1.0
     :align-speed 1.0
     :flags #x4000
     )
    )
   )
  (define *rotate-surface* v1-1)
  (set!
   (-> v1-1 mult-hook)
   (the-as
    (function surface surface surface int none)
    (lambda ((arg0 surface) (arg1 object) (arg2 object) (arg3 int))
     (when (= arg3 1)
      (let ((f0-0 151756.8))
       (set! (-> arg0 fric) f0-0)
       f0-0
       )
      )
     )
    )
   )
  (set! (-> v1-1 touch-hook) nothing)
  (set! (-> v1-1 active-hook) nothing)
  )

;; failed to figure out what this is:
(let
  ((v1-2
    (new 'static 'surface
     :name '*no-walk-surface*
     :turnv 0.5
     :turnvv 1.0
     :tiltv 1.0
     :tiltvv 1.0
     :transv-max 0.7
     :target-speed 0.7
     :seek0 24576.0
     :seek90 24576.0
     :seek180 24576.0
     :fric 23756.8
     :nonlin-fric-dist 4091904.0
     :slope-slip-angle 16384.0
     :bend-speed 4.0
     :alignv 0.5
     :slope-up-traction 0.9
     :align-speed 1.0
     :flags #x28
     )
    )
   )
  (define *no-walk-surface* v1-2)
  (set!
   (-> v1-2 mult-hook)
   (the-as (function surface surface surface int none) nothing)
   )
  (set! (-> v1-2 touch-hook) nothing)
  (set! (-> v1-2 active-hook) nothing)
  )


; (defmethod find-edge-grabs! target ((obj target) (arg0 collide-cache))
;   (format *stdcon* "no edge grabs for you!~%")
;   (the object 0)
;   )