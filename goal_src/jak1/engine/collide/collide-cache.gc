;;-*-Lisp-*-
(in-package goal)
(bundles "ENGINE.CGO" "GAME.CGO")
(require "engine/gfx/background/subdivide.gc")
(require "engine/collide/collide-func.gc")
(require "examples/debug-collide.gc")
(require "engine/collide/collide-probe.gc")
(require "engine/geometry/bounding-box.gc")
(require "engine/collide/collide-mesh-h.gc")
(require "engine/collide/main-collide.gc")
(require "engine/common-obs/water-h.gc")
(require "engine/collide/collide-shape-h.gc")
(require "engine/debug/debug.gc")

;; DECOMP BEGINS

(defmethod debug-draw ((obj collide-cache))
  "Debug draw all the things in the collide cache!"
  (let ((gp-0 (the-as collide-cache-tri (-> obj tris))))
    (countdown (s4-0 (-> obj num-tris))
      (let ((t1-0 (copy-and-set-field (-> *pat-mode-info* (-> gp-0 pat mode) color) a 64)))
        (add-debug-flat-triangle #t
                                 (bucket-id debug-no-zbuf)
                                 (the-as vector (-> gp-0 vertex))
                                 (-> gp-0 vertex 1)
                                 (-> gp-0 vertex 2)
                                 t1-0)
        (#when PC_PORT
          (add-debug-outline-triangle #t
                                      (bucket-id debug-no-zbuf)
                                      (-> gp-0 vertex 0)
                                      (-> gp-0 vertex 1)
                                      (-> gp-0 vertex 2)
                                      (static-rgba 0 0 0 64))))
      (&+! gp-0 64)))
  (let ((gp-1 (the-as collide-cache-prim (-> obj prims))))
    (countdown (s5-1 (-> obj num-prims))
      (when (= (-> gp-1 prim-core prim-type) -1)
        (let ((t0-1 (copy-and-set-field (-> *pat-mode-info* (-> (the-as collide-shape-prim-sphere (-> gp-1 prim)) pat mode) color) a 64)))
          (add-debug-sphere #t
                            (bucket-id debug-no-zbuf)
                            (the-as vector (-> gp-1 prim-core))
                            (-> gp-1 prim-core world-sphere w)
                            t0-1)))
      (&+! gp-1 48)))
  0
  (none))

;;;;;;;;;;;;;;;;;;;;;;;;
;; Setup
;;;;;;;;;;;;;;;;;;;;;;;;

(define *already-printed-exeeded-max-cache-tris* #f)

(defmethod initialize ((obj collide-cache))
  "Clear the collide-cache."
  (set! (-> obj num-tris) 0)
  (set! (-> obj num-prims) 0)
  (set! (-> obj proc) #f)
  (set! *already-printed-exeeded-max-cache-tris* #f)
  (none))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Fill using Bounding Box
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; As is typcial of ND, this is complicated.
;; We have 3 stages for loading the background mesh.
;; 1). We acquire mesh fragments. This can be with bsp methods or collide probe.
;; 2). We upload these meshes to VU0 data memory and unpack.
;; 3). We run the unpack function which downloads them with vlqi and puts the spad.
;; 4). We run the filter by box function to download only tris in the box into the cache.

(defmethod-mips2c "(method 26 collide-cache)" 26 collide-cache)

(defmethod-mips2c "(method 27 collide-cache)" 27 collide-cache)

(defmethod-mips2c "(method 28 collide-cache)" 28 collide-cache)

(defmethod-mips2c "(method 29 collide-cache)" 29 collide-cache)

(defmethod-mips2c "(method 32 collide-cache)" 32 collide-cache)

(defmethod-mips2c "(method 12 collide-shape-prim-mesh)" 12 collide-shape-prim-mesh)

(defmethod-mips2c "(method 14 collide-shape-prim-mesh)" 14 collide-shape-prim-mesh)

(defmethod-mips2c "(method 13 collide-shape-prim-mesh)" 13 collide-shape-prim-mesh)

(defmethod-mips2c "(method 30 collide-cache)" 30 collide-cache)

(defmethod-mips2c "(method 9 collide-cache-prim)" 9 collide-cache-prim)

(defmethod-mips2c "(method 10 collide-cache-prim)" 10 collide-cache-prim)

(defmethod-mips2c "(method 9 collide-puss-work)" 9 collide-puss-work)

(defmethod-mips2c "(method 10 collide-puss-work)" 10 collide-puss-work)

(def-mips2c __pc-upload-collide-frag (function object object object none))

(defmethod fill-from-background ((obj collide-cache) (bsp-find-mesh-func (function bsp-header int collide-list none)) (import-mesh-func (function collide-cache object none)))
  "This terrible function fills the collide cache with background tris from a bounding box."
  (local-vars (a0-4 int) (a0-6 int))
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Step 1: Build Collide List
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; this is a list of fragments that we will look at.
  (set! (-> *collide-list* num-items) 0)
  (cond
    ((= bsp-find-mesh-func (method-of-type bsp-header collide-ray))
     ;; for collide-ray (actually line-sphere), we have a fancy version.
     (dotimes (s4-1 (-> *level* length))
       (let ((a0-2 (-> *level* level s4-1)))
         (when (= (-> a0-2 status) 'active)
           (reset! (-> *perf-stats* data 14))
           (collide-probe-make-list a0-2 *collide-list*)
           (read! (-> *perf-stats* data 14))))))
    (else
     ;; for the othes, we don't have a fancy version, so use the versio provided by the user.
     (dotimes (s3-0 (-> *level* length))
       (let ((v1-21 (-> *level* level s3-0)))
         (if (= (-> v1-21 status) 'active) (bsp-find-mesh-func (-> v1-21 bsp) 0 *collide-list*))))))
  (when (> (-> *collide-list* num-items) 0)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Step 2: Upload to VU0 Data
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; in classic ND style, this is double buffered.
    ;; we'll undo this.
    (dotimes (i (-> *collide-list* num-items))
      (let ((frag (-> *collide-list* items i)))
        ;; to VU0 memory
        (__pc-upload-collide-frag (-> frag mesh packed-data) (-> frag mesh vertex-data-qwc) (-> frag mesh vertex-count))
        ;; from VU0 memory to scratchpad
        (unpack-background-collide-mesh obj (-> frag mesh) (-> frag inst) 0)
        ;; from scratchpad to collide-cache memory.
        (import-mesh-func obj (-> frag mesh))))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Fake it as a prim
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; The old system can actually read out lists of prims.
    ;; Note that this assumes the cache has been emptied and we're the first to fill it here.
    (let ((a0-28 (-> obj num-tris)))
      (when (> a0-28 0)
        (let ((v1-55 (-> obj prims))
              (a1-17 *collide-shape-prim-backgnd*))
          (set! (-> v1-55 0 num-tris) (the-as uint a0-28))
          (set! (-> v1-55 0 prim) a1-17)
          (set! (-> obj num-prims) 1)
          (set! (-> v1-55 0 first-tri) (the-as uint 0))
          (set! (-> v1-55 0 ccache) obj)
          (set! (-> v1-55 0 prim-core world-sphere quad) (-> a1-17 prim-core world-sphere quad))
          (set! (-> v1-55 0 prim-core quad 1) (-> a1-17 prim-core quad 1))))))
  0
  (none))

(defmethod fill-from-water ((obj collide-cache) (arg0 water-control))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf))
    (init-vf0-vector)
    (when (= (-> obj num-prims) 100)
      (if (= *cheat-mode* 'debug) (format 0 "ERROR: Exceeded max number of collide-cache prims!~%"))
      (return #f))
    (when (< *collide-cache-max-tris* (+ (-> obj num-tris) 2))
      (when (not *already-printed-exeeded-max-cache-tris*)
        (set! *already-printed-exeeded-max-cache-tris* #t)
        (if (= *cheat-mode* 'debug) (format *stdcon* "Exceeded collide cache max # of tris!~%")))
      (return #f))
    (if (not (and (logtest? (-> arg0 flags) 2) (logtest? (-> arg0 flags) 144) (zero? (logand #x10000 (-> arg0 flags)))))
      (return #f))
    (let ((v1-28 (cond
                   ((logtest? (-> *target* control root-prim prim-core action) (collide-action racer)) (+ -819.2 (-> arg0 height)))
                   ((logtest? (-> arg0 flags) 16) (- (-> arg0 height) (-> arg0 swim-height)))
                   (else (- (-> arg0 base-height) (-> arg0 bottom-height))))))
      (.lvf vf1 (&-> obj collide-box min quad))
      (.lvf vf3 (&-> obj collide-box max quad))
      (let ((a1-6 (-> obj num-prims-u))
            (a2-8 (the-as (inline-array collide-cache-tri) (-> obj tris (-> obj num-tris)))))
        (.mov vf5 v1-28)
        (.add.x.vf vf1 vf0 vf5 :mask #b10)
        (set! (-> a2-8 0 extra-quad) (the-as uint128 0))
        (set! (-> a2-8 0 prim-index) a1-6)
        (.add.x.vf vf3 vf0 vf5 :mask #b10)
        (set! (-> a2-8 1 extra-quad) (the-as uint128 0))
        (set! (-> a2-8 1 prim-index) a1-6)
        (.mov.vf vf2 vf1)
        (.mov.vf vf4 vf1)
        (.add.z.vf vf2 vf0 vf3 :mask #b100)
        (.add.x.vf vf4 vf0 vf3 :mask #b1)
        (.svf (&-> a2-8 0 vertex 0 quad) vf1)
        (.svf (&-> a2-8 0 vertex 1 quad) vf2)
        (.svf (&-> a2-8 0 vertex 2 quad) vf3)
        (set! (-> a2-8 0 pat) (new 'static 'pat-surface :material (pat-material waterbottom)))
        (.svf (&-> a2-8 1 vertex 0 quad) vf1)
        (.svf (&-> a2-8 1 vertex 1 quad) vf3)
        (.svf (&-> a2-8 1 vertex 2 quad) vf4)
        (set! (-> a2-8 1 pat) (new 'static 'pat-surface :material (pat-material waterbottom)))))
    (let ((v1-33 *collide-shape-prim-water*)
          (a1-10 (-> obj prims (-> obj num-prims))))
      (set! (-> a1-10 first-tri) (the-as uint (-> obj num-tris)))
      (set! (-> a1-10 num-tris) (the-as uint 2))
      (set! (-> a1-10 prim) v1-33)
      (set! (-> a1-10 ccache) obj)
      (set! (-> a1-10 prim-core world-sphere quad) (-> v1-33 prim-core world-sphere quad))
      (set! (-> a1-10 prim-core quad 1) (-> v1-33 prim-core quad 1)))
    (+! (-> obj num-prims) 1)
    (+! (-> obj num-tris) 2)
    (none)))

(defmethod fill-using-bounding-box ((obj collide-cache) (arg0 bounding-box) (arg1 collide-kind) (arg2 process-drawable) (arg3 pat-surface))
  (rlet ((Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf))
    (init-vf0-vector)
    (let ((v1-0 (new 'static 'vector :x 0.5)))
      (nop!)
      (.lvf vf1 (&-> arg0 min quad))
      (nop!)
      (.lvf vf2 (&-> arg0 max quad))
      (nop!)
      (set! (-> obj proc) arg2)
      (.mov.vf vf1 vf0 :mask #b1000)
      (let ((a0-1 *collide-work*))
        (.mov.vf vf2 vf0 :mask #b1000)
        (set! (-> obj ignore-mask) arg3)
        (.ftoi.vf vf3 vf1)
        (.lvf vf6 (&-> v1-0 quad))
        (.ftoi.vf vf4 vf2)
        (set! (-> obj num-tris) 0)
        (.add.vf vf5 vf2 vf1 :mask #b111)
        (.svf (&-> obj collide-box min quad) vf1)
        (.mul.x.vf vf5 vf5 vf6 :mask #b111)
        (.svf (&-> obj collide-box max quad) vf2)
        (.sub.vf vf7 vf5 vf1 :mask #b111)
        (.sub.vf vf5 vf5 vf5 :mask #b1000)
        (.mul.vf vf7 vf7 vf7 :mask #b111)
        (.svf (&-> obj collide-box4w min quad) vf3)
        (.add.y.vf vf7 vf7 vf7 :mask #b1)
        (.svf (&-> obj collide-box4w max quad) vf4)
        (.add.z.vf vf7 vf7 vf7 :mask #b1)
        (.svf (&-> a0-1 collide-box4w min quad) vf3)
        (.sqrt.vf Q vf7 :ftf #b0)
        (.svf (&-> a0-1 collide-box4w max quad) vf4)
        (set! *already-printed-exeeded-max-cache-tris* #f)
        (nop!)
        (.wait.vf)
        (set! (-> obj num-prims) 0)
        (.sub.vf vf5 vf5 Q :mask #b1000)
        (set! (-> obj collide-with) arg1)
        (nop!)
        (.svf (&-> a0-1 collide-sphere-neg-r quad) vf5)))
    0
    (if (logtest? arg1 (collide-kind background))
      (fill-from-background obj
                            (method-of-type bsp-header collide-with-box)
                            (method-of-type collide-cache load-mesh-from-spad-in-box)))
    (if (logtest? arg1 (collide-kind water)) (fill-from-water obj (-> arg2 water)))
    (if (logtest? arg1 (collide-kind cak-1 cak-2 cak-3 target)) (fill-from-foreground-using-box obj))
    0
    (none)))

(defun collide-cache-using-box-test ((arg0 vector))
  (local-vars (v1-1 int))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf))
    (init-vf0-vector)
    (nop!)
    (.max.w.vf vf3 vf0 vf0)
    (let ((v1-0 *collide-work*)) (nop!) (.lvf vf1 (&-> arg0 quad)) (nop!) (.lvf vf2 (&-> v1-0 collide-sphere-neg-r quad)))
    (.sub.vf vf1 vf1 vf2)
    (nop!)
    (.mul.vf vf1 vf1 vf1)
    (nop!)
    (.mul.x.vf acc vf3 vf1)
    (nop!)
    (.add.mul.y.vf acc vf3 vf1 acc)
    (nop!)
    (.add.mul.z.vf acc vf3 vf1 acc)
    (nop!)
    (.sub.mul.w.vf vf1 vf3 vf1 acc)
    (nop!)
    (.mov v1-1 vf1)
    (<= (the-as int v1-1) 0)))

(defmethod collide-with-box ((obj collide-fragment) (arg0 int) (arg1 collide-list))
  (let ((s3-0 *collide-work*))
    (dotimes (s2-0 arg0)
      (when (and (collide-cache-using-box-test (-> obj bsphere)) (drawable-sphere-box-intersect? obj (-> s3-0 collide-box4w)))
        (let ((v1-5 (-> arg1 items (-> arg1 num-items)))) (set! (-> v1-5 mesh) (-> obj mesh)) (set! (-> v1-5 inst) #f))
        ; (add-debug-sphere #t (bucket-id debug) (-> obj bsphere) (-> obj bsphere w) (new 'static 'rgba :g #x80 :a #x80))
        ; (format 0 "~f~%" (-> obj bsphere w))
        (+! (-> arg1 num-items) 1))
      (&+! obj 32)))
  0
  (none))

(defmethod collide-with-box ((obj instance-tie) (arg0 int) (arg1 collide-list))
  (dotimes (s3-0 arg0)
    (when (and (zero? (logand (-> obj flags) 1))
               (collide-cache-using-box-test (-> obj bsphere))
               (drawable-sphere-box-intersect? obj (-> *collide-work* collide-box4w)))
      (let ((s2-0 (-> obj bucket-ptr collide-frag)))
        (when (nonzero? s2-0)
          (let ((s1-0 (the-as object (-> s2-0 data))))
            (dotimes (s0-0 (-> s2-0 length))
              (when (instance-sphere-box-intersect? (the-as collide-fragment s1-0) obj (-> *collide-work* collide-box4w))
                (let ((v1-12 (-> arg1 items (-> arg1 num-items))))
                  (set! (-> v1-12 mesh) (-> (the-as collide-fragment s1-0) mesh))
                  (set! (-> v1-12 inst) obj))
                (+! (-> arg1 num-items) 1))
              (set! s1-0 (-> (the-as (inline-array collide-fragment) s1-0) 1)))))))
    (&+! obj 64))
  0
  (none))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Y PROBE
;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod fill-using-y-probe ((obj collide-cache) (arg0 vector) (arg1 float) (arg2 collide-kind) (arg3 process-drawable) (arg4 pat-surface))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf))
    (set! *already-printed-exeeded-max-cache-tris* #f)
    (.mov vf5 arg1)
    (.lvf vf2 (&-> arg0 quad))
    (nop!)
    (let ((v1-0 *collide-work*))
      (.mov.vf vf1 vf2)
      (set! (-> obj ignore-mask) (the-as pat-surface arg4))
      (.add.x.vf vf2 vf2 vf5 :mask #b10)
      (set! (-> obj num-tris) 0)
      (.sub.x.vf vf1 vf1 vf5 :mask #b10)
      (set! (-> obj num-prims) 0)
      (nop!)
      (set! (-> obj collide-with) arg2)
      (nop!)
      (set! (-> obj proc) arg3)
      (.ftoi.vf vf4 vf2)
      (.svf (&-> obj collide-box max quad) vf2)
      (.ftoi.vf vf3 vf1)
      (.svf (&-> obj collide-box min quad) vf1)
      (nop!)
      (.svf (&-> obj collide-box4w max quad) vf4)
      (nop!)
      (.svf (&-> obj collide-box4w min quad) vf3)
      (nop!)
      (.svf (&-> v1-0 collide-box4w max quad) vf4)
      (nop!)
      (.svf (&-> v1-0 collide-box4w min quad) vf3))
    (if (logtest? arg2 (collide-kind background))
      (fill-from-background obj
                            (method-of-type bsp-header collide-y-probe)
                            (the-as (function collide-cache object none) (method-of-type collide-cache collide-cache-method-28))))
    (if (logtest? arg2 (collide-kind water)) (fill-from-water obj (-> arg3 water)))
    (if (logtest? arg2 (collide-kind cak-1 cak-2 cak-3 target)) (fill-from-foreground-using-y-probe obj))
    0
    (none)))

(defun collide-cache-using-y-probe-test ((arg0 vector))
  (local-vars
    (zero uint128)
    (v1-1 uint128)
    (v1-2 uint128)
    (v1-3 uint128)
    (a0-1 uint128)
    (a1-2 uint128)
    (a2-0 uint128)
    (f31-0 none))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf))
    (set! zero (the-as uint128 0))
    (nop!)
    (let ((a1-0 *collide-work*))
      (nop!)
      (.lvf vf1 (&-> arg0 quad))
      (nop!)
      (let ((v1-0 (-> a1-0 collide-box4w min quad)))
        (.sub.w.vf vf2 vf1 vf1 :mask #b111)
        (let ((a1-1 (-> a1-0 collide-box4w max quad)))
          (.add.w.vf vf3 vf1 vf1 :mask #b111)
          (nop!)
          (.ftoi.vf vf4 vf2)
          (nop!)
          (.ftoi.vf vf5 vf3)
          (nop!)
          (.mov a2-0 vf4)
          (nop!)
          (.mov a0-1 vf5)
          (nop!)
          (.pcgtw a1-2 a2-0 a1-1))
        (.pcgtw v1-1 v1-0 a0-1)))
    (.por v1-2 a1-2 v1-1)
    (.ppach v1-3 zero v1-2)
    (let ((v1-4 (shl (the-as int v1-3) 16))) (nop!) (zero? v1-4))))

;; definition for method 12 of type collide-fragment
;; INFO: Return type mismatch int vs none.
(defmethod collide-y-probe ((obj collide-fragment) (arg0 int) (arg1 collide-list))
  *collide-work*
  (dotimes (s3-0 arg0)
    (when (collide-cache-using-y-probe-test (-> obj bsphere))
      (let ((v1-5 (-> arg1 items (-> arg1 num-items)))) (set! (-> v1-5 mesh) (-> obj mesh)) (set! (-> v1-5 inst) #f))
      (+! (-> arg1 num-items) 1))
    (&+! obj 32))
  0
  (none))

;; definition for method 12 of type instance-tie
;; INFO: Return type mismatch int vs none.
(defmethod collide-y-probe ((obj instance-tie) (arg0 int) (arg1 collide-list))
  (dotimes (s3-0 arg0)
    (when (and (zero? (logand (-> obj flags) 1)) (collide-cache-using-y-probe-test (-> obj bsphere)))
      (let ((s2-0 (-> obj bucket-ptr collide-frag)))
        (when (nonzero? s2-0)
          (let ((s1-0 (the-as object (-> s2-0 data))))
            (dotimes (s0-0 (-> s2-0 length))
              (when (instance-sphere-box-intersect? (the-as collide-fragment s1-0) obj (-> *collide-work* collide-box4w))
                (let ((v1-11 (-> arg1 items (-> arg1 num-items))))
                  (set! (-> v1-11 mesh) (-> (the-as collide-fragment s1-0) mesh))
                  (set! (-> v1-11 inst) obj))
                (+! (-> arg1 num-items) 1))
              (set! s1-0 (-> (the-as (inline-array collide-fragment) s1-0) 1)))))))
    (&+! obj 64))
  0
  (none))

;;;;;;;;;;;;;;;;;;;;;
;; Line Sphere Test
;;;;;;;;;;;;;;;;;;;;;

;; In this mode, we collide a line of spheres.
;; The first pass sets up a non-axis-aligned bounding box in *collide-work*
;; The box is stored as an axis-aligned box, and an inv-rot to transform from world to aligned-box coordinates.

(defmacro pabsw-hack (out in)
  `(let ((temp (new 'stack-no-clear 'array 'int32 4)))
    (set! (-> (the (pointer uint128) temp)) ,in)
    (set! (-> temp 0) (abs (-> temp 0)))
    (set! (-> temp 1) (abs (-> temp 1)))
    (set! (-> temp 2) (abs (-> temp 2)))
    (set! (-> temp 3) (abs (-> temp 3)))
    (set! ,out (-> (the (pointer uint128) temp)))))

(defmethod fill-using-line-sphere ((obj collide-cache) (arg0 vector) (arg1 vector) (arg2 float) (arg3 collide-kind) (arg4 process-drawable) (arg5 pat-surface))
  (local-vars (zero uint128) (a0-2 uint128) (a0-3 uint128) (a0-7 int) (t0-1 uint128) (t0-2 uint128))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf12 :class vf)
         (vf13 :class vf)
         (vf14 :class vf)
         (vf15 :class vf)
         (vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf2 :class vf)
         (vf20 :class vf)
         (vf21 :class vf)
         (vf22 :class vf)
         (vf23 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf))
    (set! zero (the uint128 0))
    (init-vf0-vector)
    (let ((v1-0 (new 'static 'vector4w :x #x1000 :y #x1000 :z #x1000)))
      (nop!)
      (.mov vf9 arg2)
      (.lvf vf3 (&-> arg1 quad))
      (nop!)
      (let ((a0-1 (-> v1-0 quad)))
        (.ftoi.vf vf21 vf3)
        (.lvf vf1 (&-> arg0 quad))
        (.mul.vf vf8 vf3 vf3)
        (let ((v1-1 *collide-work*))
          (.add.vf vf2 vf1 vf3)
          (set! (-> obj ignore-mask) arg5)
          (.mov t0-1 vf21)
          (nop!)
          (pabsw-hack t0-2 t0-1) ;; t0-2 is the line, absolute value
          (.pcgtw a0-2 t0-2 a0-1)
          (.ppach a0-3 zero a0-2)
          (let ((a0-4 (shl (the-as int a0-3) 16))) (b! (nonzero? a0-4) cfg-3))
          (let ((s2-0 (new 'stack-no-clear 'bounding-box)))
            (set-from-point-offset-pad! s2-0 (the-as vector3s arg0) (the-as vector3s arg1) arg2)
            (fill-using-bounding-box obj s2-0 arg3 arg4 arg5))
          (b! #t cfg-13 :delay (nop!))
          (set! v1-1 (the-as collide-work 0))
          (label cfg-3)
          (.add.y.vf vf8 vf8 vf8 :mask #b1)
          (set! (-> obj num-tris) 0)
          (.min.vf vf4 vf1 vf2)
          (set! (-> obj num-prims) 0)
          (.max.vf vf5 vf1 vf2)
          (set! (-> obj collide-with) arg3)
          (.sub.x.vf vf10 vf0 vf9 :mask #b111)
          (set! (-> obj proc) arg4)
          (.add.z.vf vf8 vf8 vf8 :mask #b1)
          (.sub.x.vf vf4 vf4 vf9 :mask #b111)
          (.add.x.vf vf5 vf5 vf9 :mask #b111)
          (.ftoi.vf vf15 vf10)
          (.isqrt.vf Q vf0 vf8 :fsf #b11 :ftf #b0)
          (.add.x.vf vf11 vf0 vf9 :mask #b111)
          (.svf (&-> v1-1 collide-box4w min quad) vf15)
          (.ftoi.vf vf6 vf4)
          (.svf (&-> obj collide-box min quad) vf4)
          (.ftoi.vf vf7 vf5)
          (.svf (&-> obj collide-box max quad) vf5)
          (.mov.vf vf13 vf0)
          (.svf (&-> obj collide-box4w min quad) vf6)
          (.svf (&-> obj collide-box4w max quad) vf7)
          (.add.vf vf8 vf0 Q :mask #b1)
          (.mul.x.vf vf12 vf3 vf8)
          (.div.vf Q vf0 vf8 :fsf #b11 :ftf #b0)
          (.mul.vf vf22 vf12 vf12)
          (.abs.vf vf23 vf12)
          (.add.y.vf vf22 vf22 vf22 :mask #b1)
          (.mov a0-7 vf23)
          (.wait.vf)
          (.add.vf vf8 vf0 Q :mask #b1)
          (b! (zero? a0-7) cfg-6 :likely-delay (.add.z.vf vf13 vf0 vf12 :mask #b1))
          (.sub.y.vf vf13 vf0 vf12 :mask #b1)
          (.isqrt.vf Q vf0 vf22 :fsf #b11 :ftf #b0)
          (.add.x.vf vf13 vf0 vf12 :mask #b10)
          (.wait.vf)
          (.mul.vf vf13 vf13 Q :mask #b11)
          (label cfg-6)
          (.outer.product.a.vf acc vf12 vf13)
          (.add.x.vf vf11 vf11 vf8 :mask #b1)
          (.outer.product.b.vf vf14 vf13 vf12 acc)
          (.ftoi.vf vf16 vf11)
          (.mov.vf vf17 vf12)
          (.mov.vf vf18 vf13)
          (.mov.vf vf19 vf14)
          (.mov.vf vf17 vf0 :mask #b1110)
          (.svf (&-> v1-1 collide-box4w max quad) vf16)
          (.mov.vf vf18 vf0 :mask #b1101)
          (.mov.vf vf19 vf0 :mask #b1011)
          (.add.x.vf vf17 vf17 vf13 :mask #b10)
          (.add.y.vf vf18 vf18 vf12 :mask #b1)
          (.add.z.vf vf19 vf19 vf12 :mask #b1)
          (.add.x.vf vf17 vf17 vf14 :mask #b100)
          (.add.y.vf vf18 vf18 vf14 :mask #b100)
          (.add.z.vf vf19 vf19 vf13 :mask #b10)
          (.mul.x.vf acc vf17 vf1)
          (.add.mul.y.vf acc vf18 vf1 acc)
          (.svf (&-> v1-1 inv-mat vector 0 quad) vf17)
          (.add.mul.z.vf vf20 vf19 vf1 acc)
          (.svf (&-> v1-1 inv-mat vector 1 quad) vf18)
          (.sub.vf vf20 vf0 vf20)
          (.svf (&-> v1-1 inv-mat vector 2 quad) vf19)
          (.svf (&-> v1-1 inv-mat vector 3 quad) vf20))))
    0
    (if (logtest? arg3 (collide-kind background))
      (fill-from-background obj
                            (method-of-type bsp-header collide-ray)
                            (the-as (function collide-cache object none) (method-of-type collide-cache collide-cache-method-27))))
    (if (logtest? arg3 (collide-kind water)) (fill-from-water obj (-> arg4 water)))
    (if (logtest? arg3 (collide-kind cak-1 cak-2 cak-3 target)) (fill-from-foreground-using-line-sphere obj))
    0
    (label cfg-13)
    (none)))

(defun collide-cache-using-line-sphere-test ((arg0 vector))
  "Check if the input sphere is in the rotated bounding box volume of the current
   line-sphere query."
  (local-vars (v1-1 uint128) (v1-2 uint128) (v1-3 uint128) (a0-1 uint128) (a1-2 uint128) (a2-0 uint128) (zero uint128))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf))
    (init-vf0-vector)
    (set! zero (the uint128 0))
    (let ((a1-0 *collide-work*))
      (.lvf vf5 (&-> arg0 quad))
      (.lvf vf4 (&-> a1-0 inv-mat vector 3 quad))
      (.lvf vf1 (&-> a1-0 inv-mat vector 0 quad))
      (.mul.w.vf acc vf4 vf0)
      (.lvf vf2 (&-> a1-0 inv-mat vector 1 quad))
      (.add.mul.x.vf acc vf1 vf5 acc)
      (.lvf vf3 (&-> a1-0 inv-mat vector 2 quad))
      (.add.mul.y.vf acc vf2 vf5 acc)
      (let ((v1-0 (-> a1-0 collide-box4w min quad)))
        (.add.mul.z.vf vf10 vf3 vf5 acc)
        (let ((a1-1 (-> a1-0 collide-box4w max quad)))
          (.sub.w.vf vf6 vf10 vf5 :mask #b111)
          (.add.w.vf vf7 vf10 vf5 :mask #b111)
          (.ftoi.vf vf8 vf6)
          (.ftoi.vf vf9 vf7)
          (.mov a2-0 vf8)
          (.mov a0-1 vf9)
          (.pcgtw a1-2 a2-0 a1-1))
        (.pcgtw v1-1 v1-0 a0-1)))
    (.por v1-2 a1-2 v1-1)
    (.ppach v1-3 zero v1-2)
    (let ((v1-4 (shl (the-as int v1-3) 16))) (nop!) (zero? v1-4))))

(defun make-collide-list-using-line-sphere-inst-test ((arg0 collide-fragment) (arg1 instance-tie))
  "Check if a collide-fragment at a given instance is in the rotated bounding box volume
   of the current line-sphere query."
  (local-vars
    (v1-1 uint128)
    (v1-2 uint128)
    (v1-3 uint128)
    (v1-4 uint128)
    (a1-2 uint128)
    (a2-1 uint128)
    (a3-1 uint128)
    (a3-3 uint128)
    (a3-4 uint128)
    (t0-1 uint128)
    (t0-2 uint128)
    (t1-0 uint128)
    (t2-1 uint128)
    (t2-2 uint128)
    (zero uint128))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf12 :class vf)
         (vf13 :class vf)
         (vf14 :class vf)
         (vf15 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf))
    (init-vf0-vector)
    (set! zero (the uint128 0))
    (let ((v1-0 *collide-work*))
      (let ((a2-0 (-> arg1 max-scale)))
        (let ((a3-0 (the-as uint128 (-> arg1 origin vector4h 3 long))))
          (let ((t2-0 (the-as uint128 (-> arg1 origin vector4h 0 long))))
            (.pextlh a3-1 a3-0 zero)
            (let ((t0-0 (the-as uint128 (-> arg1 origin vector4h 1 long))))
              (.pw.sra t1-0 a3-1 10)
              (let ((a3-2 (the-as uint128 (-> arg1 origin vector4h 2 long))))
                (.pextlh t2-1 t2-0 zero)
                (.pw.sra t2-2 t2-1 16)
                (.pextlh t0-1 t0-0 zero)
                (.mov vf4 t1-0)
                (.pw.sra t0-2 t0-1 16)
                (.mov vf1 t2-2)
                (.pextlh a3-3 a3-2 zero)))))
        (.mov vf2 t0-2)
        (.pw.sra a3-4 a3-3 16)
        (.lvf vf5 (&-> arg1 bsphere quad))
        (.mov vf3 a3-4)
        (.mov vf6 a2-0))
      (.itof.vf vf4 vf4)
      (vitof12.xyzw vf1 vf1)
      (vitof12.xyzw vf2 vf2)
      (vitof12.xyzw vf3 vf3)
      (.add.vf vf4 vf4 vf5 :mask #b111)
      (.lvf vf5 (&-> arg0 bsphere quad))
      (vitof12.xyzw vf6 vf6)
      (.mul.x.vf acc vf1 vf5)
      (.add.mul.y.vf acc vf2 vf5 acc)
      (.add.mul.z.vf acc vf3 vf5 acc)
      (.add.mul.w.vf vf11 vf4 vf0 acc)
      (.lvf vf7 (&-> v1-0 inv-mat vector 0 quad))
      (.lvf vf8 (&-> v1-0 inv-mat vector 1 quad))
      (.lvf vf9 (&-> v1-0 inv-mat vector 2 quad))
      (.lvf vf10 (&-> v1-0 inv-mat vector 3 quad))
      (.mul.x.vf acc vf7 vf11)
      (let ((a0-1 (-> v1-0 collide-box4w min quad)))
        (.add.mul.y.vf acc vf8 vf11 acc)
        (let ((a1-1 (-> v1-0 collide-box4w max quad)))
          (.add.mul.z.vf acc vf9 vf11 acc)
          (.add.mul.w.vf vf11 vf10 vf0 acc)
          (.mul.w.vf vf15 vf6 vf5 :mask #b1)
          (.add.x.vf vf12 vf11 vf15 :mask #b111)
          (.sub.x.vf vf11 vf11 vf15 :mask #b111)
          (.ftoi.vf vf14 vf12)
          (.ftoi.vf vf13 vf11)
          (.mov v1-1 vf14)
          (.mov a2-1 vf13)
          (.pcgtw a1-2 a2-1 a1-1))
        (.pcgtw v1-2 a0-1 v1-1)))
    (.por v1-3 a1-2 v1-2)
    (.ppach v1-4 zero v1-3)
    (let ((v1-5 (shl (the-as int v1-4) 16))) (nop!) (zero? v1-5))))

(defmethod collide-ray ((obj collide-fragment) (arg0 int) (arg1 collide-list))
  "Inline-array function to do line-sphere with non-instanced fragments.
   If the bsphere of the mesh is in the non-aligned bounding box, the mesh will be added
   to the given collide-list.
   Note: collide-probe is the faster implementation of this."
  *collide-work*
  ;; just iterate over all and check their bsphere.
  (dotimes (s3-0 arg0)
    (when (collide-cache-using-line-sphere-test (-> obj bsphere))
      (let ((v1-5 (-> arg1 items (-> arg1 num-items))))
        (set! (-> v1-5 mesh) (-> obj mesh))
        (set! (-> v1-5 inst) #f) ;; non-instanced.
        )
      (+! (-> arg1 num-items) 1))
    (&+! obj 32))
  0
  (none))

(defmethod collide-ray ((obj instance-tie) (arg0 int) (arg1 collide-list))
  "Inline-array function to do line-sphere with TIE instances.
  If the bsphere of the mesh is in the non-aligned bounding box, the mesh will be added
  to the given collide-list.
  Note: collide-probe is the faster implementation of this."
  ;; loop over instance-ties
  (dotimes (s3-0 arg0)
    ;; first check the instance-tie's bsphere
    (when (and (zero? (logand (-> obj flags) 1)) (collide-cache-using-line-sphere-test (-> obj bsphere)))
      ;; now, find the collide-frag
      (let ((s2-0 (-> obj bucket-ptr collide-frag)))
        (when (nonzero? s2-0)
          (let ((s1-0 (the-as object (-> s2-0 data))))
            ;; and check each mesh in the collide-frag
            (dotimes (s0-0 (-> s2-0 length))
              (when (make-collide-list-using-line-sphere-inst-test (the-as collide-fragment s1-0) obj)
                (let ((v1-10 (-> arg1 items (-> arg1 num-items))))
                  (set! (-> v1-10 mesh) (-> (the-as collide-fragment s1-0) mesh))
                  (set! (-> v1-10 inst) obj))
                (+! (-> arg1 num-items) 1))
              (set! s1-0 (-> (the-as (inline-array collide-fragment) s1-0) 1)))))))
    (&+! obj 64))
  0
  (none))

;;;;;;;;;;;;;;;;;;;
;; foreground box
;;;;;;;;;;;;;;;;;;;

;; for an unknown reason, the goal compiler went insane on this function

(defmethod fill-from-foreground-using-box ((obj collide-cache))
  (local-vars
    (zero uint128)
    (v1-2 uint128)
    (v1-15 uint128)
    (v1-18 uint128)
    (v1-31 uint128)
    (v1-44 uint128)
    (a1-1 uint128)
    (a1-6 uint128)
    (a1-11 uint128)
    (a1-16 uint128)
    (a2-0 uint128)
    (a2-1 uint128)
    (a2-2 uint128)
    (a2-3 uint128)
    (a2-5 uint128)
    (a2-6 uint128)
    (a2-7 uint128)
    (a2-8 uint128)
    (a2-10 uint128)
    (a2-11 uint128)
    (a2-12 uint128)
    (a2-13 uint128)
    (a2-15 uint128)
    (a2-16 uint128)
    (a2-17 uint128)
    (a2-18 uint128)
    (a3-0 uint128)
    (a3-1 uint128)
    (a3-2 uint128)
    (a3-3 uint128)
    (a3-4 uint128)
    (a3-5 uint128)
    (a3-6 uint128)
    (a3-7 uint128)
    (f31-0 none))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf))
    (set! zero (the-as uint128 0))
    (let ((s5-0 (the-as uint128 (-> obj collide-with)))
          (s4-0 (-> obj collide-box4w min quad))
          (s3-0 (-> obj collide-box4w max quad)))
      (let ((v1-1 (the-as uint128 (make-u128 0 16)))) (.pand v1-2 v1-1 s5-0))
      (when (nonzero? (the-as int v1-2))
        (let ((v1-5 (-> *collide-player-list* alive-list next0)))
          *collide-player-list*
          (let ((s2-0 (-> v1-5 next0)))
            (while (!= v1-5 (-> *collide-player-list* alive-list-end))
              (let* ((v1-6 (the-as collide-shape (-> (the-as connection v1-5) param1)))
                     (a0-3 (-> v1-6 root-prim)))
                (let ((a1-0 (the-as uint128 (-> a0-3 prim-core collide-as)))) (.pand a1-1 s5-0 a1-0))
                (b! (zero? (the-as int a1-1)) cfg-7)
                (nop!)
                (.lvf vf1 (&-> a0-3 prim-core world-sphere quad))
                (.sub.w.vf vf2 vf1 vf1)
                (nop!)
                (.add.w.vf vf3 vf1 vf1)
                (nop!)
                (.ftoi.vf vf4 vf2)
                (nop!)
                (.ftoi.vf vf5 vf3)
                (nop!)
                (.mov a2-0 vf4)
                (let ((v1-7 (-> v1-6 process)))
                  (.mov a3-0 vf5)
                  (let ((a1-3 (-> obj proc)))
                    (.pcgtw a2-1 a2-0 s3-0)
                    (.pcgtw a3-1 s4-0 a3-0)
                    (.por a2-2 a2-1 a3-1)
                    (.ppach a2-3 zero a2-2)
                    (let ((a2-4 (shl (the-as int a2-3) 16))) (nop!) (b! (nonzero? a2-4) cfg-6 :delay (nop!)))
                    (b! (= a1-3 v1-7) cfg-6 :delay (nop!))))
                (add-fg-prim-using-box a0-3 obj))
              (label cfg-6)
              0
              (label cfg-7)
              (set! v1-5 s2-0)
              *collide-player-list*
              (set! s2-0 (-> s2-0 next0))))))
      (let ((v1-14 (the-as uint128 (make-u128 0 14)))) (.pand v1-15 v1-14 s5-0))
      (when (nonzero? (the-as int v1-15))
        (let ((v1-17 (the-as uint128 (make-u128 0 2)))) (.pand v1-18 v1-17 s5-0))
        (when (nonzero? (the-as int v1-18))
          (let ((v1-21 (-> *collide-hit-by-player-list* alive-list next0)))
            *collide-hit-by-player-list*
            (let ((s2-1 (-> v1-21 next0)))
              (while (!= v1-21 (-> *collide-hit-by-player-list* alive-list-end))
                (let* ((v1-22 (the-as collide-shape (-> (the-as connection v1-21) param1)))
                       (a0-10 (-> v1-22 root-prim)))
                  (let ((a1-5 (the-as uint128 (-> a0-10 prim-core collide-as)))) (.pand a1-6 s5-0 a1-5))
                  (b! (zero? (the-as int a1-6)) cfg-18)
                  (nop!)
                  (.lvf vf1 (&-> a0-10 prim-core world-sphere quad))
                  (.sub.w.vf vf2 vf1 vf1)
                  (nop!)
                  (.add.w.vf vf3 vf1 vf1)
                  (nop!)
                  (.ftoi.vf vf4 vf2)
                  (nop!)
                  (.ftoi.vf vf5 vf3)
                  (nop!)
                  (.mov a2-5 vf4)
                  (let ((v1-23 (-> v1-22 process)))
                    (.mov a3-2 vf5)
                    (let ((a1-8 (-> obj proc)))
                      (.pcgtw a2-6 a2-5 s3-0)
                      (.pcgtw a3-3 s4-0 a3-2)
                      (.por a2-7 a2-6 a3-3)
                      (.ppach a2-8 zero a2-7)
                      (let ((a2-9 (shl (the-as int a2-8) 16))) (nop!) (b! (nonzero? a2-9) cfg-17 :delay (nop!)))
                      (b! (= a1-8 v1-23) cfg-17 :delay (nop!))))
                  (add-fg-prim-using-box a0-10 obj))
                (label cfg-17)
                0
                (label cfg-18)
                (set! v1-21 s2-1)
                *collide-hit-by-player-list*
                (set! s2-1 (-> s2-1 next0))))))
        (let ((v1-30 (the-as uint128 (make-u128 0 4)))) (.pand v1-31 v1-30 s5-0))
        (when (nonzero? (the-as int v1-31))
          (let ((v1-34 (-> *collide-usually-hit-by-player-list* alive-list next0)))
            *collide-usually-hit-by-player-list*
            (let ((s2-2 (-> v1-34 next0)))
              (while (!= v1-34 (-> *collide-usually-hit-by-player-list* alive-list-end))
                (let* ((v1-35 (the-as collide-shape (-> (the-as connection v1-34) param1)))
                       (a0-17 (-> v1-35 root-prim)))
                  (let ((a1-10 (the-as uint128 (-> a0-17 prim-core collide-as)))) (.pand a1-11 s5-0 a1-10))
                  (b! (zero? (the-as int a1-11)) cfg-28)
                  (nop!)
                  (nop!)
                  (.lvf vf1 (&-> a0-17 prim-core world-sphere quad))
                  (.sub.w.vf vf2 vf1 vf1)
                  (nop!)
                  (.add.w.vf vf3 vf1 vf1)
                  (nop!)
                  (.ftoi.vf vf4 vf2)
                  (nop!)
                  (.ftoi.vf vf5 vf3)
                  (nop!)
                  (.mov a2-10 vf4)
                  (let ((v1-36 (-> v1-35 process)))
                    (.mov a3-4 vf5)
                    (let ((a1-13 (-> obj proc)))
                      (.pcgtw a2-11 a2-10 s3-0)
                      (.pcgtw a3-5 s4-0 a3-4)
                      (.por a2-12 a2-11 a3-5)
                      (.ppach a2-13 zero a2-12)
                      (let ((a2-14 (shl (the-as int a2-13) 16))) (nop!) (b! (nonzero? a2-14) cfg-27 :delay (nop!)))
                      (b! (= a1-13 v1-36) cfg-27 :delay (nop!))))
                  (add-fg-prim-using-box a0-17 obj))
                (label cfg-27)
                0
                (label cfg-28)
                (set! v1-34 s2-2)
                *collide-usually-hit-by-player-list*
                (set! s2-2 (-> s2-2 next0))))))
        (let ((v1-43 (the-as uint128 (make-u128 0 8)))) (.pand v1-44 v1-43 s5-0))
        (when (nonzero? (the-as int v1-44))
          (let ((v1-46 (-> *collide-hit-by-others-list* alive-list next0)))
            *collide-hit-by-others-list*
            (let ((s2-3 (-> v1-46 next0)))
              (while (!= v1-46 (-> *collide-hit-by-others-list* alive-list-end))
                (let* ((v1-47 (the-as collide-shape (-> (the-as connection v1-46) param1)))
                       (a0-24 (-> v1-47 root-prim)))
                  (let ((a1-15 (the-as uint128 (-> a0-24 prim-core collide-as)))) (.pand a1-16 s5-0 a1-15))
                  (b! (zero? (the-as int a1-16)) cfg-38)
                  (nop!)
                  (nop!)
                  (.lvf vf1 (&-> a0-24 prim-core world-sphere quad))
                  (.sub.w.vf vf2 vf1 vf1)
                  (nop!)
                  (.add.w.vf vf3 vf1 vf1)
                  (nop!)
                  (.ftoi.vf vf4 vf2)
                  (nop!)
                  (.ftoi.vf vf5 vf3)
                  (nop!)
                  (.mov a2-15 vf4)
                  (let ((v1-48 (-> v1-47 process)))
                    (.mov a3-6 vf5)
                    (let ((a1-18 (-> obj proc)))
                      (.pcgtw a2-16 a2-15 s3-0)
                      (.pcgtw a3-7 s4-0 a3-6)
                      (.por a2-17 a2-16 a3-7)
                      (.ppach a2-18 zero a2-17)
                      (let ((a2-19 (shl (the-as int a2-18) 16))) (nop!) (b! (nonzero? a2-19) cfg-37 :delay (nop!)))
                      (b! (= a1-18 v1-48) cfg-37 :delay (nop!))))
                  (add-fg-prim-using-box a0-24 obj))
                (label cfg-37)
                0
                (label cfg-38)
                (set! v1-46 s2-3)
                *collide-hit-by-others-list*
                (set! s2-3 (-> s2-3 next0))))))))
    (none)))

(defmethod add-fg-prim-using-box ((obj collide-shape-prim) (arg0 collide-cache))
  (format 0 "ERROR: Illegal collide-shape-prim type passed to collide-shape-prim::add-fg-prim-using-box!~%")
  (none))

(defmethod add-fg-prim-using-box ((obj collide-shape-prim-sphere) (arg0 collide-cache))
  (local-vars (t1-1 uint))
  (nop!)
  (let* ((t0-0 (-> arg0 prims))
         (a3-0 (-> arg0 num-prims-u))
         (t1-0 100)
         (v1-0 (-> obj prim-core world-sphere quad))
         (t2-0 (* a3-0 2))
         (a2-0 (-> obj prim-core quad 1)))
    (b! (= a3-0 t1-0) cfg-2 :delay (set! t1-1 (+ t2-0 a3-0)))
    (let ((t0-1 (the-as object (&-> t0-0 0 prim-core quad t1-1))))
      (let ((a3-1 (+ a3-0 1)))
        (set! (-> (the-as (pointer uint128) t0-1) 2) (the-as uint128 0))
        (nop!)
        (set! (-> (the-as collide-cache-prim t0-1) prim) obj)
        (nop!)
        (set! (-> (the-as collide-cache-prim t0-1) prim-core world-sphere quad) v1-0)
        (nop!)
        (set! (-> (the-as collide-cache-prim t0-1) prim-core quad 1) a2-0)
        (nop!)
        (set! (-> arg0 num-prims) (the-as int a3-1)))
      (nop!)
      (set! (-> (the-as collide-cache-prim t0-1) ccache) arg0)))
  (b! #t cfg-3 :delay (nop!))
  (label cfg-2)
  (format 0 "ERROR: Exceeded max number of collide-cache prims!~%")
  (label cfg-3)
  (none))

(defmethod add-fg-prim-using-box ((obj collide-shape-prim-group) (arg0 collide-cache))
  (local-vars
    (zero uint128)
    (v1-2 uint128)
    (v1-3 uint128)
    (v1-4 uint128)
    (v1-5 uint128)
    (a0-1 collide-shape-prim)
    (a1-1 uint128)
    (a1-2 uint128))
  (set! zero (the-as uint128 0))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf))
    (nop!)
    (let ((s5-0 (-> obj prims))
          (s4-0 (-> obj num-prims-u)))
      (nop!)
      (let ((s3-0 (-> arg0 collide-box4w min quad)))
        (nop!)
        (let ((s2-0 (-> arg0 collide-box4w max quad)))
          (nop!)
          (let ((s1-0 (-> s5-0 0)))
            (nop!)
            (let ((s0-0 (-> arg0 collide-with)))
              (label cfg-1)
              (b! (zero? s4-0) cfg-5 :delay (set! a0-1 s1-0))
              (label cfg-2)
              (+! s4-0 -1)
              (.lvf vf1 (&-> a0-1 prim-core world-sphere quad))
              (nop!)
              (let ((v1-0 (-> a0-1 prim-core collide-as)))
                (.sub.w.vf vf2 vf1 vf1)
                (set! s5-0 (&-> s5-0 1))
                (.add.w.vf vf3 vf1 vf1)
                (set! s1-0 (-> s5-0 0))
                (let ((v1-1 (logand s0-0 v1-0))) (nop!) (b! (zero? v1-1) cfg-1 :delay (nop!)))))
            (.ftoi.vf vf4 vf2)
            (nop!)
            (.ftoi.vf vf5 vf3)
            (nop!)
            (.mov a1-1 vf4)
            (nop!)
            (.mov v1-2 vf5)
            (nop!)
            (.pcgtw a1-2 a1-1 s2-0)
            (.pcgtw v1-3 s3-0 v1-2)
            (.por v1-4 a1-2 v1-3)
            (.ppach v1-5 zero v1-4)
            (let ((v1-6 (shl (the-as int v1-5) 16))) (nop!) (b! (nonzero? v1-6) cfg-1 :delay (nop!)))
            (add-fg-prim-using-box a0-1 arg0)
            (b! (nonzero? s4-0) cfg-2 :delay (set! a0-1 s1-0))))))
    (label cfg-5)
    0
    (none)))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; Foreground Y PROBE
;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod fill-from-foreground-using-y-probe ((obj collide-cache))
  (local-vars
    (zero uint128)
    (v1-2 uint128)
    (v1-15 uint128)
    (v1-18 uint128)
    (v1-31 uint128)
    (v1-44 uint128)
    (a1-1 uint128)
    (a1-6 uint128)
    (a1-11 uint128)
    (a1-16 uint128)
    (a2-0 uint128)
    (a2-1 uint128)
    (a2-2 uint128)
    (a2-3 uint128)
    (a2-5 uint128)
    (a2-6 uint128)
    (a2-7 uint128)
    (a2-8 uint128)
    (a2-10 uint128)
    (a2-11 uint128)
    (a2-12 uint128)
    (a2-13 uint128)
    (a2-15 uint128)
    (a2-16 uint128)
    (a2-17 uint128)
    (a2-18 uint128)
    (a3-0 uint128)
    (a3-1 uint128)
    (a3-2 uint128)
    (a3-3 uint128)
    (a3-4 uint128)
    (a3-5 uint128)
    (a3-6 uint128)
    (a3-7 uint128))
  (set! zero (the uint128 0))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf))
    (let ((s5-0 (the-as uint128 (-> obj collide-with)))
          (s4-0 (-> obj collide-box4w min quad))
          (s3-0 (-> obj collide-box4w max quad)))
      (let ((v1-1 (the-as uint128 (make-u128 0 16)))) (.pand v1-2 v1-1 s5-0))
      (when (nonzero? (the-as int v1-2))
        (let ((v1-5 (-> *collide-player-list* alive-list next0)))
          *collide-player-list*
          (let ((s2-0 (-> v1-5 next0)))
            (while (!= v1-5 (-> *collide-player-list* alive-list-end))
              (let* ((v1-6 (the-as collide-shape (-> (the-as connection v1-5) param1)))
                     (a0-3 (-> v1-6 root-prim)))
                (let ((a1-0 (the-as uint128 (-> a0-3 prim-core collide-as)))) (.pand a1-1 s5-0 a1-0))
                (b! (zero? (the-as int a1-1)) cfg-7)
                (.lvf vf1 (&-> a0-3 prim-core world-sphere quad))
                (.sub.w.vf vf2 vf1 vf1)
                (.add.w.vf vf3 vf1 vf1)
                (.ftoi.vf vf4 vf2)
                (.ftoi.vf vf5 vf3)
                (.mov a2-0 vf4)
                (let ((v1-7 (-> v1-6 process)))
                  (.mov a3-0 vf5)
                  (let ((a1-3 (-> obj proc)))
                    (.pcgtw a2-1 a2-0 s3-0)
                    (.pcgtw a3-1 s4-0 a3-0)
                    (.por a2-2 a2-1 a3-1)
                    (.ppach a2-3 zero a2-2)
                    (let ((a2-4 (shl (the-as int a2-3) 16))) (nop!) (b! (nonzero? a2-4) cfg-6 :delay (nop!)))
                    (b! (= a1-3 v1-7) cfg-6 :delay (nop!))))
                (add-fg-prim-using-y-probe a0-3 obj))
              (label cfg-6)
              0
              (label cfg-7)
              (set! v1-5 s2-0)
              *collide-player-list*
              (set! s2-0 (-> s2-0 next0))))))
      (let ((v1-14 (the-as uint128 (make-u128 0 14)))) (.pand v1-15 v1-14 s5-0))
      (when (nonzero? (the-as int v1-15))
        (let ((v1-17 (the-as uint128 (make-u128 0 2)))) (.pand v1-18 v1-17 s5-0))
        (when (nonzero? (the-as int v1-18))
          (let ((v1-21 (-> *collide-hit-by-player-list* alive-list next0)))
            *collide-hit-by-player-list*
            (let ((s2-1 (-> v1-21 next0)))
              (while (!= v1-21 (-> *collide-hit-by-player-list* alive-list-end))
                (let* ((v1-22 (the-as collide-shape (-> (the-as connection v1-21) param1)))
                       (a0-10 (-> v1-22 root-prim)))
                  (let ((a1-5 (the-as uint128 (-> a0-10 prim-core collide-as)))) (.pand a1-6 s5-0 a1-5))
                  (b! (zero? (the-as int a1-6)) cfg-18)
                  (nop!)
                  (.lvf vf1 (&-> a0-10 prim-core world-sphere quad))
                  (.sub.w.vf vf2 vf1 vf1)
                  (nop!)
                  (.add.w.vf vf3 vf1 vf1)
                  (nop!)
                  (.ftoi.vf vf4 vf2)
                  (nop!)
                  (.ftoi.vf vf5 vf3)
                  (nop!)
                  (.mov a2-5 vf4)
                  (let ((v1-23 (-> v1-22 process)))
                    (.mov a3-2 vf5)
                    (let ((a1-8 (-> obj proc)))
                      (.pcgtw a2-6 a2-5 s3-0)
                      (.pcgtw a3-3 s4-0 a3-2)
                      (.por a2-7 a2-6 a3-3)
                      (.ppach a2-8 zero a2-7)
                      (let ((a2-9 (shl (the-as int a2-8) 16))) (nop!) (b! (nonzero? a2-9) cfg-17 :delay (nop!)))
                      (b! (= a1-8 v1-23) cfg-17 :delay (nop!))))
                  (add-fg-prim-using-y-probe a0-10 obj))
                (label cfg-17)
                0
                (label cfg-18)
                (set! v1-21 s2-1)
                *collide-hit-by-player-list*
                (set! s2-1 (-> s2-1 next0))))))
        (let ((v1-30 (the-as uint128 (make-u128 0 4)))) (.pand v1-31 v1-30 s5-0))
        (when (nonzero? (the-as int v1-31))
          (let ((v1-34 (-> *collide-usually-hit-by-player-list* alive-list next0)))
            *collide-usually-hit-by-player-list*
            (let ((s2-2 (-> v1-34 next0)))
              (while (!= v1-34 (-> *collide-usually-hit-by-player-list* alive-list-end))
                (let* ((v1-35 (the-as collide-shape (-> (the-as connection v1-34) param1)))
                       (a0-17 (-> v1-35 root-prim)))
                  (let ((a1-10 (the-as uint128 (-> a0-17 prim-core collide-as)))) (.pand a1-11 s5-0 a1-10))
                  (b! (zero? (the-as int a1-11)) cfg-28)
                  (nop!)
                  (nop!)
                  (.lvf vf1 (&-> a0-17 prim-core world-sphere quad))
                  (.sub.w.vf vf2 vf1 vf1)
                  (nop!)
                  (.add.w.vf vf3 vf1 vf1)
                  (nop!)
                  (.ftoi.vf vf4 vf2)
                  (nop!)
                  (.ftoi.vf vf5 vf3)
                  (nop!)
                  (.mov a2-10 vf4)
                  (let ((v1-36 (-> v1-35 process)))
                    (.mov a3-4 vf5)
                    (let ((a1-13 (-> obj proc)))
                      (.pcgtw a2-11 a2-10 s3-0)
                      (.pcgtw a3-5 s4-0 a3-4)
                      (.por a2-12 a2-11 a3-5)
                      (.ppach a2-13 zero a2-12)
                      (let ((a2-14 (shl (the-as int a2-13) 16))) (nop!) (b! (nonzero? a2-14) cfg-27 :delay (nop!)))
                      (b! (= a1-13 v1-36) cfg-27 :delay (nop!))))
                  (add-fg-prim-using-y-probe a0-17 obj))
                (label cfg-27)
                0
                (label cfg-28)
                (set! v1-34 s2-2)
                *collide-usually-hit-by-player-list*
                (set! s2-2 (-> s2-2 next0))))))
        (let ((v1-43 (the-as uint128 (make-u128 0 8)))) (.pand v1-44 v1-43 s5-0))
        (when (nonzero? (the-as int v1-44))
          (let ((v1-46 (-> *collide-hit-by-others-list* alive-list next0)))
            *collide-hit-by-others-list*
            (let ((s2-3 (-> v1-46 next0)))
              (while (!= v1-46 (-> *collide-hit-by-others-list* alive-list-end))
                (let* ((v1-47 (the-as collide-shape (-> (the-as connection v1-46) param1)))
                       (a0-24 (-> v1-47 root-prim)))
                  (let ((a1-15 (the-as uint128 (-> a0-24 prim-core collide-as)))) (.pand a1-16 s5-0 a1-15))
                  (b! (zero? (the-as int a1-16)) cfg-38)
                  (nop!)
                  (nop!)
                  (.lvf vf1 (&-> a0-24 prim-core world-sphere quad))
                  (.sub.w.vf vf2 vf1 vf1)
                  (nop!)
                  (.add.w.vf vf3 vf1 vf1)
                  (nop!)
                  (.ftoi.vf vf4 vf2)
                  (nop!)
                  (.ftoi.vf vf5 vf3)
                  (nop!)
                  (.mov a2-15 vf4)
                  (let ((v1-48 (-> v1-47 process)))
                    (.mov a3-6 vf5)
                    (let ((a1-18 (-> obj proc)))
                      (.pcgtw a2-16 a2-15 s3-0)
                      (.pcgtw a3-7 s4-0 a3-6)
                      (.por a2-17 a2-16 a3-7)
                      (.ppach a2-18 zero a2-17)
                      (let ((a2-19 (shl (the-as int a2-18) 16))) (nop!) (b! (nonzero? a2-19) cfg-37 :delay (nop!)))
                      (b! (= a1-18 v1-48) cfg-37 :delay (nop!))))
                  (add-fg-prim-using-y-probe a0-24 obj))
                (label cfg-37)
                0
                (label cfg-38)
                (set! v1-46 s2-3)
                *collide-hit-by-others-list*
                (set! s2-3 (-> s2-3 next0))))))))
    (none)))

(defmethod add-fg-prim-using-y-probe ((obj collide-shape-prim) (arg0 collide-cache))
  (format 0 "ERROR: Illegal collide-shape-prim type passed to collide-shape-prim::add-fg-prim-using-y-probe!~%")
  (none))

(defmethod add-fg-prim-using-y-probe ((obj collide-shape-prim-sphere) (arg0 collide-cache))
  (local-vars (t1-1 uint))
  (nop!)
  (let* ((t0-0 (-> arg0 prims))
         (a3-0 (-> arg0 num-prims-u))
         (t1-0 100)
         (v1-0 (-> obj prim-core world-sphere quad))
         (t2-0 (* a3-0 2))
         (a2-0 (-> obj prim-core quad 1)))
    (b! (= a3-0 t1-0) cfg-2 :delay (set! t1-1 (+ t2-0 a3-0)))
    (let ((t0-1 (the-as object (&-> t0-0 0 prim-core quad t1-1))))
      (let ((a3-1 (+ a3-0 1)))
        (set! (-> (the-as collide-cache-prim t0-1) extra-quad) (the-as uint128 0))
        (nop!)
        (set! (-> (the-as collide-cache-prim t0-1) prim) obj)
        (nop!)
        (set! (-> (the-as collide-cache-prim t0-1) prim-core world-sphere quad) v1-0)
        (nop!)
        (set! (-> (the-as collide-cache-prim t0-1) prim-core quad 1) a2-0)
        (nop!)
        (set! (-> arg0 num-prims) (the-as int a3-1)))
      (nop!)
      (set! (-> (the-as collide-cache-prim t0-1) ccache) arg0)))
  (b! #t cfg-3 :delay (nop!))
  (label cfg-2)
  (format 0 "ERROR: Exceeded max number of collide-cache prims!~%")
  (label cfg-3)
  (none))

(defmethod add-fg-prim-using-y-probe ((obj collide-shape-prim-group) (arg0 collide-cache))
  (local-vars
    (r0-0 int)
    (r0-1 int)
    (r0-2 uint128)
    (r0-3 int)
    (v1-2 uint128)
    (v1-3 uint128)
    (v1-4 uint128)
    (v1-5 uint128)
    (a0-1 collide-shape-prim)
    (a1-1 uint128)
    (a1-2 uint128)
    (f31-0 none))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf))
    (nop!)
    (let ((s5-0 (-> obj prims))
          (s4-0 (-> obj num-prims-u)))
      (nop!)
      (let ((s3-0 (-> arg0 collide-box4w min quad)))
        (nop!)
        (let ((s2-0 (-> arg0 collide-box4w max quad)))
          (nop!)
          (let ((s1-0 (-> s5-0 0)))
            (nop!)
            (let ((s0-0 (-> arg0 collide-with)))
              (label cfg-1)
              (b! (zero? s4-0) cfg-5 :delay (set! a0-1 s1-0))
              (label cfg-2)
              (+! s4-0 -1)
              (.lvf vf1 (&-> a0-1 prim-core world-sphere quad))
              (nop!)
              (let ((v1-0 (-> a0-1 prim-core collide-as)))
                (.sub.w.vf vf2 vf1 vf1)
                (set! s5-0 (&-> s5-0 1))
                (.add.w.vf vf3 vf1 vf1)
                (set! s1-0 (-> s5-0 0))
                (let ((v1-1 (logand s0-0 v1-0))) (nop!) (b! (zero? v1-1) cfg-1 :delay (nop!)))))
            (.ftoi.vf vf4 vf2)
            (nop!)
            (.ftoi.vf vf5 vf3)
            (nop!)
            (.mov a1-1 vf4)
            (nop!)
            (.mov v1-2 vf5)
            (nop!)
            (.pcgtw a1-2 a1-1 s2-0)
            (.mov r0-0 f31-0)
            (.pcgtw v1-3 s3-0 v1-2)
            (.mov r0-1 f31-0)
            (.por v1-4 a1-2 v1-3)
            (.mov r0-2 f31-0)
            (.ppach v1-5 r0-2 v1-4)
            (.mov r0-3 f31-0)
            (let ((v1-6 (shl (the-as int v1-5) 16))) (nop!) (b! (nonzero? v1-6) cfg-1 :delay (nop!)))
            (add-fg-prim-using-y-probe a0-1 arg0)
            (b! (nonzero? s4-0) cfg-2 :delay (set! a0-1 s1-0))))))
    (label cfg-5)
    0
    (none)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; foreground Line Sphere
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; added (fill from foreground using line sphere)
(deftype pc-fffuls-work (structure)
  ((reg-vf28 vector :inline)
   (reg-vf29 vector :inline)
   (reg-vf30 vector :inline)
   (reg-vf31 vector :inline)))

(define *pc-fffuls-work* (new 'global 'pc-fffuls-work))

(defmacro save-fffuls-work ()
  `(begin
    (.svf (&-> *pc-fffuls-work* reg-vf31 quad) vf31)
    (.svf (&-> *pc-fffuls-work* reg-vf30 quad) vf30)
    (.svf (&-> *pc-fffuls-work* reg-vf29 quad) vf29)
    (.svf (&-> *pc-fffuls-work* reg-vf28 quad) vf28)))

(defmacro load-fffuls-work ()
  `(begin
    (.lvf vf28 (&-> *pc-fffuls-work* reg-vf28 quad))
    (.lvf vf29 (&-> *pc-fffuls-work* reg-vf29 quad))
    (.lvf vf30 (&-> *pc-fffuls-work* reg-vf30 quad))
    (.lvf vf31 (&-> *pc-fffuls-work* reg-vf31 quad))))

(defmethod fill-from-foreground-using-line-sphere ((obj collide-cache))
  (local-vars
    (zero uint128)
    (v1-1 float)
    (v1-4 uint128)
    (v1-17 uint128)
    (v1-20 uint128)
    (v1-33 uint128)
    (v1-46 uint128)
    (a1-1 uint128)
    (a1-6 uint128)
    (a1-11 uint128)
    (a1-16 uint128)
    (a2-0 uint128)
    (a2-1 uint128)
    (a2-2 uint128)
    (a2-3 uint128)
    (a2-5 uint128)
    (a2-6 uint128)
    (a2-7 uint128)
    (a2-8 uint128)
    (a2-10 uint128)
    (a2-11 uint128)
    (a2-12 uint128)
    (a2-13 uint128)
    (a2-15 uint128)
    (a2-16 uint128)
    (a2-17 uint128)
    (a2-18 uint128)
    (a3-0 uint128)
    (a3-1 uint128)
    (a3-2 uint128)
    (a3-3 uint128)
    (a3-4 uint128)
    (a3-5 uint128)
    (a3-6 uint128)
    (a3-7 uint128)
    (f31-0 none))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf28 :class vf)
         (vf29 :class vf)
         (vf3 :class vf)
         (vf30 :class vf)
         (vf31 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf))
    (init-vf0-vector)
    (set! zero (the uint128 0))
    (let* ((v1-0 *collide-work*)
           (s5-0 (-> v1-0 collide-box4w min quad))
           (s4-0 (-> v1-0 collide-box4w max quad))
           (s3-0 (the-as uint128 (-> obj collide-with))))
      (.lvf vf28 (&-> v1-0 inv-mat vector 0 quad))
      (.lvf vf29 (&-> v1-0 inv-mat vector 1 quad))
      (.lvf vf30 (&-> v1-0 inv-mat vector 2 quad))
      (.lvf vf31 (&-> v1-0 inv-mat vector 3 quad))
      (save-fffuls-work)
      (.mov v1-1 vf31)
      (let ((v1-3 (the-as uint128 (make-u128 0 16)))) (.pand v1-4 v1-3 s3-0))
      (when (nonzero? (the-as int v1-4))
        (let ((v1-7 (-> *collide-player-list* alive-list next0)))
          *collide-player-list*
          (let ((s2-0 (-> v1-7 next0)))
            (while (!= v1-7 (-> *collide-player-list* alive-list-end))
              (let* ((v1-8 (the-as collide-shape (-> (the-as connection v1-7) param1)))
                     (a0-3 (-> v1-8 root-prim)))
                (let ((a1-0 (the-as uint128 (-> a0-3 prim-core collide-as)))) (.pand a1-1 s3-0 a1-0))
                (b! (zero? (the-as int a1-1)) cfg-7)
                (.mul.w.vf acc vf31 vf0)
                (.lvf vf1 (&-> a0-3 prim-core world-sphere quad))
                (.add.mul.x.vf acc vf28 vf1 acc)
                (nop!)
                (.add.mul.y.vf acc vf29 vf1 acc)
                (nop!)
                (.add.mul.z.vf vf6 vf30 vf1 acc)
                (nop!)
                (.sub.w.vf vf2 vf6 vf1 :mask #b111)
                (nop!)
                (.add.w.vf vf3 vf6 vf1 :mask #b111)
                (nop!)
                (.ftoi.vf vf4 vf2)
                (nop!)
                (.ftoi.vf vf5 vf3)
                (nop!)
                (.mov a2-0 vf4)
                (let ((v1-9 (-> v1-8 process)))
                  (.mov a3-0 vf5)
                  (let ((a1-3 (-> obj proc)))
                    (.pcgtw a2-1 a2-0 s4-0)
                    (.pcgtw a3-1 s5-0 a3-0)
                    (.por a2-2 a2-1 a3-1)
                    (.ppach a2-3 zero a2-2)
                    (let ((a2-4 (shl (the-as int a2-3) 16))) (nop!) (b! (nonzero? a2-4) cfg-6 :delay (nop!)))
                    (b! (= a1-3 v1-9) cfg-6 :delay (nop!))))
                (add-fg-prim-using-line-sphere a0-3 obj))
              (label cfg-6)
              0
              (label cfg-7)
              (set! v1-7 s2-0)
              *collide-player-list*
              (set! s2-0 (-> s2-0 next0))))))
      (let ((v1-16 (the-as uint128 (make-u128 0 14)))) (.pand v1-17 v1-16 s3-0))
      (when (nonzero? (the-as int v1-17))
        (let ((v1-19 (the-as uint128 (make-u128 0 2)))) (.pand v1-20 v1-19 s3-0))
        (when (nonzero? (the-as int v1-20))
          (let ((v1-23 (-> *collide-hit-by-player-list* alive-list next0)))
            *collide-hit-by-player-list*
            (let ((s2-1 (-> v1-23 next0)))
              (while (!= v1-23 (-> *collide-hit-by-player-list* alive-list-end))
                (let* ((v1-24 (the-as collide-shape (-> (the-as connection v1-23) param1)))
                       (a0-10 (-> v1-24 root-prim)))
                  (let ((a1-5 (the-as uint128 (-> a0-10 prim-core collide-as)))) (.pand a1-6 s3-0 a1-5))
                  (b! (zero? (the-as int a1-6)) cfg-18)
                  (.mul.w.vf acc vf31 vf0)
                  (.lvf vf1 (&-> a0-10 prim-core world-sphere quad))
                  (.add.mul.x.vf acc vf28 vf1 acc)
                  (nop!)
                  (.add.mul.y.vf acc vf29 vf1 acc)
                  (nop!)
                  (.add.mul.z.vf vf6 vf30 vf1 acc)
                  (nop!)
                  (.sub.w.vf vf2 vf6 vf1 :mask #b111)
                  (nop!)
                  (.add.w.vf vf3 vf6 vf1 :mask #b111)
                  (nop!)
                  (.ftoi.vf vf4 vf2)
                  (nop!)
                  (.ftoi.vf vf5 vf3)
                  (nop!)
                  (.mov a2-5 vf4)
                  (let ((v1-25 (-> v1-24 process)))
                    (.mov a3-2 vf5)
                    (let ((a1-8 (-> obj proc)))
                      (.pcgtw a2-6 a2-5 s4-0)
                      (.pcgtw a3-3 s5-0 a3-2)
                      (.por a2-7 a2-6 a3-3)
                      (.ppach a2-8 zero a2-7)
                      (let ((a2-9 (shl (the-as int a2-8) 16))) (nop!) (b! (nonzero? a2-9) cfg-17 :delay (nop!)))
                      (b! (= a1-8 v1-25) cfg-17 :delay (nop!))))
                  (add-fg-prim-using-line-sphere a0-10 obj))
                (label cfg-17)
                0
                (label cfg-18)
                (set! v1-23 s2-1)
                *collide-hit-by-player-list*
                (set! s2-1 (-> s2-1 next0))))))
        (let ((v1-32 (the-as uint128 (make-u128 0 4)))) (.pand v1-33 v1-32 s3-0))
        (when (nonzero? (the-as int v1-33))
          (let ((v1-36 (-> *collide-usually-hit-by-player-list* alive-list next0)))
            *collide-usually-hit-by-player-list*
            (let ((s2-2 (-> v1-36 next0)))
              (while (!= v1-36 (-> *collide-usually-hit-by-player-list* alive-list-end))
                (let* ((v1-37 (the-as collide-shape (-> (the-as connection v1-36) param1)))
                       (a0-17 (-> v1-37 root-prim)))
                  (let ((a1-10 (the-as uint128 (-> a0-17 prim-core collide-as)))) (.pand a1-11 s3-0 a1-10))
                  (b! (zero? (the-as int a1-11)) cfg-28)
                  (nop!)
                  (.mul.w.vf acc vf31 vf0)
                  (.lvf vf1 (&-> a0-17 prim-core world-sphere quad))
                  (.add.mul.x.vf acc vf28 vf1 acc)
                  (nop!)
                  (.add.mul.y.vf acc vf29 vf1 acc)
                  (nop!)
                  (.add.mul.z.vf vf6 vf30 vf1 acc)
                  (nop!)
                  (.sub.w.vf vf2 vf6 vf1 :mask #b111)
                  (nop!)
                  (.add.w.vf vf3 vf6 vf1 :mask #b111)
                  (nop!)
                  (.ftoi.vf vf4 vf2)
                  (nop!)
                  (.ftoi.vf vf5 vf3)
                  (nop!)
                  (.mov a2-10 vf4)
                  (let ((v1-38 (the-as basic (-> v1-37 process))))
                    (.mov a3-4 vf5)
                    (let ((a1-13 (-> obj proc)))
                      (.pcgtw a2-11 a2-10 s4-0)
                      (.pcgtw a3-5 s5-0 a3-4)
                      (.por a2-12 a2-11 a3-5)
                      (.ppach a2-13 zero a2-12)
                      (let ((a2-14 (shl (the-as int a2-13) 16))) (nop!) (b! (nonzero? a2-14) cfg-27 :delay (nop!)))
                      (b! (= a1-13 (the-as process-drawable v1-38)) cfg-27 :delay (nop!))))
                  (add-fg-prim-using-line-sphere a0-17 obj))
                (label cfg-27)
                0
                (label cfg-28)
                (set! v1-36 s2-2)
                *collide-usually-hit-by-player-list*
                (set! s2-2 (-> s2-2 next0))))))
        (let ((v1-45 (the-as uint128 (make-u128 0 8)))) (.pand v1-46 v1-45 s3-0))
        (when (nonzero? (the-as int v1-46))
          (let ((v1-48 (-> *collide-hit-by-others-list* alive-list next0)))
            *collide-hit-by-others-list*
            (let ((s2-3 (-> v1-48 next0)))
              (while (!= v1-48 (-> *collide-hit-by-others-list* alive-list-end))
                (let* ((v1-49 (the-as collide-shape (-> (the-as connection v1-48) param1)))
                       (a0-24 (-> v1-49 root-prim)))
                  (let ((a1-15 (the-as uint128 (-> a0-24 prim-core collide-as)))) (.pand a1-16 s3-0 a1-15))
                  (b! (zero? (the-as int a1-16)) cfg-38)
                  (nop!)
                  (.mul.w.vf acc vf31 vf0)
                  (.lvf vf1 (&-> a0-24 prim-core world-sphere quad))
                  (.add.mul.x.vf acc vf28 vf1 acc)
                  (nop!)
                  (.add.mul.y.vf acc vf29 vf1 acc)
                  (nop!)
                  (.add.mul.z.vf vf6 vf30 vf1 acc)
                  (nop!)
                  (.sub.w.vf vf2 vf6 vf1 :mask #b111)
                  (nop!)
                  (.add.w.vf vf3 vf6 vf1 :mask #b111)
                  (nop!)
                  (.ftoi.vf vf4 vf2)
                  (nop!)
                  (.ftoi.vf vf5 vf3)
                  (nop!)
                  (.mov a2-15 vf4)
                  (let ((v1-50 (-> v1-49 process)))
                    (.mov a3-6 vf5)
                    (let ((a1-18 (-> obj proc)))
                      (.pcgtw a2-16 a2-15 s4-0)
                      (.pcgtw a3-7 s5-0 a3-6)
                      (.por a2-17 a2-16 a3-7)
                      (.ppach a2-18 zero a2-17)
                      (let ((a2-19 (shl (the-as int a2-18) 16))) (nop!) (b! (nonzero? a2-19) cfg-37 :delay (nop!)))
                      (b! (= a1-18 v1-50) cfg-37 :delay (nop!))))
                  (add-fg-prim-using-line-sphere a0-24 obj))
                (label cfg-37)
                0
                (label cfg-38)
                (set! v1-48 s2-3)
                *collide-hit-by-others-list*
                (set! s2-3 (-> s2-3 next0))))))))
    (none)))

(defmethod add-fg-prim-using-line-sphere ((obj collide-shape-prim) (arg0 collide-cache))
  (format 0 "ERROR: Illegal collide-shape-prim type passed to collide-shape-prim::add-fg-prim-using-line-sphere!~%")
  (none))

(defmethod add-fg-prim-using-line-sphere ((obj collide-shape-prim-sphere) (arg0 collide-cache))
  (local-vars (t1-1 uint))
  (nop!)
  (let* ((t0-0 (-> arg0 prims))
         (a3-0 (-> arg0 num-prims-u))
         (t1-0 100)
         (v1-0 (-> obj prim-core world-sphere quad))
         (t2-0 (* a3-0 2))
         (a2-0 (-> obj prim-core quad 1)))
    (b! (= a3-0 t1-0) cfg-2 :delay (set! t1-1 (+ t2-0 a3-0)))
    (let ((t0-1 (the-as object (&-> t0-0 0 prim-core quad t1-1))))
      (let ((a3-1 (+ a3-0 1)))
        (set! (-> (the-as collide-cache-prim t0-1) extra-quad) (the-as uint128 0))
        (nop!)
        (set! (-> (the-as collide-cache-prim t0-1) prim) obj)
        (nop!)
        (set! (-> (the-as collide-cache-prim t0-1) prim-core world-sphere quad) v1-0)
        (nop!)
        (set! (-> (the-as collide-cache-prim t0-1) prim-core quad 1) a2-0)
        (nop!)
        (set! (-> arg0 num-prims) (the-as int a3-1)))
      (nop!)
      (set! (-> (the-as collide-cache-prim t0-1) ccache) arg0)))
  (b! #t cfg-3 :delay (nop!))
  (label cfg-2)
  (format 0 "ERROR: Exceeded max number of collide-cache prims!~%")
  (label cfg-3)
  (none))

(defmethod add-fg-prim-using-line-sphere ((obj collide-shape-prim-group) (arg0 collide-cache))
  (local-vars
    (zero uint128)
    (v1-3 uint128)
    (v1-4 uint128)
    (v1-5 uint128)
    (v1-6 uint128)
    (a0-1 collide-shape-prim)
    (a1-1 uint128)
    (a1-2 uint128))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf2 :class vf)
         (vf28 :class vf)
         (vf29 :class vf)
         (vf3 :class vf)
         (vf30 :class vf)
         (vf31 :class vf)
         (vf4 :class vf)
         (vf5 :class vf))
    (init-vf0-vector)
    (load-fffuls-work)
    (set! zero (the-as uint128 0))
    (let ((v1-0 *collide-work*)
          (s5-0 (-> obj prims))
          (s4-0 (-> obj num-prims-u)))
      (nop!)
      (let ((s3-0 (-> v1-0 collide-box4w min quad)))
        (nop!)
        (let ((s2-0 (-> v1-0 collide-box4w max quad)))
          (nop!)
          (let ((s1-0 (-> s5-0 0)))
            (nop!)
            (let ((s0-0 (-> arg0 collide-with)))
              (label cfg-1)
              (b! (zero? s4-0) cfg-5 :delay (set! a0-1 s1-0))
              (label cfg-2)
              (+! s4-0 -1)
              (.lvf vf1 (&-> a0-1 prim-core world-sphere quad))
              (nop!)
              (let ((v1-1 (-> a0-1 prim-core collide-as)))
                (.mul.w.vf acc vf31 vf0)
                (set! s5-0 (&-> s5-0 1))
                (.add.mul.x.vf acc vf28 vf1 acc)
                (set! s1-0 (-> s5-0 0))
                (let ((v1-2 (logand s0-0 v1-1)))
                  (.add.mul.y.vf acc vf29 vf1 acc)
                  (b! (zero? v1-2) cfg-1 :delay (.add.mul.z.vf vf10 vf30 vf1 acc)))))
            (.sub.w.vf vf2 vf10 vf1 :mask #b111)
            (nop!)
            (.add.w.vf vf3 vf10 vf1 :mask #b111)
            (nop!)
            (.ftoi.vf vf4 vf2)
            (nop!)
            (.ftoi.vf vf5 vf3)
            (nop!)
            (.mov a1-1 vf4)
            (nop!)
            (.mov v1-3 vf5)
            (nop!)
            (.pcgtw a1-2 a1-1 s2-0)
            (.pcgtw v1-4 s3-0 v1-3)
            (.por v1-5 a1-2 v1-4)
            (.ppach v1-6 zero v1-5)
            (let ((v1-7 (shl (the-as int v1-6) 16))) (nop!) (b! (nonzero? v1-7) cfg-1 :delay (nop!)))
            (add-fg-prim-using-line-sphere a0-1 arg0)
            (b! (nonzero? s4-0) cfg-2 :delay (set! a0-1 s1-0))))))
    (label cfg-5)
    0
    (none)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PROBE ;; PROBE ;; PROBE ;; PROBE ;; PROBE ;; PROBE ;; PROBE ;; PROBE ;; PROBE ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod fill-and-probe-using-y-probe ((obj collide-cache) (arg0 vector) (arg1 float) (arg2 collide-kind) (arg3 process-drawable) (arg4 collide-tri-result) (arg5 pat-surface))
  (fill-using-y-probe obj arg0 arg1 arg2 arg3 arg5)
  (probe-using-y-probe obj arg0 arg1 arg2 arg4 arg5))

(defmethod probe-using-y-probe ((obj collide-cache) (arg0 vector) (arg1 float) (arg2 collide-kind) (arg3 collide-tri-result) (arg4 pat-surface))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf3 :class vf))
    (init-vf0-vector)
    (let ((gp-0 (new 'stack-no-clear 'collide-puyp-work)))
      (.mov vf3 arg1)
      (.lvf vf1 (&-> arg0 quad))
      (set! (-> gp-0 best-u) 2.0)
      (set! (-> gp-0 ignore-pat) arg4)
      (set! (-> gp-0 tri-out) arg3)
      (.sub.x.vf vf3 vf0 vf3 :mask #b10)
      (.svf (&-> gp-0 start-pos quad) vf1)
      (.mov.vf vf3 vf0 :mask #b1101)
      (.svf (&-> gp-0 move-dist quad) vf3)
      (let ((s2-0 (the-as object (-> obj prims))))
        (countdown (s1-0 (-> obj num-prims))
          (when (and (logtest? arg2 (-> (the-as collide-cache-prim s2-0) prim-core collide-as))
                     (logtest? (-> (the-as collide-cache-prim s2-0) prim-core action) (collide-action solid)))
            (cond
              ((>= (-> (the-as collide-cache-prim s2-0) prim-core prim-type) 0) (puyp-mesh obj gp-0 (the-as collide-cache-prim s2-0)))
              (else
               (if (zero? (logand arg4 (-> (the-as collide-shape-prim-sphere (-> (the-as collide-cache-prim s2-0) prim)) pat)))
                 (puyp-sphere obj gp-0 (the-as collide-cache-prim s2-0))))))
          (set! s2-0 (-> (the-as (inline-array collide-cache-prim) s2-0) 1))))
      (let ((f0-1 (-> gp-0 best-u))) (if (< 1.0 f0-1) (set! f0-1 -100000000.0)) f0-1))))

(defmethod puyp-sphere ((obj collide-cache) (arg0 collide-puyp-work) (arg1 collide-cache-prim))
  (let ((f0-1 (ray-sphere-intersect (-> arg0 start-pos)
                                    (-> arg0 move-dist)
                                    (the-as vector (-> arg1 prim-core))
                                    (-> arg1 prim-core world-sphere w))))
    (when (and (>= f0-1 0.0) (< f0-1 (-> arg0 best-u)))
      (set! (-> arg0 best-u) f0-1)
      (let ((gp-0 (-> arg0 tri-out)))
        (set! (-> gp-0 pat) (-> (the-as collide-shape-prim-sphere (-> arg1 prim)) pat))
        (vector+*! (-> gp-0 intersect) (-> arg0 start-pos) (-> arg0 move-dist) f0-1)
        (vector-! (-> gp-0 normal) (-> gp-0 intersect) (the-as vector (-> arg1 prim-core)))
        (vector-normalize! (-> gp-0 normal) 1.0)
        (set! (-> gp-0 vertex 0 quad) (-> gp-0 intersect quad))
        (point-in-plane-<-point+normal! (-> gp-0 vertex 1) (-> gp-0 intersect) (-> gp-0 normal))
        (let* ((a0-11 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) (-> gp-0 vertex 1) (the-as vector (-> gp-0 vertex))) 1.0))
               (a2-5 (vector-cross! (new 'stack-no-clear 'vector) (-> gp-0 normal) a0-11)))
          (vector+*! (-> gp-0 vertex 2) (-> gp-0 intersect) a2-5 4096.0))))))

(defmethod fill-and-probe-using-line-sphere ((obj collide-cache) (arg0 vector) (arg1 vector) (arg2 float) (arg3 collide-kind) (arg4 process) (arg5 collide-tri-result) (arg6 pat-surface))
  (fill-using-line-sphere obj arg0 arg1 arg2 arg3 (the-as process-drawable arg4) arg6)
  (probe-using-line-sphere obj arg0 arg1 arg2 arg3 arg5 arg6))

(deftype collide-puls-work (structure)
  ((ignore-pat pat-surface :offset-assert 0)
   (tri-out    collide-tri-result :offset-assert 4)
   (bsphere    sphere :inline :offset-assert 16)
   (move-dist  vector :inline :offset-assert 32))
  :method-count-assert 9
  :size-assert #x30
  :flag-assert #x900000030)

(defmethod probe-using-line-sphere ((obj collide-cache) (arg0 vector) (arg1 vector) (arg2 float) (arg3 collide-kind) (arg4 collide-tri-result) (arg5 pat-surface))
  (rlet ((vf0 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf))
    (init-vf0-vector)
    (let ((s4-0 (new 'stack-no-clear 'collide-puls-work)))
      (.mov vf4 arg2)
      (.lvf vf3 (&-> arg0 quad))
      (.lvf vf2 (&-> arg1 quad))
      (set! (-> s4-0 ignore-pat) arg5)
      (.mul.x.vf vf3 vf0 vf4 :mask #b1000)
      (set! (-> s4-0 tri-out) arg4)
      (.svf (&-> s4-0 move-dist quad) vf2)
      (.svf (&-> s4-0 bsphere quad) vf3)
      (let ((s3-0 (the-as object (-> obj prims)))
            (f30-0 -100000000.0))
        (countdown (s2-0 (-> obj num-prims))
          (when (and (logtest? arg3 (-> (the-as collide-cache-prim s3-0) prim-core collide-as))
                     (logtest? (-> (the-as collide-cache-prim s3-0) prim-core action) (collide-action solid)))
            (cond
              ((>= (-> (the-as collide-cache-prim s3-0) prim-core prim-type) 0)
               (let ((f0-0 ((method-of-type collide-cache-prim resolve-moving-sphere-tri)
                            (the-as collide-cache-prim s3-0)
                            (-> s4-0 tri-out)
                            (the-as collide-prim-core (-> s4-0 bsphere))
                            (-> s4-0 move-dist)
                            f30-0
                            (collide-action solid))))
                 (if (>= f0-0 0.0) (set! f30-0 f0-0))))
              (else
               (when (zero? (logand arg5 (-> (the-as collide-shape-prim-sphere (-> (the-as collide-cache-prim s3-0) prim)) pat)))
                 (let ((f0-1 ((method-of-type collide-cache-prim resolve-moving-sphere-sphere)
                              (the-as collide-cache-prim s3-0)
                              (-> s4-0 tri-out)
                              (the-as collide-prim-core (-> s4-0 bsphere))
                              (-> s4-0 move-dist)
                              f30-0
                              (collide-action solid))))
                   (if (>= f0-1 0.0) (set! f30-0 f0-1)))))))
          (set! s3-0 (-> (the-as (inline-array collide-cache-prim) s3-0) 1)))
        f30-0))))

(defmethod fill-and-probe-using-spheres ((obj collide-cache) (arg0 collide-using-spheres-params))
  (fill-using-spheres obj arg0)
  (probe-using-spheres obj arg0))

(defmethod fill-using-spheres ((obj collide-cache) (arg0 collide-using-spheres-params))
  (let ((s4-0 (new 'stack-no-clear 'bounding-box)))
    (set-from-spheres! s4-0 (-> arg0 spheres) (the-as int (-> arg0 num-spheres)))
    ;; this box looks correct
    (fill-using-bounding-box obj s4-0 (-> arg0 collide-with) (-> arg0 proc) (the-as pat-surface (-> arg0 ignore-pat))))
  (none))

(defmethod probe-using-spheres ((obj collide-cache) (arg0 collide-using-spheres-params))
  (local-vars (v1-12 symbol))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf))
    (let ((s5-0 (scratchpad-object collide-puss-work))
          (a3-0 64)
          (a2-0 (-> arg0 num-spheres)))
      (let ((v1-0 (-> s5-0 spheres))
            (a1-1 (-> arg0 spheres)))
        (let ((a3-1 (- a2-0 (the-as uint a3-0)))) (nop!) (b! (> (the-as int a3-1) 0) cfg-20 :delay (nop!)))
        (b! (zero? a2-0) cfg-5 :delay (.lvf vf1 a1-1))
        (let ((a2-1 (+ a2-0 -1))
              (a1-2 (the-as (inline-array sphere) (-> a1-1 1))))
          (.sub.w.vf vf2 vf1 vf1 :mask #b111)
          (.svf (&-> v1-0 0 bsphere quad) vf1)
          (.add.w.vf vf3 vf1 vf1 :mask #b111)
          (let ((v1-1 (-> v1-0 1)))
            (.ftoi.vf vf4 vf2)
            (nop!)
            (.ftoi.vf vf5 vf3)
            (nop!)
            (nop!)
            (.svf (+ (the int v1-1) -32) vf4)
            (nop!)
            (.svf (+ (the int v1-1) -16) vf5)
            (label cfg-3)
            (b! (zero? a2-1) cfg-5 :delay (.lvf vf1 a1-2))
            (+! a2-1 -1)
            (set! a1-2 (the-as (inline-array sphere) (-> a1-2 1)))
            (.sub.w.vf vf4 vf1 vf1 :mask #b111)
            (.svf (&-> v1-1 bsphere quad) vf1)
            (.add.w.vf vf5 vf1 vf1 :mask #b111)
            (nop!)
            (.min.vf vf2 vf2 vf4 :mask #b111)
            (nop!)
            (.max.vf vf3 vf3 vf5 :mask #b111)
            (nop!)
            (.ftoi.vf vf4 vf4)
            (nop!)
            (.ftoi.vf vf5 vf5)
            (nop!)
            (nop!)
            (.svf (&-> v1-1 bbox4w min quad) vf4)
            (nop!)
            (.svf (&-> v1-1 bbox4w max quad) vf5)
            (b! #t cfg-3 :delay (set! v1-1 (&+ v1-1 48))))))
      (label cfg-5)
      (.ftoi.vf vf2 vf2)
      (nop!)
      (.ftoi.vf vf3 vf3)
      (nop!)
      (nop!)
      (.svf (&-> s5-0 spheres-bbox4w min quad) vf2)
      (nop!)
      (.svf (&-> s5-0 spheres-bbox4w max quad) vf3)
      (let ((s4-0 (the-as collide-cache-prim (-> obj prims)))
            (s3-0 (-> arg0 collide-with))
            (s2-0 (-> obj num-prims)))
        (b! #t cfg-18 :delay (nop!))
        (label cfg-6)
        (+! s2-0 -1)
        (when (logtest? s3-0 (-> s4-0 prim-core collide-as))
          (when (or (not (-> arg0 solid-only)) (logtest? (-> s4-0 prim-core action) (collide-action solid)))
            (if (>= (-> s4-0 prim-core prim-type) 0)
              (set! v1-12 (collide-puss-work-method-9 s5-0 s4-0 arg0))
              (set! v1-12 (collide-puss-work-method-10 s5-0 s4-0 arg0)))
            (when v1-12
              ;; uncomment to view the point that blocks you from exiting duck.
              ;;(add-debug-point #t (bucket-id debug-no-zbuf) (-> s5-0 closest-pt))
              (return #t))))
        (&+! s4-0 48)
        (label cfg-18)
        (b! (nonzero? s2-0) cfg-6 :delay (nop!)))
      (b! #t cfg-21 :delay (nop!))
      (label cfg-20)
      ;; fixed bad format string
      (format 0 "ERROR: Exceeded max # of spheres in collide-cache::probe-using-spheres!~%"))
    (label cfg-21)
    #f))

;; todo a bunch of suffering.
