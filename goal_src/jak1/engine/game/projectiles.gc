;;-*-Lisp-*-
(in-package goal)

;; name: projectiles.gc
;; name in dgo: projectiles
;; dgos: GAME, ENGINE
;; note: changed for high fps

;; DECOMP BEGINS

(deftype search-info (structure)
  ((point        vector     :inline :offset-assert   0)
   (best-point   vector     :inline :offset-assert  16)
   (match-handle handle             :offset-assert  32)
   (match        projectile         :offset-assert  40)
   (best         float              :offset-assert  44)
   (radius       float              :offset-assert  48)
   (rating       uint32             :offset-assert  52)
   (require      uint32             :offset-assert  56)
   (mask         uint32             :offset-assert  60)
   (rot-base     vector     :inline :offset-assert  64)
   (rot-range    float              :offset-assert  80)
   )
  :method-count-assert 9
  :size-assert         #x54
  :flag-assert         #x900000054
  )


(define *search-info* (new 'global 'search-info))

(defun find-nearest-attackable ((arg0 vector) (arg1 float) (arg2 uint) (arg3 uint) (arg4 vector) (arg5 float))
  (let ((gp-0 *search-info*))
    (set! (-> gp-0 match) #f)
    (set! (-> gp-0 point quad) (-> arg0 quad))
    (set! (-> gp-0 radius) arg1)
    (set! (-> gp-0 best) arg1)
    (set! (-> gp-0 rating) (the-as uint 0))
    (set! (-> gp-0 require) arg3)
    (set! (-> gp-0 mask) arg2)
    (set! (-> gp-0 rot-base quad) (-> arg4 quad))
    (set! (-> gp-0 rot-range) (if (= arg5 65536.0)
                                  -2.0
                                  (cos arg5)
                                  )
          )
    (iterate-process-tree
      *entity-pool*
      (lambda ((arg0 projectile))
        (when (logtest? (process-mask crate enemy attackable) (-> arg0 mask))
          (let* ((gp-0 *search-info*)
                 (s4-0 arg0)
                 (s5-0 (if (and (nonzero? s4-0) (type-type? (-> s4-0 type) process-drawable))
                           s4-0
                           )
                       )
                 )
            (when s5-0
              (let* ((s3-0 (-> s5-0 root-override))
                     (s4-1 (if (and (nonzero? s3-0) (type-type? (-> s3-0 type) collide-shape))
                               s3-0
                               )
                           )
                     )
                (when (the-as collide-shape-moving s4-1)
                  (let* ((s3-1 (-> s4-1 root-prim prim-core))
                         (f30-0 (- (vector-vector-distance (-> gp-0 point) (the-as vector s3-1)) (-> s3-1 world-sphere w)))
                         )
                    (when (nonzero? (-> s4-1 root-prim prim-core collide-as))
                      (let ((s4-2 0)
                            (v1-8 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) (the-as vector s3-1) (-> gp-0 point)) 1.0))
                            )
                        (if (logtest? (process-mask enemy) (-> s5-0 mask))
                            (set! s4-2 (logior s4-2 1))
                            )
                        (if (and (nonzero? (-> s5-0 draw)) (logtest? (-> s5-0 draw status) (draw-status was-drawn)))
                            (set! s4-2 (logior s4-2 2))
                            )
                        (let ((a0-16 (logand s4-2 (-> gp-0 mask))))
                          (when (and (>= a0-16 (the-as int (-> gp-0 rating)))
                                     (or (zero? (-> gp-0 require)) (logtest? a0-16 (-> gp-0 require)))
                                     (< f30-0 (-> gp-0 best))
                                     (>= (vector-dot v1-8 (-> gp-0 rot-base)) (-> gp-0 rot-range))
                                     )
                            (set! (-> gp-0 match) s5-0)
                            (set! (-> gp-0 best) f30-0)
                            (set! (-> gp-0 rating) (the-as uint a0-16))
                            a0-16
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      *null-kernel-context*
      )
    (-> gp-0 match)
    )
  )

(defun projectile-collision-reaction ((arg0 collide-shape-moving) (arg1 collide-shape-intersect) (arg2 vector) (arg3 vector))
  (local-vars (sv-64 vector) (sv-68 vector) (sv-72 matrix) (sv-80 int) (sv-224 symbol))
  (set! sv-64 (new-stack-vector0))
  (set! sv-68 (new-stack-vector0))
  (set! sv-72 (new 'stack-no-clear 'matrix))
  (set! sv-80 0)
  (set! (-> sv-72 vector 0 quad) (-> arg3 quad))
  (let ((a1-1 (new 'stack-no-clear 'vector)))
    (vector-float*! a1-1 (-> arg1 move-vec) (-> arg1 best-u))
    (move-by-vector! arg0 a1-1)
    )
  (set-and-handle-pat! arg0 (-> arg1 best-tri pat))
  (case (-> arg1 best-tri pat material)
    (((pat-material stopproj))
     (send-event (-> arg0 process) 'die)
     )
    )
  (vector-! sv-64 (the-as vector (-> arg1 best-from-prim prim-core)) (-> arg1 best-tri intersect))
  (set! (-> sv-64 w) 1.0)
  (vector-normalize! sv-64 1.0)
  (set! (-> arg0 coverage) (vector-dot sv-64 (-> arg1 best-tri normal)))
  (let ((v1-22 (-> sv-64 quad)))
    (set! (-> sv-68 quad) v1-22)
    )
  (when (= (-> arg1 best-u) 0.0)
    (let ((a1-7 (vector-float*! (new 'stack-no-clear 'vector) sv-68 32.0)))
      (move-by-vector! arg0 a1-7)
      )
    )
  (set! (-> arg0 surface-normal quad) (-> sv-68 quad))
  (set! (-> arg0 poly-normal quad) (-> arg1 best-tri normal quad))
  (set! (-> arg0 surface-angle) (vector-dot sv-68 (-> arg0 dynam gravity-normal)))
  (set! (-> arg0 poly-angle) (vector-dot (-> arg0 poly-normal) (-> arg0 dynam gravity-normal)))
  (set! (-> arg0 touch-angle)
        (vector-dot sv-68 (vector-normalize! (vector-negate! (new-stack-vector0) (the-as vector sv-72)) 1.0))
        )
  (if (< (-> arg0 poly-angle) -0.2)
      (set! sv-80 (logior sv-80 16))
      )
  (set! sv-224 (< (fabs (-> arg0 surface-angle)) (-> *pat-mode-info* (-> arg0 cur-pat mode) wall-angle)))
  (if (not (logtest? (-> arg0 prev-status) (cshape-moving-flags onsurf)))
      (set! (-> arg0 ground-impact-vel) (- (vector-dot (-> arg0 transv) (-> arg0 dynam gravity-normal))))
      )
  (set! sv-80 (logior sv-80 4))
  (if (-> arg1 best-to-prim)
      (set! sv-80 (logior sv-80 32))
      )
  (cond
    (sv-224
      (set! sv-80 (logior sv-80 8))
      (set! (-> arg0 cur-pat mode) 1)
      (set! (-> arg0 local-normal quad) (-> sv-68 quad))
      )
    (else
      (set! sv-80 (logior sv-80 1))
      (set! (-> arg0 local-normal quad) (-> sv-68 quad))
      )
    )
  (vector-reflect-flat-above! arg2 (the-as vector sv-72) sv-68)
  (when (and (not sv-224) (>= (-> arg0 coverage) 0.9))
    (set! sv-80 (logior sv-80 2))
    (set! (-> arg0 ground-poly-normal quad) (-> arg0 poly-normal quad))
    (when (!= (-> arg0 poly-pat mode) (pat-mode wall))
      (set! (-> arg0 ground-pat) (-> arg0 poly-pat))
      (set! (-> arg0 ground-touch-point quad) (-> arg1 best-tri intersect quad))
      )
    )
  (logior! (-> arg0 status) sv-80)
  (the-as cshape-moving-flags sv-80)
  )

(defpartgroup group-yellow-eco-fireball
  :id 102
  :duration (seconds 1)
  :bounds (static-bspherem 0 0 0 3)
  :parts ((sp-item 349 :flags (launch-asap) :binding 350)
    (sp-item 350 :flags (start-dead launch-asap) :binding 351)
    (sp-item 351 :flags (start-dead launch-asap) :binding 352)
    (sp-item 352 :flags (start-dead) :binding 353)
    (sp-item 352 :flags (start-dead) :binding 353)
    (sp-item 352 :flags (start-dead) :binding 353)
    (sp-item 352 :flags (start-dead) :binding 353)
    (sp-item 352 :flags (start-dead) :binding 353)
    (sp-item 352 :flags (start-dead) :binding 353)
    (sp-item 352 :flags (start-dead) :binding 353)
    (sp-item 352 :flags (start-dead) :binding 353)
    (sp-item 352 :flags (start-dead) :binding 353)
    (sp-item 352 :flags (start-dead) :binding 353)
    (sp-item 352 :flags (start-dead) :binding 353)
    (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
    )
  )

(defpart 349
  :init-specs ((:texture (new 'static 'texture-id :index #x12 :page #x2))
    (:num 1.0)
    (:scale-x (meters 0.01))
    (:scale-y :copy scale-x)
    (:a 0.0)
    (:timer (seconds 4))
    (:flags (bit3))
    (:func 'sparticle-track-root-prim)
    )
  )

(defpart 350
  :init-specs ((:texture (new 'static 'texture-id :index #x12 :page #x2))
    (:num 1.0)
    (:x (meters 0) (meters 16))
    (:y (meters 4) (meters 16))
    (:z (meters 0))
    (:scale-x (meters 5))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 128.0)
    (:g 64.0 64.0)
    (:a 32.0)
    (:vel-x (meters -0.10666667) 1 (meters 0.21333334))
    (:rotvel-z (degrees -0.4) 1 (degrees 0.8))
    (:timer (seconds 4))
    (:flags (bit2 bit3 bit7))
    )
  )

(defpart 351
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 2.0)
    (:y (meters 0) (meters 16))
    (:z (meters 0))
    (:scale-x (meters 1.5) (meters 0.5))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 128.0)
    (:g 64.0 64.0)
    (:a 64.0)
    (:omega 0.0 65536.0)
    (:vel-x (meters 0.11259259))
    (:rotvel-z (degrees -0.3) 1 (degrees 0.6))
    (:timer (seconds 4))
    (:flags (bit2 bit3 bit7))
    )
  )

(defpart 352
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 1.0)
    (:scale-x (meters 1.5) (meters 0.5))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 128.0)
    (:g 64.0 64.0)
    (:a 64.0)
    (:scalevel-x (meters -0.02))
    (:rotvel-z (degrees -0.3) 1 (degrees 0.6))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -1.0)
    (:timer (seconds 0.18))
    (:flags (bit2 bit3))
    )
  )

(defpart 353
  :init-specs ((:texture (new 'static 'texture-id :index #xf :page #x2))
    (:num 0.5 0.5)
    (:y (meters -0.05))
    (:scale-x (meters 0.3) (meters 0.1))
    (:scale-y :copy scale-x)
    (:r 100.0 28.0)
    (:g 64.0 64.0)
    (:b 0.0)
    (:a 96.0)
    (:vel-y (meters 0.005) (meters 0.011666667))
    (:scalevel-x (meters -0.000909091))
    (:scalevel-y :copy scalevel-x)
    (:fade-g -0.4)
    (:fade-a -0.024242423)
    (:accel-y (meters -0.000100000005) (meters -0.0003))
    (:friction 0.93)
    (:timer (seconds 0.1) (seconds 0.997))
    (:flags (bit2 bit3))
    (:next-time (seconds 0.3))
    (:next-launcher 354)
    (:conerot-x (degrees 0) (degrees 180))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 0.3))
    )
  )

(defpart 354
  :init-specs ((:fade-r 0.0))
  )

(defpartgroup group-part-yellow-eco-fireball-launcher
  :id 103
  :duration (seconds 2)
  :bounds (static-bspherem 0 0 0 6)
  :parts ((sp-item 355 :flags (launch-asap))
    (sp-item 356 :flags (bit1) :period (seconds 2.1) :length (seconds 0.05))
    (sp-item 357 :flags (launch-asap))
    (sp-item 358 :flags (launch-asap) :binding 359)
    (sp-item 359 :flags (start-dead launch-asap))
    (sp-item 359 :flags (start-dead launch-asap))
    (sp-item 359 :flags (start-dead launch-asap))
    (sp-item 359 :flags (start-dead launch-asap))
    (sp-item 359 :flags (start-dead launch-asap))
    (sp-item 359 :flags (start-dead launch-asap))
    (sp-item 359 :flags (start-dead launch-asap))
    (sp-item 359 :flags (start-dead launch-asap))
    (sp-item 359 :flags (start-dead launch-asap))
    (sp-item 359 :flags (start-dead launch-asap))
    (sp-item 359 :flags (start-dead launch-asap))
    (sp-item 359 :flags (start-dead launch-asap))
    (sp-item 359 :flags (start-dead launch-asap))
    (sp-item 359 :flags (start-dead launch-asap))
    (sp-item 359 :flags (start-dead launch-asap))
    (sp-item 359 :flags (start-dead launch-asap))
    )
  )

(defpart 355
  :init-specs ((:texture (new 'static 'texture-id :index #x12 :page #x2))
    (:num 1.0)
    (:scale-x (meters 8))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 128.0)
    (:a 64.0)
    (:scalevel-x (meters -0.06666667))
    (:rotvel-z (degrees -204.8) 1 (degrees 409.6))
    (:scalevel-y :copy scalevel-x)
    (:fade-a 0.0)
    (:timer (seconds 0.2))
    (:flags (bit2 bit3))
    )
  )

(defpart 357
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 5.0)
    (:x (meters -0.6) (meters 1.2))
    (:y (meters -0.6) (meters 1.2))
    (:z (meters -0.6) (meters 1.2))
    (:scale-x (meters 1.5) (meters 0.75))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 100.0 28.0)
    (:g 64.0 64.0)
    (:b 32.0)
    (:a 32.0 32.0)
    (:scalevel-x (meters 0.0044444446))
    (:rotvel-z (degrees -0.3) (degrees 0.6))
    (:scalevel-y :copy scalevel-x)
    (:fade-g -0.14222223)
    (:fade-a -0.14222223)
    (:accel-y (meters -0.000016666667))
    (:timer (seconds 1.5))
    (:flags (bit2 bit3))
    )
  )

(defpart 356
  :init-specs ((:texture (new 'static 'texture-id :index #x12 :page #x2))
    (:num 12.0)
    (:scale-x (meters 0.3) (meters 0.1))
    (:scale-y :copy scale-x)
    (:r 100.0 28.0)
    (:g 64.0 64.0)
    (:b 0.0)
    (:a 128.0)
    (:vel-y (meters 0) (meters 0.053333335))
    (:scalevel-x (meters -0.0025000002))
    (:scalevel-y :copy scalevel-x)
    (:fade-g -1.0666667)
    (:fade-a -0.17777778)
    (:accel-y (meters -0.001))
    (:friction 0.99)
    (:timer (seconds 0.2) (seconds 0.197))
    (:flags (bit2 bit3))
    (:conerot-x (degrees 0) (degrees 120))
    (:conerot-y (degrees 90) (degrees 180))
    )
  )

(defpart 360
  :init-specs ((:texture (new 'static 'texture-id :index #x12 :page #x2))
    (:num 24.0)
    (:scale-x (meters 0.3) (meters 0.1))
    (:scale-y :copy scale-x)
    (:r 100.0 28.0)
    (:g 64.0 64.0)
    (:b 0.0)
    (:a 128.0)
    (:vel-y (meters 0) (meters 0.053333335))
    (:scalevel-x (meters -0.0025000002))
    (:scalevel-y :copy scalevel-x)
    (:fade-g -1.0666667)
    (:fade-a -0.17777778)
    (:accel-y (meters -0.001))
    (:friction 0.99)
    (:timer (seconds 0.2) (seconds 0.197))
    (:flags (bit2 bit3))
    (:conerot-x (degrees 0) (degrees 180))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 358
  :init-specs ((:texture (new 'static 'texture-id :index #x12 :page #x2))
    (:num 16.0)
    (:scale-x (meters 0.1))
    (:scale-y :copy scale-x)
    (:a 1.0)
    (:vel-y (meters 0.02) (meters 0.013333334))
    (:accel-y (meters -0.0005))
    (:friction 0.99)
    (:timer (seconds 1.1))
    (:flags (bit2 bit3))
    (:conerot-x (degrees 0) (degrees 100.00001))
    (:conerot-y (degrees 90) (degrees 180))
    )
  )

(defpart 361
  :init-specs ((:texture (new 'static 'texture-id :index #x12 :page #x2))
    (:num 32.0)
    (:scale-x (meters 0.1))
    (:scale-y :copy scale-x)
    (:a 1.0)
    (:vel-y (meters 0.02) (meters 0.013333334))
    (:accel-y (meters -0.0005))
    (:friction 0.99)
    (:timer (seconds 1.1))
    (:flags (bit2 bit3))
    (:conerot-x (degrees 0) (degrees 180))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 359
  :init-specs ((:texture (new 'static 'texture-id :index #xf :page #x2))
    (:num 1.0)
    (:y (meters 0) (meters 16))
    (:z (meters 0.1) (meters 0.2))
    (:scale-x (meters 0.3) (meters 0.1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 100.0 28.0)
    (:g 64.0 64.0)
    (:b 0.0)
    (:a 64.0 64.0)
    (:omega 0.0 65536.0)
    (:vel-x (meters 0.10666667))
    (:scalevel-x (meters -0.000909091))
    (:rotvel-z (degrees -0.3) 1 (degrees 0.6))
    (:scalevel-y :copy scalevel-x)
    (:fade-g -0.26666668)
    (:fade-a -0.19393939)
    (:timer (seconds 0.3) (seconds 0.797))
    (:flags (bit2 bit3 bit7))
    )
  )

(defpartgroup group-part-yellow-eco-fireball-hit
  :id 104
  :duration (seconds 2)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 6)
  :parts ((sp-item 2059 :period (seconds 2) :length (seconds 0.017))
    (sp-item 2060 :fade-after (meters 80) :falloff-to (meters 80) :period (seconds 2) :length (seconds 0.135))
    (sp-item 2061 :period (seconds 2) :length (seconds 0.067))
    (sp-item 2062 :fade-after (meters 120) :falloff-to (meters 120) :period (seconds 2) :length (seconds 0.067))
    )
  )

(defpart 2060
  :init-specs ((:texture (new 'static 'texture-id :index #xf :page #x2))
    (:num 6.0)
    (:scale-x (meters 0.2) (meters 0.4))
    (:scale-y :copy scale-x)
    (:r 192.0 64.0)
    (:g 192.0 64.0)
    (:b 0.0)
    (:a 32.0 96.0)
    (:vel-y (meters 0.026666667) (meters 0.10666667))
    (:scalevel-x (meters -0.0016666667))
    (:scalevel-y :copy scalevel-x)
    (:accel-y (meters -0.00016666666) (meters -0.00016666666))
    (:friction 0.9)
    (:timer (seconds 1))
    (:flags (bit2 bit14))
    (:next-time (seconds 0.1) (seconds 0.097))
    (:next-launcher 2063)
    (:conerot-x (degrees 0) (degrees 180))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 2) (meters 4))
    )
  )

(defpart 2063
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0) (:fade-a -1.4222223))
  )

(defpart 2062
  :init-specs ((:texture (new 'static 'texture-id :index #xf :page #x2))
    (:num 3.0)
    (:scale-x (meters 0.2))
    (:rot-z (degrees 0) (degrees 180))
    (:scale-y (meters 8))
    (:r 255.0)
    (:g 196.0)
    (:b 0.0)
    (:a 32.0 64.0)
    (:scalevel-y (meters 0.42666668))
    (:fade-a -1.6)
    (:timer (seconds 0.2))
    (:flags (bit2 bit3 bit14))
    )
  )

(defpart 2059
  :init-specs ((:texture (new 'static 'texture-id :index #x12 :page #x2))
    (:num 1.0)
    (:scale-x (meters 16))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 192.0 32.0)
    (:b 0.0)
    (:a 96.0)
    (:fade-a -1.7454545)
    (:timer (seconds 0.18))
    (:flags (bit2 bit3 bit14))
    )
  )

(defpart 2061
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 4.0)
    (:scale-x (meters 2.5) (meters 1.5))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 192.0 64.0)
    (:b 128.0)
    (:a 64.0 64.0)
    (:vel-y (meters 0.053333335) (meters 0.013333334))
    (:scalevel-x (meters 0.013333334))
    (:rotvel-z (degrees -0.3) (degrees 0.6))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -1.6)
    (:accel-y (meters 0.00016666666) (meters 0.00016666666))
    (:friction 0.8)
    (:timer (seconds 1.7))
    (:flags (bit2 bit14))
    (:next-time (seconds 0.14))
    (:next-launcher 2064)
    (:conerot-x (degrees 0) (degrees 180))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 2064
  :init-specs ((:fade-r -0.53333336) (:fade-g -0.53333336) (:fade-b -1.0666667) (:fade-a -0.53333336))
  )

(defmethod projectile-method-24 projectile ((obj projectile))
  (spawn (-> obj part) (the-as vector (-> obj root-override root-prim prim-core)))
  0
  (none)
  )

(defmethod projectile-method-28 projectile ((obj projectile))
  0
  (none)
  )

(defstate projectile-moving (projectile)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('touched)
       (when (-> self attack-mode)
         (when (cond
                 ((= (-> proc type) target)
                  (send-event proc 'attack (-> event param 0) (static-attack-info ((mode (-> self attack-mode)))))
                  )
                 (else
                   (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
                     (set! (-> a1-2 from) self)
                     (set! (-> a1-2 num-params) 4)
                     (set! (-> a1-2 message) 'attack)
                     (set! (-> a1-2 param 0) (-> event param 0))
                     (set! (-> a1-2 param 1) (the-as uint (-> self attack-mode)))
                     (let ((v1-13 (+ *global-attack-id* 1)))
                       (set! *global-attack-id* v1-13)
                       (set! (-> a1-2 param 2) (the-as uint v1-13))
                       )
                     (set! (-> a1-2 param 3) (the-as uint 0))
                     (send-event-function proc a1-2)
                     )
                   )
                 )
           (let ((v1-14 (-> self notify-handle)))
             (if (handle->process v1-14)
                 (send-event (-> v1-14 process 0) 'notify 'attack proc)
                 )
             )
           (+! (-> self hits) 1)
           (if (>= (-> self hits) (-> self max-hits))
               (go-virtual projectile-impact)
               )
           )
         )
       )
      (('die)
       (go-virtual projectile-impact)
       )
      )
    )
  :enter (behavior ()
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (none)
    )
  :code (behavior ()
    (let ((gp-0 #f))
      (while (< (- (-> *display* base-frame-counter) (-> self state-time)) (-> self timeout))
        (let ((s5-0 (the int (-> *display* time-ratio))))
          (set-time-ratios *display* 1.0)
          (countdown (s4-0 s5-0)
            (if gp-0
                (go-virtual projectile-impact)
                )
            (projectile-method-28 self)
            ((-> self update-velocity) self)
            (when (logtest? (-> self options) 2)
              (seek! (-> self tween) 1.0 (* 0.5 (-> *display* seconds-per-frame)))
              (let ((f0-6 (vector-vector-distance (-> self root-override trans) (-> self target))))
                (cond
                  ((< f0-6 20480.0)
                   (seek! (-> self tween) 1.0 (* 3.0 (-> *display* seconds-per-frame)))
                   )
                  ((< f0-6 40960.0)
                   (seek! (-> self tween) 1.0 (-> *display* seconds-per-frame))
                   )
                  )
                )
              )
            (let ((s3-0 (new 'stack-no-clear 'vector)))
              (set! (-> s3-0 quad) (-> self root-override trans quad))
              (fill-cache-integrate-and-collide!
                (-> self root-override)
                (-> self root-override transv)
                (-> self root-override root-prim collide-with)
                )
              (set! (-> self old-dist (-> self old-dist-count))
                    (* 0.0625 (vector-vector-distance s3-0 (-> self root-override trans)))
                    )
              )
            (set! (-> self old-dist-count) (logand (+ (-> self old-dist-count) 1) 15))
            (let ((f0-16 0.0))
              (countdown (v1-35 16)
                (+! f0-16 (-> self old-dist v1-35))
                )
              ;; changed for high fps. This fixes projectile collision issues
              (if (or (and (logtest? (-> self root-override status) (cshape-moving-flags twall)) (< f0-16 (* (-> *display* time-adjust-ratio) 2048.0)))
                      (< f0-16 (* (-> *display* time-adjust-ratio) 204.8))
                      )
                  (set! gp-0 #t)
                  )
              )
            )
          (set-time-ratios *display* (the float s5-0))
          )
        (projectile-method-24 self)
        (suspend)
        )
      )
    (go-virtual projectile-dissipate)
    (none)
    )
  )

(defun projectile-update-velocity-space-wars ((arg0 projectile))
  (let ((s5-1 (vector-! (new 'stack-no-clear 'vector) (-> arg0 target) (-> arg0 root-override trans))))
    (let ((s4-0 (new 'stack-no-clear 'vector))
          (s3-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> arg0 root-override transv) 1.0))
          (f30-0 (vector-length (-> arg0 root-override transv)))
          )
      (if (logtest? (-> arg0 root-override status) (cshape-moving-flags tsurf))
          (vector-flatten! s5-1 s5-1 (-> arg0 root-override local-normal))
          )
      (vector-normalize-copy! s4-0 s5-1 1.0)
      (if (and (or (not (handle->process (-> arg0 last-target)))
                   (zero? (-> (the-as target (handle->process (-> arg0 last-target))) control root-prim prim-core collide-as))
                   )
               (< (vector-dot s4-0 s3-0) 0.0)
               )
          (go (method-of-object arg0 projectile-dissipate))
          )
      (vector-deg-slerp (-> arg0 root-override transv) s3-0 s4-0 (-> arg0 tween))
      (vector-normalize! (-> arg0 root-override transv) f30-0)
      )
    (vector+! (-> arg0 root-override transv) (-> arg0 root-override transv) s5-1)
    )
  (vector-v++!
    (-> arg0 root-override transv)
    (compute-acc-due-to-gravity (-> arg0 root-override) (new-stack-vector0) 0.0)
    )
  (if (< (-> arg0 max-speed) (vector-length (-> arg0 root-override transv)))
      (vector-normalize! (-> arg0 root-override transv) (-> arg0 max-speed))
      )
  (if (logtest? (-> arg0 options) 1)
      (set! (-> arg0 root-override transv y) -40960.0)
      )
  0
  (none)
  )

(defstate projectile-impact (projectile)
  :virtual #t
  :code (behavior ()
    (process-spawn
      part-tracker
      :init part-tracker-init
      (-> *part-group-id-table* 104)
      -1
      #f
      #f
      #f
      (-> self root-override root-prim prim-core)
      :to *entity-pool*
      )
    (if (nonzero? (-> self sound-id))
        (sound-stop (-> self sound-id))
        )
    (sound-play "yellow-explode")
    (suspend)
    (go-virtual projectile-die)
    (none)
    )
  )

(defstate projectile-dissipate (projectile)
  :virtual #t
  :code (behavior ()
    (process-spawn
      part-tracker
      :init part-tracker-init
      (-> *part-group-id-table* 104)
      -1
      #f
      #f
      #f
      (-> self root-override root-prim prim-core)
      :to *entity-pool*
      )
    (if (nonzero? (-> self sound-id))
        (sound-stop (-> self sound-id))
        )
    (sound-play "yellow-fizzle")
    (suspend)
    (go-virtual projectile-die)
    (none)
    )
  )

(defmethod projectile-method-27 projectile ((obj projectile))
  0
  (none)
  )

(defmethod projectile-method-26 projectile ((obj projectile))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) projectile-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind projectile))
      (set! (-> s4-0 collide-with) (collide-kind background cak-2 cak-3 crate enemy wall-object ground-object))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 prim-core offense) (collide-offense strong-attack))
      (set-vector! (-> s4-0 local-sphere) 0.0 5324.8 0.0 5324.8)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> s5-0 max-iteration-count) (the-as uint 2))
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

(defmethod projectile-method-25 projectile ((obj projectile))
  (go (method-of-object obj projectile-moving))
  0
  (none)
  )

(defstate projectile-die (projectile)
  :virtual #t
  :code (behavior ()
    (let ((v1-0 (-> self notify-handle)))
      (if (handle->process v1-0)
          (send-event (-> v1-0 process 0) 'notify 'die)
          )
      )
    (cleanup-for-death self)
    (none)
    )
  )

(defmethod deactivate projectile ((obj projectile))
  (if (nonzero? (-> obj sound-id))
      (sound-stop (-> obj sound-id))
      )
  ((method-of-type process-drawable deactivate) obj)
  (none)
  )

(defbehavior projectile-init-by-other projectile ((arg0 entity-actor) (arg1 vector) (arg2 vector) (arg3 uint) (arg4 handle))
  (stack-size-set! (-> self main-thread) 512)
  (set! (-> self entity) arg0)
  (set! (-> self attack-mode) #f)
  (set! (-> self update-velocity) projectile-update-velocity-space-wars)
  (set! (-> self max-speed) 40960.0)
  (set! (-> self max-turn) 18204.445)
  (set! (-> self tween) 1.0)
  (set! (-> self last-target) arg4)
  (set! (-> self timeout) (seconds 4))
  (set! (-> self options) arg3)
  (set! (-> self notify-handle) (the-as handle #f))
  (countdown (v1-4 16)
    (set! (-> self old-dist v1-4) 4095996000.0)
    )
  (projectile-method-26 self)
  (set! (-> self root-override dynam gravity y) 1228800.0)
  (set! (-> self root-override dynam gravity-length) 1228800.0)
  (set! (-> self root-override dynam gravity-max) 1228800.0)
  (set! (-> self root-override trans quad) (-> arg1 quad))
  (set! (-> self base-trans quad) (-> arg1 quad))
  (set! (-> self parent-base quad) (-> arg1 quad))
  (quaternion-copy! (-> self root-override quat) (-> (the-as process-drawable (-> self parent 0)) root quat))
  (quaternion-copy!
    (the-as quaternion (-> self parent-quat))
    (-> (the-as process-drawable (-> self parent 0)) root quat)
    )
  (vector-identity! (-> self root-override scale))
  (set! (-> self root-override transv quad) (-> arg2 quad))
  (vector-normalize-copy! (-> self base-vector) arg2 1.0)
  (vector+float*! (-> self target) (-> self root-override trans) (-> self root-override transv) 2.0)
  (set! (-> self target-base quad) (-> self target quad))
  (projectile-method-27 self)
  (projectile-method-24 self)
  (when (not (type-type? (-> self type) projectile-blue))
    (let ((a1-8 (new 'stack-no-clear 'collide-edge-hold-list)))
      (set! (-> a1-8 num-allocs) (the-as uint 1))
      (set! (-> a1-8 num-attempts) (the-as uint *touching-list*))
      (find-overlapping-shapes (-> self root-override) (the-as overlaps-others-params a1-8))
      )
    )
  (set! (-> self event-hook) (-> (method-of-object self projectile-moving) event))
  (projectile-method-25 self)
  (none)
  )

(defmethod projectile-method-27 projectile-yellow ((obj projectile-yellow))
  (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 204 (seconds 0.1))
  (set! (-> obj attack-mode) 'eco-yellow)
  (set! (-> obj mode) 1)
  (set! (-> obj max-speed) (vector-length (-> obj root-override transv)))
  (set! (-> obj update-velocity) projectile-update-velocity-space-wars)
  (set! (-> obj angle) (vector-y-angle (-> obj root-override transv)))
  (set! (-> obj tween) 0.05)
  (logior! (-> obj options) 2)
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (set! (-> s5-0 quad) (-> obj root-override trans quad))
    (+! (-> obj root-override trans y) -5324.8)
    (vector+float*! (-> obj target) (-> obj root-override trans) (-> obj root-override transv) 2.0)
    (set! (-> obj target-base quad) (-> obj target quad))
    (let ((f30-0 (the float (sar (shl (the int (y-angle (-> obj root-override))) 48) 48))))
      (set! (-> obj mask) (the-as process-mask (logior (process-mask projectile) (-> obj mask))))
      (if (logtest? (-> obj options) 16)
          (set! (-> obj max-hits) 1)
          )
      (set! (-> *part-id-table* 356 init-specs 18 initial-valuef)
            (the float (sar (shl (the int (+ -16384.0 f30-0)) 48) 48))
            )
      (set! (-> *part-id-table* 358 init-specs 11 initial-valuef)
            (the float (sar (shl (the int (+ -16384.0 f30-0)) 48) 48))
            )
      (sound-play "yellow-fire")
      (set! (-> obj sound-id) (sound-play "yellow-buzz"))
      (if (not (logtest? (-> obj options) 416))
          (process-spawn part-tracker :init part-tracker-init (-> *part-group-id-table* 103) -1 #f #f #f s5-0 :to obj)
          )
      (set! (-> *part-id-table* 350 init-specs 2 initial-valuef) f30-0)
      )
    )
  (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 102) obj))
  (when *target*
    (case (-> *target* current-level name)
      (('swamp)
       (set! (-> obj water) (new 'process 'water-control obj 0 0.0 8192.0 2048.0))
       (set! (-> obj water flags) (water-flags wt01 wt04 wt07))
       (set! (-> obj water height) (if (logtest? (-> obj options) 64)
                                       8192.0
                                       10240.0
                                       )
             )
       (logior! (-> obj root-override root-prim collide-with) (collide-kind water))
       )
      (('ogre)
       (when (not (logtest? (-> obj options) 128))
         (set! (-> obj water) (new 'process 'water-control obj 0 0.0 8192.0 2048.0))
         (set! (-> obj water flags) (water-flags wt01 wt04 wt07))
         (set! (-> obj water height) 129024.0)
         (logior! (-> obj root-override root-prim collide-with) (collide-kind water))
         )
       )
      (('finalboss)
       (+! (-> obj root-override trans y) 4096.0)
       (set! (-> obj water) (new 'process 'water-control obj 0 0.0 8192.0 2048.0))
       (set! (-> obj water flags) (water-flags wt01 wt04 wt07))
       (set! (-> obj water height) 1977958.4)
       (logior! (-> obj root-override root-prim collide-with) (collide-kind water))
       )
      )
    )
  0
  (none)
  )

(defmethod projectile-method-26 projectile-yellow ((obj projectile-yellow))
  (let ((t9-0 (method-of-type projectile projectile-method-26)))
    (t9-0 obj)
    )
  (logior! (-> obj root-override root-prim collide-with) (collide-kind mother-spider))
  (none)
  )

(defmethod projectile-method-24 projectile-yellow ((obj projectile-yellow))
  (with-pp
    (find-ground-and-draw-shadow
      (-> obj root-override trans)
      (-> obj root-override shadow-pos)
      8192.0
      (collide-kind background)
      (the-as process-drawable #f)
      12288.0
      81920.0
      )
    (if (< (-> obj root-override trans y) (-> obj root-override shadow-pos y))
        (set! (-> obj root-override trans y) (+ 1228.8 (-> obj root-override shadow-pos y)))
        )
    (update-transforms! (-> obj root-override))
    (set! (-> *part-id-table* 353 init-specs 16 initial-valuef) (the-as float 30))
    (set! (-> *part-id-table* 353 init-specs 16 random-rangef) (the-as float 300))
    (cond
      ((logtest? (-> obj options) 32)
       (when (>= (- (-> *display* base-frame-counter) (-> obj state-time)) (seconds 0.05))
         (when (< (- (-> *display* base-frame-counter) (-> obj state-time)) (seconds 0.5))
           (set! (-> *part-id-table* 353 init-specs 16 initial-valuef) (the-as float 0))
           (set! (-> *part-id-table* 353 init-specs 16 random-rangef) (the-as float 0))
           0
           )
         (spawn (-> obj part) (the-as vector (-> obj root-override root-prim prim-core)))
         )
       )
      (else
        (spawn (-> obj part) (the-as vector (-> obj root-override root-prim prim-core)))
        )
      )
    (let ((s5-0 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> s5-0 command) (sound-command set-param))
      (set! (-> s5-0 id) (-> obj sound-id))
      (let ((a1-3 (-> obj root-override trans)))
        (let ((gp-1 pp))
          (when (= a1-3 #t)
            (if (and gp-1 (type-type? (-> gp-1 type) process-drawable) (nonzero? (-> (the-as process-drawable gp-1) root)))
                (set! a1-3 (-> (the-as process-drawable gp-1) root trans))
                (set! a1-3 (the-as vector #f))
                )
            )
          )
        (sound-trans-convert (-> s5-0 parms trans) a1-3)
        )
      (set! (-> s5-0 parms mask) (sound-mask trans))
      (-> s5-0 id)
      )
    0
    (none)
    )
  )

(defmethod projectile-method-28 projectile-yellow ((obj projectile-yellow))
  (cond
    ((or (not (handle->process (-> obj last-target)))
         (zero? (-> (the-as target (handle->process (-> obj last-target))) control root-prim prim-core collide-as))
         )
     (cond
       ((zero? (-> obj target-count))
        (let ((s5-0 (find-nearest-attackable
                      (-> obj parent-base)
                      409600.0
                      (the-as uint 0)
                      (the-as uint 0)
                      (-> obj base-vector)
                      (if (logtest? (-> obj options) 160)
                          546.13336
                          8192.0
                          )
                      )
                    )
              )
          (let ((s4-0 (find-nearest-attackable
                        (-> obj parent-base)
                        163840.0
                        (the-as uint 1)
                        (the-as uint 0)
                        (-> obj base-vector)
                        (if (logtest? (-> obj options) 160)
                            910.2222
                            8192.0
                            )
                        )
                      )
                (v1-10 (find-nearest-attackable
                         (-> obj parent-base)
                         28672.0
                         (the-as uint 1)
                         (the-as uint 0)
                         (-> obj base-vector)
                         16384.0
                         )
                       )
                )
            (if s4-0
                (set! s5-0 s4-0)
                )
            (if v1-10
                (set! s5-0 v1-10)
                )
            )
          (set! (-> obj last-target) (process->handle s5-0))
          (when s5-0
            (set! (-> obj target quad) (-> s5-0 root-override root-prim prim-core world-sphere quad))
            (if (= (-> s5-0 type symbol) 'mother-spider)
                (logand! (-> obj options) -2)
                )
            )
          )
        )
       (else
         (set! (-> obj target quad) (-> obj target-base quad))
         )
       )
     )
    (else
      (let ((a1-8 (handle->process (-> obj last-target))))
        (set! (-> obj target quad) (-> (the-as target a1-8) control root-prim prim-core world-sphere quad))
        )
      (if (and (< (vector-vector-xz-distance (-> obj root-override trans) (-> obj target)) 20480.0)
               (< 24576.0 (fabs (- (-> obj target y) (-> obj root-override trans y))))
               )
          (set! (-> obj last-target) (the-as handle #f))
          )
      )
    )
  (+! (-> obj target-count) 1)
  0
  (none)
  )

(defmethod projectile-method-27 projectile-blue ((obj projectile-blue))
  (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 204 (seconds 0.1))
  (sound-play "blue-eco-on")
  (set! (-> obj mode) 2)
  (set! (-> obj max-speed) (-> *TARGET-bank* yellow-projectile-speed))
  (set! (-> obj update-velocity) projectile-update-velocity-space-wars)
  (+! (-> obj root-override trans y) -5324.8)
  (vector+float*! (-> obj target) (-> obj root-override trans) (-> obj root-override transv) 2.0)
  (set! (-> obj target-base quad) (-> obj target quad))
  (set! (-> obj mask) (the-as process-mask (logior (process-mask ambient) (-> obj mask))))
  (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 42) obj))
  (set! (-> obj root-override root-prim collide-with) (collide-kind background))
  (let* ((s5-1 (handle->process (-> obj last-target)))
         (v1-20 (if (and (nonzero? s5-1) (type-type? (-> s5-1 type) process-drawable))
                    s5-1
                    )
                )
         )
    (if v1-20
        (set! (-> obj joint-num) (rand-vu-int-range 3 (+ (-> (the-as process-drawable v1-20) node-list length) -1)))
        )
    )
  0
  (none)
  )

(defmethod projectile-method-26 projectile-blue ((obj projectile-blue))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) projectile-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind projectile))
      (set! (-> s4-0 collide-with) (collide-kind background))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 prim-core offense) (collide-offense strong-attack))
      (set-vector! (-> s4-0 local-sphere) 0.0 5324.8 0.0 5324.8)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> s5-0 max-iteration-count) (the-as uint 2))
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

(defun spawn-projectile-blue ((arg0 target))
  (local-vars (sv-48 entity-actor))
  (with-pp
    (when arg0
      (let ((s3-0 (rand-vu-int-range 3 (+ (-> arg0 node-list length) -1)))
            (gp-0 (new-stack-vector0))
            )
        (set-vector!
          gp-0
          (rand-vu-float-range -81920.0 81920.0)
          (rand-vu-float-range -81920.0 81920.0)
          (rand-vu-float-range -81920.0 81920.0)
          1.0
          )
        (let ((s4-1 (get-process *default-dead-pool* projectile-blue #x4000)))
          (when s4-1
            (let ((t9-5 (method-of-type projectile-blue activate)))
              (t9-5 (the-as projectile-blue s4-1) pp 'projectile-blue (the-as pointer #x70004000))
              )
            (let ((s2-0 run-function-in-process)
                  (s1-0 s4-1)
                  (s0-0 projectile-init-by-other)
                  )
              (set! sv-48 (-> pp entity))
              (let ((a3-1 (vector<-cspace! (new 'stack-no-clear 'vector) (-> arg0 node-list data s3-0)))
                    (t1-0 8)
                    (t2-0 (process->handle pp))
                    )
                ((the-as (function process function object object object object object object) s2-0)
                 s1-0
                 s0-0
                 sv-48
                 a3-1
                 gp-0
                 t1-0
                 t2-0
                 )
                )
              )
            (-> s4-1 ppointer)
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod projectile-method-28 projectile-blue ((obj projectile-blue))
  (let* ((s5-0 (handle->process (-> obj last-target)))
         (v1-4 (if (and (nonzero? s5-0) (type-type? (-> s5-0 type) process-drawable))
                   s5-0
                   )
               )
         )
    (if v1-4
        (vector<-cspace! (-> obj target) (-> (the-as process-drawable v1-4) node-list data (-> obj joint-num)))
        )
    )
  (if (< (vector-vector-distance (-> obj target) (-> obj root-override trans)) 4096.0)
      (go (method-of-object obj projectile-impact))
      )
  0
  (none)
  )

(defmethod projectile-method-24 projectile-blue ((obj projectile-blue))
  (if (rand-vu-percent? 0.75)
      (eco-blue-glow (the-as vector (-> obj root-override root-prim prim-core)))
      )
  0
  (none)
  )

(defstate projectile-impact (projectile-blue)
  :virtual #t
  :code (behavior ()
    (cleanup-for-death self)
    (none)
    )
  )

(defstate projectile-dissipate (projectile-blue)
  :virtual #t
  :code (behavior ()
    (go-virtual projectile-die)
    (none)
    )
  )
