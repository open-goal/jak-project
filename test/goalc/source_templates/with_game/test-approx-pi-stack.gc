;; like test-approx-pi, but using stack variables
(start-test "approx-pi-stack")

(defun test-approx-pi-stack ((res integer))
  (let ((rad (new 'stack-no-clear 'array 'int32 1))
        (count (new 'stack-no-clear 'array 'uint32 1)))
    (set! (-> rad) (* res res))
    (set! (-> count) 0)
        
    
    (dotimes (x res)
      (dotimes (y res)
        (if (> (-> rad) (+ (* x x) (* y y)))
            (+! (-> count) 1)
            )
        )
      )
    (* 4.0 (/ (the float (-> count)) (the float (-> rad))))
    )
  )

(let ((approx-pi (test-approx-pi-stack 1000)))
  (expect-true (> approx-pi 3.14))
  (expect-true (< approx-pi 3.15))
  )


(defun test-approx-pi-float-stack ((res float))
  (let* ((rad (new 'stack-no-clear 'array 'float 1))
         (count (new 'stack-no-clear 'array 'float 1))
         (x (new 'stack-no-clear 'array 'float 1))
         (y (new 'stack-no-clear 'array 'float 1))
         (scale (new 'stack-no-clear 'array 'float 1)))
    (set! (-> rad) (* res res))
    (set! (-> count) 0.0)
    (set! (-> x) 0.0)
    (set! (-> y) (-> x))
    (set! (-> scale) (/ 1.0 (-> rad)))
    
    (while (< (-> x) res)
      (set! (-> y) 0.0)
      (while (< (-> y) res)
        (if (> (-> rad) (+ (* (-> x) (-> x)) (* (-> y) (-> y))))
            (+! (-> count) (-> scale))
            )
        (+! (-> y) 1.0)
        )
      (+! (-> x) 1.0)
      )
    (* 4.0 (-> count))
    )
  )

(let ((approx-pi (test-approx-pi-float-stack 500.0)))
  (expect-true (> approx-pi 3.14))
  (expect-true (< approx-pi 3.15))
  )

(finish-test)
