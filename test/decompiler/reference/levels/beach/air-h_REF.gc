;;-*-Lisp-*-
(in-package goal)

;; definition of type air-box
(deftype air-box (structure)
  ((vecs         vector 2 :inline   :offset-assert 0)
   (x-pos        float  :offset   0)
   (height-level float  :offset   4)
   (z-pos        float  :offset   8)
   (cos-angle    float  :offset  12)
   (x-length     float  :offset  16)
   (z-length     float  :offset  24)
   (sin-angle    float  :offset  28)
   )
  :method-count-assert 9
  :size-assert         #x20
  :flag-assert         #x900000020
  )

;; definition for method 3 of type air-box
(defmethod inspect air-box ((obj air-box))
  (format #t "[~8x] ~A~%" obj 'air-box)
  (format #t "~Tvecs[2] @ #x~X~%" (-> obj vecs))
  (format #t "~Tx-pos: ~f~%" (the-as float (-> obj vecs 0 x)))
  (format #t "~Theight-level: ~f~%" (the-as float (-> obj vecs 0 y)))
  (format #t "~Tz-pos: ~f~%" (the-as float (-> obj vecs 0 z)))
  (format #t "~Tcos-angle: ~f~%" (-> obj vecs 0 w))
  (format #t "~Tx-length: ~f~%" (-> obj vecs 1 x))
  (format #t "~Tz-length: ~f~%" (-> obj vecs 1 z))
  (format #t "~Tsin-angle: ~f~%" (-> obj vecs 1 w))
  obj
  )

;; definition for function point-in-air-box-area?
(defun point-in-air-box-area? ((arg0 float) (arg1 float) (arg2 air-box))
  (let ((v0-0 #f))
   (let ((f0-2 (+ (* arg0 (-> arg2 vecs 0 w)) (* arg1 (-> arg2 vecs 1 w))))
         (f1-5 (- (* arg1 (-> arg2 vecs 0 w)) (* arg0 (-> arg2 vecs 1 w))))
         )
    (if
     (and
      (>= f0-2 0.0)
      (>= f1-5 0.0)
      (< f0-2 (-> arg2 vecs 1 x))
      (< f1-5 (-> arg2 vecs 1 z))
      )
     (set! v0-0 #t)
     )
    )
   v0-0
   )
  )

;; definition for function point-in-air-box?
(defun point-in-air-box? ((arg0 vector) (arg1 air-box))
  (when (< (-> arg1 vecs 0 y) (-> arg0 y))
   (let ((f1-2 (- (-> arg0 x) (the-as float (-> arg1 vecs 0 x))))
         (f2-1 (- (-> arg0 z) (-> arg1 vecs 0 z)))
         (v1-0 arg1)
         (v0-0 #f)
         )
    (let ((f0-5 (+ (* f1-2 (-> v1-0 vecs 0 w)) (* f2-1 (-> v1-0 vecs 1 w))))
          (f1-4 (- (* f2-1 (-> v1-0 vecs 0 w)) (* f1-2 (-> v1-0 vecs 1 w))))
          )
     (if
      (and
       (>= f0-5 0.0)
       (>= f1-4 0.0)
       (< f0-5 (-> v1-0 vecs 1 x))
       (< f1-4 (-> v1-0 vecs 1 z))
       )
      (set! v0-0 #t)
      )
     )
    v0-0
    )
   )
  )

;; failed to figure out what this is:
(let ((v0-2 0))
  )




