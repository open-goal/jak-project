;;-*-Lisp-*-
(in-package goal)

;; definition of type pelican-bank
(deftype pelican-bank (basic)
  ((circle-speed        meters   :offset-assert   4)
   (dive-time           seconds  :offset-assert   8)
   (to-nest0-time       seconds  :offset-assert  16)
   (to-nest1-time       seconds  :offset-assert  24)
   (land-time           seconds  :offset-assert  32)
   (from-nest-time      seconds  :offset-assert  40)
   (spit-time           seconds  :offset-assert  48)
   (pre-spit-wait-time  seconds  :offset-assert  56)
   (post-spit-wait-time seconds  :offset-assert  64)
   (run-away-time       seconds  :offset-assert  72)
   )
  :method-count-assert 9
  :size-assert         #x50
  :flag-assert         #x900000050
  )

;; definition for method 3 of type pelican-bank
(defmethod inspect pelican-bank ((obj pelican-bank))
  (format #t "[~8x] ~A~%" obj (-> obj type))
  (format #t "~Tcircle-speed: (meters ~m)~%" (-> obj circle-speed))
  (format #t "~Tdive-time: (seconds ~e)~%" (-> obj dive-time))
  (format #t "~Tto-nest0-time: (seconds ~e)~%" (-> obj to-nest0-time))
  (format #t "~Tto-nest1-time: (seconds ~e)~%" (-> obj to-nest1-time))
  (format #t "~Tland-time: (seconds ~e)~%" (-> obj land-time))
  (format #t "~Tfrom-nest-time: (seconds ~e)~%" (-> obj from-nest-time))
  (format #t "~Tspit-time: (seconds ~e)~%" (-> obj spit-time))
  (format #t "~Tpre-spit-wait-time: (seconds ~e)~%" (-> obj pre-spit-wait-time))
  (format #t "~Tpost-spit-wait-time: (seconds ~e)~%" (-> obj post-spit-wait-time))
  (format #t "~Trun-away-time: (seconds ~e)~%" (-> obj run-away-time))
  obj
  )

;; definition for symbol *PELICAN-bank*, type pelican-bank
(define *PELICAN-bank* (new 'static 'pelican-bank
                         :circle-speed (meters 16.0)
                         :dive-time (seconds 2)
                         :to-nest0-time (seconds 4)
                         :to-nest1-time (seconds 8)
                         :land-time (seconds 2.4)
                         :from-nest-time (seconds 20)
                         :spit-time (seconds 1)
                         :pre-spit-wait-time (seconds 0.5)
                         :post-spit-wait-time (seconds 1.5)
                         :run-away-time (seconds 10)
                         )
        )

;; definition of type pelican
(deftype pelican (process-drawable)
  ((root-override   collide-shape-moving         :offset        112)
   (query           gui-query            :inline :offset-assert 176)
   (fuel-cell       handle                       :offset-assert 208)
   (cam-tracker     handle                       :offset-assert 216)
   (path-data       curve-control        8       :offset-assert 224)
   (path-circle     curve-control                :offset        224)
   (path-dive0      curve-control                :offset        228)
   (path-to-nest0   curve-control                :offset        232)
   (path-from-nest0 curve-control                :offset        236)
   (path-spit0      curve-control                :offset        240)
   (path-dive1      curve-control                :offset        244)
   (path-to-nest1   curve-control                :offset        248)
   (path-to-nest2   curve-control                :offset        252)
   (path-cache      curve-control                :offset-assert 256)
   (time-cache      uint64                       :offset-assert 264)
   (path-pos        float                        :offset-assert 272)
   (path-speed      float                        :offset-assert 276)
   (path-max        float                        :offset-assert 280)
   (path-vector     vector               :inline :offset-assert 288)
   (state-vector    vector               :inline :offset-assert 304)
   (state-vector1   vector               :inline :offset-assert 320)
   (state-float     float                2       :offset-assert 336)
   (state-object    symbol                       :offset-assert 344)
   (neck            joint-mod                    :offset-assert 348)
   )
  :heap-base #xf0
  :method-count-assert 20
  :size-assert         #x160
  :flag-assert         #x1400f00160
  (:states
    pelican-circle
    (pelican-dive path-control curve-control uint)
    (pelican-explode symbol)
    (pelican-fly-to-end path-control int)
    pelican-from-nest
    pelican-spit
    (pelican-to-nest path-control int)
    (pelican-wait-at-end symbol)
    (pelican-wait-at-nest symbol)
    )
  )

;; definition for method 3 of type pelican
(defmethod inspect pelican ((obj pelican))
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 obj)
    )
  (format #t "~T~Tquery: #<gui-query @ #x~X>~%" (-> obj query))
  (format #t "~T~Tfuel-cell: ~D~%" (-> obj fuel-cell))
  (format #t "~T~Tcam-tracker: ~D~%" (-> obj cam-tracker))
  (format #t "~T~Tpath-data[8] @ #x~X~%" (-> obj path-data))
  (format #t "~T~Tpath-circle: ~A~%" (-> obj path-circle))
  (format #t "~T~Tpath-dive0: ~A~%" (-> obj path-dive0))
  (format #t "~T~Tpath-to-nest0: ~A~%" (-> obj path-to-nest0))
  (format #t "~T~Tpath-from-nest0: ~A~%" (-> obj path-from-nest0))
  (format #t "~T~Tpath-spit0: ~A~%" (-> obj path-spit0))
  (format #t "~T~Tpath-dive1: ~A~%" (-> obj path-dive1))
  (format #t "~T~Tpath-to-nest1: ~A~%" (-> obj path-to-nest1))
  (format #t "~T~Tpath-to-nest2: ~A~%" (-> obj path-to-nest2))
  (format #t "~T~Tpath-cache: ~A~%" (-> obj path-cache))
  (format #t "~T~Ttime-cache: ~D~%" (-> obj time-cache))
  (format #t "~T~Tpath-pos: ~f~%" (-> obj path-pos))
  (format #t "~T~Tpath-speed: ~f~%" (-> obj path-speed))
  (format #t "~T~Tpath-max: ~f~%" (-> obj path-max))
  (format #t "~T~Tpath-vector: ~`vector`P~%" (-> obj path-vector))
  (format #t "~T~Tstate-vector: ~`vector`P~%" (-> obj state-vector))
  (format #t "~T~Tstate-vector1: ~`vector`P~%" (-> obj state-vector1))
  (format #t "~T~Tstate-float[2] @ #x~X~%" (-> obj state-float))
  (format #t "~T~Tstate-object: ~A~%" (-> obj state-object))
  (format #t "~T~Tneck: ~A~%" (-> obj neck))
  obj
  )

;; definition for method 7 of type pelican
;; INFO: Return type mismatch process-drawable vs pelican.
(defmethod relocate pelican ((obj pelican) (arg0 int))
  (countdown (v1-0 8)
    (if (nonzero? (-> obj path-data v1-0))
        (&+! (-> obj path-data v1-0) arg0)
        )
    )
  (if (nonzero? (-> obj path-cache))
      (&+! (-> obj path-cache) arg0)
      )
  (if (nonzero? (-> obj neck))
      (&+! (-> obj neck) arg0)
      )
  (the-as
    pelican
    ((the-as (function process-drawable int process-drawable) (find-parent-method pelican 7)) obj arg0)
    )
  )

;; failed to figure out what this is:
(defskelgroup *pelican-sg* pelican
  0
  5
  ((1 (meters 20)) (2 (meters 40)) (3 (meters 999999)))
  :bounds (static-spherem 0 3 0 5)
  :longest-edge (meters 0)
  :shadow 4
  )

;; definition for function pelican-path-update
(defbehavior pelican-path-update pelican ((arg0 float) (arg1 int) (arg2 float) (arg3 float) (arg4 symbol))
  (TODO-RENAME-9 (-> self align))
  (let ((s3-0 (new 'stack-no-clear 'vector)))
    (let* ((f0-1 (+ (-> self path-pos) (* (-> self align align trans z) arg3)))
           (f1-2 (-> self path-max))
           (f30-0 (- f0-1 (* (the float (the int (/ f0-1 f1-2))) f1-2)))
           )
      (eval-path-curve-div! (-> self path) s3-0 f30-0 'interp)
      (+! (-> s3-0 y) (-> self align align trans y))
      (TODO-RENAME-30 (-> self root-override) s3-0)
      (TODO-RENAME-12 (-> self path) s3-0 f30-0)
      )
    (if arg4
        (set-heading-vec-clear-roll-pitch! (-> self root-override) s3-0)
        (seek-toward-heading-vec! (-> self root-override) s3-0 arg0 arg1)
        )
    )
  )

;; definition for function pelican-fly
(defbehavior pelican-fly pelican ((arg0 (function pelican int)) (arg1 (function pelican int)))
  (while #t
    (cond
      ((= (if (> (-> self skel active-channels) 0)
              (-> self skel root-channel 0 frame-group)
              )
          (-> self draw art-group data 5)
          )
       (let ((a0-5 (-> self skel root-channel 0)))
         (set! (-> a0-5 param 0) (the float (+ (-> a0-5 frame-group data 0 length) -1)))
         (set! (-> a0-5 param 1) 1.0)
         (joint-control-channel-group! a0-5 (the-as art-joint-anim #f) num-func-seek!)
         )
       (while (not (ja-done? 0))
         (suspend)
         (ja-eval)
         )
       )
      (else
        (ja-channel-push! 1 75)
        )
      )
    (let ((s4-0 (arg0 self)))
      (dotimes (s3-0 s4-0)
        (let ((a0-9 (-> self skel root-channel 0)))
          (set! (-> a0-9 frame-group) (the-as art-joint-anim (-> self draw art-group data 5)))
          (set! (-> a0-9 param 0)
                (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 5)) data 0 length) -1))
                )
          (set! (-> a0-9 param 1) 1.0)
          (set! (-> a0-9 frame-num) 0.0)
          (joint-control-channel-group! a0-9 (the-as art-joint-anim (-> self draw art-group data 5)) num-func-seek!)
          )
        (until (ja-done? 0)
          (ja-blend-eval)
          (suspend)
          (let ((a0-10 (-> self skel root-channel 0)))
            (set! (-> a0-10 param 0) (the float (+ (-> a0-10 frame-group data 0 length) -1)))
            (set! (-> a0-10 param 1) 1.0)
            (joint-control-channel-group-eval! a0-10 (the-as art-joint-anim #f) num-func-seek!)
            )
          )
        )
      )
    (let ((s4-1 (arg1 self)))
      (when (> s4-1 0)
        (let ((s3-1 (-> self skel root-channel 0)))
          (set! (-> s3-1 frame-group) (the-as art-joint-anim (-> self draw art-group data 5)))
          (set! (-> s3-1 param 0) (ja-aframe 12.0 0))
          (set! (-> s3-1 param 1) 1.0)
          (set! (-> s3-1 frame-num) 0.0)
          (joint-control-channel-group! s3-1 (the-as art-joint-anim (-> self draw art-group data 5)) num-func-seek!)
          )
        (until (ja-done? 0)
          (suspend)
          (let ((s3-2 (-> self skel root-channel 0)))
            (set! (-> s3-2 param 0) (ja-aframe 12.0 0))
            (set! (-> s3-2 param 1) 1.0)
            (joint-control-channel-group-eval! s3-2 (the-as art-joint-anim #f) num-func-seek!)
            )
          )
        (let ((a0-18 (-> self skel root-channel 0)))
          (set! (-> a0-18 param 0) 0.25)
          (joint-control-channel-group! a0-18 (the-as art-joint-anim #f) num-func-loop!)
          )
        (ja-channel-push! 1 300)
        (dotimes (s3-3 s4-1)
          (let ((a0-20 (-> self skel root-channel 0)))
            (set! (-> a0-20 frame-group) (the-as art-joint-anim (-> self draw art-group data 6)))
            (set! (-> a0-20 param 0)
                  (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 6)) data 0 length) -1))
                  )
            (set! (-> a0-20 param 1) 1.0)
            (set! (-> a0-20 frame-num) 0.0)
            (joint-control-channel-group! a0-20 (the-as art-joint-anim (-> self draw art-group data 6)) num-func-seek!)
            )
          (until (ja-done? 0)
            (ja-blend-eval)
            (suspend)
            (let ((a0-21 (-> self skel root-channel 0)))
              (set! (-> a0-21 param 0) (the float (+ (-> a0-21 frame-group data 0 length) -1)))
              (set! (-> a0-21 param 1) 1.0)
              (joint-control-channel-group-eval! a0-21 (the-as art-joint-anim #f) num-func-seek!)
              )
            )
          )
        (let ((a0-23 (-> self skel root-channel 0)))
          (set! (-> a0-23 param 0) 1.0)
          (joint-control-channel-group! a0-23 (the-as art-joint-anim #f) num-func-loop!)
          )
        )
      )
    )
  (none)
  )

;; definition for function pelican-post
(defbehavior pelican-post pelican ()
  (ja-post)
  (none)
  )

;; failed to figure out what this is:
(defstate pelican-circle (pelican)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (let ((v1-0 arg2))
      (the-as
        object
        (cond
          ((= v1-0 'dive)
           (let ((v0-0 (the-as structure #t)))
             (set! (-> self state-object) (the-as symbol v0-0))
             v0-0
             )
           )
          ((= v1-0 'fuel-cell)
           (handle->process (-> self fuel-cell))
           )
          ((= v1-0 'position)
           (set! (-> self path-pos) (the-as float (-> arg3 param 0)))
           (let ((a1-3 (TODO-RENAME-12 (-> self path) (new 'stack-no-clear 'vector) (-> self path-pos))))
             (set-heading-vec! (-> self root-override) a1-3)
             )
           )
          )
        )
      )
    )
  :enter
  (behavior ()
    (while (-> self child)
      (deactivate (-> self child 0))
      )
    (set! (-> self state-object) #f)
    (let ((gp-0 (-> self path-vector)))
      (eval-path-curve-div! (-> self path-dive0) gp-0 4.5 'interp)
      (set! (-> gp-0 y) (+ -4505.6 (-> gp-0 y)))
      (let* ((s5-0 (get-process *default-dead-pool* manipy #x4000))
             (v1-8
               (when s5-0
                 (let ((t9-3 (method-of-type manipy activate)))
                   (t9-3 (the-as manipy s5-0) self 'manipy (the-as pointer #x70004000))
                   )
                 (run-now-in-process s5-0 manipy-init gp-0 (-> self entity) *fuel-cell-sg* (new 'static 'vector :w 4915.2))
                 (-> s5-0 ppointer)
                 )
               )
             )
        (set! (-> self fuel-cell) (ppointer->handle v1-8))
        (if v1-8
            (send-event
              (ppointer->process v1-8)
              'eval
              (lambda :behavior pelican () (let ((v0-0 (create-launch-control (-> *part-group-id-table* 63) self)))
                                             (set! (-> self part) v0-0)
                                             v0-0
                                             )
                                        )
              )
            )
        )
      )
    (set! (-> self path) (-> self path-circle))
    (set! (-> self path-pos) 0.0)
    (set! (-> self path-max) (the float (+ (-> self path curve num-cverts) -1)))
    (set! (-> self path-speed)
          (/ (* (-> *PELICAN-bank* circle-speed) (-> self path-max)) (path-distance (-> self path)))
          )
    (set-roll-to-grav-2! (-> self root-override) -2730.6667)
    (none)
    )
  :trans
  (behavior ()
    (pelican-path-update 728177.75 30 1.0 (/ (-> self path-max) (path-distance (-> self path))) #f)
    (let ((f0-3 (+ (-> self path-pos) (* (-> self path-speed) (-> *display* seconds-per-frame))))
          (f1-2 (-> self path-max))
          )
      (set! (-> self path-pos) (- f0-3 (* (the float (the int (/ f0-3 f1-2))) f1-2)))
      )
    (when (and (and *target* (>= 81920.0 (vector-vector-xz-distance (-> self path-vector) (-> *target* control trans))))
               (not (handle->process (-> self cam-tracker)))
               )
      (let ((gp-1 (get-process *default-dead-pool* camera-tracker #x4000)))
        (set! (-> self cam-tracker)
              (ppointer->handle (when gp-1
                                  (let ((t9-4 (method-of-type camera-tracker activate)))
                                    (t9-4 (the-as camera-tracker gp-1) self 'camera-tracker (the-as pointer #x70004000))
                                    )
                                  (run-now-in-process
                                    gp-1
                                    camera-tracker-init
                                    (lambda :behavior camera-tracker
                                      ()
                                      (local-vars
                                        (a0-6 process-tree)
                                        (a1-5 event-message-block)
                                        (t9-6 (function process-tree event-message-block object))
                                        )
                                      (while (not (process-grab? *target*))
                                        (suspend)
                                        )
                                      (send-event (ppointer->process (-> self parent)) 'position 4.0)
                                      (send-event (ppointer->process (-> self parent)) 'dive)
                                      (suspend)
                                      (suspend)
                                      (send-event *camera* 'blend-from-as-fixed)
                                      (camera-look-at (the-as pair (ppointer->process (-> self parent))) (the-as uint 0))
                                      (camera-change-to "camera-215" 0 #f)
                                      (until (t9-6 a0-6 a1-5)
                                        (suspend)
                                        (set! a1-5 (new 'stack-no-clear 'event-message-block))
                                        (set! (-> a1-5 from) self)
                                        (set! (-> a1-5 num-params) 0)
                                        (set! (-> a1-5 message) 'got-cell?)
                                        (set! t9-6 send-event-function)
                                        (set! a0-6 (ppointer->process (-> self parent)))
                                        )
                                      (send-event *camera* 'point-of-interest #f)
                                      (while (!= (-> self message) 'release)
                                        (suspend)
                                        )
                                      (set! (-> self message) #f)
                                      (while (not (process-release? (handle->process (-> self grab-target))))
                                        (suspend)
                                        )
                                      (send-event *camera* 'blend-from-as-fixed)
                                      (camera-look-at (the-as pair *target*) (the-as uint 0))
                                      (camera-change-to (the-as string 'base) 150 #f)
                                      (none)
                                      )
                                    )
                                  (-> gp-1 ppointer)
                                  )
                                )
              )
        )
      (set! (-> self draw force-lod) 0)
      0
      )
    (when (and (-> self state-object) (>= (-> self path-pos) 6.0) (< (-> self path-pos) 7.0))
      (let ((v1-24 (-> self entity extra perm)))
        (logior! (-> v1-24 status) (entity-perm-status user-set-from-cstage))
        (set! (-> v1-24 user-int8 0) 2)
        )
      (go pelican-dive (-> self path-dive0) (-> self path-to-nest0) (the-as uint (-> *PELICAN-bank* to-nest0-time)))
      )
    (none)
    )
  :code
  (behavior ()
    (suspend)
    (send-event (-> self fuel-cell process 0) 'trans-hook fuel-cell-animate)
    (pelican-fly
      (the-as (function pelican int) (lambda () (rand-vu-int-range 2 4)))
      (the-as (function pelican int) (lambda () (rand-vu-int-range 3 5)))
      )
    (none)
    )
  :post
  pelican-post
  )

;; failed to figure out what this is:
(defstate pelican-dive (pelican)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (let ((v1-0 arg2))
      (the-as object (cond
                       ((= v1-0 'got-cell?)
                        (-> self state-object)
                        )
                       ((= v1-0 'fuel-cell)
                        (handle->process (-> self fuel-cell))
                        )
                       )
              )
      )
    )
  :enter
  (behavior ((arg0 path-control) (arg1 curve-control) (arg2 uint))
    (init! (-> self query) (the-as string #f) 40 150 25 #t (the-as string #f))
    (set! (-> self state-object) #f)
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (set-roll-to-grav-2! (-> self root-override) 0.0)
    (let ((a0-4 (handle->process (-> self fuel-cell))))
      (cond
        (a0-4
          (send-event a0-4 'trans-hook fuel-cell-animate)
          )
        (else
          )
        )
      )
    (set! (-> self path-cache) arg1)
    (set! (-> self time-cache) arg2)
    (set! (-> self path) arg0)
    (set! (-> self path-pos) 0.0)
    (set! (-> self path-max) (the float (+ (-> self path curve num-cverts) -1)))
    (set! (-> self path-speed) (/ (* 300.0 (-> self path-max)) (the float (-> *PELICAN-bank* dive-time))))
    (let ((gp-1 (new 'stack-no-clear 'vector)))
      (TODO-RENAME-12 (-> self path) gp-1 (-> self path-pos))
      (set-heading-vec! (-> self root-override) gp-1)
      )
    (set! (-> self draw force-lod) 0)
    0
    (none)
    )
  :exit
  (behavior ()
    (set! (-> self draw force-lod) -1)
    (none)
    )
  :trans
  (behavior ()
    (if (not (handle->process (-> self fuel-cell)))
        (go pelican-fly-to-end (-> self path-to-nest2) (the-as int (-> *PELICAN-bank* run-away-time)))
        )
    (pelican-path-update 364088.88 30 0.0 0.0 #t)
    (set! (-> self path-pos)
          (seek (-> self path-pos) (-> self path-max) (* (-> self path-speed) (-> *display* seconds-per-frame)))
          )
    (if (= (-> self path-pos) (-> self path-max))
        (go pelican-to-nest (-> self path-cache) (the-as int (-> self time-cache)))
        )
    (none)
    )
  :code
  (behavior ((arg0 path-control) (arg1 curve-control) (arg2 uint))
    (ja-channel-push! 1 60)
    (let ((gp-0 (-> self skel root-channel 0)))
      (set! (-> gp-0 frame-group) (the-as art-joint-anim (-> self draw art-group data 7)))
      (set! (-> gp-0 param 0) (ja-aframe 48.0 0))
      (set! (-> gp-0 param 1) 0.5)
      (set! (-> gp-0 frame-num) 0.0)
      (joint-control-channel-group! gp-0 (the-as art-joint-anim (-> self draw art-group data 7)) num-func-seek!)
      )
    (until (ja-done? 0)
      (ja-blend-eval)
      (let ((gp-1 (handle->process (-> self fuel-cell))))
        (when (and gp-1 (>= (-> self path-pos) 3.8) (let ((a1-5 (new 'stack-no-clear 'event-message-block)))
                                                      (set! (-> a1-5 from) self)
                                                      (set! (-> a1-5 num-params) 1)
                                                      (set! (-> a1-5 message) 'query)
                                                      (set! (-> a1-5 param 0) (the-as uint 'grab))
                                                      (not (send-event-function gp-1 a1-5))
                                                      )
                   )
          (level-hint-spawn (game-text-id zero) (the-as string #f) (-> self entity) *entity-pool* (game-task none))
          (send-event gp-1 'grab self)
          (send-event gp-1 'draw #f)
          (send-event gp-1 'event-hook #f)
          (set! (-> self state-object) #t)
          )
        )
      (suspend)
      (let ((gp-2 (-> self skel root-channel 0)))
        (set! (-> gp-2 param 0) (ja-aframe 48.0 0))
        (set! (-> gp-2 param 1) 0.5)
        (joint-control-channel-group-eval! gp-2 (the-as art-joint-anim #f) num-func-seek!)
        )
      )
    (let ((a0-15 (-> self skel root-channel 0)))
      (set! (-> a0-15 param 0) (the float (+ (-> a0-15 frame-group data 0 length) -1)))
      (set! (-> a0-15 param 1) 1.0)
      (joint-control-channel-group! a0-15 (the-as art-joint-anim #f) num-func-seek!)
      )
    (ja-channel-push! 1 60)
    (let ((a0-17 (-> self skel root-channel 0)))
      (set! (-> a0-17 frame-group) (the-as art-joint-anim (-> self draw art-group data 5)))
      (set! (-> a0-17 param 0)
            (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 5)) data 0 length) -1))
            )
      (set! (-> a0-17 param 1) 1.0)
      (set! (-> a0-17 frame-num) 0.0)
      (joint-control-channel-group! a0-17 (the-as art-joint-anim (-> self draw art-group data 5)) num-func-seek!)
      )
    (until (ja-done? 0)
      (suspend)
      (let ((a0-18 (-> self skel root-channel 0)))
        (set! (-> a0-18 param 0) (the float (+ (-> a0-18 frame-group data 0 length) -1)))
        (set! (-> a0-18 param 1) 1.0)
        (joint-control-channel-group-eval! a0-18 (the-as art-joint-anim #f) num-func-seek!)
        )
      )
    (anim-loop)
    (none)
    )
  :post
  pelican-post
  )

;; failed to figure out what this is:
(defstate pelican-to-nest (pelican)
  :enter
  (behavior ((arg0 path-control) (arg1 int))
    (set! (-> self path) arg0)
    (set! (-> self path-pos) 0.0)
    (set! (-> self path-max) (the float (+ (-> self path curve num-cverts) -1)))
    (set! (-> self path-speed) (/ (* 300.0 (-> self path-max)) (the float arg1)))
    (none)
    )
  :trans
  (behavior ()
    (pelican-path-update 546133.3 30 0.0 0.0 #f)
    (set! (-> self path-pos)
          (seek (-> self path-pos) (-> self path-max) (* (-> self path-speed) (-> *display* seconds-per-frame)))
          )
    (if (= (-> self path-pos) (-> self path-max))
        (go pelican-wait-at-nest #f)
        )
    (none)
    )
  :code
  (behavior ((arg0 path-control) (arg1 int))
    (pelican-fly
      (the-as (function pelican int) (lambda () 1))
      (lambda ((arg0 pelican)) (if (and (>= (-> arg0 path-pos) 4.0) (>= 6.0 (-> arg0 path-pos)))
                                   1
                                   0
                                   )
              )
      )
    (none)
    )
  :post
  pelican-post
  )

;; failed to figure out what this is:
(defstate pelican-wait-at-nest (pelican)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (let ((v1-0 arg2))
      (the-as
        object
        (cond
          ((= v1-0 'attack)
           (case (-> arg3 param 1)
             (('explode)
              (let ((a0-2 (handle->process (-> self fuel-cell))))
                (if a0-2
                    (send-event a0-2 'trans (-> self root-override trans))
                    )
                )
              (go pelican-explode #f)
              #f
              )
             (else
               (let* ((gp-0 arg0)
                      (v1-13 (if (and (nonzero? gp-0) (type-type? (-> gp-0 type) process-drawable))
                                 gp-0
                                 )
                             )
                      (f30-0 8192.0)
                      (gp-1 (-> self root-override))
                      (s4-0 (-> (the-as process-drawable v1-13) root trans))
                      )
                 (if (< f30-0
                        (fabs
                          (deg-diff (y-angle gp-1) (vector-y-angle (vector-! (new 'stack-no-clear 'vector) s4-0 (-> gp-1 trans))))
                          )
                        )
                     (go pelican-spit)
                     )
                 )
               )
             )
           )
          ((= v1-0 'touch)
           (dummy-55 (-> self root-override) arg0 (the-as touching-shapes-entry (-> arg3 param 0)) 0.7 6144.0 16384.0)
           )
          )
        )
      )
    )
  :enter
  (behavior ((arg0 symbol))
    (set! (-> self path) (-> self path-from-nest0))
    (set! (-> self path-pos) 0.0)
    (set! (-> self path-max) (the float (+ (-> self path curve num-cverts) -1)))
    (set! (-> self path-speed) (/ (* 300.0 (-> self path-max)) (the float (-> *PELICAN-bank* from-nest-time))))
    (let ((s5-0 (-> self state-vector)))
      (eval-path-curve-div! (-> self path) s5-0 (-> self path-pos) 'interp)
      (set! (-> self state-float 0) (/ (* 300.0 (vector-vector-distance (-> self root-override trans) s5-0))
                                       (the float (-> *PELICAN-bank* land-time))
                                       )
            )
      )
    (TODO-RENAME-12 (-> self path) (-> self path-vector) (-> self path-pos))
    (when arg0
      (TODO-RENAME-30 (-> self root-override) (-> self state-vector))
      (set-heading-vec! (-> self root-override) (-> self path-vector))
      (let ((a0-7 (handle->process (-> self fuel-cell))))
        (if a0-7
            (send-event a0-7 'draw #f)
            )
        )
      (let ((a0-10 (-> self entity extra perm)))
        (if (< 2 (-> a0-10 user-int8 0))
            (go pelican-explode #t)
            )
        )
      )
    (if (nonzero? (-> self neck))
        (set-mode! (-> self neck) (joint-mod-handler-mode look-at))
        )
    (none)
    )
  :exit
  (behavior ()
    (if (nonzero? (-> self neck))
        (set-mode! (-> self neck) (joint-mod-handler-mode flex-blend))
        )
    (none)
    )
  :trans
  (behavior ()
    (let ((a1-0 (-> self state-vector))
          (gp-0 (new 'stack-no-clear 'vector))
          )
      (set! (-> gp-0 quad) (-> self root-override trans quad))
      (vector-seek! gp-0 a1-0 (* (-> self state-float 0) (-> *display* seconds-per-frame)))
      (TODO-RENAME-30 (-> self root-override) gp-0)
      )
    (dummy-45 (-> self root-override))
    (seek-toward-heading-vec! (-> self root-override) (-> self path-vector) 131072.0 300)
    (spool-push *art-control* "pelican-spit-ext" 0 self -99.0)
    (none)
    )
  :code
  (behavior ((arg0 symbol))
    (cond
      (arg0
        (ja-channel-set! 1)
        )
      (else
        (let ((a0-2 (-> self skel root-channel 0)))
          (set! (-> a0-2 param 0) 0.25)
          (joint-control-channel-group! a0-2 (the-as art-joint-anim #f) num-func-loop!)
          )
        (ja-channel-push! 1 75)
        (let ((a0-4 (-> self skel root-channel 0)))
          (set! (-> a0-4 frame-group) (the-as art-joint-anim (-> self draw art-group data 8)))
          (set! (-> a0-4 param 0)
                (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 8)) data 0 length) -1))
                )
          (set! (-> a0-4 param 1) 1.0)
          (set! (-> a0-4 frame-num) 0.0)
          (joint-control-channel-group! a0-4 (the-as art-joint-anim (-> self draw art-group data 8)) num-func-seek!)
          )
        (until (ja-done? 0)
          (ja-blend-eval)
          (suspend)
          (let ((a0-5 (-> self skel root-channel 0)))
            (set! (-> a0-5 param 0) (the float (+ (-> a0-5 frame-group data 0 length) -1)))
            (set! (-> a0-5 param 1) 1.0)
            (joint-control-channel-group-eval! a0-5 (the-as art-joint-anim #f) num-func-seek!)
            )
          )
        (until (vector= (-> self root-override trans) (-> self state-vector))
          (suspend)
          (let ((a0-7 (-> self skel root-channel 0)))
            (set! (-> a0-7 param 0) 1.0)
            (joint-control-channel-group-eval! a0-7 (the-as art-joint-anim #f) num-func-loop!)
            )
          )
        (let ((a0-9 (-> self skel root-channel 0)))
          (set! (-> a0-9 param 0) 1.0)
          (joint-control-channel-group! a0-9 (the-as art-joint-anim #f) num-func-loop!)
          )
        (set! (-> self state-float 0) (* 4.0 (-> self state-float 0)))
        (ja-channel-push! 1 15)
        (let ((a0-11 (-> self skel root-channel 0)))
          (set! (-> a0-11 frame-group) (the-as art-joint-anim (-> self draw art-group data 9)))
          (set! (-> a0-11 param 0)
                (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 9)) data 0 length) -1))
                )
          (set! (-> a0-11 param 1) 1.0)
          (set! (-> a0-11 frame-num) 0.0)
          (joint-control-channel-group! a0-11 (the-as art-joint-anim (-> self draw art-group data 9)) num-func-seek!)
          )
        (until (ja-done? 0)
          (ja-blend-eval)
          (suspend)
          (let ((a0-12 (-> self skel root-channel 0)))
            (set! (-> a0-12 param 0) (the float (+ (-> a0-12 frame-group data 0 length) -1)))
            (set! (-> a0-12 param 1) 1.0)
            (joint-control-channel-group-eval! a0-12 (the-as art-joint-anim #f) num-func-seek!)
            )
          )
        (ja-channel-push! 1 150)
        )
      )
    (send-event (handle->process (-> self cam-tracker)) 'message 'release)
    (while #t
      (let ((a0-19 (-> self skel root-channel 0)))
        (set! (-> a0-19 frame-group) (the-as art-joint-anim (-> self draw art-group data 10)))
        (set! (-> a0-19 param 0)
              (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 10)) data 0 length) -1))
              )
        (set! (-> a0-19 param 1) 1.0)
        (set! (-> a0-19 frame-num) 0.0)
        (joint-control-channel-group! a0-19 (the-as art-joint-anim (-> self draw art-group data 10)) num-func-seek!)
        )
      (until (ja-done? 0)
        (suspend)
        (let ((a0-20 (-> self skel root-channel 0)))
          (set! (-> a0-20 param 0) (the float (+ (-> a0-20 frame-group data 0 length) -1)))
          (set! (-> a0-20 param 1) 1.0)
          (joint-control-channel-group-eval! a0-20 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      )
    (none)
    )
  :post
  (behavior ()
    (when *target*
      (if *target*
          (look-at-enemy! (-> *target* neck) (the-as vector (-> self root-override root-prim prim-core)) 'nothing self)
          )
      (if (nonzero? (-> self neck))
          (set-target! (-> self neck) (target-pos 5))
          )
      )
    (pelican-post)
    (none)
    )
  )

;; failed to figure out what this is:
(defstate pelican-spit (pelican)
  :event
  (-> pelican-circle event)
  :code
  (behavior ()
    (local-vars (v1-21 symbol) (v1-31 symbol))
    (let* ((gp-0 (get-process *default-dead-pool* manipy #x4000))
           (gp-1
             (ppointer->handle
               (when gp-0
                 (let ((t9-1 (method-of-type manipy activate)))
                   (t9-1 (the-as manipy gp-0) self 'manipy (the-as pointer #x70004000))
                   )
                 (run-now-in-process gp-0 manipy-init (-> self entity extra trans) (-> self entity) *beachcam-sg* #f)
                 (-> gp-0 ppointer)
                 )
               )
             )
           )
      (let ((s5-0 (get-process *default-dead-pool* othercam #x4000)))
        (ppointer->handle (when s5-0
                            (let ((t9-4 (method-of-type othercam activate)))
                              (t9-4 (the-as othercam s5-0) (-> gp-1 process 0) 'othercam (the-as pointer #x70004000))
                              )
                            (run-now-in-process s5-0 othercam-init-by-other (-> gp-1 process 0) 4 #f #t)
                            (-> s5-0 ppointer)
                            )
                          )
        )
      (let* ((s5-1 (get-process *default-dead-pool* fuel-cell #x4000))
             (s4-0 (ppointer->handle (when s5-1
                                       (let ((t9-7 (method-of-type fuel-cell activate)))
                                         (t9-7 (the-as fuel-cell s5-1) self 'fuel-cell (the-as pointer #x70004000))
                                         )
                                       (run-now-in-process s5-1 fuel-cell-init-as-clone (process->handle self) 0)
                                       (-> s5-1 ppointer)
                                       )
                                     )
                   )
             (s5-2 (new 'stack-no-clear 'quaternion))
             )
        (quaternion-copy! s5-2 (-> self root-override quat))
        (until v1-21
          (suspend)
          (set! v1-21 (or (not *target*) (process-grab? *target*)))
          )
        (send-event (-> gp-1 process 0) 'anim-mode 'clone-anim)
        (ja-play-spooled-anim
          (new 'static 'spool-anim
            :name "pelican-spit-ext"
            :index 11
            :parts 2
            :command-list
            '((10 send-event camera 'teleport-to-vector-start-string (static-vectorm -179 16 -421)))
            )
          (the-as art-joint-anim (-> self draw art-group data 10))
          (the-as art-joint-anim #f)
          (the-as (function process-drawable symbol) false-func)
          )
        (until v1-31
          (suspend)
          (set! v1-31 (or (not *target*) (process-release? *target*)))
          )
        (if (handle->process gp-1)
            (deactivate (-> gp-1 process 0))
            )
        (if (handle->process s4-0)
            (deactivate (-> s4-0 process 0))
            )
        (quaternion-copy! (-> self root-override quat) s5-2)
        )
      )
    (let ((gp-2 (get-process *default-dead-pool* process #x4000)))
      (when gp-2
        (let ((t9-18 (method-of-type process activate)))
          (t9-18 gp-2 self 'process (the-as pointer #x70004000))
          )
        (run-next-time-in-process gp-2 (lambda :behavior pelican
                                         ()
                                         (while (or (-> *setting-control* current ambient)
                                                    (-> *setting-control* current movie)
                                                    (-> *setting-control* current hint)
                                                    )
                                           (suspend)
                                           )
                                         (level-hint-spawn
                                           (game-text-id beach-pelican-quick-get-cell)
                                           "sksp0027"
                                           (the-as entity #f)
                                           *entity-pool*
                                           (game-task none)
                                           )
                                         (none)
                                         )
                                  )
        (-> gp-2 ppointer)
        )
      )
    (let ((gp-3 (handle->process (-> self fuel-cell))))
      (when gp-3
        (send-event gp-3 'release)
        (set! (-> self path-cache) (-> self path-spit0))
        (let ((s5-3 (new 'stack-no-clear 'vector)))
          (eval-path-curve-div!
            (-> self path-cache)
            s5-3
            (the float (+ (-> self path-cache curve num-cverts) -1))
            'interp
            )
          (send-event gp-3 'trans s5-3)
          )
        (send-event gp-3 'draw #t)
        (send-event
          gp-3
          'event-hook
          (lambda :behavior pelican
            ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
            (the-as object (when (or (= arg2 'touch) (= arg2 'attack))
                             (let ((v1-7 (birth-pickup-at-point
                                           (-> self root-override trans)
                                           (pickup-type fuel-cell)
                                           (the float (-> self entity extra perm task))
                                           #f
                                           (the-as process-drawable *entity-pool*)
                                           (the-as fact-info #f)
                                           )
                                         )
                                   )
                               (when v1-7
                                 (set! (-> (the-as collectable (-> v1-7 0)) collect-timeout) 0)
                                 0
                                 )
                               )
                             (deactivate self)
                             )
                    )
            )
          )
        )
      )
    (go pelican-from-nest)
    (none)
    )
  :post
  (behavior ()
    (if (not (= (if (> (-> self skel active-channels) 0)
                    (-> self skel root-channel 0 frame-group)
                    )
                (-> self draw art-group data 10)
                )
             )
        (quaternion-identity! (-> self root-override quat))
        )
    (pelican-post)
    (none)
    )
  )

;; failed to figure out what this is:
(defstate pelican-from-nest (pelican)
  :enter
  (behavior ()
    (set! (-> self path-pos) 1.5)
    (none)
    )
  :trans
  (behavior ()
    (pelican-path-update 131072.0 150 0.0 0.0 #f)
    (set! (-> self path-pos)
          (seek (-> self path-pos) (-> self path-max) (* (-> self path-speed) (-> *display* seconds-per-frame)))
          )
    (if (= (-> self path-pos) (-> self path-max))
        (go pelican-dive (-> self path-dive1) (-> self path-to-nest1) (the-as uint (-> *PELICAN-bank* to-nest1-time)))
        )
    (none)
    )
  :code
  (behavior ()
    (pelican-fly
      (the-as (function pelican int) (lambda () (rand-vu-int-range 2 4)))
      (the-as (function pelican int) zero-func)
      )
    (none)
    )
  :post
  pelican-post
  )

;; failed to figure out what this is:
(defstate pelican-fly-to-end (pelican)
  :enter
  (behavior ((arg0 path-control) (arg1 int))
    (process-entity-status! self (entity-perm-status complete) #t)
    (let ((v1-2 (-> self entity extra perm)))
      (logior! (-> v1-2 status) (entity-perm-status user-set-from-cstage))
      (set! (-> v1-2 user-int8 0) 10)
      )
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (set! (-> self path) arg0)
    (set! (-> self path-pos) 0.0)
    (set! (-> self path-max) (the float (+ (-> self path curve num-cverts) -1)))
    (set! (-> self path-speed) (/ (* 300.0 (-> self path-max)) (the float arg1)))
    (set! (-> self state-vector quad) (-> self root-override trans quad))
    (set! (-> self state-float 0) 0.0)
    (let ((gp-1 (new 'stack-no-clear 'vector)))
      (eval-path-curve-div! (-> self path) gp-1 0.0 'interp)
      (set! (-> self state-float 1) (* 0.0073242188 (vector-vector-distance (-> self root-override trans) gp-1)))
      )
    (none)
    )
  :trans
  (behavior ()
    (pelican-path-update 546133.3 30 0.0 0.0 #f)
    (set! (-> self path-pos)
          (seek (-> self path-pos) (-> self path-max) (* (-> self path-speed) (-> *display* seconds-per-frame)))
          )
    (if (= (-> self path-pos) (-> self path-max))
        (go pelican-wait-at-end #f)
        )
    (when (< (- (-> *display* base-frame-counter) (-> self state-time)) (the int (-> self state-float 1)))
      (set! (-> self state-float 0)
            (/ (the float (- (-> *display* base-frame-counter) (-> self state-time))) (-> self state-float 1))
            )
      (vector-lerp!
        (-> self root-override trans)
        (-> self state-vector)
        (-> self root-override trans)
        (-> self state-float 0)
        )
      )
    (none)
    )
  :code
  (behavior ((arg0 path-control) (arg1 int))
    (pelican-fly
      (the-as (function pelican int) (lambda () 1))
      (lambda ((arg0 pelican)) (if (and (>= (-> arg0 path-pos) 4.0) (>= 6.0 (-> arg0 path-pos)))
                                   1
                                   0
                                   )
              )
      )
    (none)
    )
  :post
  pelican-post
  )

;; failed to figure out what this is:
(defstate pelican-wait-at-end (pelican)
  :code
  (behavior ((arg0 symbol))
    (dummy-18 self)
    (none)
    )
  )

;; failed to figure out what this is:
(defstate pelican-explode (pelican)
  :code
  (behavior ((arg0 symbol))
    (let ((v1-2 (-> self entity extra perm)))
      (logior! (-> v1-2 status) (entity-perm-status user-set-from-cstage))
      (set! (-> v1-2 user-int8 0) 5)
      )
    (when (not arg0)
      (sound-play-by-name (static-sound-name "scrate-break") (new-sound-id) 1024 0 0 1 #t)
      (let ((gp-1 (get-process *default-dead-pool* part-tracker #x4000)))
        (when gp-1
          (let ((t9-3 (method-of-type part-tracker activate)))
            (t9-3 (the-as part-tracker gp-1) *entity-pool* 'part-tracker (the-as pointer #x70004000))
            )
          (run-now-in-process
            gp-1
            part-tracker-init
            (-> *part-group-id-table* 71)
            -1
            #f
            #f
            #f
            (-> self root-override trans)
            )
          (-> gp-1 ppointer)
          )
        )
      )
    (let ((gp-2 (new-stack-vector0)))
      (set! (-> gp-2 quad) (-> self root-override trans quad))
      (let ((a0-7 (handle->process (-> self fuel-cell))))
        (when a0-7
          (set! (-> gp-2 quad) (-> (the-as process-drawable a0-7) root trans quad))
          (set! (-> gp-2 y) (+ 8192.0 (-> gp-2 y)))
          (deactivate a0-7)
          )
        )
      (when (not (task-complete? *game-info* (-> self entity extra perm task)))
        (let ((v1-29 (birth-pickup-at-point
                       gp-2
                       (pickup-type fuel-cell)
                       (the float (-> self entity extra perm task))
                       #f
                       self
                       (the-as fact-info #f)
                       )
                     )
              )
          (send-event (ppointer->process v1-29) 'movie-pos 1)
          )
        )
      )
    (clear-collide-with-as (-> self root-override))
    (ja-channel-set! 0)
    (anim-loop)
    (none)
    )
  :post
  (the-as (function none :behavior pelican) ja-post)
  )

;; definition for method 11 of type pelican
;; INFO: Return type mismatch object vs none.
(defmethod init-from-entity! pelican ((obj pelican) (arg0 entity-actor))
  (stack-size-set! (-> obj main-thread) 512)
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((s3-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set-vector! (-> s3-0 local-sphere) 0.0 12288.0 0.0 12288.0)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *pelican-sg* '())
  (set! (-> obj draw shadow-ctrl)
        (new 'process 'shadow-control -81920.0 4096.0 614400.0 (the-as float 25) 409600.0)
        )
  (logclear! (-> obj mask) (process-mask actor-pause))
  (set! (-> obj align) (new 'process 'align-control obj))
  (dotimes (s5-1 8)
    (let ((v1-27 (new 'process 'curve-control obj 'path (the float (+ s5-1 1)))))
      (set! (-> obj path-data s5-1) v1-27)
      (logior! (-> v1-27 flags) (path-control-flag display draw-line draw-point draw-text))
      )
    )
  (set! (-> obj fuel-cell) (the-as handle #f))
  (set! (-> obj cam-tracker) (the-as handle #f))
  (set! (-> obj neck) (new 'process 'joint-mod (joint-mod-handler-mode flex-blend) obj 9))
  (set-vector! (-> obj neck twist-max) 2730.6667 2730.6667 0.0 1.0)
  (set! (-> obj neck up) (the-as uint 1))
  (set! (-> obj neck nose) (the-as uint 2))
  (set! (-> obj neck ear) (the-as uint 0))
  (set! (-> obj neck max-dist) 61440.0)
  (set! (-> obj neck ignore-angle) 16384.0)
  (case (-> obj entity extra perm user-int8 0)
    ((10)
     (go pelican-wait-at-end #t)
     )
    ((5)
     (go pelican-wait-at-nest #t)
     )
    ((2)
     (let* ((s4-1 (get-process *default-dead-pool* manipy #x4000))
            (s5-2 (when s4-1
                    (let ((t9-15 (method-of-type manipy activate)))
                      (t9-15 (the-as manipy s4-1) obj 'manipy (the-as pointer #x70004000))
                      )
                    (run-now-in-process
                      s4-1
                      manipy-init
                      (-> obj root-override trans)
                      (-> obj entity)
                      *fuel-cell-sg*
                      (new 'static 'vector :w 4915.2)
                      )
                    (-> s4-1 ppointer)
                    )
                  )
            )
       (set! (-> obj fuel-cell) (the-as handle (if s5-2
                                                   (ppointer->handle s5-2)
                                                   (the-as int #f)
                                                   )
                                        )
             )
       (when s5-2
         (send-event
           (ppointer->process s5-2)
           'eval
           (lambda :behavior pelican () (let ((v0-0 (create-launch-control (-> *part-group-id-table* 63) self)))
                                          (set! (-> self part) v0-0)
                                          v0-0
                                          )
                                     )
           )
         (send-event (ppointer->process s5-2) 'trans-hook fuel-cell-animate)
         )
       )
     (go pelican-wait-at-nest #t)
     )
    (else
      (go pelican-circle)
      )
    )
  (none)
  )
