;;-*-Lisp-*-
(in-package goal)

;; definition of type pelican-bank
(deftype pelican-bank (basic)
  ((circle-speed        meters   :offset-assert   4)
   (dive-time           seconds  :offset-assert   8)
   (to-nest0-time       seconds  :offset-assert  16)
   (to-nest1-time       seconds  :offset-assert  24)
   (land-time           seconds  :offset-assert  32)
   (from-nest-time      seconds  :offset-assert  40)
   (spit-time           seconds  :offset-assert  48)
   (pre-spit-wait-time  seconds  :offset-assert  56)
   (post-spit-wait-time seconds  :offset-assert  64)
   (run-away-time       seconds  :offset-assert  72)
   )
  :method-count-assert 9
  :size-assert         #x50
  :flag-assert         #x900000050
  )

;; definition for method 3 of type pelican-bank
(defmethod inspect pelican-bank ((obj pelican-bank))
  (format #t "[~8x] ~A~%" obj (-> obj type))
  (format #t "~Tcircle-speed: (meters ~m)~%" (-> obj circle-speed))
  (format #t "~Tdive-time: (seconds ~e)~%" (-> obj dive-time))
  (format #t "~Tto-nest0-time: (seconds ~e)~%" (-> obj to-nest0-time))
  (format #t "~Tto-nest1-time: (seconds ~e)~%" (-> obj to-nest1-time))
  (format #t "~Tland-time: (seconds ~e)~%" (-> obj land-time))
  (format #t "~Tfrom-nest-time: (seconds ~e)~%" (-> obj from-nest-time))
  (format #t "~Tspit-time: (seconds ~e)~%" (-> obj spit-time))
  (format #t "~Tpre-spit-wait-time: (seconds ~e)~%" (-> obj pre-spit-wait-time))
  (format #t "~Tpost-spit-wait-time: (seconds ~e)~%" (-> obj post-spit-wait-time))
  (format #t "~Trun-away-time: (seconds ~e)~%" (-> obj run-away-time))
  obj
  )

;; definition for symbol *PELICAN-bank*, type pelican-bank
(define *PELICAN-bank* (new 'static 'pelican-bank
                         :circle-speed (meters 16)
                         :dive-time (seconds 2)
                         :to-nest0-time (seconds 4)
                         :to-nest1-time (seconds 8)
                         :land-time (seconds 2.4)
                         :from-nest-time (seconds 20)
                         :spit-time (seconds 1)
                         :pre-spit-wait-time (seconds 0.5)
                         :post-spit-wait-time (seconds 1.5)
                         :run-away-time (seconds 10)
                         )
        )

;; definition of type pelican
(deftype pelican (process-drawable)
  ((root-override   collide-shape-moving         :offset        112)
   (query           gui-query            :inline :offset-assert 176)
   (fuel-cell       handle                       :offset-assert 208)
   (cam-tracker     handle                       :offset-assert 216)
   (path-data       curve-control        8       :offset-assert 224)
   (path-circle     curve-control                :offset        224)
   (path-dive0      curve-control                :offset        228)
   (path-to-nest0   curve-control                :offset        232)
   (path-from-nest0 curve-control                :offset        236)
   (path-spit0      curve-control                :offset        240)
   (path-dive1      curve-control                :offset        244)
   (path-to-nest1   curve-control                :offset        248)
   (path-to-nest2   curve-control                :offset        252)
   (path-cache      curve-control                :offset-assert 256)
   (time-cache      time-frame                   :offset-assert 264)
   (path-pos        float                        :offset-assert 272)
   (path-speed      float                        :offset-assert 276)
   (path-max        float                        :offset-assert 280)
   (path-vector     vector               :inline :offset-assert 288)
   (state-vector    vector               :inline :offset-assert 304)
   (state-vector1   vector               :inline :offset-assert 320)
   (state-float     float                2       :offset-assert 336)
   (state-object    symbol                       :offset-assert 344)
   (neck            joint-mod                    :offset-assert 348)
   )
  :heap-base #xf0
  :method-count-assert 20
  :size-assert         #x160
  :flag-assert         #x1400f00160
  (:states
    pelican-circle
    (pelican-dive path-control curve-control time-frame)
    (pelican-explode symbol)
    (pelican-fly-to-end path-control time-frame)
    pelican-from-nest
    pelican-spit
    (pelican-to-nest path-control int)
    (pelican-wait-at-end symbol)
    (pelican-wait-at-nest symbol)
    )
  )

;; definition for method 3 of type pelican
(defmethod inspect pelican ((obj pelican))
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 obj)
    )
  (format #t "~T~Tquery: #<gui-query @ #x~X>~%" (-> obj query))
  (format #t "~T~Tfuel-cell: ~D~%" (-> obj fuel-cell))
  (format #t "~T~Tcam-tracker: ~D~%" (-> obj cam-tracker))
  (format #t "~T~Tpath-data[8] @ #x~X~%" (-> obj path-data))
  (format #t "~T~Tpath-circle: ~A~%" (-> obj path-circle))
  (format #t "~T~Tpath-dive0: ~A~%" (-> obj path-dive0))
  (format #t "~T~Tpath-to-nest0: ~A~%" (-> obj path-to-nest0))
  (format #t "~T~Tpath-from-nest0: ~A~%" (-> obj path-from-nest0))
  (format #t "~T~Tpath-spit0: ~A~%" (-> obj path-spit0))
  (format #t "~T~Tpath-dive1: ~A~%" (-> obj path-dive1))
  (format #t "~T~Tpath-to-nest1: ~A~%" (-> obj path-to-nest1))
  (format #t "~T~Tpath-to-nest2: ~A~%" (-> obj path-to-nest2))
  (format #t "~T~Tpath-cache: ~A~%" (-> obj path-cache))
  (format #t "~T~Ttime-cache: ~D~%" (-> obj time-cache))
  (format #t "~T~Tpath-pos: ~f~%" (-> obj path-pos))
  (format #t "~T~Tpath-speed: ~f~%" (-> obj path-speed))
  (format #t "~T~Tpath-max: ~f~%" (-> obj path-max))
  (format #t "~T~Tpath-vector: ~`vector`P~%" (-> obj path-vector))
  (format #t "~T~Tstate-vector: ~`vector`P~%" (-> obj state-vector))
  (format #t "~T~Tstate-vector1: ~`vector`P~%" (-> obj state-vector1))
  (format #t "~T~Tstate-float[2] @ #x~X~%" (-> obj state-float))
  (format #t "~T~Tstate-object: ~A~%" (-> obj state-object))
  (format #t "~T~Tneck: ~A~%" (-> obj neck))
  obj
  )

;; definition for method 7 of type pelican
;; INFO: Return type mismatch process-drawable vs pelican.
(defmethod relocate pelican ((obj pelican) (arg0 int))
  (countdown (v1-0 8)
    (if (nonzero? (-> obj path-data v1-0))
        (&+! (-> obj path-data v1-0) arg0)
        )
    )
  (if (nonzero? (-> obj path-cache))
      (&+! (-> obj path-cache) arg0)
      )
  (if (nonzero? (-> obj neck))
      (&+! (-> obj neck) arg0)
      )
  (the-as
    pelican
    ((the-as (function process-drawable int process-drawable) (find-parent-method pelican 7)) obj arg0)
    )
  )

;; failed to figure out what this is:
(defskelgroup *pelican-sg* pelican pelican-lod0-jg pelican-fly-ja
              ((pelican-lod0-mg (meters 20)) (pelican-lod1-mg (meters 40)) (pelican-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 3 0 5)
              :shadow pelican-shadow-mg
              )

;; definition for function pelican-path-update
(defbehavior pelican-path-update pelican ((arg0 float) (arg1 int) (arg2 float) (arg3 float) (arg4 symbol))
  (compute-alignment! (-> self align))
  (let ((s3-0 (new 'stack-no-clear 'vector)))
    (let* ((f0-1 (+ (-> self path-pos) (* (-> self align align trans z) arg3)))
           (f1-2 (-> self path-max))
           (f30-0 (- f0-1 (* (the float (the int (/ f0-1 f1-2))) f1-2)))
           )
      (eval-path-curve-div! (-> self path) s3-0 f30-0 'interp)
      (+! (-> s3-0 y) (-> self align align trans y))
      (move-to-point! (-> self root-override) s3-0)
      (path-control-method-12 (-> self path) s3-0 f30-0)
      )
    (if arg4
        (set-heading-vec-clear-roll-pitch! (-> self root-override) s3-0)
        (seek-toward-heading-vec! (-> self root-override) s3-0 arg0 (the-as time-frame arg1))
        )
    )
  )

;; definition for function pelican-fly
(defbehavior pelican-fly pelican ((arg0 (function pelican int)) (arg1 (function pelican int)))
  (loop
    (cond
      ((ja-group? pelican-fly-ja)
       (ja-no-eval :num! (seek!))
       (while (not (ja-done? 0))
         (suspend)
         (ja-eval)
         )
       )
      (else
        (ja-channel-push! 1 (seconds 0.25))
        )
      )
    (let ((s4-0 (arg0 self)))
      (dotimes (s3-0 s4-0)
        (ja-no-eval :group! pelican-fly-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (ja-blend-eval)
          (suspend)
          (ja :num! (seek!))
          )
        )
      )
    (let ((s4-1 (arg1 self)))
      (when (> s4-1 0)
        (ja-no-eval :group! pelican-fly-ja :num! (seek! (ja-aframe 12.0 0)) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! (ja-aframe 12.0 0)))
          )
        (ja-no-eval :num! (loop! 0.25))
        (ja-channel-push! 1 (seconds 1))
        (dotimes (s3-3 s4-1)
          (ja-no-eval :group! pelican-glide-ja :num! (seek!) :frame-num 0.0)
          (until (ja-done? 0)
            (ja-blend-eval)
            (suspend)
            (ja :num! (seek!))
            )
          )
        (ja-no-eval :num! (loop!))
        )
      )
    )
  (none)
  )

;; definition for function pelican-post
(defbehavior pelican-post pelican ()
  (ja-post)
  (none)
  )

;; failed to figure out what this is:
(defstate pelican-circle (pelican)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as
      object
      (case event-type
        (('dive)
         (let ((v0-0 (the-as structure #t)))
           (set! (-> self state-object) (the-as symbol v0-0))
           v0-0
           )
         )
        (('fuel-cell)
         (handle->process (-> self fuel-cell))
         )
        (('position)
         (set! (-> self path-pos) (the-as float (-> event param 0)))
         (let ((a1-3 (path-control-method-12 (-> self path) (new 'stack-no-clear 'vector) (-> self path-pos))))
           (set-heading-vec! (-> self root-override) a1-3)
           )
         )
        )
      )
    )
  :enter (behavior ()
    (while (-> self child)
      (deactivate (-> self child 0))
      )
    (set! (-> self state-object) #f)
    (let ((gp-0 (-> self path-vector)))
      (eval-path-curve-div! (-> self path-dive0) gp-0 4.5 'interp)
      (+! (-> gp-0 y) -4505.6)
      (let ((v1-8 (manipy-spawn gp-0 (-> self entity) *fuel-cell-sg* (new 'static 'vector :w 4915.2) :to self)))
        (set! (-> self fuel-cell) (ppointer->handle v1-8))
        (if v1-8
            (send-event
              (ppointer->process v1-8)
              'eval
              (lambda :behavior pelican () (let ((v0-0 (create-launch-control (-> *part-group-id-table* 63) self)))
                                             (set! (-> self part) v0-0)
                                             v0-0
                                             )
                                        )
              )
            )
        )
      )
    (set! (-> self path) (-> self path-circle))
    (set! (-> self path-pos) 0.0)
    (set! (-> self path-max) (the float (+ (-> self path curve num-cverts) -1)))
    (set! (-> self path-speed)
          (/ (* (-> *PELICAN-bank* circle-speed) (-> self path-max)) (path-distance (-> self path)))
          )
    (set-roll-to-grav-2! (-> self root-override) -2730.6667)
    (none)
    )
  :trans (behavior ()
    (pelican-path-update 728177.75 30 1.0 (/ (-> self path-max) (path-distance (-> self path))) #f)
    (let ((f0-3 (+ (-> self path-pos) (* (-> self path-speed) (-> *display* seconds-per-frame))))
          (f1-2 (-> self path-max))
          )
      (set! (-> self path-pos) (- f0-3 (* (the float (the int (/ f0-3 f1-2))) f1-2)))
      )
    (when (and (and *target* (>= 81920.0 (vector-vector-xz-distance (-> self path-vector) (-> *target* control trans))))
               (not (handle->process (-> self cam-tracker)))
               )
      (set! (-> self cam-tracker)
            (ppointer->handle (process-spawn
                                camera-tracker
                                :init camera-tracker-init
                                (lambda :behavior camera-tracker
                                  ()
                                  (local-vars
                                    (a0-6 process-tree)
                                    (a1-5 event-message-block)
                                    (t9-6 (function process-tree event-message-block object))
                                    )
                                  (while (not (process-grab? *target*))
                                    (suspend)
                                    )
                                  (send-event (ppointer->process (-> self parent)) 'position 4.0)
                                  (send-event (ppointer->process (-> self parent)) 'dive)
                                  (suspend)
                                  (suspend)
                                  (send-event *camera* 'blend-from-as-fixed)
                                  (camera-look-at (the-as pair (ppointer->process (-> self parent))) (the-as uint 0))
                                  (camera-change-to "camera-215" 0 #f)
                                  (until (t9-6 a0-6 a1-5)
                                    (suspend)
                                    (set! a1-5 (new 'stack-no-clear 'event-message-block))
                                    (set! (-> a1-5 from) self)
                                    (set! (-> a1-5 num-params) 0)
                                    (set! (-> a1-5 message) 'got-cell?)
                                    (set! t9-6 send-event-function)
                                    (set! a0-6 (ppointer->process (-> self parent)))
                                    )
                                  (send-event *camera* 'point-of-interest #f)
                                  (while (!= (-> self message) 'release)
                                    (suspend)
                                    )
                                  (set! (-> self message) #f)
                                  (while (not (process-release? (handle->process (-> self grab-target))))
                                    (suspend)
                                    )
                                  (send-event *camera* 'blend-from-as-fixed)
                                  (camera-look-at (the-as pair *target*) (the-as uint 0))
                                  (camera-change-to (the-as string 'base) 150 #f)
                                  (none)
                                  )
                                :to self
                                )
                              )
            )
      (set! (-> self draw force-lod) 0)
      0
      )
    (when (and (-> self state-object) (>= (-> self path-pos) 6.0) (< (-> self path-pos) 7.0))
      (let ((v1-24 (-> self entity extra perm)))
        (logior! (-> v1-24 status) (entity-perm-status user-set-from-cstage))
        (set! (-> v1-24 user-int8 0) 2)
        )
      (go pelican-dive (-> self path-dive0) (-> self path-to-nest0) (-> *PELICAN-bank* to-nest0-time))
      )
    (none)
    )
  :code (behavior ()
    (suspend)
    (send-event (-> self fuel-cell process 0) 'trans-hook fuel-cell-animate)
    (pelican-fly
      (the-as (function pelican int) (lambda () (rand-vu-int-range 2 4)))
      (the-as (function pelican int) (lambda () (rand-vu-int-range 3 5)))
      )
    (none)
    )
  :post pelican-post
  )

;; failed to figure out what this is:
(defstate pelican-dive (pelican)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('got-cell?)
                      (-> self state-object)
                      )
                     (('fuel-cell)
                      (handle->process (-> self fuel-cell))
                      )
                     )
            )
    )
  :enter (behavior ((arg0 path-control) (arg1 curve-control) (arg2 time-frame))
    (init! (-> self query) (the-as string #f) 40 150 25 #t (the-as string #f))
    (set! (-> self state-object) #f)
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (set-roll-to-grav-2! (-> self root-override) 0.0)
    (let ((a0-4 (handle->process (-> self fuel-cell))))
      (cond
        (a0-4
          (send-event a0-4 'trans-hook fuel-cell-animate)
          )
        (else
          )
        )
      )
    (set! (-> self path-cache) arg1)
    (set! (-> self time-cache) arg2)
    (set! (-> self path) arg0)
    (set! (-> self path-pos) 0.0)
    (set! (-> self path-max) (the float (+ (-> self path curve num-cverts) -1)))
    (set! (-> self path-speed) (/ (* 300.0 (-> self path-max)) (the float (-> *PELICAN-bank* dive-time))))
    (let ((gp-1 (new 'stack-no-clear 'vector)))
      (path-control-method-12 (-> self path) gp-1 (-> self path-pos))
      (set-heading-vec! (-> self root-override) gp-1)
      )
    (set! (-> self draw force-lod) 0)
    0
    (none)
    )
  :exit (behavior ()
    (set! (-> self draw force-lod) -1)
    (none)
    )
  :trans (behavior ()
    (if (not (handle->process (-> self fuel-cell)))
        (go pelican-fly-to-end (-> self path-to-nest2) (-> *PELICAN-bank* run-away-time))
        )
    (pelican-path-update 364088.88 30 0.0 0.0 #t)
    (seek! (-> self path-pos) (-> self path-max) (* (-> self path-speed) (-> *display* seconds-per-frame)))
    (if (= (-> self path-pos) (-> self path-max))
        (go pelican-to-nest (-> self path-cache) (the-as int (-> self time-cache)))
        )
    (none)
    )
  :code (behavior ((arg0 path-control) (arg1 curve-control) (arg2 time-frame))
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! pelican-swoop-ja :num! (seek! (ja-aframe 48.0 0) 0.5) :frame-num 0.0)
    (until (ja-done? 0)
      (ja-blend-eval)
      (let ((gp-1 (handle->process (-> self fuel-cell))))
        (when (and gp-1 (>= (-> self path-pos) 3.8) (not (send-event gp-1 'query 'grab)))
          (level-hint-spawn (text-id zero) (the-as string #f) (-> self entity) *entity-pool* (game-task none))
          (send-event gp-1 'grab self)
          (send-event gp-1 'draw #f)
          (send-event gp-1 'event-hook #f)
          (set! (-> self state-object) #t)
          )
        )
      (suspend)
      (ja :num! (seek! (ja-aframe 48.0 0) 0.5))
      )
    (ja-no-eval :num! (seek!))
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! pelican-fly-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (anim-loop)
    (none)
    )
  :post pelican-post
  )

;; failed to figure out what this is:
(defstate pelican-to-nest (pelican)
  :enter (behavior ((arg0 path-control) (arg1 int))
    (set! (-> self path) arg0)
    (set! (-> self path-pos) 0.0)
    (set! (-> self path-max) (the float (+ (-> self path curve num-cverts) -1)))
    (set! (-> self path-speed) (/ (* 300.0 (-> self path-max)) (the float arg1)))
    (none)
    )
  :trans (behavior ()
    (pelican-path-update 546133.3 30 0.0 0.0 #f)
    (seek! (-> self path-pos) (-> self path-max) (* (-> self path-speed) (-> *display* seconds-per-frame)))
    (if (= (-> self path-pos) (-> self path-max))
        (go pelican-wait-at-nest #f)
        )
    (none)
    )
  :code (behavior ((arg0 path-control) (arg1 int))
    (pelican-fly
      (the-as (function pelican int) (lambda () 1))
      (lambda ((arg0 pelican)) (if (and (>= (-> arg0 path-pos) 4.0) (>= 6.0 (-> arg0 path-pos)))
                                   1
                                   0
                                   )
              )
      )
    (none)
    )
  :post pelican-post
  )

;; failed to figure out what this is:
(defstate pelican-wait-at-nest (pelican)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as
      object
      (case event-type
        (('attack)
         (case (-> event param 1)
           (('explode)
            (let ((a0-2 (handle->process (-> self fuel-cell))))
              (if a0-2
                  (send-event a0-2 'trans (-> self root-override trans))
                  )
              )
            (go pelican-explode #f)
            #f
            )
           (else
             (let* ((gp-0 proc)
                    (v1-13 (if (and (nonzero? gp-0) (type-type? (-> gp-0 type) process-drawable))
                               gp-0
                               )
                           )
                    (f30-0 8192.0)
                    (gp-1 (-> self root-override))
                    (s4-0 (-> (the-as process-drawable v1-13) root trans))
                    )
               (if (< f30-0
                      (fabs
                        (deg-diff (y-angle gp-1) (vector-y-angle (vector-! (new 'stack-no-clear 'vector) s4-0 (-> gp-1 trans))))
                        )
                      )
                   (go pelican-spit)
                   )
               )
             )
           )
         )
        (('touch)
         (the-as object (send-shove-back
                          (-> self root-override)
                          proc
                          (the-as touching-shapes-entry (-> event param 0))
                          0.7
                          6144.0
                          16384.0
                          )
                 )
         )
        )
      )
    )
  :enter (behavior ((arg0 symbol))
    (set! (-> self path) (-> self path-from-nest0))
    (set! (-> self path-pos) 0.0)
    (set! (-> self path-max) (the float (+ (-> self path curve num-cverts) -1)))
    (set! (-> self path-speed) (/ (* 300.0 (-> self path-max)) (the float (-> *PELICAN-bank* from-nest-time))))
    (let ((s5-0 (-> self state-vector)))
      (eval-path-curve-div! (-> self path) s5-0 (-> self path-pos) 'interp)
      (set! (-> self state-float 0) (/ (* 300.0 (vector-vector-distance (-> self root-override trans) s5-0))
                                       (the float (-> *PELICAN-bank* land-time))
                                       )
            )
      )
    (path-control-method-12 (-> self path) (-> self path-vector) (-> self path-pos))
    (when arg0
      (move-to-point! (-> self root-override) (-> self state-vector))
      (set-heading-vec! (-> self root-override) (-> self path-vector))
      (let ((a0-7 (handle->process (-> self fuel-cell))))
        (if a0-7
            (send-event a0-7 'draw #f)
            )
        )
      (let ((a0-10 (-> self entity extra perm)))
        (if (< 2 (-> a0-10 user-int8 0))
            (go pelican-explode #t)
            )
        )
      )
    (if (nonzero? (-> self neck))
        (set-mode! (-> self neck) (joint-mod-handler-mode look-at))
        )
    (none)
    )
  :exit (behavior ()
    (if (nonzero? (-> self neck))
        (set-mode! (-> self neck) (joint-mod-handler-mode flex-blend))
        )
    (none)
    )
  :trans (behavior ()
    (let ((a1-0 (-> self state-vector))
          (gp-0 (new 'stack-no-clear 'vector))
          )
      (set! (-> gp-0 quad) (-> self root-override trans quad))
      (vector-seek! gp-0 a1-0 (* (-> self state-float 0) (-> *display* seconds-per-frame)))
      (move-to-point! (-> self root-override) gp-0)
      )
    (do-push-aways! (-> self root-override))
    (seek-toward-heading-vec! (-> self root-override) (-> self path-vector) 131072.0 (seconds 1))
    (spool-push *art-control* "pelican-spit-ext" 0 self -99.0)
    (none)
    )
  :code (behavior ((arg0 symbol))
    (cond
      (arg0
        (ja-channel-set! 1)
        )
      (else
        (ja-no-eval :num! (loop! 0.25))
        (ja-channel-push! 1 (seconds 0.25))
        (ja-no-eval :group! pelican-fly-down-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (ja-blend-eval)
          (suspend)
          (ja :num! (seek!))
          )
        (until (vector= (-> self root-override trans) (-> self state-vector))
          (suspend)
          (ja :num! (loop!))
          )
        (ja-no-eval :num! (loop!))
        (set! (-> self state-float 0) (* 4.0 (-> self state-float 0)))
        (ja-channel-push! 1 (seconds 0.05))
        (ja-no-eval :group! pelican-land-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (ja-blend-eval)
          (suspend)
          (ja :num! (seek!))
          )
        (ja-channel-push! 1 (seconds 0.5))
        )
      )
    (send-event (handle->process (-> self cam-tracker)) 'message 'release)
    (loop
      (ja-no-eval :group! pelican-sleep-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (none)
    )
  :post (behavior ()
    (when *target*
      (if *target*
          (look-at-enemy! (-> *target* neck) (the-as vector (-> self root-override root-prim prim-core)) 'nothing self)
          )
      (if (nonzero? (-> self neck))
          (set-target! (-> self neck) (target-pos 5))
          )
      )
    (pelican-post)
    (none)
    )
  )

;; failed to figure out what this is:
(defstate pelican-spit (pelican)
  :event (-> pelican-circle event)
  :code (behavior ()
    (local-vars (v1-21 symbol) (v1-31 symbol))
    (let ((gp-1
            (ppointer->handle (manipy-spawn (-> self entity extra trans) (-> self entity) *beachcam-sg* #f :to self))
            )
          )
      (let ((s5-0 (get-process *default-dead-pool* othercam #x4000)))
        (ppointer->handle (when s5-0
                            (let ((t9-4 (method-of-type othercam activate)))
                              (t9-4 (the-as othercam s5-0) (-> gp-1 process 0) 'othercam (the-as pointer #x70004000))
                              )
                            (run-now-in-process s5-0 othercam-init-by-other (-> gp-1 process 0) 4 #f #t)
                            (-> s5-0 ppointer)
                            )
                          )
        )
      (let ((s4-0
              (ppointer->handle (process-spawn fuel-cell :init fuel-cell-init-as-clone (process->handle self) 0 :to self))
              )
            (s5-2 (new 'stack-no-clear 'quaternion))
            )
        (quaternion-copy! s5-2 (-> self root-override quat))
        (until v1-21
          (suspend)
          (set! v1-21 (or (not *target*) (process-grab? *target*)))
          )
        (send-event (-> gp-1 process 0) 'anim-mode 'clone-anim)
        (ja-play-spooled-anim
          (new 'static 'spool-anim
            :name "pelican-spit-ext"
            :index 11
            :parts 2
            :command-list '((10 send-event camera 'teleport-to-vector-start-string (static-vectorm -179 16 -421)))
            )
          (the-as art-joint-anim pelican-sleep-ja)
          (the-as art-joint-anim #f)
          (the-as (function process-drawable symbol) false-func)
          )
        (until v1-31
          (suspend)
          (set! v1-31 (or (not *target*) (process-release? *target*)))
          )
        (if (handle->process gp-1)
            (deactivate (-> gp-1 process 0))
            )
        (if (handle->process s4-0)
            (deactivate (-> s4-0 process 0))
            )
        (quaternion-copy! (-> self root-override quat) s5-2)
        )
      )
    (process-spawn-function
      process
      (lambda :behavior pelican
        ()
        (while (or (-> *setting-control* current ambient)
                   (-> *setting-control* current movie)
                   (-> *setting-control* current hint)
                   )
          (suspend)
          )
        (level-hint-spawn
          (text-id beach-pelican-quick-get-cell)
          "sksp0027"
          (the-as entity #f)
          *entity-pool*
          (game-task none)
          )
        (none)
        )
      :to self
      )
    (let ((gp-3 (handle->process (-> self fuel-cell))))
      (when gp-3
        (send-event gp-3 'release)
        (set! (-> self path-cache) (-> self path-spit0))
        (let ((s5-3 (new 'stack-no-clear 'vector)))
          (eval-path-curve-div!
            (-> self path-cache)
            s5-3
            (the float (+ (-> self path-cache curve num-cverts) -1))
            'interp
            )
          (send-event gp-3 'trans s5-3)
          )
        (send-event gp-3 'draw #t)
        (send-event
          gp-3
          'event-hook
          (lambda :behavior pelican
            ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
            (the-as object (when (or (= arg2 'touch) (= arg2 'attack))
                             (let ((v1-7 (birth-pickup-at-point
                                           (-> self root-override trans)
                                           (pickup-type fuel-cell)
                                           (the float (-> self entity extra perm task))
                                           #f
                                           *entity-pool*
                                           (the-as fact-info #f)
                                           )
                                         )
                                   )
                               (when v1-7
                                 (set! (-> (the-as collectable (-> v1-7 0)) collect-timeout) 0)
                                 0
                                 )
                               )
                             (deactivate self)
                             )
                    )
            )
          )
        )
      )
    (go pelican-from-nest)
    (none)
    )
  :post (behavior ()
    (if (not (ja-group? pelican-sleep-ja))
        (quaternion-identity! (-> self root-override quat))
        )
    (pelican-post)
    (none)
    )
  )

;; failed to figure out what this is:
(defstate pelican-from-nest (pelican)
  :enter (behavior ()
    (set! (-> self path-pos) 1.5)
    (none)
    )
  :trans (behavior ()
    (pelican-path-update 131072.0 150 0.0 0.0 #f)
    (seek! (-> self path-pos) (-> self path-max) (* (-> self path-speed) (-> *display* seconds-per-frame)))
    (if (= (-> self path-pos) (-> self path-max))
        (go pelican-dive (-> self path-dive1) (-> self path-to-nest1) (-> *PELICAN-bank* to-nest1-time))
        )
    (none)
    )
  :code (behavior ()
    (pelican-fly
      (the-as (function pelican int) (lambda () (rand-vu-int-range 2 4)))
      (the-as (function pelican int) zero-func)
      )
    (none)
    )
  :post pelican-post
  )

;; failed to figure out what this is:
(defstate pelican-fly-to-end (pelican)
  :enter (behavior ((arg0 path-control) (arg1 time-frame))
    (process-entity-status! self (entity-perm-status complete) #t)
    (let ((v1-2 (-> self entity extra perm)))
      (logior! (-> v1-2 status) (entity-perm-status user-set-from-cstage))
      (set! (-> v1-2 user-int8 0) 10)
      )
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (set! (-> self path) arg0)
    (set! (-> self path-pos) 0.0)
    (set! (-> self path-max) (the float (+ (-> self path curve num-cverts) -1)))
    (set! (-> self path-speed) (/ (* 300.0 (-> self path-max)) (the float arg1)))
    (set! (-> self state-vector quad) (-> self root-override trans quad))
    (set! (-> self state-float 0) 0.0)
    (let ((gp-1 (new 'stack-no-clear 'vector)))
      (eval-path-curve-div! (-> self path) gp-1 0.0 'interp)
      (set! (-> self state-float 1) (* 0.0073242188 (vector-vector-distance (-> self root-override trans) gp-1)))
      )
    (none)
    )
  :trans (behavior ()
    (pelican-path-update 546133.3 30 0.0 0.0 #f)
    (seek! (-> self path-pos) (-> self path-max) (* (-> self path-speed) (-> *display* seconds-per-frame)))
    (if (= (-> self path-pos) (-> self path-max))
        (go pelican-wait-at-end #f)
        )
    (when (< (- (-> *display* base-frame-counter) (-> self state-time)) (the int (-> self state-float 1)))
      (set! (-> self state-float 0)
            (/ (the float (- (-> *display* base-frame-counter) (-> self state-time))) (-> self state-float 1))
            )
      (vector-lerp!
        (-> self root-override trans)
        (-> self state-vector)
        (-> self root-override trans)
        (-> self state-float 0)
        )
      )
    (none)
    )
  :code (behavior ((arg0 path-control) (arg1 time-frame))
    (pelican-fly
      (the-as (function pelican int) (lambda () 1))
      (lambda ((arg0 pelican)) (if (and (>= (-> arg0 path-pos) 4.0) (>= 6.0 (-> arg0 path-pos)))
                                   1
                                   0
                                   )
              )
      )
    (none)
    )
  :post pelican-post
  )

;; failed to figure out what this is:
(defstate pelican-wait-at-end (pelican)
  :code (behavior ((arg0 symbol))
    (cleanup-for-death self)
    (none)
    )
  )

;; failed to figure out what this is:
(defstate pelican-explode (pelican)
  :code (behavior ((arg0 symbol))
    (let ((v1-2 (-> self entity extra perm)))
      (logior! (-> v1-2 status) (entity-perm-status user-set-from-cstage))
      (set! (-> v1-2 user-int8 0) 5)
      )
    (when (not arg0)
      (sound-play "scrate-break")
      (process-spawn
        part-tracker
        :init part-tracker-init
        (-> *part-group-id-table* 71)
        -1
        #f
        #f
        #f
        (-> self root-override trans)
        :to *entity-pool*
        )
      )
    (let ((gp-2 (new-stack-vector0)))
      (set! (-> gp-2 quad) (-> self root-override trans quad))
      (let ((a0-7 (handle->process (-> self fuel-cell))))
        (when a0-7
          (set! (-> gp-2 quad) (-> (the-as process-drawable a0-7) root trans quad))
          (+! (-> gp-2 y) 8192.0)
          (deactivate a0-7)
          )
        )
      (when (not (task-complete? *game-info* (-> self entity extra perm task)))
        (let ((v1-29 (birth-pickup-at-point
                       gp-2
                       (pickup-type fuel-cell)
                       (the float (-> self entity extra perm task))
                       #f
                       self
                       (the-as fact-info #f)
                       )
                     )
              )
          (send-event (ppointer->process v1-29) 'movie-pos 1)
          )
        )
      )
    (clear-collide-with-as (-> self root-override))
    (ja-channel-set! 0)
    (anim-loop)
    (none)
    )
  :post (the-as (function none :behavior pelican) ja-post)
  )

;; definition for method 11 of type pelican
;; INFO: Return type mismatch object vs none.
(defmethod init-from-entity! pelican ((obj pelican) (arg0 entity-actor))
  (stack-size-set! (-> obj main-thread) 512)
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((s3-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set-vector! (-> s3-0 local-sphere) 0.0 12288.0 0.0 12288.0)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *pelican-sg* '())
  (set! (-> obj draw shadow-ctrl)
        (new 'process 'shadow-control -81920.0 4096.0 614400.0 (the-as float 25) 409600.0)
        )
  (logclear! (-> obj mask) (process-mask actor-pause))
  (set! (-> obj align) (new 'process 'align-control obj))
  (dotimes (s5-1 8)
    (let ((v1-27 (new 'process 'curve-control obj 'path (the float (+ s5-1 1)))))
      (set! (-> obj path-data s5-1) v1-27)
      (logior! (-> v1-27 flags) (path-control-flag display draw-line draw-point draw-text))
      )
    )
  (set! (-> obj fuel-cell) (the-as handle #f))
  (set! (-> obj cam-tracker) (the-as handle #f))
  (set! (-> obj neck) (new 'process 'joint-mod (joint-mod-handler-mode flex-blend) obj 9))
  (set-vector! (-> obj neck twist-max) 2730.6667 2730.6667 0.0 1.0)
  (set! (-> obj neck up) (the-as uint 1))
  (set! (-> obj neck nose) (the-as uint 2))
  (set! (-> obj neck ear) (the-as uint 0))
  (set! (-> obj neck max-dist) 61440.0)
  (set! (-> obj neck ignore-angle) 16384.0)
  (case (-> obj entity extra perm user-int8 0)
    ((10)
     (go pelican-wait-at-end #t)
     )
    ((5)
     (go pelican-wait-at-nest #t)
     )
    ((2)
     (let ((s5-2 (manipy-spawn
                   (-> obj root-override trans)
                   (-> obj entity)
                   *fuel-cell-sg*
                   (new 'static 'vector :w 4915.2)
                   :to obj
                   )
                 )
           )
       (set! (-> obj fuel-cell) (if s5-2
                                    (ppointer->handle s5-2)
                                    (the-as handle #f)
                                    )
             )
       (when s5-2
         (send-event
           (ppointer->process s5-2)
           'eval
           (lambda :behavior pelican () (let ((v0-0 (create-launch-control (-> *part-group-id-table* 63) self)))
                                          (set! (-> self part) v0-0)
                                          v0-0
                                          )
                                     )
           )
         (send-event (ppointer->process s5-2) 'trans-hook fuel-cell-animate)
         )
       )
     (go pelican-wait-at-nest #t)
     )
    (else
      (go pelican-circle)
      )
    )
  (none)
  )
