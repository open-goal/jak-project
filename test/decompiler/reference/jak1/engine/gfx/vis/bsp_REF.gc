;;-*-Lisp-*-
(in-package goal)

;; definition for function mem-usage-bsp-tree
;; INFO: Return type mismatch bsp-header vs none.
(defun mem-usage-bsp-tree ((header bsp-header) (node bsp-node) (mem-use memory-usage-block) (flags int))
  (cond
    ((zero? node)
     )
    (else
      (+! (-> mem-use data 58 count) 1)
      (let ((v1-3 32))
        (+! (-> mem-use data 58 used) v1-3)
        (+! (-> mem-use data 58 total) (logand -16 (+ v1-3 15)))
        )
      (if (> (-> node front) 0)
          (mem-usage-bsp-tree header (the-as bsp-node (-> node front)) mem-use flags)
          )
      (if (> (-> node back) 0)
          (mem-usage-bsp-tree header (the-as bsp-node (-> node back)) mem-use flags)
          )
      )
    )
  (none)
  )

;; definition for method 8 of type bsp-header
(defmethod mem-usage bsp-header ((obj bsp-header) (mem-use memory-usage-block) (flags int))
  (set! (-> mem-use work-bsp) obj)
  (when (nonzero? (-> obj info))
    (set! (-> mem-use length) (max 82 (-> mem-use length)))
    (set! (-> mem-use data 81 name) "array")
    (+! (-> mem-use data 81 count) 1)
    (let ((v1-8 (asize-of (-> obj info))))
      (+! (-> mem-use data 81 used) v1-8)
      (+! (-> mem-use data 81 total) (logand -16 (+ v1-8 15)))
      )
    )
  (if (nonzero? (-> obj drawable-trees))
      (mem-usage (-> obj drawable-trees) mem-use flags)
      )
  (set! (-> mem-use length) (max 63 (-> mem-use length)))
  (set! (-> mem-use data 43 name) "entity")
  (set! (-> mem-use data 44 name) "camera")
  (set! (-> mem-use data 62 name) "pat")
  (set! (-> mem-use data 58 name) "bsp-node")
  (set! (-> mem-use length) (max 57 (-> mem-use length)))
  (set! (-> mem-use data 56 name) "bsp-main")
  (+! (-> mem-use data 56 count) 1)
  (let ((v1-27 400))
    (+! (-> mem-use data 56 used) v1-27)
    (+! (-> mem-use data 56 total) (logand -16 (+ v1-27 15)))
    )
  (set! (-> mem-use length) (max 60 (-> mem-use length)))
  (set! (-> mem-use data 59 name) "bsp-leaf-vis-self")
  (+! (-> mem-use data 59 count) 1)
  (let ((v1-36 (-> obj visible-list-length)))
    (+! (-> mem-use data 59 used) v1-36)
    (+! (-> mem-use data 59 total) (logand -16 (+ v1-36 15)))
    )
  (set! (-> mem-use length) (max 58 (-> mem-use length)))
  (set! (-> mem-use data 57 name) "bsp-misc")
  (+! (-> mem-use data 57 count) 1)
  (let ((v1-46 (* (-> obj texture-remap-table-len) 8)))
    (+! (-> mem-use data 57 used) v1-46)
    (+! (-> mem-use data 57 total) (logand -16 (+ v1-46 15)))
    )
  (set! (-> mem-use length) (max 58 (-> mem-use length)))
  (set! (-> mem-use data 57 name) "bsp-misc")
  (+! (-> mem-use data 57 count) 1)
  (let ((v1-56 (* (-> obj texture-page-count) 4)))
    (+! (-> mem-use data 57 used) v1-56)
    (+! (-> mem-use data 57 total) (logand -16 (+ v1-56 15)))
    )
  (when (nonzero? (-> obj unk-zero-0))
    (set! (-> mem-use length) (max 58 (-> mem-use length)))
    (set! (-> mem-use data 57 name) "bsp-misc")
    (+! (-> mem-use data 57 count) 1)
    (let ((v1-68 (asize-of (-> obj unk-zero-0))))
      (+! (-> mem-use data 57 used) v1-68)
      (+! (-> mem-use data 57 total) (logand -16 (+ v1-68 15)))
      )
    )
  (when (nonzero? (-> obj adgifs))
    (set! (-> mem-use length) (max 58 (-> mem-use length)))
    (set! (-> mem-use data 57 name) "bsp-misc")
    (+! (-> mem-use data 57 count) 1)
    (let ((v1-80 (asize-of (-> obj adgifs))))
      (+! (-> mem-use data 57 used) v1-80)
      (+! (-> mem-use data 57 total) (logand -16 (+ v1-80 15)))
      )
    )
  (when (nonzero? (-> obj boxes))
    (set! (-> mem-use length) (max 58 (-> mem-use length)))
    (set! (-> mem-use data 57 name) "bsp-misc")
    (+! (-> mem-use data 57 count) 1)
    (let ((v1-92 (asize-of (-> obj boxes))))
      (+! (-> mem-use data 57 used) v1-92)
      (+! (-> mem-use data 57 total) (logand -16 (+ v1-92 15)))
      )
    (when (nonzero? (-> obj split-box-indices))
      (set! (-> mem-use length) (max 58 (-> mem-use length)))
      (set! (-> mem-use data 57 name) "bsp-misc")
      (+! (-> mem-use data 57 count) 1)
      (let ((v1-105 (* (-> obj boxes length) 2)))
        (+! (-> mem-use data 57 used) v1-105)
        (+! (-> mem-use data 57 total) (logand -16 (+ v1-105 15)))
        )
      )
    )
  (when (nonzero? (-> obj actor-birth-order))
    (set! (-> mem-use length) (max 58 (-> mem-use length)))
    (set! (-> mem-use data 57 name) "bsp-misc")
    (+! (-> mem-use data 57 count) 1)
    (let ((v1-118 (* (-> obj actors length) 4)))
      (+! (-> mem-use data 57 used) v1-118)
      (+! (-> mem-use data 57 total) (logand -16 (+ v1-118 15)))
      )
    )
  (+! (-> mem-use data 62 count) (-> obj pat-length))
  (let ((v1-125 (* (-> obj pat-length) 4)))
    (+! (-> mem-use data 62 used) v1-125)
    (+! (-> mem-use data 62 total) (logand -16 (+ v1-125 15)))
    )
  (let ((s3-0 (-> obj cameras)))
    (when (nonzero? s3-0)
      (dotimes (s2-0 (-> s3-0 length))
        (mem-usage (-> s3-0 s2-0) mem-use (logior flags 256))
        )
      )
    )
  (mem-usage-bsp-tree obj (the-as bsp-node (-> obj nodes)) mem-use flags)
  obj
  )

;; definition for method 9 of type bsp-header
(defmethod login bsp-header ((obj bsp-header))
  (if (nonzero? (-> obj drawable-trees))
      (login (-> obj drawable-trees))
      )
  (when (nonzero? (-> obj adgifs))
    (let ((s5-0 (-> obj adgifs)))
      (dotimes (s4-0 (-> s5-0 length))
        (adgif-shader-login-no-remap (-> s5-0 data s4-0))
        )
      )
    )
  obj
  )

;; definition for symbol *test-shrub*, type int
(define *test-shrub* 0)

;; definition for method 10 of type bsp-header
;; INFO: Used lq/sq
(defmethod draw bsp-header ((obj bsp-header) (other-draw bsp-header) (disp-frame display-frame))
  (local-vars (a3-4 uint128) (a3-5 uint128))
  (rlet ((vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf20 :class vf)
         (vf21 :class vf)
         (vf22 :class vf)
         (vf23 :class vf)
         (vf24 :class vf)
         (vf25 :class vf)
         (vf26 :class vf)
         (vf27 :class vf)
         (vf28 :class vf)
         (vf29 :class vf)
         (vf30 :class vf)
         (vf31 :class vf)
         )
    (let ((lev (-> obj level)))
      (set! (-> (the-as terrain-bsp #x70000000) lev-index) (-> lev index))
      (set! (-> (the-as terrain-bsp #x70000000) mood) (-> lev mood))
      (if *artist-use-menu-subdiv*
          (update-subdivide-settings! *subdivide-settings* *math-camera* 3)
          (update-subdivide-settings! *subdivide-settings* *math-camera* (-> lev index))
          )
      (add-irq-to-tex-buckets! lev)
      (let ((vis-list-qwc (/ (+ (-> obj visible-list-length) 15) 16)))
        (dma-send-to-spr-no-flush
          (the-as uint (+ #x38b0 #x70000000))
          (the-as uint (-> lev vis-bits))
          (the-as uint vis-list-qwc)
          #f
          )
        )
      )
    (when *artist-flip-visible*
      (let ((vis-list-qwc2 (/ (+ (-> obj visible-list-length) 15) 16))
            (vis-list-spad (the-as (pointer uint128) (+ #x38b0 #x70000000)))
            (vis-list-lev (the-as (pointer uint128) (-> obj all-visible-list)))
            )
        (dotimes (current-qw vis-list-qwc2)
          (let ((a3-3 (-> vis-list-spad current-qw)))
            (.pnor a3-4 a3-3 0)
            )
          (let ((t0-2 (-> vis-list-lev current-qw)))
            (.pand a3-5 a3-4 t0-2)
            )
          (set! (-> vis-list-spad current-qw) a3-5)
          )
        )
      )
    (let ((at-0 *math-camera*))
      (.lvf vf16 (&-> at-0 plane 0 quad))
      (.lvf vf17 (&-> at-0 plane 1 quad))
      (.lvf vf18 (&-> at-0 plane 2 quad))
      (.lvf vf19 (&-> at-0 plane 3 quad))
      (.lvf vf20 (&-> at-0 shrub-mat vector 0 quad))
      (.lvf vf21 (&-> at-0 shrub-mat vector 1 quad))
      (.lvf vf22 (&-> at-0 shrub-mat vector 2 quad))
      (.lvf vf23 (&-> at-0 shrub-mat vector 3 quad))
      (.lvf vf24 (&-> at-0 camera-rot vector 0 quad))
      (.lvf vf25 (&-> at-0 camera-rot vector 1 quad))
      (.lvf vf26 (&-> at-0 camera-rot vector 2 quad))
      (.lvf vf27 (&-> at-0 camera-rot vector 3 quad))
      (.lvf vf28 (&-> at-0 camera-temp vector 0 quad))
      (.lvf vf29 (&-> at-0 camera-temp vector 1 quad))
      (.lvf vf30 (&-> at-0 camera-temp vector 2 quad))
      (.lvf vf31 (&-> at-0 camera-temp vector 3 quad))
      )
    (when (nonzero? (-> obj drawable-trees))
      (if *debug-segment*
          (add-frame
            (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
            'draw
            (new 'static 'rgba :r #x40 :b #x40 :a #x80)
            )
          )
      (let ((a1-7 (-> obj drawable-trees)))
        (draw a1-7 a1-7 disp-frame)
        )
      (if *debug-segment*
          (add-frame
            (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
            'draw
            (new 'static 'rgba :r #x80 :g #xc0 :a #x80)
            )
          )
      )
    (let ((s5-1 (-> *display* frames (-> *display* on-screen) frame)))
      (foreground-engine-execute
        (-> obj level foreground-draw-engine 0)
        s5-1
        (-> (the-as terrain-bsp #x70000000) lev-index)
        0
        )
      (foreground-engine-execute
        (-> obj level foreground-draw-engine 1)
        s5-1
        (-> (the-as terrain-bsp #x70000000) lev-index)
        1
        )
      (foreground-engine-execute
        (-> obj level foreground-draw-engine 2)
        s5-1
        (-> (the-as terrain-bsp #x70000000) lev-index)
        2
        )
      )
    (none)
    )
  )

;; definition for method 15 of type bsp-header
;; INFO: Return type mismatch profile-frame vs none.
(defmethod debug-draw bsp-header ((obj bsp-header) (arg0 drawable) (arg1 display-frame))
  (rlet ((vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf20 :class vf)
         (vf21 :class vf)
         (vf22 :class vf)
         (vf23 :class vf)
         (vf24 :class vf)
         (vf25 :class vf)
         (vf26 :class vf)
         (vf27 :class vf)
         (vf28 :class vf)
         (vf29 :class vf)
         (vf30 :class vf)
         (vf31 :class vf)
         )
    (let ((s4-0 (-> obj level)))
      (set! (-> (the-as terrain-bsp #x70000000) lev-index) (-> s4-0 index))
      (set! (-> (the-as terrain-bsp #x70000000) mood) (-> s4-0 mood))
      (add-irq-to-tex-buckets! s4-0)
      (let ((a2-1 (/ (+ (-> obj visible-list-length) 15) 16)))
        (dma-send-to-spr-no-flush
          (the-as uint (+ #x38b0 #x70000000))
          (the-as uint (-> s4-0 vis-bits))
          (the-as uint a2-1)
          #f
          )
        )
      )
    (let ((at-0 *math-camera*))
      (.lvf vf16 (&-> at-0 plane 0 quad))
      (.lvf vf17 (&-> at-0 plane 1 quad))
      (.lvf vf18 (&-> at-0 plane 2 quad))
      (.lvf vf19 (&-> at-0 plane 3 quad))
      (.lvf vf20 (&-> at-0 shrub-mat vector 0 quad))
      (.lvf vf21 (&-> at-0 shrub-mat vector 1 quad))
      (.lvf vf22 (&-> at-0 shrub-mat vector 2 quad))
      (.lvf vf23 (&-> at-0 shrub-mat vector 3 quad))
      (.lvf vf24 (&-> at-0 camera-rot vector 0 quad))
      (.lvf vf25 (&-> at-0 camera-rot vector 1 quad))
      (.lvf vf26 (&-> at-0 camera-rot vector 2 quad))
      (.lvf vf27 (&-> at-0 camera-rot vector 3 quad))
      (.lvf vf28 (&-> at-0 camera-temp vector 0 quad))
      (.lvf vf29 (&-> at-0 camera-temp vector 1 quad))
      (.lvf vf30 (&-> at-0 camera-temp vector 2 quad))
      (.lvf vf31 (&-> at-0 camera-temp vector 3 quad))
      )
    (when (nonzero? (-> obj drawable-trees))
      (if *debug-segment*
          (add-frame
            (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
            'draw
            (new 'static 'rgba :r #x40 :b #x40 :a #x80)
            )
          )
      (let ((a1-3 (-> obj drawable-trees)))
        (debug-draw a1-3 a1-3 arg1)
        )
      (if *debug-segment*
          (add-frame
            (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
            'draw
            (new 'static 'rgba :r #x80 :g #xc0 :a #x80)
            )
          )
      )
    (none)
    )
  )

;; definition for method 14 of type bsp-header
(defmethod collect-stats bsp-header ((obj bsp-header))
  (rlet ((vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf20 :class vf)
         (vf21 :class vf)
         (vf22 :class vf)
         (vf23 :class vf)
         (vf24 :class vf)
         (vf25 :class vf)
         (vf26 :class vf)
         (vf27 :class vf)
         (vf28 :class vf)
         (vf29 :class vf)
         (vf30 :class vf)
         (vf31 :class vf)
         )
    (let ((v1-0 (-> obj level))
          (a2-0 (/ (+ (-> obj visible-list-length) 15) 16))
          )
      (dma-send-to-spr-no-flush
        (the-as uint (+ #x38b0 #x70000000))
        (the-as uint (-> v1-0 vis-bits))
        (the-as uint a2-0)
        #f
        )
      )
    (let ((at-0 *math-camera*))
      (.lvf vf16 (&-> at-0 plane 0 quad))
      (.lvf vf17 (&-> at-0 plane 1 quad))
      (.lvf vf18 (&-> at-0 plane 2 quad))
      (.lvf vf19 (&-> at-0 plane 3 quad))
      (.lvf vf20 (&-> at-0 shrub-mat vector 0 quad))
      (.lvf vf21 (&-> at-0 shrub-mat vector 1 quad))
      (.lvf vf22 (&-> at-0 shrub-mat vector 2 quad))
      (.lvf vf23 (&-> at-0 shrub-mat vector 3 quad))
      (.lvf vf24 (&-> at-0 camera-rot vector 0 quad))
      (.lvf vf25 (&-> at-0 camera-rot vector 1 quad))
      (.lvf vf26 (&-> at-0 camera-rot vector 2 quad))
      (.lvf vf27 (&-> at-0 camera-rot vector 3 quad))
      (.lvf vf28 (&-> at-0 camera-temp vector 0 quad))
      (.lvf vf29 (&-> at-0 camera-temp vector 1 quad))
      (.lvf vf30 (&-> at-0 camera-temp vector 2 quad))
      (.lvf vf31 (&-> at-0 camera-temp vector 3 quad))
      )
    (if (nonzero? (-> obj drawable-trees))
        (collect-stats (-> obj drawable-trees))
        )
    (none)
    )
  )

;; definition for function bsp-camera-asm
;; INFO: Return type mismatch int vs none.
;; ERROR: Function may read a register that is not set: a2
(defun bsp-camera-asm ((bsp-hdr bsp-header) (camera-pos vector))
  (local-vars (v1-1 float) (real-node bsp-node))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         )
    (nop!)
    (let ((next-node (the-as bsp-node (-> bsp-hdr nodes))))
      (.lvf vf1 (&-> camera-pos quad))
      (label cfg-1)
      (b! (< (the-as int next-node) 0) cfg-4 :delay (set! real-node next-node))
      (.lvf vf2 (&-> real-node plane quad))
      (.mul.vf vf2 vf2 vf1 :mask #b111)
      (.add.x.vf vf2 vf2 vf2 :mask #b10)
      (.add.z.vf vf2 vf2 vf2 :mask #b10)
      (.sub.w.vf vf2 vf2 vf2 :mask #b10)
      (.mov v1-1 vf2)
      (let ((a2-0 (-> real-node front-flags)))
        (b! (>= (the-as int v1-1) 0) cfg-1 :delay (set! next-node (the-as bsp-node (-> real-node front))))
        (set! a2-0 (-> real-node back-flags))
        (b! #t cfg-1 :delay (set! next-node (the-as bsp-node (-> real-node back))))
        (label cfg-4)
        (set! (-> bsp-hdr current-leaf-idx) (the-as uint next-node))
        (set! (-> bsp-hdr current-bsp-back-flags) a2-0)
        )
      )
    0
    (none)
    )
  )

;; definition for method 11 of type bsp-header
;; INFO: Return type mismatch symbol vs none.
(defmethod collide-with-box bsp-header ((obj bsp-header) (arg0 int) (arg1 collide-list))
  (+! (-> *collide-stats* calls) 1)
  (let ((s4-0 (-> obj drawable-trees)))
    (dotimes (s3-0 (-> s4-0 length))
      (collide-with-box (-> s4-0 trees s3-0) arg0 arg1)
      )
    )
  (none)
  )

;; definition for method 12 of type bsp-header
;; INFO: Return type mismatch symbol vs none.
(defmethod collide-y-probe bsp-header ((obj bsp-header) (arg0 int) (arg1 collide-list))
  (+! (-> *collide-stats* calls) 1)
  (let ((s4-0 (-> obj drawable-trees)))
    (dotimes (s3-0 (-> s4-0 length))
      (collide-y-probe (-> s4-0 trees s3-0) arg0 arg1)
      )
    )
  (none)
  )

;; definition for method 13 of type bsp-header
;; INFO: Return type mismatch symbol vs none.
(defmethod collide-ray bsp-header ((obj bsp-header) (arg0 int) (arg1 collide-list))
  (+! (-> *collide-stats* calls) 1)
  (let ((s4-0 (-> obj drawable-trees)))
    (dotimes (s3-0 (-> s4-0 length))
      (collide-ray (-> s4-0 trees s3-0) arg0 arg1)
      )
    )
  (none)
  )

;; definition for method 17 of type bsp-header
;; INFO: Return type mismatch symbol vs none.
(defmethod collect-ambients bsp-header ((obj bsp-header) (arg0 sphere) (arg1 int) (arg2 ambient-list))
  (let ((s3-0 (-> obj drawable-trees)))
    (dotimes (s2-0 (-> s3-0 length))
      (collect-ambients (-> s3-0 trees s2-0) arg0 arg1 arg2)
      )
    )
  (none)
  )

;; definition for function clear-cl-stat
;; INFO: Return type mismatch int vs none.
(defun clear-cl-stat ((arg0 cl-stat))
  (set! (-> arg0 fragments) (the-as uint 0))
  (set! (-> arg0 tris) (the-as uint 0))
  (set! (-> arg0 output) (the-as uint 0))
  0
  (none)
  )

;; definition for function print-cl-stat
;; INFO: Return type mismatch uint vs none.
(defun print-cl-stat ((arg0 cl-stat) (arg1 string))
  (when (nonzero? (+ (-> arg0 fragments) (-> arg0 tris)))
    (format
      *stdcon*
      "~0k~5d/~d   ~6d/~d   ~6d/~d      "
      (-> arg0 fragments)
      (/ (-> arg0 fragments) (-> *collide-stats* calls))
      (-> arg0 tris)
      (/ (-> arg0 tris) (-> *collide-stats* calls))
      (-> arg0 output)
      (/ (-> arg0 output) (-> *collide-stats* calls))
      )
    (format *stdcon* "~0k~s~%" arg1)
    (+! (-> *collide-stats* total fragments) (-> arg0 fragments))
    (+! (-> *collide-stats* total tris) (-> arg0 tris))
    (+! (-> *collide-stats* total output) (-> arg0 output))
    )
  (none)
  )

;; definition for function print-collide-stats
;; INFO: Return type mismatch int vs none.
(defun print-collide-stats ()
  (if *debug-segment*
      (add-frame
        (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
        'draw
        (new 'static 'rgba :r #x40 :b #x40 :a #x80)
        )
      )
  (format *stdcon* "~0k  frags       tris      output~%")
  (print-cl-stat (-> *collide-stats* other) "other")
  (format *stdcon* "~0k---------------------------------------------------------------~%")
  (print-cl-stat (-> *collide-stats* total) "total")
  (format *stdcon* "~0kcalls = ~d~%" (-> *collide-stats* calls))
  (let ((gp-0 (stopwatch-elapsed-ticks (-> *collide-stats* total-target)))
        (s4-0 (stopwatch-elapsed-ticks (-> *collide-stats* target-cache-fill)))
        (s5-0 (stopwatch-elapsed-ticks (-> *collide-stats* target-ray-poly)))
        )
    (format *stdcon* "~0ktotal-target      ~D~%" gp-0)
    (format *stdcon* "~0ktarget-cache-fill ~D ~0,,2f%~%" s4-0 (/ (* 100.0 (the float s4-0)) (the float gp-0)))
    (format *stdcon* "~0ktarget-ray-poly   ~D ~0,,2f%~%" s5-0 (/ (* 100.0 (the float s5-0)) (the float gp-0)))
    )
  (clear-cl-stat (-> *collide-stats* other))
  (clear-cl-stat (-> *collide-stats* total))
  (set! *collide-nodes* 0)
  (set! (-> *collide-stats* calls) (the-as uint 0))
  (stopwatch-init (-> *collide-stats* total-target))
  (stopwatch-init (-> *collide-stats* target-cache-fill))
  (stopwatch-init (-> *collide-stats* target-ray-poly))
  (if *debug-segment*
      (add-frame
        (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
        'draw
        (new 'static 'rgba :b #xff :a #x80)
        )
      )
  0
  (none)
  )

;; definition for function level-remap-texture
;; INFO: Return type mismatch int vs texture-id.
(defun level-remap-texture ((tex-id texture-id))
  (let ((bsp-hdr (-> *level* log-in-level-bsp)))
    (when bsp-hdr
      (let* ((table-size (-> bsp-hdr texture-remap-table-len))
             (table-data-start (-> bsp-hdr texture-remap-table))
             (table-data-ptr table-data-start)
             (mask1 (the-as uint #xfffffff8))
             (masked-tex-id (logand (new 'static 'texture-id :index #xfff :page #xfff) tex-id))
             (table-data-end (&+ table-data-ptr (* table-size 8)))
             )
        (label cfg-2)
        (b! (= (the-as object table-data-start) table-data-end) cfg-8 :delay (nop!))
        (let ((midpoint (the-as
                          object
                          (logand (/ (the-as int (+ (the-as int table-data-start) (the-as int table-data-end))) 2) mask1)
                          )
                        )
              )
          (let ((diff (- (-> (the-as (pointer int32) midpoint) 0) (the-as int masked-tex-id))))
            (b! (zero? diff) cfg-7 :delay (nop!))
            (b! (< diff 0) cfg-6 :delay (nop!))
            )
          (b! #t cfg-2 :delay (set! table-data-end (the-as (pointer uint64) midpoint)))
          (label cfg-6)
          (b! #t cfg-2 :delay (set! table-data-start (the-as (pointer uint64) (+ (the-as int midpoint) 8))))
          (label cfg-7)
          (set! tex-id (the-as texture-id (logior (-> (the-as (pointer int32) midpoint) 1) 20)))
          )
        )
      (label cfg-8)
      0
      )
    )
  (the-as texture-id tex-id)
  )
