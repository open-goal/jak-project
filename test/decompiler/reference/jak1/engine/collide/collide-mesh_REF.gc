;;-*-Lisp-*-
(in-package goal)

;; definition for method 5 of type collide-mesh
;; INFO: Return type mismatch uint vs int.
(defmethod asize-of collide-mesh ((obj collide-mesh))
  (the-as int (+ (-> collide-mesh size) (* (+ (-> obj num-tris) -1) 8)))
  )

;; definition for method 8 of type collide-mesh
;; INFO: Return type mismatch int vs collide-mesh.
(defmethod mem-usage collide-mesh ((obj collide-mesh) (arg0 memory-usage-block) (arg1 int))
  (set! (-> arg0 length) (max 79 (-> arg0 length)))
  (set! (-> arg0 data 78 name) "collide-mesh")
  (+! (-> arg0 data 78 count) 1)
  (let ((v1-6 (asize-of obj)))
    (+! (-> arg0 data 78 used) v1-6)
    (+! (-> arg0 data 78 total) (logand -16 (+ v1-6 15)))
    )
  (set! (-> arg0 length) (max 79 (-> arg0 length)))
  (set! (-> arg0 data 78 name) "collide-mesh")
  (+! (-> arg0 data 78 count) 1)
  (let ((v1-16 (* (-> obj num-verts) 16)))
    (+! (-> arg0 data 78 used) v1-16)
    (+! (-> arg0 data 78 total) (logand -16 (+ v1-16 15)))
    )
  (the-as collide-mesh 0)
  )

;; definition for method 9 of type collide-mesh
;; INFO: Return type mismatch int vs none.
(defmethod debug-draw-tris collide-mesh ((obj collide-mesh) (arg0 process-drawable) (arg1 int))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (the-as object (-> obj tris)))
          (s4-0 (-> arg0 node-list data arg1 bone transform))
          )
      (countdown (s3-0 (-> obj num-tris))
        (let ((a2-1 (new 'stack-no-clear 'vector))
              (a3-0 (new 'stack-no-clear 'vector))
              (t0-0 (new 'stack-no-clear 'vector))
              )
          (.lvf vf4 (&-> s4-0 vector 0 quad))
          (.lvf vf5 (&-> s4-0 vector 1 quad))
          (.lvf vf6 (&-> s4-0 vector 2 quad))
          (.lvf vf7 (&-> s4-0 vector 3 quad))
          (.lvf vf1 (&-> (-> obj vertex-data (-> (the-as collide-mesh-tri s5-0) vertex-index 0)) quad))
          (.lvf vf2 (&-> (-> obj vertex-data (-> (the-as collide-mesh-tri s5-0) vertex-index 1)) quad))
          (.lvf vf3 (&-> (-> obj vertex-data (-> (the-as collide-mesh-tri s5-0) vertex-index 2)) quad))
          (let ((t1-0 (copy-and-set-field (-> *pat-mode-info* (-> (the-as collide-mesh-tri s5-0) pat mode) color) a 16)))
            (.mul.w.vf acc vf7 vf0)
            (.add.mul.x.vf acc vf4 vf1 acc)
            (.add.mul.y.vf acc vf5 vf1 acc)
            (.add.mul.z.vf vf1 vf6 vf1 acc)
            (.mul.w.vf acc vf7 vf0)
            (.add.mul.x.vf acc vf4 vf2 acc)
            (.add.mul.y.vf acc vf5 vf2 acc)
            (.add.mul.z.vf vf2 vf6 vf2 acc)
            (.mul.w.vf acc vf7 vf0)
            (.add.mul.x.vf acc vf4 vf3 acc)
            (.add.mul.y.vf acc vf5 vf3 acc)
            (.add.mul.z.vf vf3 vf6 vf3 acc)
            (.svf (&-> a2-1 quad) vf1)
            (.svf (&-> a3-0 quad) vf2)
            (.svf (&-> t0-0 quad) vf3)
            (add-debug-flat-triangle #t (bucket-id debug-no-zbuf) a2-1 a3-0 t0-0 t1-0)
            )
          )
        (set! s5-0 (-> (the-as (inline-array collide-mesh-tri) s5-0) 1))
        )
      )
    0
    (none)
    )
  )

;; definition of type sopt-work
(deftype sopt-work (structure)
  ((intersect     vector         :inline :offset-assert   0)
   (sphere-bbox4w bounding-box4w :inline :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x30
  :flag-assert         #x900000030
  )

;; definition for method 3 of type sopt-work
(defmethod inspect sopt-work ((obj sopt-work))
  (format #t "[~8x] ~A~%" obj 'sopt-work)
  (format #t "~Tintersect: #<vector @ #x~X>~%" (-> obj intersect))
  (format #t "~Tsphere-bbox4w: #<bounding-box4w @ #x~X>~%" (-> obj sphere-bbox4w))
  obj
  )

;; definition for method 12 of type collide-mesh
;; INFO: function output is handled by mips2c
(defmethod-mips2c "(method 12 collide-mesh)" 12 collide-mesh)

;; definition of type spat-work
(deftype spat-work (structure)
  ((intersect     vector         :inline :offset-assert   0)
   (sphere-bbox4w bounding-box4w :inline :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x30
  :flag-assert         #x900000030
  )

;; definition for method 3 of type spat-work
(defmethod inspect spat-work ((obj spat-work))
  (format #t "[~8x] ~A~%" obj 'spat-work)
  (format #t "~Tintersect: #<vector @ #x~X>~%" (-> obj intersect))
  (format #t "~Tsphere-bbox4w: #<bounding-box4w @ #x~X>~%" (-> obj sphere-bbox4w))
  obj
  )

;; definition for method 11 of type collide-mesh
;; INFO: function output is handled by mips2c
(defmethod-mips2c "(method 11 collide-mesh)" 11 collide-mesh)

;; definition for method 14 of type collide-mesh
;; INFO: function output is handled by mips2c
(defmethod-mips2c "(method 14 collide-mesh)" 14 collide-mesh)

;; definition for method 15 of type collide-mesh
;; INFO: function output is handled by mips2c
(defmethod-mips2c "(method 15 collide-mesh)" 15 collide-mesh)

;; definition for method 9 of type collide-mesh-cache
;; INFO: Return type mismatch (pointer uint8) vs int.
(defmethod allocate! collide-mesh-cache ((obj collide-mesh-cache) (arg0 int))
  (local-vars (a1-2 int) (a2-2 int))
  (let* ((v1-0 (+ arg0 15))
         (a1-1 (-> obj used-size))
         (v1-1 (/ v1-0 16))
         (a3-0 (-> obj data))
         (a2-0 (-> obj max-size))
         (v1-2 (* v1-1 16))
         (a3-1 (&+ a3-0 a1-1))
         )
    (let ((t1-0 (- a2-0 (the-as uint v1-2)))
          (t0-0 (-> obj id))
          )
      (b! (< (the-as int t1-0) 0) cfg-6 :delay (set! a1-2 (the-as int (+ a1-1 v1-2))))
      (b! (>= (the-as int (- a2-0 (the-as uint a1-2))) 0) cfg-5 :delay (set! a2-2 (the-as int (+ t0-0 1))))
      )
    (b! (zero? (the-as uint a2-2)) cfg-4 :likely-delay (set! a2-2 1))
    (label cfg-4)
    (set! a1-2 v1-2)
    (set! a3-1 (-> obj data))
    (set! (-> obj id) (the-as uint a2-2))
    (label cfg-5)
    (set! (-> obj used-size) (the-as uint a1-2))
    (let ((v0-0 a3-1))
      (b! #t cfg-7 :delay (nop!))
      (label cfg-6)
      (format 0 "ERROR: Attempted to allocate something bigger than the entire mesh cache!~%")
      (set! v0-0 (the-as (pointer uint8) #f))
      (label cfg-7)
      (the-as int v0-0)
      )
    )
  )

;; definition for method 13 of type collide-mesh
;; INFO: Return type mismatch int vs none.
;; WARN: Failed load: (set! vf1 (l.vf t0-4)) at op 77
;; WARN: Failed load: (set! vf2 (l.vf t1-1)) at op 79
;; WARN: Failed load: (set! vf3 (l.vf t2-2)) at op 81
(defmethod populate-cache! collide-mesh ((obj collide-mesh) (arg0 collide-mesh-cache-tri) (arg1 matrix))
  (local-vars (t0-2 uint))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf12 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (nop!)
    (let ((t0-0 #x70000000)
          (v1-0 (-> obj num-verts))
          )
      (nop!)
      (let ((a3-0 (-> obj vertex-data)))
        (b! (zero? v1-0) cfg-3 :delay (.lvf vf1 (&-> arg1 vector 0 quad)))
        (nop!)
        (.lvf vf2 (&-> arg1 vector 1 quad))
        (let ((t0-1 (+ t0-0 -64)))
          (.lvf vf3 (&-> arg1 vector 2 quad))
          (nop!)
          (.lvf vf4 (&-> arg1 vector 3 quad))
          (nop!)
          (.lvf vf5 (&-> a3-0 0 quad))
          (nop!)
          (.lvf vf6 (&-> a3-0 1 quad))
          (nop!)
          (.lvf vf7 (&-> a3-0 2 quad))
          (nop!)
          (.lvf vf8 (&-> a3-0 3 quad))
          (label cfg-2)
          (.mul.w.vf acc vf4 vf0)
          (set! a3-0 (the-as (inline-array vector) (-> a3-0 4)))
          (.add.mul.x.vf acc vf1 vf5 acc)
          (+! t0-1 64)
          (.add.mul.y.vf acc vf2 vf5 acc)
          (nop!)
          (.add.mul.z.vf vf9 vf3 vf5 acc)
          (nop!)
          (.mul.w.vf acc vf4 vf0)
          (.lvf vf5 (&-> a3-0 0 quad))
          (.add.mul.x.vf acc vf1 vf6 acc)
          (nop!)
          (.add.mul.y.vf acc vf2 vf6 acc)
          (nop!)
          (.add.mul.z.vf vf10 vf3 vf6 acc)
          (nop!)
          (.mul.w.vf acc vf4 vf0)
          (.lvf vf6 (&-> a3-0 1 quad))
          (.add.mul.x.vf acc vf1 vf7 acc)
          (nop!)
          (.add.mul.y.vf acc vf2 vf7 acc)
          (nop!)
          (.add.mul.z.vf vf11 vf3 vf7 acc)
          (nop!)
          (.mul.w.vf acc vf4 vf0)
          (.lvf vf7 (&-> a3-0 2 quad))
          (.add.mul.x.vf acc vf1 vf8 acc)
          (nop!)
          (.add.mul.y.vf acc vf2 vf8 acc)
          (nop!)
          (.add.mul.z.vf vf12 vf3 vf8 acc)
          (nop!)
          (nop!)
          (.lvf vf8 (&-> a3-0 3 quad))
          (+! v1-0 -4)
          (s.vf! t0-1 vf9)
          (nop!)
          (s.vf! (+ t0-1 16) vf10)
          (nop!)
          (s.vf! (+ t0-1 32) vf11)
          (b! (> (the-as int v1-0) 0) cfg-2 :delay (s.vf! (+ t0-1 48) vf12))
          )
        )
      )
    (label cfg-3)
    (let ((v1-1 (the-as collide-mesh-tri (-> obj tris))))
      (nop!)
      (let ((a2-1 #x70000000)
            (a0-1 (-> obj num-tris))
            )
        (b! (zero? a0-1) cfg-6 :delay (set! t0-2 (-> v1-1 vertex-index 0)))
        (let* ((a1-1 (+ (the-as uint arg0) -96))
               (a3-1 (-> v1-1 vertex-index 1))
               (t0-3 (* t0-2 16))
               (t2-0 (-> v1-1 vertex-index 2))
               (t1-0 (* a3-1 16))
               (a3-2 (-> v1-1 pat))
               )
          (let* ((t2-1 (* t2-0 16))
                 (t0-4 (+ t0-3 a2-1))
                 (t1-1 (+ t1-0 a2-1))
                 (t2-2 (+ t2-1 a2-1))
                 )
            (label cfg-5)
            (+! a0-1 -1)
            (.lvf vf1 t0-4)
            (&+! v1-1 8)
            (.lvf vf2 t1-1)
            (&+! a1-1 96)
            (.lvf vf3 t2-2)
            (.sub.vf vf4 vf2 vf1)
            (.svf (&-> a1-1 vertex 0 quad) vf1)
            (.min.vf vf8 vf1 vf2)
            (.svf (&-> a1-1 vertex 1 quad) vf2)
            (.sub.vf vf5 vf3 vf1)
            (.svf (&-> a1-1 vertex 2 quad) vf3)
            (.max.vf vf9 vf1 vf2)
            (let ((t1-2 (-> v1-1 vertex-index 0)))
              (.outer.product.a.vf acc vf4 vf5)
              (let ((t2-3 (-> v1-1 vertex-index 1)))
                (.outer.product.b.vf vf6 vf5 vf4 acc)
                (let ((t0-5 (-> v1-1 vertex-index 2)))
                  (.mul.vf vf7 vf6 vf6)
                  (nop!)
                  (.min.vf vf8 vf8 vf3)
                  (let ((t1-3 (* t1-2 16)))
                    (.max.vf vf9 vf9 vf3)
                    (let ((t2-4 (* t2-3 16)))
                      (.mul.x.vf acc vf0 vf7 :mask #b1000)
                      (let ((t3-0 (* t0-5 16)))
                        (.add.mul.y.vf acc vf0 vf7 acc :mask #b1000)
                        (set! t0-4 (+ t1-3 a2-1))
                        (.add.mul.z.vf vf7 vf0 vf7 acc :mask #b1000)
                        (set! t1-1 (+ t2-4 a2-1))
                        (.isqrt.vf Q vf0 vf7 :fsf #b11 :ftf #b11)
                        (set! t2-2 (+ t3-0 a2-1))
                        )
                      )
                    )
                  )
                )
              )
            )
          (.ftoi.vf vf8 vf8)
          (nop!)
          (.ftoi.vf vf9 vf9)
          (nop!)
          (nop!)
          (.svf (&-> a1-1 bbox4w min quad) vf8)
          (.wait.vf)
          (.svf (&-> a1-1 bbox4w max quad) vf9)
          (.mul.vf vf6 vf6 Q :mask #b111)
          (nop!)
          (nop!)
          (.svf (&-> a1-1 normal quad) vf6)
          (nop!)
          (set! (-> a1-1 normal w) (the-as float a3-2))
          (b! (nonzero? a0-1) cfg-5 :delay (set! a3-2 (-> v1-1 pat)))
          )
        )
      )
    (label cfg-6)
    0
    (none)
    )
  )

;; definition of type oot-work
(deftype oot-work (structure)
  ((intersect     vector         :inline :offset-assert   0)
   (sphere-bbox4w bounding-box4w :inline :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x30
  :flag-assert         #x900000030
  )

;; definition for method 3 of type oot-work
(defmethod inspect oot-work ((obj oot-work))
  (format #t "[~8x] ~A~%" obj 'oot-work)
  (format #t "~Tintersect: #<vector @ #x~X>~%" (-> obj intersect))
  (format #t "~Tsphere-bbox4w: #<bounding-box4w @ #x~X>~%" (-> obj sphere-bbox4w))
  obj
  )

;; definition for method 10 of type collide-mesh
;; INFO: Used lq/sq
(defmethod overlap-test collide-mesh ((obj collide-mesh) (arg0 collide-mesh-cache-tri) (arg1 vector))
  (local-vars
    (v1-0 uint128)
    (a0-1 uint128)
    (a1-2 uint128)
    (a1-3 uint128)
    (a1-4 uint128)
    (a1-7 float)
    (a2-1 uint128)
    (a2-2 uint128)
    )
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (new 'stack-no-clear 'matrix))
          (s4-0 arg0)
          )
      (.lvf vf2 (&-> arg1 quad))
      (let ((s3-0 (-> obj num-tris)))
        (.sub.w.vf vf5 vf2 vf2)
        (.add.w.vf vf6 vf2 vf2)
        (.ftoi.vf vf5 vf5)
        (.ftoi.vf vf6 vf6)
        (.mov v1-0 vf5)
        (.svf (&-> s5-0 vector 1 quad) vf5)
        (.mov a0-1 vf6)
        (.svf (&-> s5-0 vector 2 quad) vf6)
        (label cfg-1)
        (b! (zero? s3-0) cfg-7 :delay (set! a2-1 (-> s4-0 bbox4w min quad)))
        (+! s3-0 -1)
        )
      (let ((a1-1 (-> s4-0 bbox4w max quad)))
        (.pcgtw a2-2 a2-1 a0-1)
        (nop!)
        (.pcgtw a1-2 v1-0 a1-1)
        )
      (nop!)
      (.por a1-3 a2-2 a1-2)
      (nop!)
      (.ppach a1-4 (the-as uint128 0) a1-3)
      (nop!)
      (let ((a1-5 (shl (the-as int a1-4) 16)))
        (nop!)
        (b! (nonzero? a1-5) cfg-1 :likely-delay (set! s4-0 (+ s4-0 96)))
        )
      (closest-pt-in-triangle
        (the-as vector (-> s5-0 vector))
        arg1
        (the-as matrix (-> s4-0 vertex))
        (-> s4-0 normal)
        )
      (.lvf vf1 (&-> s5-0 vector 0 quad))
      (.lvf vf2 (&-> arg1 quad))
      (set! v1-0 (-> s5-0 vector 1 quad))
      (set! a0-1 (-> s5-0 vector 2 quad))
      (.sub.vf vf3 vf2 vf1)
      (.mul.w.vf vf4 vf2 vf2 :mask #b1000)
      (.mul.vf vf3 vf3 vf3)
      (.mul.x.vf acc vf0 vf3 :mask #b1000)
      (.add.mul.y.vf acc vf0 vf3 acc :mask #b1000)
      (.add.mul.z.vf vf3 vf0 vf3 acc :mask #b1000)
      (.sub.w.vf vf3 vf3 vf4 :mask #b1000)
      (.add.w.vf vf3 vf0 vf3 :mask #b10)
      (.mov a1-7 vf3)
      (b! (>= (the-as int a1-7) 0) cfg-1 :delay (set! s4-0 (+ s4-0 96)))
      )
    (let ((v0-1 #t))
      (b! #t cfg-8 :delay (nop!))
      (the-as none 0)
      (label cfg-7)
      (set! v0-1 #f)
      (label cfg-8)
      v0-1
      )
    )
  )
