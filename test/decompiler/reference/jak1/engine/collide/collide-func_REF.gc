;;-*-Lisp-*-
(in-package goal)

;; definition for function raw-ray-sphere-intersect
;; INFO: Return type mismatch number vs float.
;; ERROR: Bad vector register dependency: vf1
;; ERROR: Bad vector register dependency: vf2
(defun raw-ray-sphere-intersect ((arg0 float))
  (local-vars (v1-1 float) (v1-2 float) (v1-4 number) (a0-1 float) (a0-2 float) (a0-3 float) (a1-0 float))
  (rlet ((Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (.mov vf3 arg0)
    (.mul.vf vf4 vf2 vf2)
    (.mul.vf vf3 vf3 vf3)
    (.mul.vf vf6 vf1 vf1)
    (.mul.vf vf5 vf2 vf1)
    (.add.y.vf vf4 vf4 vf4 :mask #b1)
    (let ((result (the-as float 0)))
      (.add.x.vf vf6 vf6 vf6 :mask #b10)
      (.sub.x.vf vf6 vf6 vf3 :mask #b100)
      (.add.z.vf vf4 vf4 vf4 :mask #b1)
      (.add.x.vf vf5 vf5 vf5 :mask #b10)
      (let ((v1-0 (the-as float 0)))
        (.add.z.vf vf6 vf6 vf6 :mask #b10)
        (.div.vf Q vf0 vf4 :fsf #b11 :ftf #b0)
        (.add.z.vf vf5 vf5 vf5 :mask #b10)
        (.mov a0-1 vf4)
        (.mul.x.vf vf7 vf6 vf4)
        (.mov a1-0 vf6)
        (.mul.vf vf8 vf5 vf5)
        (b! (< (the-as int a1-0) 0) cfg-7 :delay (set! a0-2 a0-1))
        (.mul.vf vf4 vf0 Q :mask #b1000)
        (.sub.vf vf9 vf8 vf7)
        (b! (= a0-2 v1-0) cfg-6 :delay (.mov v1-1 vf5))
        )
      (.sqrt.vf Q vf9 :ftf #b1)
      (b! (>= (the-as int v1-1) 0) cfg-6 :delay (.mov v1-2 vf9))
      (b! (< (the-as int v1-2) 0) cfg-6 :delay 1.0)
      (.add.x.vf vf6 vf5 vf4)
      (.mov v1-4 vf6)
      (.mul.vf vf6 vf6 vf6)
      (.mul.vf vf9 vf0 Q :mask #b1000)
      (.sub.vf vf6 vf9 vf6)
      (.add.w.vf vf9 vf5 vf9 :mask #b10)
      (.mov a0-3 vf6)
      (.mul.w.vf vf9 vf9 vf4 :mask #b10)
      (b! (< (logand (the-as uint v1-4) (the-as uint a0-3)) 0) cfg-6 :delay (.sub.y.vf vf4 vf0 vf9))
      (b! #t cfg-7 :delay (.mov result vf4))
      (label cfg-6)
      (set! result -100000000.0)
      (label cfg-7)
      (the-as float result)
      )
    )
  )

;; definition for function ray-sphere-intersect
(defun ray-sphere-intersect ((ray-origin vector) (ray-dir vector) (sph-origin vector) (radius float))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         )
    (.lvf vf1 (&-> ray-origin quad))
    (.lvf vf2 (&-> sph-origin quad))
    (.sub.vf vf1 vf1 vf2)
    (.lvf vf2 (&-> ray-dir quad))
    (raw-ray-sphere-intersect radius)
    )
  )

;; definition for function ray-circle-intersect
(defun ray-circle-intersect ((ray-origin vector) (ray-dir vector) (circle-origin vector) (radius float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf1 (&-> ray-origin quad))
    (.mov.vf vf1 vf0 :mask #b10)
    (.lvf vf2 (&-> circle-origin quad))
    (.mov.vf vf2 vf0 :mask #b10)
    (.sub.vf vf1 vf1 vf2)
    (.lvf vf2 (&-> ray-dir quad))
    (.mov.vf vf2 vf0 :mask #b10)
    (raw-ray-sphere-intersect radius)
    )
  )

;; definition for function ray-cylinder-intersect
;; WARN: Using logior on floats
(defun ray-cylinder-intersect ((ray-origin vector)
                      (ray-dir vector)
                      (cyl-origin vector)
                      (cyl-axis vector)
                      (cyl-rad float)
                      (cyl-len float)
                      (arg6 vector)
                      )
  (local-vars (v0-1 float) (v1-0 number) (v1-2 float) (a0-1 uint) (a0-2 float) (a0-4 float) (a0-5 float))
  (rlet ((vf1 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf12 :class vf)
         (vf13 :class vf)
         (vf14 :class vf)
         (vf15 :class vf)
         (vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf2 :class vf)
         (vf20 :class vf)
         (vf21 :class vf)
         )
    (.lvf vf10 (&-> ray-origin quad))
    (.lvf vf12 (&-> cyl-origin quad))
    (.sub.vf vf15 vf10 vf12)
    (.lvf vf11 (&-> ray-dir quad))
    (.lvf vf13 (&-> cyl-axis quad))
    (.mov vf14 cyl-len)
    (.mul.vf vf16 vf15 vf13)
    (.mul.vf vf17 vf11 vf13)
    (.add.x.vf vf16 vf16 vf16 :mask #b10)
    (.add.x.vf vf17 vf17 vf17 :mask #b10)
    (.add.z.vf vf16 vf16 vf16 :mask #b10)
    (.add.z.vf vf17 vf17 vf17 :mask #b10)
    (.mul.y.vf vf1 vf13 vf16)
    (.add.vf vf18 vf17 vf16)
    (.sub.x.vf vf19 vf16 vf14)
    (.mul.y.vf vf2 vf13 vf17)
    (.mov v1-0 vf16)
    (.sub.x.vf vf20 vf18 vf14)
    (.mov a0-1 vf18)
    (let ((v1-1 (logand (the-as uint v1-0) a0-1)))
      (.sub.vf vf1 vf15 vf1)
      (b! (< (the-as int v1-1) 0) cfg-6 :delay (.sub.vf vf2 vf11 vf2))
      )
    (.mov v1-2 vf19)
    (.mov a0-2 vf20)
    (b! (>= (the-as int (logior v1-2 (the-as uint a0-2))) 0) cfg-6 :delay (nop!))
    (let ((v1-4 (raw-ray-sphere-intersect cyl-rad)))
      (b! (< (the-as int v1-4) 0) cfg-6 :delay (.mov vf21 v1-4))
      (.mul.x.vf vf17 vf17 vf21)
      (.add.vf vf16 vf16 vf17)
      (.mul.y.vf vf13 vf13 vf16)
      (.sub.x.vf vf19 vf16 vf14)
      (.mov a0-4 vf16)
      (b! (< (the-as int a0-4) 0) cfg-6 :delay (.add.vf vf12 vf12 vf13 :mask #b111))
      (.mov a0-5 vf19)
      (b! (>= (the-as int a0-5) 0) cfg-6 :delay (.svf (&-> arg6 quad) vf12))
      (b! #t cfg-7 :delay (set! v0-1 v1-4))
      )
    (label cfg-6)
    (set! v0-1 -100000000.0)
    (label cfg-7)
    v0-1
    )
  )

;; definition for function ray-plane-intersect
(defun ray-plane-intersect ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 vector) (arg4 vector) (arg5 vector) (arg6 vector))
  (local-vars (v1-0 float) (v1-1 float) (a2-1 float))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf3 (&-> arg5 quad))
    (.lvf vf1 (&-> arg4 quad))
    (.lvf vf2 (&-> arg6 quad))
    (.sub.vf vf1 vf3 vf1)
    (.sub.vf vf2 vf3 vf2)
    (.lvf vf6 (&-> arg2 quad))
    (.lvf vf7 (&-> arg3 quad))
    (.sub.vf vf8 vf3 vf6)
    (.outer.product.a.vf acc vf2 vf1)
    (.outer.product.b.vf vf4 vf1 vf2 acc)
    (.mul.vf vf8 vf8 vf4)
    (.mul.vf vf9 vf7 vf4)
    (.mul.vf vf5 vf4 vf4)
    (.add.y.vf vf8 vf8 vf8 :mask #b1)
    (.add.y.vf vf9 vf9 vf9 :mask #b1)
    (.add.y.vf vf5 vf5 vf5 :mask #b1)
    (.add.z.vf vf8 vf8 vf8 :mask #b1)
    (.add.z.vf vf9 vf9 vf9 :mask #b1)
    (.add.z.vf vf5 vf5 vf5 :mask #b1)
    (.mov v1-0 vf9)
    (.mov a2-1 vf8)
    (.isqrt.vf Q vf0 vf5 :fsf #b11 :ftf #b0)
    (let ((f1-0 a2-1)
          (f2-0 v1-0)
          )
      (cond
        ((!= f2-0 0.0)
         (let ((f1-1 (/ f1-0 f2-0)))
           (.mov.vf vf4 vf0 :mask #b1000)
           (.wait.vf)
           (.mul.vf vf4 vf4 Q :mask #b111)
           (let ((v0-0 f1-1))
             (.mov vf8 v0-0)
             (.svf (&-> arg1 quad) vf4)
             (.mul.x.vf acc vf7 vf8)
             (.add.mul.w.vf vf7 vf6 vf0 acc :mask #b111)
             (.svf (&-> arg0 quad) vf7)
             (.mov v1-1 vf7)
             v0-0
             )
           )
         )
        (else
          -100000000.0
          )
        )
      )
    )
  )

;; definition for function ray-triangle-intersect
;; WARN: Using logior on floats
;; WARN: Using logior on floats
;; INFO: Return type mismatch number vs float.
;; ERROR: Unsupported inline assembly instruction kind - [sll v1, v1, 1]
(defun ray-triangle-intersect ((arg0 vector) (arg1 vector) (arg2 float) (arg3 matrix) (arg4 vector) (arg5 vector))
  (local-vars (v1-0 float) (v1-1 int) (v1-2 float) (a0-1 float) (a0-2 float) (a1-1 float))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf12 :class vf)
         (vf13 :class vf)
         (vf14 :class vf)
         (vf15 :class vf)
         (vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf2 :class vf)
         (vf20 :class vf)
         (vf21 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf1 (&-> arg3 vector 0 quad))
    (.lvf vf2 (&-> arg3 vector 1 quad))
    (.lvf vf3 (&-> arg3 vector 2 quad))
    (.lvf vf8 (&-> arg0 quad))
    (.lvf vf9 (&-> arg1 quad))
    (.sub.vf vf4 vf2 vf1)
    (.sub.vf vf5 vf2 vf3)
    (.sub.vf vf10 vf2 vf8)
    (.mul.vf vf17 vf9 vf9)
    (.outer.product.a.vf acc vf5 vf4)
    (.outer.product.b.vf vf6 vf4 vf5 acc)
    (.add.y.vf vf17 vf17 vf17 :mask #b1)
    (.mul.vf vf7 vf6 vf6)
    (.mul.vf vf10 vf10 vf6)
    (.mul.vf vf11 vf9 vf6)
    (.add.z.vf vf17 vf17 vf17 :mask #b1)
    (.add.y.vf vf7 vf7 vf7 :mask #b1)
    (.add.y.vf vf10 vf10 vf10 :mask #b1)
    (.add.y.vf vf11 vf11 vf11 :mask #b1)
    (.mov vf18 arg2)
    (.add.z.vf vf7 vf7 vf7 :mask #b1)
    (.add.z.vf vf10 vf10 vf10 :mask #b1)
    (.add.z.vf vf11 vf11 vf11 :mask #b1)
    (.isqrt.vf Q vf0 vf7 :fsf #b11 :ftf #b0)
    (.mov v1-0 vf11)
    (.mov a0-1 vf10)
    (let* ((f2-0 v1-0)
           (f3-0 (/ a0-1 f2-0))
           )
      (.sll v1-1 v1-0 1)
      (.mov.vf vf6 vf0 :mask #b1000)
      (b! (zero? v1-1) cfg-5 :delay (.wait.vf))
      (.mul.vf vf6 vf6 Q :mask #b111)
      (let ((v0-0 (the-as number f3-0)))
        (.mov vf12 v0-0)
        (.svf (&-> arg5 quad) vf6)
        (.mul.x.vf acc vf9 vf12)
        (.add.mul.w.vf vf13 vf8 vf0 acc)
        (b! (< (the-as int v0-0) 0) cfg-5 :delay (.svf (&-> arg4 quad) vf13))
        (.sub.vf vf19 vf2 vf13)
        (.sub.vf vf20 vf13 vf3)
        (.sub.vf vf21 vf13 vf1)
        (.isqrt.vf Q vf0 vf17 :fsf #b11 :ftf #b0)
        (.outer.product.a.vf acc vf5 vf19)
        (.outer.product.b.vf vf14 vf19 vf5 acc)
        (.outer.product.a.vf acc vf19 vf4)
        (.outer.product.b.vf vf15 vf4 vf19 acc)
        (.outer.product.a.vf acc vf20 vf21)
        (.outer.product.b.vf vf16 vf21 vf20 acc)
        (.mul.vf vf14 vf14 vf6 :mask #b111)
        (.mul.vf vf15 vf15 vf6 :mask #b111)
        (.mul.vf vf16 vf16 vf6 :mask #b111)
        (.add.x.vf vf14 vf14 vf14 :mask #b10)
        (.add.x.vf vf15 vf15 vf15 :mask #b10)
        (.add.x.vf vf16 vf16 vf16 :mask #b10)
        (.add.z.vf vf14 vf14 vf14 :mask #b10)
        (.add.z.vf vf15 vf15 vf15 :mask #b10)
        (.add.z.vf vf16 vf16 vf16 :mask #b10)
        (.mov a0-2 vf14)
        (.mov a1-1 vf15)
        (.mov v1-2 vf16)
        (b! (< (the-as int (logior (logior a0-2 (the-as uint a1-1)) (the-as uint v1-2))) 0) cfg-5 :delay (nop!))
        (b! (zero? (the int arg2)) cfg-6 :delay (nop!))
        (.wait.vf)
        (.mul.vf vf18 vf18 Q :mask #b1)
        (.sub.x.vf vf12 vf12 vf18 :mask #b1)
        (.max.x.vf vf12 vf12 vf0 :mask #b1)
        (b! #t cfg-6 :delay (.mov v0-0 vf12))
        (label cfg-5)
        (set! v0-0 -859915232)
        (label cfg-6)
        (the-as float v0-0)
        )
      )
    )
  )

;; definition for function collide-do-primitives
;; INFO: function output is handled by mips2c
(def-mips2c collide-do-primitives (function float))

;; definition for function moving-sphere-triangle-intersect
;; INFO: function output is handled by mips2c
(def-mips2c moving-sphere-triangle-intersect (function vector vector float collide-cache-tri vector vector float))

;; definition for function moving-sphere-sphere-intersect
;; INFO: Used lq/sq
(defun moving-sphere-sphere-intersect ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 vector))
  (let ((f30-0 (ray-sphere-intersect arg0 arg1 arg2 (+ (-> arg0 w) (-> arg2 w)))))
    (when (>= f30-0 0.0)
      (let ((s3-1 (vector-normalize! (vector-! (new-stack-vector0) arg2 arg0) (-> arg0 w))))
        (vector+*! arg3 arg0 arg1 f30-0)
        (vector+! arg3 arg3 s3-1)
        )
      )
    f30-0
    )
  )

;; definition for function moving-sphere-moving-sphere-intersect
;; INFO: Used lq/sq
(defun moving-sphere-moving-sphere-intersect ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 vector) (arg4 vector))
  (let ((f30-0 (ray-sphere-intersect arg0 (vector-! (new-stack-vector0) arg1 arg3) arg2 (+ (-> arg0 w) (-> arg2 w))))
        )
    (cond
      ((and (>= f30-0 0.0) (>= 1.0 f30-0))
       (let ((s3-1 (vector-normalize! (vector-! (new-stack-vector0) arg2 arg0) (-> arg0 w))))
         (vector+*! arg4 arg0 arg1 f30-0)
         (vector+! arg4 arg4 s3-1)
         )
       )
      (else
        (set! f30-0 -100000000.0)
        )
      )
    f30-0
    )
  )
