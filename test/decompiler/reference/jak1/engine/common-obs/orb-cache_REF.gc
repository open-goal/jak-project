;;-*-Lisp-*-
(in-package goal)

(import "goal_src/jak1/import/orb-cache-top-ag.gc")

;; definition of type orb-cache-top
(deftype orb-cache-top (baseplat)
  ((active-distance   float     :offset-assert 228)
   (inactive-distance float     :offset-assert 232)
   (money-list        handle 60 :offset-assert 240)
   (money-pos-list    float  60 :offset-assert 720)
   (money-pos-actual  float  60 :offset-assert 960)
   (platform-pos      float     :offset-assert 1200)
   (root-pos          float     :offset-assert 1204)
   (money             int32     :offset-assert 1208)
   (activated         symbol    :offset-assert 1212)
   )
  :heap-base #x450
  :method-count-assert 29
  :size-assert         #x4c0
  :flag-assert         #x1d045004c0
  (:methods
    (pos-logic (_type_ symbol) symbol 27)
    (calculate-pos (_type_ symbol) none 28)
    )
  (:states
    (orb-cache-top-activate symbol)
    (orb-cache-top-complete symbol)
    (orb-cache-top-idle symbol)
    )
  )

;; definition for method 3 of type orb-cache-top
(defmethod inspect orb-cache-top ((obj orb-cache-top))
  (let ((t9-0 (method-of-type baseplat inspect)))
    (t9-0 obj)
    )
  (format #t "~T~Tactive-distance: ~f~%" (-> obj active-distance))
  (format #t "~T~Tinactive-distance: ~f~%" (-> obj inactive-distance))
  (format #t "~T~Tmoney-list[60] @ #x~X~%" (-> obj money-list))
  (format #t "~T~Tmoney-pos-list[60] @ #x~X~%" (-> obj money-pos-list))
  (format #t "~T~Tmoney-pos-actual[60] @ #x~X~%" (-> obj money-pos-actual))
  (format #t "~T~Tplatform-pos: ~f~%" (-> obj platform-pos))
  (format #t "~T~Troot-pos: ~f~%" (-> obj root-pos))
  (format #t "~T~Tmoney: ~D~%" (-> obj money))
  (format #t "~T~Tactivated: ~A~%" (-> obj activated))
  obj
  )

;; failed to figure out what this is:
(defskelgroup *orb-cache-top-sg* orb-cache-top orb-cache-top-lod0-jg orb-cache-top-idle-ja
              ((orb-cache-top-lod0-mg (meters 20)) (orb-cache-top-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

;; failed to figure out what this is:
(defstate orb-cache-top-idle (orb-cache-top)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('eco-blue)
       (process-entity-status! self (entity-perm-status complete) #t)
       (dotimes (gp-0 5)
         (spawn-projectile-blue *target*)
         )
       (increment-success-for-hint (text-id sidekick-hint-orb-cache-top))
       (go orb-cache-top-activate #f)
       )
      (else
        (plat-event proc arg1 event-type event)
        )
      )
    )
  :trans (behavior ()
    (if (and (and *target* (>= 20480.0 (vector-vector-distance (-> self root-override trans) (-> *target* control trans))))
             (not (send-event *target* 'query 'powerup (pickup-type eco-blue)))
             )
        (level-hint-spawn
          (text-id sidekick-hint-orb-cache-top)
          "sksp0009"
          (the-as entity #f)
          *entity-pool*
          (game-task none)
          )
        )
    (none)
    )
  :code (behavior ((arg0 symbol))
    (if (and (not arg0) (-> self child))
        (sound-play "close-orb-cash")
        )
    (dotimes (gp-1 (-> self money))
      (let ((a0-4 (handle->process (-> self money-list gp-1))))
        (if a0-4
            (deactivate a0-4)
            )
        )
      )
    (process-entity-status! self (entity-perm-status complete) #f)
    (ja :group! (-> self draw art-group data 3) :num! (identity (ja-aframe 0.0 0)))
    (transform-post)
    (anim-loop)
    (none)
    )
  )

;; definition for method 22 of type orb-cache-top
;; INFO: Return type mismatch int vs none.
(defmethod baseplat-method-22 orb-cache-top ((obj orb-cache-top))
  (if (< 4096.0 (- (-> obj basetrans y) (-> obj root-pos)))
      (activate! (-> obj smush) -1.0 60 150 1.0 1.0)
      (activate! (-> obj smush) -0.5 60 150 1.0 1.0)
      )
  (set! (-> obj bouncing) #t)
  (logclear! (-> obj mask) (process-mask sleep))
  0
  (none)
  )

;; definition for method 28 of type orb-cache-top
;; INFO: Return type mismatch int vs none.
(defmethod calculate-pos orb-cache-top ((obj orb-cache-top) (arg0 symbol))
  (let ((f0-0 0.0))
    (when arg0
      (set! f0-0 (+ 10240.0 (* 6144.0 (the float (+ (-> obj money) -1)))))
      (if (< f0-0 2048.0)
          (set! f0-0 2048.0)
          )
      )
    (set! (-> obj platform-pos) (+ (-> obj root-pos) f0-0))
    (let ((f0-2 (+ -6144.0 f0-0)))
      (dotimes (v1-5 (-> obj money))
        (set! (-> obj money-pos-list v1-5) (+ (-> obj root-pos) f0-2))
        (set! f0-2 (+ -6144.0 f0-2))
        )
      )
    )
  0
  (none)
  )

;; definition for method 27 of type orb-cache-top
;; INFO: Used lq/sq
(defmethod pos-logic orb-cache-top ((obj orb-cache-top) (arg0 symbol))
  (dotimes (s4-0 (-> obj money))
    (when (not (handle->process (-> obj money-list s4-0)))
      (dotimes (v1-6 (-> obj money))
        (when (< s4-0 v1-6)
          (set! (-> obj money-list (+ v1-6 -1)) (-> obj money-list v1-6))
          (set! (-> obj money-pos-actual (+ v1-6 -1)) (-> obj money-pos-actual v1-6))
          )
        )
      (+! (-> obj money) -1)
      (calculate-pos obj arg0)
      (+! s4-0 -1)
      (let ((v1-15 (-> obj entity extra perm)))
        (logior! (-> v1-15 status) (entity-perm-status user-set-from-cstage))
        (+! (-> v1-15 user-int16 0) 1)
        )
      )
    )
  (let ((s4-1 (new 'stack-no-clear 'vector))
        (s5-1 #t)
        )
    (let ((s3-0 #f))
      (let ((f28-0 (- (-> obj basetrans y) (-> obj root-pos)))
            (f30-0 (- (-> obj platform-pos) (-> obj root-pos)))
            )
        (when (zero? (-> obj money))
          (set! f30-0 2048.0)
          (set! s3-0 #t)
          )
        (when (and (< f30-0 15155.2)
                   (and *target* (>= 16384.0 (vector-vector-distance (-> obj root-override trans) (-> *target* control trans))))
                   (< (-> (target-pos 0) y) (-> obj basetrans y))
                   )
          (set! f30-0 (if (< 14131.2 f28-0)
                          15155.2
                          f28-0
                          )
                )
          (set! s3-0 #f)
          )
        (seek! (-> obj basetrans y) (+ (-> obj root-pos) f30-0) (* 40960.0 (-> *display* seconds-per-frame)))
        (if (not (= (-> obj basetrans y) (+ (-> obj root-pos) f30-0)))
            (set! s5-1 #f)
            )
        )
      (dotimes (s2-0 (-> obj money))
        (set! (-> s4-1 quad)
              (-> (the-as process-drawable (handle->process (-> obj money-list s2-0))) root trans quad)
              )
        (seek!
          (-> obj money-pos-actual s2-0)
          (-> obj money-pos-list s2-0)
          (* 40960.0 (-> *display* seconds-per-frame))
          )
        (if (not (= (-> obj money-pos-actual s2-0) (-> obj money-pos-list s2-0)))
            (set! s5-1 #f)
            )
        (if (>= (-> obj money-pos-actual s2-0) (+ -8192.0 (-> obj root-pos)))
            (set! (-> s4-1 y) (-> obj money-pos-actual s2-0))
            (set! (-> s4-1 y) (+ -8192.0 (-> obj root-pos)))
            )
        (send-event (handle->process (-> obj money-list s2-0)) 'trans s4-1)
        )
      (set! s3-0 (and s5-1 s3-0))
      (if s3-0
          (go orb-cache-top-complete #f)
          )
      )
    s5-1
    )
  )

;; failed to figure out what this is:
(defstate orb-cache-top-activate (orb-cache-top)
  :event (the-as (function process int symbol event-message-block object :behavior orb-cache-top) plat-event)
  :exit (behavior ()
    (process-entity-status! self (entity-perm-status bit-3) #f)
    (none)
    )
  :trans (the-as (function none :behavior orb-cache-top) plat-trans)
  :code (behavior ((arg0 symbol))
    (process-entity-status! self (entity-perm-status bit-3) #t)
    (calculate-pos self arg0)
    (if arg0
        (set! (-> self basetrans y) (-> self platform-pos))
        (sound-play "open-orb-cash")
        )
    (dotimes (s5-1 (-> self money))
      (let ((s4-1 (new 'stack-no-clear 'vector)))
        (set! (-> s4-1 quad) (-> self basetrans quad))
        (set! (-> s4-1 y) (-> self money-pos-list s5-1))
        (set! (-> self money-pos-actual s5-1) (-> s4-1 y))
        (set! (-> self money-list s5-1)
              (ppointer->handle
                (process-spawn money :init money-init-by-other-no-bob s4-1 *null-vector* 5 1.0 (-> self entity) :to self)
                )
              )
        )
      )
    (loop
      (calculate-pos self #t)
      (while (not (or (not *target*) (< (-> self inactive-distance)
                                        (vector-vector-xz-distance (-> self root-override trans) (-> *target* control trans))
                                        )
                      )
                  )
        (pos-logic self #t)
        (suspend)
        )
      (calculate-pos self #f)
      (while (and (not (and (and *target* (>= (-> self active-distance)
                                              (vector-vector-xz-distance (-> self root-override trans) (-> *target* control trans))
                                              )
                                 )
                            (let ((a1-11 (new 'stack-no-clear 'event-message-block)))
                              (set! (-> a1-11 from) self)
                              (set! (-> a1-11 num-params) 2)
                              (set! (-> a1-11 message) 'query)
                              (set! (-> a1-11 param 0) (the-as uint 'powerup))
                              (set! (-> a1-11 param 1) (the-as uint 3))
                              (or (send-event-function *target* a1-11) (-> self activated))
                              )
                            )
                       )
                  (not (pos-logic self #f))
                  )
        (suspend)
        )
      (if (not (and (and *target* (>= (-> self active-distance)
                                      (vector-vector-xz-distance (-> self root-override trans) (-> *target* control trans))
                                      )
                         )
                    (let ((a1-14 (new 'stack-no-clear 'event-message-block)))
                      (set! (-> a1-14 from) self)
                      (set! (-> a1-14 num-params) 2)
                      (set! (-> a1-14 message) 'query)
                      (set! (-> a1-14 param 0) (the-as uint 'powerup))
                      (set! (-> a1-14 param 1) (the-as uint 3))
                      (or (send-event-function *target* a1-14) (-> self activated))
                      )
                    )
               )
          (go orb-cache-top-idle arg0)
          )
      )
    (none)
    )
  :post (the-as (function none :behavior orb-cache-top) plat-post)
  )

;; failed to figure out what this is:
(defstate orb-cache-top-complete (orb-cache-top)
  :event (the-as (function process int symbol event-message-block object :behavior orb-cache-top) plat-event)
  :trans (the-as (function none :behavior orb-cache-top) plat-trans)
  :code (behavior ((arg0 symbol))
    (if (not arg0)
        (sound-play "close-orb-cash")
        )
    (ja :group! (-> self draw art-group data 3) :num! (identity (ja-aframe 0.0 0)))
    (new 'stack-no-clear 'vector)
    (set! (-> self basetrans y) (+ 2048.0 (-> self root-pos)))
    (anim-loop)
    (none)
    )
  :post (the-as (function none :behavior orb-cache-top) plat-post)
  )

;; definition for method 11 of type orb-cache-top
;; INFO: Return type mismatch object vs none.
(defmethod init-from-entity! orb-cache-top ((obj orb-cache-top) (arg0 entity-actor))
  (let ((a0-1 (-> obj entity)))
    (if (when a0-1
          (let ((a0-2 (-> a0-1 extra perm task)))
            (if a0-2
                (= a0-2 (game-task none))
                )
            )
          )
        (set! (-> obj entity extra perm task) (game-task complete))
        )
    )
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s4-0 1)
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object blue-eco-suck))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 0)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 11468.8)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (logclear! (-> obj mask) (process-mask actor-pause))
  (initialize-skeleton obj *orb-cache-top-sg* '())
  (logior! (-> obj skel status) (janim-status inited))
  (update-transforms! (-> obj root-override))
  (baseplat-method-21 obj)
  (set! (-> obj money) (res-lump-value (-> obj entity) 'orb-cache-count int :default (the-as uint128 20)))
  (set! (-> obj active-distance) 61440.0)
  (set! (-> obj inactive-distance) 245760.0)
  (set! (-> obj root-pos) (-> obj basetrans y))
  (set! (-> obj platform-pos) (-> obj root-pos))
  (set! (-> obj activated)
        (the-as
          symbol
          (and (-> obj entity) (logtest? (-> obj entity extra perm status) (entity-perm-status complete)))
          )
        )
  (let ((v1-39 (-> obj entity extra perm)))
    (logior! (-> v1-39 status) (entity-perm-status user-set-from-cstage))
    (set! (-> obj money) (- (-> obj money) (-> v1-39 user-int16 0)))
    )
  (dotimes (v1-42 (-> obj money))
    (set! (-> obj money-list v1-42) (the-as handle #f))
    )
  (cond
    ((zero? (-> obj money))
     (go orb-cache-top-complete #t)
     )
    ((and (-> obj entity) (logtest? (-> obj entity extra perm status) (entity-perm-status complete)))
     (go orb-cache-top-activate #t)
     )
    (else
      (go orb-cache-top-idle #f)
      )
    )
  (none)
  )
