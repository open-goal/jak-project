;;-*-Lisp-*-
(in-package goal)

;; definition for function sphere-cull
;; ERROR: Bad vector register dependency: vf16
;; ERROR: Bad vector register dependency: vf17
;; ERROR: Bad vector register dependency: vf18
;; ERROR: Bad vector register dependency: vf19
(defun sphere-cull ((arg0 vector))
  (local-vars (v1-0 uint128) (v1-1 uint128) (v1-2 uint128))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf10 :class vf)
         (vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf10 (&-> arg0 quad))
    (.mul.x.vf acc vf16 vf10)
    (.add.mul.y.vf acc vf17 vf10 acc)
    (.add.mul.z.vf acc vf18 vf10 acc)
    (.sub.mul.w.vf vf9 vf19 vf0 acc)
    (.add.w.vf vf9 vf9 vf10)
    (.mov v1-0 vf9)
    (.pcgtw v1-1 0 v1-0)
    (.ppach v1-2 (the-as uint128 0) v1-1)
    (zero? (the-as int v1-2))
    )
  )

;; definition for function guard-band-cull
;; ERROR: Bad vector register dependency: vf20
;; ERROR: Bad vector register dependency: vf21
;; ERROR: Bad vector register dependency: vf22
;; ERROR: Bad vector register dependency: vf23
(defun guard-band-cull ((arg0 vector))
  (local-vars (v1-0 uint128) (v1-1 uint128) (v1-2 uint128))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf10 :class vf)
         (vf20 :class vf)
         (vf21 :class vf)
         (vf22 :class vf)
         (vf23 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf10 (&-> arg0 quad))
    (.mul.x.vf acc vf20 vf10)
    (.add.mul.y.vf acc vf21 vf10 acc)
    (.add.mul.z.vf acc vf22 vf10 acc)
    (.sub.mul.w.vf vf9 vf23 vf0 acc)
    (.sub.w.vf vf9 vf9 vf10)
    (.mov v1-0 vf9)
    (.pcgtw v1-1 0 v1-0)
    (.ppach v1-2 (the-as uint128 0) v1-1)
    (nonzero? (the-as int v1-2))
    )
  )

;; definition for function sphere-in-view-frustum?
(defun sphere-in-view-frustum? ((arg0 sphere))
  (local-vars (v1-1 uint128) (v1-2 uint128) (v1-3 uint128))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (let ((v1-0 *math-camera*))
      (.lvf vf6 (&-> arg0 quad))
      (.lvf vf1 (&-> v1-0 plane 0 quad))
      (.lvf vf2 (&-> v1-0 plane 1 quad))
      (.lvf vf3 (&-> v1-0 plane 2 quad))
      (.lvf vf4 (&-> v1-0 plane 3 quad))
      )
    (.mul.x.vf acc vf1 vf6)
    (.add.mul.y.vf acc vf2 vf6 acc)
    (.add.mul.z.vf acc vf3 vf6 acc)
    (.sub.mul.w.vf vf5 vf4 vf0 acc)
    (.add.w.vf vf5 vf5 vf6)
    (.mov v1-1 vf5)
    (.pcgtw v1-2 0 v1-1)
    (.ppach v1-3 (the-as uint128 0) v1-2)
    (zero? (the-as int v1-3))
    )
  )

;; definition for function line-in-view-frustum?
(defun line-in-view-frustum? ((arg0 vector) (arg1 vector))
  (local-vars (v1-1 uint128) (v1-2 uint128) (v1-3 uint128) (a0-1 uint128) (a0-2 uint128) (a0-3 uint128))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf10 :class vf)
         (vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (let ((v1-0 *math-camera*))
      (.lvf vf9 (&-> arg0 quad))
      (.lvf vf10 (&-> arg1 quad))
      (.lvf vf16 (&-> v1-0 plane 0 quad))
      (.lvf vf17 (&-> v1-0 plane 1 quad))
      (.lvf vf18 (&-> v1-0 plane 2 quad))
      (.lvf vf19 (&-> v1-0 plane 3 quad))
      )
    (.mul.x.vf acc vf16 vf9)
    (.add.mul.y.vf acc vf17 vf9 acc)
    (.add.mul.z.vf acc vf18 vf9 acc)
    (.sub.mul.w.vf vf9 vf19 vf0 acc)
    (.mul.x.vf acc vf16 vf10)
    (.add.mul.y.vf acc vf17 vf10 acc)
    (.add.mul.z.vf acc vf18 vf10 acc)
    (.sub.mul.w.vf vf10 vf19 vf0 acc)
    (.mov v1-1 vf9)
    (.pcgtw v1-2 0 v1-1)
    (.ppach v1-3 (the-as uint128 0) v1-2)
    (.mov a0-1 vf10)
    (.pcgtw a0-2 0 a0-1)
    (.ppach a0-3 (the-as uint128 0) a0-2)
    (zero? (logand (the-as int v1-3) (the-as int a0-3)))
    )
  )

;; definition for function vis-cull
;; ERROR: Type Propagation failed: Failed type prop at op 3 ((set! v1 (l.b (+ v1 #x38b0)))): Could not get type of load: (set! v1 (l.b (+ v1 #x38b0))). 
;; ERROR: Type Propagation failed: Type analysis failed
;; ERROR: Unsupported inline assembly instruction kind - [addiu a0, a0, 56]
(defun vis-cull ((a0-0 int))
  (local-vars (v0-0 none) (v1-0 int) (v1-1 int) (v1-2 none) (v1-3 none) (a0-1 none) (a0-2 none) (a1-0 int))
  (set! v1-0 #x70000000)
  (shift-arith-right-32 a1-0 a0-0 3)
  (set! v1-1 (+ a1-0 v1-0))
  (set! v1-2 (the-as none (l.b (+ v1-1 #x38b0))))
  (set! a0-1 (the-as none (logand a0-0 7)))
  (.addiu a0-2 a0-1 56)
  (set! v1-3 (the-as none (sll v1-2 a0-2)))
  (set! v0-0 (the-as none (<0.si v1-3)))
  (ret-value v0-0)
  )

;; definition for function error-sphere
;; INFO: Return type mismatch int vs none.
(defun error-sphere ((arg0 drawable-error) (arg1 string))
  (when *artist-error-spheres*
    (when (vis-cull (-> arg0 id))
      (when (sphere-cull (-> arg0 bsphere))
        (add-debug-sphere
          #t
          (bucket-id debug)
          (-> arg0 bsphere)
          (-> arg0 bsphere w)
          (new 'static 'rgba :r #x80 :a #x80)
          )
        (add-debug-text-3d
          #t
          (bucket-id debug-no-zbuf)
          arg1
          (-> arg0 bsphere)
          (font-color white)
          (the-as vector2h #f)
          )
        )
      )
    )
  0
  (none)
  )

;; definition for method 9 of type drawable
(defmethod login drawable ((obj drawable))
  obj
  )

;; definition for method 10 of type drawable
;; INFO: Return type mismatch int vs none.
(defmethod draw drawable ((obj drawable) (arg0 drawable) (arg1 display-frame))
  0
  (none)
  )

;; definition for method 11 of type drawable
;; INFO: Return type mismatch int vs none.
(defmethod collide-with-box drawable ((obj drawable) (arg0 int) (arg1 collide-list))
  0
  (none)
  )

;; definition for method 12 of type drawable
;; INFO: Return type mismatch int vs none.
(defmethod collide-y-probe drawable ((obj drawable) (arg0 int) (arg1 collide-list))
  0
  (none)
  )

;; definition for method 13 of type drawable
;; INFO: Return type mismatch int vs none.
(defmethod collide-ray drawable ((obj drawable) (arg0 int) (arg1 collide-list))
  0
  (none)
  )

;; definition for method 17 of type drawable
;; INFO: Return type mismatch int vs none.
(defmethod collect-ambients drawable ((obj drawable) (arg0 sphere) (arg1 int) (arg2 ambient-list))
  0
  (none)
  )

;; definition for method 14 of type drawable
;; INFO: Return type mismatch int vs none.
(defmethod collect-stats drawable ((obj drawable))
  0
  (none)
  )

;; definition for method 15 of type drawable
;; INFO: Return type mismatch int vs none.
(defmethod debug-draw drawable ((obj drawable) (arg0 drawable) (arg1 display-frame))
  0
  (none)
  )

;; definition for method 10 of type drawable-error
;; INFO: Return type mismatch drawable-error vs none.
(defmethod draw drawable-error ((obj drawable-error) (arg0 drawable-error) (arg1 display-frame))
  (error-sphere arg0 (-> arg0 name))
  (none)
  )

;; definition for method 16 of type drawable
(defmethod unpack-vis drawable ((obj drawable) (arg0 (pointer int8)) (arg1 (pointer int8)))
  arg1
  )

;; definition for symbol *edit-instance*, type string
(define *edit-instance* (the-as string #f))

;; this part is debug only
(when *debug-segment*
;; definition for symbol *instance-mem-usage*, type memory-usage-block
(define *instance-mem-usage* (new 'debug 'memory-usage-block))

)
;; definition (debug) for function find-instance-by-name
(defun-debug find-instance-by-name ((arg0 string))
  (dotimes (s5-0 (-> *level* length))
    (let ((v1-3 (-> *level* level s5-0)))
      (when (= (-> v1-3 status) 'active)
        (let ((s4-0 (-> v1-3 bsp drawable-trees)))
          (dotimes (s3-0 (-> s4-0 length))
            (let ((v1-7 (-> s4-0 trees s3-0)))
              (case (-> v1-7 type)
                ((drawable-tree-instance-shrub)
                 (let ((s2-0 (-> (the-as drawable-tree-instance-shrub v1-7) info prototype-inline-array-shrub)))
                   (dotimes (s1-0 (-> s2-0 length))
                     (if (string= arg0 (-> s2-0 data s1-0 name))
                         (return (-> s2-0 data s1-0))
                         )
                     )
                   )
                 )
                ((drawable-tree-instance-tie)
                 (let ((s2-1 (-> (the-as drawable-tree-instance-tie v1-7) prototypes prototype-array-tie)))
                   (dotimes (s1-1 (-> s2-1 length))
                     (if (string= arg0 (-> s2-1 array-data s1-1 name))
                         (return (-> s2-1 array-data s1-1))
                         )
                     )
                   )
                 )
                )
              )
            )
          )
        )
      )
    )
  (the-as prototype-bucket #f)
  )

;; definition (debug) for function find-instance-by-index
(defun-debug find-instance-by-index ((arg0 type) (arg1 int) (arg2 bsp-header))
  (dotimes (v1-0 (-> *level* length))
    (let ((a3-3 (-> *level* level v1-0)))
      (when (= (-> a3-3 status) 'active)
        (let ((a3-4 (-> a3-3 bsp)))
          (when (or (not arg2) (= a3-4 arg2))
            (let ((a3-5 (-> a3-4 drawable-trees)))
              (dotimes (t0-5 (-> a3-5 length))
                (let ((t1-3 (-> a3-5 trees t0-5)))
                  (case (-> t1-3 type)
                    ((drawable-tree-instance-shrub)
                     (when (= arg0 (-> t1-3 type))
                       (let ((v1-2 (-> (the-as drawable-tree-instance-shrub t1-3) info prototype-inline-array-shrub)))
                         (return (-> v1-2 data arg1))
                         )
                       )
                     )
                    ((drawable-tree-instance-tie)
                     (when (= arg0 (-> t1-3 type))
                       (let ((v1-5 (-> (the-as drawable-tree-instance-tie t1-3) prototypes prototype-array-tie)))
                         (return (-> v1-5 array-data arg1))
                         )
                       )
                     )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  (the-as prototype-bucket #f)
  )

;; definition (debug) for function prototype-bucket-type
(defun-debug prototype-bucket-type ((arg0 prototype-bucket))
  (case (-> arg0 geometry 1 type)
    ((prototype-shrubbery shrubbery)
     instance-shrubbery
     )
    ((prototype-tie prototype-tie tie-fragment)
     instance-tie
     )
    )
  )

;; definition (debug) for function prototype-bucket-recalc-fields
(defun-debug prototype-bucket-recalc-fields ((arg0 prototype-bucket))
  (case (prototype-bucket-type arg0)
    ((instance-shrubbery)
     (set! (-> arg0 rdists x) (/ 1.0 (- (-> arg0 dists w) (-> arg0 dists x))))
     )
    (else
      (set! (-> arg0 dists z) (+ (-> arg0 dists x) (* 0.33333334 (- (-> arg0 dists w) (-> arg0 dists x)))))
      (set! (-> arg0 rdists x) (/ 1.0 (- (-> arg0 dists z) (-> arg0 dists x))))
      )
    )
  (set! (-> arg0 rdists z) (/ 1.0 (- (-> arg0 dists w) (-> arg0 dists z))))
  (set! (-> arg0 dists y) (* 0.5 (-> arg0 dists x)))
  (set! (-> arg0 rdists y) (/ 1.0 (-> arg0 dists y)))
  arg0
  )

;; definition (debug) for function draw-instance-info
;; INFO: Used lq/sq
;; INFO: Return type mismatch object vs none.
(defun-debug draw-instance-info ((arg0 string))
  (local-vars
    (sv-16 uint)
    (sv-32 uint)
    (sv-48 uint)
    (sv-64 int)
    (sv-80 int)
    (sv-96 int)
    (sv-112 int)
    (sv-128 int)
    (sv-144 int)
    )
  (when (and *display-instance-info* *edit-instance*)
    (let ((s5-0 (find-instance-by-name *edit-instance*)))
      (when s5-0
        (let ((s2-0 (prototype-bucket-type s5-0)))
          (let ((s4-0 0))
            0
            (cond
              ((= s2-0 instance-shrubbery)
               (set! s4-0 595)
               )
              ((= s2-0 instance-tie)
               (reset! *instance-mem-usage*)
               (dotimes (s4-1 4)
                 (when (nonzero? (-> s5-0 geometry s4-1))
                   (let* ((a0-4 (-> s5-0 geometry s4-1))
                          (t9-3 (method-of-object a0-4 mem-usage))
                          (a1-0 *instance-mem-usage*)
                          (v1-16 s4-1)
                          )
                     (t9-3 a0-4 a1-0 (logior (cond
                                               ((= v1-16 1)
                                                4
                                                )
                                               ((= v1-16 2)
                                                8
                                                )
                                               ((= v1-16 3)
                                                16
                                                )
                                               (else
                                                 0
                                                 )
                                               )
                                             2
                                             )
                           )
                     )
                   )
                 )
               (set! s4-0 (+ (calculate-total *instance-mem-usage*) 580))
               )
              )
            (mem-usage s5-0 (reset! *instance-mem-usage*) 0)
            (let ((v1-26 (calculate-total *instance-mem-usage*)))
              (format
                arg0
                "~%~A ~A b @ #x~X ~,,2fK/~,,2fK~%"
                s2-0
                (-> s5-0 name)
                s5-0
                (* 0.0009765625 (the float v1-26))
                (* 0.0009765625 (the float s4-0))
                )
              )
            )
          (format arg0 "near: ~m  mid: ~m  far: ~m~%" (-> s5-0 dists x) (-> s5-0 dists z) (-> s5-0 dists w))
          (let ((s3-1 0)
                (s4-2 0)
                )
            (cond
              ((= s2-0 instance-shrubbery)
               (let ((f30-0 0.0))
                 (format
                   arg0
                   "usage: vis: ~D  shurb: ~D  trans-shrub ~D  bill: ~D   in level: ~D~%"
                   (-> s5-0 count 0)
                   (-> s5-0 count 1)
                   (-> s5-0 count 2)
                   (-> s5-0 count 3)
                   (-> s5-0 in-level)
                   )
                 (format arg0 "~%frag#     tris   dverts   strlen  tex~%")
                 (let ((s1-1 (-> s5-0 geometry 1))
                       (s2-1 (+ (-> s5-0 count 1) (-> s5-0 count 2)))
                       )
                   (dotimes (s0-0 (-> (the-as drawable-group s1-1) length))
                     (set! sv-16 (shrub-num-tris (the-as shrubbery (+ (+ (* s0-0 32) 32) (the-as int s1-1)))))
                     (set! sv-32 (-> (the-as prototype-shrubbery (+ (the-as uint s1-1) (* s0-0 32))) data 0 header data 2))
                     (set! sv-48 (-> (the-as prototype-shrubbery (+ (the-as uint s1-1) (* s0-0 32))) data 0 header data 0))
                     (format
                       arg0
                       "~5D     ~4D    ~5D   ~6f    ~D~%"
                       s0-0
                       sv-16
                       sv-32
                       (/ (* 2.0 (the float sv-16)) (the float (- sv-32 sv-16)))
                       sv-48
                       )
                     (+! s3-1 sv-16)
                     (+! s4-2 sv-32)
                     (set! f30-0
                           (+ 29.0
                              (* 5.5 (the float (- sv-32 sv-16)))
                              (* 22.0 (the float sv-48))
                              (* 8.0 (the float sv-32))
                              (* 53.0 (the float (/ (+ s2-1 9) (the-as uint 10))))
                              (* (the float s2-1) (+ 15.0 (* 5.0 (the float sv-48)) (* 13.5 (the float sv-32))))
                              f30-0
                              )
                           )
                     )
                   (format
                     arg0
                     "total     ~4D    ~5D   ~6f    ~D  speed: ~f~%"
                     s3-1
                     s4-2
                     (/ (* 2.0 (the float s3-1)) (the float (- s4-2 s3-1)))
                     (-> s5-0 utextures)
                     (/ f30-0 (* (the float s2-1) (the float s3-1)))
                     )
                   )
                 )
               )
              ((= s2-0 instance-tie)
               (set! sv-144 0)
               (let ((s1-2 0)
                     (s0-1 0)
                     (s2-2 0)
                     )
                 (format arg0 "~%level   visible  frags   tris   dverts   strlen  tex  ttris~%")
                 (set! sv-64 1)
                 (set! sv-80 3)
                 (while (>= sv-80 sv-64)
                   (let ((v1-65 (-> s5-0 geometry sv-64)))
                     (set! sv-96 0)
                     (set! sv-112 0)
                     (set! sv-128 0)
                     (dotimes (a0-23 (-> (the-as prototype-tie v1-65) length))
                       (set! sv-96 (+ sv-96 (l.hu (+ (the-as uint v1-65) (* a0-23 64) 68))))
                       (set! sv-112 (+ sv-112 (l.hu (+ (the-as uint v1-65) (* a0-23 64) 70))))
                       (set! sv-128 (+ sv-128 (l.hu (+ (the-as uint v1-65) (* a0-23 64) 60))))
                       )
                     (set! sv-144 (+ sv-144 (-> s5-0 count sv-64)))
                     (format arg0 "~5D  ~7D  ~5D   ~5D" sv-64 (-> s5-0 count sv-64) (-> (the-as prototype-tie v1-65) length) sv-96)
                     )
                   (format
                     arg0
                     "    ~5D   ~6f  ~3D  ~5D~%"
                     sv-112
                     (/ (* 2.0 (the float sv-96)) (the float (- sv-112 sv-96)))
                     sv-128
                     (* (the-as uint sv-96) (-> s5-0 count sv-64))
                     )
                   (+! s1-2 (* (the-as uint sv-96) (-> s5-0 count sv-64)))
                   (+! s0-1 (* (the-as uint sv-112) (-> s5-0 count sv-64)))
                   (+! s3-1 sv-96)
                   (+! s4-2 sv-112)
                   (+! s2-2 sv-128)
                   (set! sv-64 (+ sv-64 1))
                   )
                 (let ((t9-18 format)
                       (a0-39 arg0)
                       (a1-22 "total  ~7D/~3D      ~5D")
                       (a3-11 (-> s5-0 in-level))
                       )
                   (t9-18 a0-39 a1-22 sv-144 a3-11 s3-1)
                   )
                 (format
                   arg0
                   "    ~5D   ~6f  ~3D  ~5D~%"
                   s4-2
                   (/ (* 2.0 (the float s1-2)) (the float (- s0-1 s1-2)))
                   s2-2
                   s1-2
                   )
                 )
               )
              )
            )
          )
        )
      )
    )
  (none)
  )

;; definition for function dma-add-process-drawable
;; INFO: Return type mismatch int vs none.
;; WARN: Function dma-add-process-drawable has a return type of none, but the expression builder found a return statement.
(defun dma-add-process-drawable ((arg0 process-drawable) (arg1 draw-control) (arg2 symbol) (arg3 dma-buffer))
  (local-vars (v1-37 float) (sv-16 process-drawable))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf15 :class vf)
         (vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf2 :class vf)
         (vf20 :class vf)
         (vf21 :class vf)
         (vf22 :class vf)
         (vf23 :class vf)
         (vf24 :class vf)
         (vf25 :class vf)
         (vf26 :class vf)
         (vf27 :class vf)
         (vf28 :class vf)
         (vf29 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         )
    (init-vf0-vector)
    (set! sv-16 arg0)
    (logclear! (-> arg1 status) (draw-status was-drawn))
    (when (zero? (logand (-> arg1 status) (draw-status hidden no-anim no-skeleton-update)))
      (let ((s4-0 (the-as vector (+ 48 (the-as int (the-as terrain-context #x70000000)))))
            (vu-lgt (the-as vu-lights (+ 64 (the-as int (the-as terrain-context #x70000000)))))
            (tod *time-of-day-context*)
            )
        (.lvf vf16 (&-> arg1 origin quad))
        (.lvf vf17 (&-> arg1 bounds quad))
        (.mul.x.vf vf16 vf16 vf0 :mask #b1000)
        (.add.vf vf16 vf16 vf17)
        (.svf (&-> s4-0 quad) vf16)
        (.lvf vf28 (&-> arg1 color-mult quad))
        (.lvf vf29 (&-> arg1 color-emissive quad))
        (when (sphere-in-view-frustum? (the-as sphere s4-0))
          (case (-> arg1 global-effect)
            (((draw-effect title))
             (when (not (-> tod title-updated))
               (set! (-> tod title-updated) #t)
               (let ((s0-0 (-> *math-camera* inv-camera-rot))
                     (a1-1 (new 'stack-no-clear 'vector))
                     (s1-0 (new 'stack-no-clear 'vector))
                     )
                 (set-vector! a1-1 0.612 0.5 -0.612 0.0)
                 (set-vector! s1-0 -0.696 0.174 0.696 0.0)
                 (vector-matrix*! (the-as vector (-> tod title-light-group)) a1-1 s0-0)
                 (vector-matrix*! (the-as vector (-> tod title-light-group dir1)) s1-0 s0-0)
                 )
               (set-vector! (-> *time-of-day-context* current-shadow) 0.612 -0.5 -0.612 1.0)
               )
             (vu-lights<-light-group! vu-lgt (-> tod title-light-group))
             )
            (else
              (let ((interp (-> arg1 secondary-interp))
                    (cur-interp (-> arg1 current-secondary-interp))
                    (shadow-msk (-> arg1 shadow-mask))
                    (lev-idx (-> arg1 level-index))
                    (lgt (-> tod light-group (-> *target* draw light-index)))
                    (cur-lgt (new 'stack-no-clear 'light-group))
                    )
                (cond
                  ((= (-> arg1 light-index) 255)
                   )
                  ((= lev-idx 2)
                   (set! lgt (-> tod light-group (-> arg1 light-index)))
                   )
                  (else
                    (set! lgt (-> tod moods lev-idx light-group (-> arg1 light-index)))
                    )
                  )
                (when (not (or (= lev-idx 2) (zero? shadow-msk)))
                  (let* ((lgt-msk-0 (-> tod light-masks-0 lev-idx))
                         (lgt-msk-1 (-> tod light-masks-1 lev-idx))
                         (lgt-interp (-> tod light-interp lev-idx))
                         (a0-13 (logand lgt-msk-0 shadow-msk))
                         (v1-18 (logand lgt-msk-1 shadow-msk))
                         )
                    (cond
                      ((and (zero? a0-13) (zero? v1-18))
                       )
                      (else
                        (set! interp (cond
                                       ((and (nonzero? a0-13) (nonzero? v1-18))
                                        1.0
                                        )
                                       ((zero? a0-13)
                                        (quad-copy! (the-as pointer cur-lgt) (the-as pointer lgt) 12)
                                        (set! lgt cur-lgt)
                                        (set! (-> lgt dir1 levels x) 0.0)
                                        lgt-interp
                                        )
                                       (else
                                         (quad-copy! (the-as pointer cur-lgt) (the-as pointer lgt) 12)
                                         (set! lgt cur-lgt)
                                         (set! (-> lgt dir0 levels x) 0.0)
                                         (- 1.0 lgt-interp)
                                         )
                                       )
                              )
                        )
                      )
                    )
                  )
                (if *teleport*
                    (set! cur-interp interp)
                    )
                (when (not (or (paused?) (= interp cur-interp)))
                  (let ((f0-15 (- cur-interp interp)))
                    (set! cur-interp (cond
                                       ((< (fabs f0-15) 0.2)
                                        interp
                                        )
                                       ((< f0-15 0.0)
                                        (+ 0.2 cur-interp)
                                        )
                                       (else
                                         (+ -0.2 cur-interp)
                                         )
                                       )
                          )
                    )
                  (set! (-> arg1 current-secondary-interp) cur-interp)
                  )
                (cond
                  ((= cur-interp 0.0)
                   (vu-lights<-light-group! vu-lgt lgt)
                   )
                  (else
                    (if (!= lgt cur-lgt)
                        (quad-copy! (the-as pointer cur-lgt) (the-as pointer lgt) 12)
                        )
                    (let ((f0-20 (- 1.0 cur-interp)))
                      (set! (-> cur-lgt dir0 levels x) (* (-> cur-lgt dir0 levels x) f0-20))
                      (set! (-> cur-lgt dir0 levels y) (* (-> cur-lgt dir0 levels y) f0-20))
                      (set! (-> cur-lgt dir1 levels x) (* (-> cur-lgt dir1 levels x) f0-20))
                      (set! (-> cur-lgt dir1 levels y) (* (-> cur-lgt dir1 levels y) f0-20))
                      (set! (-> cur-lgt dir2 levels x) (* (-> cur-lgt dir2 levels x) f0-20))
                      (set! (-> cur-lgt dir2 levels y) (* (-> cur-lgt dir2 levels y) f0-20))
                      )
                    (vu-lights<-light-group! vu-lgt cur-lgt)
                    )
                  )
                )
              (.lvf vf2 (&-> vu-lgt color 0 quad))
              (.lvf vf3 (&-> vu-lgt color 1 quad))
              (.lvf vf4 (&-> vu-lgt color 2 quad))
              (.lvf vf5 (&-> vu-lgt ambient quad))
              (.mul.vf vf5 vf5 vf28)
              (.mul.vf vf2 vf2 vf28)
              (.mul.vf vf3 vf3 vf28)
              (.mul.vf vf4 vf4 vf28)
              (.add.vf vf5 vf5 vf29)
              (.svf (&-> vu-lgt color 0 quad) vf2)
              (.svf (&-> vu-lgt color 1 quad) vf3)
              (.svf (&-> vu-lgt color 2 quad) vf4)
              (.svf (&-> vu-lgt ambient quad) vf5)
              (.mov v1-37 vf5)
              )
            )
          (if *display-lights*
              (add-debug-lights #t (bucket-id debug) (the-as (inline-array light) (-> tod light-group)) (-> arg1 origin))
              )
          (let ((at-0 *math-camera*))
            (.lvf vf16 (&-> at-0 plane 0 quad))
            (.lvf vf17 (&-> at-0 plane 1 quad))
            (.lvf vf18 (&-> at-0 plane 2 quad))
            (.lvf vf19 (&-> at-0 plane 3 quad))
            (.lvf vf20 (&-> at-0 guard-plane 0 quad))
            (.lvf vf21 (&-> at-0 guard-plane 1 quad))
            (.lvf vf22 (&-> at-0 guard-plane 2 quad))
            (.lvf vf23 (&-> at-0 guard-plane 3 quad))
            (.lvf vf24 (&-> at-0 camera-rot vector 0 quad))
            (.lvf vf25 (&-> at-0 camera-rot vector 1 quad))
            (.lvf vf26 (&-> at-0 camera-rot vector 2 quad))
            (.lvf vf27 (&-> at-0 camera-rot vector 3 quad))
            )
          (let ((v1-42 (the-as vector (+ 176 (the-as int (the-as terrain-context #x70000000))))))
            (.lvf vf15 (&-> s4-0 quad))
            (.mul.w.vf acc vf27 vf0)
            (.add.mul.x.vf acc vf24 vf15 acc)
            (.add.mul.y.vf acc vf25 vf15 acc)
            (.add.mul.z.vf vf15 vf26 vf15 acc :mask #b111)
            (.mul.vf vf28 vf15 vf15)
            (.max.w.vf vf29 vf0 vf0)
            (.add.y.vf acc vf28 vf28)
            (.add.mul.z.vf vf28 vf29 vf28 acc :mask #b1)
            (.sqrt.vf Q vf28 :ftf #b0)
            (.sub.w.vf vf28 vf0 vf15 :mask #b1000)
            (.wait.vf)
            (.add.vf vf15 vf28 Q :mask #b1000)
            (.svf (&-> v1-42 quad) vf15)
            (when (< 0.0 (+ (-> v1-42 z) (-> arg1 bounds w)))
              (let ((lod-to-use 0))
                (let ((cam-dist (-> v1-42 w)))
                  (when (nonzero? (-> arg1 lod-set max-lod))
                    (cond
                      ((>= (-> arg1 force-lod) 0)
                       (set! lod-to-use (-> arg1 force-lod))
                       (if (< (-> arg1 lod-set lod (-> arg1 lod-set max-lod) dist) cam-dist)
                           (return #f)
                           )
                       )
                      (else
                        (while (and (< lod-to-use (-> arg1 lod-set max-lod)) (< (-> arg1 lod-set lod lod-to-use dist) cam-dist))
                          (+! lod-to-use 1)
                          )
                        )
                      )
                    )
                  (if (and (< (-> arg1 lod-set lod lod-to-use dist) cam-dist) (< (-> arg1 force-lod) 0))
                      (return #f)
                      )
                  (let ((v1-64 (-> arg1 sink-group level))
                        (a0-26 (+ (-> arg1 sink-group merc-sink foreground-texture-page) 6))
                        )
                    (when (zero? (logand (-> arg1 status) (draw-status do-not-check-distance)))
                      (if (< cam-dist (-> v1-64 closest-object a0-26))
                          (set! (-> v1-64 closest-object a0-26) cam-dist)
                          )
                      (when (and (!= a0-26 6) (!= (-> arg1 level-index) 2))
                        (let ((a1-45 (cond
                                       ((< 102400.0 cam-dist)
                                        (-> arg1 mgeo header masks 0)
                                        )
                                       ((< 81920.0 cam-dist)
                                        (-> arg1 mgeo header masks 1)
                                        )
                                       (else
                                         (-> arg1 mgeo header masks 2)
                                         )
                                       )
                                     )
                              )
                          (logior! (-> v1-64 texture-mask a0-26) a1-45)
                          )
                        )
                      )
                    )
                  (if (or (guard-band-cull s4-0) (< cam-dist (* 1.2 (-> *math-camera* d))))
                      (logior! (-> arg1 status) (draw-status needs-clip))
                      (logclear! (-> arg1 status) (draw-status needs-clip))
                      )
                  (logior! (-> arg1 status) (draw-status was-drawn))
                  (if (logtest? (-> arg1 status) (draw-status skip-bones))
                      (return #f)
                      )
                  (draw-bones arg1 arg3 cam-dist)
                  )
                (when (and (< lod-to-use (-> arg1 cur-lod)) (logtest? (-> arg1 status) (draw-status has-joint-channels)))
                  (let ((v1-82 *matrix-engine*))
                    (set! (-> v1-82 (-> v1-82 length)) (process->handle sv-16))
                    (+! (-> v1-82 length) 1)
                    )
                  )
                (lod-set! arg1 lod-to-use)
                )
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

;; definition for symbol *hud-lights*, type vu-lights
(define *hud-lights* (new 'global 'vu-lights))

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* direction 0) 1.0 0.0 0.0 1.0)

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* direction 1) 0.0 1.0 0.0 1.0)

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* direction 2) 0.0 0.0 1.0 1.0)

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* color 0) 0.0 0.0 0.0 1.0)

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* color 1) 0.0 0.0 0.0 1.0)

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* color 2) 0.5 0.5 0.5 1.0)

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* ambient) 0.5 0.5 0.5 1.0)

;; definition for function dma-add-process-drawable-hud
;; INFO: Used lq/sq
;; INFO: Return type mismatch int vs none.
(defun dma-add-process-drawable-hud ((arg0 process-drawable) (arg1 draw-control) (arg2 symbol) (arg3 dma-buffer))
  (logclear! (-> arg1 status) (draw-status was-drawn))
  (when (zero? (logand (-> arg1 status) (draw-status hidden no-anim no-skeleton-update)))
    (let ((v1-6 (the-as vu-lights (+ 64 #x70000000)))
          (a0-3 *hud-lights*)
          )
      (set! (-> v1-6 direction 0 quad) (-> a0-3 direction 0 quad))
      (set! (-> v1-6 direction 1 quad) (-> a0-3 direction 1 quad))
      (set! (-> v1-6 direction 2 quad) (-> a0-3 direction 2 quad))
      (set! (-> v1-6 color 0 quad) (-> a0-3 color 0 quad))
      (set! (-> v1-6 color 1 quad) (-> a0-3 color 1 quad))
      (set! (-> v1-6 color 2 quad) (-> a0-3 color 2 quad))
      (set! (-> v1-6 ambient quad) (-> a0-3 ambient quad))
      )
    (lod-set! arg1 0)
    (logior! (-> arg1 status) (draw-status was-drawn))
    (draw-bones-hud arg1 arg3)
    )
  0
  (none)
  )

;; definition for function add-process-drawable
;; INFO: Return type mismatch symbol vs none.
(defun add-process-drawable ((arg0 process-drawable) (arg1 draw-control) (arg2 symbol) (arg3 dma-buffer))
  ((-> arg1 dma-add-func) arg0 arg1 arg2 arg3)
  (none)
  )

;; definition for function foreground-engine-execute
;; INFO: Return type mismatch int vs none.
;; ERROR: Unsupported inline assembly instruction kind - [sync.l]
;; ERROR: Unsupported inline assembly instruction kind - [cache dxwbin v1, 0]
;; ERROR: Unsupported inline assembly instruction kind - [sync.l]
;; ERROR: Unsupported inline assembly instruction kind - [cache dxwbin v1, 1]
;; ERROR: Unsupported inline assembly instruction kind - [sync.l]
(defun foreground-engine-execute ((arg0 engine) (arg1 display-frame) (arg2 int) (arg3 int))
  (let ((s4-0 (-> *display* frames (-> *display* on-screen) frame global-buf base)))
    (if *debug-segment*
        (add-frame
          (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
          'draw
          (new 'static 'rgba :r #x40 :b #x40 :a #x80)
          )
        )
    (let ((a1-2 (+ (+ (* arg3 32) 272 (* 2608 arg2)) (the-as int *level*)))
          (s2-1 (-> arg1 global-buf))
          )
      (let ((v1-14 (-> s2-1 base)))
        (.sync.l)
        (.cache dxwbin v1-14 0)
        (.sync.l)
        (.cache dxwbin v1-14 1)
        )
      (.sync.l)
      0
      (bones-init s2-1 (the-as dma-foreground-sink-group a1-2))
      (execute-connections arg0 s2-1)
      )
    (bones-wrapup)
    (if *debug-segment*
        (add-frame
          (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
          'draw
          (new 'static 'rgba :r #xbe :g #x55 :b #x82 :a #x80)
          )
        )
    (let ((v1-24 *dma-mem-usage*))
      (when (nonzero? v1-24)
        (set! (-> v1-24 length) (max 36 (-> v1-24 length)))
        (set! (-> v1-24 data 35 name) "pris-fragment")
        (+! (-> v1-24 data 35 count) 1)
        (+! (-> v1-24 data 35 used)
            (&- (-> *display* frames (-> *display* on-screen) frame global-buf base) (the-as uint s4-0))
            )
        (set! (-> v1-24 data 35 total) (-> v1-24 data 35 used))
        )
      )
    )
  (when (logtest? *vu1-enable-user* (vu1-renderer-mask generic))
    (when (nonzero? (-> *merc-globals* first))
      (let ((s4-1 (-> *display* frames (-> *display* on-screen) frame global-buf base)))
        (let ((a0-25 (-> (the-as (pointer uint32) (+ (the-as uint *level*) (* 2608 arg2) (* arg3 32))) 69)))
          (generic-merc-add-to-cue (the-as generic-dma-foreground-sink a0-25))
          )
        (let ((a0-26 *dma-mem-usage*))
          (when (nonzero? a0-26)
            (set! (-> a0-26 length) (max 87 (-> a0-26 length)))
            (set! (-> a0-26 data 86 name) "pris-generic")
            (+! (-> a0-26 data 86 count) 1)
            (+! (-> a0-26 data 86 used)
                (&- (-> *display* frames (-> *display* on-screen) frame global-buf base) (the-as uint s4-1))
                )
            (set! (-> a0-26 data 86 total) (-> a0-26 data 86 used))
            )
          )
        )
      )
    )
  (when #t
    (let ((v1-41 *shadow-queue*))
      (+! (-> v1-41 cur-run) 1)
      )
    )
  0
  (none)
  )

;; definition (debug) for function main-debug-hook
(defun-debug main-debug-hook ()
  (when (not (or (= *master-mode* 'menu) (= *master-mode* 'progress)))
    (execute-connections *debug-engine* #f)
    (draw-instance-info *stdcon*)
    )
  (none)
  )

;; definition for symbol *debug-hook*, type (function none)
(define *debug-hook* main-debug-hook)

;; definition for symbol *add-sphere*, type symbol
(define *add-sphere* #f)

;; definition for symbol *generic-effect-mode*, type int
(define *generic-effect-mode* 0)

;; definition for function real-main-draw-hook
;; INFO: Return type mismatch int vs none.
;; ERROR: Unsupported inline assembly instruction kind - [mtc0 Perf, r0]
;; ERROR: Unsupported inline assembly instruction kind - [sync.l]
;; ERROR: Unsupported inline assembly instruction kind - [sync.p]
;; ERROR: Unsupported inline assembly instruction kind - [mtpc pcr0, r0]
;; ERROR: Unsupported inline assembly instruction kind - [mtpc pcr1, r0]
;; ERROR: Unsupported inline assembly instruction kind - [sync.l]
;; ERROR: Unsupported inline assembly instruction kind - [sync.p]
;; ERROR: Unsupported inline assembly instruction kind - [mtc0 Perf, a0]
;; ERROR: Unsupported inline assembly instruction kind - [sync.l]
;; ERROR: Unsupported inline assembly instruction kind - [sync.p]
;; ERROR: Unsupported inline assembly instruction kind - [mtc0 Perf, r0]
;; ERROR: Unsupported inline assembly instruction kind - [sync.l]
;; ERROR: Unsupported inline assembly instruction kind - [sync.p]
;; ERROR: Unsupported inline assembly instruction kind - [mfpc a0, pcr0]
;; ERROR: Unsupported inline assembly instruction kind - [mfpc a0, pcr1]
(defun real-main-draw-hook ()
  (local-vars (a0-74 int) (a0-76 int))
  (when *slow-frame-rate*
    (dotimes (v1-2 #xc3500)
      (nop!)
      (nop!)
      (nop!)
      (nop!)
      (nop!)
      (nop!)
      )
    )
  "Function to be executed to set up for engine dma"
  (set! *vu1-enable-user* *vu1-enable-user-menu*)
  (set! *texture-enable-user* *texture-enable-user-menu*)
  (when *debug-segment*
    (when (or *stats-memory* *stats-memory-short*)
      (dotimes (gp-0 (-> *level* length))
        (let ((s5-0 (-> *level* level gp-0)))
          (if (= (-> s5-0 status) 'active)
              (print-mem-usage (compute-memory-usage s5-0 #f) s5-0 *stdcon*)
              )
          )
        )
      )
    (reset! *dma-mem-usage*)
    )
  (shrub-make-perspective-matrix (-> *math-camera* shrub-mat))
  (generic-init-buffers)
  (when (logtest? *texture-enable-user* 1)
    (dotimes (gp-1 (-> *level* length))
      (let ((a1-2 (-> *level* level gp-1)))
        (if (= (-> a1-2 status) 'active)
            (add-tex-to-dma! *texture-pool* a1-2 0)
            )
        )
      )
    )
  (when (logtest? *texture-enable-user* 2)
    (dotimes (gp-2 (-> *level* length))
      (let ((a1-3 (-> *level* level gp-2)))
        (if (= (-> a1-3 status) 'active)
            (add-tex-to-dma! *texture-pool* a1-3 1)
            )
        )
      )
    )
  (when (logtest? *texture-enable-user* 4)
    (dotimes (gp-3 (-> *level* length))
      (let ((a1-4 (-> *level* level gp-3)))
        (if (= (-> a1-4 status) 'active)
            (add-tex-to-dma! *texture-pool* a1-4 2)
            )
        )
      )
    )
  (when (logtest? *texture-enable-user* 8)
    (let ((s5-1 #f))
      (dotimes (gp-4 (-> *level* length))
        (let ((a1-5 (-> *level* level gp-4)))
          (when (= (-> a1-5 status) 'active)
            (add-tex-to-dma! *texture-pool* a1-5 3)
            (when (not s5-1)
              (upload-one-common! *texture-pool* (-> *level* level0))
              (set! s5-1 #t)
              )
            )
          )
        )
      (when (not s5-1)
        (upload-one-common! *texture-pool* (-> *level* level0))
        #t
        )
      )
    )
  (when (logtest? *texture-enable-user* 16)
    (dotimes (gp-5 (-> *level* length))
      (let ((a1-8 (-> *level* level gp-5)))
        (if (= (-> a1-8 status) 'active)
            (add-tex-to-dma! *texture-pool* a1-8 4)
            )
        )
      )
    )
  (when (zero? (logand *vu1-enable-user* (vu1-renderer-mask sky)))
    (let* ((s5-2 (-> *display* frames (-> *display* on-screen) frame global-buf))
           (gp-6 (-> s5-2 base))
           )
      (let* ((v1-114 s5-2)
             (a0-27 (the-as object (-> v1-114 base)))
             )
        (set! (-> (the-as dma-packet a0-27) dma) (new 'static 'dma-tag :qwc #x4 :id (dma-tag-id cnt)))
        (set! (-> (the-as dma-packet a0-27) vif0) (new 'static 'vif-tag))
        (set! (-> (the-as dma-packet a0-27) vif1) (new 'static 'vif-tag :imm #x4 :cmd (vif-cmd direct) :msk #x1))
        (set! (-> v1-114 base) (&+ (the-as pointer a0-27) 16))
        )
      (let* ((v1-115 s5-2)
             (a0-29 (the-as object (-> v1-115 base)))
             )
        (set! (-> (the-as gs-gif-tag a0-29) tag) (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x3))
        (set! (-> (the-as gs-gif-tag a0-29) regs)
              (new 'static 'gif-tag-regs
                :regs0 (gif-reg-id a+d)
                :regs1 (gif-reg-id a+d)
                :regs2 (gif-reg-id a+d)
                :regs3 (gif-reg-id a+d)
                :regs4 (gif-reg-id a+d)
                :regs5 (gif-reg-id a+d)
                :regs6 (gif-reg-id a+d)
                :regs7 (gif-reg-id a+d)
                :regs8 (gif-reg-id a+d)
                :regs9 (gif-reg-id a+d)
                :regs10 (gif-reg-id a+d)
                :regs11 (gif-reg-id a+d)
                :regs12 (gif-reg-id a+d)
                :regs13 (gif-reg-id a+d)
                :regs14 (gif-reg-id a+d)
                :regs15 (gif-reg-id a+d)
                )
              )
        (set! (-> v1-115 base) (&+ (the-as pointer a0-29) 16))
        )
      (let* ((v1-116 s5-2)
             (a0-31 (-> v1-116 base))
             )
        (set! (-> (the-as (pointer gs-zbuf) a0-31) 0) (new 'static 'gs-zbuf :zbp #x1c0 :psm (gs-psm ct24)))
        (set! (-> (the-as (pointer gs-reg64) a0-31) 1) (gs-reg64 zbuf-1))
        (set! (-> (the-as (pointer gs-test) a0-31) 2)
              (new 'static 'gs-test :ate #x1 :atst (gs-atest always) :zte #x1 :ztst (gs-ztest always))
              )
        (set! (-> (the-as (pointer gs-reg64) a0-31) 3) (gs-reg64 test-1))
        (set! (-> (the-as (pointer gs-alpha) a0-31) 4) (new 'static 'gs-alpha :b #x1 :d #x1))
        (set! (-> (the-as (pointer gs-reg64) a0-31) 5) (gs-reg64 alpha-1))
        (set! (-> v1-116 base) (&+ a0-31 48))
        )
      (screen-gradient
        s5-2
        (-> *display* bg-clear-color 0)
        (-> *display* bg-clear-color 1)
        (-> *display* bg-clear-color 2)
        (-> *display* bg-clear-color 3)
        )
      (let ((a3-1 (-> s5-2 base)))
        (let ((v1-121 (the-as object (-> s5-2 base))))
          (set! (-> (the-as dma-packet v1-121) dma) (new 'static 'dma-tag :id (dma-tag-id next)))
          (set! (-> (the-as dma-packet v1-121) vif0) (new 'static 'vif-tag))
          (set! (-> (the-as dma-packet v1-121) vif1) (new 'static 'vif-tag))
          (set! (-> s5-2 base) (&+ (the-as pointer v1-121) 16))
          )
        (dma-bucket-insert-tag
          (-> *display* frames (-> *display* on-screen) frame bucket-group)
          (bucket-id sky-draw)
          gp-6
          (the-as (pointer dma-tag) a3-1)
          )
        )
      )
    )
  (when (logtest? *vu1-enable-user* (vu1-renderer-mask sky))
    (cond
      ((and (-> *time-of-day-context* sky) *sky-drawn*)
       (render-sky-tng *time-of-day-context*)
       )
      (else
        (let* ((s5-3 (-> *display* frames (-> *display* on-screen) frame global-buf))
               (gp-7 (-> s5-3 base))
               )
          (let* ((v1-137 s5-3)
                 (a0-43 (the-as object (-> v1-137 base)))
                 )
            (set! (-> (the-as dma-packet a0-43) dma) (new 'static 'dma-tag :qwc #x4 :id (dma-tag-id cnt)))
            (set! (-> (the-as dma-packet a0-43) vif0) (new 'static 'vif-tag))
            (set! (-> (the-as dma-packet a0-43) vif1) (new 'static 'vif-tag :imm #x4 :cmd (vif-cmd direct) :msk #x1))
            (set! (-> v1-137 base) (&+ (the-as pointer a0-43) 16))
            )
          (let* ((v1-138 s5-3)
                 (a0-45 (the-as object (-> v1-138 base)))
                 )
            (set! (-> (the-as gs-gif-tag a0-45) tag) (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x3))
            (set! (-> (the-as gs-gif-tag a0-45) regs)
                  (new 'static 'gif-tag-regs
                    :regs0 (gif-reg-id a+d)
                    :regs1 (gif-reg-id a+d)
                    :regs2 (gif-reg-id a+d)
                    :regs3 (gif-reg-id a+d)
                    :regs4 (gif-reg-id a+d)
                    :regs5 (gif-reg-id a+d)
                    :regs6 (gif-reg-id a+d)
                    :regs7 (gif-reg-id a+d)
                    :regs8 (gif-reg-id a+d)
                    :regs9 (gif-reg-id a+d)
                    :regs10 (gif-reg-id a+d)
                    :regs11 (gif-reg-id a+d)
                    :regs12 (gif-reg-id a+d)
                    :regs13 (gif-reg-id a+d)
                    :regs14 (gif-reg-id a+d)
                    :regs15 (gif-reg-id a+d)
                    )
                  )
            (set! (-> v1-138 base) (&+ (the-as pointer a0-45) 16))
            )
          (let* ((v1-139 s5-3)
                 (a0-47 (-> v1-139 base))
                 )
            (set! (-> (the-as (pointer gs-zbuf) a0-47) 0) (new 'static 'gs-zbuf :zbp #x1c0 :psm (gs-psm ct24)))
            (let ((a1-28 78))
              (s.d! (+ (the-as (pointer gs-reg) a0-47) 8) a1-28)
              )
            (set! (-> (the-as (pointer gs-test) a0-47) 2)
                  (new 'static 'gs-test :ate #x1 :atst (gs-atest always) :zte #x1 :ztst (gs-ztest always))
                  )
            (set! (-> (the-as (pointer gs-reg64) a0-47) 3) (gs-reg64 test-1))
            (set! (-> (the-as (pointer gs-alpha) a0-47) 4) (new 'static 'gs-alpha :b #x1 :d #x1))
            (set! (-> (the-as (pointer gs-reg64) a0-47) 5) (gs-reg64 alpha-1))
            (set! (-> v1-139 base) (&+ a0-47 48))
            )
          (screen-gradient
            s5-3
            (-> *time-of-day-context* erase-color)
            (-> *time-of-day-context* erase-color)
            (-> *time-of-day-context* erase-color)
            (-> *time-of-day-context* erase-color)
            )
          (let ((a3-3 (-> s5-3 base)))
            (let ((v1-144 (the-as object (-> s5-3 base))))
              (set! (-> (the-as dma-packet v1-144) dma) (new 'static 'dma-tag :id (dma-tag-id next)))
              (set! (-> (the-as dma-packet v1-144) vif0) (new 'static 'vif-tag))
              (set! (-> (the-as dma-packet v1-144) vif1) (new 'static 'vif-tag))
              (set! (-> s5-3 base) (&+ (the-as pointer v1-144) 16))
              )
            (dma-bucket-insert-tag
              (-> *display* frames (-> *display* on-screen) frame bucket-group)
              (bucket-id sky-draw)
              gp-7
              (the-as (pointer dma-tag) a3-3)
              )
            )
          )
        )
      )
    )
  (update-time-of-day *time-of-day-context*)
  (dotimes (v1-150 (-> *level* length))
    (let ((a0-59 (-> *level* level v1-150)))
      (when (= (-> a0-59 status) 'active)
        (dotimes (a1-38 9)
          (set! (-> a0-59 closest-object a1-38) 4095996000.0)
          (set! (-> a0-59 texture-mask a1-38) (the-as uint 0))
          )
        )
      )
    )
  (if *debug-segment*
      (add-frame
        (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
        'draw
        (new 'static 'rgba :r #x40 :b #x40 :a #x80)
        )
      )
  (update-ocean)
  (draw-ocean)
  (if *debug-segment*
      (add-frame
        (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
        'draw
        (new 'static 'rgba :b #xff :a #x80)
        )
      )
  (set! (-> *merc-global-array* count) (the-as uint 0))
  (set! *merc-globals* (the-as merc-globals (-> *merc-global-array* globals)))
  (set! (-> *shadow-queue* cur-run) (the-as uint 0))
  0
  (init-background)
  (execute-connections *background-draw-engine* (-> *display* frames (-> *display* on-screen) frame))
  (let* ((v1-178 (-> *perf-stats* data 3))
         (a0-72 (-> v1-178 ctrl))
         )
    (+! (-> v1-178 count) 1)
    (b! (zero? a0-72) cfg-77 :delay (nop!))
    (.mtc0 Perf r0)
    (.sync.l)
    (.sync.p)
    (.mtpc pcr0 r0)
    (.mtpc pcr1 r0)
    (.sync.l)
    (.sync.p)
    (.mtc0 Perf a0-72)
    )
  (.sync.l)
  (.sync.p)
  (label cfg-77)
  0
  (finish-background)
  (let ((v1-181 (-> *perf-stats* data 3)))
    (b! (zero? (-> v1-181 ctrl)) cfg-79 :delay (nop!))
    (.mtc0 Perf r0)
    (.sync.l)
    (.sync.p)
    (.mfpc a0-74 pcr0)
    (+! (-> v1-181 accum0) a0-74)
    (.mfpc a0-76 pcr1)
    (+! (-> v1-181 accum1) a0-76)
    )
  (label cfg-79)
  0
  (update-wait-stats
    (-> *perf-stats* data 3)
    (-> *background-work* wait-to-vu0)
    (the-as uint 0)
    (the-as uint 0)
    )
  (end-perf-stat-collection)
  (when (not (paused?))
    (when *stats-poly*
      (dotimes (gp-8 (-> *level* length))
        (let ((v1-193 (-> *level* level gp-8)))
          (if (= (-> v1-193 status) 'active)
              (collect-stats (-> v1-193 bsp))
              )
          )
        )
      (print-terrain-stats)
      )
    (if *display-perf-stats*
        (print-perf-stats)
        )
    )
  (start-perf-stat-collection)
  (foreground-engine-execute
    (-> *level* level-default foreground-draw-engine 0)
    (-> *display* frames (-> *display* on-screen) frame)
    2
    0
    )
  (foreground-engine-execute
    (-> *level* level-default foreground-draw-engine 1)
    (-> *display* frames (-> *display* on-screen) frame)
    2
    1
    )
  (let ((gp-9 (-> *display* frames (-> *display* on-screen) frame global-buf)))
    (bones-mtx-calc-execute)
    (generic-merc-execute-all gp-9)
    (shadow-execute-all gp-9 *shadow-queue*)
    )
  (-> *display* frames (-> *display* on-screen) frame global-buf)
  (update-eyes)
  (when (logtest? (vu1-renderer-mask sprite) *vu1-enable-user*)
    (swap-fake-shadow-buffers)
    (sprite-draw *display*)
    )
  (when *debug-segment*
    (debug-draw-actors *level* *display-actor-marks*)
    (collide-shape-draw-debug-marks)
    )
  (render-boundaries)
  (send-events-for-touching-shapes *touching-list*)
  (free-all-prim-nodes *touching-list*)
  (if *debug-segment*
      (add-frame
        (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
        'draw
        (new 'static 'rgba :r #x40 :b #x40 :a #x80)
        )
      )
  (actors-update *level*)
  (if *debug-segment*
      (add-frame
        (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
        'draw
        (new 'static 'rgba :r #x80 :a #x80)
        )
      )
  (when (not (paused?))
    (if *stats-collide*
        (print-collide-stats)
        )
    )
  0
  (none)
  )

;; definition for function main-draw-hook
(defun main-draw-hook ()
  (real-main-draw-hook)
  (none)
  )

;; definition for symbol *draw-hook*, type (function none)
(define *draw-hook* main-draw-hook)

;; definition for function debug-init-buffer
;; INFO: Return type mismatch symbol vs none.
(defun debug-init-buffer ((arg0 bucket-id) (arg1 gs-zbuf) (arg2 gs-test))
  (let* ((t0-0 (-> *display* frames (-> *display* on-screen) frame global-buf))
         (v1-3 (-> t0-0 base))
         )
    (let* ((a3-3 t0-0)
           (t1-0 (the-as object (-> a3-3 base)))
           )
      (set! (-> (the-as dma-packet t1-0) dma) (new 'static 'dma-tag :qwc #x3 :id (dma-tag-id cnt)))
      (set! (-> (the-as dma-packet t1-0) vif0) (new 'static 'vif-tag))
      (set! (-> (the-as dma-packet t1-0) vif1) (new 'static 'vif-tag :imm #x3 :cmd (vif-cmd direct) :msk #x1))
      (set! (-> a3-3 base) (&+ (the-as pointer t1-0) 16))
      )
    (let* ((a3-4 t0-0)
           (t1-2 (the-as object (-> a3-4 base)))
           )
      (set! (-> (the-as gs-gif-tag t1-2) tag) (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x2))
      (set! (-> (the-as gs-gif-tag t1-2) regs)
            (new 'static 'gif-tag-regs
              :regs0 (gif-reg-id a+d)
              :regs1 (gif-reg-id a+d)
              :regs2 (gif-reg-id a+d)
              :regs3 (gif-reg-id a+d)
              :regs4 (gif-reg-id a+d)
              :regs5 (gif-reg-id a+d)
              :regs6 (gif-reg-id a+d)
              :regs7 (gif-reg-id a+d)
              :regs8 (gif-reg-id a+d)
              :regs9 (gif-reg-id a+d)
              :regs10 (gif-reg-id a+d)
              :regs11 (gif-reg-id a+d)
              :regs12 (gif-reg-id a+d)
              :regs13 (gif-reg-id a+d)
              :regs14 (gif-reg-id a+d)
              :regs15 (gif-reg-id a+d)
              )
            )
      (set! (-> a3-4 base) (&+ (the-as pointer t1-2) 16))
      )
    (let* ((a3-5 t0-0)
           (t1-4 (-> a3-5 base))
           )
      (set! (-> (the-as (pointer gs-zbuf) t1-4) 0) arg1)
      (set! (-> (the-as (pointer gs-reg64) t1-4) 1) (gs-reg64 zbuf-1))
      (set! (-> (the-as (pointer gs-test) t1-4) 2) arg2)
      (set! (-> (the-as (pointer gs-reg64) t1-4) 3) (gs-reg64 test-1))
      (set! (-> a3-5 base) (&+ t1-4 32))
      )
    (let ((a3-6 (-> t0-0 base)))
      (let ((a1-4 (the-as object (-> t0-0 base))))
        (set! (-> (the-as dma-packet a1-4) dma) (new 'static 'dma-tag :id (dma-tag-id next)))
        (set! (-> (the-as dma-packet a1-4) vif0) (new 'static 'vif-tag))
        (set! (-> (the-as dma-packet a1-4) vif1) (new 'static 'vif-tag))
        (set! (-> t0-0 base) (&+ (the-as pointer a1-4) 16))
        )
      (dma-bucket-insert-tag
        (-> *display* frames (-> *display* on-screen) frame bucket-group)
        arg0
        v1-3
        (the-as (pointer dma-tag) a3-6)
        )
      )
    )
  (none)
  )

;; definition for symbol *screen-shot*, type symbol
(define *screen-shot* #f)

;; definition for function display-frame-start
;; INFO: Return type mismatch display vs none.
(defun display-frame-start ((disp display) (new-frame-idx int) (odd-even int))
  (set! (-> (the-as vif-bank #x10003c00) err me0) 1)
  (let ((time-ratio
          (the float (+ (/ (timer-count (the-as timer-bank #x10000800)) (the-as uint *ticks-per-frame*)) 1))
          )
        )
    (set-time-ratios *display* time-ratio)
    (set! (-> disp old-base-frame-counter) (-> disp base-frame-counter))
    (set! (-> disp old-game-frame-counter) (-> disp game-frame-counter))
    (set! (-> disp old-real-frame-counter) (-> disp real-frame-counter))
    (set! (-> disp old-integral-frame-counter) (-> disp integral-frame-counter))
    (set! (-> disp old-real-integral-frame-counter) (-> disp real-integral-frame-counter))
    (set! (-> disp old-part-frame-counter) (-> disp part-frame-counter))
    (set! (-> disp old-actual-frame-counter) (-> disp actual-frame-counter))
    (set! (-> disp old-real-actual-frame-counter) (-> disp real-actual-frame-counter))
    (let ((scaled-seconds (* (the int time-ratio) (the int (-> disp time-factor)))))
      (set-particle-frame-time (min 12 scaled-seconds))
      (when (not (paused?))
        (+! (-> disp base-frame-counter) scaled-seconds)
        (+! (-> disp part-frame-counter) scaled-seconds)
        (+! (-> disp integral-frame-counter) (the int time-ratio))
        (+! (-> disp actual-frame-counter) 1)
        (if (not (movie?))
            (+! (-> disp game-frame-counter) scaled-seconds)
            )
        )
      (+! (-> disp real-frame-counter) scaled-seconds)
      )
    (+! (-> disp real-integral-frame-counter) (the int time-ratio))
    )
  (+! (-> disp real-actual-frame-counter) 1)
  (timer-reset (the-as timer-bank #x10000800))
  (when *screen-shot*
    (if *debug-segment*
        (store-image odd-even)
        )
    (set! *screen-shot* #f)
    )
  (let ((new-frame (-> disp frames new-frame-idx frame)))
    (when *debug-segment*
      (dotimes (s2-0 2)
        (reset (-> new-frame profile-bar s2-0))
        )
      )
    (if *sync-dma*
        (sync-path 0 0)
        )
    (let ((v1-56 (-> new-frame global-buf)))
      (set! (-> v1-56 base) (-> v1-56 data))
      (set! (-> v1-56 end) (&-> v1-56 data-buffer (-> v1-56 allocated-length)))
      )
    (when *debug-segment*
      (let ((v1-59 (-> new-frame debug-buf)))
        (set! (-> v1-59 base) (-> v1-59 data))
        (set! (-> v1-59 end) (&-> v1-59 data-buffer (-> v1-59 allocated-length)))
        )
      )
    (let ((v1-60 (-> new-frame calc-buf)))
      (set! (-> v1-60 base) (-> v1-60 data))
      (set! (-> v1-60 end) (&-> v1-60 data-buffer (-> v1-60 allocated-length)))
      )
    (default-buffer-init *default-regs-buffer*)
    (let* ((v1-61 (-> new-frame calc-buf))
           (a2-1 *default-regs-buffer*)
           (a0-28 (the-as object (-> v1-61 base)))
           )
      (set! (-> (the-as dma-packet a0-28) dma)
            (new 'static 'dma-tag :id (dma-tag-id call) :addr (the-as int (-> a2-1 data)))
            )
      (set! (-> (the-as dma-packet a0-28) vif0) (new 'static 'vif-tag))
      (set! (-> (the-as dma-packet a0-28) vif1) (new 'static 'vif-tag))
      (set! (-> v1-61 base) (&+ (the-as pointer a0-28) 16))
      )
    (*pre-draw-hook* (-> new-frame calc-buf))
    (when (not (paused?))
      (clear *stdcon1*)
      (debug-reset-buffers)
      )
    (set! (-> new-frame bucket-group) (dma-buffer-add-buckets (-> new-frame calc-buf) 69))
    )
  (debug-init-buffer
    (bucket-id debug-no-zbuf)
    (new 'static 'gs-zbuf :zbp #x1c0 :psm (gs-psm ct24) :zmsk #x1)
    (new 'static 'gs-test :zte #x1 :ztst (gs-ztest always))
    )
  (set-draw-env-offset (-> disp frames new-frame-idx draw) 2048 2048 odd-even)
  (service-cpads)
  (none)
  )

;; definition for function display-frame-finish
(defun display-frame-finish ((disp display))
  (let* ((this-frame (-> disp frames (-> disp on-screen) frame))
         (this-calc-buf (-> this-frame calc-buf))
         )
    (tie-init-buffers this-calc-buf)
    (merc-vu1-init-buffers)
    (*post-draw-hook* (-> disp frames (-> disp on-screen) frame calc-buf))
    (dotimes (bucket-idx 69)
      (let* ((this-global-buf (-> this-frame global-buf))
             (a2-0 (-> this-global-buf base))
             )
        (let* ((a0-3 this-global-buf)
               (t0-0 *default-regs-buffer*)
               (a1-0 (the-as object (-> a0-3 base)))
               )
          (set! (-> (the-as dma-packet a1-0) dma)
                (new 'static 'dma-tag :id (dma-tag-id call) :addr (the-as int (-> t0-0 data)))
                )
          (set! (-> (the-as dma-packet a1-0) vif0) (new 'static 'vif-tag :irq #x1))
          (set! (-> (the-as dma-packet a1-0) vif1) (new 'static 'vif-tag))
          (set! (-> a0-3 base) (&+ (the-as pointer a1-0) 16))
          )
        (let ((a3-4 (-> this-global-buf base)))
          (let ((a0-4 (the-as object (-> this-global-buf base))))
            (set! (-> (the-as dma-packet a0-4) dma) (new 'static 'dma-tag :id (dma-tag-id next)))
            (set! (-> (the-as dma-packet a0-4) vif0) (new 'static 'vif-tag))
            (set! (-> (the-as dma-packet a0-4) vif1) (new 'static 'vif-tag))
            (set! (-> this-global-buf base) (&+ (the-as pointer a0-4) 16))
            )
          (dma-bucket-insert-tag
            (-> *display* frames (-> *display* on-screen) frame bucket-group)
            (the-as bucket-id bucket-idx)
            a2-0
            (the-as (pointer dma-tag) a3-4)
            )
          )
        )
      )
    (let* ((v1-14 this-calc-buf)
           (a0-10 (the-as object (-> v1-14 base)))
           )
      (set! (-> (the-as dma-packet a0-10) dma) (new 'static 'dma-tag :id (dma-tag-id cnt)))
      (set! (-> (the-as dma-packet a0-10) vif0) (new 'static 'vif-tag :cmd (vif-cmd flushe) :msk #x1))
      (set! (-> (the-as dma-packet a0-10) vif1) (new 'static 'vif-tag :irq #x1))
      (set! (-> v1-14 base) (&+ (the-as pointer a0-10) 16))
      )
    (dma-buffer-patch-buckets (-> this-frame bucket-group) 69)
    (let* ((v1-15 this-calc-buf)
           (a0-13 (the-as object (-> v1-15 base)))
           )
      (set! (-> (the-as dma-packet a0-13) dma) (new 'static 'dma-tag :id (dma-tag-id end)))
      (set! (-> (the-as (pointer uint64) a0-13) 1) (the-as uint 0))
      (set! (-> v1-15 base) (&+ (the-as pointer a0-13) 16))
      )
    (flush-cache 0)
    (when (not (paused?))
      (when *stats-buffer*
        (let* ((global-buf (-> this-frame global-buf))
               (calc-current (-> this-calc-buf base))
               (calc-start (-> this-calc-buf data))
               (global-current (-> global-buf base))
               (global-start (-> global-buf data))
               (global-end (-> global-buf end))
               )
          (format *stdcon* "~0kvu1 buf = ~d~%" (&- calc-current (the-as uint calc-start)))
          (format *stdcon* "~0kglobal buf = ~d~%" (&- global-current (the-as uint global-start)))
          (format *stdcon* "~0kbase = #x~x~%" global-current)
          (format *stdcon* "~0kend = #x~x~%" global-end)
          )
        )
      )
    )
  disp
  )

;; definition for function determine-pause-mode
(defun determine-pause-mode ()
  (when (and *debug-pause* (= *master-mode* 'pause))
    (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons start r2))
    (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons start r2))
    (while (and (= *master-mode* 'pause) (zero? (logand (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons start r2))))
      (sync-path 0 0)
      (service-cpads)
      )
    (toggle-pause)
    )
  (when (or (not *progress-process*) (can-go-back? (-> *progress-process* 0)))
    (if (or (cpad-pressed? 0 select r3 start)
            (and (logtest? (-> *cpad-list* cpads 0 valid) 128)
                 (= *master-mode* 'game)
                 (>= (-> *display* base-frame-counter) (-> *game-info* blackout-time))
                 (< (seconds 1003) (-> *display* real-frame-counter))
                 )
            (and (cpad-pressed? 0 r2) (paused?))
            *pause-lock*
            )
        (toggle-pause)
        )
    )
  (if (!= *master-mode* 'progress)
      (deactivate-progress)
      )
  0
  )

;; definition for symbol *surrogate-dma-buffer*, type dma-buffer
(define *surrogate-dma-buffer* (the-as dma-buffer #f))

;; definition for function display-sync
(defun display-sync ((disp display))
  (sync-path 0 0)
  (set! (-> disp frames (-> disp on-screen) frame run-time)
        (the-as int (timer-count (the-as timer-bank #x10000800)))
        )
  (let ((frame-idx (-> disp on-screen))
        (syncv-result (syncv 0))
        )
    (set! *oddeven* syncv-result)
    (when (-> *video-parms* set-video-mode)
      (set-display2 *display* 0 512 (-> *video-parms* screen-sy) 2 49)
      (set! (-> *video-parms* set-video-mode) #f)
      (when (-> *video-parms* reset-video-mode)
        (set! (-> *video-parms* reset-video-mode) #f)
        (if (= (-> *setting-control* current video-mode) 'ntsc)
            (set! *video-reset-parm* 2)
            (set! *video-reset-parm* 3)
            )
        (reset-graph 0 1 *video-reset-parm* 1)
        )
      )
    (put-display-env (-> disp frames frame-idx display))
    (put-draw-env (the-as (pointer gif-tag) (-> disp frames frame-idx gif)))
    (let ((dma-buf-to-send (-> disp frames frame-idx frame calc-buf)))
      (if (nonzero? (dma-buffer-length dma-buf-to-send))
          (dma-buffer-send-chain (the-as dma-bank-source #x10009000) (cond
                                                                       (*surrogate-dma-buffer*
                                                                         *surrogate-dma-buffer*
                                                                         )
                                                                       (else
                                                                         (empty)
                                                                         dma-buf-to-send
                                                                         )
                                                                       )
                                 )
          )
      )
    (determine-pause-mode)
    (let ((next-frame (+ frame-idx 1)))
      (if (< 1 next-frame)
          (set! next-frame 0)
          )
      (set! (-> disp last-screen) (-> disp on-screen))
      (set! (-> disp on-screen) next-frame)
      (display-frame-start disp next-frame syncv-result)
      )
    )
  (none)
  )

;; definition for function swap-display
(defun swap-display ((arg0 display))
  (display-frame-finish arg0)
  (display-sync arg0)
  (none)
  )

;; definition (debug) for function marks-cam-restore
;; INFO: Used lq/sq
;; INFO: Return type mismatch symbol vs none.
(defun-debug marks-cam-restore ()
  (let ((a0-0 (new-stack-vector0))
        (a1-0 (new-stack-matrix0))
        )
    (set! (-> a0-0 x) 1672489.2)
    (set! (-> a0-0 y) 60862.703)
    (set! (-> a0-0 z) -13051605.0)
    (set! (-> a0-0 w) 1.0)
    (set! (-> a1-0 vector 0 x) -0.1783)
    (set! (-> a1-0 vector 0 y) 0.0)
    (set! (-> a1-0 vector 0 z) 0.9839)
    (set! (-> a1-0 vector 0 w) 0.0)
    (set! (-> a1-0 vector 1 x) -0.0629)
    (set! (-> a1-0 vector 1 y) 0.9979)
    (set! (-> a1-0 vector 1 z) -0.0114)
    (set! (-> a1-0 vector 1 w) 0.0)
    (set! (-> a1-0 vector 2 x) -0.9819)
    (set! (-> a1-0 vector 2 y) -0.064)
    (set! (-> a1-0 vector 2 z) -0.178)
    (set! (-> a1-0 vector 2 w) 0.0)
    (set! (-> a1-0 vector 3 x) 0.0)
    (set! (-> a1-0 vector 3 y) 0.0)
    (set! (-> a1-0 vector 3 z) 0.0)
    (set! (-> a1-0 vector 3 w) 1.0)
    (debug-set-camera-pos-rot! a0-0 a1-0)
    )
  (send-event *camera* 'set-fov 17294.205)
  (clear *camera-old-level*)
  (format *camera-old-level* "village3")
  (set! *camera-old-cpu* 1219)
  (set! *camera-old-vu* 9602)
  (set! *camera-old-tfrag-bytes* 0)
  (clear *camera-old-stat-string-tfrag*)
  (clear *camera-old-stat-string-tfrag-near*)
  (clear *camera-old-stat-string-total*)
  (set! *display-camera-old-stats* #t)
  (none)
  )

;; definition (debug) for function eddie-cam-restore
;; INFO: Used lq/sq
;; INFO: Return type mismatch vector vs none.
(defun-debug eddie-cam-restore ()
  (let ((a0-0 (new-stack-vector0))
        (a1-0 (new-stack-matrix0))
        )
    (set! (-> a0-0 x) -427963.66)
    (set! (-> a0-0 y) 24967.182)
    (set! (-> a0-0 z) 339465.53)
    (set! (-> a0-0 w) 1.0)
    (set! (-> a1-0 vector 0 x) -0.6026)
    (set! (-> a1-0 vector 0 y) 0.0)
    (set! (-> a1-0 vector 0 z) 0.7979)
    (set! (-> a1-0 vector 0 w) 0.0)
    (set! (-> a1-0 vector 1 x) -0.1522)
    (set! (-> a1-0 vector 1 y) 0.9816)
    (set! (-> a1-0 vector 1 z) -0.1149)
    (set! (-> a1-0 vector 1 w) 0.0)
    (set! (-> a1-0 vector 2 x) -0.7833)
    (set! (-> a1-0 vector 2 y) -0.1908)
    (set! (-> a1-0 vector 2 z) -0.5915)
    (set! (-> a1-0 vector 2 w) 0.0)
    (set! (-> a1-0 vector 3 x) 0.0)
    (set! (-> a1-0 vector 3 y) 0.0)
    (set! (-> a1-0 vector 3 z) 0.0)
    (set! (-> a1-0 vector 3 w) 1.0)
    (debug-set-camera-pos-rot! a0-0 a1-0)
    )
  (none)
  )

;; definition (debug) for function gregs-jungle-cam-restore
;; INFO: Used lq/sq
;; INFO: Return type mismatch string vs none.
(defun-debug gregs-jungle-cam-restore ()
  (let ((a0-0 (new-stack-vector0))
        (a1-0 (new-stack-matrix0))
        )
    (set! (-> a0-0 x) 1399233.0)
    (set! (-> a0-0 y) 39027.11)
    (set! (-> a0-0 z) -1485580.1)
    (set! (-> a0-0 w) 1.0)
    (set! (-> a1-0 vector 0 x) 0.9965)
    (set! (-> a1-0 vector 0 y) 0.0)
    (set! (-> a1-0 vector 0 z) 0.0829)
    (set! (-> a1-0 vector 0 w) 0.0)
    (set! (-> a1-0 vector 1 x) -0.0021)
    (set! (-> a1-0 vector 1 y) 0.9996)
    (set! (-> a1-0 vector 1 z) 0.0253)
    (set! (-> a1-0 vector 1 w) 0.0)
    (set! (-> a1-0 vector 2 x) -0.0829)
    (set! (-> a1-0 vector 2 y) -0.0254)
    (set! (-> a1-0 vector 2 z) 0.9962)
    (set! (-> a1-0 vector 2 w) 0.0)
    (set! (-> a1-0 vector 3 x) 0.0)
    (set! (-> a1-0 vector 3 y) 0.0)
    (set! (-> a1-0 vector 3 z) 0.0)
    (set! (-> a1-0 vector 3 w) 1.0)
    (debug-set-camera-pos-rot! a0-0 a1-0)
    )
  (send-event *camera* 'set-fov 11650.845)
  (clear *camera-old-level*)
  (format *camera-old-level* "jungle")
  (set! *camera-old-cpu* 5801)
  (set! *camera-old-vu* 9605)
  (set! *camera-old-tfrag-bytes* #x1ffee0)
  (clear *camera-old-stat-string-tfrag*)
  (clear *camera-old-stat-string-tfrag-near*)
  (clear *camera-old-stat-string-total*)
  (none)
  )

;; definition (debug) for function gregs-village1-cam-restore
;; INFO: Used lq/sq
;; INFO: Return type mismatch string vs none.
(defun-debug gregs-village1-cam-restore ()
  (let ((a0-0 (new-stack-vector0))
        (a1-0 (new-stack-matrix0))
        )
    (set! (-> a0-0 x) -511224.06)
    (set! (-> a0-0 y) 157579.95)
    (set! (-> a0-0 z) 764585.25)
    (set! (-> a0-0 w) 1.0)
    (set! (-> a1-0 vector 0 x) -0.9009)
    (set! (-> a1-0 vector 0 y) 0.0)
    (set! (-> a1-0 vector 0 z) -0.4338)
    (set! (-> a1-0 vector 0 w) 0.0)
    (set! (-> a1-0 vector 1 x) 0.0984)
    (set! (-> a1-0 vector 1 y) 0.9739)
    (set! (-> a1-0 vector 1 z) -0.2043)
    (set! (-> a1-0 vector 1 w) 0.0)
    (set! (-> a1-0 vector 2 x) 0.4225)
    (set! (-> a1-0 vector 2 y) -0.2268)
    (set! (-> a1-0 vector 2 z) -0.8774)
    (set! (-> a1-0 vector 2 w) 0.0)
    (set! (-> a1-0 vector 3 x) 0.0)
    (set! (-> a1-0 vector 3 y) 0.0)
    (set! (-> a1-0 vector 3 z) 0.0)
    (set! (-> a1-0 vector 3 w) 1.0)
    (debug-set-camera-pos-rot! a0-0 a1-0)
    )
  (send-event *camera* 'set-fov 11650.845)
  (clear *camera-old-level*)
  (format *camera-old-level* "village1")
  (set! *camera-old-cpu* 4899)
  (set! *camera-old-vu* 9605)
  (set! *camera-old-tfrag-bytes* #x24e680)
  (clear *camera-old-stat-string-tfrag*)
  (clear *camera-old-stat-string-tfrag-near*)
  (clear *camera-old-stat-string-total*)
  (none)
  )

;; definition (debug) for function gregs-texture-cam-restore
;; INFO: Used lq/sq
;; INFO: Return type mismatch string vs none.
(defun-debug gregs-texture-cam-restore ()
  (let ((a0-0 (new-stack-vector0))
        (a1-0 (new-stack-matrix0))
        )
    (set! (-> a0-0 x) 1103816.0)
    (set! (-> a0-0 y) 96275.71)
    (set! (-> a0-0 z) -632064.5)
    (set! (-> a0-0 w) 1.0)
    (set! (-> a1-0 vector 0 x) 0.4063)
    (set! (-> a1-0 vector 0 y) 0.0)
    (set! (-> a1-0 vector 0 z) -0.9137)
    (set! (-> a1-0 vector 0 w) 1.0)
    (set! (-> a1-0 vector 1 x) 0.2824)
    (set! (-> a1-0 vector 1 y) 0.951)
    (set! (-> a1-0 vector 1 z) 0.1256)
    (set! (-> a1-0 vector 1 w) 1.0)
    (set! (-> a1-0 vector 2 x) 0.8689)
    (set! (-> a1-0 vector 2 y) -0.3091)
    (set! (-> a1-0 vector 2 z) 0.3864)
    (set! (-> a1-0 vector 2 w) 1.0)
    (set! (-> a1-0 vector 3 x) 0.0)
    (set! (-> a1-0 vector 3 y) 0.0)
    (set! (-> a1-0 vector 3 z) 0.0)
    (set! (-> a1-0 vector 3 w) 1.0)
    (debug-set-camera-pos-rot! a0-0 a1-0)
    )
  (send-event *camera* 'set-fov 11650.845)
  (clear *camera-old-level*)
  (format *camera-old-level* "village1")
  (set! *camera-old-cpu* 4772)
  (set! *camera-old-vu* 9603)
  (set! *camera-old-tfrag-bytes* #x22e680)
  (clear *camera-old-stat-string-tfrag*)
  (clear *camera-old-stat-string-tfrag-near*)
  (clear *camera-old-stat-string-total*)
  (none)
  )

;; definition (debug) for function gregs-texture2-cam-restore
;; INFO: Used lq/sq
;; INFO: Return type mismatch string vs none.
(defun-debug gregs-texture2-cam-restore ()
  (let ((a0-0 (new-stack-vector0))
        (a1-0 (new-stack-matrix0))
        )
    (set! (-> a0-0 x) 1954572.9)
    (set! (-> a0-0 y) 135123.98)
    (set! (-> a0-0 z) -1028725.44)
    (set! (-> a0-0 w) 1.0)
    (set! (-> a1-0 vector 0 x) 0.2535)
    (set! (-> a1-0 vector 0 y) 0.0)
    (set! (-> a1-0 vector 0 z) 0.9673)
    (set! (-> a1-0 vector 0 w) 1.0)
    (set! (-> a1-0 vector 1 x) -0.1051)
    (set! (-> a1-0 vector 1 y) 0.994)
    (set! (-> a1-0 vector 1 z) 0.0275)
    (set! (-> a1-0 vector 1 w) 1.0)
    (set! (-> a1-0 vector 2 x) -0.9615)
    (set! (-> a1-0 vector 2 y) -0.1087)
    (set! (-> a1-0 vector 2 z) 0.252)
    (set! (-> a1-0 vector 2 w) 1.0)
    (set! (-> a1-0 vector 3 x) 0.0)
    (set! (-> a1-0 vector 3 y) 0.0)
    (set! (-> a1-0 vector 3 z) 0.0)
    (set! (-> a1-0 vector 3 w) 1.0)
    (debug-set-camera-pos-rot! a0-0 a1-0)
    )
  (send-event *camera* 'set-fov 11650.845)
  (clear *camera-old-level*)
  (format *camera-old-level* "village1")
  (set! *camera-old-cpu* 4936)
  (set! *camera-old-vu* #x4b0c)
  (set! *camera-old-tfrag-bytes* #x22e680)
  (clear *camera-old-stat-string-tfrag*)
  (clear *camera-old-stat-string-tfrag-near*)
  (clear *camera-old-stat-string-total*)
  (none)
  )

;; definition (debug) for function cave-cam-restore
;; INFO: Used lq/sq
;; INFO: Return type mismatch vector vs none.
(defun-debug cave-cam-restore ()
  (let ((a0-0 (new-stack-vector0))
        (a1-0 (new-stack-matrix0))
        )
    (set! (-> a0-0 x) -1449013.1)
    (set! (-> a0-0 y) 15114.015)
    (set! (-> a0-0 z) -1621305.5)
    (set! (-> a0-0 w) 1.0)
    (set! (-> a1-0 vector 0 x) -0.8223)
    (set! (-> a1-0 vector 0 y) 0.0)
    (set! (-> a1-0 vector 0 z) -0.5689)
    (set! (-> a1-0 vector 0 w) 0.0)
    (set! (-> a1-0 vector 1 x) 0.0076)
    (set! (-> a1-0 vector 1 y) 0.9999)
    (set! (-> a1-0 vector 1 z) -0.0111)
    (set! (-> a1-0 vector 1 w) 0.0)
    (set! (-> a1-0 vector 2 x) 0.5689)
    (set! (-> a1-0 vector 2 y) -0.0135)
    (set! (-> a1-0 vector 2 z) -0.8222)
    (set! (-> a1-0 vector 2 w) 0.0)
    (set! (-> a1-0 vector 3 x) 0.0)
    (set! (-> a1-0 vector 3 y) 0.0)
    (set! (-> a1-0 vector 3 z) 0.0)
    (set! (-> a1-0 vector 3 w) 1.0)
    (debug-set-camera-pos-rot! a0-0 a1-0)
    )
  (none)
  )

;; definition (debug) for function paals-cam-restore
;; INFO: Used lq/sq
;; INFO: Return type mismatch vector vs none.
(defun-debug paals-cam-restore ()
  (let ((a0-0 (new-stack-vector0))
        (a1-0 (new-stack-matrix0))
        )
    (set! (-> a0-0 x) -791260.7)
    (set! (-> a0-0 y) 50858.62)
    (set! (-> a0-0 z) -163715.47)
    (set! (-> a0-0 w) 1.0)
    (set! (-> a1-0 vector 0 x) -0.7816)
    (set! (-> a1-0 vector 0 y) 0.0)
    (set! (-> a1-0 vector 0 z) -0.6236)
    (set! (-> a1-0 vector 0 w) 0.0)
    (set! (-> a1-0 vector 1 x) 0.0672)
    (set! (-> a1-0 vector 1 y) 0.9941)
    (set! (-> a1-0 vector 1 z) -0.0843)
    (set! (-> a1-0 vector 1 w) 0.0)
    (set! (-> a1-0 vector 2 x) 0.62)
    (set! (-> a1-0 vector 2 y) -0.1079)
    (set! (-> a1-0 vector 2 z) -0.7771)
    (set! (-> a1-0 vector 2 w) 0.0)
    (set! (-> a1-0 vector 3 x) 0.0)
    (set! (-> a1-0 vector 3 y) 0.0)
    (set! (-> a1-0 vector 3 z) 0.0)
    (set! (-> a1-0 vector 3 w) 1.0)
    (debug-set-camera-pos-rot! a0-0 a1-0)
    )
  (none)
  )
