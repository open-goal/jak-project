;;-*-Lisp-*-
(in-package goal)

;; definition for function unpack-comp-rle
;; INFO: Return type mismatch int vs none.
(defun unpack-comp-rle ((out (pointer int8)) (in (pointer int8)))
  (local-vars (current-input int) (copy-length int))
  (nop!)
  (loop
    (loop
      (set! current-input (-> in 0))
      (set! in (&-> in 1))
      (b! (<= current-input 0) cfg-5 :delay (nop!))
      (let ((repeated-value (-> in 0)))
        (set! in (&-> in 1))
        (label cfg-3)
        (nop!)
        (nop!)
        (nop!)
        (nop!)
        (set! (-> out 0) repeated-value)
        )
      (set! out (&-> out 1))
      (b! (> current-input 0) cfg-3 :delay (set! current-input (+ current-input -1)))
      )
    (label cfg-5)
    (b! (zero? current-input) cfg-8 :delay (set! copy-length (- current-input)))
    (label cfg-6)
    (let ((src-val (-> in 0)))
      (set! in (&-> in 1))
      (nop!)
      (nop!)
      (set! (-> out 0) src-val)
      )
    (+! copy-length -1)
    (b! (> copy-length 0) cfg-6 :delay (set! out (&-> out 1)))
    )
  (label cfg-8)
  0
  (none)
  )

;; definition of type huf-dictionary-node
(deftype huf-dictionary-node (structure)
  ((zero uint16  :offset-assert   0)
   (one  uint16  :offset-assert   2)
   )
  :method-count-assert 9
  :size-assert         #x4
  :flag-assert         #x900000004
  )

;; definition for method 3 of type huf-dictionary-node
(defmethod inspect huf-dictionary-node ((obj huf-dictionary-node))
  (format #t "[~8x] ~A~%" obj 'huf-dictionary-node)
  (format #t "~Tzero: ~D~%" (-> obj zero))
  (format #t "~Tone: ~D~%" (-> obj one))
  obj
  )

;; definition for function unpack-comp-huf
;; INFO: Return type mismatch int vs none.
(defun unpack-comp-huf ((arg0 (pointer uint8)) (arg1 (pointer uint8)) (arg2 uint) (arg3 huf-dictionary-node))
  (local-vars (t1-1 uint) (t3-2 object))
  (nop!)
  (let ((t1-0 (-> arg3 zero))
        (a2-1 (+ arg2 -1028))
        (t2-0 (-> arg3 one))
        )
    (nop!)
    (label cfg-1)
    (let ((v1-4 128))
      (nop!)
      (let ((t0-0 (-> arg1 0)))
        (set! arg1 (&-> arg1 1))
        (label cfg-2)
        (let ((t3-0 (logand t0-0 v1-4)))
          (shift-arith-right-32 v1-4 v1-4 1)
          (b! (zero? t3-0) cfg-4 :delay (set! t1-1 t1-0))
          )
        )
      (nop!)
      (set! t1-1 t2-0)
      (label cfg-4)
      (let ((t2-1 (+ t1-1 -256)))
        (let ((t3-1 (* t1-1 4)))
          (b! (< (the-as int t2-1) 0) cfg-8 :delay (set! t3-2 (+ t3-1 a2-1)))
          )
        (b! (zero? t2-1) cfg-10 :delay (set! t1-0 (-> (the-as (pointer uint16) t3-2) 0)))
        )
      (b! (nonzero? v1-4) cfg-2 :delay (set! t2-0 (-> (the-as (pointer uint16) t3-2) 1)))
      (b! #t cfg-1 :delay (nop!))
      (label cfg-8)
      (set! (-> arg0 0) t1-1)
      (set! arg0 (&-> arg0 1))
      (nop!)
      (set! t1-0 (-> arg3 zero))
      (b! (nonzero? v1-4) cfg-2 :delay (set! t2-0 (-> arg3 one)))
      )
    )
  (b! #t cfg-1 :delay (nop!))
  (label cfg-10)
  (nop!)
  (nop!)
  0
  (none)
  )

;; definition for method 16 of type level
;; INFO: Used lq/sq
(defmethod update-vis! level ((obj level) (vis-info level-vis-info) (arg1 uint) (arg2 uint))
  (local-vars (t0-3 uint128) (vis-buffer object))
  (let* ((cam-leaf-idx (-> vis-info from-bsp current-leaf-idx))
         (curr-vis-str (-> vis-info current-vis-string))
         (desired-vis-str (-> vis-info vis-string cam-leaf-idx))
         )
    0
    (+ 16 #x70000000)
    (+ 2064 #x70000000)
    (when (= curr-vis-str desired-vis-str)
      (b! (zero? (logand #x40000000 (-> vis-info flags))) cfg-6 :delay (empty-form))
      (if (check-busy *ramdisk-rpc*)
          (return #f)
          )
      (set! (-> vis-info flags) (logand -1073741825 (-> vis-info flags)))
      (set! vis-buffer (-> obj vis-buffer))
      (b! #t cfg-27 :delay (nop!))
      (label cfg-6)
      (return #t)
      )
    (when (logtest? #x40000000 (-> vis-info flags))
      (if (check-busy *ramdisk-rpc*)
          (return #f)
          )
      (set! (-> vis-info flags) (logand -1073741825 (-> vis-info flags)))
      )
    (set! (-> vis-info current-vis-string) desired-vis-str)
    (b! (logtest? #x20000000 (-> vis-info flags)) cfg-15 :delay (empty-form))
    (set! vis-buffer (+ arg2 desired-vis-str))
    (b! #t cfg-27 :delay (nop!))
    (label cfg-15)
    (let ((vis-load-result (vis-load obj)))
      (b! (nonzero? vis-load-result) cfg-21 :delay (empty-form))
      (let* ((dest-bits (-> vis-info vis-bits))
             (len (-> obj bsp visible-list-length))
             (bsp-bits (the-as (pointer uinteger) (-> obj bsp all-visible-list)))
             (len-qw (/ (+ len 15) 16))
             )
        (dotimes (a2-1 len-qw)
          (set! (-> (the-as (pointer uint128) dest-bits) 0) (-> (the-as (pointer uint128) bsp-bits) 0))
          (&+! dest-bits 16)
          (set! bsp-bits (&-> (the-as (pointer uint16) bsp-bits) 8))
          )
        )
      (let ((result #f))
        (b! #t cfg-55 :delay (nop!))
        (the-as none 0)
        (label cfg-21)
        (when (check-busy *ramdisk-rpc*)
          (set! (-> vis-info current-vis-string) (the-as uint -1))
          (set! (-> obj all-visible?) 'loading)
          (if (= *cheat-mode* 'debug)
              (format *stdcon* "Ramdisk loading~%")
              )
          (return #f)
          )
        (set! (-> vis-info flags) (logior #x40000000 (-> vis-info flags)))
        (ramdisk-load (the-as int vis-load-result) desired-vis-str (the-as uint 2048) (-> obj vis-buffer))
        (set! result #f)
        (b! #t cfg-55 :delay (nop!))
        (label cfg-27)
        (let ((lower-flag-bits (the-as int (logand #x1fffffff (-> vis-info flags))))
              (spad-start (the-as object (+ 16 #x70000000)))
              (spad-end (+ 2064 #x70000000))
              (list-len (-> obj bsp visible-list-length))
              )
          (when (zero? (the-as uint lower-flag-bits))
            (let ((list-qwc (/ (+ list-len 15) 16)))
              (dotimes (a0-28 list-qwc)
                (set! (-> (the-as (pointer uint128) spad-start) a0-28) (the-as uint128 0))
                )
              )
            (mem-copy! (the-as pointer spad-start) (the-as pointer vis-buffer) list-len)
            )
          (while (nonzero? lower-flag-bits)
            (case (logand lower-flag-bits 7)
              ((1)
               (let ((v1-55 (/ (+ list-len 15) 16)))
                 (dotimes (a0-32 v1-55)
                   (set! (-> (the-as (pointer uint128) spad-start) a0-32) (the-as uint128 0))
                   )
                 )
               (unpack-vis (-> obj bsp drawable-trees) (the-as (pointer int8) spad-start) (the-as (pointer int8) vis-buffer))
               )
              ((2)
               (unpack-comp-rle (the-as (pointer int8) spad-start) (the-as (pointer int8) vis-buffer))
               )
              ((3)
               (unpack-comp-huf
                 (the-as (pointer uint8) spad-start)
                 (the-as (pointer uint8) vis-buffer)
                 (-> vis-info dictionary)
                 (the-as huf-dictionary-node (+ (-> vis-info dictionary) (-> vis-info dictionary-length) -4))
                 )
               )
              )
            (set! vis-buffer (the-as int spad-start))
            (set! spad-start spad-end)
            (set! spad-end (the-as int vis-buffer))
            (shift-arith-right-32 lower-flag-bits lower-flag-bits 3)
            )
          (let ((s2-1 vis-buffer)
                (s1-1 (the-as (pointer uinteger) (-> obj bsp all-visible-list)))
                (v1-67 #f)
                )
            (dotimes (s0-1 list-len)
              (when (!= (logand (-> (the-as (pointer uint8) s2-1) 0) (-> (the-as (pointer uint8) s1-1) 0))
                        (-> (the-as (pointer uint8) s2-1) 0)
                        )
                (format
                  #t
                  "ERROR: illegal vis bits set [byte ~X] ~X -> ~X~%"
                  s0-1
                  (-> (the-as (pointer uint8) s2-1) 0)
                  (-> (the-as (pointer uint8) s1-1) 0)
                  )
                (set! v1-67 #t)
                )
              (set! s2-1 (&-> (the-as (pointer uint8) s2-1) 1))
              (set! s1-1 (&+ (the-as (pointer uint16) s1-1) 1))
              )
            (when v1-67
              (format
                #t
                "src = #x~x dest = #x~x  ~s  ~s~%"
                vis-buffer
                (-> vis-info vis-bits)
                (-> vis-info level)
                (-> vis-info from-level)
                )
              (format #t "leaf-index = ~d~%" (-> vis-info from-bsp current-leaf-idx))
              0
              )
            )
          (let ((v1-71 vis-buffer)
                (a0-47 (-> vis-info vis-bits))
                (a1-22 (the-as (pointer uinteger) (-> obj bsp all-visible-list)))
                (a2-11 (/ (+ list-len 15) 16))
                )
            (dotimes (a3-8 a2-11)
              (let ((t0-2 (-> (the-as (pointer uint128) v1-71) 0))
                    (t1-1 (-> (the-as (pointer uint128) a1-22) 0))
                    )
                (.pand t0-3 t0-2 t1-1)
                )
              (set! (-> (the-as (pointer uint128) a0-47) 0) t0-3)
              (&+! a0-47 16)
              (set! v1-71 (&-> (the-as (pointer uint16) v1-71) 8))
              (set! a1-22 (&-> (the-as (pointer uint16) a1-22) 8))
              )
            )
          )
        (set! result #t)
        (label cfg-55)
        result
        )
      )
    )
  )
