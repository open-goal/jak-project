;;-*-Lisp-*-
(in-package goal)

;; definition for function plane-from-points
;; WARN: Unsupported inline assembly instruction kind - [mula.s f0, f3]
;; WARN: Unsupported inline assembly instruction kind - [madda.s f1, f4]
;; WARN: Unsupported inline assembly instruction kind - [madd.s f0, f2, f5]
(defun
  plane-from-points
  ((arg0 (inline-array plane))
   (arg1 vector)
   (arg2 vector)
   (arg3 vector)
   (arg4 int)
   )
  (local-vars (f0-1 float))
  (rlet ((acc :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
   (let ((s4-0 (new 'stack-no-clear 'vector)))
    (let ((v1-0 s4-0))
     (let ((a1-1 arg2))
      (.lvf vf1 (&-> arg1 quad))
      (.lvf vf2 (&-> a1-1 quad))
      )
     (.outer.product.vf vf3 vf1 vf2)
     (.svf (&-> v1-0 quad) vf3)
     )
    (vector-normalize! s4-0 1.0)
    (let* ((v1-1 s4-0))
     (set! f0-1 (vector-dot v1-1 arg3))
     )
    (set! (-> s4-0 w) f0-1)
    (set! (-> arg0 0 data arg4) (-> s4-0 x))
    (set! (-> arg0 1 data arg4) (-> s4-0 y))
    (set! (-> arg0 2 data arg4) (-> s4-0 z))
    (let ((f0-6 (-> s4-0 w)))
     (set! (-> arg0 3 data arg4) f0-6)
     f0-6
     )
    )
   )
  )

;; definition for function set-point
(defun set-point ((arg0 vector) (arg1 float) (arg2 float) (arg3 float))
  (set! (-> arg0 x) arg1)
  (set! (-> arg0 y) arg2)
  (set! (-> arg0 z) arg3)
  (let ((f0-3 1.0))
   (set! (-> arg0 w) f0-3)
   f0-3
   )
  )

;; definition for function update-view-planes
;; Used lq/sq
(defun
  update-view-planes
  ((arg0 math-camera) (arg1 (inline-array plane)) (arg2 float))
  (local-vars (sv-240 vector))
  (when (not *artist-fix-frustum*)
   (let ((s5-0 (new 'stack 'view-frustum)))
    (let ((f30-0 (* (* arg2 (-> arg0 x-ratio)) (-> arg0 d)))
          (f26-0 (* (* arg2 (-> arg0 y-ratio)) (-> arg0 d)))
          (f28-0 (* (* arg2 (-> arg0 x-ratio)) (-> arg0 f)))
          (f24-0 (* (* arg2 (-> arg0 y-ratio)) (-> arg0 f)))
          )
     (set-point (-> s5-0 hither-top-left) (- f30-0) f26-0 (-> arg0 d))
     (set-point (-> s5-0 hither-top-right) f30-0 f26-0 (-> arg0 d))
     (set-point (-> s5-0 hither-bottom-left) (- f30-0) (- f26-0) (-> arg0 d))
     (set-point (-> s5-0 hither-bottom-right) f30-0 (- f26-0) (-> arg0 d))
     (set-point (-> s5-0 yon-top-left) (- f28-0) f24-0 (-> arg0 f))
     (set-point (-> s5-0 yon-top-right) f28-0 f24-0 (-> arg0 f))
     (set-point (-> s5-0 yon-bottom-left) (- f28-0) (- f24-0) (-> arg0 f))
     (set-point (-> s5-0 yon-bottom-right) f28-0 (- f24-0) (-> arg0 f))
     )
    (vector-matrix*!
     (-> s5-0 hither-top-left)
     (-> s5-0 hither-top-left)
     (-> arg0 inv-camera-rot)
     )
    (vector-matrix*!
     (-> s5-0 hither-top-right)
     (-> s5-0 hither-top-right)
     (-> arg0 inv-camera-rot)
     )
    (vector-matrix*!
     (-> s5-0 hither-bottom-left)
     (-> s5-0 hither-bottom-left)
     (-> arg0 inv-camera-rot)
     )
    (vector-matrix*!
     (-> s5-0 hither-bottom-right)
     (-> s5-0 hither-bottom-right)
     (-> arg0 inv-camera-rot)
     )
    (vector-matrix*!
     (-> s5-0 yon-top-left)
     (-> s5-0 yon-top-left)
     (-> arg0 inv-camera-rot)
     )
    (vector-matrix*!
     (-> s5-0 yon-top-right)
     (-> s5-0 yon-top-right)
     (-> arg0 inv-camera-rot)
     )
    (vector-matrix*!
     (-> s5-0 yon-bottom-left)
     (-> s5-0 yon-bottom-left)
     (-> arg0 inv-camera-rot)
     )
    (vector-matrix*!
     (-> s5-0 yon-bottom-right)
     (-> s5-0 yon-bottom-right)
     (-> arg0 inv-camera-rot)
     )
    (let ((s2-0 (new-stack-vector0))
          (s3-1 (new-stack-vector0))
          (s1-0 (new-stack-vector0))
          (s0-0 (new-stack-vector0))
          )
     (set! (-> (new 'stack-no-clear 'vector) quad) (the-as uint128 0))
     (set! sv-240 (new 'stack-no-clear 'vector))
     (set! (-> sv-240 quad) (the-as uint128 0))
     (let ((v1-5 (-> arg0 inv-camera-rot vector 3 quad)))
      (set! (-> sv-240 quad) v1-5)
      )
     (vector-! s2-0 (-> s5-0 yon-top-left) sv-240)
     (vector-! s3-1 (-> s5-0 yon-top-right) sv-240)
     (vector-! s1-0 (-> s5-0 yon-bottom-left) sv-240)
     (vector-! s0-0 (-> s5-0 yon-bottom-right) sv-240)
     (plane-from-points arg1 s2-0 s1-0 sv-240 0)
     (plane-from-points arg1 s0-0 s3-1 sv-240 1)
     (plane-from-points arg1 s3-1 s2-0 sv-240 2)
     (let ((t9-20 plane-from-points)
           (t0-3 3)
           )
      (t9-20 arg1 s1-0 s0-0 sv-240 t0-3)
      )
     )
    )
   )
  )

;; definition for symbol *update-leaf-when-outside-bsp*, type symbol
(define *update-leaf-when-outside-bsp* #t)

;; definition for function update-visible
(defun update-visible ((arg0 math-camera) (arg1 int) (arg2 uint) (arg3 uint))
  (local-vars (a0-16 symbol) (s3-0 level-vis-info) (s4-0 level-vis-info))
  (when (not *artist-fix-visible*)
   (dotimes (s5-0 (-> *level* length))
    (let ((v1-4 (-> *level* level s5-0)))
     (when (= (-> v1-4 status) 'active)
      (if
       (and
        (nonzero? (-> v1-4 bsp nodes))
        (or *update-leaf-when-outside-bsp* (-> v1-4 inside-boxes?))
        )
       (bsp-camera-asm (-> v1-4 bsp) (-> arg0 trans))
       )
      )
     )
    )
   (dotimes (gp-1 (-> *level* length))
    (let ((s5-1 (-> *level* level gp-1)))
     (when (= (-> s5-1 status) 'active)
      (let ((a2-1 (/ (+ (-> s5-1 bsp visible-list-length) 15) 16)))
       (set! (-> s5-1 all-visible?) (if (-> s5-1 all-visible?)
                                     (-> s5-1 all-visible?)
                                     #t
                                     )
        )
       (cond
        ((or (not (-> s5-1 force-all-visible?)) (-> s5-1 inside-boxes?))
         (cond
          ((or *artist-all-visible* (zero? (-> s5-1 bsp nodes)))
           (quad-copy! (-> s5-1 vis-bits) (-> s5-1 bsp all-visible-list) a2-1)
           )
          ((begin
            (set! s4-0 (-> s5-1 vis-info (-> s5-1 vis-self-index)))
            (set! s3-0 (-> s5-1 vis-info (-> s5-1 vis-adj-index)))
            (let ((v1-32 #f))
             (set! a0-16 #f)
             (when s4-0
              (set!
               v1-32
               (nonzero? (logand (shl #x8000 16) (the-as int (-> s4-0 flags))))
               )
              (let ((a1-8 (-> s4-0 length)))
               (set! arg3 (-> s4-0 from-bsp unk-data-2 0))
               (if (< a1-8 arg3)
                (set! v1-32 #f)
                )
               )
              )
             (when s3-0
              (set!
               a0-16
               (nonzero? (logand (shl #x8000 16) (the-as int (-> s3-0 flags))))
               )
              (let ((a1-15 (-> s3-0 length)))
               (set! arg3 (-> s3-0 from-bsp unk-data-2 0))
               (if (< a1-15 arg3)
                (set! a0-16 #f)
                )
               )
              )
             v1-32
             )
            )
           (if (!= (-> s5-1 all-visible?) 'loading)
            (set! (-> s5-1 all-visible?) #f)
            )
           (let* ((a0-19 s5-1)
                  (t9-2 (method-of-object a0-19 dummy-16))
                  )
            (-> s4-0 ramdisk)
            (set! arg3 (-> s4-0 string-block))
            (when (t9-2 a0-19)
             (countdown (v1-40 8)
              (let ((a0-22 (-> s5-1 vis-info v1-40)))
               (when a0-22
                (if (!= a0-22 s4-0)
                 (set! (-> a0-22 current-vis-string) (the-as uint -1))
                 )
                )
               )
              )
             (set! (-> s5-1 all-visible?) #f)
             )
            )
           )
          (else
           (cond
            (a0-16
             (if (!= (-> s5-1 all-visible?) 'loading)
              (set! (-> s5-1 all-visible?) #f)
              )
             (let* ((a0-24 s5-1)
                    (t9-3 (method-of-object a0-24 dummy-16))
                    )
              (-> s3-0 ramdisk)
              (set! arg3 (-> s3-0 string-block))
              (when (t9-3 a0-24)
               (countdown (v1-50 8)
                (let ((a0-27 (-> s5-1 vis-info v1-50)))
                 (when a0-27
                  (if (!= a0-27 s3-0)
                   (set! (-> a0-27 current-vis-string) (the-as uint -1))
                   )
                  )
                 )
                )
               (set! (-> s5-1 all-visible?) #f)
               )
              )
             )
            (else
             (cond
              ((and (= (-> s5-1 all-visible?) 'loading) (-> *level* play?))
               )
              (else
               (quad-copy!
                (-> s5-1 vis-bits)
                (-> s5-1 bsp all-visible-list)
                a2-1
                )
               )
              )
             )
            )
           )
          )
         )
        (else
         (quad-copy! (-> s5-1 vis-bits) (-> s5-1 bsp all-visible-list) a2-1)
         )
        )
       )
      (if (and *stats-bsp* (= *master-mode* 'game))
       (format *stdcon* "~0kleaf-index = ~d~%" (-> s5-1 bsp unk-data-2 0) arg3)
       )
      )
     )
    )
   #f
   )
  )

;; definition for symbol *save-camera-inv-rot*, type matrix
(define *save-camera-inv-rot* (new 'global 'matrix))

;; failed to figure out what this is:
(matrix-identity! *save-camera-inv-rot*)

;; definition for function move-camera-from-pad
;; Used lq/sq
(defun move-camera-from-pad ((arg0 math-camera))
  (let ((v1-0 *external-cam-mode*)
        (s5-0 0)
        )
   (cond
    ((= v1-0 'locked)
     (set! v1-0 #f)
     )
    ((= v1-0 'pad-1)
     (set! s5-0 1)
     )
    ((not *camera-combiner*)
     (set! v1-0 'pad-0)
     )
    )
   (when v1-0
    (let
     ((s4-1
       (vector-negate-in-place!
        (vector-normalize-copy!
         (new-stack-vector0)
         (-> *standard-dynamics* gravity)
         1.0
         )
        )
       )
      )
     (if (= (vector-length s4-1) 0.0)
      (set! (-> s4-1 y) -1.0)
      )
     (if (nonzero? (logand *external-cam-options* 1))
      (set! s4-1 (the-as vector #f))
      )
     (cam-free-floating-move *save-camera-inv-rot* (-> arg0 trans) s4-1 s5-0)
     )
    )
   )
  (let* ((a2-2 (-> *math-camera* inv-camera-rot))
         (a3-1 *save-camera-inv-rot*)
         (v1-11 (-> a3-1 vector 0 quad))
         (a0-14 (-> a3-1 vector 1 quad))
         (a1-2 (-> a3-1 vector 2 quad))
         (a3-2 (-> a3-1 vector 3 quad))
         )
   (set! (-> a2-2 vector 0 quad) v1-11)
   (set! (-> a2-2 vector 1 quad) a0-14)
   (set! (-> a2-2 vector 2 quad) a1-2)
   (set! (-> a2-2 vector 3 quad) a3-2)
   )
  arg0
  )

;; definition for symbol *start-timer*, type int
(define *start-timer* (the-as int #f))

;; definition for symbol *timer-value*, type int
(define *timer-value* 0)

;; definition for symbol *start-pos*, type vector
(define *start-pos* (new 'global 'vector))

;; definition for function update-camera
;; Used lq/sq
(defun update-camera ()
  (local-vars (a3-12 number))
  (when *start-timer*
   (when (= *timer-value* 180)
    (format
     #t
     "Player pos = ~F ~F ~F~%"
     (-> *target* control trans x)
     (-> *target* control trans y)
     (-> *target* control trans z)
     )
    (set! (-> *start-pos* quad) (-> *target* control trans quad))
    )
   (when (= *timer-value* 480)
    (format
     #t
     "Player pos = ~F ~F ~F~%"
     (-> *target* control trans x)
     (-> *target* control trans y)
     (-> *target* control trans z)
     )
    (format
     #t
     "Dist = ~F~%"
     (*
      0.00024414062
      (vector-vector-xz-distance (-> *target* control trans) *start-pos*)
      )
     )
    (set! *start-timer* (the-as int #f))
    )
   (if (< 179 *timer-value*)
    (format *stdcon* "~%~%Time = ~D~%" *timer-value*)
    )
   (set! *timer-value* (+ *timer-value* 1))
   )
  (when (not *start-timer*)
   (set! *timer-value* 0)
   0
   )
  (dotimes (gp-1 2)
   (let ((s5-1 (-> *level* level gp-1)))
    (when (!= (-> s5-1 status) 'inactive)
     (let ((a0-14 (new-stack-vector0)))
      (vector-!
       a0-14
       (the-as vector (-> s5-1 info bsphere))
       (-> *math-camera* trans)
       )
      (set!
       (-> s5-1 level-distance)
       (fmax 0.0 (- (vector-length a0-14) (-> s5-1 info bsphere w)))
       )
      )
     (when *display-level-spheres*
      (add-debug-sphere
       #t
       (bucket-id debug-draw1)
       (-> s5-1 info bsphere)
       (-> s5-1 info bsphere w)
       (new 'static 'rgba :r #xff :a #x80)
       )
      (format
       *stdcon*
       "~f ~f ~f ~f~%"
       (* 0.00024414062 (-> s5-1 info bsphere x))
       (* 0.00024414062 (-> s5-1 info bsphere y))
       (* 0.00024414062 (-> s5-1 info bsphere z))
       (* 0.00024414062 (-> s5-1 info bsphere w))
       )
      )
     )
    )
   )
  (update-math-camera
   *math-camera*
   (-> *setting-control* current video-mode)
   (-> *setting-control* current aspect-ratio)
   )
  (update! *camera-smush-control*)
  (cond
   ((or (= *master-mode* 'pause) (= *master-mode* 'progress) *progress-process*)
    )
   ((>= *camera-look-through-other* 2)
    (set! *camera-look-through-other* 1)
    )
   ((and (= *camera-look-through-other* 1) (!= *master-mode* 'menu))
    (set! *camera-look-through-other* 0)
    0
    )
   )
  (cond
   (*external-cam-mode*
    (move-camera-from-pad *math-camera*)
    )
   ((nonzero? *camera-look-through-other*)
    (set! (-> *math-camera* fov) (-> *camera-other-fov* data))
    (set! (-> *math-camera* trans quad) (-> *camera-other-trans* quad))
    (set!
     (-> *math-camera* trans y)
     (+ (-> *math-camera* trans y) (get-no-update *camera-smush-control*))
     )
    (let* ((a2-9 (-> *math-camera* inv-camera-rot))
           (a3-4 *camera-other-matrix*)
           (v1-86 (-> a3-4 vector 0 quad))
           (a0-29 (-> a3-4 vector 1 quad))
           (a1-10 (-> a3-4 vector 2 quad))
           (a3-5 (-> a3-4 vector 3 quad))
           )
     (set! (-> a2-9 vector 0 quad) v1-86)
     (set! (-> a2-9 vector 1 quad) a0-29)
     (set! (-> a2-9 vector 2 quad) a1-10)
     (set! (-> a2-9 vector 3 quad) a3-5)
     )
    (let* ((a2-10 *save-camera-inv-rot*)
           (a3-6 *camera-other-matrix*)
           (v1-87 (-> a3-6 vector 0 quad))
           (a0-30 (-> a3-6 vector 1 quad))
           (a1-11 (-> a3-6 vector 2 quad))
           (a3-7 (-> a3-6 vector 3 quad))
           )
     (set! (-> a2-10 vector 0 quad) v1-87)
     (set! (-> a2-10 vector 1 quad) a0-30)
     (set! (-> a2-10 vector 2 quad) a1-11)
     (set! (-> a2-10 vector 3 quad) a3-7)
     )
    )
   (else
    (cond
     ((and *camera-combiner* (not *external-cam-mode*))
      (set! (-> *math-camera* fov) (-> *camera-combiner* fov))
      (set! (-> *math-camera* trans quad) (-> *camera-combiner* trans quad))
      (set!
       (-> *math-camera* trans y)
       (+ (-> *math-camera* trans y) (get-no-update *camera-smush-control*))
       )
      (let* ((v1-100 (-> *math-camera* inv-camera-rot))
             (a3-8 (-> *camera-combiner* inv-camera-rot))
             (a0-36 (-> a3-8 vector 0 quad))
             (a1-12 (-> a3-8 vector 1 quad))
             (a2-11 (-> a3-8 vector 2 quad))
             (a3-9 (-> a3-8 vector 3 quad))
             )
       (set! (-> v1-100 vector 0 quad) a0-36)
       (set! (-> v1-100 vector 1 quad) a1-12)
       (set! (-> v1-100 vector 2 quad) a2-11)
       (set! (-> v1-100 vector 3 quad) a3-9)
       )
      (let* ((v1-101 *save-camera-inv-rot*)
             (a3-10 (-> *camera-combiner* inv-camera-rot))
             (a0-38 (-> a3-10 vector 0 quad))
             (a1-13 (-> a3-10 vector 1 quad))
             (a2-12 (-> a3-10 vector 2 quad))
             (a3-11 (-> a3-10 vector 3 quad))
             )
       (set! (-> v1-101 vector 0 quad) a0-38)
       (set! (-> v1-101 vector 1 quad) a1-13)
       (set! (-> v1-101 vector 2 quad) a2-12)
       (set! (-> v1-101 vector 3 quad) a3-11)
       )
      )
     (else
      (move-camera-from-pad *math-camera*)
      )
     )
    )
   )
  (matrix-transpose!
   (-> *math-camera* camera-rot)
   (-> *math-camera* inv-camera-rot)
   )
  (cond
   (*camera-no-mip-correction*
    (set! (-> *math-camera* fov-correction-factor) 1.0)
    )
   (else
    (let ((f0-28 (fmin 11650.845 (-> *math-camera* fov))))
     (set! (-> *math-camera* fov-correction-factor) (* 0.00008583069 f0-28))
     )
    )
   )
  (if (< 0.0 (-> *math-camera* smooth-t))
   (set!
    (-> *math-camera* smooth-t)
    (- (-> *math-camera* smooth-t) (-> *math-camera* smooth-step))
    )
   )
  (cond
   ((< 0.0 (-> *math-camera* smooth-t))
    (let ((gp-2 (new-stack-quaternion0)))
     (matrix->quaternion gp-2 (-> *math-camera* inv-camera-rot))
     (let ((t9-16 quaternion-slerp!)
           (a0-42 gp-2)
           (a1-16 gp-2)
           (a2-13 (-> *math-camera* inv-camera-rot-smooth-from))
           )
      (set! a3-12 (-> *math-camera* smooth-t))
      (t9-16 a0-42 a1-16 a2-13 (the-as float a3-12))
      )
     (quaternion->matrix (-> *math-camera* inv-camera-rot-smooth) gp-2)
     )
    )
   (else
    (let ((v1-124 (-> *math-camera* inv-camera-rot-smooth)))
     (let* ((a3-13 (-> *math-camera* inv-camera-rot))
            (a0-45 (-> a3-13 vector 0 quad))
            (a1-18 (-> a3-13 vector 1 quad))
            (a2-14 (-> a3-13 vector 2 quad))
            )
      (set! a3-12 (-> a3-13 vector 3 quad))
      (set! (-> v1-124 vector 0 quad) a0-45)
      (set! (-> v1-124 vector 1 quad) a1-18)
      (set! (-> v1-124 vector 2 quad) a2-14)
      )
     (set! (-> v1-124 vector 3 quad) (the-as uint128 a3-12))
     )
    )
   )
  (when (and (!= *master-mode* 'menu) *display-camera-info*)
   (let ((t9-18 format)
         (a0-48 *stdcon*)
         (a1-19 "cam pos ~M ~M ~M~%")
         (a2-15 (-> *math-camera* trans x))
         )
    (set! a3-12 (-> *math-camera* trans y))
    (t9-18 a0-48 a1-19 a2-15 (the-as float a3-12) (-> *math-camera* trans z))
    )
   )
  (when (zero? (-> *math-camera* reset))
   (let ((v1-136 (-> *math-camera* prev-camera-temp)))
    (let* ((a3-14 (-> *math-camera* camera-temp))
           (a0-50 (-> a3-14 vector 0 quad))
           (a1-20 (-> a3-14 vector 1 quad))
           (a2-16 (-> a3-14 vector 2 quad))
           )
     (set! a3-12 (-> a3-14 vector 3 quad))
     (set! (-> v1-136 vector 0 quad) a0-50)
     (set! (-> v1-136 vector 1 quad) a1-20)
     (set! (-> v1-136 vector 2 quad) a2-16)
     )
    (set! (-> v1-136 vector 3 quad) (the-as uint128 a3-12))
    )
   )
  (let ((gp-3 (-> *math-camera* camera-temp))
        (s4-1 (-> *math-camera* camera-rot))
        (s5-2 (-> *math-camera* inv-camera-rot))
        (s3-0 (-> *math-camera* trans))
        )
   (let ((s2-0 (new-stack-vector0)))
    (set! (-> s2-0 x) (- (-> s3-0 x)))
    (set! (-> s2-0 y) (- (-> s3-0 y)))
    (set! (-> s2-0 z) (- (-> s3-0 z)))
    (set! (-> s2-0 w) 1.0)
    (vector-matrix*! s2-0 s2-0 s4-1)
    (set! (-> s4-1 vector 3 quad) (-> s2-0 quad))
    )
   (matrix*! gp-3 s4-1 (-> *math-camera* perspective))
   (set! (-> s5-2 vector 3 quad) (-> s3-0 quad))
   )
  (when (nonzero? (-> *math-camera* reset))
   (let ((v1-148 (-> *math-camera* prev-camera-temp)))
    (let* ((a3-15 (-> *math-camera* camera-temp))
           (a0-54 (-> a3-15 vector 0 quad))
           (a1-23 (-> a3-15 vector 1 quad))
           (a2-19 (-> a3-15 vector 2 quad))
           )
     (set! a3-12 (-> a3-15 vector 3 quad))
     (set! (-> v1-148 vector 0 quad) a0-54)
     (set! (-> v1-148 vector 1 quad) a1-23)
     (set! (-> v1-148 vector 2 quad) a2-19)
     )
    (set! (-> v1-148 vector 3 quad) (the-as uint128 a3-12))
    )
   (set! (-> *math-camera* reset) 0)
   0
   )
  (let ((f0-45 (-> *math-camera* fog-min))
        (f1-10 (-> *math-camera* fog-max))
        )
   (let ((f2-0 (-> *math-camera* d)))
    (set! (-> *instance-tie-work* hmge-d x) f0-45)
    (set! (-> *instance-tie-work* hmge-d y) f1-10)
    (set! (-> *instance-tie-work* hmge-d z) (* 32.0 f2-0))
    (set!
     (-> *instance-tie-work* hmge-d w)
     (* f2-0 (-> *math-camera* hmge-scale w))
     )
    (let ((v1-160 (-> *math-camera* hvdf-off quad)))
     (set! (-> *instance-tie-work* hvdf-offset quad) v1-160)
     )
    (set! (-> *instance-shrub-work* hmge-d x) f0-45)
    (set! (-> *instance-shrub-work* hmge-d y) f1-10)
    (set! (-> *instance-shrub-work* hmge-d z) (* 3.0 f2-0))
    (set!
     (-> *instance-shrub-work* hmge-d w)
     (* f2-0 (-> *math-camera* hmge-scale w))
     )
    (set!
     (-> *instance-shrub-work* billboard-const x)
     (/ (-> *math-camera* x-pix) (* f2-0 (-> *math-camera* x-ratio)))
     )
    (set!
     (-> *instance-shrub-work* billboard-const y)
     (/ (-> *math-camera* y-pix) (* f2-0 (-> *math-camera* y-ratio)))
     )
    )
   (set! (-> *instance-shrub-work* billboard-const z) f0-45)
   (set! (-> *instance-shrub-work* billboard-const w) f1-10)
   )
  (set!
   (-> *instance-shrub-work* constants w)
   (the-as float (-> *math-camera* vis-gifs 0 fog0))
   )
  (let ((a0-56 (-> *math-camera* hvdf-off quad)))
   (set! (-> *instance-shrub-work* hvdf-offset quad) a0-56)
   )
  (update-view-planes *math-camera* (-> *math-camera* plane) 1.0)
  (let ((t9-22 update-view-planes)
        (a0-58 *math-camera*)
        (a1-25 (-> *math-camera* guard-plane))
        (a2-21 4.0)
        )
   (t9-22 a0-58 a1-25 a2-21)
   (set!
    (-> *instance-shrub-work* guard-plane 0 quad)
    (-> *math-camera* guard-plane 0 quad)
    )
   (set!
    (-> *instance-shrub-work* guard-plane 1 quad)
    (-> *math-camera* guard-plane 1 quad)
    )
   (set!
    (-> *instance-shrub-work* guard-plane 2 quad)
    (-> *math-camera* guard-plane 2 quad)
    )
   (set!
    (-> *instance-shrub-work* guard-plane 3 quad)
    (-> *math-camera* guard-plane 3 quad)
    )
   (set!
    (-> *instance-tie-work* guard-plane 0 quad)
    (-> *math-camera* guard-plane 0 quad)
    )
   (set!
    (-> *instance-tie-work* guard-plane 1 quad)
    (-> *math-camera* guard-plane 1 quad)
    )
   (set!
    (-> *instance-tie-work* guard-plane 2 quad)
    (-> *math-camera* guard-plane 2 quad)
    )
   (set!
    (-> *instance-tie-work* guard-plane 3 quad)
    (-> *math-camera* guard-plane 3 quad)
    )
   (update-visible
    *math-camera*
    (the-as int a1-25)
    (the-as uint a2-21)
    (the-as uint a3-12)
    )
   )
  (if (not (paused?))
   (update-wind *wind-work* *wind-scales*)
   )
  #f
  )




