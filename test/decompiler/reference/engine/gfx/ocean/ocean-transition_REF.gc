;;-*-Lisp-*-
(in-package goal)

;; definition for function ocean-trans-camera-masks-bit?
(defun ocean-trans-camera-masks-bit? ((arg0 uint) (arg1 uint))
  (let ((v1-3 (- arg0 (* (-> *ocean-work* mid-minz) 4)))
        (a0-4 (- arg1 (* (-> *ocean-work* mid-minx) 4)))
        )
   (cond
    ((or
      (< v1-3 0)
      (>= v1-3 (the-as uint 16))
      (< a0-4 0)
      (>= a0-4 (the-as uint 16))
      )
     #f
     )
    (else
     (let* ((a3-0 (shr v1-3 2))
            (a2-3 (shr a0-4 2))
            (a1-2 (logand v1-3 3))
            (v1-4 (logand a0-4 3))
            (a0-6 (+ (* a3-0 4) a2-3))
            )
      (nonzero?
       (logand
        (-> *ocean-work* trans-camera-masks 0 mask (+ a1-2 (* a0-6 8)))
        (ash 1 v1-4)
        )
       )
      )
     )
    )
   )
  )

;; definition for function ocean-trans-mask-ptrs-bit?
(defun ocean-trans-mask-ptrs-bit? ((arg0 int) (arg1 int))
  (let ((v1-3 (- arg0 (the-as int (* (-> *ocean-work* mid-minz) 4))))
        (a0-4 (- arg1 (the-as int (* (-> *ocean-work* mid-minx) 4))))
        )
   (cond
    ((or
      (< (the-as uint v1-3) 0)
      (>= (the-as uint v1-3) (the-as uint 16))
      (< (the-as uint a0-4) 0)
      (>= (the-as uint a0-4) (the-as uint 16))
      )
     #f
     )
    (else
     (let* ((a3-0 (shr v1-3 2))
            (a2-3 (shr a0-4 2))
            (a1-2 (logand v1-3 3))
            (v1-4 (logand a0-4 3))
            (a0-11
             (->
              *ocean-work*
              trans-mask-ptrs
              (+ (* (+ (* a3-0 4) a2-3) 4) a1-2)
              )
             )
            )
      (if a0-11
       (nonzero? (logand (-> a0-11 1) (ash 1 v1-4)))
       #f
       )
      )
     )
    )
   )
  )

;; definition for function ocean-trans-mask-ptrs-set!
(defun ocean-trans-mask-ptrs-set! ((arg0 int) (arg1 int))
  (let ((v1-3 (- arg0 (the-as int (* (-> *ocean-work* mid-minz) 4))))
        (a0-4 (- arg1 (the-as int (* (-> *ocean-work* mid-minx) 4))))
        )
   (cond
    ((or
      (< (the-as uint v1-3) 0)
      (>= (the-as uint v1-3) (the-as uint 16))
      (< (the-as uint a0-4) 0)
      (>= (the-as uint a0-4) (the-as uint 16))
      )
     #f
     )
    (else
     (let* ((a2-3 (shr v1-3 2))
            (a1-2 (shr a0-4 2))
            (v1-4 (logand v1-3 3))
            (a0-5 (logand a0-4 3))
            (a3-6
             (->
              *ocean-work*
              trans-mask-ptrs
              (+ (* (+ (* a2-3 4) a1-2) 4) v1-4)
              )
             )
            )
      (cond
       (a3-6
        (cond
         ((logtest? (-> a3-6 1) (ash 1 a0-5))
          #f
          )
         (else
          (let ((a1-6 (-> *ocean-work* trans-temp-masks (+ (* a2-3 4) a1-2))))
           (logior! (-> a1-6 mask v1-4) (ash 1 a0-5))
           )
          #t
          )
         )
        )
       (else
        #f
        )
       )
      )
     )
    )
   )
  )

;; definition for function ocean-trans-add-upload-table
;; WARN: Function may read a register that is not set: f31
;; Used lq/sq
(defun
  ocean-trans-add-upload-table
  ((arg0 dma-buffer)
   (arg1 int)
   (arg2 int)
   (arg3 (pointer float))
   (arg4 int)
   (arg5 symbol)
   )
  (local-vars
   (r0-0 uint128)
   (r0-1 uint128)
   (r0-2 uint128)
   (r0-3 uint128)
   (r0-4 uint128)
   (r0-5 uint128)
   (v1-12 (inline-array vector))
   (v1-14 float)
   (a0-23 uint128)
   (a0-24 uint128)
   (a1-15 uint128)
   (a1-16 uint128)
   (a1-17 uint128)
   (a2-15 uint128)
   (a2-16 uint128)
   (a3-10 uint128)
   (f31-0 none)
   )
  (rlet ((acc :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf12 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
   (when (ocean-trans-mask-ptrs-set! arg1 arg2)
    (let ((a1-2 (new-stack-vector0)))
     (let ((v1-1 (-> *ocean-map* start-corner)))
      (set! (-> a1-2 x) (+ (-> v1-1 x) (* 98304.0 (the float arg2))))
      (set! (-> a1-2 y) (-> v1-1 y))
      (set! (-> a1-2 z) (+ (-> v1-1 z) (* 98304.0 (the float arg1))))
      )
     (set! (-> a1-2 w) 1.0)
     )
    (ocean-mid-add-matrices arg0)
    (let* ((a1-3 9)
           (v1-3 arg0)
           (a0-3 (the-as object (-> v1-3 base)))
           )
     (set!
      (-> (the-as dma-packet a0-3) dma)
      (new 'static 'dma-tag :id (dma-tag-id cnt) :qwc a1-3)
      )
     (set!
      (-> (the-as dma-packet a0-3) vif0)
      (new 'static 'vif-tag :imm #x404 :cmd (vif-cmd stcycl))
      )
     (set!
      (-> (the-as dma-packet a0-3) vif1)
      (new 'static 'vif-tag :imm #x8008 :cmd (vif-cmd unpack-v4-32) :num a1-3)
      )
     (set! (-> v1-3 base) (&+ (the-as pointer a0-3) 16))
     )
    (set-vector! (the-as vector4w (-> arg0 base)) arg4 0 0 0)
    (&+! (-> arg0 base) 16)
    (let* ((a0-5 (logand arg1 3))
           (v1-7 (logand arg2 3))
           (v1-8 (+ (* 5 a0-5) v1-7))
           )
     (.lvf vf5 (&-> (&-> *ocean-trans-corner-table* 0 quad v1-8) 0))
     (.lvf vf6 (&-> (&-> *ocean-trans-corner-table* 0 quad (+ v1-8 1)) 0))
     (.lvf vf7 (&-> (&-> *ocean-trans-corner-table* 0 quad (+ v1-8 5)) 0))
     (.lvf vf8 (&-> (&-> *ocean-trans-corner-table* 0 quad (+ v1-8 6)) 0))
     )
    (.mov v1-12 vf8)
    (let ((v1-13 (the-as (inline-array vector) (-> arg0 base))))
     (let ((a0-16 (/ arg1 4))
           (a1-11 (/ arg2 4))
           )
      (.lvf vf1 (&-> *ocean-trans-st-table* 0 quad))
      (.lvf vf2 (&-> *ocean-trans-st-table* 1 quad))
      (.lvf vf3 (&-> *ocean-trans-st-table* 2 quad))
      (.lvf vf4 (&-> *ocean-trans-st-table* 3 quad))
      (.mul.x.vf acc vf1 vf5)
      (nop!)
      (.add.mul.y.vf acc vf2 vf5 acc)
      (nop!)
      (.add.mul.z.vf acc vf3 vf5 acc)
      (nop!)
      (.add.mul.w.vf vf9 vf4 vf5 acc)
      (nop!)
      (.mul.x.vf acc vf1 vf6)
      (nop!)
      (.add.mul.y.vf acc vf2 vf6 acc)
      (nop!)
      (.add.mul.z.vf acc vf3 vf6 acc)
      (nop!)
      (.add.mul.w.vf vf10 vf4 vf6 acc)
      (.svf (&-> v1-13 0 quad) vf9)
      (.mul.x.vf acc vf1 vf7)
      (nop!)
      (.add.mul.y.vf acc vf2 vf7 acc)
      (nop!)
      (.add.mul.z.vf acc vf3 vf7 acc)
      (nop!)
      (.add.mul.w.vf vf11 vf4 vf7 acc)
      (.svf (&-> v1-13 1 quad) vf10)
      (.mul.x.vf acc vf1 vf8)
      (nop!)
      (.add.mul.y.vf acc vf2 vf8 acc)
      (nop!)
      (.add.mul.z.vf acc vf3 vf8 acc)
      (nop!)
      (.add.mul.w.vf vf12 vf4 vf8 acc)
      (.svf (&-> v1-13 2 quad) vf11)
      (nop!)
      (.svf (&-> v1-13 3 quad) vf12)
      (let
       ((a2-14
         (the-as
          uint128
          (-> *ocean-map* ocean-colors colors (+ (* 52 a0-16) a1-11))
          )
         )
        (a3-9
         (the-as
          uint128
          (-> *ocean-map* ocean-colors colors (+ (+ a1-11 1) (* 52 a0-16)))
          )
         )
        (t0-10
         (the-as
          uint128
          (-> *ocean-map* ocean-colors colors (+ (* 52 (+ a0-16 1)) a1-11))
          )
         )
        (a0-22
         (the-as
          uint128
          (->
           *ocean-map*
           ocean-colors
           colors
           (+ (+ a1-11 1) (* 52 (+ a0-16 1)))
           )
          )
         )
        )
       (.pextlb a1-15 r0-0 a2-14)
       (.mov r0-1 f31-0)
       (.pextlb a2-15 r0-1 a3-9)
       (.mov r0-2 f31-0)
       (.pextlb a3-10 r0-2 t0-10)
       (.mov r0-3 f31-0)
       (.pextlb a0-23 r0-3 a0-22)
       )
      )
     (.mov r0-4 f31-0)
     (.pextlh a1-16 r0-4 a1-15)
     (.mov r0-5 f31-0)
     (.pextlh a2-16 r0-5 a2-15)
     (.mov vf1 a1-16)
     (.pextlh a1-17 r0-5 a3-10)
     (.mov vf2 a2-16)
     (.pextlh a0-24 r0-5 a0-23)
     (.mov vf3 a1-17)
     (nop!)
     (.mov vf4 a0-24)
     (.itof.vf vf1 vf1)
     (nop!)
     (.itof.vf vf2 vf2)
     (nop!)
     (.itof.vf vf3 vf3)
     (nop!)
     (.itof.vf vf4 vf4)
     (nop!)
     (.mul.x.vf acc vf1 vf5)
     (nop!)
     (.add.mul.y.vf acc vf2 vf5 acc)
     (nop!)
     (.add.mul.z.vf acc vf3 vf5 acc)
     (nop!)
     (.add.mul.w.vf vf9 vf4 vf5 acc)
     (nop!)
     (.mul.x.vf acc vf1 vf6)
     (nop!)
     (.add.mul.y.vf acc vf2 vf6 acc)
     (nop!)
     (.add.mul.z.vf acc vf3 vf6 acc)
     (nop!)
     (.add.mul.w.vf vf10 vf4 vf6 acc)
     (.svf (&-> v1-13 4 quad) vf9)
     (.mul.x.vf acc vf1 vf7)
     (nop!)
     (.add.mul.y.vf acc vf2 vf7 acc)
     (nop!)
     (.add.mul.z.vf acc vf3 vf7 acc)
     (nop!)
     (.add.mul.w.vf vf11 vf4 vf7 acc)
     (.svf (&-> v1-13 5 quad) vf10)
     (.mul.x.vf acc vf1 vf8)
     (nop!)
     (.add.mul.y.vf acc vf2 vf8 acc)
     (nop!)
     (.add.mul.z.vf acc vf3 vf8 acc)
     (nop!)
     (.add.mul.w.vf vf12 vf4 vf8 acc)
     (.svf (&-> v1-13 6 quad) vf11)
     (nop!)
     (.svf (&-> v1-13 7 quad) vf12)
     )
    (.mov v1-14 vf12)
    (&+! (-> arg0 base) 128)
    (let* ((v1-17 arg0)
           (a0-25 (the-as object (-> v1-17 base)))
           )
     (set!
      (-> (the-as dma-packet a0-25) dma)
      (new 'static 'dma-tag
       :id (dma-tag-id ref)
       :addr (the-as int arg3)
       :qwc arg4
       )
      )
     (set!
      (-> (the-as dma-packet a0-25) vif0)
      (new 'static 'vif-tag :imm #x404 :cmd (vif-cmd stcycl))
      )
     (set!
      (-> (the-as dma-packet a0-25) vif1)
      (new 'static 'vif-tag :imm #x8011 :cmd (vif-cmd unpack-v4-32) :num arg4)
      )
     (set! (-> v1-17 base) (&+ (the-as pointer a0-25) 16))
     )
    (if arg5
     (ocean-mid-add-call arg0 275)
     (ocean-mid-add-call arg0 107)
     )
    )
   (none)
   )
  )

;; definition for function ocean-trans-add-upload-strip
;; WARN: Type Propagation failed: Failed type prop at op 163 ((set! a3 (sll a3 33))): Cannot get_type_int2: (sll a3 33), args ocean-trans-strip and <integer 33>
;; WARN: Type Propagation failed: Type analysis failed
;; WARN: Function may read a register that is not set: f31
;; Used lq/sq
(defun
  ocean-trans-add-upload-strip
  ((a0-0 dma-buffer)
   (a1-0 uint)
   (a2-0 uint)
   (a3-0 uint)
   (t0-0 uint)
   (t1-0 uint)
   )
  (local-vars
   (r0-0 uint128)
   (r0-1 uint128)
   (r0-2 uint128)
   (r0-3 uint128)
   (r0-4 uint128)
   (r0-5 uint128)
   (v0-0 none)
   (v0-1 none)
   (v1-0 ocean-map)
   (v1-1 vector)
   (v1-3 dma-buffer)
   (v1-4 pointer)
   (v1-5 pointer)
   (v1-6 pointer)
   (v1-7 pointer)
   (v1-8 float)
   (v1-9 pointer)
   (v1-10 pointer)
   (v1-11 dma-buffer)
   (a0-1 dma-buffer)
   (a0-2 pointer)
   (a0-3 pointer)
   (a0-4 uint)
   (a0-5 uint)
   (a0-6 uint)
   (a0-7 int)
   (a0-8 int)
   (a0-9 (inline-array vector))
   (a0-10 uint128)
   (a0-11 (inline-array vector))
   (a0-12 uint128)
   (a0-13 (inline-array vector))
   (a0-14 uint128)
   (a0-15 (inline-array vector))
   (a0-16 uint128)
   (a0-17 int)
   (a0-18 int)
   (a0-19 int)
   (a0-20 int)
   (a0-21 int)
   (a0-22 uint128)
   (a0-23 uint128)
   (a0-24 uint128)
   (a0-25 uint128)
   (a0-26 pointer)
   (a0-27 none)
   (a1-1 vector)
   (a1-2 int)
   (a1-3 int)
   (a1-4 int)
   (a1-5 int)
   (a1-6 ocean-work)
   (a1-7 ocean-map)
   (a1-8 ocean-colors)
   (a1-9 uint)
   (a1-10 uint)
   (a1-11 uint)
   (a1-12 int)
   (a1-13 uint128)
   (a1-14 uint128)
   (a1-15 uint128)
   (a1-16 uint128)
   (a1-17 int)
   (a1-18 none)
   (a1-19 none)
   (a1-20 none)
   (a1-21 none)
   (a2-1 int)
   (a2-2 int)
   (a2-3 int)
   (a2-4 int)
   (a2-5 int)
   (a2-6 int)
   (a2-7 ocean-map)
   (a2-8 ocean-colors)
   (a2-9 int)
   (a2-10 int)
   (a2-11 int)
   (a2-12 int)
   (a2-13 int)
   (a2-14 uint128)
   (a2-15 uint128)
   (a2-16 int)
   (a2-17 int)
   (a2-18 none)
   (a2-19 none)
   (a2-20 none)
   (a3-1 int)
   (a3-2 int)
   (a3-3 uint)
   (a3-4 ocean-map)
   (a3-5 ocean-colors)
   (a3-6 uint)
   (a3-7 uint)
   (a3-8 uint)
   (a3-9 int)
   (a3-10 uint128)
   (a3-11 uint128)
   (a3-12 int)
   (a3-13 int)
   (a3-14 int)
   (a3-15 int)
   (a3-16 int)
   (a3-17 ocean-trans-strip)
   (a3-18 none)
   (a3-19 none)
   (t0-1 int)
   (t0-2 int)
   (t0-3 ocean-map)
   (t0-4 ocean-colors)
   (t0-5 ocean-trans-strip-array)
   (t1-1 uint)
   (t9-0 (function dma-buffer none))
   (t9-1 none)
   (f0-0 float)
   (f0-1 float)
   (f0-2 float)
   (f0-3 float)
   (f0-4 float)
   (f0-5 float)
   (f1-0 float)
   (f1-1 float)
   (f1-2 float)
   (f1-3 float)
   (f2-0 uint)
   (f2-1 float)
   (f2-2 uint)
   (f2-3 float)
   (f31-0 none)
   )
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
   (set! a1-1 (new 'stack-no-clear 'vector))
   (set! (-> a1-1 quad) (the-as uint128 0))
   (set! v1-0 *ocean-map*)
   (set! v1-1 (-> v1-0 start-corner))
   (set! f0-0 (-> v1-1 x))
   (set! f1-0 393216.0)
   (set! f2-0 (gpr->fpr a2-0))
   (set! f2-1 (i2f f2-0))
   (set! f1-1 (*.s f1-0 f2-1))
   (set! f0-1 (+.s f0-0 f1-1))
   (set! (-> a1-1 x) f0-1)
   (set! f0-2 (-> v1-1 y))
   (set! (-> a1-1 y) f0-2)
   (set! f0-3 (-> v1-1 z))
   (set! f1-2 393216.0)
   (set! f2-2 (gpr->fpr a1-0))
   (set! f2-3 (i2f f2-2))
   (set! f1-3 (*.s f1-2 f2-3))
   (set! f0-4 (+.s f0-3 f1-3))
   (set! (-> a1-1 z) f0-4)
   (set! f0-5 1.0)
   (set! (-> a1-1 w) f0-5)
   (set! t9-0 ocean-mid-add-matrices)
   (set! a0-1 a0-0)
   (call! a0-1)
   (set! v1-2 v0-0)
   (set! a1-2 9)
   (set! v1-3 a0-0)
   (set! a0-2 (-> v1-3 base))
   (set! a2-1 #x10000000)
   (set! a3-1 (sll a1-2 48))
   (set! a3-2 (srl a3-1 48))
   (set! a2-2 (logior a2-1 a3-2))
   (set! (the-as (pointer int64) (-> (the-as (pointer int64) a0-2))) a2-2)
   (set! a2-3 #x1000404)
   (s.w! (+ a0-2 8) a2-3)
   (set! a2-4 #x6c008008)
   (set! a1-3 (sll a1-2 56))
   (set! a1-4 (srl a1-3 40))
   (set! a1-5 (logior a2-4 a1-4))
   (s.w! (+ a0-2 12) a1-5)
   (set! a0-3 (+ a0-2 16))
   (set! (-> v1-3 base) a0-3)
   (set! v1-4 (-> a0-0 base))
   (set! a0-4 (sll t0-0 2))
   (set! a0-5 (+ a0-4 t1-0))
   (set! a0-6 (sll a0-5 2))
   (set! a1-6 *ocean-work*)
   (set! a0-7 (+ a0-6 a1-6))
   (set! (dynamic-array-field-access a0-7 trans-mask-ptrs PLACEHOLDER) v1-4)
   (set! a0-8 10)
   (set! (the-as (pointer int32) (-> (the-as (pointer int32) v1-4))) a0-8)
   (s.w! (+ v1-4 4) a3-0)
   (s.w! (+ v1-4 8) 0)
   (s.w! (+ v1-4 12) 0)
   (set! v1-5 (-> a0-0 base))
   (set! v1-6 (+ v1-5 16))
   (set! (-> a0-0 base) v1-6)
   (set! v1-7 (-> a0-0 base))
   (set! a0-9 *ocean-trans-st-table*)
   (set! a0-10 (-> a0-9 0 quad))
   (set! (the-as (pointer uint128) (-> (the-as (pointer uint128) v1-7))) a0-10)
   (set! a0-11 *ocean-trans-st-table*)
   (set! a0-12 (-> a0-11 1 quad))
   (s.q! (+ v1-7 16) a0-12)
   (set! a0-13 *ocean-trans-st-table*)
   (set! a0-14 (-> a0-13 2 quad))
   (s.q! (+ v1-7 32) a0-14)
   (set! a0-15 *ocean-trans-st-table*)
   (set! a0-16 (-> a0-15 3 quad))
   (s.q! (+ v1-7 48) a0-16)
   (set! a0-17 52)
   (set! a0-18 (*.si a0-17 a1-0))
   (set! a0-19 (+ a0-18 a2-0))
   (set! a0-20 (sll a0-19 2))
   (set! a1-7 *ocean-map*)
   (set! a1-8 (-> a1-7 ocean-colors))
   (set! a0-21 (+ a0-20 a1-8))
   (set!
    a0-22
    (the-as uint128 (dynamic-array-field-access a0-21 colors PLACEHOLDER))
    )
   (set! a1-9 (+ a2-0 1))
   (set! a2-5 52)
   (set! a2-6 (*.si a2-5 a1-0))
   (set! a1-10 (+ a1-9 a2-6))
   (set! a1-11 (sll a1-10 2))
   (set! a2-7 *ocean-map*)
   (set! a2-8 (-> a2-7 ocean-colors))
   (set! a1-12 (+ a1-11 a2-8))
   (set!
    a1-13
    (the-as uint128 (dynamic-array-field-access a1-12 colors PLACEHOLDER))
    )
   (set! a2-9 52)
   (set! a3-3 (+ a1-0 1))
   (set! a2-10 (*.si a2-9 a3-3))
   (set! a2-11 (+ a2-10 a2-0))
   (set! a2-12 (sll a2-11 2))
   (set! a3-4 *ocean-map*)
   (set! a3-5 (-> a3-4 ocean-colors))
   (set! a2-13 (+ a2-12 a3-5))
   (set!
    a2-14
    (the-as uint128 (dynamic-array-field-access a2-13 colors PLACEHOLDER))
    )
   (set! a3-6 (+ a2-0 1))
   (set! t0-1 52)
   (set! t1-1 (+ a1-0 1))
   (set! t0-2 (*.si t0-1 t1-1))
   (set! a3-7 (+ a3-6 t0-2))
   (set! a3-8 (sll a3-7 2))
   (set! t0-3 *ocean-map*)
   (set! t0-4 (-> t0-3 ocean-colors))
   (set! a3-9 (+ a3-8 t0-4))
   (set!
    a3-10
    (the-as uint128 (dynamic-array-field-access a3-9 colors PLACEHOLDER))
    )
   (.pextlb a0-23 r0-0 a0-22)
   (.mov r0-1 f31-0)
   (.pextlb a1-14 r0-1 a1-13)
   (.mov r0-2 f31-0)
   (.pextlb a2-15 r0-2 a2-14)
   (.mov r0-3 f31-0)
   (.pextlb a3-11 r0-3 a3-10)
   (.mov r0-4 f31-0)
   (.pextlh a0-24 r0-4 a0-23)
   (.mov r0-5 f31-0)
   (.pextlh a1-15 r0-5 a1-14)
   (.mov vf1 a0-24)
   (.pextlh a0-25 r0-5 a2-15)
   (.mov vf2 a1-15)
   (.pextlh a1-16 r0-5 a3-11)
   (.mov vf3 a0-25)
   (nop!)
   (.mov vf4 a1-16)
   (.itof.vf vf1 vf1)
   (nop!)
   (.itof.vf vf2 vf2)
   (nop!)
   (.itof.vf vf3 vf3)
   (nop!)
   (.itof.vf vf4 vf4)
   (nop!)
   (nop!)
   (s.vf! (+ v1-7 64) vf1)
   (nop!)
   (s.vf! (+ v1-7 80) vf2)
   (nop!)
   (s.vf! (+ v1-7 96) vf3)
   (nop!)
   (s.vf! (+ v1-7 112) vf4)
   (.mov v1-8 vf4)
   (set! v1-9 (-> a0-0 base))
   (set! v1-10 (+ v1-9 128))
   (set! (-> a0-0 base) v1-10)
   (set! a1-17 10)
   (set! v1-11 a0-0)
   (set! a0-26 (-> v1-11 base))
   (set! a2-16 #x30000000)
   (set! a3-12 (sll a1-17 48))
   (set! a3-13 (srl a3-12 48))
   (set! a2-17 (logior a2-16 a3-13))
   (set! a3-14 160)
   (set! a3-15 (*.si a3-14 t1-0))
   (set! a3-16 (+ a3-15 0))
   (set! t0-5 *ocean-trans-strip-array*)
   (set! a3-17 (+ a3-16 t0-5))
   (set! a3-18 (the-as none (sll a3-17 33)))
   (set! a3-19 (the-as none (srl a3-18 1)))
   (set! a2-18 (the-as none (logior a2-17 a3-19)))
   (s.d! a0-26 a2-18)
   (set! a2-19 (the-as none #x1000404))
   (s.w! (+ a0-26 8) a2-19)
   (set! a2-20 (the-as none #x6c008011))
   (set! a1-18 (the-as none (sll a1-17 56)))
   (set! a1-19 (the-as none (srl a1-18 40)))
   (set! a1-20 (the-as none (logior a2-20 a1-19)))
   (s.w! (+ a0-26 12) a1-20)
   (set! a0-27 (the-as none (+ a0-26 16)))
   (s.w! (+ v1-11 4) a0-27)
   (set! t9-1 (the-as none ocean-mid-add-call))
   (set! a1-21 (the-as none 107))
   (set! a0-28 (the-as none a0-0))
   (call!)
   (ret-none)
   )
  )

;; definition for function ocean-transition-check
;; Used lq/sq
(defun
  ocean-transition-check
  ((arg0 ocean-trans-mask) (arg1 int) (arg2 int) (arg3 vector))
  (local-vars
   (v0-0 symbol)
   (v1-10 float)
   (a3-2 float)
   (a3-6 float)
   (a3-10 float)
   )
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
   (let ((v1-0 (new-stack-vector0))
         (t0-1 (-> *math-camera* trans))
         )
    1.0
    (set! (-> v1-0 x) (+ (-> arg3 x) (* 98304.0 (the float arg1))))
    (set! (-> v1-0 y) (-> arg3 y))
    (set! (-> v1-0 z) (+ (-> arg3 z) (* 98304.0 (the float arg2))))
    (let ((a3-1 v1-0)
          (t1-0 t0-1)
          )
     (.lvf vf2 (&-> a3-1 quad))
     (.lvf vf3 (&-> t1-0 quad))
     )
    (.sub.vf vf1 vf3 vf2)
    (.mul.vf vf1 vf1 vf1)
    (.add.y.vf vf1 vf1 vf1 :mask #b1)
    (.add.z.vf vf1 vf1 vf1 :mask #b1)
    (.mov a3-2 vf1)
    (when (< a3-2 19327350000.0)
     (logior! (-> arg0 mask arg2) (ash 1 arg1))
     (return #f)
     )
    (set! (-> v1-0 x) (+ 98304.0 (-> v1-0 x)))
    (let ((a3-5 v1-0)
          (t1-1 t0-1)
          )
     (.lvf vf2 (&-> a3-5 quad))
     (.lvf vf3 (&-> t1-1 quad))
     )
    (.sub.vf vf1 vf3 vf2)
    (.mul.vf vf1 vf1 vf1)
    (.add.y.vf vf1 vf1 vf1 :mask #b1)
    (.add.z.vf vf1 vf1 vf1 :mask #b1)
    (.mov a3-6 vf1)
    (when (< a3-6 19327350000.0)
     (logior! (-> arg0 mask arg2) (ash 1 arg1))
     (return #f)
     )
    (set! (-> v1-0 z) (+ 98304.0 (-> v1-0 z)))
    (let ((a3-9 v1-0)
          (t1-2 t0-1)
          )
     (.lvf vf2 (&-> a3-9 quad))
     (.lvf vf3 (&-> t1-2 quad))
     )
    (.sub.vf vf1 vf3 vf2)
    (.mul.vf vf1 vf1 vf1)
    (.add.y.vf vf1 vf1 vf1 :mask #b1)
    (.add.z.vf vf1 vf1 vf1 :mask #b1)
    (.mov a3-10 vf1)
    (when (< a3-10 19327350000.0)
     (logior! (-> arg0 mask arg2) (ash 1 arg1))
     (return #f)
     )
    (set! (-> v1-0 x) (+ -98304.0 (-> v1-0 x)))
    (.lvf vf2 (&-> v1-0 quad))
    (.lvf vf3 (&-> t0-1 quad))
    )
   (.sub.vf vf1 vf3 vf2)
   (.mul.vf vf1 vf1 vf1)
   (.add.y.vf vf1 vf1 vf1 :mask #b1)
   (.add.z.vf vf1 vf1 vf1 :mask #b1)
   (.mov v1-10 vf1)
   (when (< v1-10 19327350000.0)
    (logior! (-> arg0 mask arg2) (ash 1 arg1))
    (return #f)
    v0-0
    )
   )
  )

;; definition for function ocean-make-trans-camera-masks
;; Used lq/sq
(defun
  ocean-make-trans-camera-masks
  ((arg0 uint) (arg1 uint) (arg2 uint) (arg3 uint))
  (local-vars
   (sv-48 ocean-trans-mask)
   (sv-52 vector)
   (sv-56 vector)
   (sv-60 vector)
   )
  (set! sv-48 (-> *ocean-work* trans-camera-masks (+ (* arg2 4) arg3)))
  (set! sv-52 (-> *math-camera* trans))
  (set! sv-56 (new-stack-vector0))
  (set! sv-60 (new-stack-vector0))
  (set!
   (-> sv-56 x)
   (+ (-> *ocean-map* start-corner x) (* 393216.0 (the float arg1)))
   )
  (set! (-> sv-56 y) (-> *ocean-map* start-corner y))
  (set!
   (-> sv-56 z)
   (+ (-> *ocean-map* start-corner z) (* 393216.0 (the float arg0)))
   )
  (set! (-> sv-56 w) 1.0)
  (dotimes (gp-0 4)
   (dotimes (s5-0 4)
    (set!
     (-> sv-60 x)
     (- (+ (-> sv-56 x) (* 98304.0 (the float s5-0))) (-> sv-52 x))
     )
    (set! (-> sv-60 y) (- (-> sv-56 y) (-> sv-52 y)))
    (set!
     (-> sv-60 z)
     (- (+ (-> sv-56 z) (* 98304.0 (the float gp-0))) (-> sv-52 z))
     )
    (ocean-transition-check sv-48 s5-0 gp-0 sv-56)
    )
   )
  #f
  )

;; definition for function ocean-trans-add-upload
(defun ocean-trans-add-upload ((arg0 dma-buffer) (arg1 int) (arg2 int))
  (when (not (ocean-trans-mask-ptrs-bit? arg1 arg2))
   (let
    ((s1-0
      (ocean-trans-camera-masks-bit?
       (the-as uint (+ arg1 -1))
       (the-as uint arg2)
       )
      )
     (s2-0
      (ocean-trans-camera-masks-bit?
       (the-as uint (+ arg1 1))
       (the-as uint arg2)
       )
      )
     (s3-0
      (ocean-trans-camera-masks-bit?
       (the-as uint arg1)
       (the-as uint (+ arg2 -1))
       )
      )
     (a0-6
      (ocean-trans-camera-masks-bit?
       (the-as uint arg1)
       (the-as uint (+ arg2 1))
       )
      )
     (v1-0 0)
     )
    (if s1-0
     (+! v1-0 1)
     )
    (if s2-0
     (+! v1-0 2)
     )
    (if s3-0
     (+! v1-0 4)
     )
    (if a0-6
     (+! v1-0 8)
     )
    (cond
     ((= v1-0 1)
      (if (not (ocean-trans-mask-ptrs-bit? (+ arg1 -1) arg2))
       (ocean-trans-add-upload-table
        arg0
        arg1
        arg2
        *ocean-trans-up-table*
        11
        #t
        )
       )
      )
     ((= v1-0 2)
      (if (not (ocean-trans-mask-ptrs-bit? (+ arg1 1) arg2))
       (ocean-trans-add-upload-table
        arg0
        arg1
        arg2
        *ocean-trans-down-table*
        11
        #t
        )
       )
      )
     ((= v1-0 4)
      (if (not (ocean-trans-mask-ptrs-bit? arg1 (+ arg2 -1)))
       (ocean-trans-add-upload-table
        arg0
        arg1
        arg2
        *ocean-trans-left-table*
        11
        #t
        )
       )
      )
     ((= v1-0 5)
      (let ((s3-1 (ocean-trans-mask-ptrs-bit? (+ arg1 -1) arg2))
            (v1-1 (ocean-trans-mask-ptrs-bit? arg1 (+ arg2 -1)))
            )
       (cond
        ((and s3-1 v1-1)
         )
        (s3-1
         (ocean-trans-add-upload-table
          arg0
          arg1
          arg2
          *ocean-trans-left-table*
          11
          #t
          )
         )
        (v1-1
         (ocean-trans-add-upload-table
          arg0
          arg1
          arg2
          *ocean-trans-up-table*
          11
          #t
          )
         )
        (else
         (ocean-trans-add-upload-table
          arg0
          arg1
          arg2
          *ocean-trans-up-left-table*
          18
          #f
          )
         )
        )
       )
      )
     ((= v1-0 6)
      (let ((s3-2 (ocean-trans-mask-ptrs-bit? (+ arg1 1) arg2))
            (v1-2 (ocean-trans-mask-ptrs-bit? arg1 (+ arg2 -1)))
            )
       (cond
        ((and s3-2 v1-2)
         )
        (s3-2
         (ocean-trans-add-upload-table
          arg0
          arg1
          arg2
          *ocean-trans-left-table*
          11
          #t
          )
         )
        (v1-2
         (ocean-trans-add-upload-table
          arg0
          arg1
          arg2
          *ocean-trans-down-table*
          11
          #t
          )
         )
        (else
         (ocean-trans-add-upload-table
          arg0
          arg1
          arg2
          *ocean-trans-down-left-table*
          18
          #t
          )
         )
        )
       )
      )
     ((= v1-0 8)
      (if (not (ocean-trans-mask-ptrs-bit? arg1 (+ arg2 1)))
       (ocean-trans-add-upload-table
        arg0
        arg1
        arg2
        *ocean-trans-right-table*
        11
        #t
        )
       )
      )
     ((= v1-0 9)
      (let ((s3-3 (ocean-trans-mask-ptrs-bit? (+ arg1 -1) arg2))
            (v1-3 (ocean-trans-mask-ptrs-bit? arg1 (+ arg2 1)))
            )
       (cond
        ((and s3-3 v1-3)
         )
        (s3-3
         (ocean-trans-add-upload-table
          arg0
          arg1
          arg2
          *ocean-trans-right-table*
          11
          #t
          )
         )
        (v1-3
         (ocean-trans-add-upload-table
          arg0
          arg1
          arg2
          *ocean-trans-up-table*
          11
          #t
          )
         )
        (else
         (ocean-trans-add-upload-table
          arg0
          arg1
          arg2
          *ocean-trans-up-right-table*
          18
          #t
          )
         )
        )
       )
      )
     ((= v1-0 10)
      (let ((s3-4 (ocean-trans-mask-ptrs-bit? (+ arg1 1) arg2))
            (v1-4 (ocean-trans-mask-ptrs-bit? arg1 (+ arg2 1)))
            )
       (cond
        ((and s3-4 v1-4)
         )
        (s3-4
         (ocean-trans-add-upload-table
          arg0
          arg1
          arg2
          *ocean-trans-right-table*
          11
          #t
          )
         )
        (v1-4
         (ocean-trans-add-upload-table
          arg0
          arg1
          arg2
          *ocean-trans-down-table*
          11
          #t
          )
         )
        (else
         (ocean-trans-add-upload-table
          arg0
          arg1
          arg2
          *ocean-trans-down-right-table*
          18
          #f
          )
         )
        )
       )
      )
     )
    )
   )
  (none)
  )

;; definition for function draw-ocean-transition-seams
(defun draw-ocean-transition-seams ((arg0 dma-buffer))
  (local-vars
   (sv-32 uint)
   (sv-33 uint)
   (sv-34 uint)
   (sv-35 uint)
   (sv-36 sphere)
   )
  (set! sv-32 (-> *ocean-work* near-minx))
  (set! sv-33 (-> *ocean-work* near-maxx))
  (set! sv-34 (-> *ocean-work* near-minz))
  (set! sv-35 (-> *ocean-work* near-maxz))
  (set! sv-36 (new 'stack 'sphere))
  (set! (-> sv-36 y) (-> *ocean-map* start-corner y))
  (set! (-> sv-36 w) 69511.42)
  (when (and (< sv-32 sv-33) (< sv-34 sv-35))
   (let ((s5-0 sv-34)
         (s4-0 sv-35)
         )
    (while (>= s4-0 s5-0)
     (let ((s3-0 sv-32)
           (s2-0 sv-33)
           )
      (while (>= s2-0 s3-0)
       (set!
        (-> sv-36 x)
        (+
         (+ 49152.0 (* 98304.0 (the float s3-0)))
         (-> *ocean-map* start-corner x)
         )
        )
       (set!
        (-> sv-36 z)
        (+
         (+ 49152.0 (* 98304.0 (the float s5-0)))
         (-> *ocean-map* start-corner z)
         )
        )
       (when (sphere-cull sv-36)
        (if (not (ocean-trans-camera-masks-bit? s5-0 s3-0))
         (ocean-trans-add-upload arg0 (the-as int s5-0) (the-as int s3-0))
         )
        )
       (+! s3-0 1)
       )
      )
     (+! s5-0 1)
     )
    )
   )
  (dotimes (v1-27 16)
   (when (nonzero? (-> *ocean-work* trans-camera-masks v1-27 word))
    (dotimes (a0-12 4)
     (let ((a1-8 (-> *ocean-work* trans-mask-ptrs (+ (* v1-27 4) a0-12))))
      (if a1-8
       (logior!
        (-> a1-8 1)
        (-> *ocean-work* trans-temp-masks 0 mask (+ a0-12 (* v1-27 8)))
        )
       )
      )
     )
    )
   )
  #f
  )

;; definition for function ocean-trans-add-constants
(defun ocean-trans-add-constants ((arg0 dma-buffer))
  (let* ((a2-0 4)
         (v1-0 arg0)
         (a1-0 (the-as object (-> v1-0 base)))
         )
   (set!
    (-> (the-as dma-packet a1-0) dma)
    (new 'static 'dma-tag :id (dma-tag-id cnt) :qwc a2-0)
    )
   (set!
    (-> (the-as dma-packet a1-0) vif0)
    (new 'static 'vif-tag :imm #x404 :cmd (vif-cmd stcycl))
    )
   (set!
    (-> (the-as dma-packet a1-0) vif1)
    (new 'static 'vif-tag :imm #x2fd :cmd (vif-cmd unpack-v4-32) :num a2-0)
    )
   (set! (-> v1-0 base) (&+ (the-as pointer a1-0) 16))
   )
  (let ((v1-1 (the-as matrix (-> arg0 base))))
   (set-vector! (-> v1-1 vector 0) 0.0 0.0 0.0 1.0)
   (set-vector! (-> v1-1 vector 1) 98304.0 0.0 0.0 1.0)
   (set-vector! (-> v1-1 vector 2) 0.0 0.0 98304.0 1.0)
   (set-vector! (-> v1-1 vector 3) 98304.0 0.0 98304.0 1.0)
   )
  (let ((v0-0 (&+ (-> arg0 base) 64)))
   (set! (-> arg0 base) v0-0)
   v0-0
   )
  )

;; definition for function draw-ocean-transition
;; INFO: Return type mismatch int vs none.
(defun draw-ocean-transition ((arg0 dma-buffer))
  (local-vars
   (sv-32 uint)
   (sv-33 uint)
   (sv-34 uint)
   (sv-35 uint)
   (sv-36 sphere)
   (sv-40 ocean-trans-mask)
   (sv-44 uint)
   )
  (dotimes (v1-0 16)
   (set! (-> *ocean-work* trans-camera-masks v1-0 word) (the-as uint 0))
   (set! (-> *ocean-work* near-mask-indices v1-0) (the-as uint -1))
   )
  (dotimes (v1-3 64)
   (set! (-> *ocean-work* trans-mask-ptrs v1-3) (the-as (pointer int32) #f))
   )
  (set! sv-32 (-> *ocean-work* mid-minx))
  (set! sv-33 (-> *ocean-work* mid-maxx))
  (set! sv-34 (-> *ocean-work* mid-minz))
  (set! sv-35 (-> *ocean-work* mid-maxz))
  (set! sv-36 (new 'stack 'sphere))
  (set! (-> sv-36 y) (-> *ocean-map* start-corner y))
  (set! (-> sv-36 w) 278045.7)
  (let ((s5-0 sv-34)
        (s4-0 sv-35)
        )
   (while (>= s4-0 s5-0)
    (let ((s3-0 sv-32)
          (s2-0 sv-33)
          )
     (while (>= s2-0 s3-0)
      (when (not (ocean-mid-mask-ptrs-bit? s5-0))
       (when (ocean-mid-camera-masks-bit? s5-0)
        (set!
         (-> sv-36 x)
         (+
          (+ 196608.0 (* 393216.0 (the float s3-0)))
          (-> *ocean-map* start-corner x)
          )
         )
        (set!
         (-> sv-36 z)
         (+
          (+ 196608.0 (* 393216.0 (the float s5-0)))
          (-> *ocean-map* start-corner z)
          )
         )
        (if (sphere-cull sv-36)
         (ocean-make-trans-camera-masks s5-0 s3-0 (- s5-0 sv-34) (- s3-0 sv-32))
         )
        )
       )
      (+! s3-0 1)
      )
     )
    (+! s5-0 1)
    )
   )
  (let ((a2-2 192)
        (a1-8 0)
        (a0-11 192)
        (v1-32 0)
        )
   (let ((a3-1 sv-34)
         (t0-0 sv-35)
         )
    (while (>= t0-0 a3-1)
     (let ((t1-0 sv-32)
           (t2-0 sv-33)
           )
      (while (>= t2-0 t1-0)
       (set!
        sv-40
        (->
         *ocean-work*
         trans-camera-masks
         (+ (* (- a3-1 sv-34) 4) (- t1-0 sv-32))
         )
        )
       (when (nonzero? (-> sv-40 word))
        (dotimes (t3-10 4)
         (let ((t4-5 (-> sv-40 mask t3-10)))
          (when (nonzero? t4-5)
           (let ((t5-2 (+ (* a3-1 4) (the-as uint t3-10))))
            (if (< t5-2 (the-as uint a0-11))
             (set! a0-11 (the-as int t5-2))
             )
            (if (< (the-as uint v1-32) t5-2)
             (set! v1-32 (the-as int t5-2))
             )
            )
           (dotimes (t5-3 4)
            (when (logtest? t4-5 (ash 1 t5-3))
             (let ((t6-9 (+ (* t1-0 4) (the-as uint t5-3))))
              (if (< t6-9 (the-as uint a2-2))
               (set! a2-2 (the-as int t6-9))
               )
              (if (< (the-as uint a1-8) t6-9)
               (set! a1-8 (the-as int t6-9))
               )
              )
             )
            )
           )
          )
         )
        )
       (+! t1-0 1)
       )
      )
     (+! a3-1 1)
     )
    )
   (set! (-> *ocean-work* near-minx) (the-as uint (+ a2-2 -1)))
   (set! (-> *ocean-work* near-maxx) (the-as uint (+ a1-8 1)))
   (set! (-> *ocean-work* near-minz) (the-as uint (+ a0-11 -1)))
   (set! (-> *ocean-work* near-maxz) (the-as uint (+ v1-32 1)))
   )
  (dotimes (v1-34 16)
   (set!
    (-> *ocean-work* trans-temp-masks v1-34 word)
    (-> *ocean-work* trans-camera-masks v1-34 word)
    )
   )
  (let ((s5-1 sv-34)
        (s4-1 sv-35)
        )
   (while (>= s4-1 s5-1)
    (let ((s3-1 sv-32)
          (s2-1 sv-33)
          )
     (while (>= s2-1 s3-1)
      (when (not (ocean-mid-mask-ptrs-bit? s5-1))
       (when (ocean-mid-camera-masks-bit? s5-1)
        (let
         ((v1-43
           (->
            *ocean-map*
            ocean-trans-indices
            data
            (+ (* (the-as uint 48) s5-1) (the-as int s3-1))
            )
           )
          )
         (when (>= (-> v1-43 parent) 0)
          (set! sv-44 (+ (* (- s5-1 sv-34) 4) (- s3-1 sv-32)))
          (set!
           (-> *ocean-work* near-mask-indices sv-44)
           (the-as uint (-> v1-43 child))
           )
          (let ((s1-0 (-> *ocean-map* ocean-mid-masks data (-> v1-43 parent))))
           (dotimes (s0-0 4)
            (let
             ((a3-5
               (-> (the-as ocean-mid-mask (+ s0-0 (the-as int s1-0))) mask 0)
               )
              )
             (if (!= a3-5 255)
              (ocean-trans-add-upload-strip
               arg0
               s5-1
               s3-1
               a3-5
               sv-44
               (the-as uint s0-0)
               )
              )
             )
            )
           )
          )
         )
        )
       )
      (+! s3-1 1)
      )
     )
    (+! s5-1 1)
    )
   )
  (ocean-mid-add-call-flush arg0 (the-as uint 41))
  (ocean-trans-add-constants arg0)
  (draw-ocean-transition-seams arg0)
  (ocean-mid-add-call-flush arg0 (the-as uint 41))
  0
  (none)
  )
