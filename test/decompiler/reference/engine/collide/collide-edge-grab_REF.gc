;;-*-Lisp-*-
(in-package goal)

;; definition for method 20 of type target
;; INFO: Return type mismatch int vs object.
;; Used lq/sq
(defmethod dummy-20 target ((obj target) (arg0 collide-cache))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (let ((gp-0 *collide-edge-work*))
      (set! (-> gp-0 num-verts) (the-as uint 0))
      (set! (-> gp-0 num-edges) (the-as uint 0))
      (set! (-> gp-0 num-tris) (the-as uint 0))
      (let ((v1-0 (-> obj control)))
        (set! (-> gp-0 ccache) arg0)
        (.lvf vf1 (&-> gp-0 local-cache-fill-box min quad))
        (.lvf vf2 (&-> gp-0 local-cache-fill-box max quad))
        (set! (-> gp-0 cshape) v1-0)
        (.lvf vf3 (&-> v1-0 trans quad))
        )
      (.add.vf vf1 vf1 vf3 :mask #b111)
      (.add.vf vf2 vf2 vf3 :mask #b111)
      (.svf (&-> gp-0 cache-fill-box min quad) vf1)
      (.svf (&-> gp-0 cache-fill-box max quad) vf2)
      (.lvf vf4 (&-> gp-0 local-within-reach-box min quad))
      (.lvf vf5 (&-> gp-0 local-within-reach-box max quad))
      (.add.vf vf4 vf4 vf3 :mask #b111)
      (.add.vf vf5 vf5 vf3 :mask #b111)
      (.ftoi.vf vf6 vf4)
      (.ftoi.vf vf7 vf5)
      (.svf (&-> gp-0 within-reach-box min quad) vf4)
      (.svf (&-> gp-0 within-reach-box max quad) vf5)
      (.svf (&-> gp-0 within-reach-box4w min quad) vf6)
      (.svf (&-> gp-0 within-reach-box4w max quad) vf7)
      (dummy-13
        arg0
        (-> gp-0 cache-fill-box)
        (-> obj control root-prim collide-with)
        obj
        (new 'static 'pat-surface :skip #x1 :noentity #x1)
        )
      (dummy-16 gp-0)
      (when (nonzero? (-> gp-0 num-tris))
        (dummy-15 gp-0)
        (when (nonzero? (-> gp-0 num-edges))
          (set! (-> gp-0 search-pt quad) (-> *target* control unknown-vector90 quad))
          (when (!= (-> *cpad-list* cpads (-> *target* control unknown-cpad-info00 number) stick0-speed) 0.0)
            (set! (-> gp-0 search-dir-vec quad) (-> *target* control unknown-vector20 quad))
            (dummy-9 gp-0 (-> gp-0 hold-list))
            (let ((a0-14 gp-0)
                  (t9-4 (method-of-type collide-edge-work dummy-18))
                  )
              (-> gp-0 hold-list)
              *edge-grab-info*
              (when (t9-4 a0-14)
                (send-event *target* 'edge-grab)
                (return (the-as object #f))
                )
              )
            )
          (vector-z-quaternion! (-> gp-0 search-dir-vec) (-> *target* control unknown-quaternion00))
          (dummy-9 gp-0 (-> gp-0 hold-list))
          (let ((a0-18 gp-0)
                (t9-8 (method-of-type collide-edge-work dummy-18))
                )
            (-> gp-0 hold-list)
            *edge-grab-info*
            (if (t9-8 a0-18)
                (send-event *target* 'edge-grab)
                )
            )
          0
          )
        )
      )
    0
    )
  )

;; definition for method 9 of type collide-edge-work
(defmethod dummy-9 collide-edge-work ((obj collide-edge-work) (arg0 collide-edge-hold-list))
  (set! (-> arg0 num-allocs) (the-as uint 0))
  (set! (-> arg0 num-attempts) (the-as uint 0))
  (set! (-> arg0 head) #f)
  (let ((s4-0 (the-as object (-> arg0 items)))
        (s3-0 (the-as object (-> obj edges)))
        )
    (countdown (s2-0 (-> obj num-edges))
      (when (not (-> (the-as collide-edge-edge s3-0) ignore))
        (let ((a0-1 obj)
              (t9-0 (method-of-type collide-edge-work dummy-13))
              )
          (-> (the-as collide-edge-hold-item s4-0) center-pt)
          (t9-0 a0-1)
          )
        (when (dummy-17 obj)
          ((method-of-type collide-edge-hold-list dummy-10))
          (+! (-> arg0 num-allocs) 1)
          (when (= (-> arg0 num-allocs) 32)
            (format 0 "ERROR: Reached limit of edge grab hold items!~%")
            (return #f)
            )
          (set! s4-0 (-> (the-as (inline-array collide-edge-hold-item) s4-0) 1))
          )
        )
      (set! s3-0 (-> (the-as (inline-array collide-edge-edge) s3-0) 1))
      )
    )
  #f
  )

;; definition for method 10 of type collide-edge-hold-list
;; ERROR: function was not converted to expressions. Cannot decompile.

;; definition of type pbhp-stack-vars
(deftype pbhp-stack-vars (structure)
  ((edge        collide-edge-edge         :offset-assert   0)
   (allocated   basic                     :offset-assert   4)
   (neg-hold-pt vector            :inline :offset-assert  16)
   (split-vec   vector            :inline :offset-assert  32)
   )
  :method-count-assert 9
  :size-assert         #x30
  :flag-assert         #x900000030
  )

;; definition for method 3 of type pbhp-stack-vars
(defmethod inspect pbhp-stack-vars ((obj pbhp-stack-vars))
  (format #t "[~8x] ~A~%" obj 'pbhp-stack-vars)
  (format #t "~Tedge: #<collide-edge-edge @ #x~X>~%" (-> obj edge))
  (format #t "~Tallocated: ~A~%" (-> obj allocated))
  (format #t "~Tneg-hold-pt: #<vector @ #x~X>~%" (-> obj neg-hold-pt))
  (format #t "~Tsplit-vec: #<vector @ #x~X>~%" (-> obj split-vec))
  obj
  )

;; definition for method 18 of type collide-edge-work
;; ERROR: function was not converted to expressions. Cannot decompile.

;; definition for method 19 of type collide-edge-work
;; WARN: Type Propagation failed: Failed type prop at op 155 ((set! a2 (l.wu a1))): Could not get type of load: (set! a2 (l.wu a1)). 
;; WARN: Type Propagation failed: Type analysis failed
;; WARN: Unsupported inline assembly instruction kind - [sllv a1, a1, r0]
;; Used lq/sq
(defmethod dummy-19 collide-edge-work ((a0-0 collide-edge-work) (a1-0 collide-edge-hold-item) (a2-0 edge-grab-info))
  (local-vars
    (r0-0 none)
    (v0-0 vector)
    (v0-1 float)
    (v0-2 symbol)
    (v0-3 vector)
    (v0-4 vector)
    (v0-5 float)
    (v0-6 vector)
    (v0-7 vector)
    (v0-8 none)
    (v0-9 none)
    (v0-10 none)
    (v0-11 none)
    (v1-0 collide-edge-tri)
    (v1-1 type)
    (v1-4 (function vector vector vector float vector))
    (v1-5 vector)
    (v1-6 type)
    (v1-9 (inline-array vector))
    (v1-10 vector)
    (v1-11 vector)
    (v1-12 pat-surface)
    (v1-13 vector)
    (v1-14 (inline-array vector))
    (v1-15 vector)
    (v1-16 vector)
    (v1-17 vector)
    (v1-18 vector)
    (v1-19 matrix)
    (v1-20 vector)
    (v1-21 type)
    (v1-22 (inline-array sphere))
    (v1-23 int)
    (v1-24 collide-shape)
    (v1-25 collide-shape-prim)
    (v1-26 collide-kind)
    (v1-27 int)
    (v1-28 symbol)
    (v1-29 type)
    (v1-32 int)
    (v1-33 int)
    (v1-34 int)
    (v1-35 collide-cache-prim)
    (v1-36 (pointer collide-shape-prim))
    (v1-37 none)
    (v1-38 none)
    (v1-39 none)
    (v1-40 none)
    (v1-41 none)
    (v1-42 none)
    (v1-43 none)
    (v1-44 none)
    (a0-1 vector)
    (a0-2 collide-edge-work)
    (a0-3 vector)
    (a0-4 vector)
    (a0-5 collide-edge-work)
    (a0-6 (inline-array vector))
    (a0-7 uint128)
    (a0-8 vector)
    (a0-9 uint128)
    (a0-10 vector)
    (a0-11 uint128)
    (a0-12 vector)
    (a0-13 uint128)
    (a0-14 (inline-array vector))
    (a0-15 vector)
    (a0-16 uint128)
    (a0-17 (inline-array vector))
    (a0-18 vector)
    (a0-19 uint128)
    (a0-20 target)
    (a0-21 control-info)
    (a0-22 dynamics)
    (a0-23 vector)
    (a0-24 uint128)
    (a0-25 vector)
    (a0-26 vector)
    (a0-27 matrix)
    (a0-28 vector)
    (a0-29 vector)
    (a0-30 vector)
    (a0-31 uint128)
    (a0-32 matrix)
    (a0-33 collide-cache)
    (a0-34 collide-cache)
    (a0-35 collide-shape-prim)
    (a0-36 none)
    (a0-37 none)
    (a0-39 none)
    (a1-1 vector)
    (a1-2 vector)
    (a1-3 vector)
    (a1-4 vector)
    (a1-5 vector)
    (a1-6 (inline-array vector))
    (a1-7 float)
    (a1-8 vector)
    (a1-9 float)
    (a1-10 vector)
    (a1-11 vector)
    (a1-12 (inline-array sphere))
    (a1-13 collide-using-spheres-params)
    (a1-14 collide-shape-prim)
    (a1-15 int)
    (a1-16 float)
    (a1-17 none)
    (a1-18 none)
    (a1-19 none)
    (a1-20 none)
    (a2-1 vector)
    (a2-2 vector)
    (a2-3 vector)
    (a2-4 vector)
    (a2-5 (inline-array sphere))
    (a2-6 collide-shape-prim)
    (a2-7 none)
    (a2-8 none)
    (a2-9 none)
    (a3-0 float)
    (a3-1 uint)
    (a3-2 float)
    (a3-3 uint)
    (a3-4 int)
    (s0-0 vector)
    (s1-0 collide-cache-tri)
    (s3-0 collide-edge-edge)
    (s4-0 uint)
    (s4-1 none)
    (s5-1 none)
    (t9-0 (function vector vector vector float vector))
    (t9-1 (function collide-edge-work vector vector int float))
    (t9-2 (function vector vector vector))
    (t9-3 (function vector vector vector float vector))
    (t9-4 (function collide-edge-work vector vector int float))
    (t9-5 (function vector float vector))
    (t9-6 (function vector float vector))
    (t9-7 (function matrix (inline-array vector) (inline-array vector) int none))
    (t9-8 (function collide-cache none))
    (t9-9 none)
    (t9-10 none)
    (f0-0 float)
    (f0-1 float)
    (f1-0 float)
    (f1-1 float)
    )
  (if (begin
        (if (begin
              (if (begin
                    (set! s3-0 (-> a1-0 edge))
                    (set! v1-0 (-> s3-0 etri))
                    (set! s1-0 (-> v1-0 ctri))
                    (set! s4-0 (-> s1-0 prim-index))
                    (set! s0-0 (new 'stack-no-clear 'vector))
                    (set! t9-0 vector+*!)
                    (set! a0-1 s0-0)
                    (set! a1-1 (-> a1-0 center-pt))
                    (set! a2-1 (-> s3-0 edge-vec-norm))
                    (set! a3-0 1105.92)
                    (call! a0-1 a1-1 a2-1 a3-0)
                    (set! a0-2 a0-0)
                    (set! v1-1 collide-edge-work)
                    (set! t9-1 (method-of-type v1-1 dummy-14))
                    (set! a1-2 (-> a2-0 right-hand-hold))
                    (set! a2-2 s0-0)
                    (set! a3-1 s4-0)
                    (set! v0-1 (call! a0-2 a1-2 a2-2 a3-1))
                    (set! f0-0 (gpr->fpr v0-1))
                    (set! f1-0 491.52)
                    (<.s f1-0 f0-0)
                    )
                  (return (set! v0-2 #f))
                  )
              (set! v1-4 vector+*!)
              (set! sv-144 v1-4)
              (set! sv-160 s0-0)
              (set! v1-5 (-> a1-0 center-pt))
              (set! sv-176 v1-5)
              (set! t9-2 vector-negate!)
              (set! a0-3 (new 'stack-no-clear 'vector))
              (set! a1-3 (-> s3-0 edge-vec-norm))
              (set! v0-3 (call! a0-3 a1-3))
              (set! a2-3 v0-3)
              (set! a3-2 1105.92)
              (set! t9-3 (the-as (function vector vector vector float vector) sv-144))
              (set! a0-4 (the-as vector sv-160))
              (set! a1-4 (the-as vector sv-176))
              (call! a0-4 a1-4 a2-3 a3-2)
              (set! a0-5 a0-0)
              (set! v1-6 collide-edge-work)
              (set! t9-4 (method-of-type v1-6 dummy-14))
              (set! a1-5 (-> a2-0 left-hand-hold))
              (set! a3-3 s4-0)
              (set! a2-4 s0-0)
              (set! v0-5 (call! a0-5 a1-5 a2-4 a3-3))
              (set! f0-1 (gpr->fpr v0-5))
              (set! f1-1 491.52)
              (<.s f1-1 f0-1)
              )
            (return (set! v0-2 #f))
            )
        (set! v1-9 (-> a2-0 tri-vertex))
        (set! a0-6 (-> s1-0 vertex))
        (set! a0-7 (-> a0-6 0 quad))
        (set! (-> v1-9 0 quad) a0-7)
        (set! v1-10 (-> a2-0 world-vertex 4))
        (set! a0-8 (-> s1-0 vertex 1))
        (set! a0-9 (-> a0-8 quad))
        (set! (-> v1-10 quad) a0-9)
        (set! v1-11 (-> a2-0 world-vertex 5))
        (set! a0-10 (-> s1-0 vertex 2))
        (set! a0-11 (-> a0-10 quad))
        (set! (-> v1-11 quad) a0-11)
        (set! v1-12 (-> s1-0 pat))
        (set! (-> a2-0 edge-tri-pat) (the-as uint v1-12))
        (set! v1-13 (-> a2-0 center-hold))
        (set! a0-12 (-> a1-0 center-pt))
        (set! a0-13 (-> a0-12 quad))
        (set! (-> v1-13 quad) a0-13)
        (set! v1-14 (-> a2-0 world-vertex))
        (set! a0-14 (-> s3-0 vertex-ptr 0))
        (set! a0-15 (-> a0-14 0))
        (set! a0-16 (-> a0-15 quad))
        (set! (-> v1-14 0 quad) a0-16)
        (set! v1-15 (-> a2-0 world-vertex 1))
        (set! a0-17 (-> s3-0 vertex-ptr 1))
        (set! a0-18 (-> a0-17 0))
        (set! a0-19 (-> a0-18 quad))
        (set! (-> v1-15 quad) a0-19)
        (set! v1-16 (-> a2-0 hanging-matrix vector 1))
        (set! a0-20 *target*)
        (set! a0-21 (-> a0-20 control))
        (set! a0-22 (-> a0-21 dynam))
        (set! a0-23 (-> a0-22 gravity-normal))
        (set! a0-24 (-> a0-23 quad))
        (set! (-> v1-16 quad) a0-24)
        (set! t9-5 vector-normalize!)
        (set! a0-25 (-> a2-0 hanging-matrix vector 2))
        (set! v1-17 (-> a2-0 world-vertex 1))
        (set! a1-6 (-> a2-0 world-vertex))
        (set! a0-26 (vector-!2 a0-25 v1-17 a1-6))
        (set! a1-7 1.0)
        (call! a0-26 a1-7)
        (set! t9-6 vector-normalize!)
        (set! a0-27 (-> a2-0 hanging-matrix))
        (set! v1-18 (-> a2-0 hanging-matrix vector 2))
        (set! a1-8 (-> a2-0 hanging-matrix vector 1))
        (set! a0-28 (veccross a0-27 v1-18 a1-8))
        (set! a1-9 1.0)
        (call! a0-28 a1-9)
        (set! a1-10 (-> a2-0 hanging-matrix vector 2))
        (set! v1-19 (-> a2-0 hanging-matrix))
        (set! a0-29 (-> a2-0 hanging-matrix vector 1))
        (set! a1-11 (veccross a1-10 v1-19 a0-29))
        (set! v1-20 (-> a2-0 hanging-matrix vector 3))
        (set! a0-30 (-> a2-0 center-hold))
        (set! a0-31 (-> a0-30 quad))
        (set! (-> v1-20 quad) a0-31)
        (set! a0-32 (-> a2-0 hanging-matrix))
        (set! v1-21 matrix)
        (set! t9-7 (method-of-type v1-21 transform-vectors!))
        (set! a1-12 (-> a0-0 world-player-spheres))
        (set! a2-5 (-> a0-0 local-player-spheres))
        (set! a3-4 12)
        (call! a0-32 a1-12 a2-5 a3-4)
        (set! a1-13 (new 'stack-no-clear 'collide-using-spheres-params))
        (set! v1-22 (-> a0-0 world-player-spheres))
        (set! (-> a1-13 spheres) (the-as (pointer sphere) v1-22))
        (set! v1-23 12)
        (set! (-> a1-13 num-spheres) (the-as uint v1-23))
        (set! v1-24 (-> a0-0 cshape))
        (set! v1-25 (-> v1-24 root-prim))
        (set! v1-26 (-> v1-25 collide-with))
        (set! (-> a1-13 collide-with) v1-26)
        (set! (-> a1-13 proc) #f)
        (set! v1-27 1)
        (set! (-> a1-13 ignore-pat) (the-as uint v1-27))
        (set! v1-28 #t)
        (set! (-> a1-13 solid-only) v1-28)
        (set! a0-33 (-> a0-0 ccache))
        (set! v1-29 (-> a0-33 type))
        (set! t9-8 (method-of-type v1-29 probe-using-spheres))
        (set! v0-9 (call! a0-33))
        v0-9
        )
      (return (set! v0-2 #f))
      )
  (cond
    ((begin
       (set! v1-32 48)
       (set! v1-33 (*.ui v1-32 s4-0))
       (set! v1-34 (+ v1-33 108))
       (set! a0-34 (-> a0-0 ccache))
       (set! v1-35 (+ v1-34 a0-34))
       (set! v1-36 (-> v1-35 prim))
       (set! a0-35 (-> v1-36 0))
       a0-35
       )
     (if (begin
           (set! a1-14 (l.wu (+ a0-35 136)))
           (set! a1-15 (- v1-36 a1-14))
           (set! (-> a2-0 actor-cshape-prim-offset) a1-15)
           (set! a2-6 (l.wu (+ a0-35 136)))
           a2-6
           )
         (set! a1-16 (-> a2-6 prim-core world-sphere z))
         )
     (set! a2-7 (the-as none (l.wu a1-16)))
     (set! a2-8 (the-as none (l.w (+ a2-7 36))))
     (set! a2-9 (the-as none (sll a2-8 32)))
     (.sllv a1-17 a1-16 r0-0)
     (set! a1-18 (the-as none (logior a2-9 a1-17)))
     (s.d! (+ a2-0 200) a1-18)
     (set! a0-36 (the-as none (l.wu (+ a0-35 136))))
     (set! a0-37 (the-as none (l.wu (+ a0-36 112))))
     (set! v1-37 (the-as none (l.b (+ v1-36 8))))
     (set! v1-38 (the-as none (sll v1-37 5)))
     (set! v1-39 (the-as none (+ a0-37 v1-38)))
     (set! v1-40 (the-as none (l.wu (+ v1-39 28))))
     (set! a1-19 (the-as none (+ v1-40 0)))
     (set! s5-1 (the-as none (new 'stack-no-clear 'matrix)))
     (set! t9-9 (the-as none matrix-4x4-inverse!))
     (set! a0-38 (the-as none s5-1))
     (call!)
     (set! s4-1 (the-as none 0))
     (while (<.si s4-1 6)
       (set! t9-10 (the-as none vector-matrix*!))
       (set! v1-41 (the-as none (sll s4-1 4)))
       (set! v1-42 (the-as none (+ v1-41 96)))
       (set! a0-39 (the-as none (+ v1-42 a2-0)))
       (set! v1-43 (the-as none (sll s4-1 4)))
       (set! v1-44 (the-as none (+ v1-43 0)))
       (set! a1-20 (the-as none (+ v1-44 a2-0)))
       (set! a2-10 (the-as none s5-1))
       (call!)
       (set! s4-1 (the-as none (+ s4-1 1)))
       )
     )
    (else
      (set! (-> a2-0 actor-cshape-prim-offset) 0)
      (s.d! (+ a2-0 200) #f)
      )
    )
  (set! v0-2 (the-as symbol #t))
  (ret-value v0-2)
  )

;; definition for method 9 of type edge-grab-info
;; ERROR: function was not converted to expressions. Cannot decompile.

;; definition for method 16 of type collide-edge-work
;; ERROR: function was not converted to expressions. Cannot decompile.

;; definition for method 15 of type collide-edge-work
;; ERROR: function was not converted to expressions. Cannot decompile.

;; definition for method 14 of type collide-edge-work
;; Used lq/sq
(defmethod dummy-14 collide-edge-work ((obj collide-edge-work) (arg0 vector) (arg1 vector) (arg2 int))
  (let ((f30-0 -1.0))
    (let ((s2-0 (new 'stack-no-clear 'vector)))
      (dotimes (s1-0 (the-as int (-> obj num-edges)))
        (let ((v1-3 (-> obj edges s1-0)))
          (when (not (-> v1-3 ignore))
            (when (= (-> v1-3 etri ctri prim-index) arg2)
              (let ((f0-0 (vector-segment-distance-point! arg1 (-> v1-3 vertex-ptr 0 0) (-> v1-3 vertex-ptr 1 0) s2-0)))
                (when (or (< f30-0 0.0) (< f0-0 f30-0))
                  (set! f30-0 f0-0)
                  (set! (-> arg0 quad) (-> s2-0 quad))
                  )
                )
              )
            )
          )
        )
      )
    f30-0
    )
  )

;; definition for method 17 of type collide-edge-work
;; ERROR: function was not converted to expressions. Cannot decompile.

;; definition for method 13 of type collide-edge-work
;; ERROR: function was not converted to expressions. Cannot decompile.

;; definition for method 10 of type edge-grab-info
;; INFO: Return type mismatch object vs symbol.
(defmethod dummy-10 edge-grab-info ((obj edge-grab-info))
  (add-debug-line
    #t
    (bucket-id debug-draw1)
    (the-as vector (-> obj world-vertex))
    (-> obj world-vertex 1)
    (new 'static 'rgba :r #xff :a #x60)
    #f
    (the-as rgba -1)
    )
  (add-debug-sphere
    #t
    (bucket-id debug-draw1)
    (-> obj center-hold)
    204.8
    (new 'static 'rgba :r #xff :g #xff :a #x80)
    )
  (add-debug-sphere
    #t
    (bucket-id debug-draw1)
    (-> obj left-hand-hold)
    204.8
    (new 'static 'rgba :r #xff :g #xff :a #x60)
    )
  (add-debug-sphere
    #t
    (bucket-id debug-draw1)
    (-> obj right-hand-hold)
    204.8
    (new 'static 'rgba :r #xff :g #xff :a #x60)
    )
  (add-debug-outline-triangle
    #t
    (bucket-id debug-draw1)
    (the-as vector (-> obj tri-vertex))
    (-> obj world-vertex 4)
    (-> obj world-vertex 5)
    (new 'static 'rgba :r #xff :a #x30)
    )
  (the-as symbol (cond
                   ((nonzero? (-> obj actor-cshape-prim-offset))
                    (if (handle->process (-> obj actor-handle))
                        (format *stdcon* "grab: ~A~%" (-> obj actor-handle process 0 name))
                        (format *stdcon* "grab: invalid handle~%")
                        )
                    )
                   (else
                     (format *stdcon* "grab: ground~%")
                     )
                   )
          )
  )

;; definition for method 10 of type collide-edge-work
(defmethod debug-draw-edges collide-edge-work ((obj collide-edge-work))
  (let ((gp-0 0))
    (dotimes (s4-0 (the-as int (-> obj num-edges)))
      (let* ((s3-0 (-> obj edges s4-0))
             (a2-0 (-> s3-0 vertex-ptr 0 0))
             (a3-0 (-> s3-0 vertex-ptr 1 0))
             (s2-0 (new 'stack-no-clear 'vector))
             )
        (vector+! s2-0 a2-0 a3-0)
        (vector-float*! s2-0 s2-0 0.5)
        (cond
          ((-> s3-0 ignore)
           (add-debug-line
             #t
             (bucket-id debug-draw1)
             a2-0
             a3-0
             (new 'static 'rgba :r #x7f :g #x7f :b #x7f :a #x50)
             #f
             (the-as rgba -1)
             )
           (+! gp-0 1)
           )
          (else
            (add-debug-line
              #t
              (bucket-id debug-draw1)
              a2-0
              a3-0
              (new 'static 'rgba :r #xff :g #xff :b #xff :a #x60)
              #f
              (the-as rgba -1)
              )
            (add-debug-vector
              #t
              (bucket-id debug-draw1)
              s2-0
              (-> s3-0 outward)
              (meters 0.3)
              (new 'static 'rgba :r #xff :a #x80)
              )
            )
          )
        )
      )
    (format *stdcon* "found ~D edges (and ~D ignored)~%" (- (-> obj num-edges) (the-as uint gp-0)) gp-0)
    )
  )

;; definition for method 12 of type collide-edge-work
(defmethod debug-draw-sphere collide-edge-work ((obj collide-edge-work))
  (dotimes (s5-0 (the-as int (-> obj num-verts)))
    (let ((a2-0 (-> obj verts s5-0)))
      (add-debug-sphere #t (bucket-id debug-draw1) a2-0 819.2 (new 'static 'rgba :r #xff :g #xff :a #x80))
      )
    )
  #f
  )

;; definition for method 9 of type collide-edge-hold-list
;; Used lq/sq
(defmethod debug-draw collide-edge-hold-list ((obj collide-edge-hold-list))
  (let ((s4-0 (-> obj head))
        (s5-0 0)
        )
    (let ((s3-0 (new 'stack-no-clear 'vector))
          (s2-0 #t)
          )
      (set! (-> s3-0 quad) (-> *target* control unknown-vector90 quad))
      (while s4-0
        (+! s5-0 1)
        (set! (-> s3-0 y) (-> s4-0 center-pt y))
        (add-debug-sphere #t (bucket-id debug-draw1) s3-0 409.6 (new 'static 'rgba :a #x80))
        (cond
          (s2-0
            (set! s2-0 #f)
            (add-debug-sphere
              #t
              (bucket-id debug-draw1)
              (-> s4-0 center-pt)
              614.4
              (new 'static 'rgba :r #xff :g #xff :a #x80)
              )
            (add-debug-sphere #t (bucket-id debug-draw1) (-> s4-0 outward-pt) 409.6 (new 'static 'rgba :r #xff :a #x80))
            )
          (else
            (add-debug-sphere
              #t
              (bucket-id debug-draw1)
              (-> s4-0 center-pt)
              614.4
              (new 'static 'rgba :r #x7f :g #x7f :a #x40)
              )
            (add-debug-sphere #t (bucket-id debug-draw1) (-> s4-0 outward-pt) 409.6 (new 'static 'rgba :r #x7f :a #x40))
            )
          )
        (set! s4-0 (-> s4-0 next))
        )
      )
    (format *stdcon* "hold list has ~D item(s)~%" s5-0)
    )
  (dotimes (s5-1 (the-as int (-> obj num-attempts)))
    (add-debug-sphere
      #t
      (bucket-id debug-draw1)
      (the-as vector (-> obj attempts s5-1))
      409.6
      (new 'static 'rgba :a #x40)
      )
    )
  (format *stdcon* "hold list has ~D attempt(s)~%" (-> obj num-attempts))
  )

;; definition for method 11 of type collide-edge-work
;; INFO: Return type mismatch symbol vs none.
(defmethod dummy-11 collide-edge-work ((obj collide-edge-work))
  (dotimes (s5-0 (the-as int (-> obj num-tris)))
    (let* ((v1-3 (-> obj tris s5-0 ctri))
           (t1-0 (copy-and-set-field (-> *pat-mode-info* (-> v1-3 pat mode) color) a 64))
           )
      (add-debug-outline-triangle
        #t
        (bucket-id debug-draw1)
        (the-as vector (-> v1-3 vertex))
        (-> v1-3 vertex 1)
        (-> v1-3 vertex 2)
        t1-0
        )
      )
    )
  (none)
  )

;; failed to figure out what this is:
(let ((v1-1
        (new 'static 'surface
          :name '*rotate-surface*
          :turnv 1.0
          :turnvv 1.0
          :tiltv 1.0
          :tiltvv 1.0
          :transv-max 1.0
          :target-speed 1.0
          :seek0 153600.0
          :seek90 153600.0
          :seek180 256000.0
          :fric 153600.0
          :nonlin-fric-dist 5120.0
          :slip-factor 1.0
          :slope-down-factor 10240.0
          :slope-slip-angle 8192.0
          :impact-fric 1.0
          :bend-factor 0.8
          :bend-speed 4.0
          :alignv 1.0
          :slope-up-traction 1.0
          :align-speed 1.0
          :flags #x4000
          )
        )
      )
  (set! *rotate-surface* v1-1)
  (set! (-> v1-1 mult-hook)
        (the-as
          (function surface surface surface int none)
          (lambda ((arg0 surface) (arg1 object) (arg2 object) (arg3 int)) (when (= arg3 1)
                                                                            (let ((f0-0 151756.8))
                                                                              (set! (-> arg0 fric) f0-0)
                                                                              f0-0
                                                                              )
                                                                            )
                  )
          )
        )
  (set! (-> v1-1 touch-hook) nothing)
  (set! (-> v1-1 active-hook) nothing)
  )

;; failed to figure out what this is:
(let ((v1-2 (new 'static 'surface
              :name '*no-walk-surface*
              :turnv 0.5
              :turnvv 1.0
              :tiltv 1.0
              :tiltvv 1.0
              :transv-max 0.7
              :target-speed 0.7
              :seek0 24576.0
              :seek90 24576.0
              :seek180 24576.0
              :fric 23756.8
              :nonlin-fric-dist 4091904.0
              :slope-slip-angle 16384.0
              :bend-speed 4.0
              :alignv 0.5
              :slope-up-traction 0.9
              :align-speed 1.0
              :flags #x28
              )
            )
      )
  (set! *no-walk-surface* v1-2)
  (set! (-> v1-2 mult-hook) (the-as (function surface surface surface int none) nothing))
  (set! (-> v1-2 touch-hook) nothing)
  (set! (-> v1-2 active-hook) nothing)
  )
