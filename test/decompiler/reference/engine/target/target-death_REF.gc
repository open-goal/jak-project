;;-*-Lisp-*-
(in-package goal)

;; failed to figure out what this is:
(defskelgroup *deathcam-sg* deathcam
  0
  2
  ((1 (meters 999999)))
  :bounds (static-spherem 0 0 0 4)
  :longest-edge (meters 0)
  :texture-level 2
  )

;; definition for symbol *auto-continue*, type symbol
(define *auto-continue* #f)

;; definition for function next-level
;; INFO: Return type mismatch symbol vs level-load-info.
(defun next-level ((arg0 symbol))
  (let ((v1-0 (lookup-level-info arg0)))
    (the-as level-load-info (when v1-0
                              (let* ((a0-1 *level-load-list*)
                                     (a1-0 (car a0-1))
                                     )
                                (while (not (null? a0-1))
                                  (let ((a1-1 (the-as basic (-> (the-as level-load-info a1-0) name))))
                                    (if (= (-> (the-as level-load-info a1-1) index) (+ (-> v1-0 index) 1))
                                        (return (the-as level-load-info a1-1))
                                        )
                                    )
                                  (set! a0-1 (cdr a0-1))
                                  (set! a1-0 (car a0-1))
                                  )
                                )
                              #f
                              )
            )
    )
  )

;; failed to figure out what this is:
(defstate target-continue (target)
  :event
  target-generic-event-handler
  :exit
  (behavior ()
    (set! (-> *load-boundary-target* 0 quad) (-> (camera-pos) quad))
    (set! (-> *load-boundary-target* 1 quad) (-> (target-pos 0) quad))
    (set! (-> *load-boundary-target* 2 quad) (-> *load-boundary-target* 0 quad))
    (set! (-> *load-boundary-target* 3 quad) (-> *load-boundary-target* 1 quad))
    (when (zero? (logand (-> *game-info* current-continue flags) 176))
      (set! (-> *level* border?) (-> *level* play?))
      (set! (-> *setting-control* default border-mode) (-> *level* play?))
      )
    (clear-pending-settings-from-process *setting-control* self 'allow-pause)
    (clear-pending-settings-from-process *setting-control* self 'allow-progress)
    (clear-pending-settings-from-process *setting-control* self 'bg-a)
    (clear-pending-settings-from-process *setting-control* self 'music-volume)
    (clear-pending-settings-from-process *setting-control* self 'sfx-volume)
    (clear-pending-settings-from-process *setting-control* self 'ambient-volume)
    (clear-pending-settings-from-process *setting-control* self 'music)
    (none)
    )
  :code
  (behavior ((arg0 continue-point))
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (if (-> *art-control* reserve-buffer)
        (reserve-free *art-control* (-> *art-control* reserve-buffer heap))
        )
    (push-setting! *setting-control* self 'bg-a 'abs 1.0 0)
    (set! (-> *setting-control* current bg-a) 1.0)
    (set-setting! *setting-control* self 'sfx-volume 'abs (the-as float 0.0) 0)
    (set-setting! *setting-control* self 'ambient-volume 'abs (the-as float 0.0) 0)
    (let ((v1-20 (lookup-level-info (-> arg0 level))))
      (when v1-20
        (set-setting! *setting-control* self 'music (-> v1-20 music-bank) (the-as float 0.0) 0)
        (set-setting! *setting-control* self 'music-volume 'abs (the-as float 0.0) 0)
        )
      )
    (set! (-> *level* border?) #f)
    (set! (-> *setting-control* default border-mode) #f)
    (reset-target-state #t)
    (target-exit)
    (ja-channel-set! 0)
    (quaternion-copy! (-> self control unknown-quaternion00) (-> arg0 quat))
    (move-to-point! (-> self control) (-> arg0 trans))
    (rot->dir-targ! (-> self control))
    (set! (-> (&-> (-> self control) unknown-qword00) 0) (-> self control trans quad))
    (cond
      ((not (string= (-> arg0 name) "default"))
       (set! *external-cam-mode* #f)
       (cam-stop)
       (suspend)
       0
       )
      (else
        (send-event *camera* 'clear-entity)
        (send-event *camera* 'change-state cam-fixed 0)
        (suspend)
        0
        )
      )
    (set! (-> *load-state* vis-nick) (-> arg0 vis-nick))
    (set! (-> *load-state* want 0 name) (-> arg0 lev0))
    (set! (-> *load-state* want 0 display?) (-> arg0 disp0))
    (set! (-> *load-state* want 0 force-vis?) #f)
    (set! (-> *load-state* want 0 force-inside?) #f)
    (set! (-> *load-state* want 1 name) (-> arg0 lev1))
    (set! (-> *load-state* want 1 display?) (-> arg0 disp1))
    (set! (-> *load-state* want 1 force-vis?) #f)
    (set! (-> *load-state* want 1 force-inside?) #f)
    (when (not (string= (-> arg0 name) "default"))
      (while (not
               (and (or (not (-> arg0 lev0)) (not (-> arg0 disp0)) (= (level-status *level* (-> arg0 lev0)) 'active))
                    (or (not (-> arg0 lev1)) (not (-> arg0 disp1)) (= (level-status *level* (-> arg0 lev1)) 'active))
                    )
               )
        (let ((v1-52 (lookup-level-info (-> arg0 level))))
          (if (and v1-52
                   (= (-> *setting-control* current music) (-> v1-52 music-bank))
                   (zero? (logand (-> arg0 flags) 160))
                   )
              (clear-pending-settings-from-process *setting-control* self 'music-volume)
              )
          )
        (suspend)
        )
      )
    (backup-load-state-and-set-cmds *load-state* '())
    (execute-command *load-state* '(teleport))
    (let* ((s5-0 (-> arg0 load-commands))
           (a1-18 (car s5-0))
           )
      (while (not (null? s5-0))
        (execute-command *load-state* (the-as pair a1-18))
        (set! s5-0 (cdr s5-0))
        (set! a1-18 (car s5-0))
        )
      )
    (restore-load-state *load-state*)
    (set! (-> *ACTOR-bank* birth-max) 1000)
    (new 'stack 'transformq)
    (cond
      ((not (string= (-> arg0 name) "default"))
       (cam-start #t)
       (suspend)
       (suspend)
       (set! (-> *camera-combiner* trans quad) (-> arg0 camera-trans quad))
       (let ((s5-1 (-> *camera-combiner* inv-camera-rot))
             (s4-0 (-> arg0 camera-rot))
             )
         (matrix-identity! s5-1)
         (set! (-> s5-1 vector 0 x) (-> s4-0 0))
         (set! (-> s5-1 vector 0 y) (-> s4-0 1))
         (set! (-> s5-1 vector 0 z) (-> s4-0 2))
         (set! (-> s5-1 vector 1 x) (-> s4-0 3))
         (set! (-> s5-1 vector 1 y) (-> s4-0 4))
         (set! (-> s5-1 vector 1 z) (-> s4-0 5))
         (set! (-> s5-1 vector 2 x) (-> s4-0 6))
         (set! (-> s5-1 vector 2 y) (-> s4-0 7))
         (set! (-> s5-1 vector 2 z) (-> s4-0 8))
         )
       (send-event *camera* 'change-target self)
       (send-event *camera* 'no-intro)
       (send-event *camera* 'clear-entity)
       (send-event *camera* 'force-blend 0)
       (send-event *camera* 'change-state cam-fixed 0)
       (send-event *camera* 'change-state cam-string 0)
       )
      (else
        (send-event *camera* 'change-target self)
        (send-event *camera* 'change-state cam-string 0)
        (send-event *camera* 'teleport)
        (send-event *camera* 'no-intro)
        (send-event *camera* 'clear-entity)
        )
      )
    (send-event self 'level-enter (-> arg0 level))
    (dotimes (v1-124 (-> *level* length))
      (let ((a0-64 (-> *level* level v1-124)))
        (if (= (-> a0-64 status) 'active)
            (set! (-> a0-64 all-visible?) 'loading)
            )
        )
      )
    (let ((s5-2 (level-get *level* (-> arg0 level))))
      (when s5-2
        (while (and (= (-> s5-2 all-visible?) 'loading) (-> *level* vis?))
          (suspend)
          )
        )
      )
    (set! *spawn-actors* #t)
    (set! *teleport* #t)
    (set! (-> *ACTOR-bank* birth-max) 1000)
    (set-blackout-frames (seconds 0.1))
    (cond
      ((logtest? (-> arg0 flags) 128)
       (go target-title)
       )
      ((logtest? (-> arg0 flags) 16)
       (start-sequence-a)
       )
      ((logtest? (-> arg0 flags) 32)
       (let ((s5-3 (entity-by-name "sage-23")))
         (when s5-3
           (set-blackout-frames (seconds 100))
           (entity-birth-no-kill s5-3)
           (suspend)
           (send-event
             (if s5-3
                 (-> s5-3 extra process)
                 )
             'play-anim
             )
           )
         )
       )
      ((and (logtest? (-> arg0 flags) 2048)
            (or (= (get-task-status (game-task beach-ecorocks)) (task-status need-hint))
                (= (get-task-status (game-task beach-ecorocks)) (task-status need-introduction))
                )
            )
       (let ((s5-4 (entity-by-name "sage-23")))
         (when s5-4
           (set-blackout-frames (seconds 100))
           (entity-birth-no-kill s5-4)
           (suspend)
           (set! arg0 (get-continue-by-name *game-info* "village1-hut"))
           (send-event
             (if s5-4
                 (-> s5-4 extra process)
                 )
             'play-anim
             )
           )
         )
       )
      ((logtest? (-> arg0 flags) 8)
       (go target-demo)
       )
      ((logtest? (-> arg0 flags) 64)
       (set-blackout-frames (seconds 1))
       (let ((s5-5 (get-process *default-dead-pool* process #x4000)))
         (when s5-5
           (let ((t9-60 (method-of-type process activate)))
             (t9-60 s5-5 *default-pool* 'process (the-as pointer #x70004000))
             )
           (run-next-time-in-process
             s5-5
             (lambda ()
               (local-vars (v1-10 basic))
               (let ((gp-0 (entity-by-name "sage-23")))
                 (when gp-0
                   (set-blackout-frames (seconds 100))
                   (entity-birth-no-kill gp-0)
                   (suspend)
                   (suspend)
                   (send-event
                     (if gp-0
                         (-> gp-0 extra process)
                         )
                     'play-anim
                     )
                   )
                 )
               (let ((gp-1 (-> *display* base-frame-counter)))
                 (until (>= (- (-> *display* base-frame-counter) gp-1) (seconds 2))
                   (suspend)
                   )
                 )
               (until (not v1-10)
                 (suspend)
                 (set! v1-10 (and *target* (logtest? (-> *target* state-flags) 256)))
                 )
               (set! (-> *cpad-list* cpads 0 change-time) (-> *display* base-frame-counter))
               (reset-actors 'dead)
               (start 'play (get-continue-by-name *game-info* "misty-start"))
               )
             )
           (-> s5-5 ppointer)
           )
         )
       )
      ((logtest? (-> arg0 flags) 4)
       (let ((s5-6 (new 'static 'vector)))
         (cond
           ((string= (-> arg0 name) "village1-warp")
            (set! (-> s5-6 quad) (-> (entity-by-name "villagea-part-1") extra trans quad))
            (suspend)
            (let ((s4-2 (new 'stack-no-clear 'event-message-block)))
              (set! (-> s4-2 from) self)
              (set! (-> s4-2 num-params) 0)
              (set! (-> s4-2 message) 'hidden-other)
              (let ((s3-0 send-event-function)
                    (v1-175 (entity-by-name "sage-23"))
                    )
                (s3-0
                  (if v1-175
                      (-> v1-175 extra process)
                      )
                  s4-2
                  )
                )
              )
            (let ((s4-3 (new 'stack-no-clear 'event-message-block)))
              (set! (-> s4-3 from) self)
              (set! (-> s4-3 num-params) 0)
              (set! (-> s4-3 message) 'hidden-other)
              (let ((s3-1 send-event-function)
                    (v1-179 (entity-by-name "assistant-11"))
                    )
                (s3-1
                  (if v1-179
                      (-> v1-179 extra process)
                      )
                  s4-3
                  )
                )
              )
            (set-continue! *game-info* "village1-hut")
            )
           ((or (string= (-> arg0 name) "training-warp") (string= (-> arg0 name) "game-start"))
            (if (logtest? (-> arg0 flags) 1024)
                (close-specific-task! (game-task intro) (task-status need-resolution))
                )
            (set! (-> s5-6 quad) (-> (entity-by-name "training-part-1") extra trans quad))
            (set-continue! *game-info* "training-start")
            )
           ((string= (-> arg0 name) "village2-warp")
            (set! (-> s5-6 quad) (-> (entity-by-name "villageb-part-55") extra trans quad))
            (when (task-closed? (game-task village2-levitator) (task-status need-hint))
              (suspend)
              (let ((s4-6 (new 'stack-no-clear 'event-message-block)))
                (set! (-> s4-6 from) self)
                (set! (-> s4-6 num-params) 0)
                (set! (-> s4-6 message) 'hidden-other)
                (let ((s3-2 send-event-function)
                      (v1-201 (entity-by-name "assistant-bluehut-1"))
                      )
                  (s3-2
                    (if v1-201
                        (-> v1-201 extra process)
                        )
                    s4-6
                    )
                  )
                )
              (let ((s4-7 (new 'stack-no-clear 'event-message-block)))
                (set! (-> s4-7 from) self)
                (set! (-> s4-7 num-params) 0)
                (set! (-> s4-7 message) 'hidden-other)
                (let ((s3-3 send-event-function)
                      (v1-205 (entity-by-name "sage-bluehut-1"))
                      )
                  (s3-3
                    (if v1-205
                        (-> v1-205 extra process)
                        )
                    s4-7
                    )
                  )
                )
              (let ((s4-8 (new 'stack-no-clear 'event-message-block)))
                (set! (-> s4-8 from) self)
                (set! (-> s4-8 num-params) 0)
                (set! (-> s4-8 message) 'hidden-other)
                (let ((s3-4 send-event-function)
                      (v1-209 (entity-by-name "flutflut-bluehut-1"))
                      )
                  (s3-4
                    (if v1-209
                        (-> v1-209 extra process)
                        )
                    s4-8
                    )
                  )
                )
              )
            (set-continue! *game-info* "village2-start")
            )
           ((string= (-> arg0 name) "village3-warp")
            (set! (-> s5-6 quad) (-> (entity-by-name "villagec-part-32") extra trans quad))
            (when (task-closed? (game-task village3-button) (task-status need-hint))
              (suspend)
              (let ((s4-10 (new 'stack-no-clear 'event-message-block)))
                (set! (-> s4-10 from) self)
                (set! (-> s4-10 num-params) 0)
                (set! (-> s4-10 message) 'hidden-other)
                (let ((s3-5 send-event-function)
                      (v1-220 (entity-by-name "assistant-villagec-1"))
                      )
                  (s3-5
                    (if v1-220
                        (-> v1-220 extra process)
                        )
                    s4-10
                    )
                  )
                )
              (let ((s4-11 (new 'stack-no-clear 'event-message-block)))
                (set! (-> s4-11 from) self)
                (set! (-> s4-11 num-params) 0)
                (set! (-> s4-11 message) 'hidden-other)
                (let ((s3-6 send-event-function)
                      (v1-224 (entity-by-name "sage-villagec-1"))
                      )
                  (s3-6
                    (if v1-224
                        (-> v1-224 extra process)
                        )
                    s4-11
                    )
                  )
                )
              )
            (set-continue! *game-info* "village3-start")
            )
           ((string= (-> arg0 name) "citadel-warp")
            (set! (-> s5-6 quad) (-> (entity-by-name "citb-part-1") extra trans quad))
            (when (task-closed? (game-task village4-button) (task-status need-hint))
              (suspend)
              (let ((s4-13 (new 'stack-no-clear 'event-message-block)))
                (set! (-> s4-13 from) self)
                (set! (-> s4-13 num-params) 0)
                (set! (-> s4-13 message) 'hidden-other)
                (let ((s3-7 send-event-function)
                      (v1-235 (entity-by-name "assistant-lavatube-end-3"))
                      )
                  (s3-7
                    (if v1-235
                        (-> v1-235 extra process)
                        )
                    s4-13
                    )
                  )
                )
              )
            (set-continue! *game-info* "lavatube-end")
            )
           )
         (go target-warp-in s5-6 (-> arg0 trans))
         )
       )
      (else
        (let ((s5-7 (-> *display* base-frame-counter)))
          (until (>= (- (-> *display* base-frame-counter) s5-7) (seconds 0.05))
            (suspend)
            )
          )
        )
      )
    (set-continue! *game-info* arg0)
    (when *auto-continue*
      (let ((s5-8 (next-level (-> arg0 level))))
        (when (and s5-8 (not (null? (-> s5-8 continues))))
          (format 0 "~A ~A ~A~%" (-> arg0 level) (-> s5-8 name) (car (-> s5-8 continues)))
          (inspect global)
          (let ((gp-1 (get-process *default-dead-pool* process #x4000)))
            (when gp-1
              (let ((t9-104 (method-of-type process activate)))
                (t9-104 gp-1 *default-pool* 'process (the-as pointer #x70004000))
                )
              (run-next-time-in-process gp-1 (lambda ((arg0 continue-point)) (start 'play arg0)) (car (-> s5-8 continues)))
              (-> gp-1 ppointer)
              )
            )
          )
        )
      )
    (ja-channel-set! 1)
    (let ((v1-264 (-> self skel root-channel 0)))
      (set! (-> v1-264 frame-group) (the-as art-joint-anim (-> self draw art-group data 5)))
      )
    (suspend)
    (logior! (-> self control status) 7)
    (go target-stance)
    (none)
    )
  :post
  target-no-move-post
  )

;; definition for symbol *smack-mods*, type surface
(define *smack-mods* (new 'static 'surface
                       :name 'jump
                       :tiltv 32768.0
                       :tiltvv 131072.0
                       :transv-max 40960.0
                       :target-speed 40960.0
                       :seek0 0.3
                       :seek90 0.3
                       :seek180 0.3
                       :fric 0.05
                       :nonlin-fric-dist 1.0
                       :slip-factor 1.0
                       :slide-factor 1.0
                       :slope-up-factor 1.0
                       :slope-down-factor 1.0
                       :slope-slip-angle 1.0
                       :impact-fric 1.0
                       :bend-factor 1.0
                       :bend-speed 1.0
                       :alignv 1.0
                       :slope-up-traction 1.0
                       :align-speed 1.0
                       :mult-hook
                       (lambda :behavior target
                         ((arg0 surface) (arg1 surface) (arg2 surface) (arg3 int))
                         (when (= arg3 1)
                           (let ((f30-0 (-> self control unknown-float40))
                                 (f28-0 (-> self control unknown-float41))
                                 )
                             (set! (-> arg0 seek0) (lerp (-> arg0 seek0) (the-as float 409600.0) f28-0))
                             (set! (-> arg0 seek90) (lerp (-> arg0 seek90) (the-as float 409600.0) f28-0))
                             (set! (-> arg0 seek180) (lerp (-> arg0 seek180) (the-as float 409600.0) f28-0))
                             (set! (-> arg0 target-speed) (lerp (-> arg0 target-speed) f30-0 f28-0))
                             (set! (-> arg0 transv-max) (lerp (-> arg0 transv-max) f30-0 f28-0))
                             )
                           )
                         (none)
                         )
                       :mode 'air
                       :flags #x800
                       )
        )

;; definition for symbol *smack-up-mods*, type surface
(define
  *smack-up-mods*
  (new 'static 'surface
    :name 'jump
    :turnv 131072.0
    :turnvv 32768.0
    :tiltv 32768.0
    :tiltvv 131072.0
    :transv-max 40960.0
    :target-speed 40960.0
    :seek0 0.3
    :seek90 0.3
    :seek180 0.3
    :fric 0.05
    :nonlin-fric-dist 1.0
    :slip-factor 1.0
    :slide-factor 1.0
    :slope-up-factor 1.0
    :slope-down-factor 1.0
    :slope-slip-angle 1.0
    :impact-fric 1.0
    :bend-factor 1.0
    :bend-speed 1.0
    :alignv 1.0
    :slope-up-traction 1.0
    :align-speed 1.0
    :mult-hook
    (lambda :behavior target
      ((arg0 surface) (arg1 surface) (arg2 surface) (arg3 int))
      (when (= arg3 1)
        (let ((f30-0 (-> self control unknown-float40))
              (f28-0 (-> self control unknown-float41))
              )
          (set! (-> arg0 seek0) (lerp (-> arg0 seek0) (the-as float 409600.0) f28-0))
          (set! (-> arg0 seek90) (lerp (-> arg0 seek90) (the-as float 409600.0) f28-0))
          (set! (-> arg0 seek180) (lerp (-> arg0 seek180) (the-as float 409600.0) f28-0))
          (set! (-> arg0 target-speed) (lerp (-> arg0 target-speed) f30-0 f28-0))
          (set! (-> arg0 transv-max) (lerp (-> arg0 transv-max) f30-0 f28-0))
          )
        )
      (none)
      )
    :mode 'air
    :flags #x818
    )
  )

;; definition for function velocity-set-to-target!
;; Used lq/sq
(defbehavior velocity-set-to-target! target ((arg0 vector) (arg1 float) (arg2 attack-info))
  (let* ((v1-1 (-> self control trans))
         (gp-1 (vector-! (new 'stack-no-clear 'vector) arg0 v1-1))
         )
    (set! (-> gp-1 y) 0.0)
    (set! (-> self control unknown-vector40 quad) (-> gp-1 quad))
    (vector-xz-normalize! (-> self control unknown-vector40) (the-as float 1.0))
    (set! (-> self control unknown-float50) 1.0)
    (set! (-> self control unknown-float40) arg1)
    (set! (-> self control unknown-float41) (- 1.0 (-> arg2 control)))
    gp-1
    )
  )

;; definition for function target-hit-effect
;; INFO: Return type mismatch int vs none.
(defbehavior target-hit-effect target ((arg0 attack-info))
  (let ((s5-0 (get-process *default-dead-pool* part-tracker #x4000)))
    (when s5-0
      (let ((t9-1 (method-of-type part-tracker activate)))
        (t9-1 (the-as part-tracker s5-0) self 'part-tracker (the-as pointer #x70004000))
        )
      (run-now-in-process
        s5-0
        part-tracker-init
        (-> *part-group-id-table* 1)
        -1
        #f
        #f
        #f
        (if (logtest? (-> arg0 mask) 4)
            (-> arg0 intersection)
            (-> self control root-prim prim-core)
            )
        )
      (-> s5-0 ppointer)
      )
    )
  (let ((v1-9 (-> arg0 mode)))
    (cond
      ((or (= v1-9 'endlessfall) (= v1-9 'instant-death))
       )
      ((begin
         (target-timed-invulnerable (-> arg0 invinc-time) self)
         (cpad-set-buzz! (-> *cpad-list* cpads 0) 0 255 (seconds 0.5))
         (let ((v1-13 (-> arg0 angle)))
           (= v1-13 'up)
           )
         )
       (sound-play-by-name (static-sound-name "hit-up") (new-sound-id) 1024 0 0 1 #t)
       )
      (else
        (sound-play-by-name (static-sound-name "oof") (new-sound-id) 1024 0 0 1 #t)
        )
      )
    )
  (case (-> arg0 mode)
    (('burn 'burnup)
     (let ((gp-1 (get-process *default-dead-pool* process #x4000)))
       (when gp-1
         (let ((t9-10 (method-of-type process activate)))
           (t9-10 gp-1 self 'process (the-as pointer #x70004000))
           )
         (run-next-time-in-process gp-1 process-drawable-burn-effect 1200)
         (-> gp-1 ppointer)
         )
       )
     )
    (('tar)
     (sound-play-by-name (static-sound-name "get-burned") (new-sound-id) 1024 0 0 1 #t)
     )
    )
  0
  (none)
  )

;; definition for function target-hit-push
;; INFO: Return type mismatch symbol vs object.
;; Used lq/sq
(defbehavior target-hit-push target ((arg0 vector) (arg1 matrix) (arg2 float) (arg3 float) (arg4 attack-info))
  (case (-> arg4 angle)
    (('jump 'up 'up-forward)
     (when (and (zero? (logand (-> self control root-prim prim-core action) (collide-action ca-9 ca-14)))
                (not (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact-info-target health))))
                )
       (if (and (cpad-pressed? (-> self control unknown-cpad-info00 number) circle) (can-feet?))
           (go target-attack-air #f)
           )
       (if (and (cpad-pressed? (-> self control unknown-cpad-info00 number) square)
                (< (vector-dot (-> self control dynam gravity-normal) (-> self control transv)) 26624.0)
                (and (< -61440.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                     (>= (- (-> *display* base-frame-counter) (-> self control unknown-dword36))
                         (the-as time-frame (-> *TARGET-bank* stuck-timeout))
                         )
                     (zero? (logand (-> self state-flags) 4096))
                     (zero? (logand (-> self control unknown-surface01 flags) 384))
                     )
                )
           (go
             target-flop
             (the-as float 65502.96)
             (the-as float -163840.0)
             (the-as float (if (= (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) stick0-speed) 0.0)
                               0.0
                               68812.8
                               )
                     )
             )
           )
       )
     )
    )
  (when (if (and (< (target-move-dist (-> *TARGET-bank* stuck-time)) (-> *TARGET-bank* stuck-distance))
                 (and (>= (- (-> *display* base-frame-counter) (-> self state-time))
                          (the-as time-frame (-> *TARGET-bank* stuck-time))
                          )
                      (not (and *cheat-mode* (cpad-hold? (-> self control unknown-cpad-info00 number) r2)))
                      )
                 )
            #t
            )
    (logior! (-> self control status) 1)
    (return (the-as object 'stuck))
    )
  (let ((s1-0 (new-stack-vector0)))
    (set! (-> s1-0 z) arg2)
    (vector-matrix*! s1-0 s1-0 arg1)
    (vector+! s1-0 s1-0 arg0)
    (cond
      ((< (vector-vector-distance arg0 s1-0) (fabs (-> arg4 dist)))
       (velocity-set-to-target! s1-0 (fabs arg3) arg4)
       #t
       )
      (else
        (set! (-> self control unknown-float40) 0.0)
        (set! (-> self control unknown-float41) (- 1.0 (-> arg4 control)))
        #f
        )
      )
    )
  )

;; definition for function target-hit-orient
(defbehavior target-hit-orient target ((arg0 attack-info) (arg1 vector))
  (let ((s5-0 #f))
    (if (and (!= (-> arg0 angle) 'front)
             (!= (-> arg0 angle) 'shove)
             (logtest? (-> arg0 mask) 2)
             (!= (-> arg0 shove-back) 0.0)
             )
        (forward-up-nopitch->quaternion (-> self control dir-targ) arg1 (-> self control dynam gravity-normal))
        )
    (case (-> arg0 angle)
      (('back 'air)
       (set! s5-0 #t)
       )
      (('up-forward)
       (set! (-> self control unknown-surface00) *smack-up-mods*)
       )
      (('front)
       (if (and (logtest? (-> arg0 mask) 2) (!= (-> arg0 shove-back) 0.0))
           (forward-up-nopitch->quaternion
             (-> self control dir-targ)
             (vector-negate! (new 'stack-no-clear 'vector) arg1)
             (-> self control dynam gravity-normal)
             )
           )
       (set! s5-0 #t)
       )
      (('jump)
       (set! s5-0 #t)
       (set! (-> self control unknown-surface00) *forward-high-jump-mods*)
       )
      )
    s5-0
    )
  )

;; definition for function target-hit-setup-anim
(defbehavior target-hit-setup-anim target ((arg0 attack-info))
  (case (-> arg0 angle)
    (('back)
     (when (not (= (if (> (-> self skel active-channels) 0)
                       (-> self skel root-channel 0 frame-group)
                       )
                   (-> self draw art-group data 74)
                   )
                )
       (ja-channel-push! 1 22)
       (let ((gp-1 (-> self skel root-channel 0)))
         (joint-control-channel-group-eval!
           gp-1
           (the-as art-joint-anim (-> self draw art-group data 74))
           num-func-identity
           )
         (let ((f0-0 0.0))
           (set! (-> gp-1 frame-num) f0-0)
           f0-0
           )
         )
       )
     )
    (('up 'up-forward)
     (when (not (= (if (> (-> self skel active-channels) 0)
                       (-> self skel root-channel 0 frame-group)
                       )
                   (-> self draw art-group data 75)
                   )
                )
       (ja-channel-push! 1 22)
       (let ((gp-2 (-> self skel root-channel 0)))
         (joint-control-channel-group-eval!
           gp-2
           (the-as art-joint-anim (-> self draw art-group data 75))
           num-func-identity
           )
         (let ((f0-1 0.0))
           (set! (-> gp-2 frame-num) f0-1)
           f0-1
           )
         )
       )
     )
    (('air 'jump)
     (ja-channel-push! 1 15)
     (let ((a0-21 (-> self skel root-channel 0)))
       (set! (-> a0-21 frame-group) (the-as art-joint-anim (-> self draw art-group data 34)))
       (set! (-> a0-21 param 0)
             (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 34)) data 0 length) -1))
             )
       (set! (-> a0-21 param 1) 1.0)
       (set! (-> a0-21 frame-num) 0.0)
       (joint-control-channel-group! a0-21 (the-as art-joint-anim (-> self draw art-group data 34)) num-func-seek!)
       )
     (when (= (-> arg0 angle) 'air)
       (sound-play-by-name (static-sound-name "smack-surface") (new-sound-id) 1024 0 0 1 #t)
       (dummy-10 (-> self skel effect) 'group-smack-surface (the-as float 0.0) 5)
       (dummy-10 (-> self skel effect) 'group-smack-surface-dizzy (the-as float 0.0) 8)
       )
     )
    (('shove)
     (ja-channel-push! 1 15)
     (let ((a0-30 (-> self skel root-channel 0)))
       (set! (-> a0-30 frame-group) (the-as art-joint-anim (-> self draw art-group data 78)))
       (set! (-> a0-30 param 0)
             (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 78)) data 0 length) -1))
             )
       (set! (-> a0-30 param 1) 1.0)
       (set! (-> a0-30 frame-num) 0.0)
       (joint-control-channel-group! a0-30 (the-as art-joint-anim (-> self draw art-group data 78)) num-func-seek!)
       )
     (sound-play-by-name (static-sound-name "smack-surface") (new-sound-id) 1024 0 0 1 #t)
     )
    (else
      (when (not (= (if (> (-> self skel active-channels) 0)
                        (-> self skel root-channel 0 frame-group)
                        )
                    (-> self draw art-group data 73)
                    )
                 )
        (ja-channel-push! 1 22)
        (let ((gp-5 (-> self skel root-channel 0)))
          (joint-control-channel-group-eval!
            gp-5
            (the-as art-joint-anim (-> self draw art-group data 73))
            num-func-identity
            )
          (let ((f0-10 0.0))
            (set! (-> gp-5 frame-num) f0-10)
            f0-10
            )
          )
        )
      )
    )
  )

;; definition for function target-hit-move
;; INFO: Return type mismatch int vs none.
;; Used lq/sq
(defbehavior target-hit-move target ((arg0 attack-info) (arg1 symbol) (arg2 (function none :behavior target)) (arg3 float))
  (local-vars (v1-40 symbol) (s2-1 object))
  (vector-identity! (-> self control transv))
  (let ((s3-0 (new-stack-vector0)))
    (let ((f0-1 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
      0.0
      (vector-! s3-0 (-> self control transv) (vector-float*! s3-0 (-> self control dynam gravity-normal) f0-1))
      )
    (let* ((f0-2 (vector-length s3-0))
           (f1-1 f0-2)
           (f2-1 (+ 2048.0 (sqrtf (* 491520.0 (-> arg0 shove-up)))))
           )
      (vector+!
        (-> self control transv)
        (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-1)
        (vector-float*! s3-0 s3-0 (/ f0-2 f1-1))
        )
      )
    )
  (let ((s3-1 (new 'stack-no-clear 'vector)))
    (set! (-> s3-1 quad) (-> self control trans quad))
    (let ((s1-1 (matrix-rotate-y! (new 'stack-no-clear 'matrix) (+ 32768.0 (vector-y-angle (-> arg0 vector)))))
          (f30-1 0.0)
          )
      (set-quaternion! (-> self control) (-> self control dir-targ))
      #t
      (let ((f28-1 (* 1.05 (/ (* -60.0 arg3) (* (the float (+ (-> (if (> (-> self skel active-channels) 0)
                                                                      (-> self skel root-channel 0 frame-group)
                                                                      )
                                                                  data
                                                                  0
                                                                  length
                                                                  )
                                                              -1
                                                              )
                                                     )
                                                (ja-step 0)
                                                )
                              )
                      )
                   )
            )
        (until v1-40
          (+! f30-1 (* (-> arg0 shove-back) f28-1 (-> *display* seconds-per-frame)))
          (set! s2-1 (target-hit-push s3-1 s1-1 f30-1 (* (-> arg0 shove-back) f28-1) arg0))
          (suspend)
          (let ((a0-14 (-> self skel root-channel 0)))
            (set! (-> a0-14 param 0) (the float (+ (-> a0-14 frame-group data 0 length) -1)))
            (set! (-> a0-14 param 1) 1.0)
            (joint-control-channel-group-eval! a0-14 (the-as art-joint-anim #f) num-func-seek!)
            )
          (set! v1-40 (or (ja-done? 0) (and arg1 (logtest? (-> self control status) 1))))
          )
        (while (and (or (zero? (logand (-> self control status) 1)) s2-1) (!= s2-1 'stuck))
          (arg2)
          (+! f30-1 (* (-> arg0 shove-back) f28-1 (-> *display* seconds-per-frame)))
          (set! s2-1 (target-hit-push s3-1 s1-1 f30-1 (* (-> arg0 shove-back) f28-1) arg0))
          (if (not s2-1)
              (set! (-> self state-flags) (logand -9 (-> self state-flags)))
              )
          (suspend)
          )
        )
      )
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate target-hit (target)
  :event
  target-standard-event-handler
  :exit
  (behavior ()
    (let ((gp-0 (new-stack-vector0))
          (f30-0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
          )
      0.0
      (vector-! gp-0 (-> self control transv) (vector-float*! gp-0 (-> self control dynam gravity-normal) f30-0))
      (let* ((f1-0 (vector-length gp-0))
             (f0-3 f1-0)
             )
        (if (< 40960.0 f1-0)
            (set! f1-0 40960.0)
            )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f30-0)
          (vector-float*! gp-0 gp-0 (/ f1-0 f0-3))
          )
        )
      )
    (if (!= (-> self next-state name) 'target-death)
        (set! (-> self state-flags) (logand -32777 (-> self state-flags)))
        )
    (target-exit)
    (none)
    )
  :trans
  (behavior ()
    (when (= *cheat-mode* 'debug)
      (when (and (not *pause-lock*) (cpad-hold? (-> self control unknown-cpad-info00 number) r2))
        (pickup-collectable! (-> self fact-info-target) (pickup-type eco-green) (the-as float 1.0) (the-as handle #f))
        (go target-stance)
        )
      )
    (none)
    )
  :code
  (behavior ((arg0 symbol) (arg1 attack-info))
    (set! (-> self water flags) (logand -65537 (-> self water flags)))
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (let ((gp-0 (-> self attack-info)))
      (let ((s5-0 (new 'stack-no-clear 'vector)))
        (let ((v1-4 gp-0))
          (set! (-> v1-4 attacker) (the-as handle #f))
          (set! (-> v1-4 mode) 'generic)
          (set! (-> v1-4 shove-back) 6144.0)
          (set! (-> v1-4 shove-up) 4915.2)
          (set! (-> v1-4 angle) #f)
          (set! (-> v1-4 trans quad) (-> self control trans quad))
          (set! (-> v1-4 control) 0.0)
          (set! (-> v1-4 invinc-time) (-> *TARGET-bank* hit-invulnerable-timeout))
          )
        (case arg0
          (('shove)
           (let ((v1-7 gp-0))
             (set! (-> v1-7 shove-back) (-> *TARGET-bank* smack-surface-dist))
             (set! (-> v1-7 shove-up) (-> *TARGET-bank* smack-surface-height))
             (set! (-> v1-7 angle) 'shove)
             )
           )
          )
        (dummy-9 gp-0 arg1)
        (when (zero? (logand (-> gp-0 mask) 2))
          (vector-z-quaternion! (-> gp-0 vector) (-> self control unknown-quaternion00))
          (vector-xz-normalize! (-> gp-0 vector) (- (fabs (-> gp-0 shove-back))))
          (set! (-> gp-0 vector y) (-> gp-0 shove-up))
          )
        (set! (-> s5-0 quad) (-> gp-0 vector quad))
        (let ((f0-10 (vector-dot
                       (vector-normalize-copy! (new 'stack-no-clear 'vector) s5-0 (the-as float 1.0))
                       (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control unknown-quaternion00))
                       )
                     )
              )
          (if (not (-> self attack-info angle))
              (set! (-> self attack-info angle) (if (>= 0.0 f0-10)
                                                    'front
                                                    'back
                                                    )
                    )
              )
          )
        (when (= arg0 'attack)
          (logior! (-> self state-flags) 8)
          (set! (-> self game hit-time) (-> *display* base-frame-counter))
          (case (-> gp-0 mode)
            (('endlessfall)
             (cond
               ((= (-> self game mode) 'debug)
                (let ((s4-1 (new-stack-vector0)))
                  (set! (-> s4-1 quad) (-> self control last-known-safe-ground quad))
                  (ja-channel-set! 0)
                  (let ((s3-1 (-> *display* base-frame-counter)))
                    (until (>= (- (-> *display* base-frame-counter) s3-1) (seconds 1))
                      (suspend)
                      )
                    )
                  (move-to-point! (-> self control) s4-1)
                  )
                (set! (-> (&-> (-> self control) unknown-qword00) 0) (-> self control trans quad))
                (send-event *camera* 'teleport)
                (go target-stance)
                )
               (else
                 (pickup-collectable!
                   (-> self fact-info-target)
                   (pickup-type eco-green)
                   (the-as float -1000.0)
                   (the-as handle #f)
                   )
                 (go target-death (-> gp-0 mode))
                 )
               )
             )
            (('drown-death 'sharkey 'lava 'dark-eco-pool 'ogreboss-super-boulder 'melt 'instant-death)
             (pickup-collectable!
               (-> self fact-info-target)
               (pickup-type eco-green)
               (the-as float -1000.0)
               (the-as handle #f)
               )
             (if (= (-> self game mode) 'play)
                 (go target-death (-> gp-0 mode))
                 )
             )
            (('death)
             (pickup-collectable!
               (-> self fact-info-target)
               (pickup-type eco-green)
               (the-as float -1000.0)
               (the-as handle #f)
               )
             )
            (('plant-boss)
             (pickup-collectable!
               (-> self fact-info-target)
               (pickup-type eco-green)
               (- (-> *FACT-bank* health-single-inc))
               (the-as handle #f)
               )
             (if (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact-info-target health)))
                 (go target-death (-> gp-0 mode))
                 )
             )
            (else
              (pickup-collectable!
                (-> self fact-info-target)
                (pickup-type eco-green)
                (- (-> *FACT-bank* health-single-inc))
                (the-as handle #f)
                )
              )
            )
          (target-hit-effect gp-0)
          )
        (set! (-> self control unknown-surface00) *smack-mods*)
        (target-hit-setup-anim gp-0)
        (target-hit-move gp-0 (target-hit-orient gp-0 s5-0) target-falling-anim-trans (the-as float 1.0))
        )
      (if (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact-info-target health)))
          (go target-death (-> gp-0 mode))
          )
      )
    (go target-hit-ground #f)
    (none)
    )
  :post
  (the-as (function none :behavior target) target-post)
  )

;; definition for symbol *death-spool-array*, type (array spool-anim)
(define
  *death-spool-array*
  (the-as (array spool-anim)
    (new
      'static
      'boxed-array
      :type spool-anim :length 11 :allocated-length 11
      (new 'static 'spool-anim :name "death-0181" :index 3 :parts 1 :command-list '())
      (new 'static 'spool-anim :name "death-0182" :index 4 :parts 1 :command-list '())
      (new 'static 'spool-anim :name "death-0184" :index 5 :parts 1 :command-list '())
      (new 'static 'spool-anim :name "death-0186" :index 6 :parts 1 :command-list '())
      (new 'static 'spool-anim :name "death-0187" :index 7 :parts 1 :command-list '())
      (new 'static 'spool-anim :name "death-0191" :index 8 :parts 1 :command-list '())
      (new 'static 'spool-anim :name "death-0193" :index 9 :parts 2 :command-list '())
      (new 'static 'spool-anim :name "death-0195" :index 10 :parts 1 :command-list '())
      (new 'static 'spool-anim :name "death-0197" :index 11 :parts 2 :command-list '())
      (new 'static 'spool-anim :name "death-0199" :index 12 :parts 2 :command-list '())
      (new 'static 'spool-anim :name "death-0202" :index 13 :parts 1 :command-list '())
      )
    )
  )

;; failed to figure out what this is:
(if (!= *kernel-boot-message* 'play)
    (set! (-> *death-spool-array* length) 3)
    )

;; definition for function death-movie-remap
(defun death-movie-remap ((arg0 int) (arg1 int))
  (let ((v1-0 (/ arg0 arg1)))
    (mod
      (if (zero? (logand v1-0 1))
          (logxor v1-0 arg0)
          (logand #xfffffff (- (logxor v1-0 arg0)))
          )
      arg1
      )
    )
  )

;; definition for function target-death-anim
;; INFO: Return type mismatch int vs none.
(defbehavior target-death-anim target ((arg0 spool-anim))
  (set! (-> self control unknown-surface00) *neutral-mods*)
  (ja-channel-push! 1 30)
  (let ((a0-3 (-> self skel root-channel 0)))
    (set! (-> a0-3 frame-group) (the-as art-joint-anim (-> self draw art-group data 76)))
    (set! (-> a0-3 param 0)
          (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 76)) data 0 length) -1))
          )
    (set! (-> a0-3 param 1) 1.0)
    (set! (-> a0-3 frame-num) 0.0)
    (joint-control-channel-group! a0-3 (the-as art-joint-anim (-> self draw art-group data 76)) num-func-seek!)
    )
  (until (ja-done? 0)
    (if arg0
        (spool-push *art-control* (-> arg0 name) 0 self (the-as float -99.0))
        )
    (send-event *camera* 'joystick 0.0 -1.0)
    (TODO-RENAME-9 (-> self align))
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (when (zero? (logand (-> self align flags) 1))
        (vector-matrix*! s5-0 (the-as vector (-> self align delta)) (-> self control unknown-matrix01))
        (vector-float*! (-> self control transv) s5-0 (-> *display* frames-per-second))
        )
      )
    (suspend)
    (let ((a0-9 (-> self skel root-channel 0)))
      (set! (-> a0-9 param 0) (the float (+ (-> a0-9 frame-group data 0 length) -1)))
      (set! (-> a0-9 param 1) 1.0)
      (joint-control-channel-group-eval! a0-9 (the-as art-joint-anim #f) num-func-seek!)
      )
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate target-death (target)
  :exit
  (behavior ()
    (set! (-> self state-flags) (logand -32777 (-> self state-flags)))
    (target-exit)
    (clear-pending-settings-from-process *setting-control* self 'process-mask)
    (clear-pending-settings-from-process *setting-control* self 'allow-progress)
    (restore-collide-with-as (-> self control))
    (set! (-> self control pat-ignore-mask) (new 'static 'pat-surface :skip #x1 :noentity #x1))
    (set! (-> self control dynam gravity-max) (-> self control unknown-dynamics00 gravity-max))
    (set! (-> self control dynam gravity-length) (-> self control unknown-dynamics00 gravity-length))
    (none)
    )
  :trans
  (-> target-hit trans)
  :code
  (behavior ((arg0 symbol))
    (set! (-> self control unknown-uint20) (the-as uint #f))
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) self)
      (set! (-> a1-0 num-params) 2)
      (set! (-> a1-0 message) 'target)
      (set! (-> a1-0 param 0) (the-as uint 'die))
      (set! (-> a1-0 param 1) (the-as uint arg0))
      (set! (-> self control unknown-int21)
            (the-as int (send-event-function (handle->process (-> self attack-info attacker)) a1-0))
            )
      )
    (set! (-> self neck flex-blend) 0.0)
    (target-timed-invulnerable-off self)
    (set-setting! *setting-control* self 'process-mask 'set (the-as float 0.0) #x14a0000)
    (copy-settings-from-target! *setting-control*)
    (set! (-> self control transv quad) (the-as uint128 0))
    (logior! (-> self state-flags) #x8000)
    (case arg0
      (('none 'instant-death)
       )
      (('ogreboss-super-boulder)
       (set! (-> self post-hook) target-no-ja-move-post)
       (-> self attack-info attacker)
       (ja-channel-set! 0)
       (ja-post)
       (let ((gp-1 (-> *display* base-frame-counter)))
         (until (>= (- (-> *display* base-frame-counter) gp-1) (seconds 1))
           (suspend)
           )
         )
       )
      (('drown 'drown-death)
       (sound-play-by-name (static-sound-name "death-drown") (new-sound-id) 1024 0 0 1 #t)
       (set! (-> self water flags) (logand -17 (-> self water flags)))
       (clear-collide-with-as (-> self control))
       (set! (-> self control unknown-surface00) *dive-mods*)
       (set! (-> self control dynam gravity-max) 6144.0)
       (set! (-> self control dynam gravity-length) 6144.0)
       (ja-channel-push! 1 30)
       (let ((f30-0 0.7)
             (gp-3 (-> self skel root-channel 0))
             )
         (set! (-> gp-3 frame-group) (the-as art-joint-anim (-> self draw art-group data 93)))
         (set! (-> gp-3 param 0) (ja-aframe (the-as float 73.0) 0))
         (let ((f30-1 (seek f30-0 (the-as float 0.05) (* 1.5 (-> *display* seconds-per-frame)))))
           (set! (-> gp-3 param 1) f30-1)
           (set! (-> gp-3 frame-num) 0.0)
           (joint-control-channel-group! gp-3 (the-as art-joint-anim (-> self draw art-group data 93)) num-func-seek!)
           (until (ja-done? 0)
             (suspend)
             (let ((gp-4 (-> self skel root-channel 0)))
               (set! (-> gp-4 param 0) (ja-aframe (the-as float 73.0) 0))
               (set! f30-1 (seek f30-1 (the-as float 0.05) (* 1.5 (-> *display* seconds-per-frame))))
               (set! (-> gp-4 param 1) f30-1)
               (joint-control-channel-group-eval! gp-4 (the-as art-joint-anim #f) num-func-seek!)
               )
             )
           )
         )
       )
      (('lava 'dark-eco-pool 'melt)
       (let ((s5-1 (handle->process (-> self attack-info attacker))))
         (when (if (and (nonzero? s5-1) (type-type? (-> s5-1 type) water-vol))
                   s5-1
                   )
           (set! (-> self state-flags) (logior #x80000 (-> self state-flags)))
           (set! (-> self alt-cam-pos y) (+ 4096.0 (-> self water height)))
           )
         )
       (cond
         ((= arg0 'dark-eco-pool)
          (sound-play-by-name (static-sound-name "death-darkeco") (new-sound-id) 1024 0 0 1 #t)
          (let ((gp-6 (get-process *default-dead-pool* part-tracker #x4000)))
            (when gp-6
              (let ((t9-21 (method-of-type part-tracker activate)))
                (t9-21 (the-as part-tracker gp-6) *entity-pool* 'part-tracker (the-as pointer #x70004000))
                )
              (run-now-in-process gp-6 part-tracker-init (-> *part-group-id-table* 31) -1 #f #f #f (-> self control trans))
              (-> gp-6 ppointer)
              )
            )
          )
         ((or (= arg0 'lava) (= arg0 'melt))
          (sound-play-by-name (static-sound-name "death-melt") (new-sound-id) 1024 0 0 1 #t)
          (let ((gp-8 (get-process *default-dead-pool* part-tracker #x4000)))
            (when gp-8
              (let ((t9-26 (method-of-type part-tracker activate)))
                (t9-26 (the-as part-tracker gp-8) *entity-pool* 'part-tracker (the-as pointer #x70004000))
                )
              (run-now-in-process gp-8 part-tracker-init (-> *part-group-id-table* 32) -1 #f #f #f (-> self control trans))
              (-> gp-8 ppointer)
              )
            )
          )
         )
       (clear-collide-with-as (-> self control))
       (set! (-> self post-hook) target-no-ja-move-post)
       (ja-channel-set! 0)
       (ja-post)
       (let ((gp-9 (-> *display* base-frame-counter)))
         (until (>= (- (-> *display* base-frame-counter) gp-9) (seconds 2))
           (suspend)
           )
         )
       )
      (('endlessfall)
       (sound-play-by-name (static-sound-name "death-fall") (new-sound-id) 1024 0 0 1 #t)
       (camera-change-to (the-as string cam-endlessfall) 30 #f)
       (set! (-> self control pat-ignore-mask unknown-bit) 1)
       (set! (-> self water flags) (logand -17 (-> self water flags)))
       (let ((f30-2 (fmin -4096.0 (- (-> self control ground-impact-vel)))))
         (set! (-> self control unknown-uint20) (the-as uint f30-2))
         (let ((gp-11 (new-stack-vector0)))
           (let ((f0-14 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
             0.0
             (vector-! gp-11 (-> self control transv) (vector-float*! gp-11 (-> self control dynam gravity-normal) f0-14))
             )
           (let* ((f0-15 (vector-length gp-11))
                  (f1-6 f0-15)
                  )
             (vector+!
               (-> self control transv)
               (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f30-2)
               (vector-float*! gp-11 gp-11 (/ f0-15 f1-6))
               )
             )
           )
         )
       (set! (-> self trans-hook)
             (lambda :behavior target
               ()
               (vector-seek! (-> self draw color-mult) *zero-vector* (-> *display* seconds-per-frame))
               (let ((gp-0 (new-stack-vector0))
                     (f30-0 (the-as number (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
                     )
                 0.0
                 (vector-!
                   gp-0
                   (-> self control transv)
                   (vector-float*! gp-0 (-> self control dynam gravity-normal) (the-as float f30-0))
                   )
                 (let* ((f0-4 (vector-length gp-0))
                        (f1-0 f0-4)
                        )
                   (if (< (the-as float (-> self control unknown-uint20)) (the-as float f30-0))
                       (set! f30-0 (-> self control unknown-uint20))
                       )
                   (vector+!
                     (-> self control transv)
                     (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) (the-as float f30-0))
                     (vector-float*! gp-0 gp-0 (/ f0-4 f1-0))
                     )
                   )
                 )
               ((-> target-hit trans))
               (none)
               )
             )
       (target-falling-anim (seconds 0.1) 99)
       (ja-channel-push! 1 90)
       (let ((a0-75 (-> self skel root-channel 0)))
         (set! (-> a0-75 frame-group) (the-as art-joint-anim (-> self draw art-group data 43)))
         (set! (-> a0-75 param 0) 0.5)
         (set! (-> a0-75 frame-num) 0.0)
         (joint-control-channel-group! a0-75 (the-as art-joint-anim (-> self draw art-group data 43)) num-func-loop!)
         )
       (let ((gp-12 (-> *display* base-frame-counter)))
         (until (>= (- (-> *display* base-frame-counter) gp-12) (seconds 0.8))
           (let ((a0-76 (-> self skel root-channel 0)))
             (set! (-> a0-76 frame-group) (the-as art-joint-anim (-> self draw art-group data 43)))
             (set! (-> a0-76 param 0) 0.5)
             (joint-control-channel-group-eval!
               a0-76
               (the-as art-joint-anim (-> self draw art-group data 43))
               num-func-loop!
               )
             )
           (suspend)
           )
         )
       (camera-change-to (the-as string 'base) 0 #f)
       )
      (('target-hit-ground-hard)
       (set! (-> self control unknown-surface00) *neutral-mods*)
       (ja-channel-push! 1 30)
       (let ((a0-81 (-> self skel root-channel 0)))
         (set! (-> a0-81 frame-group) (the-as art-joint-anim (-> self draw art-group data 77)))
         (set! (-> a0-81 param 0)
               (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 77)) data 0 length) -1))
               )
         (set! (-> a0-81 param 1) 1.0)
         (set! (-> a0-81 frame-num) 0.0)
         (joint-control-channel-group! a0-81 (the-as art-joint-anim (-> self draw art-group data 77)) num-func-seek!)
         )
       (until (ja-done? 0)
         (suspend)
         (let ((a0-82 (-> self skel root-channel 0)))
           (set! (-> a0-82 param 0) (the float (+ (-> a0-82 frame-group data 0 length) -1)))
           (set! (-> a0-82 param 1) 1.0)
           (joint-control-channel-group-eval! a0-82 (the-as art-joint-anim #f) num-func-seek!)
           )
         )
       )
      (('sharkey)
       (send-event self 'dry)
       (set! (-> self post-hook) target-no-ja-move-post)
       (let ((gp-13 (-> self attack-info attacker)))
         (ja-channel-set! 0)
         (ja-post)
         (while (and (handle->process gp-13) (not (-> self control unknown-spoolanim00)))
           (send-event *camera* 'joystick 0.0 0.0)
           (suspend)
           )
         )
       )
      (('plant-boss)
       (set! (-> self trans-hook) #f)
       (let ((gp-14 (-> self attack-info attacker))
             (a1-44 (new 'stack-no-clear 'event-message-block))
             )
         (set! (-> a1-44 from) self)
         (set! (-> a1-44 num-params) 0)
         (set! (-> a1-44 message) 'joint)
         (let ((s5-5 (the-as int (send-event-function (handle->process gp-14) a1-44))))
           (send-event (ppointer->process (-> self sidekick)) 'matrix 'copy-parent)
           (set! (-> self post-hook) target-no-ja-move-post)
           (let ((a0-98 (-> self node-list data)))
             (set! (-> a0-98 0 param0) nothing)
             (set! (-> a0-98 0 param1) #f)
             (set! (-> a0-98 0 param2) #f)
             )
           (while (and (handle->process gp-14) (not (-> self control unknown-spoolanim00)) (-> self control unknown-int21))
             (let* ((v1-205 (-> (the-as process-drawable (handle->process gp-14)) node-list data s5-5 bone transform))
                    (a3-9 (-> self node-list data 0 bone transform))
                    (a0-106 (-> v1-205 vector 0 quad))
                    (a1-47 (-> v1-205 vector 1 quad))
                    (a2-26 (-> v1-205 vector 2 quad))
                    (v1-206 (-> v1-205 vector 3 quad))
                    )
               (set! (-> a3-9 vector 0 quad) a0-106)
               (set! (-> a3-9 vector 1 quad) a1-47)
               (set! (-> a3-9 vector 2 quad) a2-26)
               (set! (-> a3-9 vector 3 quad) v1-206)
               )
             (clone-anim-once gp-14 33 #f "")
             (suspend)
             0
             )
           )
         )
       )
      (('burn 'burnup)
       (let ((gp-15 (get-process *default-dead-pool* part-tracker #x4000)))
         (when gp-15
           (let ((t9-52 (method-of-type part-tracker activate)))
             (t9-52 (the-as part-tracker gp-15) *entity-pool* 'part-tracker (the-as pointer #x70004000))
             )
           (run-now-in-process
             gp-15
             part-tracker-init
             (-> *part-group-id-table* 708)
             -1
             #f
             #f
             #f
             (-> self control trans)
             )
           (-> gp-15 ppointer)
           )
         )
       (target-death-anim (the-as spool-anim #f))
       )
      (else
        (case arg0
          (('tar)
           (sound-play-by-name (static-sound-name "death-drown") (new-sound-id) 1024 0 0 1 #t)
           )
          )
        (+! (-> *game-info* death-movie-tick) 1)
        (if (= (death-movie-remap (+ (-> *game-info* death-movie-tick) -1) (-> *death-spool-array* length))
               (death-movie-remap (-> *game-info* death-movie-tick) (-> *death-spool-array* length))
               )
            (+! (-> *game-info* death-movie-tick) 1)
            )
        (let ((gp-18
                (-> *death-spool-array* (death-movie-remap (-> *game-info* death-movie-tick) (-> *death-spool-array* length)))
                )
              )
          (set-setting! *setting-control* self 'allow-progress #f (the-as float 0.0) 0)
          (target-death-anim gp-18)
          (when (and (< (rand-vu-int-count (-> *game-info* death-movie-tick)) (* (-> *death-spool-array* length) 2))
                     (zero? (logand (-> self water flags) 512))
                     (!= (-> self control ground-pat material) 9)
                     (!= (-> self control ground-pat material) 10)
                     )
            (iterate-process-tree
              *entity-pool*
              (lambda :behavior target
                ((arg0 process))
                (if (and (logtest? (process-mask enemy) (-> arg0 mask))
                         (type-type? (-> arg0 type) process-drawable)
                         (nonzero? (-> (the-as process-drawable arg0) root))
                         (< (vector-vector-distance (-> (the-as process-drawable arg0) root trans) (-> *target* control trans))
                            61440.0
                            )
                         )
                    (process-entity-status! arg0 (entity-perm-status bit-9) #t)
                    )
                )
              *null-kernel-context*
              )
            (set! (-> *ACTOR-bank* birth-max) 1000)
            (set! (-> self trans-hook) #f)
            (send-event (ppointer->process (-> self sidekick)) 'matrix 'play-anim)
            (send-event (ppointer->process (-> self sidekick)) 'shadow #f)
            (send-event self 'blend-shape #t)
            (let* ((s5-7 (get-process *default-dead-pool* pov-camera #x4000))
                   (s5-8
                     (ppointer->handle
                       (when s5-7
                         (let ((t9-68 (method-of-type pov-camera activate)))
                           (t9-68 (the-as pov-camera s5-7) *target-pool* 'pov-camera (the-as pointer #x70004000))
                           )
                         (run-now-in-process s5-7 pov-camera-init-by-other (-> self control trans) *deathcam-sg* gp-18 4 self '())
                         (-> s5-7 ppointer)
                         )
                       )
                     )
                   )
              (send-event (handle->process s5-8) 'music-movie-volume 0.0)
              (send-event (handle->process s5-8) 'sfx-movie-volume 50.0)
              (set! (-> self post-hook) target-no-ja-move-post)
              (while (not (-> self control unknown-spoolanim00))
                (spool-push *art-control* (-> gp-18 name) 0 self (the-as float -99.0))
                (clone-anim-once s5-8 33 #f "")
                (suspend)
                )
              (let ((a0-155 (handle->process s5-8)))
                (if a0-155
                    (deactivate a0-155)
                    )
                )
              )
            (send-event (ppointer->process (-> self sidekick)) 'shadow #t)
            (suspend)
            0
            )
          )
        )
      )
    (set! (-> self control transv quad) (the-as uint128 0))
    (initialize! (-> self game) 'dead (the-as game-save #f) (the-as string #f))
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (anim-loop)
    (none)
    )
  :post
  target-no-stick-post
  )
