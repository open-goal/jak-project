;;-*-Lisp-*-
(in-package goal)

;; failed to figure out what this is:
(defstate target-load-wait (target)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (case arg2
      (('loading)
       (set! (-> self state-time) (-> *display* base-frame-counter))
       #f
       )
      (else
        (target-standard-event-handler arg0 arg1 arg2 arg3)
        )
      )
    )
  :exit
  target-exit
  :code
  (behavior ()
    (set! (-> self control unknown-surface00) *walk-no-turn-mods*)
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (while (< (- (-> *display* base-frame-counter) (-> self state-time)) 15)
      (ja-channel-push! 1 30)
      (let ((a0-2 (-> self skel root-channel 0)))
        (set! (-> a0-2 frame-group) (the-as art-joint-anim (-> self draw art-group data 112)))
        (set! (-> a0-2 param 0)
              (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 112)) data 0 length) -1))
              )
        (set! (-> a0-2 param 1) 1.0)
        (set! (-> a0-2 frame-num) 0.0)
        (joint-control-channel-group! a0-2 (the-as art-joint-anim (-> self draw art-group data 112)) num-func-seek!)
        )
      (until (ja-done? 0)
        (TODO-RENAME-9 (-> self align))
        (TODO-RENAME-10 (-> self align) 4 (the-as float 1.0) (the-as float 1.0) (the-as float 1.0))
        (send-event *camera* 'joystick (-> (new 'static 'array int32 1 0) 0) (-> (new 'static 'array int32 1 0) 0))
        (suspend)
        (let ((a0-6 (-> self skel root-channel 0)))
          (set! (-> a0-6 param 0) (the float (+ (-> a0-6 frame-group data 0 length) -1)))
          (set! (-> a0-6 param 1) 1.0)
          (joint-control-channel-group-eval! a0-6 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      (let ((gp-0 (-> *display* base-frame-counter)))
        (until (>= (- (-> *display* base-frame-counter) gp-0) 90)
          (suspend)
          (let ((s5-0 (-> self skel root-channel 0)))
            (set! (-> s5-0 param 0) (ja-aframe (the-as float 19.0) 0))
            (set! (-> s5-0 param 1) 0.05)
            (joint-control-channel-group-eval! s5-0 (the-as art-joint-anim #f) num-func-seek!)
            )
          (suspend)
          )
        )
      (ja-channel-push! 1 90)
      (let ((gp-1 (-> self skel root-channel 0)))
        (set! (-> gp-1 frame-group) (the-as art-joint-anim (-> self draw art-group data 36)))
        (set! (-> gp-1 param 0)
              (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 36)) data 0 length) -1))
              )
        (set! (-> gp-1 param 1) 1.0)
        (set! (-> gp-1 frame-num) (ja-aframe (the-as float 40.0) 0))
        (joint-control-channel-group! gp-1 (the-as art-joint-anim (-> self draw art-group data 36)) num-func-seek!)
        )
      (until (ja-done? 0)
        (suspend)
        (let ((a0-13 (-> self skel root-channel 0)))
          (set! (-> a0-13 param 0) (the float (+ (-> a0-13 frame-group data 0 length) -1)))
          (set! (-> a0-13 param 1) 1.0)
          (joint-control-channel-group-eval! a0-13 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      (let ((a0-15 (-> self skel root-channel 0)))
        (set! (-> a0-15 frame-group) (the-as art-joint-anim (-> self draw art-group data 37)))
        (set! (-> a0-15 param 0)
              (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 37)) data 0 length) -1))
              )
        (set! (-> a0-15 param 1) 1.0)
        (set! (-> a0-15 frame-num) 0.0)
        (joint-control-channel-group! a0-15 (the-as art-joint-anim (-> self draw art-group data 37)) num-func-seek!)
        )
      (until (ja-done? 0)
        (suspend)
        (let ((a0-16 (-> self skel root-channel 0)))
          (set! (-> a0-16 param 0) (the float (+ (-> a0-16 frame-group data 0 length) -1)))
          (set! (-> a0-16 param 1) 1.0)
          (joint-control-channel-group-eval! a0-16 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      )
    (go target-stance)
    (none)
    )
  :post
  target-no-stick-post
  )

;; failed to figure out what this is:
(defstate target-stance-ambient (target)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (case arg2
      (('movie)
       (go target-stance)
       )
      (else
        (target-standard-event-handler arg0 arg1 arg2 arg3)
        )
      )
    )
  :enter
  (behavior ()
    (set! (-> self neck flex-blend) 0.0)
    ((-> target-stance enter))
    (let ((v1-2 (rand-vu-int-count 4)))
      (cond
        ((zero? v1-2)
         (set! (-> self control unknown-uint20)
               (the-as uint (new 'static 'spool-anim :name "eichar-ambient-1" :index #xe7 :parts 1 :command-list '()))
               )
         )
        ((= v1-2 1)
         (set! (-> self control unknown-uint20)
               (the-as uint (new 'static 'spool-anim :name "eichar-ambient-2" :index #xe8 :parts 1 :command-list '()))
               )
         )
        ((= v1-2 2)
         (set! (-> self control unknown-uint20)
               (the-as uint (new 'static 'spool-anim :name "eichar-ambient-3" :index #xe9 :parts 1 :command-list '()))
               )
         )
        (else
          (set! (-> self control unknown-uint20)
                (the-as uint (new 'static 'spool-anim :name "eichar-ambient-4" :index #xea :parts 1 :command-list '()))
                )
          )
        )
      )
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (none)
    )
  :exit
  (behavior ()
    (let ((a0-0 (-> self control unknown-spoolanim00)))
      (when a0-0
        (ja-abort-spooled-anim a0-0 (the-as art-joint-anim #f) -1)
        (ja-channel-set! 1)
        (let ((gp-0 (-> self skel root-channel 0)))
          (joint-control-channel-group-eval!
            gp-0
            (the-as art-joint-anim (-> self draw art-group data 5))
            num-func-identity
            )
          (set! (-> gp-0 frame-num) 0.0)
          )
        )
      )
    ((-> target-stance exit))
    (target-exit)
    (none)
    )
  :trans
  (behavior ()
    (spool-push *art-control* (-> self control unknown-spoolanim00 name) 0 self (the-as float -99.0))
    (if (or (logtest? (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-abs 0)
                      (pad-buttons start l1 r1 triangle circle x square)
                      )
            *progress-process*
            )
        (go target-stance)
        )
    (none)
    )
  :code
  (behavior ()
    (while (let ((v1-13 (file-status *art-control* (-> self control unknown-spoolanim00 name) 0)))
             (not (or (= v1-13 'locked) (= v1-13 'active)))
             )
      (suspend)
      (let ((a0-0 (-> self skel root-channel 0)))
        (set! (-> a0-0 param 0) 1.0)
        (joint-control-channel-group-eval! a0-0 (the-as art-joint-anim #f) num-func-loop!)
        )
      (let ((a0-1 (-> self skel root-channel 1)))
        (set! (-> a0-1 param 0) 0.0)
        (joint-control-channel-group-eval! a0-1 (the-as art-joint-anim #f) num-func-chan)
        )
      (let ((a0-2 (-> self skel root-channel 2)))
        (set! (-> a0-2 param 0) 0.0)
        (joint-control-channel-group-eval! a0-2 (the-as art-joint-anim #f) num-func-chan)
        )
      )
    (ja-play-spooled-anim
      (-> self control unknown-spoolanim00)
      (the-as art-joint-anim (-> self draw art-group data 5))
      (the-as art-joint-anim (-> self draw art-group data 5))
      (the-as (function process-drawable symbol) (lambda () (!= (-> *cpad-list* cpads 0 stick0-speed) 0.0)))
      )
    (set! (-> self control unknown-uint20) (the-as uint #f))
    (go target-stance)
    (none)
    )
  :post
  (the-as (function none :behavior target) target-post)
  )

;; definition of type first-person-hud
(deftype first-person-hud (process)
  ((max-nb-of-particles int32          :offset-assert 112)
   (nb-of-particles     int32          :offset-assert 116)
   (particles           hud-particle 3 :offset-assert 120)
   (in-out-position     int32          :offset-assert 132)
   (sides-x-scale       float          :offset-assert 136)
   (sides-y-scale       float          :offset-assert 140)
   (x-offset            int32          :offset-assert 144)
   )
  :heap-base #x30
  :method-count-assert 15
  :size-assert         #x94
  :flag-assert         #xf00300094
  (:methods
    (dumb-15 (_type_) none 14)
    )
  (:states
    hud-coming-in
    hud-going-out
    hud-normal
    hud-waiting
    )
  )

;; definition for method 3 of type first-person-hud
(defmethod inspect first-person-hud ((obj first-person-hud))
  (let ((t9-0 (method-of-type process inspect)))
    (t9-0 obj)
    )
  (format #t "~T~Tmax-nb-of-particles: ~D~%" (-> obj max-nb-of-particles))
  (format #t "~T~Tnb-of-particles: ~D~%" (-> obj nb-of-particles))
  (format #t "~T~Tparticles[3] @ #x~X~%" (-> obj particles))
  (format #t "~T~Tin-out-position: ~D~%" (-> obj in-out-position))
  (format #t "~T~Tsides-x-scale: ~f~%" (-> obj sides-x-scale))
  (format #t "~T~Tsides-y-scale: ~f~%" (-> obj sides-y-scale))
  (format #t "~T~Tx-offset: ~D~%" (-> obj x-offset))
  obj
  )

;; definition for symbol *fp-hud-stack*, type pointer
(define *fp-hud-stack* (malloc 'global #x3800))

;; definition for method 10 of type first-person-hud
(defmethod deactivate first-person-hud ((obj first-person-hud))
  (dotimes (s5-0 (-> obj nb-of-particles))
    (kill-and-free-particles (-> obj particles s5-0 part))
    (set! (-> obj particles s5-0 part matrix) -1)
    )
  (enable-hud)
  (set! (-> *target* fp-hud) (the-as handle #f))
  ((the-as (function process none) (find-parent-method first-person-hud 10)) obj)
  (none)
  )

;; definition for function first-person-hud-init-by-other
;; INFO: Return type mismatch object vs none.
(defbehavior first-person-hud-init-by-other first-person-hud ()
  (logclear! (-> self mask) (process-mask pause))
  (set! (-> self nb-of-particles) 0)
  (set! (-> self max-nb-of-particles) 3)
  (set! (-> self in-out-position) 4096)
  (when (< (-> self nb-of-particles) (-> self max-nb-of-particles))
    (let ((gp-0 (-> self nb-of-particles)))
      (set! (-> self particles gp-0) (new 'static 'hud-particle))
      (set! (-> self particles gp-0 part) (create-launch-control (-> *part-group-id-table* 611) self))
      (set! (-> self particles gp-0 init-pos x) -320.0)
      (set! (-> self particles gp-0 init-pos y) 254.0)
      (set! (-> self particles gp-0 init-pos z) 15.0)
      (set! (-> self particles gp-0 part matrix) -1)
      )
    (+! (-> self nb-of-particles) 1)
    )
  (when (< (-> self nb-of-particles) (-> self max-nb-of-particles))
    (let ((gp-1 (-> self nb-of-particles)))
      (set! (-> self particles gp-1) (new 'static 'hud-particle))
      (set! (-> self particles gp-1 part) (create-launch-control (-> *part-group-id-table* 612) self))
      (set! (-> self particles gp-1 init-pos x) -320.0)
      (set! (-> self particles gp-1 init-pos y) 192.0)
      (set! (-> self particles gp-1 init-pos z) 15.0)
      (set! (-> self particles gp-1 part matrix) -1)
      )
    (+! (-> self nb-of-particles) 1)
    )
  (when (< (-> self nb-of-particles) (-> self max-nb-of-particles))
    (let ((gp-2 (-> self nb-of-particles)))
      (set! (-> self particles gp-2) (new 'static 'hud-particle))
      (set! (-> self particles gp-2 part) (create-launch-control (-> *part-group-id-table* 613) self))
      (set! (-> self particles gp-2 init-pos x) 256.0)
      (set! (-> self particles gp-2 init-pos y) 244.0)
      (set! (-> self particles gp-2 init-pos z) 15.0)
      (set! (-> self particles gp-2 part matrix) -1)
      )
    (+! (-> self nb-of-particles) 1)
    )
  (case (get-aspect-ratio)
    (('aspect4x3)
     (set! (-> self sides-x-scale) 3.5)
     (set! (-> self sides-y-scale) 13.0)
     (set! (-> self x-offset) 0)
     0
     )
    (('aspect16x9)
     (set! (-> self sides-x-scale) 2.8)
     (set! (-> self sides-y-scale) 9.75)
     (set! (-> self x-offset) 12)
     )
    )
  (set! (-> self event-hook) (-> hud-waiting event))
  (go hud-waiting)
  (none)
  )

;; definition for method 7 of type first-person-hud
;; INFO: Return type mismatch process vs first-person-hud.
(defmethod relocate first-person-hud ((obj first-person-hud) (arg0 int))
  (dotimes (v1-0 (-> obj nb-of-particles))
    (when (-> obj particles v1-0 part)
      (if (nonzero? (-> obj particles v1-0 part))
          (&+! (-> obj particles v1-0 part) arg0)
          )
      )
    )
  (the-as first-person-hud ((method-of-type process relocate) obj arg0))
  )

;; definition for method 14 of type first-person-hud
;; INFO: Return type mismatch int vs none.
(defmethod dumb-15 first-person-hud ((obj first-person-hud))
  (dotimes (s5-0 (-> obj nb-of-particles))
    (set! (-> obj particles s5-0 pos x) (+ -256.0 (-> obj particles s5-0 init-pos x)))
    (set! (-> obj particles s5-0 pos y)
          (* 0.5 (- (* (-> obj particles s5-0 init-pos y) (-> *video-parms* relative-y-scale))
                    (the float (-> *video-parms* screen-sy))
                    )
             )
          )
    (set! (-> obj particles s5-0 pos z) (-> obj particles s5-0 init-pos z))
    (if (> (-> obj particles s5-0 part matrix) 0)
        (set-vector!
          (sprite-get-user-hvdf (-> obj particles s5-0 part matrix))
          (the float (+ (the int (-> obj particles s5-0 pos x)) 2048))
          (the float (+ (the int (-> obj particles s5-0 pos y)) 2048))
          (- (-> *math-camera* hvdf-off z) (* 1024.0 (-> obj particles s5-0 pos z)))
          (-> *math-camera* hvdf-off w)
          )
        )
    (spawn (-> obj particles s5-0 part) *null-vector*)
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate hud-waiting (first-person-hud)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (case arg2
      (('go-away)
       (go hud-going-out)
       )
      )
    )
  :enter
  (behavior ()
    (disable-hud (the-as int (-> *hud-parts* power)))
    (none)
    )
  :code
  (behavior ()
    (while #t
      (dotimes (gp-0 (-> self nb-of-particles))
        (if (= (-> self particles gp-0 part matrix) -1)
            (set! (-> self particles gp-0 part matrix) (sprite-allocate-user-hvdf))
            )
        )
      (set-setting! *setting-control* self 'common-page 'set (the-as float (-> (new 'static 'array int32 1 0) 0)) 1)
      (suspend)
      (go hud-coming-in)
      (suspend)
      )
    (none)
    )
  )

;; failed to figure out what this is:
(defstate hud-coming-in (first-person-hud)
  :event
  (-> hud-waiting event)
  :code
  (behavior ()
    (while #t
      (set! (-> self in-out-position)
            (seekl (-> self in-out-position) 0 (the int (* 350.0 (-> *display* time-adjust-ratio))))
            )
      (if (zero? (-> self in-out-position))
          (go hud-normal)
          )
      (suspend)
      )
    (none)
    )
  :post
  (behavior ()
    (dumb-15 self)
    (none)
    )
  )

;; failed to figure out what this is:
(defstate hud-normal (first-person-hud)
  :event
  (-> hud-waiting event)
  :code
  (behavior ()
    (while #t
      (if (or (not *progress-process*)
              (= (-> *progress-process* 0 next-state name) 'progress-going-out)
              (= (-> *progress-process* 0 next-state name) 'progress-gone)
              )
          (set! (-> self in-out-position)
                (seekl (-> self in-out-position) 0 (the int (* 150.0 (-> *display* time-adjust-ratio))))
                )
          (set! (-> self in-out-position)
                (seekl (-> self in-out-position) 4096 (the int (* 200.0 (-> *display* time-adjust-ratio))))
                )
          )
      (suspend)
      )
    (none)
    )
  )

;; failed to figure out what this is:
(defstate hud-going-out (first-person-hud)
  :code
  (behavior ()
    (while #t
      (set! (-> self in-out-position)
            (seekl (-> self in-out-position) 4096 (the int (* 350.0 (-> *display* time-adjust-ratio))))
            )
      (if (= (-> self in-out-position) 4096)
          (deactivate self)
          )
      (suspend)
      )
    (none)
    )
  :post
  (behavior ()
    (dumb-15 self)
    (none)
    )
  )

;; definition for function part-first-person-hud-left-func
;; INFO: Return type mismatch int vs none.
(defun part-first-person-hud-left-func ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 matrix))
  (let ((s5-0 (handle->process (-> *target* fp-hud))))
    (when s5-0
      (let ((f30-0 (* 0.00024414062 (the float (-> (the-as first-person-hud s5-0) in-out-position)))))
        (if (or (-> *setting-control* current movie) (movie?))
            (set! f30-0 1.0)
            )
        (if (< 0.25 f30-0)
            (set! f30-0 1.0)
            (* 4.0 f30-0)
            )
        (set! (-> (the-as first-person-hud s5-0) particles 0 init-pos x)
              (the float (- 59 (-> (the-as first-person-hud s5-0) x-offset)))
              )
        (set! (-> arg2 vector 0 w) (* 4096.0 (+ (-> (the-as first-person-hud s5-0) sides-x-scale) (* 10.0 f30-0))))
        (set! (-> arg2 vector 1 w) (* 4096.0 (+ (-> (the-as first-person-hud s5-0) sides-y-scale) (* 10.0 f30-0))))
        )
      )
    )
  0
  (none)
  )

;; definition for function part-first-person-hud-right-func
;; INFO: Return type mismatch int vs none.
(defun part-first-person-hud-right-func ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 matrix))
  (let ((s5-0 (handle->process (-> *target* fp-hud))))
    (when s5-0
      (let ((f30-0 (* 0.00024414062 (the float (-> (the-as first-person-hud s5-0) in-out-position)))))
        (if (or (-> *setting-control* current movie) (movie?))
            (set! f30-0 1.0)
            )
        (if (< 0.25 f30-0)
            (set! f30-0 1.0)
            (* 4.0 f30-0)
            )
        (set! (-> (the-as first-person-hud s5-0) particles 1 init-pos x)
              (the float (+ (-> (the-as first-person-hud s5-0) x-offset) 452))
              )
        (set! (-> arg2 vector 0 w) (* 4096.0 (+ (-> (the-as first-person-hud s5-0) sides-x-scale) (* 10.0 f30-0))))
        (set! (-> arg2 vector 1 w) (* 4096.0 (+ (-> (the-as first-person-hud s5-0) sides-y-scale) (* 10.0 f30-0))))
        )
      )
    )
  0
  (none)
  )

;; definition for function part-first-person-hud-selector-func
;; INFO: Return type mismatch int vs none.
(defun part-first-person-hud-selector-func ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 matrix))
  (let ((v1-2 (handle->process (-> *target* fp-hud))))
    (when v1-2
      (let ((f30-0 (* 0.00024414062 (the float (-> (the-as first-person-hud v1-2) in-out-position)))))
        (if (or (-> *setting-control* current movie) (movie?))
            (set! f30-0 1.0)
            )
        (if (< 0.5 f30-0)
            (set! f30-0 1.0)
            (* 2.0 f30-0)
            )
        (set! (-> arg2 vector 2 w) (- 64.0 (* 64.0 f30-0)))
        )
      )
    )
  0
  (none)
  )

;; definition for function look-for-points-of-interest
;; ERROR: function was not converted to expressions. Cannot decompile.

;; failed to figure out what this is:
(defstate target-stance-look-around (target)
  :event
  target-standard-event-handler
  :enter
  (-> target-stance enter)
  :exit
  (-> target-stance exit)
  :trans
  (-> target-stance trans)
  :code
  (behavior ()
    (while (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
             (set! (-> a1-0 from) self)
             (set! (-> a1-0 num-params) 0)
             (set! (-> a1-0 message) 'dist-from-interp-src)
             (and (< (send-event-function *camera* a1-0) 4915.2)
                  (< (- (-> *display* base-frame-counter) (-> self state-time)) 21)
                  (zero? (ja-group-size))
                  )
             )
      (suspend)
      )
    (let ((v1-8 target-stance))
      (set! (-> self next-state) v1-8)
      (set! (-> self state) v1-8)
      )
    ((the-as (function none :behavior target) (-> target-stance code)))
    (none)
    )
  :post
  (the-as (function none :behavior target) target-post)
  )

;; failed to figure out what this is:
(defstate target-look-around (target)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (cond
      ((and (= arg2 'query) (= (-> arg3 param 0) 'mode))
       (-> self state name)
       )
      ((let ((v1-4 arg2))
         (= v1-4 'end-mode)
         )
       (go target-stance-look-around)
       )
      ((-> self control unknown-symbol30)
       (target-dangerous-event-handler arg0 arg1 arg2 arg3)
       )
      (else
        (target-standard-event-handler arg0 arg1 arg2 arg3)
        )
      )
    )
  :enter
  (behavior ()
    (set! (-> self cam-user-mode) 'look-around)
    (set! (-> self control unknown-surface00) *duck-mods*)
    (logior! (-> self state-flags) 512)
    (send-event *camera* 'blend-from-as-fixed)
    (send-event *camera* 'no-intro)
    (camera-change-to (the-as string 'cam-eye) 60 #f)
    (let ((a0-5 (handle->process (-> self fp-hud))))
      (if a0-5
          (deactivate a0-5)
          )
      )
    (let ((gp-0 (get-process *default-dead-pool* first-person-hud #x4000)))
      (set! (-> self fp-hud)
            (ppointer->handle
              (when gp-0
                (let ((t9-5 (method-of-type first-person-hud activate)))
                  (t9-5 (the-as first-person-hud gp-0) *dproc* 'first-person-hud (&+ *fp-hud-stack* #x3800))
                  )
                (run-now-in-process gp-0 first-person-hud-init-by-other)
                (-> gp-0 ppointer)
                )
              )
            )
      )
    (none)
    )
  :exit
  (behavior ()
    (let ((a0-1 (handle->process (-> self fp-hud))))
      (if a0-1
          (send-event a0-1 'go-away)
          )
      )
    (set! (-> self cam-user-mode) 'normal)
    (target-exit)
    (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-2 from) self)
      (set! (-> a1-2 num-params) 1)
      (set! (-> a1-2 message) 'query-state)
      (set! (-> a1-2 param 0) (the-as uint cam-eye))
      (when (send-event-function *camera* a1-2)
        (send-event *camera* 'no-intro)
        (send-event *camera* 'force-blend 60)
        (send-event *camera* 'clear-entity)
        (camera-change-to (the-as string 'base) 60 #f)
        )
      )
    (none)
    )
  :trans
  (behavior ()
    (local-vars (sv-48 vector))
    (rlet ((vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           )
      (init-vf0-vector)
      (when (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 0)
                                           (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 1)
                                           )
                                   (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 2)
                                   )
                           (pad-buttons r2 circle square)
                           )
                 (and (= (-> self fact-info-target eco-type) 1) (>= (-> self fact-info-target eco-level) 1.0))
                 (>= (- (-> *display* base-frame-counter) (-> self control unknown-dword82)) 150)
                 (not *pause-lock*)
                 )
        (let ((gp-1 (vector-float*!
                      (new-stack-vector0)
                      (-> *math-camera* inv-camera-rot vector 2)
                      (the-as float (-> *TARGET-bank* yellow-projectile-speed))
                      )
                    )
              (s5-1 (vector-float*! (new-stack-vector0) (-> *math-camera* inv-camera-rot vector 2) 8192.0))
              )
          (vector+float*! s5-1 s5-1 (-> *math-camera* inv-camera-rot vector 1) (the-as float -2048.0))
          (let ((s4-0 (get-process *default-dead-pool* projectile-yellow #x4000)))
            (when s4-0
              (let ((t9-2 (method-of-type projectile-yellow activate)))
                (t9-2 (the-as projectile-yellow s4-0) self 'projectile-yellow (the-as pointer #x70004000))
                )
              (let ((s3-0 run-function-in-process)
                    (s2-0 s4-0)
                    (s1-0 projectile-init-by-other)
                    (s0-0 (-> self entity))
                    )
                (set! sv-48 s5-1)
                (let ((v0-3 (camera-pos)))
                  (.mov.vf vf6 vf0 :mask #b1000)
                  (.lvf vf4 (&-> v0-3 quad))
                  )
                (.lvf vf5 (&-> s5-1 quad))
                (.add.vf vf6 vf4 vf5 :mask #b111)
                (.svf (&-> sv-48 quad) vf6)
                (let ((t1-0 (if (>= (-> self fact-info-target eco-level) (-> *FACT-bank* eco-level-max))
                                56
                                40
                                )
                            )
                      (t2-0 #f)
                      )
                  ((the-as (function object object object object object object object none) s3-0)
                   s2-0
                   s1-0
                   s0-0
                   sv-48
                   gp-1
                   t1-0
                   t2-0
                   )
                  )
                )
              (-> s4-0 ppointer)
              )
            )
          )
        (set! (-> self control unknown-dword82) (-> *display* base-frame-counter))
        )
      (when (logtest? (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 0)
                      (pad-buttons triangle)
                      )
        (logclear!
          (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-abs 0)
          (pad-buttons triangle)
          )
        (logclear!
          (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 0)
          (pad-buttons triangle)
          )
        (set! (-> self cam-user-mode) 'normal)
        )
      (none)
      )
    )
  :code
  (behavior ()
    (while (let ((f30-0 8192.0)
                 (a1-0 (new 'stack-no-clear 'event-message-block))
                 )
             (set! (-> a1-0 from) self)
             (set! (-> a1-0 num-params) 0)
             (set! (-> a1-0 message) 'dist-from-interp-dest)
             (< f30-0 (send-event-function *camera* a1-0))
             )
      (if (!= (-> self cam-user-mode) 'look-around)
          (go target-stance)
          )
      (suspend)
      )
    (ja-channel-set! 0)
    (set! (-> self control transv quad) (the-as uint128 0))
    (while #t
      (if (!= (-> self cam-user-mode) 'look-around)
          (go target-stance-look-around)
          )
      (suspend)
      )
    (none)
    )
  :post
  target-no-move-post
  )

;; failed to figure out what this is:
(defstate target-billy-game (target)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (cond
      ((and (= arg2 'query) (= (-> arg3 param 0) 'mode))
       (-> self state name)
       )
      ((let ((v1-4 arg2))
         (= v1-4 'end-mode)
         )
       (go target-stance)
       )
      (else
        (target-standard-event-handler arg0 arg1 arg2 arg3)
        )
      )
    )
  :enter
  (behavior ()
    (set! (-> self neck flex-blend) 0.0)
    (set! (-> self control unknown-surface00) *duck-mods*)
    (logior! (-> self state-flags) 512)
    (send-event *camera* 'blend-from-as-fixed)
    (send-event *camera* 'clear-entity)
    (send-event *camera* 'no-intro)
    (camera-change-to (the-as string 'cam-billy) 0 #f)
    (let ((a0-6 (handle->process (-> self fp-hud))))
      (if a0-6
          (deactivate a0-6)
          )
      )
    (let ((gp-0 (get-process *default-dead-pool* first-person-hud #x4000)))
      (set! (-> self fp-hud)
            (ppointer->handle
              (when gp-0
                (let ((t9-6 (method-of-type first-person-hud activate)))
                  (t9-6 (the-as first-person-hud gp-0) *dproc* 'first-person-hud (&+ *fp-hud-stack* #x3800))
                  )
                (run-now-in-process gp-0 first-person-hud-init-by-other)
                (-> gp-0 ppointer)
                )
              )
            )
      )
    (none)
    )
  :exit
  (behavior ()
    (let ((a0-1 (handle->process (-> self fp-hud))))
      (if a0-1
          (send-event a0-1 'go-away)
          )
      )
    (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-2 from) self)
      (set! (-> a1-2 num-params) 1)
      (set! (-> a1-2 message) 'query-state)
      (set! (-> a1-2 param 0) (the-as uint cam-billy))
      (when (send-event-function *camera* a1-2)
        (send-event *camera* 'no-intro)
        (send-event *camera* 'force-blend 0)
        (camera-change-to (the-as string 'base) 0 #f)
        )
      )
    (target-exit)
    (none)
    )
  :trans
  (behavior ()
    (local-vars (sv-48 vector))
    (rlet ((vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           )
      (init-vf0-vector)
      (when (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 0)
                                           (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 1)
                                           )
                                   (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 2)
                                   )
                           (pad-buttons r2 circle square)
                           )
                 (>= (- (-> *display* base-frame-counter) (-> self control unknown-dword82)) 135)
                 (and (= (-> self fact-info-target eco-type) 1) (>= (-> self fact-info-target eco-level) 1.0))
                 (not *pause-lock*)
                 )
        (let ((gp-1 (vector-float*!
                      (new-stack-vector0)
                      (-> *math-camera* inv-camera-rot vector 2)
                      (the-as float (-> *TARGET-bank* yellow-projectile-speed))
                      )
                    )
              (s5-1 (vector-float*! (new-stack-vector0) (-> *math-camera* inv-camera-rot vector 2) 8192.0))
              )
          (vector+float*! s5-1 s5-1 (-> *math-camera* inv-camera-rot vector 1) (the-as float -2048.0))
          (let ((s4-0 (get-process *default-dead-pool* projectile-yellow #x4000)))
            (when s4-0
              (let ((t9-2 (method-of-type projectile-yellow activate)))
                (t9-2 (the-as projectile-yellow s4-0) self 'projectile-yellow (the-as pointer #x70004000))
                )
              (let ((s3-0 run-function-in-process)
                    (s2-0 s4-0)
                    (s1-0 projectile-init-by-other)
                    (s0-0 (-> self entity))
                    )
                (set! sv-48 s5-1)
                (let ((v0-4 (camera-pos)))
                  (.mov.vf vf6 vf0 :mask #b1000)
                  (.lvf vf4 (&-> v0-4 quad))
                  )
                (.lvf vf5 (&-> s5-1 quad))
                (.add.vf vf6 vf4 vf5 :mask #b111)
                (.svf (&-> sv-48 quad) vf6)
                (let ((t1-0 (if (>= (-> self fact-info-target eco-level) (-> *FACT-bank* eco-level-max))
                                120
                                104
                                )
                            )
                      (t2-0 #f)
                      )
                  ((the-as (function object object object object object object object none) s3-0)
                   s2-0
                   s1-0
                   s0-0
                   sv-48
                   gp-1
                   t1-0
                   t2-0
                   )
                  )
                )
              (-> s4-0 ppointer)
              )
            )
          )
        (set! (-> self control unknown-dword82) (-> *display* base-frame-counter))
        )
      (none)
      )
    )
  :code
  (behavior ()
    (ja-channel-set! 0)
    (set! (-> self control transv quad) (the-as uint128 0))
    (anim-loop)
    (none)
    )
  :post
  target-no-move-post
  )

;; failed to figure out what this is:
(defstate target-grab (target)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (cond
      ((and (= arg2 'query) (= (-> arg3 param 0) 'mode))
       (-> self state name)
       )
      (else
        (case arg2
          (('end-mode)
           (go target-stance)
           )
          (('play-anim)
           (let ((v0-0 (the-as object (-> arg3 param 0))))
             (set! (-> self control unknown-uint20) (the-as uint v0-0))
             v0-0
             )
           )
          (('clone-anim)
           (go target-clone-anim (process->handle (the-as process (-> arg3 param 0))))
           )
          (('change-mode)
           (case (-> arg3 param 0)
             (('final-door)
              (go
                target-final-door
                (the-as basic (process->handle (the-as process (-> arg3 param 1))))
                (process->handle (the-as process (-> arg3 param 2)))
                )
              )
             )
           )
          (else
            (target-generic-event-handler arg0 arg1 arg2 arg3)
            )
          )
        )
      )
    )
  :enter
  (behavior ()
    (set! (-> self control unknown-surface00) *grab-mods*)
    (set! (-> self neck flex-blend) 0.0)
    (logior! (-> self state-flags) 272)
    (set! (-> self control unknown-uint20) (the-as uint 'stance))
    (none)
    )
  :exit
  (behavior ()
    (set! (-> self state-flags) (logand -17 (-> self state-flags)))
    (target-exit)
    (none)
    )
  :code
  (behavior ()
    (set-forward-vel (the-as float (-> (new 'static 'array int32 1 0) 0)))
    (let ((gp-0 0))
      (while (zero? (logand (-> self control status) 1))
        (target-falling-anim-trans)
        (+! gp-0 (- (-> *display* base-frame-counter) (-> *display* old-base-frame-counter)))
        (suspend)
        )
      (if (or (> gp-0 0) (let ((v1-11 (if (> (-> self skel active-channels) 0)
                                          (-> self skel root-channel 0 frame-group)
                                          )
                                      )
                               )
                           (or (= v1-11 (-> self draw art-group data 34))
                               (= v1-11 (-> self draw art-group data 38))
                               (= v1-11 (-> self draw art-group data 42))
                               (= v1-11 (-> self draw art-group data 43))
                               (= v1-11 (-> self draw art-group data 41))
                               )
                           )
              )
          (target-hit-ground-anim #f)
          )
      )
    (-> self control unknown-spoolanim00)
    (while #t
      (let ((gp-1 (-> self control unknown-spoolanim00)))
        (case gp-1
          (('stance)
           (cond
             ((or (and (= (if (> (-> self skel active-channels) 0)
                              (-> self skel root-channel 0 frame-group)
                              )
                          (-> self draw art-group data 23)
                          )
                       (< 0.5 (-> self skel root-channel 6 frame-interp))
                       )
                  (let ((v1-32 (if (> (-> self skel active-channels) 0)
                                   (-> self skel root-channel 0 frame-group)
                                   )
                               )
                        )
                    (or (= v1-32 (-> self draw art-group data 28))
                        (= v1-32 (-> self draw art-group data 29))
                        (= v1-32 (-> self draw art-group data 54))
                        (= v1-32 (-> self draw art-group data 55))
                        )
                    )
                  )
              (ja-channel-push! 1 45)
              (let ((a0-39 (-> self skel root-channel 0)))
                (set! (-> a0-39 frame-group) (the-as art-joint-anim (-> self draw art-group data 4)))
                (set! (-> a0-39 param 0)
                      (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 4)) data 0 length) -1))
                      )
                (set! (-> a0-39 param 1) 1.0)
                (set! (-> a0-39 frame-num) 0.0)
                (joint-control-channel-group! a0-39 (the-as art-joint-anim (-> self draw art-group data 4)) num-func-seek!)
                )
              (until (ja-done? 0)
                (suspend)
                (let ((a0-40 (-> self skel root-channel 0)))
                  (set! (-> a0-40 param 0) (the float (+ (-> a0-40 frame-group data 0 length) -1)))
                  (set! (-> a0-40 param 1) 1.0)
                  (joint-control-channel-group-eval! a0-40 (the-as art-joint-anim #f) num-func-seek!)
                  )
                )
              (let ((a0-42 (-> self skel root-channel 0)))
                (set! (-> a0-42 frame-group) (the-as art-joint-anim (-> self draw art-group data 3)))
                (set! (-> a0-42 param 0)
                      (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 3)) data 0 length) -1))
                      )
                (set! (-> a0-42 param 1) 1.0)
                (set! (-> a0-42 frame-num) 0.0)
                (joint-control-channel-group! a0-42 (the-as art-joint-anim (-> self draw art-group data 3)) num-func-seek!)
                )
              (until (ja-done? 0)
                (suspend)
                (let ((a0-43 (-> self skel root-channel 0)))
                  (set! (-> a0-43 param 0) (the float (+ (-> a0-43 frame-group data 0 length) -1)))
                  (set! (-> a0-43 param 1) 1.0)
                  (joint-control-channel-group-eval! a0-43 (the-as art-joint-anim #f) num-func-seek!)
                  )
                )
              (ja-channel-push! 1 45)
              )
             ((let ((v1-87 (if (> (-> self skel active-channels) 0)
                               (-> self skel root-channel 0 frame-group)
                               )
                           )
                    )
                (and (or (= v1-87 (-> self draw art-group data 39)) (= v1-87 (-> self draw art-group data 35)))
                     (not (ja-max? 0))
                     )
                )
              (let ((a0-54 (-> self skel root-channel 0)))
                (set! (-> a0-54 param 0) (the float (+ (-> a0-54 frame-group data 0 length) -1)))
                (set! (-> a0-54 param 1) 1.0)
                (joint-control-channel-group! a0-54 (the-as art-joint-anim #f) num-func-seek!)
                )
              (while (not (ja-done? 0))
                (suspend)
                (ja-eval)
                )
              (ja-channel-push! 1 22)
              )
             ((not (and (= (if (> (-> self skel active-channels) 0)
                               (-> self skel root-channel 0 frame-group)
                               )
                           (-> self draw art-group data 5)
                           )
                        (= (ja-group-size) 1)
                        )
                   )
              (ja-channel-push! 1 22)
              )
             )
           (while #t
             (let ((a0-63 (-> self skel root-channel 0)))
               (set! (-> a0-63 frame-group) (the-as art-joint-anim (-> self draw art-group data 5)))
               (set! (-> a0-63 param 0)
                     (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 5)) data 0 length) -1))
                     )
               (set! (-> a0-63 param 1) 1.0)
               (set! (-> a0-63 frame-num) 0.0)
               (joint-control-channel-group! a0-63 (the-as art-joint-anim (-> self draw art-group data 5)) num-func-seek!)
               )
             (until (ja-done? 0)
               (if (!= gp-1 (-> self control unknown-spoolanim00))
                   (goto cfg-94)
                   )
               (suspend)
               (let ((a0-64 (-> self skel root-channel 0)))
                 (set! (-> a0-64 param 0) (the float (+ (-> a0-64 frame-group data 0 length) -1)))
                 (set! (-> a0-64 param 1) 1.0)
                 (joint-control-channel-group-eval! a0-64 (the-as art-joint-anim #f) num-func-seek!)
                 )
               )
             )
           )
          (('shock-in)
           (ja-channel-push! 1 60)
           (let ((s5-0 (-> self skel root-channel 0)))
             (set! (-> s5-0 frame-group) (the-as art-joint-anim (-> self draw art-group data 88)))
             (set! (-> s5-0 param 0) (ja-aframe (the-as float 18.0) 0))
             (set! (-> s5-0 param 1) 1.0)
             (set! (-> s5-0 frame-num) 0.0)
             (joint-control-channel-group! s5-0 (the-as art-joint-anim (-> self draw art-group data 88)) num-func-seek!)
             )
           (until (ja-done? 0)
             (if (!= gp-1 (-> self control unknown-spoolanim00))
                 (goto cfg-94)
                 )
             (suspend)
             (let ((s5-1 (-> self skel root-channel 0)))
               (set! (-> s5-1 param 0) (ja-aframe (the-as float 18.0) 0))
               (set! (-> s5-1 param 1) 1.0)
               (joint-control-channel-group-eval! s5-1 (the-as art-joint-anim #f) num-func-seek!)
               )
             )
           (while #t
             (if (!= gp-1 (-> self control unknown-spoolanim00))
                 (goto cfg-94)
                 )
             (suspend)
             )
           )
          (('shock-out)
           (if (not (= (if (> (-> self skel active-channels) 0)
                           (-> self skel root-channel 0 frame-group)
                           )
                       (-> self draw art-group data 88)
                       )
                    )
               (ja-channel-push! 1 60)
               )
           (let ((s5-2 (-> self skel root-channel 0)))
             (set! (-> s5-2 frame-group) (the-as art-joint-anim (-> self draw art-group data 88)))
             (set! (-> s5-2 param 0)
                   (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 88)) data 0 length) -1))
                   )
             (set! (-> s5-2 param 1) 1.0)
             (set! (-> s5-2 frame-num) (ja-aframe (the-as float 18.0) 0))
             (joint-control-channel-group! s5-2 (the-as art-joint-anim (-> self draw art-group data 88)) num-func-seek!)
             )
           (until (ja-done? 0)
             (if (!= gp-1 (-> self control unknown-spoolanim00))
                 (goto cfg-94)
                 )
             (suspend)
             (let ((a0-82 (-> self skel root-channel 0)))
               (set! (-> a0-82 param 0) (the float (+ (-> a0-82 frame-group data 0 length) -1)))
               (set! (-> a0-82 param 1) 1.0)
               (joint-control-channel-group-eval! a0-82 (the-as art-joint-anim #f) num-func-seek!)
               )
             )
           (set! (-> self control unknown-uint20) (the-as uint 'stance))
           )
          )
        )
      (label cfg-94)
      )
    (none)
    )
  :post
  (behavior ()
    (if (logtest? (-> self control status) 1)
        (set! (-> self control transv quad) (the-as uint128 0))
        )
    (target-no-stick-post)
    (none)
    )
  )

;; failed to figure out what this is:
(defstate target-pole-cycle (target)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (if (and (= arg2 'query) (= (-> arg3 param 0) 'mode))
        (-> self state name)
        (target-standard-event-handler arg0 arg1 arg2 arg3)
        )
    )
  :enter
  (behavior ((arg0 handle))
    (set! (-> self control unknown-handle10) arg0)
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (set! (-> self control unknown-surface00) *pole-mods*)
    (logior! (-> self control root-prim prim-core action) (collide-action ca-8))
    (target-collide-set! 'pole (the-as float (-> (new 'static 'array int32 1 0) 0)))
    (set! (-> self control unknown-vector102 quad) (-> self control transv quad))
    (set! (-> self control transv quad) (the-as uint128 0))
    (send-event *camera* 'ease-in)
    (set! (-> self control unknown-int21) (the-as int #f))
    (none)
    )
  :exit
  (behavior ()
    (target-collide-set! 'normal (the-as float (-> (new 'static 'array int32 1 0) 0)))
    (logclear! (-> self control root-prim prim-core action) (collide-action ca-8))
    (set! (-> self control unknown-handle10) (the-as handle #f))
    (none)
    )
  :trans
  (behavior ()
    (when (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 0)
                                         (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 1)
                                         )
                                 (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 2)
                                 )
                         (pad-buttons x)
                         )
               (zero? (logand (-> self state-flags) 2048))
               (>= (- (-> *display* base-frame-counter) (-> self state-time)) 30)
               )
      (set! (-> self control transv quad) (the-as uint128 0))
      (cond
        ((< 44.0 (ja-aframe-num 0))
         (set-forward-vel (the-as float -49152.0))
         (let ((gp-0 (new-stack-vector0)))
           (let ((f0-2 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
             0.0
             (vector-! gp-0 (-> self control transv) (vector-float*! gp-0 (-> self control dynam gravity-normal) f0-2))
             )
           (let* ((f0-3 (vector-length gp-0))
                  (f1-1 f0-3)
                  (f2-0 -81920.0)
                  )
             (vector+!
               (-> self control transv)
               (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-0)
               (vector-float*! gp-0 gp-0 (/ f0-3 f1-1))
               )
             )
           )
         (set! (-> self control status) (logand -8 (-> self control status)))
         (go target-falling 'target-pole-cycle)
         )
        ((>= (ja-aframe-num 0) 14.0)
         (remove-exit)
         (go target-pole-flip-up 28672.0 28672.0 (* 1024.0 (- 26.0 (ja-aframe-num 0))))
         )
        (else
          (remove-exit)
          (go target-pole-flip-forward (the-as float 14336.0) (the-as float 14336.0) (the-as float 57344.0))
          )
        )
      )
    (none)
    )
  :code
  (behavior ((arg0 handle))
    (target-compute-pole)
    (set! (-> self control unknown-uint20)
          (the-as uint (vector-dot
                         (-> self control unknown-vector100)
                         (vector-normalize! (-> self control unknown-vector102) (the-as float 1.0))
                         )
                  )
          )
    (cond
      ((= (if (> (-> self skel active-channels) 0)
              (-> self skel root-channel 0 frame-group)
              )
          (-> self draw art-group data 83)
          )
       (while (not (-> self control unknown-int21))
         (let ((a0-6 (-> self skel root-channel 0)))
           (set! (-> a0-6 param 0) (the float (+ (-> a0-6 frame-group data 0 length) -1)))
           (set! (-> a0-6 param 1) 1.0)
           (joint-control-channel-group-eval! a0-6 (the-as art-joint-anim #f) num-func-seek!)
           )
         (suspend)
         )
       (let ((gp-1 (-> self skel root-channel 0)))
         (set! (-> gp-1 num-func) num-func-identity)
         (set! (-> gp-1 frame-num) (ja-aframe (the-as float 37.0) 0))
         )
       )
      (else
        (while (not (-> self control unknown-int21))
          (suspend)
          )
        (suspend)
        (ja-channel-push! 1 45)
        )
      )
    (let ((a0-9 (-> self skel root-channel 0)))
      (set! (-> a0-9 frame-group) (the-as art-joint-anim (-> self draw art-group data 80)))
      (set! (-> a0-9 param 0)
            (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 80)) data 0 length) -1))
            )
      (set! (-> a0-9 param 1) 1.0)
      (set! (-> a0-9 frame-num) 0.0)
      (joint-control-channel-group! a0-9 (the-as art-joint-anim (-> self draw art-group data 80)) num-func-seek!)
      )
    (until (ja-done? 0)
      (suspend)
      (let ((a0-10 (-> self skel root-channel 0)))
        (set! (-> a0-10 param 0) (the float (+ (-> a0-10 frame-group data 0 length) -1)))
        (set! (-> a0-10 param 1) 1.0)
        (joint-control-channel-group-eval! a0-10 (the-as art-joint-anim #f) num-func-seek!)
        )
      )
    (while #t
      (set! (-> self anim-seed) (the-as uint (if (rand-vu-percent? (the-as float 0.1))
                                                 0
                                                 1
                                                 )
                                        )
            )
      (let ((a0-13 (-> self skel root-channel 0)))
        (set! (-> a0-13 frame-group) (the-as art-joint-anim (-> self draw art-group data 80)))
        (set! (-> a0-13 param 0)
              (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 80)) data 0 length) -1))
              )
        (set! (-> a0-13 param 1) 1.0)
        (set! (-> a0-13 frame-num) 0.0)
        (joint-control-channel-group! a0-13 (the-as art-joint-anim (-> self draw art-group data 80)) num-func-seek!)
        )
      (until (ja-done? 0)
        (suspend)
        (let ((a0-14 (-> self skel root-channel 0)))
          (set! (-> a0-14 param 0) (the float (+ (-> a0-14 frame-group data 0 length) -1)))
          (set! (-> a0-14 param 1) 1.0)
          (joint-control-channel-group-eval! a0-14 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      )
    (none)
    )
  :post
  target-no-move-post
  )

;; failed to figure out what this is:
(defstate target-pole-flip-up (target)
  :event
  target-standard-event-handler
  :exit
  (-> target-pole-cycle exit)
  :code
  (behavior ((arg0 object) (arg1 object) (arg2 float))
    (let ((s3-0 (-> self skel root-channel 0)))
      (set! (-> s3-0 frame-group) (the-as art-joint-anim (-> self draw art-group data 81)))
      (set! (-> s3-0 param 0)
            (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 81)) data 0 length) -1))
            )
      (set! (-> s3-0 param 1) 1.0)
      (set! (-> s3-0 frame-num) (ja-aframe (+ 1.0 (fmin 17.0 (ja-aframe-num 0))) 0))
      (joint-control-channel-group! s3-0 (the-as art-joint-anim (-> self draw art-group data 81)) num-func-seek!)
      )
    (until (ja-done? 0)
      (suspend)
      (let ((a0-4 (-> self skel root-channel 0)))
        (set! (-> a0-4 param 0) (the float (+ (-> a0-4 frame-group data 0 length) -1)))
        (set! (-> a0-4 param 1) 1.0)
        (joint-control-channel-group-eval! a0-4 (the-as art-joint-anim #f) num-func-seek!)
        )
      )
    (set-forward-vel arg2)
    (go target-pole-flip-up-jump (the-as float arg0) (the-as float arg1))
    (none)
    )
  :post
  target-no-move-post
  )

;; failed to figure out what this is:
(defstate target-pole-flip-up-jump (target)
  :event
  target-standard-event-handler
  :enter
  (-> target-jump-forward enter)
  :exit
  target-exit
  :trans
  (behavior ()
    ((-> target-jump-forward trans))
    (vector-flatten! (-> self control transv) (-> self control transv) (-> self control unknown-vector100))
    (none)
    )
  :code
  (behavior ((arg0 float) (arg1 float))
    (sound-play-by-name (static-sound-name "jump") (new-sound-id) 1024 0 0 1 #t)
    (send-event *camera* 'damp-up)
    (let ((gp-1 (-> self skel root-channel 0)))
      (joint-control-channel-group-eval!
        gp-1
        (the-as art-joint-anim (-> self draw art-group data 83))
        num-func-identity
        )
      (set! (-> gp-1 frame-num) 0.0)
      )
    (let ((f0-1 (target-height-above-ground))
          (f1-1 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
          )
      (while (not (and (< (fabs (/ f0-1 (* 0.0033333334 f1-1))) 40.0) (and (< f1-1 0.0) (ja-min? 0))))
        (suspend)
        (let ((a0-5 (-> self skel root-channel 0)))
          (set! (-> a0-5 param 0) 1.0)
          (joint-control-channel-group-eval! a0-5 (the-as art-joint-anim #f) num-func-loop!)
          )
        (set! f0-1 (target-height-above-ground))
        (set! f1-1 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
        )
      )
    (ja-channel-push! 1 75)
    (let ((a0-9 (-> self skel root-channel 0)))
      (set! (-> a0-9 frame-group) (the-as art-joint-anim (-> self draw art-group data 38)))
      (set! (-> a0-9 param 0) 1.0)
      (set! (-> a0-9 frame-num) 0.0)
      (joint-control-channel-group! a0-9 (the-as art-joint-anim (-> self draw art-group data 38)) num-func-loop!)
      )
    (while #t
      (suspend)
      (let ((a0-10 (-> self skel root-channel 0)))
        (set! (-> a0-10 frame-group) (the-as art-joint-anim (-> self draw art-group data 38)))
        (set! (-> a0-10 param 0) 1.0)
        (joint-control-channel-group-eval!
          a0-10
          (the-as art-joint-anim (-> self draw art-group data 38))
          num-func-loop!
          )
        )
      )
    (none)
    )
  :post
  (the-as (function none :behavior target) target-post)
  )

;; failed to figure out what this is:
(defstate target-pole-flip-forward (target)
  :event
  target-standard-event-handler
  :exit
  (-> target-pole-cycle exit)
  :code
  (behavior ((arg0 float) (arg1 float) (arg2 float))
    (let ((s3-0 (-> self skel root-channel 0)))
      (set! (-> s3-0 frame-group) (the-as art-joint-anim (-> self draw art-group data 82)))
      (set! (-> s3-0 param 0) (ja-aframe (the-as float 16.0) 0))
      (set! (-> s3-0 param 1) 1.0)
      (set! (-> s3-0 frame-num) (ja-aframe (+ 1.0 (ja-aframe-num 0)) 0))
      (joint-control-channel-group! s3-0 (the-as art-joint-anim (-> self draw art-group data 82)) num-func-seek!)
      )
    (until (ja-done? 0)
      (suspend)
      (let ((s3-1 (-> self skel root-channel 0)))
        (set! (-> s3-1 param 0) (ja-aframe (the-as float 16.0) 0))
        (set! (-> s3-1 param 1) 1.0)
        (joint-control-channel-group-eval! s3-1 (the-as art-joint-anim #f) num-func-seek!)
        )
      )
    (set-forward-vel arg2)
    (go target-pole-flip-forward-jump arg0 arg1)
    (none)
    )
  :post
  target-no-move-post
  )

;; failed to figure out what this is:
(defstate target-pole-flip-forward-jump (target)
  :event
  target-standard-event-handler
  :enter
  (behavior ((arg0 float) (arg1 float))
    ((-> target-jump enter) arg0 arg1 (the-as surface #f))
    (set! (-> self control unknown-surface00) *forward-pole-jump-mods*)
    (none)
    )
  :exit
  target-exit
  :trans
  (behavior ()
    ((-> target-jump-forward trans))
    (vector-flatten! (-> self control transv) (-> self control transv) (-> self control unknown-vector100))
    (none)
    )
  :code
  (behavior ((arg0 float) (arg1 float))
    (sound-play-by-name (static-sound-name "jump") (new-sound-id) 1024 0 0 1 #t)
    (until (ja-done? 0)
      (suspend)
      (let ((a0-2 (-> self skel root-channel 0)))
        (set! (-> a0-2 param 0) (the float (+ (-> a0-2 frame-group data 0 length) -1)))
        (set! (-> a0-2 param 1) 1.0)
        (joint-control-channel-group-eval! a0-2 (the-as art-joint-anim #f) num-func-seek!)
        )
      )
    ((the-as (function none :behavior target) (-> target-pole-flip-up-jump code)))
    (none)
    )
  :post
  (the-as (function none :behavior target) target-post)
  )

;; failed to figure out what this is:
(defstate target-edge-grab (target)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (case arg2
      (('end-mode)
       (go target-falling 'target-edge-grab)
       )
      (else
        (target-standard-event-handler arg0 arg1 arg2 arg3)
        )
      )
    )
  :enter
  (behavior ()
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (set! (-> self control unknown-surface00) *edge-grab-mods*)
    (set! (-> self control unknown-dword41) (-> *display* base-frame-counter))
    (logior! (-> self control root-prim prim-core action) (collide-action ca-3 ca-7))
    (set! (-> self control unknown-vector102 quad) (-> self control transv quad))
    (set! (-> self control transv quad) (the-as uint128 0))
    (send-event *camera* 'ease-in)
    (none)
    )
  :exit
  (behavior ()
    (when (logtest? (-> self control root-prim prim-core action) (collide-action ca-7))
      (logclear! (-> self control root-prim prim-core action) (collide-action ca-3 ca-7))
      (send-event *camera* 'damp-up)
      )
    (none)
    )
  :trans
  (behavior ()
    (when (and (>= (- (-> *display* base-frame-counter) (-> self state-time)) 60)
               (logtest? (logior (logior (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 0)
                                         (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 1)
                                         )
                                 (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 2)
                                 )
                         (pad-buttons x)
                         )
               (zero? (logand (-> self state-flags) 2048))
               )
      (cond
        ((or (< -0.2 (local-pad-angle))
             (= (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) stick0-speed) 0.0)
             )
         (let ((a1-2 (new 'stack-no-clear 'collide-using-spheres-params)))
           (set! (-> a1-2 spheres) (-> *collide-edge-work* world-player-leap-up-spheres))
           (set! (-> a1-2 num-spheres) (the-as uint 6))
           (set! (-> a1-2 collide-with) (-> self control root-prim collide-with))
           (set! (-> a1-2 proc) #f)
           (set! (-> a1-2 ignore-pat) (the-as uint 1))
           (set! (-> a1-2 solid-only) #t)
           (when (not (fill-and-probe-using-spheres *collide-cache* a1-2))
             (remove-exit)
             (go
               target-edge-grab-jump
               (-> *TARGET-bank* edge-grab-jump-height-min)
               (-> *TARGET-bank* edge-grab-jump-height-max)
               )
             )
           )
         )
        (else
          (remove-exit)
          (go target-edge-grab-off)
          )
        )
      )
    (none)
    )
  :code
  (behavior ()
    (target-compute-edge)
    (set! (-> self control unknown-uint20)
          (the-as uint (vector-dot
                         (-> self control unknown-vector100)
                         (vector-normalize! (-> self control unknown-vector102) (the-as float 1.0))
                         )
                  )
          )
    (while (< 0.0 (-> self control unknown-float110))
      (when (not (= (if (> (-> self skel active-channels) 0)
                        (-> self skel root-channel 0 frame-group)
                        )
                    (-> self draw art-group data 38)
                    )
                 )
        (ja-channel-push! 1 45)
        (let ((gp-1 (-> self skel root-channel 0)))
          (joint-control-channel-group-eval!
            gp-1
            (the-as art-joint-anim (-> self draw art-group data 38))
            num-func-identity
            )
          (set! (-> gp-1 frame-num) 0.0)
          )
        )
      (suspend)
      )
    (ja-channel-push! 1 45)
    (cond
      ((< (the-as float (-> self control unknown-uint20)) -0.3)
       (let ((gp-2 (-> self skel root-channel 0)))
         (joint-control-channel-group-eval!
           gp-2
           (the-as art-joint-anim (-> self draw art-group data 48))
           num-func-identity
           )
         (set! (-> gp-2 frame-num) 0.0)
         )
       )
      ((< 0.3 (the-as float (-> self control unknown-uint20)))
       (let ((gp-3 (-> self skel root-channel 0)))
         (joint-control-channel-group-eval!
           gp-3
           (the-as art-joint-anim (-> self draw art-group data 47))
           num-func-identity
           )
         (set! (-> gp-3 frame-num) 0.0)
         )
       )
      (else
        (let ((gp-4 (-> self skel root-channel 0)))
          (joint-control-channel-group-eval!
            gp-4
            (the-as art-joint-anim (-> self draw art-group data 46))
            num-func-identity
            )
          (set! (-> gp-4 frame-num) 0.0)
          )
        )
      )
    (until (ja-done? 0)
      (suspend)
      (let ((a0-11 (-> self skel root-channel 0)))
        (set! (-> a0-11 param 0) (the float (+ (-> a0-11 frame-group data 0 length) -1)))
        (set! (-> a0-11 param 1) 1.0)
        (joint-control-channel-group-eval! a0-11 (the-as art-joint-anim #f) num-func-seek!)
        )
      )
    (ja-channel-set! 1)
    (while #t
      (let ((a0-14 (-> self skel root-channel 0)))
        (set! (-> a0-14 frame-group) (the-as art-joint-anim (-> self draw art-group data 44)))
        (set! (-> a0-14 param 0)
              (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 44)) data 0 length) -1))
              )
        (set! (-> a0-14 param 1) 1.0)
        (set! (-> a0-14 frame-num) 0.0)
        (joint-control-channel-group! a0-14 (the-as art-joint-anim (-> self draw art-group data 44)) num-func-seek!)
        )
      (until (ja-done? 0)
        (suspend)
        (let ((a0-15 (-> self skel root-channel 0)))
          (set! (-> a0-15 param 0) (the float (+ (-> a0-15 frame-group data 0 length) -1)))
          (set! (-> a0-15 param 1) 1.0)
          (joint-control-channel-group-eval! a0-15 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      (+! (-> self anim-seed) 1)
      (let ((a0-17 (-> self skel root-channel 0)))
        (set! (-> a0-17 frame-group) (the-as art-joint-anim (-> self draw art-group data 45)))
        (set! (-> a0-17 param 0)
              (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 45)) data 0 length) -1))
              )
        (set! (-> a0-17 param 1) 1.0)
        (set! (-> a0-17 frame-num) 0.0)
        (joint-control-channel-group! a0-17 (the-as art-joint-anim (-> self draw art-group data 45)) num-func-seek!)
        )
      (until (ja-done? 0)
        (suspend)
        (let ((a0-18 (-> self skel root-channel 0)))
          (set! (-> a0-18 param 0) (the float (+ (-> a0-18 frame-group data 0 length) -1)))
          (set! (-> a0-18 param 1) 1.0)
          (joint-control-channel-group-eval! a0-18 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      )
    (none)
    )
  :post
  target-no-move-post
  )

;; failed to figure out what this is:
(defstate target-edge-grab-jump (target)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (case arg2
      (('end-mode)
       (go target-falling 'target-edge-grab)
       )
      (else
        (target-standard-event-handler arg0 arg1 arg2 arg3)
        )
      )
    )
  :exit
  (-> target-edge-grab exit)
  :code
  (behavior ((arg0 float) (arg1 float))
    (ja-channel-set! 1)
    (set-quaternion! (-> self control) (-> self control dir-targ))
    (logclear! (-> self control root-prim prim-core action) (collide-action ca-3 ca-7))
    (set! (-> self control transv quad) (the-as uint128 0))
    (let ((s4-0 (new 'stack-no-clear 'vector)))
      (let ((a0-8 (-> self skel root-channel 0)))
        (set! (-> a0-8 frame-group) (the-as art-joint-anim (-> self draw art-group data 49)))
        (set! (-> a0-8 param 0)
              (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 49)) data 0 length) -1))
              )
        (set! (-> a0-8 param 1) 1.0)
        (set! (-> a0-8 frame-num) 0.0)
        (joint-control-channel-group! a0-8 (the-as art-joint-anim (-> self draw art-group data 49)) num-func-seek!)
        )
      (until (ja-done? 0)
        (target-compute-edge-rider)
        (TODO-RENAME-9 (-> self align))
        (when (zero? (logand (-> self align flags) 1))
          (vector-matrix*! s4-0 (the-as vector (-> self align delta)) (-> self control unknown-matrix01))
          (move-by-vector! (-> self control) s4-0)
          )
        (suspend)
        (let ((a0-12 (-> self skel root-channel 0)))
          (set! (-> a0-12 param 0) (the float (+ (-> a0-12 frame-group data 0 length) -1)))
          (set! (-> a0-12 param 1) 1.0)
          (joint-control-channel-group-eval! a0-12 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      )
    (set! (-> self control transv quad) (the-as uint128 0))
    (set! (-> self control unknown-dword70) 0)
    (set-forward-vel (the-as float 16384.0))
    (send-event *camera* 'damp-up)
    (go target-jump-forward arg0 arg1)
    (none)
    )
  :post
  target-no-move-post
  )

;; failed to figure out what this is:
(defstate target-edge-grab-off (target)
  :event
  target-standard-event-handler
  :exit
  (-> target-edge-grab exit)
  :code
  (behavior ()
    (ja-channel-set! 1)
    (set-quaternion! (-> self control) (-> self control dir-targ))
    (send-event *camera* 'damp-up)
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (let ((s5-0 (-> self skel root-channel 0)))
        (set! (-> s5-0 frame-group) (the-as art-joint-anim (-> self draw art-group data 50)))
        (set! (-> s5-0 param 0) (ja-aframe (the-as float 191.0) 0))
        (set! (-> s5-0 param 1) 1.0)
        (set! (-> s5-0 frame-num) 0.0)
        (joint-control-channel-group! s5-0 (the-as art-joint-anim (-> self draw art-group data 50)) num-func-seek!)
        )
      (until (ja-done? 0)
        (TODO-RENAME-9 (-> self align))
        (when (zero? (logand (-> self align flags) 1))
          (vector-matrix*! gp-0 (the-as vector (-> self align delta)) (-> self control unknown-matrix01))
          (move-by-vector! (-> self control) gp-0)
          )
        (suspend)
        (let ((s5-1 (-> self skel root-channel 0)))
          (set! (-> s5-1 param 0) (ja-aframe (the-as float 191.0) 0))
          (set! (-> s5-1 param 1) 1.0)
          (joint-control-channel-group-eval! s5-1 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      )
    (set! (-> self control transv quad) (the-as uint128 0))
    (logclear! (-> self control root-prim prim-core action) (collide-action ca-3 ca-7))
    (vector-float*! (-> self control transv) (-> self control unknown-vector101) -40960.0)
    (when (and (< (- (-> *display* base-frame-counter) (the-as int (-> self control rider-time))) 60)
               (or (logtest? (-> self control unknown-surface01 flags) #x4000)
                   (= (-> self control poly-pat material) (pat-material rotate))
                   )
               )
      (+! (-> self control transv x) (-> self control rider-last-move x))
      (+! (-> self control transv z) (-> self control rider-last-move z))
      )
    (go target-falling 'target-edge-grab)
    (none)
    )
  :post
  target-no-move-post
  )

;; failed to figure out what this is:
(defstate target-yellow-blast (target)
  :event
  (-> target-running-attack event)
  :enter
  (behavior ()
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (set! (-> self control unknown-surface00) *run-attack-mods*)
    (set! (-> *run-attack-mods* turnv) 655360.0)
    (set! (-> *run-attack-mods* turnvv) 655360.0)
    (target-start-attack)
    (target-danger-set! 'spin #f)
    (set! (-> self control unknown-uint20) (the-as uint 0))
    (set! (-> self control unknown-int21) 0)
    (set! (-> self control unknown-uint31) (the-as uint 0))
    (let ((gp-0 (new-stack-vector0))
          (f30-0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
          )
      0.0
      (vector-! gp-0 (-> self control transv) (vector-float*! gp-0 (-> self control dynam gravity-normal) f30-0))
      (let* ((f0-5 (vector-length gp-0))
             (f1-0 f0-5)
             )
        (if (< 0.0 f30-0)
            (set! f30-0 0.0)
            )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f30-0)
          (vector-float*! gp-0 gp-0 (/ f0-5 f1-0))
          )
        )
      )
    (none)
    )
  :exit
  (behavior ()
    (set! (-> *run-attack-mods* turnv) 0.0)
    (set! (-> *run-attack-mods* turnvv) 0.0)
    (set! (-> self control unknown-dword31) (-> *display* base-frame-counter))
    (target-exit)
    (none)
    )
  :code
  (behavior ()
    (let ((gp-0 (the-as handle #f)))
      (ja-channel-push! 1 22)
      (level-hint-spawn
        (game-text-id daxter-you-can-shoot-with-yellow-eco)
        "sksp0145"
        (the-as entity #f)
        *entity-pool*
        (game-task none)
        )
      (case (-> (level-get-target-inside *level*) name)
        (('maincave)
         (level-hint-spawn
           (game-text-id daxter-maybe-you-can-shoot-better-goggles)
           "sksp0328"
           (the-as entity #f)
           *entity-pool*
           (game-task none)
           )
         )
        )
      (let ((s5-0 (-> self skel root-channel 0)))
        (set! (-> s5-0 frame-group) (the-as art-joint-anim (-> self draw art-group data 84)))
        (set! (-> s5-0 param 0) (ja-aframe (the-as float 9.0) 0))
        (set! (-> s5-0 param 1) 1.0)
        (set! (-> s5-0 frame-num) 0.0)
        (joint-control-channel-group! s5-0 (the-as art-joint-anim (-> self draw art-group data 84)) num-func-seek!)
        )
      (until (ja-done? 0)
        (if (>= (- (-> *display* base-frame-counter) (-> self state-time)) 30)
            (set! (-> *run-attack-mods* turnvv) 0.0)
            )
        (suspend)
        (let ((s5-1 (-> self skel root-channel 0)))
          (set! (-> s5-1 param 0) (ja-aframe (the-as float 9.0) 0))
          (set! (-> s5-1 param 1) 1.0)
          (joint-control-channel-group-eval! s5-1 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      (let ((s5-2 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control quat))))
        (set! (-> s5-2 y) 0.0)
        (vector-normalize! s5-2 (-> *TARGET-bank* yellow-projectile-speed))
        (when (and (= (-> self fact-info-target eco-type) 1) (>= (-> self fact-info-target eco-level) 1.0))
          (let ((gp-1 (get-process *default-dead-pool* projectile-yellow #x4000)))
            (set! gp-0 (ppointer->handle
                         (when gp-1
                           (let ((t9-12 (method-of-type projectile-yellow activate)))
                             (t9-12 (the-as projectile-yellow gp-1) self 'projectile-yellow (the-as pointer #x70004000))
                             )
                           (run-now-in-process
                             gp-1
                             projectile-init-by-other
                             (-> self entity)
                             (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 23))
                             s5-2
                             (if (>= (-> self fact-info-target eco-level) (-> *FACT-bank* eco-level-max))
                                 25
                                 9
                                 )
                             #f
                             )
                           (-> gp-1 ppointer)
                           )
                         )
                  )
            )
          (set! (-> self control unknown-dword82) (-> *display* base-frame-counter))
          )
        )
      (let ((s5-3 (-> self skel root-channel 0)))
        (set! (-> s5-3 frame-group) (the-as art-joint-anim (-> self draw art-group data 84)))
        (set! (-> s5-3 param 0)
              (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 84)) data 0 length) -1))
              )
        (set! (-> s5-3 param 1) 1.0)
        (set! (-> s5-3 frame-num) (ja-aframe (the-as float 9.0) 0))
        (joint-control-channel-group! s5-3 (the-as art-joint-anim (-> self draw art-group data 84)) num-func-seek!)
        )
      (until (ja-done? 0)
        (if (or (< (the-as uint (- (-> *display* base-frame-counter) (the-as int (-> self control unknown-uint30))))
                   (the-as uint 30)
                   )
                (= (-> self control unknown-uint31) 1)
                )
            (send-event (handle->process gp-0) 'die)
            )
        (suspend)
        (let ((a0-32 (-> self skel root-channel 0)))
          (set! (-> a0-32 param 0) (the float (+ (-> a0-32 frame-group data 0 length) -1)))
          (set! (-> a0-32 param 1) 1.0)
          (joint-control-channel-group-eval! a0-32 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      )
    (if (logtest? (-> self control status) 1)
        (go target-stance)
        (go target-falling #f)
        )
    (none)
    )
  :post
  (the-as (function none :behavior target) target-post)
  )

;; definition for symbol *yellow-jump-mods*, type surface
(define *yellow-jump-mods* (new 'static 'surface
                             :name 'run
                             :tiltv 65536.0
                             :tiltvv 131072.0
                             :transv-max 40960.0
                             :target-speed 40960.0
                             :fric 0.1
                             :nonlin-fric-dist 1.0
                             :slip-factor 1.0
                             :slide-factor 1.0
                             :slope-up-factor 1.0
                             :slope-down-factor 1.0
                             :slope-slip-angle 1.0
                             :impact-fric 1.0
                             :bend-factor 1.0
                             :bend-speed 1.0
                             :alignv 1.0
                             :slope-up-traction 1.0
                             :align-speed 1.0
                             :mode 'air
                             :flags #x800
                             )
        )

;; failed to figure out what this is:
(defstate target-yellow-jump-blast (target)
  :event
  target-standard-event-handler
  :enter
  (behavior ()
    (set! (-> self control unknown-surface00) *yellow-jump-mods*)
    (let ((gp-0 (new-stack-vector0)))
      (let ((f0-1 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
        0.0
        (vector-! gp-0 (-> self control transv) (vector-float*! gp-0 (-> self control dynam gravity-normal) f0-1))
        )
      (let* ((f0-2 (vector-length gp-0))
             (f1-1 f0-2)
             (f2-0 46917.434)
             )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-0)
          (vector-float*! gp-0 gp-0 (/ f0-2 f1-1))
          )
        )
      )
    (none)
    )
  :exit
  (behavior ()
    (rot->dir-targ! (-> self control))
    (set! (-> self control unknown-dword31) (-> *display* base-frame-counter))
    (target-exit)
    (none)
    )
  :code
  (behavior ()
    (ja-channel-push! 1 22)
    (let ((gp-0 (-> self skel root-channel 0)))
      (set! (-> gp-0 frame-group) (the-as art-joint-anim (-> self draw art-group data 86)))
      (set! (-> gp-0 param 0) (ja-aframe (the-as float 15.0) 0))
      (set! (-> gp-0 param 1) 1.0)
      (set! (-> gp-0 frame-num) 0.0)
      (joint-control-channel-group! gp-0 (the-as art-joint-anim (-> self draw art-group data 86)) num-func-seek!)
      )
    (until (ja-done? 0)
      (suspend)
      (let ((gp-1 (-> self skel root-channel 0)))
        (set! (-> gp-1 param 0) (ja-aframe (the-as float 15.0) 0))
        (set! (-> gp-1 param 1) 1.0)
        (joint-control-channel-group-eval! gp-1 (the-as art-joint-anim #f) num-func-seek!)
        )
      )
    (suspend)
    (let ((gp-2 (new-stack-vector0)))
      (let ((f0-6 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
        0.0
        (vector-! gp-2 (-> self control transv) (vector-float*! gp-2 (-> self control dynam gravity-normal) f0-6))
        )
      (let* ((f0-7 (vector-length gp-2))
             (f1-1 f0-7)
             (f2-0 46917.434)
             )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-0)
          (vector-float*! gp-2 gp-2 (/ f0-7 f1-1))
          )
        )
      )
    (let ((a0-13 (-> self skel root-channel 0)))
      (set! (-> a0-13 param 0) (the float (+ (-> a0-13 frame-group data 0 length) -1)))
      (set! (-> a0-13 param 1) 1.0)
      (joint-control-channel-group-eval! a0-13 (the-as art-joint-anim #f) num-func-seek!)
      )
    (let ((gp-3 (get-process *default-dead-pool* projectile-yellow #x4000)))
      (when gp-3
        (let ((t9-9 (method-of-type projectile-yellow activate)))
          (t9-9 (the-as projectile-yellow gp-3) self 'projectile-yellow (the-as pointer #x70004000))
          )
        (run-now-in-process
          gp-3
          projectile-init-by-other
          (-> self entity)
          (-> self control unknown-vector90)
          (vector-float*!
            (new 'stack-no-clear 'vector)
            (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control quat))
            (the-as float (-> *TARGET-bank* yellow-projectile-speed))
            )
          (if (>= (-> self fact-info-target eco-level) (-> *FACT-bank* eco-level-max))
              16
              0
              )
          #f
          )
        (-> gp-3 ppointer)
        )
      )
    (set! (-> self control unknown-dword82) (-> *display* base-frame-counter))
    (let ((gp-4 (-> *display* base-frame-counter)))
      (until (>= (- (-> *display* base-frame-counter) gp-4) 30)
        (suspend)
        )
      )
    (let ((gp-5 (-> self skel root-channel 0)))
      (set! (-> gp-5 frame-group) (the-as art-joint-anim (-> self draw art-group data 86)))
      (set! (-> gp-5 param 0)
            (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 86)) data 0 length) -1))
            )
      (set! (-> gp-5 param 1) 1.0)
      (set! (-> gp-5 frame-num) (ja-frame-num 0))
      (joint-control-channel-group! gp-5 (the-as art-joint-anim (-> self draw art-group data 86)) num-func-seek!)
      )
    (until (ja-done? 0)
      (suspend)
      (let ((a0-22 (-> self skel root-channel 0)))
        (set! (-> a0-22 param 0) (the float (+ (-> a0-22 frame-group data 0 length) -1)))
        (set! (-> a0-22 param 1) 1.0)
        (joint-control-channel-group-eval! a0-22 (the-as art-joint-anim #f) num-func-seek!)
        )
      )
    (if (logtest? (-> self control status) 1)
        (go target-stance)
        (go target-falling #f)
        )
    (none)
    )
  :post
  target-no-stick-post
  )

;; failed to figure out what this is:
(defstate target-eco-powerup (target)
  :event
  target-standard-event-handler
  :exit
  target-exit
  :trans
  (behavior ()
    (slide-down-test)
    (none)
    )
  :code
  (behavior ((arg0 object) (arg1 float))
    (set! (-> self neck flex-blend) 0.0)
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (if (= arg1 (-> *FACT-bank* eco-full-inc))
        (set! (-> self control unknown-surface00) *double-jump-mods*)
        (set! (-> self control unknown-surface00) *walk-mods*)
        )
    (ja-channel-push! 1 15)
    (let ((s5-0 (-> self skel root-channel 0)))
      (set! (-> s5-0 frame-group) (the-as art-joint-anim (-> self draw art-group data 87)))
      (set! (-> s5-0 param 0)
            (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 87)) data 0 length) -1))
            )
      (set! (-> s5-0 param 1) (the-as float (if (= arg1 (-> *FACT-bank* eco-full-inc))
                                                2.0
                                                3.0
                                                )
                                      )
            )
      (set! (-> s5-0 frame-num) (ja-aframe
                                  (the-as float (if (= arg1 (-> *FACT-bank* eco-full-inc))
                                                    (-> (new 'static 'array int32 1 0) 0)
                                                    6.0
                                                    )
                                          )
                                  0
                                  )
            )
      (joint-control-channel-group! s5-0 (the-as art-joint-anim (-> self draw art-group data 87)) num-func-seek!)
      )
    (until (ja-done? 0)
      (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 0)
                                         (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 1)
                                         )
                                 (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 2)
                                 )
                         (pad-buttons x)
                         )
               (zero? (logand (-> self water flags) 512))
               (zero? (logand (-> self state-flags) 2048))
               )
          (go target-jump (-> *TARGET-bank* jump-height-min) (-> *TARGET-bank* jump-height-max) (the-as surface #f))
          )
      (if (and (logtest? (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 0)
                         (pad-buttons circle)
                         )
               (can-feet?)
               )
          (go target-attack-air #f)
          )
      (when (can-hands? #f)
        (if (and (= (-> self fact-info-target eco-type) 1) (>= (-> self fact-info-target eco-level) 1.0))
            (go target-yellow-jump-blast)
            (go target-running-attack)
            )
        )
      (TODO-RENAME-9 (-> self align))
      (TODO-RENAME-10
        (-> self align)
        2
        (the-as float 1.0)
        (the-as float (if (= arg1 (-> *FACT-bank* eco-full-inc))
                          2.0
                          1.0
                          )
                )
        (the-as float 1.0)
        )
      (suspend)
      (let ((a0-30 (-> self skel root-channel 0)))
        (set! (-> a0-30 param 0) (the float (+ (-> a0-30 frame-group data 0 length) -1)))
        (set! (-> a0-30 param 1) (the-as float (if (= arg1 (-> *FACT-bank* eco-full-inc))
                                                   2.0
                                                   3.0
                                                   )
                                         )
              )
        (joint-control-channel-group-eval! a0-30 (the-as art-joint-anim #f) num-func-seek!)
        )
      )
    (go target-falling 'target-eco-powerup)
    (none)
    )
  :post
  (the-as (function none :behavior target) target-post)
  )

;; failed to figure out what this is:
(defstate target-wade-stance (target)
  :event
  target-standard-event-handler
  :enter
  (behavior ()
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (set! (-> self control unknown-surface00) *wade-mods*)
    (set-zero! (-> self water bob))
    (none)
    )
  :exit
  (behavior ()
    (target-state-hook-exit)
    (target-exit)
    (let ((v1-1 (-> self skel effect)))
      (set! (-> v1-1 channel-offset) 0)
      )
    0
    (none)
    )
  :trans
  (behavior ()
    ((-> self state-hook))
    (when (and (zero? (logand (-> self water flags) 1024))
               (>= (- (-> *display* base-frame-counter) (the-as int (-> self water wade-time))) 15)
               )
      (if (logtest? (-> self water flags) 2048)
          (go target-swim-stance)
          (go target-stance)
          )
      )
    (if (and (logtest? (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-abs 0)
                       (pad-buttons l1 r1)
                       )
             (can-duck?)
             )
        (go target-duck-stance)
        )
    (if (!= (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) stick0-speed) 0.0)
        (go target-wade-walk)
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 2)
                               )
                       (pad-buttons x)
                       )
             (can-jump? #f)
             )
        (go target-jump (-> *TARGET-bank* jump-height-min) (-> *TARGET-bank* jump-height-max) (the-as surface #f))
        )
    (when (and (logtest? (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 0)
                         (pad-buttons circle)
                         )
               (can-feet?)
               )
      (sound-play-by-name (static-sound-name "swim-stroke") (new-sound-id) 1024 0 0 1 #t)
      (dummy-13 (-> self water) (the-as float 1.4) (-> self control trans) 0 (-> self control transv))
      (go target-attack)
      )
    (if (can-hands? #t)
        (go target-running-attack)
        )
    (none)
    )
  :code
  (-> target-stance code)
  :post
  (the-as (function none :behavior target) target-post)
  )

;; failed to figure out what this is:
(defstate target-wade-walk (target)
  :event
  target-standard-event-handler
  :enter
  (-> target-wade-stance enter)
  :exit
  (-> target-wade-stance exit)
  :trans
  (behavior ()
    ((-> self state-hook))
    (when (and (zero? (logand (-> self water flags) 1024))
               (>= (- (-> *display* base-frame-counter) (the-as int (-> self water wade-time))) 30)
               )
      (if (logtest? (-> self water flags) 2048)
          (go target-swim-stance)
          (go target-stance)
          )
      )
    (if (= (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) stick0-speed) 0.0)
        (go target-wade-stance)
        )
    (if (and (logtest? (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-abs 0)
                       (pad-buttons l1 r1)
                       )
             (can-duck?)
             )
        (go target-duck-walk)
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 2)
                               )
                       (pad-buttons x)
                       )
             (can-jump? #f)
             )
        (go target-jump (-> *TARGET-bank* jump-height-min) (-> *TARGET-bank* jump-height-max) (the-as surface #f))
        )
    (when (and (logtest? (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 0)
                         (pad-buttons circle)
                         )
               (can-feet?)
               )
      (sound-play-by-name (static-sound-name "swim-stroke") (new-sound-id) 1024 0 0 1 #t)
      (dummy-13 (-> self water) (the-as float 1.4) (-> self control trans) 0 (-> self control transv))
      (go target-attack)
      )
    (if (can-hands? #t)
        (go target-running-attack)
        )
    (none)
    )
  :code
  (behavior ()
    (let ((gp-0 105)
          (f30-0 0.0)
          )
      (let ((v1-2 (if (> (-> self skel active-channels) 0)
                      (-> self skel root-channel 0 frame-group)
                      )
                  )
            )
        (cond
          ((or (= v1-2 (-> self draw art-group data 23)) (= v1-2 (-> self draw art-group data 18)))
           (set! gp-0 15)
           (set! f30-0 (ja-frame-num 0))
           )
          ((let ((v1-9 (if (> (-> self skel active-channels) 0)
                           (-> self skel root-channel 0 frame-group)
                           )
                       )
                 )
             (or (= v1-9 (-> self draw art-group data 34)) (= v1-9 (-> self draw art-group data 38)))
             )
           (set! gp-0 30)
           )
          ((= (if (> (-> self skel active-channels) 0)
                  (-> self skel root-channel 0 frame-group)
                  )
              (-> self draw art-group data 92)
              )
           (set! gp-0 120)
           )
          )
        )
      (cond
        ((and (= (ja-group-size) 6) (= (if (> (-> self skel active-channels) 0)
                                           (-> self skel root-channel 0 frame-group)
                                           )
                                       (-> self draw art-group data 89)
                                       )
              )
         )
        (else
          (ja-channel-push! 6 gp-0)
          (let ((gp-1 (-> self skel root-channel 0)))
            (set! (-> gp-1 dist) (-> *TARGET-bank* wade-shallow-walk-cycle-dist))
            (joint-control-channel-group-eval!
              gp-1
              (the-as art-joint-anim (-> self draw art-group data 89))
              num-func-identity
              )
            (set! (-> gp-1 frame-num) f30-0)
            )
          (let ((gp-2 (-> self skel root-channel 1)))
            (set! (-> gp-2 dist) (-> *TARGET-bank* wade-deep-walk-cycle-dist))
            (joint-control-channel-group-eval!
              gp-2
              (the-as art-joint-anim (-> self draw art-group data 90))
              num-func-identity
              )
            (set! (-> gp-2 frame-num) f30-0)
            )
          (let ((gp-3 (-> self skel root-channel 2)))
            (set! (-> gp-3 frame-interp) 0.0)
            (set! (-> gp-3 dist) (-> *TARGET-bank* walk-cycle-dist))
            (joint-control-channel-group-eval!
              gp-3
              (the-as art-joint-anim (-> self draw art-group data 23))
              num-func-identity
              )
            (set! (-> gp-3 frame-num) f30-0)
            )
          (let ((gp-4 (-> self skel root-channel 3)))
            (set! (-> gp-4 frame-interp) 0.0)
            (set! (-> gp-4 dist) (-> *TARGET-bank* walk-down-cycle-dist))
            (joint-control-channel-group-eval!
              gp-4
              (the-as art-joint-anim (-> self draw art-group data 25))
              num-func-identity
              )
            (set! (-> gp-4 frame-num) f30-0)
            )
          (let ((gp-5 (-> self skel root-channel 4)))
            (set! (-> gp-5 frame-interp) 0.0)
            (set! (-> gp-5 dist) (-> *TARGET-bank* walk-side-cycle-dist))
            (joint-control-channel-group-eval!
              gp-5
              (the-as art-joint-anim (-> self draw art-group data 27))
              num-func-identity
              )
            (set! (-> gp-5 frame-num) f30-0)
            )
          )
        )
      )
    (set! (-> self skel root-channel 2 command) 'push)
    (set! (-> self skel root-channel 5 command) 'stack)
    (let ((f30-1 0.0)
          (f28-0 0.0)
          (f26-0 (lerp-scale
                   (the-as float 1.0)
                   (the-as float (-> (new 'static 'array int32 1 0) 0))
                   (-> self control unknown-float01)
                   (the-as float 16384.0)
                   (the-as float 32768.0)
                   )
                 )
          (gp-6 0)
          )
      (while #t
        (let ((f0-10 (fmax -1.0 (fmin 1.0 (* 2.0 (-> self control unknown-float61)))))
              (f24-0 (fmax -1.0 (fmin 1.0 (* 1.6 (-> self control unknown-float62)))))
              )
          (let ((f1-4 (fabs (- f0-10 f30-1))))
            (set! f30-1 (seek f30-1 f0-10 (fmax 0.05 (fmin 0.2 (* 0.25 f1-4)))))
            )
          (let ((f0-14 (fabs (- f24-0 f28-0))))
            (set! f28-0 (seek f28-0 f24-0 (fmax 0.05 (fmin 0.2 (* 0.25 f0-14)))))
            )
          )
        (let ((v1-84 (-> self skel root-channel 3)))
          (set! (-> v1-84 dist) (-> *TARGET-bank* walk-down-cycle-dist))
          (set! (-> v1-84 frame-group) (the-as art-joint-anim (-> self draw art-group data 25)))
          )
        (cond
          ((>= f30-1 0.0)
           (let ((v1-87 (-> self skel root-channel 3)))
             (set! (-> v1-87 frame-interp) (fabs f30-1))
             (set! (-> v1-87 dist) (-> *TARGET-bank* walk-up-cycle-dist))
             (set! (-> v1-87 frame-group) (the-as art-joint-anim (-> self draw art-group data 24)))
             )
           )
          (else
            (let ((v1-90 (-> self skel root-channel 3)))
              (set! (-> v1-90 frame-interp) (fabs f30-1))
              (set! (-> v1-90 dist) (-> *TARGET-bank* walk-down-cycle-dist))
              (set! (-> v1-90 frame-group) (the-as art-joint-anim (-> self draw art-group data 25)))
              )
            )
          )
        (cond
          ((>= f28-0 0.0)
           (let ((v1-93 (-> self skel root-channel 4)))
             (set! (-> v1-93 frame-interp) (fabs f28-0))
             (set! (-> v1-93 dist) (-> *TARGET-bank* walk-side-cycle-dist))
             (set! (-> v1-93 frame-group) (the-as art-joint-anim (-> self draw art-group data 26)))
             )
           )
          (else
            (let ((v1-96 (-> self skel root-channel 4)))
              (set! (-> v1-96 frame-interp) (fabs f28-0))
              (set! (-> v1-96 dist) (-> *TARGET-bank* walk-side-cycle-dist))
              (set! (-> v1-96 frame-group) (the-as art-joint-anim (-> self draw art-group data 27)))
              )
            )
          )
        (let* ((f0-30 (- (-> self water height) (-> self control trans y)))
               (f24-1 (lerp-scale
                        (the-as float (-> (new 'static 'array int32 1 0) 0))
                        (the-as float 1.0)
                        f0-30
                        (lerp (-> self water wade-height) (-> self water swim-height) (the-as float 0.25))
                        (lerp (-> self water wade-height) (-> self water swim-height) (the-as float 0.75))
                        )
                      )
               )
          (let ((v1-108 (-> self skel effect)))
            (set! (-> v1-108 channel-offset) (if (< 0.5 f24-1)
                                                 1
                                                 0
                                                 )
                  )
            )
          0
          (set! f26-0 (seek
                        f26-0
                        (lerp-scale
                          (the-as float 1.0)
                          (the-as float (-> (new 'static 'array int32 1 0) 0))
                          (-> self control unknown-float01)
                          (the-as float 16384.0)
                          (the-as float 32768.0)
                          )
                        (* 4.0 (-> *display* seconds-per-frame))
                        )
                )
          (set! (-> self skel root-channel 1 frame-interp) f24-1)
          (let ((s5-2 (-> self skel root-channel 0)))
            (set! (-> s5-2 param 0) (/ (-> self control unknown-float01)
                                       (* 60.0 (/ (dummy-9 (-> self skel)) (-> *TARGET-bank* run-cycle-length)))
                                       )
                  )
            (joint-control-channel-group-eval! s5-2 (the-as art-joint-anim #f) num-func-loop!)
            )
          (let ((s5-3 (-> self skel root-channel 5)))
            (set! (-> s5-3 frame-interp) (lerp f26-0 (the-as float (-> (new 'static 'array int32 1 0) 0)) f24-1))
            )
          )
        (let ((a0-66 (-> self skel root-channel 1)))
          (set! (-> a0-66 param 0) 0.0)
          (joint-control-channel-group-eval! a0-66 (the-as art-joint-anim #f) num-func-chan)
          )
        (let ((a0-67 (-> self skel root-channel 2)))
          (set! (-> a0-67 param 0) 0.0)
          (joint-control-channel-group-eval! a0-67 (the-as art-joint-anim #f) num-func-chan)
          )
        (let ((a0-68 (-> self skel root-channel 3)))
          (set! (-> a0-68 param 0) 0.0)
          (joint-control-channel-group-eval! a0-68 (the-as art-joint-anim #f) num-func-chan)
          )
        (let ((a0-69 (-> self skel root-channel 4)))
          (set! (-> a0-69 param 0) 0.0)
          (joint-control-channel-group-eval! a0-69 (the-as art-joint-anim #f) num-func-chan)
          )
        (when (and (>= (- (-> *display* base-frame-counter) gp-6) 60)
                   (< (- (-> self water height) (-> self control trans y)) 4096.0)
                   )
          (case (the int (ja-aframe-num 0))
            ((15 16 17 18)
             (dummy-13
               (-> self water)
               (the-as float 0.2)
               (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 75))
               0
               (vector-float*! (new 'stack-no-clear 'vector) (-> self control transv) 2.5)
               )
             (set! gp-6 (-> *display* base-frame-counter))
             )
            ((46 47 48 49)
             (dummy-13
               (-> self water)
               (the-as float 0.2)
               (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 71))
               0
               (vector-float*! (new 'stack-no-clear 'vector) (-> self control transv) 2.5)
               )
             (set! gp-6 (-> *display* base-frame-counter))
             )
            )
          )
        (suspend)
        )
      )
    (none)
    )
  :post
  (the-as (function none :behavior target) target-post)
  )

;; definition for function target-swim-tilt
(defbehavior target-swim-tilt target ((arg0 float) (arg1 float) (arg2 float) (arg3 float))
  (let ((gp-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control unknown-quaternion00))))
    (let ((v1-2 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control dir-targ)))
          (f0-1
            (fmin 1.0 (* arg0 (/ (-> self control unknown-float01) (-> self control unknown-surface01 target-speed))))
            )
          )
      (set! (-> self control unknown-float130)
            (seek
              (-> self control unknown-float130)
              (fmax (fmin (* (+ f0-1 arg2) (fmax 0.5 (+ 0.5 (vector-dot gp-0 v1-2)))) arg3) (- arg3))
              (* arg1 (-> *display* seconds-per-frame))
              )
            )
      )
    (let ((a2-2 (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> self control unknown-quaternion00))))
      (forward-up-nopitch->quaternion (-> self control unknown-quaternion01) gp-0 a2-2)
      )
    )
  (quaternion-rotate-x!
    (-> self control unknown-quaternion01)
    (-> self control unknown-quaternion01)
    (the-as float (if (>= (-> self control unknown-float130) 0.0)
                      16384.0
                      -16384.0
                      )
            )
    )
  (set! (-> self control unknown-float00) (fabs (-> self control unknown-float130)))
  (if (= (-> self next-state name) 'target-swim-down)
      (set! (-> self control unknown-float131)
            (seek (-> self control unknown-float131) (the-as float -6144.0) (* 4096.0 (-> *display* seconds-per-frame)))
            )
      (set! (-> self control unknown-float131) (seek
                                                 (-> self control unknown-float131)
                                                 (the-as float (-> (new 'static 'array int32 1 0) 0))
                                                 (* 2048.0 (-> *display* seconds-per-frame))
                                                 )
            )
      )
  (let ((f0-20 (-> self control unknown-float131)))
    (set! (-> self control unknown-vector11 y) f0-20)
    f0-20
    )
  )

;; failed to figure out what this is:
(defstate target-swim-stance (target)
  :event
  target-standard-event-handler
  :enter
  (behavior ()
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (set! (-> self control unknown-surface00) *swim-mods*)
    (logior! (-> self water flags) 16)
    (none)
    )
  :exit
  (behavior ()
    (target-state-hook-exit)
    (set! (-> self control unknown-surface00 target-speed) 28672.0)
    (target-exit)
    (when (not (or (= (-> self next-state name) 'target-swim-stance)
                   (= (-> self next-state name) 'target-swim-walk)
                   (= (-> self next-state name) 'target-swim-down)
                   (= (-> self next-state name) 'target-swim-up)
                   )
               )
      (quaternion-identity! (-> self control unknown-quaternion01))
      (set! (-> self control unknown-float00) 0.0)
      )
    (none)
    )
  :trans
  (behavior ()
    ((-> self state-hook))
    (if (and (logtest? (-> self control status) 1) (zero? (logand (-> self control status) 1024)))
        (set-zero! (-> self water bob))
        )
    (when (and (zero? (logand (-> self water flags) 2048))
               (>= (- (-> *display* base-frame-counter) (-> self state-time)) 30)
               )
      (if (logtest? (-> self water flags) 1024)
          (go target-wade-stance)
          (go target-stance)
          )
      )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 2)
                               )
                       (pad-buttons x)
                       )
             (can-jump? #f)
             (>= (- (-> *display* base-frame-counter) (the-as int (-> self water enter-swim-time))) 30)
             )
        (go target-swim-jump (-> *TARGET-bank* swim-jump-height-min) (-> *TARGET-bank* swim-jump-height-max))
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 2)
                               )
                       (pad-buttons square)
                       )
             (< (-> *TARGET-bank* min-dive-depth) (target-height-above-ground))
             )
        (go target-swim-down)
        )
    (if (and (!= (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) stick0-speed) 0.0)
             (let ((gp-0 (if (> (-> self skel active-channels) 0)
                             (-> self skel root-channel 0 frame-group)
                             )
                         )
                   )
               (ja-aframe-num 0)
               (if (or (and (= gp-0 (-> self draw art-group data 96)) #t) (and (= gp-0 (-> self draw art-group data 95)) #t))
                   #f
                   #t
                   )
               )
             )
        (go target-swim-walk)
        )
    (target-swim-tilt
      (the-as float (-> (new 'static 'array int32 1 0) 0))
      (the-as float 2.0)
      (the-as float (-> (new 'static 'array int32 1 0) 0))
      (the-as float 1.0)
      )
    (none)
    )
  :code
  (behavior ()
    (let ((v1-2 (if (> (-> self skel active-channels) 0)
                    (-> self skel root-channel 0 frame-group)
                    )
                )
          )
      (cond
        ((or (= v1-2 (-> self draw art-group data 96)) (= v1-2 (-> self draw art-group data 95)))
         (ja-channel-push! 1 22)
         (let ((a0-8 (-> self skel root-channel 0)))
           (set! (-> a0-8 frame-group) (the-as art-joint-anim (-> self draw art-group data 97)))
           (set! (-> a0-8 param 0)
                 (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 97)) data 0 length) -1))
                 )
           (set! (-> a0-8 param 1)
                 (the-as float (if (= (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) stick0-speed) 0.0)
                                   1.0
                                   2.0
                                   )
                         )
                 )
           (set! (-> a0-8 frame-num) 0.0)
           (joint-control-channel-group! a0-8 (the-as art-joint-anim (-> self draw art-group data 97)) num-func-seek!)
           )
         (until (ja-done? 0)
           (suspend)
           (let ((a0-9 (-> self skel root-channel 0)))
             (set! (-> a0-9 param 0) (the float (+ (-> a0-9 frame-group data 0 length) -1)))
             (let ((v1-41 (if (= (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) stick0-speed) 0.0)
                              1.0
                              2.0
                              )
                          )
                   )
               (set! (-> a0-9 param 1) (the-as float v1-41))
               )
             (joint-control-channel-group-eval! a0-9 (the-as art-joint-anim #f) num-func-seek!)
             )
           )
         )
        ((= (if (> (-> self skel active-channels) 0)
                (-> self skel root-channel 0 frame-group)
                )
            (-> self draw art-group data 92)
            )
         (ja-channel-push! 1 249)
         )
        (else
          (ja-channel-push! 1 45)
          )
        )
      )
    (while #t
      (let ((gp-0 (-> self skel root-channel 0)))
        (joint-control-channel-group-eval!
          gp-0
          (the-as art-joint-anim (-> self draw art-group data 91))
          num-func-identity
          )
        (set! (-> gp-0 frame-num) 0.0)
        )
      (until (and (ja-done? 0) (= (-> self skel root-channel 0) (-> self skel channel)))
        (suspend)
        (when (= (-> self skel root-channel 0) (-> self skel channel))
          (let ((a0-21 (-> self skel root-channel 0)))
            (set! (-> a0-21 param 0) (the float (+ (-> a0-21 frame-group data 0 length) -1)))
            (set! (-> a0-21 param 1) 1.0)
            (joint-control-channel-group-eval! a0-21 (the-as art-joint-anim #f) num-func-seek!)
            )
          )
        )
      )
    (none)
    )
  :post
  target-swim-post
  )

;; failed to figure out what this is:
(defstate target-swim-walk (target)
  :event
  target-standard-event-handler
  :enter
  (behavior ()
    ((-> target-swim-stance enter))
    (die-on-next-update! (-> self water bob))
    (set! (-> self control unknown-uint20) (the-as uint (-> *display* base-frame-counter)))
    (none)
    )
  :exit
  (-> target-swim-stance exit)
  :trans
  (behavior ()
    ((-> self state-hook))
    (if (and (logtest? (-> self control status) 1) (zero? (logand (-> self control status) 1024)))
        (set-zero! (-> self water bob))
        )
    (when (and (zero? (logand (-> self water flags) 2048))
               (>= (- (-> *display* base-frame-counter) (the-as int (-> self water swim-time))) 30)
               )
      (if (logtest? (-> self water flags) 1024)
          (go target-wade-stance)
          (go target-stance)
          )
      )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 2)
                               )
                       (pad-buttons x)
                       )
             (can-jump? #f)
             (>= (- (-> *display* base-frame-counter) (the-as int (-> self water enter-swim-time))) 30)
             )
        (go target-swim-jump (-> *TARGET-bank* swim-jump-height-min) (-> *TARGET-bank* swim-jump-height-max))
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 2)
                               )
                       (pad-buttons square)
                       )
             (< (-> *TARGET-bank* min-dive-depth) (target-height-above-ground))
             )
        (go target-swim-down)
        )
    (cond
      ((= (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) stick0-speed) 0.0)
       (if (>= (the-as uint (- (-> *display* base-frame-counter) (the-as int (-> self control unknown-uint20))))
               (the-as uint 15)
               )
           (go target-swim-stance)
           )
       )
      (else
        (set! (-> self control unknown-uint20) (the-as uint (-> *display* base-frame-counter)))
        )
      )
    (target-swim-tilt
      (the-as float (-> (new 'static 'array int32 1 0) 0))
      (the-as float 2.0)
      (the-as float (-> (new 'static 'array int32 1 0) 0))
      (the-as float 1.0)
      )
    (none)
    )
  :code
  (behavior ()
    (let ((v1-2 (if (> (-> self skel active-channels) 0)
                    (-> self skel root-channel 0 frame-group)
                    )
                )
          )
      (cond
        ((or (= v1-2 (-> self draw art-group data 96))
             (= v1-2 (-> self draw art-group data 95))
             (= v1-2 (-> self draw art-group data 97))
             )
         (ja-channel-push! 1 90)
         )
        ((= (if (> (-> self skel active-channels) 0)
                (-> self skel root-channel 0 frame-group)
                )
            (-> self draw art-group data 97)
            )
         (ja-channel-push! 1 45)
         (let ((gp-0 (-> self skel root-channel 0)))
           (set! (-> gp-0 frame-group) (the-as art-joint-anim (-> self draw art-group data 92)))
           (set! (-> gp-0 param 0)
                 (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 92)) data 0 length) -1))
                 )
           (set! (-> gp-0 param 1) 1.0)
           (set! (-> gp-0 frame-num) (ja-aframe (the-as float 19.0) 0))
           (joint-control-channel-group! gp-0 (the-as art-joint-anim (-> self draw art-group data 92)) num-func-seek!)
           )
         (until (ja-done? 0)
           (TODO-RENAME-9 (-> self align))
           (if (zero? (logand (-> self align flags) 1))
               (set! (-> self control unknown-surface00 target-speed)
                     (* (-> self align delta trans z) (-> self control unknown-surface01 alignv) (-> *display* frames-per-second))
                     )
               )
           (suspend)
           (let ((a0-19 (-> self skel root-channel 0)))
             (set! (-> a0-19 param 0) (the float (+ (-> a0-19 frame-group data 0 length) -1)))
             (set! (-> a0-19 param 1) 1.0)
             (joint-control-channel-group-eval! a0-19 (the-as art-joint-anim #f) num-func-seek!)
             )
           )
         )
        (else
          (ja-channel-push! 1 45)
          )
        )
      )
    (while #t
      (let ((a0-22 (-> self skel root-channel 0)))
        (set! (-> a0-22 frame-group) (the-as art-joint-anim (-> self draw art-group data 92)))
        (set! (-> a0-22 param 0)
              (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 92)) data 0 length) -1))
              )
        (set! (-> a0-22 param 1) 1.0)
        (set! (-> a0-22 frame-num) 0.0)
        (joint-control-channel-group! a0-22 (the-as art-joint-anim (-> self draw art-group data 92)) num-func-seek!)
        )
      (until (ja-done? 0)
        (TODO-RENAME-9 (-> self align))
        (if (zero? (logand (-> self align flags) 1))
            (set! (-> self control unknown-surface00 target-speed)
                  (* (-> self align delta trans z) (-> self control unknown-surface01 alignv) (-> *display* frames-per-second))
                  )
            )
        (suspend)
        (let ((a0-24 (-> self skel root-channel 0)))
          (set! (-> a0-24 param 0) (the float (+ (-> a0-24 frame-group data 0 length) -1)))
          (set! (-> a0-24 param 1) 1.0)
          (joint-control-channel-group-eval! a0-24 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      )
    (none)
    )
  :post
  target-swim-post
  )

;; failed to figure out what this is:
(defstate target-swim-down (target)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (case arg2
      (('attack 'attack-invinc)
       (let ((v1-2 (the-as attack-info (-> arg3 param 1))))
         (when (or (zero? (logand (-> v1-2 mask) 32)) (= (-> v1-2 mode) 'generic) (= (-> v1-2 mode) 'drown))
           (set! (-> v1-2 mode) 'damage)
           (if (and (= (-> self game mode) 'play) (>= 1.0 (-> self fact-info-target health)))
               (set! (-> v1-2 mode) 'drown-death)
               )
           (logior! (-> v1-2 mask) 32)
           (set! (-> self control unknown-uint20) (the-as uint #t))
           )
         )
       )
      )
    (target-standard-event-handler arg0 arg1 arg2 arg3)
    )
  :enter
  (behavior ()
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (set! (-> self water flags) (logand -17 (-> self water flags)))
    (set! (-> self control unknown-surface00) *dive-mods*)
    (set! (-> self control dynam gravity-max) 16384.0)
    (set! (-> self control dynam gravity-length) 16384.0)
    (set! (-> self water swim-time) (the-as uint (-> *display* base-frame-counter)))
    (set! (-> self control unknown-uint20) (the-as uint #f))
    (if (= (-> self next-state name) 'target-swim-down)
        (set! (-> self control unknown-float130) 0.0)
        )
    (none)
    )
  :exit
  (behavior ()
    (set! (-> self control dynam gravity-max) (-> self control unknown-dynamics00 gravity-max))
    (set! (-> self control dynam gravity-length) (-> self control unknown-dynamics00 gravity-length))
    (target-exit)
    (when (not (or (= (-> self next-state name) 'target-swim-stance)
                   (= (-> self next-state name) 'target-swim-walk)
                   (= (-> self next-state name) 'target-swim-down)
                   (= (-> self next-state name) 'target-swim-up)
                   )
               )
      (quaternion-identity! (-> self control unknown-quaternion01))
      (set! (-> self control unknown-float00) 0.0)
      )
    (none)
    )
  :trans
  (behavior ()
    (if (>= (- (-> *display* base-frame-counter) (the-as int (-> self water swim-time))) 150)
        (go target-stance)
        )
    (cond
      ((>= (- (-> *display* base-frame-counter) (-> self control unknown-dword11)) 30)
       (set! (-> self control unknown-surface00) *dive-mods*)
       (if (= (-> self next-state name) 'target-swim-down)
           (target-swim-tilt
             (the-as float -0.9)
             (the-as float 1.0)
             (the-as float (-> (new 'static 'array int32 1 0) 0))
             (the-as float 0.5)
             )
           )
       )
      (else
        (set! (-> self control unknown-surface00) *dive-bottom-mods*)
        (if (or (= (-> self next-state name) 'target-swim-down) (= (-> self next-state name) 'target-swim-stance))
            (target-swim-tilt
              (the-as float (-> (new 'static 'array int32 1 0) 0))
              (the-as float 2.0)
              (the-as float -1.0)
              (the-as float 1.0)
              )
            )
        )
      )
    (none)
    )
  :code
  (behavior ()
    (let ((gp-0 60)
          (s5-0 3000)
          (f30-0 0.0)
          )
      (let ((v1-2 (if (> (-> self skel active-channels) 0)
                      (-> self skel root-channel 0 frame-group)
                      )
                  )
            )
        (set! f30-0
              (cond
                ((or (= v1-2 (-> self draw art-group data 91))
                     (= v1-2 (-> self draw art-group data 92))
                     (= v1-2 (-> self draw art-group data 97))
                     (= v1-2 (-> self draw art-group data 96))
                     (= v1-2 (-> self draw art-group data 95))
                     )
                 (ja-channel-push! 1 22)
                 (let ((a0-17 (-> self skel root-channel 0)))
                   (set! (-> a0-17 frame-group) (the-as art-joint-anim (-> self draw art-group data 93)))
                   (set! (-> a0-17 param 0)
                         (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 93)) data 0 length) -1))
                         )
                   (set! (-> a0-17 param 1) 1.0)
                   (set! (-> a0-17 frame-num) 0.0)
                   (joint-control-channel-group! a0-17 (the-as art-joint-anim (-> self draw art-group data 93)) num-func-seek!)
                   )
                 (until (ja-done? 0)
                   (TODO-RENAME-9 (-> self align))
                   (TODO-RENAME-10 (-> self align) 6 (the-as float 1.0) (the-as float 1.0) (the-as float 1.0))
                   (if (= (ja-aframe-num 0) 73.0)
                       (dummy-13 (-> self water) (the-as float 0.7) (-> self control trans) 1 *null-vector*)
                       )
                   (suspend)
                   (let ((a0-22 (-> self skel root-channel 0)))
                     (set! (-> a0-22 param 0) (the float (+ (-> a0-22 frame-group data 0 length) -1)))
                     (set! (-> a0-22 param 1) 1.0)
                     (joint-control-channel-group-eval! a0-22 (the-as art-joint-anim #f) num-func-seek!)
                     )
                   )
                 (let ((s4-0 (-> self skel root-channel 0)))
                   (joint-control-channel-group-eval!
                     s4-0
                     (the-as art-joint-anim (-> self draw art-group data 94))
                     num-func-identity
                     )
                   (set! (-> s4-0 frame-num) 0.0)
                   )
                 f30-0
                 )
                (else
                  (case (if (> (-> self skel active-channels) 0)
                            (-> self skel root-channel 0 frame-group)
                            )
                    (((-> self draw art-group data 63)
                      (-> self draw art-group data 66)
                      (-> self draw art-group data 64)
                      (-> self draw art-group data 67)
                      )
                     (ja-channel-push! 1 22)
                     (set! gp-0 120)
                     (let ((s4-1 (-> self skel root-channel 0)))
                       (joint-control-channel-group-eval!
                         s4-1
                         (the-as art-joint-anim (-> self draw art-group data 94))
                         num-func-identity
                         )
                       (set! (-> s4-1 frame-num) (ja-aframe (the-as float 124.0) 0))
                       )
                     -16384.0
                     )
                    (else
                      (ja-channel-push! 1 22)
                      (let ((s4-2 (-> self skel root-channel 0)))
                        (joint-control-channel-group-eval!
                          s4-2
                          (the-as art-joint-anim (-> self draw art-group data 94))
                          num-func-identity
                          )
                        (set! (-> s4-2 frame-num) 0.0)
                        )
                      f30-0
                      )
                    )
                  )
                )
              )
        )
      (while #t
        (if (and (or (zero? (logand (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-abs 0)
                                    (pad-buttons square)
                                    )
                            )
                     (-> self control unknown-spoolanim00)
                     )
                 (>= (- (-> *display* base-frame-counter) (-> self state-time)) gp-0)
                 )
            (go target-swim-up)
            )
        (if (or (>= (- (-> *display* base-frame-counter) (-> self state-time)) s5-0)
                (and (logtest? (-> self control status) 1)
                     (and (< (-> self water swim-depth) 8192.0)
                          (>= (- (-> *display* base-frame-counter) (-> self state-time)) gp-0)
                          )
                     )
                )
            (go target-swim-up)
            )
        (let ((s4-3 (new-stack-vector0))
              (f24-0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
              )
          0.0
          (vector-! s4-3 (-> self control transv) (vector-float*! s4-3 (-> self control dynam gravity-normal) f24-0))
          (let* ((f28-0 (vector-length s4-3))
                 (f26-0 f28-0)
                 (f24-1 (+ f24-0 f30-0))
                 )
            (set! f30-0
                  (seek f30-0 (the-as float (-> (new 'static 'array int32 1 0) 0)) (* 32768.0 (-> *display* seconds-per-frame)))
                  )
            (vector+!
              (-> self control transv)
              (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f24-1)
              (vector-float*! s4-3 s4-3 (/ f28-0 f26-0))
              )
            )
          )
        (suspend)
        (let ((s4-4 (-> self skel root-channel 0)))
          (set! (-> s4-4 param 0) (lerp-scale
                                    (the-as float 0.4)
                                    (the-as float 1.0)
                                    (vector-length (-> self control transv))
                                    (the-as float (-> (new 'static 'array int32 1 0) 0))
                                    (the-as float 16384.0)
                                    )
                )
          (joint-control-channel-group-eval! s4-4 (the-as art-joint-anim #f) num-func-loop!)
          )
        )
      )
    (none)
    )
  :post
  target-swim-post
  )

;; failed to figure out what this is:
(defstate target-swim-up (target)
  :event
  (-> target-swim-down event)
  :enter
  (-> target-swim-down enter)
  :exit
  (-> target-swim-down exit)
  :trans
  (behavior ()
    (if (and (logtest? (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 0) (pad-buttons x))
             (zero? (logand (-> self state-flags) 2048))
             (zero? (logand (-> self water flags) #x6000))
             )
        (go
          target-swim-jump-jump
          (-> *TARGET-bank* swim-jump-height-min)
          (-> *TARGET-bank* swim-jump-height-max)
          (the-as surface #f)
          )
        )
    (when (and (>= (- (-> *display* base-frame-counter) (-> self state-time)) 3000)
               (< (target-move-dist (the-as int (-> *TARGET-bank* stuck-time))) (-> *TARGET-bank* stuck-distance))
               )
      (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-1 from) self)
        (set! (-> a1-1 num-params) 2)
        (set! (-> a1-1 message) 'attack)
        (set! (-> a1-1 param 0) (the-as uint #f))
        (let ((a0-8 (new 'static 'attack-info :mask #x20)))
          (set! (-> a0-8 mode) 'drown-death)
          (set! (-> a1-1 param 1) (the-as uint a0-8))
          )
        (send-event-function self a1-1)
        )
      )
    ((-> target-swim-down trans))
    (none)
    )
  :code
  (behavior ()
    (ja-channel-push! 1 30)
    (let ((f30-0 1.0))
      (let ((gp-0 #t))
        (let ((a0-1 (-> self skel root-channel 0)))
          (set! (-> a0-1 frame-group) (the-as art-joint-anim (-> self draw art-group data 95)))
          (set! (-> a0-1 param 0)
                (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 95)) data 0 length) -1))
                )
          (set! (-> a0-1 param 1) 1.0)
          (set! (-> a0-1 frame-num) 0.0)
          (joint-control-channel-group! a0-1 (the-as art-joint-anim (-> self draw art-group data 95)) num-func-seek!)
          )
        (until (ja-done? 0)
          (target-swim-tilt
            (the-as float (if (< 8192.0 (-> self water swim-depth))
                              0.5
                              (-> (new 'static 'array int32 1 0) 0)
                              )
                    )
            (the-as float 1.0)
            (the-as float (-> (new 'static 'array int32 1 0) 0))
            (the-as float 0.1)
            )
          (if (and (zero? (logand (-> self water flags) 4096))
                   (or (>= (ja-aframe-num 0) 222.0)
                       (and (!= (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) stick0-speed) 0.0)
                            (>= (ja-aframe-num 0) 200.0)
                            )
                       )
                   )
              (goto cfg-37)
              )
          (TODO-RENAME-9 (-> self align))
          (when (zero? (logand (-> self water flags) 4096))
            (logior! (-> self water flags) 16)
            (set! gp-0 #f)
            )
          (if gp-0
              (TODO-RENAME-10 (-> self align) 2 (the-as float 1.0) (the-as float 1.0) (the-as float 1.0))
              )
          (suspend)
          (let ((a0-9 (-> self skel root-channel 0)))
            (set! (-> a0-9 param 0) (the float (+ (-> a0-9 frame-group data 0 length) -1)))
            (set! (-> a0-9 param 1) 1.0)
            (joint-control-channel-group-eval! a0-9 (the-as art-joint-anim #f) num-func-seek!)
            )
          )
        )
      (let ((gp-1 (-> self skel root-channel 0)))
        (joint-control-channel-group-eval!
          gp-1
          (the-as art-joint-anim (-> self draw art-group data 96))
          num-func-identity
          )
        (set! (-> gp-1 frame-num) 0.0)
        )
      (while #t
        (target-swim-tilt
          (the-as float (if (< 8192.0 (-> self water swim-depth))
                            0.3
                            (-> (new 'static 'array int32 1 0) 0)
                            )
                  )
          (the-as float 1.0)
          (the-as float (-> (new 'static 'array int32 1 0) 0))
          (the-as float 0.1)
          )
        (if (zero? (logand (-> self water flags) 4096))
            (goto cfg-37)
            )
        (if (logtest? (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) button0-rel 0) (pad-buttons x))
            (set! f30-0 2.0)
            )
        (TODO-RENAME-9 (-> self align))
        (when (logtest? (-> self water flags) 4096)
          (TODO-RENAME-10 (-> self align) 2 (the-as float 1.0) (the-as float 1.0) (the-as float 1.0))
          (set! (-> self control transv y) (+ 8192.0 (* 8192.0 f30-0)))
          )
        (suspend)
        (let ((a0-16 (-> self skel root-channel 0)))
          (set! (-> a0-16 param 0) f30-0)
          (joint-control-channel-group-eval! a0-16 (the-as art-joint-anim #f) num-func-loop!)
          )
        (set! f30-0 (seek f30-0 (the-as float 1.0) (-> *display* seconds-per-frame)))
        )
      )
    (label cfg-37)
    (logior! (-> self water flags) 16)
    (set! (-> self water swim-time) (the-as uint (-> *display* base-frame-counter)))
    (start-bobbing! (-> self water) (the-as float -4096.0) 600 1500)
    (set! (-> self water bob start-time) (+ (-> *display* base-frame-counter) -15))
    (go target-swim-stance)
    (none)
    )
  :post
  target-swim-post
  )

;; failed to figure out what this is:
(defstate target-swim-jump-jump (target)
  :event
  (-> target-jump event)
  :enter
  (-> target-jump enter)
  :exit
  target-exit
  :trans
  (behavior ()
    (cond
      ((< (- (-> *display* base-frame-counter) (-> self state-time)) 150)
       (set! (-> self water flags) (logior #x10000 (-> self water flags)))
       (set! (-> self control status) (logand -8 (-> self control status)))
       )
      (else
        (set! (-> self trans-hook) (-> target-jump trans))
        )
      )
    ((-> target-jump trans))
    (none)
    )
  :code
  (-> target-jump code)
  :post
  (the-as (function none :behavior target) target-post)
  )

;; failed to figure out what this is:
(defstate target-swim-jump (target)
  :event
  target-standard-event-handler
  :enter
  (-> target-swim-stance enter)
  :exit
  (behavior ()
    ((-> target-swim-stance exit))
    (die-on-next-update! (-> self water bob))
    (set! (-> self water align-offset) 0.0)
    (set! (-> self water flags) (logior #x10000 (-> self water flags)))
    (none)
    )
  :code
  (behavior ((arg0 float) (arg1 float))
    (die-on-next-update! (-> self water bob))
    (ja-channel-push! 1 15)
    (let ((s4-0 (-> self skel root-channel 0)))
      (joint-control-channel-group-eval!
        s4-0
        (the-as art-joint-anim (-> self draw art-group data 98))
        num-func-identity
        )
      (set! (-> s4-0 frame-num) 0.0)
      )
    (until (and (ja-done? 0) (= (-> self skel root-channel 0) (-> self skel channel)))
      (TODO-RENAME-9 (-> self align))
      (if (zero? (logand (-> self align flags) 1))
          (+! (-> self water align-offset) (* 0.6 (-> self align delta trans y)))
          )
      (suspend)
      (when (= (-> self skel root-channel 0) (-> self skel channel))
        (let ((a0-8 (-> self skel root-channel 0)))
          (set! (-> a0-8 param 0) (the float (+ (-> a0-8 frame-group data 0 length) -1)))
          (set! (-> a0-8 param 1) 2.0)
          (joint-control-channel-group-eval! a0-8 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      )
    (let ((f30-0 (fmax 0.0 (- (-> self water bob-offset)))))
      (let ((s4-1 (new-stack-vector0)))
        (let ((f0-8 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
          0.0
          (vector-! s4-1 (-> self control transv) (vector-float*! s4-1 (-> self control dynam gravity-normal) f0-8))
          )
        (let* ((f0-9 (vector-length s4-1))
               (f1-5 f0-9)
               (f2-1 0.4096)
               )
          (vector+!
            (-> self control transv)
            (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-1)
            (vector-float*! s4-1 s4-1 (/ f0-9 f1-5))
            )
          )
        )
      (go target-swim-jump-jump (+ f30-0 arg0) (+ f30-0 arg1) (the-as surface #f))
      )
    (none)
    )
  :post
  target-swim-post
  )

;; failed to figure out what this is:
(defstate target-hit-ground-hard (target)
  :event
  target-standard-event-handler
  :enter
  (behavior ((arg0 float))
    (set! (-> self control unknown-dword31) 0)
    (set! (-> self control unknown-dword33) 0)
    (set-forward-vel (the-as float (-> (new 'static 'array int32 1 0) 0)))
    (set! (-> self control unknown-surface00) *walk-mods*)
    (none)
    )
  :code
  (behavior ((arg0 float))
    (when (!= arg0 0.0)
      (let ((f0-5 (the float (the int (+ 1.0 (/ (- arg0 (-> *TARGET-bank* fall-far)) (-> *TARGET-bank* fall-far-inc))))))
            )
        (pickup-collectable!
          (-> self fact-info-target)
          (pickup-type eco-green)
          (* (-> *FACT-bank* health-single-inc) (- (fmax 0.0 f0-5)))
          (the-as handle #f)
          )
        )
      (if (zero? (logand (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons l3)))
          (target-timed-invulnerable (-> *TARGET-bank* hit-invulnerable-timeout) self)
          )
      )
    (cond
      ((and (= (-> self game mode) 'play) (>= 0.0 (-> self fact-info-target health)))
       (set! (-> self attack-info attacker) (the-as handle #f))
       (go target-death 'target-hit-ground-hard)
       )
      (else
        (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 30)
        (ja-channel-push! 1 1)
        (let ((gp-0 (-> self skel root-channel 0)))
          (joint-control-channel-group-eval!
            gp-0
            (the-as art-joint-anim (-> self draw art-group data 36))
            num-func-identity
            )
          (set! (-> gp-0 frame-num) 0.0)
          )
        (until (and (ja-done? 0) (= (-> self skel root-channel 0) (-> self skel channel)))
          (suspend)
          (when (= (-> self skel root-channel 0) (-> self skel channel))
            (let ((a0-12 (-> self skel root-channel 0)))
              (set! (-> a0-12 param 0) (the float (+ (-> a0-12 frame-group data 0 length) -1)))
              (set! (-> a0-12 param 1) 1.0)
              (joint-control-channel-group-eval! a0-12 (the-as art-joint-anim #f) num-func-seek!)
              )
            )
          )
        (let ((gp-1 (-> self skel root-channel 0)))
          (joint-control-channel-group-eval!
            gp-1
            (the-as art-joint-anim (-> self draw art-group data 37))
            num-func-identity
            )
          (set! (-> gp-1 frame-num) 0.0)
          )
        (until (and (ja-done? 0) (= (-> self skel root-channel 0) (-> self skel channel)))
          (suspend)
          (when (= (-> self skel root-channel 0) (-> self skel channel))
            (let ((a0-20 (-> self skel root-channel 0)))
              (set! (-> a0-20 param 0) (the float (+ (-> a0-20 frame-group data 0 length) -1)))
              (set! (-> a0-20 param 1) 1.0)
              (joint-control-channel-group-eval! a0-20 (the-as art-joint-anim #f) num-func-seek!)
              )
            )
          )
        (go target-stance)
        )
      )
    (none)
    )
  :post
  target-no-stick-post
  )

;; failed to figure out what this is:
(defstate target-launch (target)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (if (and (= arg2 'query) (= (-> arg3 param 0) 'mode))
        'target-launch
        (target-standard-event-handler arg0 arg1 arg2 arg3)
        )
    )
  :code
  (behavior ((arg0 float) (arg1 symbol) (arg2 vector) (arg3 int))
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (set! (-> self control unknown-surface00) *turn-around-mods*)
    (ja-channel-push! 1 45)
    (set-forward-vel (the-as float (-> (new 'static 'array int32 1 0) 0)))
    (let ((s2-0 (-> self skel root-channel 0)))
      (set! (-> s2-0 frame-group) (the-as art-joint-anim (-> self draw art-group data 31)))
      (set! (-> s2-0 param 0) (ja-aframe (the-as float 15.0) 0))
      (set! (-> s2-0 param 1) 3.0)
      (set! (-> s2-0 frame-num) 0.0)
      (joint-control-channel-group! s2-0 (the-as art-joint-anim (-> self draw art-group data 31)) num-func-seek!)
      )
    (until (ja-done? 0)
      (suspend)
      (let ((s2-1 (-> self skel root-channel 0)))
        (set! (-> s2-1 param 0) (ja-aframe (the-as float 15.0) 0))
        (set! (-> s2-1 param 1) 3.0)
        (joint-control-channel-group-eval! s2-1 (the-as art-joint-anim #f) num-func-seek!)
        )
      )
    (if arg1
        (send-event *camera* 'change-state arg1 180)
        )
    (when (nonzero? arg3)
      (let ((s3-1 (get-process *default-dead-pool* process #x4000)))
        (when s3-1
          (let ((t9-9 (method-of-type process activate)))
            (t9-9 s3-1 self 'process (the-as pointer #x70004000))
            )
          (run-next-time-in-process
            s3-1
            (lambda :behavior target
              ((arg0 vector) (arg1 int) (arg2 float))
              (local-vars (sv-32 int) (sv-40 vector) (sv-44 symbol))
              (set! sv-32 (-> *display* base-frame-counter))
              (let ((v1-2 (new-stack-vector0)))
                (set! (-> v1-2 quad) (-> arg0 quad))
                (set! sv-40 v1-2)
                )
              (set! sv-44 #t)
              (until (>= (- (-> *display* base-frame-counter) sv-32) arg1)
                (let ((s4-0 (ppointer->process (-> self parent))))
                  (cond
                    ((and sv-44
                          (< (- (-> (the-as target s4-0) control trans y) (-> (the-as target s4-0) control unknown-vector52 y)) arg2)
                          )
                     (vector-xz-normalize!
                       (-> (the-as target s4-0) control transv)
                       (the-as float (-> (new 'static 'array int32 1 0) 0))
                       )
                     (case (-> (the-as target s4-0) current-level name)
                       (('jungleb)
                        (let ((v1-16 (vector-! (new-stack-vector0) (-> (the-as target s4-0) control trans) sv-40)))
                          (set! (-> (the-as target s4-0) control trans x) (+ (-> sv-40 x) (fmax -4096.0 (fmin 4096.0 (-> v1-16 x)))))
                          (set! (-> (the-as target s4-0) control trans z) (+ (-> sv-40 z) (fmax -4096.0 (fmin 4096.0 (-> v1-16 z)))))
                          )
                        )
                       )
                     )
                    (else
                      (if sv-44
                          (set! sv-32 (-> *display* base-frame-counter))
                          )
                      (set! sv-44 (the-as symbol #f))
                      (when (or (= (-> (the-as target s4-0) next-state name) 'target-duck-high-jump-jump)
                                (= (-> (the-as target s4-0) next-state name) 'target-falling)
                                )
                        (let ((v1-30 (-> (the-as target s4-0) control trans))
                              (s3-0 (-> (the-as target s4-0) control transv))
                              )
                          (set! (-> s3-0 x) (- (-> sv-40 x) (-> v1-30 x)))
                          (set! (-> s3-0 z) (- (-> sv-40 z) (-> v1-30 z)))
                          (let ((f30-0 (vector-xz-length s3-0)))
                            (if (< 122880.0 f30-0)
                                (vector-xz-normalize! s3-0 (the-as float 122880.0))
                                )
                            (if (< 4096.0 f30-0)
                                (forward-up-nopitch->quaternion
                                  (-> (the-as target s4-0) control dir-targ)
                                  (vector-normalize-copy! (new 'stack-no-clear 'vector) s3-0 (the-as float 1.0))
                                  (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> (the-as target s4-0) control quat))
                                  )
                                )
                            )
                          )
                        )
                      )
                    )
                  )
                (suspend)
                0
                )
              #f
              )
            arg2
            arg3
            (-> (new 'static 'array float 1 143360.0) 0)
            )
          (-> s3-1 ppointer)
          )
        )
      )
    (sound-play-by-name (static-sound-name "launch-fire") (new-sound-id) 1024 0 0 1 #t)
    (go target-high-jump arg0 arg0 'launch)
    (none)
    )
  :post
  target-no-stick-post
  )

;; failed to figure out what this is:
(defstate target-periscope (target)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (case arg2
      (('change-mode)
       #f
       )
      (('end-mode)
       (when (-> self control unknown-spoolanim00)
         (set! (-> self control unknown-uint20) (the-as uint #f))
         #t
         )
       )
      (else
        (target-generic-event-handler arg0 arg1 arg2 arg3)
        )
      )
    )
  :exit
  (behavior ()
    (target-exit)
    (set! (-> self cam-user-mode) 'normal)
    (logior! (-> self state-flags) 256)
    (set! (-> self state-flags) (logand -17 (-> self state-flags)))
    (none)
    )
  :code
  (behavior ((arg0 handle))
    (set! (-> self neck flex-blend) 0.0)
    (target-exit)
    (logior! (-> self state-flags) 144)
    (let ((v1-4 (handle->process arg0)))
      (if v1-4
          (quaterion<-rotate-y-vector (-> self control dir-targ) (vector-!
                                                                   (new 'stack-no-clear 'vector)
                                                                   (-> (the-as process-drawable v1-4) root trans)
                                                                   (-> self control trans)
                                                                   )
                                      )
          )
      )
    (set! (-> self control unknown-uint20) (the-as uint #t))
    (ja-channel-push! 1 30)
    (let ((a0-11 (-> self skel root-channel 0)))
      (set! (-> a0-11 frame-group) (the-as art-joint-anim (-> self draw art-group data 101)))
      (set! (-> a0-11 param 0)
            (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 101)) data 0 length) -1))
            )
      (set! (-> a0-11 param 1) 1.0)
      (set! (-> a0-11 frame-num) 0.0)
      (joint-control-channel-group! a0-11 (the-as art-joint-anim (-> self draw art-group data 101)) num-func-seek!)
      )
    (until (ja-done? 0)
      (suspend)
      (let ((a0-12 (-> self skel root-channel 0)))
        (set! (-> a0-12 param 0) (the float (+ (-> a0-12 frame-group data 0 length) -1)))
        (set! (-> a0-12 param 1) 1.0)
        (joint-control-channel-group-eval! a0-12 (the-as art-joint-anim #f) num-func-seek!)
        )
      )
    (send-event (handle->process arg0) 'change-mode)
    (while (-> self control unknown-spoolanim00)
      (suspend)
      )
    (let ((a0-16 (-> self skel root-channel 0)))
      (set! (-> a0-16 frame-group) (the-as art-joint-anim (-> self draw art-group data 101)))
      (set! (-> a0-16 param 0) 0.0)
      (set! (-> a0-16 param 1) 2.0)
      (set! (-> a0-16 frame-num)
            (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 101)) data 0 length) -1))
            )
      (joint-control-channel-group! a0-16 (the-as art-joint-anim (-> self draw art-group data 101)) num-func-seek!)
      )
    (until (ja-done? 0)
      (suspend)
      (let ((a0-17 (-> self skel root-channel 0)))
        (set! (-> a0-17 param 0) 0.0)
        (set! (-> a0-17 param 1) 2.0)
        (joint-control-channel-group-eval! a0-17 (the-as art-joint-anim #f) num-func-seek!)
        )
      )
    (go target-stance)
    (none)
    )
  :post
  target-no-stick-post
  )

;; failed to figure out what this is:
(defstate target-play-anim (target)
  :event
  target-generic-event-handler
  :enter
  (behavior ((arg0 string) (arg1 handle))
    (set! (-> self control unknown-handle10) arg1)
    (move-to-ground
      (-> self control)
      (the-as float 40960.0)
      (the-as float 40960.0)
      #f
      (-> self control root-prim collide-with)
      )
    (logior! (-> self state-flags) 256)
    (set! (-> self neck flex-blend) 0.0)
    (none)
    )
  :exit
  (behavior ()
    (send-event (handle->process (-> self control unknown-handle10)) 'end-mode)
    (target-exit)
    (none)
    )
  :code
  (behavior ((arg0 string) (arg1 handle))
    (let ((gp-0 (the-as art-joint-anim (lookup-art (-> self draw art-group) arg0 art-joint-anim))))
      (when gp-0
        (send-event (ppointer->process (-> self sidekick)) 'matrix 'play-anim)
        (ja-channel-set! 1)
        (let ((a0-4 (-> self skel root-channel 0)))
          (set! (-> a0-4 frame-group) gp-0)
          (set! (-> a0-4 param 0) (the float (+ (-> gp-0 data 0 length) -1)))
          (set! (-> a0-4 param 1) 1.0)
          (set! (-> a0-4 frame-num) 0.0)
          (joint-control-channel-group! a0-4 gp-0 num-func-seek!)
          )
        (until (ja-done? 0)
          (suspend)
          (let ((a0-5 (-> self skel root-channel 0)))
            (set! (-> a0-5 param 0) (the float (+ (-> a0-5 frame-group data 0 length) -1)))
            (set! (-> a0-5 param 1) 1.0)
            (joint-control-channel-group-eval! a0-5 (the-as art-joint-anim #f) num-func-seek!)
            )
          )
        (send-event (ppointer->process (-> self sidekick)) 'matrix 'normal)
        )
      )
    (go target-stance)
    (none)
    )
  :post
  target-no-stick-post
  )

;; failed to figure out what this is:
(defstate target-clone-anim (target)
  :event
  (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (if (and (= arg2 'trans) (= (-> arg3 param 0) 'restore))
        (set! (-> self control unknown-uint20) (the-as uint #f))
        )
    ((-> target-grab event) arg0 arg1 arg2 arg3)
    )
  :enter
  (behavior ((arg0 handle))
    (set! (-> self control unknown-handle10) arg0)
    (set! (-> self control unknown-vector102 quad) (-> self control trans quad))
    (set! (-> self control unknown-uint20) (the-as uint #t))
    (quaternion-copy! (the-as quaternion (-> self control unknown-vector103)) (-> self control quat))
    (logior! (-> self state-flags) 256)
    (vector-reset! (-> self control transv))
    (set! (-> self neck flex-blend) 0.0)
    (send-event (ppointer->process (-> self sidekick)) 'shadow #t)
    (none)
    )
  :exit
  (behavior ()
    (send-event (ppointer->process (-> self sidekick)) 'matrix 'normal)
    (send-event (ppointer->process (-> self sidekick)) 'shadow #t)
    (let ((gp-0 (-> self node-list data 3))
          (a1-2 (&-> (-> self control) unknown-qword00))
          )
      (cond
        ((not (-> self control unknown-spoolanim00))
         )
        ((zero? (logand (-> self draw status) (draw-status drwf01)))
         (move-to-point! (-> self control) (the-as vector a1-2))
         (matrix->quaternion (-> self control unknown-quaternion00) (-> gp-0 bone transform))
         (quaternion-copy! (-> self control quat) (-> self control unknown-quaternion00))
         (move-to-ground
           (-> self control)
           (the-as float 4096.0)
           (the-as float 40960.0)
           #t
           (-> self control root-prim collide-with)
           )
         (when (logtest? (-> self control status) 1024)
           (let ((a1-6 (new-stack-vector0)))
             (set! (-> a1-6 x) (-> self control trans x))
             (set! (-> a1-6 y) (-> self water height))
             (set! (-> a1-6 z) (-> self control trans z))
             (set! (-> a1-6 w) 1.0)
             (move-to-point! (-> self control) a1-6)
             )
           )
         )
        (else
          (format 0 "ERROR: <ASG>: camera used backup position~%")
          (move-to-point! (-> self control) (-> self control unknown-vector102))
          (quaternion-copy! (-> self control quat) (the-as quaternion (-> self control unknown-vector103)))
          )
        )
      )
    (rot->dir-targ! (-> self control))
    (logior! (-> self control status) 7)
    (set! (-> self control unknown-dword11) (-> *display* base-frame-counter))
    (ja-channel-set! 0)
    (ja-post)
    (target-exit)
    (none)
    )
  :code
  (behavior ((arg0 handle))
    (clone-anim arg0 (the-as int (-> self draw origin-joint-index)) #t "")
    (go target-stance)
    (none)
    )
  :post
  target-no-ja-move-post
  )
