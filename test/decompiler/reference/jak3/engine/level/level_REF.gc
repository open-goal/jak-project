;;-*-Lisp-*-
(in-package goal)

;; definition for function level-memory-mode->string
(defun level-memory-mode->string ((arg0 level-memory-mode))
  "Convert level-memory-mode enum to string."
  (case arg0
    (((level-memory-mode large))
     "large"
     )
    (((level-memory-mode city-center))
     "city-center"
     )
    (((level-memory-mode tiny))
     "tiny"
     )
    (((level-memory-mode borrow1))
     "borrow1"
     )
    (((level-memory-mode borrow))
     "borrow"
     )
    (((level-memory-mode small-center))
     "small-center"
     )
    (((level-memory-mode alias))
     "alias"
     )
    (((level-memory-mode borrow2))
     "borrow2"
     )
    (((level-memory-mode tiny-edge))
     "tiny-edge"
     )
    (((level-memory-mode borrow-city-small))
     "borrow-city-small"
     )
    (((level-memory-mode borrow3))
     "borrow3"
     )
    (((level-memory-mode medium))
     "medium"
     )
    (((level-memory-mode tiny-center-micro))
     "tiny-center-micro"
     )
    (((level-memory-mode small-edge))
     "small-edge"
     )
    (((level-memory-mode borrow4))
     "borrow4"
     )
    (((level-memory-mode tiny-center))
     "tiny-center"
     )
    (((level-memory-mode city-tiny-edge))
     "city-tiny-edge"
     )
    (((level-memory-mode tiny-center-small))
     "tiny-center-small"
     )
    (((level-memory-mode borrow0))
     "borrow0"
     )
    (((level-memory-mode micro))
     "micro"
     )
    (else
      "*unknown*"
      )
    )
  )

;; definition for function lookup-level-info
;; WARN: Return type mismatch object vs level-load-info.
(defun lookup-level-info ((arg0 symbol))
  "Get the level load info. Symbol can be the level name, visname, nickname, or a symbol that contains a level-load-info value."
  (the-as
    level-load-info
    (cond
      (arg0
        (let ((v1-0 (-> arg0 value)))
          (if (and (nonzero? v1-0)
                   v1-0
                   (= (logand (the-as int v1-0) 7) 4)
                   (= (-> (the-as basic v1-0) type) level-load-info)
                   )
              (return (the-as level-load-info v1-0))
              )
          )
        (let* ((v1-2 *level-load-list*)
               (a1-5 (car v1-2))
               )
          (while (not (null? v1-2))
            (let ((a1-6 (the-as level-load-info (-> (the-as symbol a1-5) value))))
              (if (or (= arg0 (-> a1-6 name)) (= arg0 (-> a1-6 visname)) (= arg0 (-> a1-6 nickname)))
                  (return a1-6)
                  )
              )
            (set! v1-2 (cdr v1-2))
            (set! a1-5 (car v1-2))
            )
          )
        default-level
        )
      (else
        default-level
        )
      )
    )
  )

;; definition for method 9 of type level-load-info
(defmethod get-callback-symbol-value-by-slot! ((this level-load-info) (arg0 int))
  "Look up value of symbol in callback-list with the given int as the car. Print warning if symbol's value is 0."
  (let* ((v1-0 (the-as object (-> this callback-list)))
         (a2-0 (-> (the-as pair v1-0) car))
         )
    (while (not (null? v1-0))
      (let ((a3-1 (/ (the-as int (-> (the-as pair a2-0) car)) 8))
            (t0-0 (-> (the-as pair a2-0) cdr))
            )
        (when (= a3-1 arg0)
          (cond
            ((nonzero? (-> (the-as symbol t0-0) value))
             (return (-> (the-as symbol t0-0) value))
             )
            (else
              (format 0 "WARNING: level ~A has undefined callback slot ~D with value ~A~%" (-> this name) a3-1 t0-0)
              (return #f)
              )
            )
          (set! v1-0 0)
          )
        )
      (set! v1-0 (-> (the-as pair v1-0) cdr))
      (set! a2-0 (-> (the-as pair v1-0) car))
      )
    )
  #f
  )

;; definition for method 10 of type level-load-info
;; WARN: Return type mismatch pair vs object.
(defmethod get-callback-by-slot! ((this level-load-info) (arg0 int))
  "Look up value in callback-list with the given int as the car and return it. Doesn't derefence the symbol."
  (let* ((v1-0 (-> this callback-list))
         (a0-1 (car v1-0))
         )
    (while (not (null? v1-0))
      (let ((a2-1 (/ (the-as int (car a0-1)) 8))
            (a0-2 (cdr a0-1))
            )
        (if (= a2-1 arg0)
            (return (the-as object a0-2))
            )
        )
      (set! v1-0 (cdr v1-0))
      (set! a0-1 (car v1-0))
      )
    )
  (the-as pair #f)
  )

;; definition for method 28 of type level-group
(defmethod load-in-progress? ((this level-group))
  "Is there a load happening now?"
  (!= (-> *level* loading-level) (-> *level* level-default))
  )

;; definition for method 11 of type level-group
(defmethod get-level-by-heap-ptr-and-status ((this level-group) (arg0 pointer) (arg1 symbol))
  "Look up a loaded level, given pointer inside of level's heap,
   and the status of the level (active or loading)."
  (case arg1
    (('active)
     (dotimes (v1-1 (-> this length))
       (let ((a2-6 (-> this level v1-1)))
         (when (= (-> a2-6 status) 'active)
           (if (and (>= (the-as int arg0) (the-as int (-> a2-6 heap base)))
                    (< (the-as int arg0) (the-as int (-> a2-6 heap top-base)))
                    )
               (return a2-6)
               )
           )
         )
       )
     )
    (('loading)
     (dotimes (v1-5 (-> this length))
       (let ((a2-12 (-> this level v1-5)))
         (when (!= (-> a2-12 status) 'inactive)
           (if (and (>= (the-as int arg0) (the-as int (-> a2-12 heap base)))
                    (< (the-as int arg0) (the-as int (-> a2-12 heap top-base)))
                    )
               (return a2-12)
               )
           )
         )
       )
     )
    )
  (the-as level #f)
  )

;; definition for method 29 of type level-group
;; WARN: Return type mismatch object vs symbol.
(defmethod is-load-allowed? ((this level-group) (arg0 (pointer symbol)))
  "Does the exclusive-load setting allow us to load this level?"
  (let ((v1-1 (the-as pair (-> *setting-control* user-current exclusive-load))))
    (if (or (not v1-1) (null? v1-1))
        (return (the-as symbol #t))
        )
    (let ((a0-4 (if arg0
                    (-> arg0 0)
                    'default
                    )
                )
          (v0-0 (the-as object #t))
          )
      (let ((a1-1 (car v1-1)))
        (while (not (null? v1-1))
          (case (car a1-1)
            (('allow)
             (if (= (car (cdr a1-1)) a0-4)
                 (return (the-as symbol #t))
                 )
             (if (= (car (cdr a1-1)) 'all)
                 (set! v0-0 #t)
                 )
             )
            (('ignore)
             (if (= (car (cdr a1-1)) a0-4)
                 (return (the-as symbol #f))
                 )
             (if (= (car (cdr a1-1)) 'all)
                 (set! v0-0 #f)
                 )
             )
            )
          (set! v1-1 (cdr v1-1))
          (set! a1-1 (car v1-1))
          )
        )
      (the-as symbol v0-0)
      )
    )
  )

;; definition for function remap-level-name
(defun remap-level-name ((arg0 level-load-info))
  "Get the load name, depending on if we should load a vis level or not."
  (if (-> *level* vis?)
      (-> arg0 visname)
      (-> arg0 name)
      )
  )

;; definition for method 21 of type level
(defmethod get-art-group-by-name ((this level) (arg0 string))
  "Look up art-group in this level by name."
  (countdown (s4-0 (-> this art-group art-group-array length))
    (if (name= (-> this art-group art-group-array s4-0 name) arg0)
        (return (-> this art-group art-group-array s4-0))
        )
    )
  (the-as art-group #f)
  )

;; definition for method 13 of type level
(defmethod bsp-name ((this level))
  "Try getting the name from the BSP. If that fails, return the level's name (typically the same)."
  (if (and (!= (-> this status) 'inactive) (-> this bsp) (nonzero? (-> this bsp name)))
      (-> this bsp name)
      (-> this name)
      )
  )

;; definition for function add-bsp-drawable
(defun add-bsp-drawable ((arg0 bsp-header) (arg1 level) (arg2 symbol) (arg3 display-frame))
  "Callback function used by background-engine to draw a bsp.
   Note that most drawing work has been moved into finish-background,
   and the draw method called here just adds references to high-level rendering data
   to lists. The exception is debug-draw, which does run here (only for draw-strip-lines)."
  (draw arg0)
  (if (nonzero? *display-strip-lines*)
      (debug-draw arg0)
      )
  (none)
  )

;; definition for method 2 of type level
(defmethod print ((this level))
  (format #t "#<~A ~A ~S @ #x~X>" (-> this type) (-> this status) (-> this name) this)
  this
  )

;; definition for method 7 of type bsp-header
(defmethod relocate ((this bsp-header) (offset int))
  (let ((gp-0 (-> *level* loading-level)))
    (when gp-0
      (cond
        (this
          (cond
            ((not (type? this bsp-header))
             (format 0 "ERROR: level ~A is not a bsp-header.~%" (-> gp-0 name))
             (the-as bsp-header #f)
             )
            ((not (file-info-correct-version? (-> this info) (file-kind level-bt) 0))
             (the-as bsp-header #f)
             )
            ((< 2048 (-> this visible-list-length))
             (format
               0
               "ERROR: level ~A visible-list-length ~d is greater than 2048 (16384 drawables).~%"
               (-> gp-0 name)
               (-> this visible-list-length)
               )
             (the-as bsp-header #f)
             )
            (else
              (set! (-> gp-0 bsp) this)
              (set! (-> this level) gp-0)
              this
              )
            )
          )
        (else
          (format 0 "ERROR: level ~A is not a valid file.~%" (-> gp-0 name))
          (the-as bsp-header #f)
          )
        )
      )
    )
  )

;; definition for method 27 of type level
;; WARN: Return type mismatch level vs none.
(defmethod load-common-package ((this level))
  "Somewhat useless leftover from a more compliated package system. Will load common in some cases."
  (when (not (or (not (-> this bsp)) (= *kernel-boot-mode* 'debug-boot)))
    (if (not (null? (-> this info packages)))
        (load-package "common" global)
        )
    )
  (none)
  )

;; definition for method 29 of type level
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod vis-clear ((this level))
  "Clear visibility data: both the info and the cached vis bits. Switch all-visible? to loading."
  (countdown (v1-0 8)
    (nop!)
    (set! (-> this vis-info v1-0) #f)
    )
  (dotimes (v1-3 128)
    (set! (-> (the-as (pointer int128) (&+ (-> this vis-bits) (* v1-3 16)))) 0)
    )
  (set! (-> this all-visible?) 'loading)
  0
  (none)
  )

;; definition for method 28 of type level
;; WARN: Return type mismatch int vs none.
(defmethod init-vis-from-bsp ((this level))
  "Link vis-infos from the bsp to the level."
  (when (not (or (= (-> this status) 'inactive) (not (-> this bsp))))
    (set! (-> this all-visible?) 'loading)
    (dotimes (s5-0 8)
      (let ((s4-0 (-> this bsp vis-info s5-0)))
        (cond
          ((and s4-0 (nonzero? s4-0) (valid? s4-0 level-vis-info (the-as string #f) #f 0))
           (set! (-> this vis-info s5-0) s4-0)
           (set! (-> s4-0 current-vis-string) (the-as uint -1))
           (if (= (-> s4-0 from-level) (-> this load-name))
               (set! (-> s4-0 from-bsp) (-> this bsp))
               (set! (-> s4-0 from-bsp) #f)
               )
           (set! (-> s4-0 vis-bits) (the-as uint (-> this vis-bits)))
           (set! (-> s4-0 flags)
                 (the-as vis-info-flag (logclear (-> s4-0 flags) (vis-info-flag in-iop loading vis-valid)))
                 )
           (set! *vis-boot* #t)
           )
          (else
            (set! (-> this vis-info s5-0) #f)
            )
          )
        )
      )
    )
  0
  (none)
  )

;; definition for method 12 of type level-group
(defmethod level-get-for-use ((this level-group) (arg0 symbol) (arg1 symbol))
  "Request a level by name in the given state.
   Will return quickly (non-blocking) and might not be able to get a level in the desired state,
   though it will do some small amount of work to make progress on loading.
   
   This is the most general/powerful function like this: if there is no level with this name
   it will kick out levels as needed to make a free slot, and set up a new level, and start
   the load. This should only be used when you might want to start a load."
  (local-vars (s5-1 level))
  (init-level-system this #f)
  (let* ((s2-0 (lookup-level-info arg0))
         (s1-0 (remap-level-name s2-0))
         )
    (let ((s5-0 (level-get this s1-0)))
      (when s5-0
        (level-status-update! s5-0 arg1)
        (set! s5-1 s5-0)
        (goto cfg-28)
        )
      )
    (let ((a0-7 (level-get-most-disposable this)))
      (set! s5-1 (if a0-7
                     (level-status-update! a0-7 'inactive)
                     a0-7
                     )
            )
      )
    (when (not level)
      (format 0 "ERROR: could not find a slot to load ~A into.~%" arg0)
      (set! s5-1 (the-as level #f))
      (goto cfg-28)
      )
    (let ((s0-0 (-> s2-0 master-level)))
      (when s0-0
        (let ((a0-10 (lookup-level-info s0-0)))
          (when (not (logtest? (level-flags lf17) (-> a0-10 level-flags)))
            (dotimes (v1-16 (-> this length))
              (let ((a0-15 (-> this level v1-16)))
                (when (or (= (-> a0-15 status) 'active) (= (-> a0-15 status) 'alive) (= (-> a0-15 status) 'loaded))
                  (if (= (-> a0-15 name) s0-0)
                      (goto cfg-24)
                      )
                  )
                )
              )
            (format 0 "ERROR: level ~A is loading before master-level ~A~%" arg0 s0-0)
            (break!)
            0
            )
          )
        )
      )
    (label cfg-24)
    (let ((v1-22 (+ (-> this load-order) 1)))
      (set! (-> this load-order) v1-22)
      (set! (-> s5-1 load-order) v1-22)
      )
    (set! (-> s5-1 info) s2-0)
    (set! (-> s5-1 name) arg0)
    (set! (-> s5-1 load-name) s1-0)
    )
  (dotimes (v1-23 11)
    (set! (-> s5-1 texture-anim-array v1-23) #f)
    )
  (set! (-> s5-1 display?) #f)
  (set! (-> s5-1 force-all-visible?) #f)
  (set! (-> s5-1 force-inside?) #f)
  (level-status-update! s5-1 'loading)
  (level-status-update! s5-1 arg1)
  (label cfg-28)
  s5-1
  )

;; definition for method 27 of type level-group
;; WARN: Return type mismatch int vs none.
(defmethod do-nothing ((this level-group))
  "Empty method."
  0
  (none)
  )

;; definition for method 26 of type level-group
(defmethod status-of-level-and-borrows ((this level-group) (arg0 symbol) (arg1 symbol))
  "Get the combined status of a level and borrow levels."
  (if (not arg0)
      (return #f)
      )
  (let ((s4-0 (level-get *level* arg0))
        (v1-3 (lookup-level-info arg0))
        )
    (cond
      (s4-0
        (when (and (or (= (-> s4-0 status) 'loaded) (= (-> s4-0 status) 'active))
                   (and (-> s4-0 info borrow) (!= arg1 'ignore-borrow))
                   )
          (dotimes (s3-1 5)
            (let ((v1-14 (-> s4-0 info borrow borrow-info s3-1)))
              (when v1-14
                (when (car (cdr v1-14))
                  (let ((v1-15 (status-of-level-and-borrows this (the-as symbol (car v1-14)) arg1)))
                    (if (!= v1-15 (-> s4-0 status))
                        (return v1-15)
                        )
                    )
                  )
                )
              )
            )
          )
        (-> s4-0 status)
        )
      ((and v1-3 (-> v1-3 borrow) (-> v1-3 borrow alias))
       (b!
         (not (or (= arg0 'ctywide-ff)
                  (= arg0 'ctywide-kg)
                  (= arg0 'ctywide-mh)
                  (= arg0 'ctywide-ff-kg)
                  (= arg0 'ctywide-ff-mh)
                  (= arg0 'ctywide-mh-kg)
                  )
              )
         cfg-42
         :delay (nop!)
         )
       (let ((s5-1 (the-as object *borrow-city-status-list*)))
         (b! #t cfg-43 :delay (nop!))
         (label cfg-42)
         (set! s5-1 (-> v1-3 borrow alias))
         (label cfg-43)
         (let* ((a0-26 s5-1)
                (s4-1 ((method-of-type (rtype-of a0-26) length) a0-26))
                )
           (while (and (> s4-1 0) (car s5-1))
             (when (and (!= (car s5-1) 'dummy)
                        (or (= arg1 'all) (let ((a0-31 (lookup-level-info (the-as symbol (car s5-1)))))
                                            (and a0-31 (not (logtest? (-> a0-31 level-flags) (level-flags lf15))))
                                            )
                            )
                        )
               (let ((v1-29 (status-of-level-and-borrows *level* (the-as symbol (car s5-1)) arg1)))
                 (if (!= v1-29 'active)
                     (return v1-29)
                     )
                 )
               )
             (set! s5-1 (cdr (cdr s5-1)))
             (+! s4-1 -2)
             )
           )
         )
       'active
       )
      )
    )
  )

;; definition for method 26 of type level
;; INFO: Used lq/sq
(defmethod level-status-update! ((this level) (arg0 symbol))
  "Try to update the level to the given status, calling whatever is needed to make it happen.
   This can do both loading, linking, login, and activation.
   This is somewhat similar to level-get-for-use, but requires that you already have the level object.
   This function is the way to transition from loaded to alive/active."
  (case arg0
    (('inactive)
     (-> this status)
     (unload! this)
     )
    (('loading)
     (case (-> this status)
       (('inactive)
        (load-begin this)
        )
       )
     )
    (('loading-bt)
     (case (-> this status)
       (('loading)
        (set! (-> this status) arg0)
        (do-nothing *level*)
        (load-continue this)
        )
       )
     )
    (('loading-done)
     (case (-> this status)
       (('loading-bt)
        (set! (-> this status) arg0)
        (do-nothing *level*)
        )
       )
     )
    (('loaded)
     (case (-> this status)
       (('loading-done)
        (login-begin this)
        )
       (('alive 'active)
        (deactivate this)
        )
       )
     )
    (('alive 'active)
     (when *dproc*
       (case (-> this status)
         (('loaded)
          (birth this)
          (level-status-update! this arg0)
          )
         (('alive)
          (when (and *dproc* (= arg0 'active))
            (when (zero? (-> this display-start-time))
              (set! (-> this display-start-time) (the-as uint (-> *display* real-clock frame-counter)))
              0
              )
            (remove-by-param1 *background-draw-engine* (the-as int (-> this bsp)))
            (add-connection *background-draw-engine* *dproc* add-bsp-drawable (-> this bsp) this #f)
            (dotimes (v1-49 20)
              (set! (-> this closest-object v1-49) 0.0)
              (set! (-> this texture-mask v1-49 mask quad) (the-as uint128 0))
              )
            (set! (-> this status) 'active)
            (do-nothing *level*)
            (assign-draw-indices *level*)
            )
          )
         )
       )
     )
    )
  this
  )

;; definition for symbol *login-state*, type login-state
(define *login-state* (new 'global 'login-state))

;; definition for symbol *print-login*, type symbol
(define *print-login* #t)

;; definition for function load-buffer-resize
;; WARN: Return type mismatch int vs none.
(defun load-buffer-resize ((arg0 level) (arg1 dgo-header))
  "Resize and relocate the DGO load buffers, making sure there is enough room to both load objects and heap alloc in the linker."
  (case (-> arg0 load-buffer-mode)
    (((level-memory-mode tiny))
     (set! (-> arg0 load-buffer-size) (the-as uint (min #x113000 (the-as int (-> arg0 load-buffer-size)))))
     )
    (((level-memory-mode tiny-edge))
     (set! (-> arg0 load-buffer-size) (+ (-> arg1 length) 2048))
     )
    )
  (let ((v1-4 (logand -64 (+ (-> arg0 load-buffer-size) 63))))
    (if (= arg1 (-> arg0 load-buffer 0))
        (set! (-> arg0 load-buffer 0) (- (-> arg0 load-buffer 1) v1-4))
        (set! (-> arg0 load-buffer 1)
              (the-as uint (&- (logand -64 (&+ (-> arg0 heap top-base) 0)) (the-as uint v1-4)))
              )
        )
    )
  (set! (-> arg0 heap top) (the-as pointer (-> arg0 load-buffer 0)))
  0
  (none)
  )

;; definition for method 17 of type level
(defmethod load-continue ((this level))
  "Main function to run level loading/linking.
   Called by the engine to make progress on loading levels."
  (local-vars (sv-16 symbol))
  (when (-> this linking)
    (when (nonzero? (link-resume))
      (set! (-> this linking) #f)
      (case (-> this status)
        (('loading)
         (when (not (-> *texture-relocate-later* memcpy))
           (cond
             ((= (-> this load-buffer-mode) (level-memory-mode borrow))
              (let ((a2-0 (logand -64 (&+ (-> this heap current) 63))))
                (dgo-load-continue a2-0 a2-0 a2-0)
                )
              )
             (else
               (load-buffer-resize this (-> this load-buffer-last))
               (dgo-load-continue
                 (the-as pointer (-> this load-buffer 0))
                 (the-as pointer (-> this load-buffer 1))
                 (logand -64 (&+ (-> this heap current) 63))
                 )
               )
             )
           )
         )
        (('loading-bt)
         (level-status-update! this 'loading-done)
         (level-status-update! this 'loaded)
         )
        )
      )
    (set! this this)
    (goto cfg-39)
    )
  (when (-> *texture-relocate-later* memcpy)
    (relocate-later)
    (load-buffer-resize this (-> this load-buffer-last))
    (dgo-load-continue
      (the-as pointer (-> this load-buffer 0))
      (the-as pointer (-> this load-buffer 1))
      (logand -64 (&+ (-> this heap current) 63))
      )
    (set! this this)
    (goto cfg-39)
    )
  (case (-> this status)
    (('loading)
     (set! sv-16 (the-as symbol #f))
     (let ((s5-0 (dgo-load-get-next (& sv-16))))
       (when s5-0
         (set! (-> this load-buffer-last) (the-as dgo-header s5-0))
         (+! (-> *level* load-size) (-> (the-as (pointer uint32) s5-0)))
         (set! (-> *level* load-time)
               (* 0.016666668 (the float (- (-> *display* real-clock integral-frame-counter) *dgo-time*)))
               )
         (set! (-> *level* load-login-time)
               (* 0.016666668 (the float (- (-> *display* real-clock integral-frame-counter) *dgo-time*)))
               )
         (cond
           ((not sv-16)
            (cond
              ((= (-> this load-buffer-mode) (level-memory-mode borrow))
               (cond
                 ((dgo-load-link (the-as dgo-header s5-0) (-> this heap) (the-as uint (-> this heap top-base)) *print-login* #f)
                  (when (not (-> *texture-relocate-later* memcpy))
                    (let ((a2-8 (logand -64 (&+ (-> this heap current) 63))))
                      (dgo-load-continue a2-8 a2-8 a2-8)
                      )
                    )
                  )
                 (else
                   (set! (-> this linking) #t)
                   )
                 )
               )
              ((dgo-load-link (the-as dgo-header s5-0) (-> this heap) (-> this load-buffer 1) *print-login* #f)
               (when (not (-> *texture-relocate-later* memcpy))
                 (load-buffer-resize this (the-as dgo-header s5-0))
                 (dgo-load-continue
                   (the-as pointer (-> this load-buffer 0))
                   (the-as pointer (-> this load-buffer 1))
                   (logand -64 (&+ (-> this heap current) 63))
                   )
                 )
               )
              (else
                (set! (-> this linking) #t)
                )
              )
            )
           (else
             (set! (-> this heap top) (-> this heap top-base))
             (level-status-update! this 'loading-bt)
             )
           )
         )
       )
     )
    (('login)
     (level-update-after-load this *login-state*)
     )
    (('loading-bt)
     (let ((a0-36 (logand -64 (&+ (-> this heap current) 63))))
       (cond
         ((dgo-load-link
            (the-as dgo-header a0-36)
            (-> this heap)
            (the-as uint (-> this heap top-base))
            *print-login*
            #t
            )
          (level-status-update! this 'loading-done)
          (level-status-update! this 'loaded)
          )
         (else
           (set! (-> this linking) #t)
           )
         )
       )
     )
    )
  (label cfg-39)
  this
  )

;; definition for function level-find-borrow-slot
;; WARN: Return type mismatch int vs none.
(defun level-find-borrow-slot ((borrower-level level) (mode level-memory-mode))
  "Set up a level to 'borrow' from another.
   This function finds the right 'host' level, which should
   have prepared a heap for this level. This level will then
   be configured to use this heap."
  (local-vars (a2-1 level) (found-slot symbol))
  (let ((host-level-borrow-slot -1))
    (dotimes (host-level-candidate-idx 10)
      (let ((host-level-candidate (-> *level* level host-level-candidate-idx)))
        (when (and (or (= (-> host-level-candidate status) 'active) (= (-> host-level-candidate status) 'loaded))
                   (and (-> host-level-candidate info borrow)
                        (begin
                          (let ((mode2 mode))
                            (set! found-slot
                                  (cond
                                    ((= mode2 (level-memory-mode borrow))
                                     (dotimes (host-level-slot-idx 5)
                                       (when (and (-> host-level-candidate info borrow borrow-info host-level-slot-idx)
                                                  (= (car (-> host-level-candidate info borrow borrow-info host-level-slot-idx)) (-> borrower-level name))
                                                  (nonzero? (-> host-level-candidate info borrow borrow-size host-level-slot-idx))
                                                  )
                                         (set! host-level-borrow-slot host-level-slot-idx)
                                         (set! found-slot #t)
                                         (goto cfg-70)
                                         )
                                       )
                                     #f
                                     )
                                    ((= mode2 (level-memory-mode borrow-city-small))
                                     (when (= (-> borrower-level info master-level) (-> host-level-candidate name))
                                       (dotimes (t0-13 3)
                                         (when (not (-> host-level-candidate borrow-level t0-13))
                                           (set! host-level-borrow-slot t0-13)
                                           (set! found-slot #t)
                                           (goto cfg-70)
                                           )
                                         )
                                       #f
                                       )
                                     )
                                    ((= mode2 (level-memory-mode borrow0))
                                     (when (and (= (-> borrower-level info master-level) (-> host-level-candidate name))
                                                (nonzero? (-> host-level-candidate info borrow borrow-size 0))
                                                )
                                       (set! host-level-borrow-slot 0)
                                       (set! found-slot #t)
                                       (goto cfg-70)
                                       found-slot
                                       )
                                     )
                                    ((= mode2 (level-memory-mode borrow1))
                                     (when (and (= (-> borrower-level info master-level) (-> host-level-candidate name))
                                                (nonzero? (-> host-level-candidate info borrow borrow-size 1))
                                                )
                                       (set! host-level-borrow-slot 1)
                                       (set! found-slot #t)
                                       (goto cfg-70)
                                       found-slot
                                       )
                                     )
                                    ((= mode2 (level-memory-mode borrow2))
                                     (when (and (= (-> borrower-level info master-level) (-> host-level-candidate name))
                                                (nonzero? (-> host-level-candidate info borrow borrow-size 2))
                                                )
                                       (set! host-level-borrow-slot 2)
                                       (set! found-slot #t)
                                       (goto cfg-70)
                                       found-slot
                                       )
                                     )
                                    ((= mode2 (level-memory-mode borrow3))
                                     (when (and (= (-> borrower-level info master-level) (-> host-level-candidate name))
                                                (nonzero? (-> host-level-candidate info borrow borrow-size 3))
                                                )
                                       (set! host-level-borrow-slot 3)
                                       (set! found-slot #t)
                                       (goto cfg-70)
                                       found-slot
                                       )
                                     )
                                    ((= mode2 (level-memory-mode borrow4))
                                     (when (and (= (-> borrower-level info master-level) (-> host-level-candidate name))
                                                (nonzero? (-> host-level-candidate info borrow borrow-size 4))
                                                )
                                       (set! host-level-borrow-slot 4)
                                       (set! found-slot #t)
                                       (goto cfg-70)
                                       found-slot
                                       )
                                     )
                                    )
                                  )
                            )
                          (label cfg-70)
                          (and found-slot
                               (>= host-level-borrow-slot 0)
                               (not (-> host-level-candidate borrow-level host-level-borrow-slot))
                               )
                          )
                        )
                   )
          (set! a2-1 host-level-candidate)
          (goto cfg-82)
          )
        )
      )
    (set! a2-1 (the-as level #f))
    (label cfg-82)
    (cond
      (a2-1
        (set! (-> borrower-level borrow-from-level) a2-1)
        (set! (-> a2-1 borrow-level host-level-borrow-slot) borrower-level)
        (mem-copy!
          (the-as pointer (-> borrower-level heap))
          (the-as pointer (-> a2-1 borrow-heap host-level-borrow-slot))
          16
          )
        )
      (else
        (format
          0
          "ERROR: level ~A could not find free ~S bank in the level-group heap~%"
          (-> borrower-level name)
          (level-memory-mode->string mode)
          )
        (break!)
        0
        )
      )
    )
  0
  (none)
  )

;; definition for method 18 of type level
(defmethod load-begin ((this level))
  "Start loading data of a level."
  (local-vars
    (sv-16 level)
    (memory-unused? (function level-group int symbol))
    (sv-24 int)
    (mask int)
    (sv-40 int)
    (sv-48 int)
    (sv-56 int)
    )
  (dotimes (v1-0 5)
    (set! (-> this borrow-level v1-0) #f)
    )
  (set! (-> this borrow-from-level) #f)
  (set! (-> this memory-mask) (the-as uint 0))
  (let ((mem-mode (-> this info memory-mode)))
    (dotimes (v1-4 10)
      (set! sv-16 (-> *level* level v1-4))
      (when (and (or (= (-> sv-16 status) 'active) (= (-> sv-16 status) 'loaded)) (-> sv-16 info borrow))
        (dotimes (a0-16 5)
          (when (and (-> sv-16 info borrow borrow-info a0-16)
                     (= (car (-> sv-16 info borrow borrow-info a0-16)) (-> this name))
                     (nonzero? (-> sv-16 info borrow borrow-size a0-16))
                     )
            (when (!= mem-mode (level-memory-mode borrow))
              (format 0 "WARNING: level ~A upgraded to borrow~%" (-> this name))
              (set! mem-mode (level-memory-mode borrow))
              )
            (goto cfg-28)
            )
          )
        )
      )
    (label cfg-28)
    (case mem-mode
      (((level-memory-mode borrow)
        (level-memory-mode borrow0)
        (level-memory-mode borrow1)
        (level-memory-mode borrow2)
        (level-memory-mode borrow3)
        (level-memory-mode borrow4)
        (level-memory-mode borrow-city-small)
        )
       (level-find-borrow-slot this mem-mode)
       )
      (else
        (set! memory-unused? (lambda ((arg0 level-group) (arg1 int))
                               (dotimes (v1-0 11)
                                 (if (logtest? (-> arg0 level v1-0 memory-mask) arg1)
                                     (return #f)
                                     )
                                 )
                               #t
                               )
              )
        (set! sv-24 0)
        (set! mask 0)
        (set! sv-40 0)
        (dotimes (v1-15 10)
          (let ((lev (-> *level* level v1-15)))
            (when (and (or (= (-> lev status) 'active) (= (-> lev status) 'loaded))
                       (or (= (-> lev info memory-mode) (level-memory-mode micro))
                           (= (-> lev info memory-mode) (level-memory-mode city-tiny-edge))
                           )
                       )
              (case (-> lev info memory-mode)
                (((level-memory-mode city-tiny-edge))
                 (set! mask (if (or (= (-> lev memory-mask) 60) (= (-> lev memory-mask) #x3c000))
                                3
                                #x30000
                                )
                       )
                 (if (zero? sv-40)
                     (set! sv-40 (if (or (= (-> lev memory-mask) 15) (= (-> lev memory-mask) #x3c000))
                                     #x3c000
                                     60
                                     )
                           )
                     )
                 )
                (((level-memory-mode micro))
                 (set! mask (the-as int (-> lev memory-mask)))
                 )
                )
              )
            )
          )
        (let ((v1-18 mem-mode))
          (set! sv-48 (cond
                        ((= v1-18 (level-memory-mode large))
                         #xbd0000
                         )
                        ((= v1-18 (level-memory-mode medium))
                         #x8fb800
                         )
                        ((or (= v1-18 (level-memory-mode small-center)) (= v1-18 (level-memory-mode city-center)))
                         #x627000
                         )
                        ((or (= v1-18 (level-memory-mode city-tiny-edge))
                             (= v1-18 (level-memory-mode tiny-center))
                             (= v1-18 (level-memory-mode tiny-edge))
                             (= v1-18 (level-memory-mode tiny))
                             )
                         #x3f0000
                         )
                        ((= v1-18 (level-memory-mode micro))
                         #x1f8000
                         )
                        ((= v1-18 (level-memory-mode tiny-center-micro))
                         #x2f4000
                         )
                        ((= v1-18 (level-memory-mode tiny-center-small))
                         #x4ec000
                         )
                        (else
                          #x5e8000
                          )
                        )
                )
          )
        (set! sv-56 0)
        (case mem-mode
          (((level-memory-mode large))
           (case mask
             ((3)
              (let ((s4-0 #x3ffc0))
                (when (memory-unused? *level* s4-0)
                  (set! sv-24 48)
                  (set! sv-56 s4-0)
                  (goto cfg-322)
                  )
                )
              (let ((s4-1 #x3ffc))
                (when (memory-unused? *level* s4-1)
                  (set! sv-24 16)
                  (set! sv-56 s4-1)
                  (goto cfg-322)
                  )
                )
              )
             ((#x30000)
              (let ((s4-2 4095))
                (when (memory-unused? *level* s4-2)
                  (set! sv-24 0)
                  (set! sv-56 s4-2)
                  (goto cfg-322)
                  )
                )
              (let ((s4-3 #xfff0))
                (when (memory-unused? *level* s4-3)
                  (set! sv-24 32)
                  (set! sv-56 s4-3)
                  (goto cfg-322)
                  )
                )
              )
             (else
               (let ((s4-4 4095))
                 (when (memory-unused? *level* s4-4)
                   (set! sv-24 0)
                   (set! sv-56 s4-4)
                   (goto cfg-322)
                   )
                 )
               (let ((s4-5 #x3ffc0))
                 (when (memory-unused? *level* s4-5)
                   (set! sv-24 48)
                   (set! sv-56 s4-5)
                   (goto cfg-322)
                   )
                 )
               )
             )
           )
          (((level-memory-mode medium))
           (let ((s4-6 511))
             (when (memory-unused? *level* s4-6)
               (set! sv-24 0)
               (set! sv-56 s4-6)
               (goto cfg-322)
               )
             )
           (let ((s4-7 #x3fe00))
             (when (memory-unused? *level* s4-7)
               (set! sv-24 73)
               (set! sv-56 s4-7)
               (goto cfg-322)
               )
             )
           )
          (((level-memory-mode small-center))
           (case mask
             ((3)
              (case sv-40
                ((#x3c000)
                 (let ((s4-8 #x3f00))
                   (when (memory-unused? *level* s4-8)
                     (set! sv-24 64)
                     (set! sv-56 s4-8)
                     (goto cfg-322)
                     )
                   )
                 )
                (else
                  (let ((s4-9 4032))
                    (when (memory-unused? *level* s4-9)
                      (set! sv-24 48)
                      (set! sv-56 s4-9)
                      (goto cfg-322)
                      )
                    )
                  )
                )
              )
             ((#x30000)
              (case sv-40
                ((#x3c000)
                 (let ((s4-10 1008))
                   (when (memory-unused? *level* s4-10)
                     (set! sv-24 32)
                     (set! sv-56 s4-10)
                     (goto cfg-322)
                     )
                   )
                 )
                (else
                  (let ((s4-11 4032))
                    (when (memory-unused? *level* s4-11)
                      (set! sv-24 48)
                      (set! sv-56 s4-11)
                      (goto cfg-322)
                      )
                    )
                  )
                )
              )
             (else
               (let ((s4-12 4032))
                 (when (memory-unused? *level* s4-12)
                   (set! sv-24 48)
                   (set! sv-56 s4-12)
                   (goto cfg-322)
                   )
                 )
               )
             )
           )
          (((level-memory-mode city-center))
           (let ((s4-13 4032))
             (when (memory-unused? *level* s4-13)
               (set! sv-24 48)
               (set! sv-56 s4-13)
               (goto cfg-322)
               )
             )
           )
          (((level-memory-mode small-edge))
           (case mask
             ((3)
              (case sv-40
                ((#x3c000)
                 (let ((s4-14 252))
                   (when (memory-unused? *level* s4-14)
                     (set! sv-24 16)
                     (set! sv-56 s4-14)
                     (goto cfg-322)
                     )
                   )
                 (let ((s4-15 #x3f00))
                   (when (memory-unused? *level* s4-15)
                     (set! sv-24 64)
                     (set! sv-56 s4-15)
                     (goto cfg-322)
                     )
                   )
                 )
                (else
                  (let ((s4-16 #x3f000))
                    (when (memory-unused? *level* s4-16)
                      (set! sv-24 98)
                      (set! sv-56 s4-16)
                      (goto cfg-322)
                      )
                    )
                  (let ((s4-17 4032))
                    (when (memory-unused? *level* s4-17)
                      (set! sv-24 48)
                      (set! sv-56 s4-17)
                      (goto cfg-322)
                      )
                    )
                  )
                )
              )
             ((#x30000)
              (case sv-40
                ((#x3c000)
                 (let ((s4-18 #xfc00))
                   (when (memory-unused? *level* s4-18)
                     (set! sv-24 82)
                     (set! sv-56 s4-18)
                     (goto cfg-322)
                     )
                   )
                 (let ((s4-19 1008))
                   (when (memory-unused? *level* s4-19)
                     (set! sv-24 32)
                     (set! sv-56 s4-19)
                     (goto cfg-322)
                     )
                   )
                 )
                (else
                  (let ((s4-20 63))
                    (when (memory-unused? *level* s4-20)
                      (set! sv-24 0)
                      (set! sv-56 s4-20)
                      (goto cfg-322)
                      )
                    )
                  (let ((s4-21 4032))
                    (when (memory-unused? *level* s4-21)
                      (set! sv-24 48)
                      (set! sv-56 s4-21)
                      (goto cfg-322)
                      )
                    )
                  )
                )
              )
             (else
               (let ((s4-22 63))
                 (when (memory-unused? *level* s4-22)
                   (set! sv-24 0)
                   (set! sv-56 s4-22)
                   (goto cfg-322)
                   )
                 )
               (let ((s4-23 #x3f000))
                 (when (memory-unused? *level* s4-23)
                   (set! sv-24 98)
                   (set! sv-56 s4-23)
                   (goto cfg-322)
                   )
                 )
               )
             )
           )
          (((level-memory-mode micro))
           (let ((s4-24 3))
             (when (memory-unused? *level* s4-24)
               (set! sv-24 0)
               (set! sv-56 s4-24)
               (goto cfg-322)
               )
             )
           (let ((s4-25 #x30000))
             (when (memory-unused? *level* s4-25)
               (set! sv-24 130)
               (set! sv-56 s4-25)
               (goto cfg-322)
               )
             )
           )
          (((level-memory-mode tiny-edge) (level-memory-mode city-tiny-edge))
           (let ((v1-126 mask))
             (cond
               ((or (zero? v1-126) (= v1-126 3))
                (let ((s4-26 60))
                  (when (memory-unused? *level* s4-26)
                    (set! sv-24 16)
                    (set! sv-56 s4-26)
                    (goto cfg-322)
                    )
                  )
                (let ((s4-27 #x3c000))
                  (when (memory-unused? *level* s4-27)
                    (set! sv-24 114)
                    (set! sv-56 s4-27)
                    (goto cfg-322)
                    )
                  )
                )
               ((= v1-126 #x30000)
                (let ((s4-28 #xf000))
                  (when (memory-unused? *level* s4-28)
                    (set! sv-24 98)
                    (set! sv-56 s4-28)
                    (goto cfg-322)
                    )
                  )
                (let ((s4-29 15))
                  (when (memory-unused? *level* s4-29)
                    (set! sv-24 0)
                    (set! sv-56 s4-29)
                    (goto cfg-322)
                    )
                  )
                )
               )
             )
           )
          (((level-memory-mode tiny))
           (let ((v1-143 mask))
             (cond
               ((or (zero? v1-143) (= v1-143 3))
                (let ((s4-30 60))
                  (when (memory-unused? *level* s4-30)
                    (set! sv-24 16)
                    (set! sv-56 s4-30)
                    (goto cfg-322)
                    )
                  )
                (let ((s4-31 #x3c000))
                  (when (memory-unused? *level* s4-31)
                    (set! sv-24 114)
                    (set! sv-56 s4-31)
                    (goto cfg-322)
                    )
                  )
                (let ((s4-32 #x3c00))
                  (when (memory-unused? *level* s4-32)
                    (set! sv-24 82)
                    (set! sv-56 s4-32)
                    (goto cfg-322)
                    )
                  )
                (let ((s4-33 960))
                  (when (memory-unused? *level* s4-33)
                    (set! sv-24 48)
                    (set! sv-56 s4-33)
                    (goto cfg-322)
                    )
                  )
                )
               ((= v1-143 #x30000)
                (let ((s4-34 #xf000))
                  (when (memory-unused? *level* s4-34)
                    (set! sv-24 98)
                    (set! sv-56 s4-34)
                    (goto cfg-322)
                    )
                  )
                (let ((s4-35 15))
                  (when (memory-unused? *level* s4-35)
                    (set! sv-24 0)
                    (set! sv-56 s4-35)
                    (goto cfg-322)
                    )
                  )
                (let ((s4-36 240))
                  (when (memory-unused? *level* s4-36)
                    (set! sv-24 32)
                    (set! sv-56 s4-36)
                    (goto cfg-322)
                    )
                  )
                (let ((s4-37 3840))
                  (when (memory-unused? *level* s4-37)
                    (set! sv-24 64)
                    (set! sv-56 s4-37)
                    (goto cfg-322)
                    )
                  )
                )
               )
             )
           )
          (((level-memory-mode tiny-center))
           (let ((v1-176 mask))
             (cond
               ((or (zero? v1-176) (= v1-176 3))
                (let ((s4-38 #x3c00))
                  (when (memory-unused? *level* s4-38)
                    (set! sv-24 82)
                    (set! sv-56 s4-38)
                    (goto cfg-322)
                    )
                  )
                (let ((s4-39 960))
                  (when (memory-unused? *level* s4-39)
                    (set! sv-24 48)
                    (set! sv-56 s4-39)
                    (goto cfg-322)
                    )
                  )
                )
               ((= v1-176 #x30000)
                (let ((s4-40 240))
                  (when (memory-unused? *level* s4-40)
                    (set! sv-24 32)
                    (set! sv-56 s4-40)
                    (goto cfg-322)
                    )
                  )
                (let ((s4-41 3840))
                  (when (memory-unused? *level* s4-41)
                    (set! sv-24 64)
                    (set! sv-56 s4-41)
                    (goto cfg-322)
                    )
                  )
                )
               )
             )
           )
          (((level-memory-mode tiny-center-small))
           (let ((v1-194 mask))
             (cond
               ((or (zero? v1-194) (= v1-194 3))
                (let ((s4-42 #x3e00))
                  (when (memory-unused? *level* s4-42)
                    (set! sv-24 72)
                    (set! sv-56 s4-42)
                    (goto cfg-322)
                    )
                  )
                (let ((s4-43 1984))
                  (when (memory-unused? *level* s4-43)
                    (set! sv-24 48)
                    (set! sv-56 s4-43)
                    (goto cfg-322)
                    )
                  )
                )
               ((= v1-194 #x30000)
                (let ((s4-44 496))
                  (when (memory-unused? *level* s4-44)
                    (set! sv-24 32)
                    (set! sv-56 s4-44)
                    (goto cfg-322)
                    )
                  )
                (let ((s4-45 3968))
                  (when (memory-unused? *level* s4-45)
                    (set! sv-24 56)
                    (set! sv-56 s4-45)
                    (goto cfg-322)
                    )
                  )
                )
               )
             )
           )
          (((level-memory-mode tiny-center-micro))
           (let ((v1-213 mask))
             (cond
               ((or (zero? v1-213) (= v1-213 3))
                (let ((s4-46 448))
                  (when (memory-unused? *level* s4-46)
                    (set! sv-24 48)
                    (set! sv-56 s4-46)
                    (goto cfg-322)
                    )
                  )
                (let ((s4-47 #x3800))
                  (when (memory-unused? *level* s4-47)
                    (set! sv-24 90)
                    (set! sv-56 s4-47)
                    (goto cfg-322)
                    )
                  )
                )
               ((= v1-213 #x30000)
                (let ((s4-48 3584))
                  (when (memory-unused? *level* s4-48)
                    (set! sv-24 72)
                    (set! sv-56 s4-48)
                    (goto cfg-322)
                    )
                  )
                (let ((s4-49 112))
                  (when (memory-unused? *level* s4-49)
                    (set! sv-24 32)
                    (set! sv-56 s4-49)
                    (goto cfg-322)
                    )
                  )
                )
               )
             )
           )
          )
        (label cfg-322)
        (cond
          ((zero? sv-56)
           (format
             0
             "ERROR: level ~A could not find free ~S bank in the level-group heap (micro ~X tiny ~X)~%"
             (-> this name)
             (level-memory-mode->string mem-mode)
             mask
             sv-40
             )
           (dotimes (s5-1 11)
             (let ((s4-51 (-> *level* level s5-1)))
               (when (!= (-> s4-51 status) 'inactive)
                 (format 0 "~Tlevel ~2D ~16S " s5-1 (-> s4-51 name))
                 (format
                   0
                   "~16S bits #b~18,'0B~%"
                   (if (nonzero? (-> s4-51 info))
                       (level-memory-mode->string (-> s4-51 info memory-mode))
                       )
                   (-> s4-51 memory-mask)
                   )
                 )
               )
             )
           #t
           (break!)
           0
           )
          (else
            (set! (-> this memory-mask) (the-as uint sv-56))
            (format 0 "lev ~A ~X micro ~X tiny ~X~%" (-> this name) (-> this memory-mask) mask sv-40)
            (cond
              ((= (&- (-> *level* heap top) (the-as uint (-> *level* heap base))) #x1af2800)
               (let ((v1-245 (-> this heap)))
                 (set! (-> v1-245 base) (&+ (-> *level* heap base) (* #x2f400 sv-24)))
                 (set! (-> v1-245 current) (-> v1-245 base))
                 (set! (-> v1-245 top-base) (&+ (-> v1-245 base) (+ sv-48 (/ sv-48 2))))
                 (set! (-> v1-245 top) (-> v1-245 top-base))
                 )
               )
              (else
                (let ((v1-246 (-> this heap)))
                  (set! (-> v1-246 base) (&+ (-> *level* heap base) (* #x1f800 sv-24)))
                  (set! (-> v1-246 current) (-> v1-246 base))
                  (set! (-> v1-246 top-base) (&+ (-> v1-246 base) sv-48))
                  (set! (-> v1-246 top) (-> v1-246 top-base))
                  )
                )
              )
            )
          )
        )
      )
    )
  (set! loading-level (-> this heap))
  (set! (-> *level* loading-level) this)
  (set! (-> this level-type) #f)
  (set! *level-type-list* (the-as type (&-> this level-type)))
  (set! (-> *level* log-in-level-bsp) #f)
  (set! (-> this nickname) #f)
  (set! (-> this bsp) #f)
  (set! (-> this entity) #f)
  (set! (-> this linking) #f)
  (set! (-> this task-mask) (-> *setting-control* user-current task-mask))
  (vis-clear this)
  (set! (-> this load-start-time) (the-as uint (-> *display* real-clock frame-counter)))
  (set! (-> this load-stop-time) (the-as uint 0))
  (set! (-> this display-start-time) (the-as uint 0))
  (set! (-> this part-engine) #f)
  (dotimes (v1-258 4)
    (set! (-> this user-object v1-258) #f)
    )
  (set! (-> this load-id) (the-as uint (new-sound-id)))
  (set! (-> this status) 'loading)
  (do-nothing *level*)
  (set! (-> *texture-pool* allocate-func) texture-page-level-allocate)
  (if (= (-> this load-name) (-> this info visname))
      (format (clear *temp-string*) "~S" (-> this info nickname))
      (format (clear *temp-string*) "~S" (-> this name))
      )
  (set! (-> *temp-string* data 8) (the-as uint 0))
  (format *temp-string* ".DGO")
  (set! (-> this heap top) (-> this heap top-base))
  (set! (-> *level* load-level) (-> this load-name))
  (set! (-> *level* load-size) (the-as uint 0))
  (set! (-> *level* load-time) 0.0)
  (set! (-> *level* load-login-time) 0.0)
  (set! (-> this code-memory-start) (-> this heap current))
  (let ((v1-278 (-> this info memory-mode)))
    (cond
      ((or (or (= v1-278 (level-memory-mode borrow)) (or (= v1-278 (level-memory-mode borrow0))
                                                         (= v1-278 (level-memory-mode borrow1))
                                                         (= v1-278 (level-memory-mode borrow2))
                                                         (= v1-278 (level-memory-mode borrow3))
                                                         (= v1-278 (level-memory-mode borrow4))
                                                         (= v1-278 (level-memory-mode micro))
                                                         (= v1-278 (level-memory-mode borrow-city-small))
                                                         )
               )
           (-> this borrow-from-level)
           (logtest? (-> this info level-flags) (level-flags lf6))
           )
       (set! (-> this load-buffer-mode) (level-memory-mode borrow))
       (let ((t0-2 (logand -64 (&+ (-> this heap current) 63))))
         (dgo-load-begin *temp-string* (the-as uint128 (-> this load-id)) t0-2 t0-2 t0-2)
         )
       )
      (else
        (let* ((v1-287 (-> this info memory-mode))
               (s4-52
                 (cond
                   ((= v1-287 (level-memory-mode micro))
                    #x80000
                    )
                   ((= v1-287 (level-memory-mode tiny-center-micro))
                    #xc0000
                    )
                   ((or (= v1-287 (level-memory-mode tiny-center))
                        (= v1-287 (level-memory-mode tiny-edge))
                        (= v1-287 (level-memory-mode tiny))
                        (= v1-287 (level-memory-mode city-tiny-edge))
                        )
                    #xc8000
                    )
                   (else
                     #x1b5800
                     )
                   )
                 )
               (s5-4 (kmalloc (-> this heap) s4-52 (kmalloc-flags align-64 top) "dgo-level-buf-2"))
               (s3-2 (kmalloc (-> this heap) s4-52 (kmalloc-flags align-64 top) "dgo-level-buf-2"))
               )
          (format 0 "-----------> begin load ~A [~S] buffers ~d bytes~%" (-> this load-name) *temp-string* s4-52)
          (set! (-> this load-buffer 0) (the-as uint s3-2))
          (set! (-> this load-buffer 1) (the-as uint s5-4))
          (set! (-> this load-buffer-size) (the-as uint s4-52))
          (set! (-> this load-buffer-mode) (level-memory-mode micro))
          (dgo-load-begin
            *temp-string*
            (the-as uint128 (-> this load-id))
            s3-2
            s5-4
            (logand -64 (&+ (-> this heap current) 63))
            )
          )
        )
      )
    )
  this
  )

;; definition for method 19 of type level
(defmethod login-begin ((this level))
  "Start logging in loaded level data."
  (set! (-> *texture-pool* allocate-func) texture-page-default-allocate)
  (cond
    ((-> this bsp)
     (let ((s5-0 (-> this bsp)))
       (set! (-> s5-0 level tfrag-gs-test)
             (if (logtest? (-> s5-0 texture-flags 0) (texture-page-flag alpha-enable))
                 (new 'static 'gs-test :ate #x1 :atst (gs-atest always) :zte #x1 :ztst (gs-ztest greater-equal))
                 (new 'static 'gs-test
                   :ate #x1
                   :atst (gs-atest greater-equal)
                   :aref #x26
                   :zte #x1
                   :ztst (gs-ztest greater-equal)
                   )
                 )
             )
       (set! (-> *level* log-in-level-bsp) (-> this bsp))
       (login-level-textures *texture-pool* this (-> this bsp texture-page-count) (-> this bsp texture-ids))
       (dotimes (v1-10 10)
         (set! (-> this sky-mask mask data v1-10) 0)
         )
       (let* ((s4-0 (-> this info callback-list))
              (v1-14 (car s4-0))
              )
         (while (not (null? s4-0))
           (let ((s3-0 (/ (the-as int (car v1-14)) 8))
                 (a3-1 (the-as symbol (cdr v1-14)))
                 )
             (when (and (< (the-as uint 1) s3-0) (< s3-0 (the-as uint 13)))
               (if (nonzero? (-> a3-1 value))
                   (set! (-> this texture-anim-array (+ s3-0 -2)) (init! (the-as texture-anim-array (-> a3-1 value))))
                   (format 0 "WARNING: level ~A has undefined texture anim array ~A~%" (-> this name) a3-1)
                   )
               )
             )
           (set! s4-0 (cdr s4-0))
           (set! v1-14 (car s4-0))
           )
         )
       (build-masks s5-0)
       )
     (set! (-> *login-state* state) -1)
     (set! (-> *login-state* pos) (the-as uint 0))
     (set! (-> *login-state* elts) (the-as uint 0))
     (dotimes (v1-28 11)
       (set! (-> this eye-slot-lowres v1-28) (the-as uint 0))
       (set! (-> this eye-slot-highres v1-28) (the-as uint 0))
       )
     (set! (-> this status) 'login)
     (do-nothing *level*)
     )
    (else
      (level-status-update! this 'inactive)
      (set! loading-level global)
      (set! (-> *level* loading-level) (-> *level* level-default))
      (set! *level-type-list* (the-as type 0))
      0
      )
    )
  this
  )

;; definition for function level-update-after-load
;; WARN: Found some very strange gotos. Check result carefully, this is not well tested.
;; INFO: Used lq/sq
;; ERROR: Unsupported inline assembly instruction kind - [mfc0 s5, Count]
;; ERROR: Unsupported inline assembly instruction kind - [mfc0 v1, Count]
;; ERROR: Unsupported inline assembly instruction kind - [mfc0 v1, Count]
(defun level-update-after-load ((arg0 level) (arg1 login-state))
  "Run the post-load state machine to login level data."
  (local-vars
    (v1-4 int)
    (v1-244 int)
    (s5-0 int)
    (sv-16 drawable)
    (sv-32 proxy-prototype-array-tie)
    (sv-48 int)
    (sv-64 prototype-bucket-tie)
    (sv-80 int)
    (sv-96 adgif-shader)
    )
  (set! *level-index* (-> arg0 index))
  0
  (let* ((s3-0 (-> arg0 bsp))
         (s2-0 (-> s3-0 drawable-trees))
         )
    0
    (.mfc0 s5-0 Count)
    (label cfg-1)
    0
    (.mfc0 v1-4 Count)
    (let ((v1-5 (- v1-4 s5-0)))
      (when (< #x186a0 v1-5)
        (set! arg0 arg0)
        (goto cfg-116)
        )
      )
    (let ((s0-0 (the-as int (-> arg1 pos))))
      (when (= (-> arg1 state) -1)
        (when (< s0-0 (-> s2-0 length))
          (let ((s1-0 (-> s2-0 trees (the-as uint s0-0))))
            (cond
              ((= (-> (the-as drawable-tree-tfrag s1-0) type) drawable-tree-tfrag)
               (dotimes (s0-1 (-> (the-as drawable-tree-tfrag s1-0) length))
                 (cond
                   ((= (-> (the-as drawable-tree-tfrag s1-0) arrays s0-1 type) drawable-inline-array-tfrag)
                    (set! (-> arg1 elt (-> arg1 elts)) (-> (the-as drawable-tree-tfrag s1-0) arrays s0-1))
                    (+! (-> arg1 elts) 1)
                    )
                   (else
                     (login (-> (the-as drawable-tree-tfrag s1-0) arrays s0-1))
                     )
                   )
                 )
               )
              ((= (-> s1-0 type) drawable-tree-instance-tie)
               (set! (-> arg1 elt (-> arg1 elts)) s1-0)
               (+! (-> arg1 elts) 1)
               )
              (else
                (login s1-0)
                (if (nonzero? (-> s3-0 hfrag-drawable))
                    (login (-> s3-0 hfrag-drawable))
                    )
                )
              )
            )
          (+! (-> arg1 pos) 1)
          (goto cfg-1)
          )
        (let ((v1-42 (- (the-as uint s0-0) (-> s2-0 length))))
          (when (< (the-as int v1-42) (-> arg0 art-group art-group-array length))
            (let ((s0-2 (-> arg0 art-group art-group-array v1-42))
                  (s1-1 (-> *kernel-context* login-level-index))
                  )
              (set! (-> *kernel-context* login-level-index) (-> arg0 index))
              (login s0-2)
              (if (contains-art-for-other-group? s0-2)
                  (link-art-to-master s0-2)
                  )
              (set! (-> *kernel-context* login-level-index) s1-1)
              )
            (+! (-> arg1 pos) 1)
            (goto cfg-1)
            )
          )
        (set! (-> arg1 pos) (the-as uint 0))
        (set! (-> arg1 state) 0)
        (goto cfg-1)
        )
      (when (< (-> arg1 state) (the-as int (-> arg1 elts)))
        (set! sv-16 (-> arg1 elt (-> arg1 state)))
        (cond
          ((= (-> sv-16 type) drawable-inline-array-tfrag)
           (set! *texture-masks-array* (-> arg0 bsp tfrag-masks))
           (cond
             ((< s0-0 (-> (the-as drawable-inline-array-tfrag sv-16) length))
              (dotimes (s1-2 200)
                (when (< s0-0 (-> (the-as drawable-inline-array-tfrag sv-16) length))
                  (login (-> (the-as drawable-inline-array-tfrag sv-16) data (the-as uint s0-0)))
                  (set! s0-0 (the-as int (+ (the-as uint s0-0) 1)))
                  )
                )
              (set! (-> arg1 pos) (the-as uint s0-0))
              )
             (else
               (set! (-> arg1 pos) (the-as uint 0))
               (set! s0-0 (+ (-> arg1 state) 1))
               (set! (-> arg1 state) s0-0)
               )
             )
           )
          ((= (-> sv-16 type) drawable-tree-instance-tie)
           (let ((s1-3 (-> (the-as drawable-tree-instance-tie sv-16) prototypes prototype-array-tie)))
             (set! sv-32 (-> (the-as drawable-tree-instance-tie sv-16) prototypes))
             (when (< s0-0 (-> s1-3 length))
               (set! sv-48 0)
               (while (< sv-48 10)
                 (when (< s0-0 (-> s1-3 length))
                   (set! sv-64 (-> s1-3 array-data (the-as uint s0-0)))
                   (+! (-> sv-32 prototype-max-qwc) 32)
                   (cond
                     ((logtest? (-> sv-64 flags) (prototype-flags tpage-alpha))
                      (set! *texture-masks* (-> *level* level *level-index* bsp alpha-masks data (-> sv-64 texture-masks-index)))
                      )
                     ((logtest? (-> sv-64 flags) (prototype-flags tpage-water))
                      (set! *texture-masks* (-> *level* level *level-index* bsp water-masks data (-> sv-64 texture-masks-index)))
                      )
                     (else
                       (set! *texture-masks* (-> *level* level *level-index* bsp tfrag-masks data (-> sv-64 texture-masks-index)))
                       )
                     )
                   (when (and *debug-segment* (-> *screen-shot-work* highres-enable))
                     (dotimes (v1-116 4)
                       (+! (-> sv-64 dists data v1-116) 40960000.0)
                       (set! (-> sv-64 rdists data v1-116) (/ 1.0 (-> sv-64 dists data v1-116)))
                       )
                     )
                   (set! sv-80 0)
                   (while (< sv-80 4)
                     (let ((a0-63 (-> sv-64 tie-geom sv-80)))
                       (when (nonzero? a0-63)
                         (+! (-> sv-32 prototype-max-qwc) (* 7 (-> a0-63 length)))
                         (login a0-63)
                         )
                       )
                     (set! sv-80 (+ sv-80 1))
                     )
                   (set! s0-0 (the-as int (+ (the-as uint s0-0) 1)))
                   )
                 (set! sv-48 (+ sv-48 1))
                 )
               (set! (-> arg1 pos) (the-as uint s0-0))
               )
             (when (= (the-as uint s0-0) (-> s1-3 length))
               (dotimes (s0-3 (-> s1-3 length))
                 (let ((v1-146 (-> s1-3 array-data s0-3)))
                   (cond
                     ((logtest? (-> v1-146 flags) (prototype-flags tpage-alpha))
                      (set! *texture-masks* (-> *level* level *level-index* bsp alpha-masks data (-> v1-146 texture-masks-index)))
                      )
                     ((logtest? (-> v1-146 flags) (prototype-flags tpage-water))
                      (set! *texture-masks* (-> *level* level *level-index* bsp water-masks data (-> v1-146 texture-masks-index)))
                      )
                     (else
                       (set! *texture-masks* (-> *level* level *level-index* bsp tfrag-masks data (-> v1-146 texture-masks-index)))
                       )
                     )
                   (set! sv-96 (-> v1-146 envmap-shader))
                   )
                 (when (nonzero? sv-96)
                   (let ((v0-8 (adgif-shader-login-no-remap sv-96)))
                     (when v0-8
                       (dotimes (v1-150 3)
                         (dotimes (a0-82 3)
                           (set! (-> (the-as (pointer int32) (+ (+ (* v1-150 16) (* a0-82 4)) (the-as int *texture-masks*))))
                                 (logior (-> (the-as (pointer int32) (+ (* a0-82 4) (the-as int *texture-masks*) (* v1-150 16))) 0)
                                         (-> (the-as (pointer int32) (+ (* a0-82 4) (the-as int v0-8) (* v1-150 16))) 15)
                                         )
                                 )
                           )
                         (set! (-> *texture-masks* data v1-150 dist)
                               (fmax (-> *texture-masks* data v1-150 dist) (-> v0-8 masks data v1-150 dist))
                               )
                         )
                       )
                     )
                   (set! (-> sv-96 tex1) (new 'static 'gs-tex1 :mmag #x1 :mmin #x1))
                   (set! (-> sv-96 clamp) (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp)))
                   (set! (-> sv-96 alpha) (new 'static 'gs-miptbp :tbp1 #x58))
                   (set! (-> sv-96 reg-0) (gs-reg tex0-1))
                   (set! (-> sv-96 reg-1) (gs-reg tex1-1))
                   (set! (-> sv-96 reg-2) (gs-reg miptbp1-1))
                   (set! (-> sv-96 reg-3) (gs-reg clamp-1))
                   (set! (-> sv-96 reg-4) (gs-reg alpha-1))
                   )
                 )
               (set! (-> arg1 pos) (the-as uint 0))
               (+! (-> arg1 state) 1)
               )
             )
           )
          )
        (goto cfg-1)
        )
      (when (= (-> arg1 state) (-> arg1 elts))
        (let ((v1-168 (-> arg0 bsp)))
          (cond
            ((or (zero? (-> v1-168 nav-meshes)) (= (the-as uint s0-0) (-> v1-168 nav-meshes length)))
             (set! (-> arg1 pos) (the-as uint 0))
             (+! (-> arg1 state) 1)
             )
            (else
              (initialize-nav-mesh! (-> v1-168 nav-meshes (the-as uint s0-0)))
              (+! (-> arg1 pos) 1)
              )
            )
          )
        (goto cfg-1)
        )
      (when (zero? (the-as uint s0-0))
        (set! (-> arg1 pos) (the-as uint 1))
        (set! arg0 arg0)
        (goto cfg-116)
        )
      )
    )
  (set! (-> arg0 nickname) (-> arg0 bsp nickname))
  (let ((f0-6 (-> arg0 bsp subdivide-close))
        (f1-3 (-> arg0 bsp subdivide-far))
        )
    (when (and (= f0-6 0.0) (= f1-3 0.0))
      (set! f0-6 122880.0)
      (set! f1-3 286720.0)
      )
    (set! (-> *subdivide-settings* close (-> arg0 index)) f0-6)
    (set! (-> *subdivide-settings* far (-> arg0 index)) f1-3)
    (set! (-> *subdivide-settings* close 11) f0-6)
    (set! (-> *subdivide-settings* far 11) f1-3)
    )
  (when (and *debug-segment* (-> *screen-shot-work* highres-enable))
    (set! (-> *subdivide-settings* close (-> arg0 index)) 40960000.0)
    (set! (-> *subdivide-settings* far (-> arg0 index)) 41369600.0)
    (set! (-> *subdivide-settings* close 11) 40960000.0)
    (set! (-> *subdivide-settings* far 11) 41369600.0)
    )
  (init-vis-from-bsp arg0)
  (if (nonzero? (-> arg0 info part-engine-max))
      (set! (-> arg0 part-engine)
            (new 'loading-level 'engine 'sparticle-launcher (the-as int (* (-> arg0 info part-engine-max) 16)) connection)
            )
      )
  (load-common-package arg0)
  (clear-mood-context (-> arg0 mood-context))
  (set! (-> arg0 mood-init)
        (the-as (function mood-context none) (get-callback-symbol-value-by-slot! (-> arg0 info) 23))
        )
  (if (-> arg0 mood-init)
      ((-> arg0 mood-init) (-> arg0 mood-context))
      )
  (when (-> arg0 info borrow)
    (dotimes (v1-229 5)
      (set! (-> arg0 heap top-base)
            (&- (-> arg0 heap top-base) (the-as uint (shl (-> arg0 info borrow borrow-size v1-229) 10)))
            )
      (set! (-> arg0 heap top) (-> arg0 heap top-base))
      (let ((a0-121 (-> arg0 borrow-heap v1-229)))
        (set! (-> a0-121 base) (-> arg0 heap top))
        (set! (-> a0-121 current) (-> a0-121 base))
        (set! (-> a0-121 top-base) (&+ (-> a0-121 base) (shl (-> arg0 info borrow borrow-size v1-229) 10)))
        (set! (-> a0-121 top) (-> a0-121 top-base))
        )
      )
    )
  (set! (-> arg0 draw-priority) (-> arg0 info draw-priority))
  (set! (-> arg0 status) 'loaded)
  (do-nothing *level*)
  (mark-hud-warp-sprite-dirty *texture-pool*)
  (set! loading-level global)
  (set! (-> *level* loading-level) (-> *level* level-default))
  (set! *level-type-list* (the-as type 0))
  (set! (-> *level* log-in-level-bsp) #f)
  (set! (-> arg0 load-stop-time) (the-as uint (-> *display* real-clock frame-counter)))
  0
  (.mfc0 v1-244 Count)
  (- v1-244 s5-0)
  (set! (-> *level* load-login-time)
        (* 0.016666668 (the float (- (-> *display* real-clock integral-frame-counter) *dgo-time*)))
        )
  (label cfg-116)
  arg0
  )

;; definition for method 25 of type level
;; INFO: Used lq/sq
(defmethod birth ((this level))
  "Start running a level."
  (local-vars (sv-96 int))
  (case (-> this status)
    (('loaded)
     (let ((s5-0 loading-level)
           (s4-0 (-> *level* loading-level))
           (s3-0 (-> *level* log-in-level-bsp))
           (s2-1 *level-type-list*)
           )
       (let ((s1-0 (not (-> this entity))))
         (set! loading-level (-> this heap))
         (set! (-> *level* log-in-level-bsp) (-> this bsp))
         (set! (-> *level* loading-level) this)
         (set! *level-type-list* (the-as type (&-> this level-type)))
         (cond
           ((valid? (-> this bsp light-hash) light-hash (the-as string #f) #t 0)
            (set! (-> this light-hash) (-> this bsp light-hash))
            )
           (else
             (set! (-> this light-hash) (the-as light-hash 0))
             0
             )
           )
         (birth (-> this bsp))
         (set! (-> this status) 'alive)
         (do-nothing *level*)
         (set! (-> this render?) #t)
         (copy-perms-to-level! *game-info* this)
         (send-event *camera* 'level-activate (-> this name))
         (send-event *target* 'level-activate (-> this name))
         (when s1-0
           (let ((s1-1 (get-callback-symbol-value-by-slot! (-> this info) 33)))
             (if (and s1-1 (type? s1-1 function))
                 ((the-as (function object object) s1-1) this)
                 )
             )
           )
         )
       (let ((s1-2 (-> this status)))
         (set! (-> this status) 'active)
         (do-nothing *level*)
         (update-task-masks 'level)
         (assign-draw-indices *level*)
         (let ((s0-0 (-> this bsp nav-meshes)))
           (when (nonzero? s0-0)
             (set! sv-96 0)
             (while (< sv-96 (-> s0-0 length))
               (birth! (-> s0-0 sv-96))
               (set! sv-96 (+ sv-96 1))
               )
             )
           )
         (if (and (!= (-> this bsp city-level-info) 0) *traffic-manager*)
             (send-event *traffic-manager* 'level-loaded this)
             )
         (let ((s0-1 (get-callback-symbol-value-by-slot! (-> this info) 35)))
           (if (and s0-1 (type? s0-1 function))
               ((the-as (function object object object) s0-1) this 'display)
               )
           )
         (set! (-> this status) s1-2)
         )
       (set! loading-level s5-0)
       (set! (-> *level* loading-level) s4-0)
       (set! (-> *level* log-in-level-bsp) s3-0)
       (set! *level-type-list* s2-1)
       )
     )
    )
  this
  )

;; definition for method 9 of type level
;; INFO: Used lq/sq
(defmethod deactivate ((this level))
  "Keep a level in memory, but kill entities and stop drawing it."
  (case (-> this status)
    (('active 'alive)
     (format 0 "----------- deactivate(kill) ~A (status ~A)~%" this (-> this status))
     (if (and (!= (-> this bsp city-level-info) 0) *traffic-manager*)
         (send-event *traffic-manager* 'level-killed this)
         )
     (let ((s5-0 (get-callback-symbol-value-by-slot! (-> this info) 36)))
       (if (and s5-0 (type? s5-0 function))
           ((the-as (function object object) s5-0) this)
           )
       )
     (copy-perms-from-level! *game-info* this)
     (send-event *target* 'level-deactivate (-> this name))
     (remove-by-param1 *background-draw-engine* (the-as int (-> this bsp)))
     (let ((s5-1 (-> this status)))
       (set! (-> this status) 'shutdown)
       (do-nothing *level*)
       (deactivate-entities (-> this bsp))
       (set! (-> this status) s5-1)
       )
     (kill-all-particles-in-level this)
     (unload-from-heap *anim-manager* (-> this heap))
     (set! (-> this inside-boxes?) #f)
     (set! (-> this meta-inside?) #f)
     (set! (-> this force-inside?) #f)
     (set! (-> this status) 'loaded)
     (do-nothing *level*)
     (set! (-> this light-hash) (the-as light-hash 0))
     (set! (-> this all-visible?) 'loading)
     (dotimes (v1-35 128)
       (set! (-> (the-as (pointer int128) (&+ (-> this vis-bits) (* v1-35 16)))) 0)
       )
     (countdown (v1-38 8)
       (let ((a0-23 (-> this vis-info v1-38)))
         (if a0-23
             (set! (-> a0-23 current-vis-string) (the-as uint -1))
             )
         )
       )
     (when (logtest? (-> this info base-task-mask) (task-mask primary0))
       (let ((v1-45 (task-mask)))
         (dotimes (a0-24 (-> *level* length))
           (let ((a1-15 (-> *level* level a0-24)))
             (if (= (-> a1-15 status) 'active)
                 (set! v1-45 (logior v1-45 (logand (-> a1-15 info base-task-mask) (task-mask primary0))))
                 )
             )
           )
         (when (not (logtest? v1-45 (task-mask primary0)))
           (dotimes (v1-48 (-> *level* length))
             (let ((a0-30 (-> *level* level v1-48)))
               (if (= (-> a0-30 status) 'active)
                   (logior! (-> a0-30 task-mask) (task-mask primary0))
                   )
               )
             )
           )
         )
       )
     )
    )
  (if (= (-> *level* log-in-level-bsp) (-> this bsp))
      (set! (-> *level* log-in-level-bsp) #f)
      )
  this
  )

;; definition for method 10 of type level
(defmethod unload! ((this level))
  "Remove level from memory."
  (deactivate this)
  (when (!= (-> this status) 'inactive)
    (when (not (logtest? (level-flags lf17) (-> this info level-flags)))
      (dotimes (s5-0 (-> *level* length))
        (let ((v1-10 (-> *level* level s5-0)))
          (when (or (= (-> v1-10 status) 'active) (= (-> v1-10 status) 'alive) (= (-> v1-10 status) 'loaded))
            (when (= (-> v1-10 info master-level) (-> this name))
              (format
                0
                "ERROR: level ~A is unloading but level ~A depends on it as a master-level~%"
                (-> this name)
                (-> v1-10 name)
                )
              (break!)
              0
              )
            )
          )
        )
      )
    (dotimes (s5-1 5)
      (when (-> this borrow-level s5-1)
        (unload! (-> this borrow-level s5-1))
        (set! (-> this borrow-level s5-1) #f)
        )
      )
    (when (-> this borrow-from-level)
      (dotimes (v1-30 5)
        (if (= this (-> this borrow-from-level borrow-level v1-30))
            (set! (-> this borrow-from-level borrow-level v1-30) #f)
            )
        )
      (set! (-> this borrow-from-level) #f)
      )
    (case (-> this status)
      (('loading 'loading-bt)
       (dgo-load-cancel (the-as int (-> this load-id)))
       (link-reset)
       )
      (('alive 'active 'loaded)
       (when (-> this entity)
         (let ((s5-2 (get-callback-symbol-value-by-slot! (-> this info) 34)))
           (if (and s5-2 (type? s5-2 function))
               ((the-as (function level object) s5-2) this)
               )
           )
         )
       )
      )
    (when (or (= (-> this status) 'loaded)
              (= (-> this status) 'alive)
              (= (-> this status) 'active)
              (= (-> this status) 'login)
              )
      (dotimes (s5-3 (-> this art-group art-group-array length))
        (let ((s4-0 (-> this art-group art-group-array s5-3)))
          (if (contains-art-for-other-group? s4-0)
              (unlink-art-to-master s4-0)
              )
          (art-method-10 s4-0)
          )
        )
      (case (-> this status)
        (('alive 'active 'loaded)
         (let* ((s5-4 (-> this info callback-list))
                (v1-68 (car s5-4))
                )
           (while (not (null? s5-4))
             (let ((s4-1 (/ (the-as int (car v1-68)) 8))
                   (v1-69 (the-as object (cdr v1-68)))
                   )
               (when (and (< (the-as uint 1) s4-1) (< s4-1 (the-as uint 13)))
                 (if (nonzero? (-> (the-as symbol v1-69) value))
                     (set! (-> this texture-anim-array (+ s4-1 -2))
                           (clear! (the-as texture-anim-array (-> (the-as symbol v1-69) value)))
                           )
                     )
                 )
               )
             (set! s5-4 (cdr s5-4))
             (set! v1-68 (car s5-4))
             )
           )
         )
        )
      )
    (set! (-> this bsp) #f)
    (set! (-> this entity) #f)
    (set! (-> this status) 'inactive)
    (do-nothing *level*)
    (set! (-> this linking) #f)
    (set! (-> this art-group string-array length) 0)
    (set! (-> this art-group art-group-array length) 0)
    (set! (-> this mem-usage-block) (the-as memory-usage-block 0))
    (set! (-> this mem-usage) 0)
    (set! (-> this part-engine) #f)
    (dotimes (v1-83 4)
      (set! (-> this user-object v1-83) #f)
      )
    (dotimes (v1-86 11)
      (set! (-> this texture-anim-array v1-86) #f)
      )
    (countdown (s5-5 (-> this loaded-texture-page-count))
      (dotimes (v1-89 32)
        (when (= (-> this loaded-texture-page s5-5) (-> *texture-pool* common-page v1-89))
          (set! (-> *texture-pool* common-page v1-89) (the-as texture-page 0))
          0
          )
        )
      (unload-page *texture-pool* (-> this loaded-texture-page s5-5))
      )
    (set! (-> this loaded-texture-page-count) 0)
    (unlink-shaders-in-heap *texture-page-dir* (-> this heap))
    (unlink-part-group-by-heap (-> this heap))
    (unlink-lightning-spec-by-heap (-> this heap))
    (particle-adgif-cache-flush)
    (set! (-> this loaded-text-info-count) 0)
    (dotimes (s5-6 2)
      (let ((v1-103 (-> *art-control* buffer s5-6 pending-load-file)))
        (if (and (>= (the-as int v1-103) (the-as int (-> this heap base)))
                 (< (the-as int v1-103) (the-as int (-> this heap top-base)))
                 )
            (set-pending-file (-> *art-control* buffer s5-6) (the-as string #f) -1 (the-as handle #f) 100000000.0)
            )
        )
      )
    (let ((v1-112 0)
          (a0-79 0)
          (a1-27 (-> this level-type))
          )
      (while a1-27
        (+! a0-79 1)
        (+! v1-112 (-> a1-27 psize))
        (set! (-> a1-27 symbol value) (the-as object 0))
        (set! a1-27 (the-as type (-> a1-27 method-table 8)))
        )
      )
    (let* ((s5-7 (-> this info packages))
           (a0-80 (car s5-7))
           )
      (while (not (null? s5-7))
        (case (rtype-of a0-80)
          ((symbol)
           (unload (symbol->string (the-as symbol a0-80)))
           )
          ((string)
           (unload (the-as string a0-80))
           )
          )
        (set! s5-7 (cdr s5-7))
        (set! a0-80 (car s5-7))
        )
      )
    (vis-clear this)
    (let ((v1-127 (-> this heap)))
      (set! (-> v1-127 current) (-> v1-127 base))
      )
    (set! (-> this memory-mask) (the-as uint 0))
    (set! (-> this code-memory-start) (the-as pointer 0))
    (set! (-> this code-memory-end) (the-as pointer 0))
    (set! (-> this level-type) #f)
    (when (= (-> *level* loading-level) this)
      (set! loading-level global)
      (set! (-> *level* loading-level) (-> *level* level-default))
      (set! (-> *level* log-in-level-bsp) #f)
      (set! *level-type-list* (the-as type 0))
      0
      )
    (assign-draw-indices *level*)
    )
  this
  )

;; definition for method 11 of type level
;; ERROR: Unsupported inline assembly instruction kind - [addiu a0, a0, 56]
(defmethod is-object-visible? ((this level) (arg0 int))
  "Look up object visibility from bit-string."
  (local-vars (a0-1 int) (a0-3 int))
  (let ((v1-0 (-> this vis-bits)))
    (shift-arith-right-32 a0-1 arg0 3)
    (let ((v1-2 (-> (the-as (pointer int8) (+ a0-1 (the-as int v1-0))))))
      (let ((a0-2 (logand arg0 7)))
        (.addiu a0-3 a0-2 56)
        )
      (< (shl v1-2 a0-3) 0)
      )
    )
  )

;; definition for method 15 of type level
(defmethod inside-bsp? ((this level))
  "Check if the camera is inside the BSP for this level."
  (cond
    ((not (-> this bsp))
     #f
     )
    ((-> this force-inside?)
     #t
     )
    (else
      (zero? (-> this bsp cam-outside-bsp))
      )
    )
  )

;; definition for method 20 of type level
;; WARN: Return type mismatch int vs none.
(defmethod debug-print-region-splitbox ((this level) (arg0 vector) (arg1 object))
  (cond
    ((or (not (-> this bsp)) (zero? (-> this bsp region-tree)))
     )
    ((nonzero? (-> this bsp region-tree))
     (debug-print (-> this bsp region-tree) arg0 arg1)
     )
    )
  0
  (none)
  )

;; definition for method 8 of type level
(defmethod mem-usage ((this level) (usage memory-usage-block) (flags int))
  (when (= (-> this status) 'active)
    (set! (-> usage length) (max 68 (-> usage length)))
    (set! (-> usage data 67 name) "entity-links")
    (+! (-> usage data 67 count) (-> this entity length))
    (let ((v1-8 (asize-of (-> this entity))))
      (+! (-> usage data 67 used) v1-8)
      (+! (-> usage data 67 total) (logand -16 (+ v1-8 15)))
      )
    (mem-usage (-> this art-group) usage flags)
    (set! (-> usage length) (max 67 (-> usage length)))
    (set! (-> usage data 66 name) "level-code")
    (+! (-> usage data 66 count) 1)
    (let ((v1-20 (&- (-> this code-memory-end) (the-as uint (-> this code-memory-start)))))
      (+! (-> usage data 66 used) v1-20)
      (+! (-> usage data 66 total) (logand -16 (+ v1-20 15)))
      )
    (countdown (s3-0 (-> this loaded-texture-page-count))
      (mem-usage (-> this loaded-texture-page s3-0) usage flags)
      )
    (countdown (s3-1 (-> this loaded-text-info-count))
      (mem-usage (-> this loaded-text-info s3-1) usage flags)
      )
    (countdown (s3-2 8)
      (let ((s2-0 (-> this vis-info s3-2)))
        (when s2-0
          (cond
            ((zero? s3-2)
             (set! (-> usage length) (max 63 (-> usage length)))
             (set! (-> usage data 62 name) "bsp-leaf-vis-self")
             (+! (-> usage data 62 count) 1)
             (let ((v1-47 (+ (asize-of s2-0) (-> s2-0 allocated-length))))
               (+! (-> usage data 62 used) v1-47)
               (+! (-> usage data 62 total) (logand -16 (+ v1-47 15)))
               )
             )
            (else
              (set! (-> usage length) (max 64 (-> usage length)))
              (set! (-> usage data 63 name) "bsp-leaf-vis-adj")
              (+! (-> usage data 63 count) 1)
              (let ((v1-58 (+ (asize-of s2-0) (-> s2-0 allocated-length))))
                (+! (-> usage data 63 used) v1-58)
                (+! (-> usage data 63 total) (logand -16 (+ v1-58 15)))
                )
              )
            )
          )
        )
      )
    (mem-usage (-> this bsp) usage flags)
    )
  this
  )

;; definition for method 21 of type level-group
;; WARN: Return type mismatch int vs none.
(defmethod init-level-system ((this level-group) (arg0 symbol))
  "If needed, initialize the level system by loading common/art packages and allocating level heaps."
  (when (zero? (-> *level* heap base))
    (kmemopen global "level-heaps")
    (when (nmember "game" *kernel-packages*)
      (set! *kernel-packages* (cons "art" *kernel-packages*))
      (set! *kernel-packages* (cons "common" *kernel-packages*))
      )
    (load-package "art" global)
    (if arg0
        (load-package "common" global)
        )
    (let ((s5-1 (if (and arg0 (not *debug-segment*))
                    #x11f7000
                    #x1af2800
                    )
                )
          (gp-1 (-> this heap))
          )
      (set! (-> gp-1 base) (kmalloc global s5-1 (kmalloc-flags) "heap"))
      (set! (-> gp-1 current) (-> gp-1 base))
      (set! (-> gp-1 top-base) (&+ (-> gp-1 base) s5-1))
      (set! (-> gp-1 top) (-> gp-1 top-base))
      )
    (kmemclose)
    )
  0
  (none)
  )

;; definition for method 10 of type level-group
(defmethod level-get-with-status ((this level-group) (arg0 symbol))
  "Get the first level with the given status, #f if there are none."
  (dotimes (v1-0 (-> this length))
    (if (= (-> this level v1-0 status) arg0)
        (return (-> this level v1-0))
        )
    )
  (the-as level #f)
  )

;; definition for method 30 of type level-group
(defmethod level-get-most-disposable ((this level-group))
  "Get the level inside this level-group that should
   be used to load a new level."
  (dotimes (v1-0 (-> this length))
    (case (-> this level v1-0 status)
      (('inactive)
       (return (-> this level v1-0))
       )
      )
    )
  (dotimes (v1-6 (-> this length))
    (case (-> this level v1-6 status)
      (('loading 'loading-bt)
       (return (-> this level v1-6))
       )
      )
    )
  (dotimes (v1-12 (-> this length))
    (case (-> this level v1-12 status)
      (('loaded)
       (return (-> this level v1-12))
       )
      )
    )
  (let ((v0-0 (the-as level #f)))
    (dotimes (v1-18 (-> this length))
      (case (-> this level v1-18 status)
        (('active)
         (if (and (not (-> this level v1-18 inside-boxes?))
                  (or (not v0-0) (< (-> this level v1-18 info priority) (-> v0-0 info priority)))
                  )
             (set! v0-0 (-> this level v1-18))
             )
         )
        )
      )
    v0-0
    )
  )

;; definition for method 9 of type level-group
(defmethod level-get ((this level-group) (arg0 symbol))
  "Lookup loaded level by name."
  (when arg0
    (dotimes (v1-0 (-> this length))
      (if (and (!= (-> this level v1-0 status) 'inactive)
               (or (= (-> this level v1-0 name) arg0) (= (-> this level v1-0 load-name) arg0))
               )
          (return (-> this level v1-0))
          )
      )
    (the-as level #f)
    )
  )

;; definition for method 22 of type level-group
(defmethod art-group-get-by-name ((this level-group) (arg0 string) (arg1 (pointer level)))
  "Check all levels for an art group with the given name."
  (countdown (s4-0 11)
    (let ((s3-0 (-> *level* level s4-0)))
      (when (or (= (-> s3-0 status) 'active) (= (-> s3-0 status) 'reserved))
        (countdown (s2-0 (-> s3-0 art-group art-group-array length))
          (when (name= (-> s3-0 art-group art-group-array s2-0 name) arg0)
            (if arg1
                (set! (-> arg1 0) s3-0)
                )
            (return (-> s3-0 art-group art-group-array s2-0))
            )
          )
        )
      )
    )
  (the-as art-group #f)
  )

;; definition for method 13 of type level-group
(defmethod activate-levels! ((this level-group))
  "Make all levels 'active!"
  (dotimes (s5-0 (-> this length))
    (level-status-update! (-> this level s5-0) 'active)
    )
  0
  )

;; definition for method 20 of type level-group
(defmethod level-get-target-inside ((this level-group))
  "Get the level that the player is 'in'."
  (let ((s5-0 (target-pos 0)))
    (let ((v1-1 (-> *load-state* vis-nick)))
      (when v1-1
        (dotimes (a0-3 (-> this length))
          (let ((a1-3 (-> this level a0-3)))
            (when (= (-> a1-3 status) 'active)
              (if (and (= (-> a1-3 name) v1-1) (not (logtest? (-> a1-3 info level-flags) (level-flags lf1))))
                  (return a1-3)
                  )
              )
            )
          )
        )
      )
    (let ((v1-5 (-> *game-info* current-continue level)))
      (dotimes (a0-5 (-> this length))
        (let ((a1-8 (-> this level a0-5)))
          (when (= (-> a1-8 status) 'active)
            (if (and (= (-> a1-8 name) v1-5) (not (logtest? (-> a1-8 info level-flags) (level-flags lf1))))
                (return a1-8)
                )
            )
          )
        )
      )
    (let ((s4-0 (the-as level #f)))
      (let ((f30-0 0.0))
        (dotimes (s3-0 (-> this length))
          (let ((s2-0 (-> this level s3-0)))
            (when (= (-> s2-0 status) 'active)
              (let ((f0-0 (vector-vector-distance (-> s2-0 bsp bsphere) s5-0)))
                (if (and (-> s2-0 inside-boxes?)
                         (not (logtest? (-> s2-0 info level-flags) (level-flags lf1)))
                         (or (not s4-0) (< f0-0 f30-0))
                         )
                    (set! s4-0 s2-0)
                    )
                )
              )
            )
          )
        )
      (if s4-0
          (return s4-0)
          )
      )
    )
  (dotimes (v1-26 (-> this length))
    (let ((a0-11 (-> this level v1-26)))
      (when (= (-> a0-11 status) 'active)
        (if (and (-> a0-11 meta-inside?) (not (logtest? (-> a0-11 info level-flags) (level-flags lf1))))
            (return a0-11)
            )
        )
      )
    )
  (let ((v0-1 (the-as level #f)))
    0.0
    (dotimes (v1-29 (-> this length))
      (let ((a0-16 (-> this level v1-29)))
        (when (= (-> a0-16 status) 'active)
          (if (and (not v0-1) (not (logtest? (-> a0-16 info level-flags) (level-flags lf1))))
              (set! v0-1 a0-16)
              )
          )
        )
      )
    v0-1
    )
  )

;; definition for method 8 of type level-group
(defmethod mem-usage ((this level-group) (usage memory-usage-block) (flags int))
  (dotimes (s3-0 (-> this length))
    (mem-usage (-> this level s3-0) usage flags)
    )
  this
  )

;; definition for function bg
;; WARN: Return type mismatch int vs none.
(defun bg ((arg0 symbol))
  "Debug function to start playing a given level."
  (set! *cheat-mode* (if *debug-segment*
                         'debug
                         #f
                         )
        )
  (let ((v1-2 (lookup-level-info arg0)))
    (cond
      ((= (-> v1-2 visname) arg0)
       (set! (-> *level* vis?) #t)
       (set! arg0 (-> v1-2 name))
       )
      (else
        (set! (-> *level* vis?) #f)
        (set! (-> *kernel-context* low-memory-message) #f)
        )
      )
    (let ((a0-8 (-> v1-2 memory-mode)))
      (if (or (= a0-8 (level-memory-mode borrow)) (or (= a0-8 (level-memory-mode borrow0))
                                                      (= a0-8 (level-memory-mode borrow1))
                                                      (= a0-8 (level-memory-mode borrow2))
                                                      (= a0-8 (level-memory-mode borrow3))
                                                      (= a0-8 (level-memory-mode borrow4))
                                                      (= a0-8 (level-memory-mode borrow-city-small))
                                                      )
              )
          (set! (-> v1-2 memory-mode) (level-memory-mode small-edge))
          )
      )
    (let* ((s5-0 (-> v1-2 run-packages))
           (a0-12 (car s5-0))
           )
      (while (not (null? s5-0))
        (case (rtype-of a0-12)
          ((symbol)
           (load-package (symbol->string (the-as symbol a0-12)) global)
           )
          ((string)
           (load-package (the-as string a0-12) global)
           )
          )
        (set! s5-0 (cdr s5-0))
        (set! a0-12 (car s5-0))
        )
      )
    )
  (let ((s5-1 (level-get-for-use *level* arg0 'active)))
    (while (and s5-1
                (or (= (-> s5-1 status) 'loading) (= (-> s5-1 status) 'loading-bt) (= (-> s5-1 status) 'login))
                (not *dproc*)
                )
      (load-continue s5-1)
      )
    (reset! *load-state*)
    (set! (-> *load-state* vis-nick) (-> s5-1 name))
    (set! (-> *load-state* want 0 name) (-> s5-1 name))
    (set! (-> *load-state* want 0 display?) 'display)
    (if (-> s5-1 info continues)
        (set-continue! *game-info* (the-as basic (car (-> s5-1 info continues))) #f)
        )
    )
  (dotimes (v1-35 3)
    (set! (-> *load-state* want-sound v1-35 name) (-> *game-info* current-continue want-sound v1-35))
    (set! (-> *load-state* want-sound v1-35 mode) (sound-bank-mode unknown))
    )
  (add-borrow-levels *load-state*)
  (activate-levels! *level*)
  (set! *print-login* #f)
  (cond
    ((= arg0 'halfpipe)
     (send-event (ppointer->process *time-of-day*) 'change 'ratio 0.0)
     (send-event (ppointer->process *time-of-day*) 'change 'hour 14)
     (set! (-> *time-of-day-context* mode) (time-of-day-palette-id unk0 unk1))
     )
    (else
      (set! (-> *time-of-day-context* mode) (time-of-day-palette-id unk3))
      )
    )
  0
  (none)
  )

;; definition for function play
(defun play ((arg0 symbol) (arg1 symbol))
  "Start (or restart) the game!
   This will start up the display process, and load the initial level."
  (kmemopen global "level-boot")
  (when *kernel-boot-level*
    (bg (string->symbol (the-as string *kernel-boot-level*)))
    (on #f)
    (kmemclose)
    (kmemclose)
    (return 0)
    )
  *kernel-boot-message*
  (let ((s5-0 (if *debug-segment*
                  'wasall
                  'title
                  )
              )
        )
    (stop 'play)
    (set! (-> *level* vis?) arg0)
    (set! (-> *level* want-level) #f)
    (set! (-> *level* border?) #t)
    (set! (-> *setting-control* user-default border-mode) #t)
    (set! (-> *level* play?) #t)
    (init-level-system *level* #t)
    (set! *display-profile* #f)
    (set! *cheat-mode* (if *debug-segment*
                           'debug
                           #f
                           )
          )
    (set! *time-of-day-fast* #f)
    (send-event (ppointer->process *time-of-day*) 'change 'ratio 1.0)
    (send-event (ppointer->process *time-of-day*) 'change 'hour 7)
    (send-event (ppointer->process *time-of-day*) 'change 'minutes 0)
    (send-event (ppointer->process *time-of-day*) 'change 'seconds 0)
    (send-event (ppointer->process *time-of-day*) 'change 'frames 0)
    (set! (-> *time-of-day-context* mode) (time-of-day-palette-id unk3))
    (set! (-> *mood-control* overide-weather-flag) #f)
    (set-blackout-frames (seconds 0.02))
    (when (not *dproc*)
      (reset! *load-state*)
      (let ((s4-1 (level-get-for-use *level* s5-0 'active)))
        (let ((a1-9 (new 'stack-no-clear 'array 'symbol 10)))
          (set! (-> a1-9 9) #f)
          (set! (-> a1-9 8) #f)
          (set! (-> a1-9 7) #f)
          (set! (-> a1-9 6) #f)
          (set! (-> a1-9 5) #f)
          (set! (-> a1-9 4) #f)
          (set! (-> a1-9 3) #f)
          (set! (-> a1-9 2) #f)
          (set! (-> a1-9 1) (if (= s5-0 'ctysluma)
                                'ctywide
                                )
                )
          (set! (-> a1-9 0) s5-0)
          (want-levels *load-state* a1-9)
          )
        (want-display-level *load-state* s5-0 'display)
        (if (= s5-0 'ctysluma)
            (want-display-level *load-state* 'ctywide 'display)
            )
        (want-vis-level *load-state* s5-0)
        (while (and s4-1 (or (= (-> s4-1 status) 'loading) (= (-> s4-1 status) 'loading-bt) (= (-> s4-1 status) 'login)))
          (set-blackout-frames (seconds 0.02))
          (load-continue s4-1)
          )
        )
      )
    (set! *print-login* #f)
    (level-status-update! (level-get *level* s5-0) 'active)
    )
  (on #t)
  (if arg1
      (initialize! *game-info* 'boot (the-as game-save #f) (the-as string #f) (the-as resetter-spec #f))
      )
  (kmemclose)
  (kmemclose)
  0
  )

;; definition for function play-boot
;; WARN: Return type mismatch int vs none.
(defun play-boot ()
  "Function called by the C Kernel to start the game (wrapper around play)."
  (process-spawn-function
    process
    (lambda () (play #t #t) (none))
    :from *4k-dead-pool*
    :stack *kernel-dram-stack*
    )
  0
  (none)
  )

;; definition for function sound-bank-name->mode
;; WARN: Return type mismatch int vs sound-bank-mode.
(defun sound-bank-name->mode ((arg0 symbol))
  (let ((v1-0 arg0))
    (the-as sound-bank-mode (cond
                              ((or (= v1-0 'half1)
                                   (= v1-0 'half2)
                                   (= v1-0 'ctyslmch)
                                   (= v1-0 'ctyslmbh)
                                   (= v1-0 'ctygnbh)
                                   (= v1-0 'ctyindh)
                                   (= v1-0 'ctyslmah)
                                   (= v1-0 'ctyporth)
                                   (= v1-0 'mhcity1h)
                                   (= v1-0 'mhcity2h)
                                   (= v1-0 'citypedh)
                                   (= v1-0 'cityffh)
                                   (= v1-0 'citycarh)
                                   (= v1-0 'vinroomh)
                                   (= v1-0 'ctyprtdh)
                                   (= v1-0 'citybbh)
                                   )
                               5
                               )
                              ((= v1-0 'ctywide)
                               9
                               )
                              (else
                                4
                                )
                              )
            )
    )
  )

;; definition for function update-sound-banks
;; WARN: Return type mismatch int vs none.
;; WARN: Function update-sound-banks has a return type of none, but the expression builder found a return statement.
(defun update-sound-banks ((arg0 load-state) (arg1 (inline-array sound-bank-state)))
  (local-vars (v1-90 symbol))
  (let ((s4-0 0)
        (s5-0 (the-as object #f))
        )
    (dotimes (v1-1 6)
      (set! (-> arg0 want-exp-sound v1-1 name) #f)
      (set! (-> arg0 want-exp-sound v1-1 mode) (sound-bank-mode none))
      (set! (-> arg0 target-sound v1-1 name) #f)
      (set! (-> arg0 target-sound v1-1 mode) (sound-bank-mode none))
      )
    (dotimes (s3-0 3)
      (let ((a0-10 (the-as object (-> *load-state* want-sound s3-0 name))))
        (dotimes (v1-6 (-> *level* length))
          (let ((a1-4 (-> *level* level v1-6)))
            (when (= (-> a1-4 status) 'active)
              (let ((a1-6 (-> a1-4 info extra-sound-bank)))
                (when a1-6
                  (let ((a2-4 (car a1-6)))
                    (while (not (null? a1-6))
                      (if (= (car a2-4) a0-10)
                          (set! a0-10 (cdr a2-4))
                          )
                      (set! a1-6 (cdr a1-6))
                      (set! a2-4 (car a1-6))
                      )
                    )
                  )
                )
              )
            )
          )
        (dotimes (v1-9 (the-as int (-> *setting-control* user-current extra-bank-count)))
          (let ((a1-13 (and (not (null? (-> *setting-control* user-current extra-bank v1-9)))
                            (-> *setting-control* user-current extra-bank v1-9)
                            )
                       )
                )
            (when a1-13
              (let ((a2-12 (car a1-13)))
                (while (not (null? a1-13))
                  (cond
                    ((and (= s3-0 2) (= (car a2-12) 'force2))
                     (set! s5-0 (car (cdr a2-12)))
                     )
                    ((= (car a2-12) a0-10)
                     (set! a0-10 (cdr a2-12))
                     )
                    )
                  (set! a1-13 (cdr a1-13))
                  (set! a2-12 (car (the-as pair a1-13)))
                  )
                )
              )
            )
          )
        (case (rtype-of a0-10)
          ((symbol)
           (when a0-10
             (set! (-> arg0 want-exp-sound s4-0 name) (the-as symbol a0-10))
             (set! (-> arg0 want-exp-sound s4-0 mode) (sound-bank-name->mode (the-as symbol a0-10)))
             (+! s4-0 1)
             )
           )
          ((pair)
           (let* ((s2-0 (the-as pair a0-10))
                  (a0-11 (car s2-0))
                  )
             (while (not (null? s2-0))
               (when a0-11
                 (set! (-> arg0 want-exp-sound s4-0 name) (the-as symbol a0-11))
                 (set! (-> arg0 want-exp-sound s4-0 mode) (sound-bank-name->mode (the-as symbol a0-11)))
                 (+! s4-0 1)
                 )
               (set! s2-0 (cdr s2-0))
               (set! a0-11 (car s2-0))
               )
             )
           )
          )
        )
      )
    (if (= *city-mode* 'ctywide)
        (city-sound-expand-want-list)
        )
    (when s5-0
      (cond
        ((-> arg0 want-exp-sound 1)
         (set! (-> arg0 want-exp-sound 2 name) (the-as symbol s5-0))
         (set! (-> arg0 want-exp-sound 2 mode) (sound-bank-name->mode (the-as symbol s5-0)))
         )
        ((-> arg0 want-exp-sound)
         (set! (-> arg0 want-exp-sound 1 name) (the-as symbol s5-0))
         (set! (-> arg0 want-exp-sound 1 mode) (sound-bank-name->mode (the-as symbol s5-0)))
         )
        (else
          (set! (-> arg0 want-exp-sound 0 name) (the-as symbol s5-0))
          (set! (-> arg0 want-exp-sound 0 mode) (sound-bank-name->mode (the-as symbol s5-0)))
          )
        )
      )
    )
  (let ((s4-1 0)
        (s3-1 0)
        (s2-1 0)
        (s1-0 0)
        (s5-1 (new 'stack-no-clear 'array 'int8 36))
        )
    (dotimes (v1-43 10)
      (set! (-> s5-1 v1-43) 0)
      )
    (dotimes (s0-0 6)
      (case (-> arg0 want-exp-sound s0-0 mode)
        (((sound-bank-mode virtual))
         )
        (((sound-bank-mode full))
         (if (>= s2-1 3)
             (goto cfg-80)
             )
         (+! s2-1 1)
         (+! s3-1 1)
         (mem-copy! (the-as pointer (-> arg0 target-sound s1-0)) (the-as pointer (-> arg0 want-exp-sound s0-0)) 8)
         (+! s1-0 1)
         )
        (((sound-bank-mode half))
         (cond
           ((even? s4-1)
            (if (>= s2-1 3)
                (goto cfg-80)
                )
            (+! s2-1 1)
            (mem-copy! (the-as pointer (-> arg0 target-sound s1-0)) (the-as pointer (-> arg0 want-exp-sound s0-0)) 8)
            )
           (else
             (mem-copy! (the-as pointer (-> arg0 target-sound s1-0)) (the-as pointer (-> arg0 want-exp-sound s0-0)) 8)
             )
           )
         (set! (-> arg0 target-sound s1-0 mode) (sound-bank-mode half))
         (+! s4-1 1)
         (+! s1-0 1)
         )
        )
      (label cfg-80)
      )
    (let ((v1-76 0))
      (dotimes (a0-28 6)
        (case (-> arg0 target-sound a0-28 mode)
          (((sound-bank-mode half))
           (dotimes (a1-32 6)
             (when (= (-> *level* sound-bank a1-32 name) (-> arg0 target-sound a0-28 name))
               (let ((a2-26 (-> *level* sound-bank a1-32 mode)))
                 (when (and (>= (the-as uint a2-26) (the-as uint 6))
                            (>= (the-as uint 8) (the-as uint a2-26))
                            (not (and (nonzero? s3-1)
                                      (= (+ v1-76 1) s4-1)
                                      (< 1 s4-1)
                                      (zero? (-> s5-1 a2-26))
                                      (or (= (-> s5-1 6) 1) (= (-> s5-1 7) 1) (= (-> s5-1 8) 1))
                                      )
                                 )
                            )
                   (set! (-> arg0 target-sound a0-28 mode) (-> *level* sound-bank a1-32 mode))
                   (+! (-> s5-1 a2-26) 1)
                   (+! v1-76 1)
                   )
                 )
               (goto cfg-112)
               )
             )
           )
          )
        (label cfg-112)
        )
      )
    (dotimes (v1-79 6)
      (case (-> arg0 target-sound v1-79 mode)
        (((sound-bank-mode half))
         (cond
           ((= (-> s5-1 6) 1)
            (+! (-> s5-1 6) 1)
            (set! (-> arg0 target-sound v1-79 mode) (sound-bank-mode halfa))
            )
           ((= (-> s5-1 7) 1)
            (+! (-> s5-1 7) 1)
            (set! (-> arg0 target-sound v1-79 mode) (sound-bank-mode halfb))
            )
           ((= (-> s5-1 8) 1)
            (+! (-> s5-1 8) 1)
            (set! (-> arg0 target-sound v1-79 mode) (sound-bank-mode halfc))
            )
           ((zero? (-> s5-1 6))
            (+! (-> s5-1 6) 1)
            (set! (-> arg0 target-sound v1-79 mode) (sound-bank-mode halfa))
            )
           ((zero? (-> s5-1 7))
            (+! (-> s5-1 7) 1)
            (set! (-> arg0 target-sound v1-79 mode) (sound-bank-mode halfb))
            )
           ((zero? (-> s5-1 8))
            (+! (-> s5-1 8) 1)
            (set! (-> arg0 target-sound v1-79 mode) (sound-bank-mode halfc))
            )
           )
         )
        )
      )
    )
  (if (or (nonzero? (rpc-busy? 1)) (not (-> *setting-control* user-current sound-bank-load)))
      (return 0)
      )
  (dotimes (s4-2 6)
    (let ((s5-2 (-> arg0 target-sound s4-2))
          (s2-2
            (lambda ((arg0 load-state) (arg1 sound-bank-state))
              (if (not (-> arg1 name))
                  (return #f)
                  )
              (countdown (v1-3 6)
                (if (and (= (-> arg1 name) (-> arg0 target-sound v1-3 name)) (= (-> arg1 mode) (-> arg0 target-sound v1-3 mode)))
                    (return #t)
                    )
                )
              #f
              )
            )
          )
      (set! v1-90 (and (-> s5-2 name) (begin
                                        (dotimes (v1-91 6)
                                          (when (and (= (-> s5-2 name) (-> *level* sound-bank v1-91 name))
                                                     (= (-> s5-2 mode) (-> *level* sound-bank v1-91 mode))
                                                     )
                                            (set! v1-90 #f)
                                            (goto cfg-150)
                                            )
                                          )
                                        #t
                                        )
                       )
            )
      (label cfg-150)
      (when v1-90
        (let ((s3-2 -1))
          (let ((v1-94 -1))
            (case (-> s5-2 mode)
              (((sound-bank-mode full))
               )
              (else
                (dotimes (a0-70 3)
                  (if (or (= (-> *level* sound-bank (* a0-70 2) mode) (-> s5-2 mode))
                          (= (-> *level* sound-bank (+ (* a0-70 2) 1) mode) (-> s5-2 mode))
                          )
                      (set! v1-94 a0-70)
                      )
                  )
                )
              )
            (dotimes (a0-73 3)
              (case (-> s5-2 mode)
                (((sound-bank-mode full))
                 (when (and (not (-> *level* sound-bank (* a0-73 2) name)) (not (-> *level* sound-bank (+ (* a0-73 2) 1) name)))
                   (set! s3-2 (* a0-73 2))
                   (goto cfg-224)
                   )
                 )
                (else
                  (when (or (< v1-94 0) (= v1-94 a0-73))
                    (when (and (not (-> *level* sound-bank (* a0-73 2) name))
                               (or (not (-> *level* sound-bank (+ (* a0-73 2) 1) name))
                                   (= (-> *level* sound-bank (+ (* a0-73 2) 1) mode) (-> s5-2 mode))
                                   )
                               )
                      (set! s3-2 (* a0-73 2))
                      (goto cfg-224)
                      )
                    (when (and (not (-> *level* sound-bank (+ (* a0-73 2) 1) name))
                               (= (-> *level* sound-bank (* a0-73 2) mode) (-> s5-2 mode))
                               )
                      (set! s3-2 (+ (* a0-73 2) 1))
                      (goto cfg-224)
                      )
                    )
                  )
                )
              )
            )
          (case (-> s5-2 mode)
            (((sound-bank-mode full))
             )
            (else
              (let ((s1-1 0))
                (while (< s1-1 6)
                  (when (or (and (-> *level* sound-bank s1-1 name)
                                 (= (-> *level* sound-bank s1-1 mode) (-> s5-2 mode))
                                 (not (s2-2 arg0 (-> *level* sound-bank s1-1)))
                                 )
                            (= (-> *level* sound-bank s1-1 name) (-> s5-2 name))
                            )
                    (format 0 "Unload soundbank ~A from slot ~D~%" (-> *level* sound-bank s1-1 name) s1-1)
                    (sound-bank-unload (string->sound-name (symbol->string (-> *level* sound-bank s1-1 name))))
                    (set! (-> *level* sound-bank s1-1 name) #f)
                    (set! (-> *level* sound-bank s1-1 mode) (sound-bank-mode none))
                    (return 0)
                    )
                  (set! s1-1 (+ s1-1 1))
                  )
                )
              )
            )
          (dotimes (s1-2 3)
            (when (and (not (s2-2 arg0 (-> *level* sound-bank (* s1-2 2))))
                       (not (s2-2 arg0 (-> *level* sound-bank (+ (* s1-2 2) 1))))
                       )
              (let ((gp-2 (if (-> *level* sound-bank (* s1-2 2) name)
                              (* s1-2 2)
                              (+ (* s1-2 2) 1)
                              )
                          )
                    )
                (format 0 "Unload soundbank ~A from slot ~D~%" (-> *level* sound-bank gp-2 name) gp-2)
                (sound-bank-unload (string->sound-name (symbol->string (-> *level* sound-bank gp-2 name))))
                (set! (-> *level* sound-bank gp-2 name) #f)
                (set! (-> *level* sound-bank gp-2 mode) (sound-bank-mode none))
                )
              (return 0)
              )
            )
          (label cfg-224)
          (let ((s2-3 0))
            (while (< s2-3 6)
              (when (= (-> *level* sound-bank s2-3 name) (-> s5-2 name))
                (format 0 "Unload soundbank ~A from slot ~D~%" (-> *level* sound-bank s2-3 name) s2-3)
                (sound-bank-unload (string->sound-name (symbol->string (-> *level* sound-bank s2-3 name))))
                (set! (-> *level* sound-bank s2-3 name) #f)
                (set! (-> *level* sound-bank s2-3 mode) (sound-bank-mode none))
                (return 0)
                )
              (set! s2-3 (+ s2-3 1))
              )
            )
          (when (>= s3-2 0)
            (format 0 "Load soundbank ~A in slot ~D~%" (-> s5-2 name) s3-2)
            (sound-bank-load (string->sound-name (symbol->string (-> s5-2 name))) (the-as int (-> s5-2 mode)) 0)
            (mem-copy! (the-as pointer (-> *level* sound-bank s3-2)) (the-as pointer s5-2) 8)
            (return 0)
            )
          )
        )
      )
    )
  0
  (none)
  )

;; definition for method 10 of type load-state
(defmethod update! ((this load-state))
  (local-vars (a0-11 symbol))
  (if (-> this update-callback)
      ((-> this update-callback) this)
      )
  (let ((v1-3 #f))
    (let ((s5-0 0))
      -1
      (countdown (s4-0 10)
        (let ((a0-3 -1))
          (countdown (a1-0 10)
            (let ((a2-3 (-> *level* level a1-0)))
              (when (and (!= (-> a2-3 status) 'inactive) (>= (-> a2-3 load-order) (the-as uint s5-0)))
                (let ((a3-5 #f))
                  (dotimes (t0-2 10)
                    (if (= (-> a2-3 name) (-> this target t0-2 name))
                        (set! a3-5 #t)
                        )
                    )
                  (when (not a3-5)
                    (set! s5-0 (the-as int (-> a2-3 load-order)))
                    (set! a0-3 a1-0)
                    )
                  )
                )
              )
            )
          (when (>= a0-3 0)
            (let ((s3-0 (-> *level* level a0-3)))
              (format 0 "Discarding level ~A~%" (-> s3-0 name))
              (level-status-update! s3-0 'inactive)
              )
            (set! v1-3 #t)
            )
          )
        )
      )
    (let ((s5-1 #f))
      (countdown (a0-10 10)
        (when (!= (-> *level* level a0-10 status) 'inactive)
          (set! a0-11 #f)
          (goto cfg-25)
          )
        )
      (set! a0-11 #t)
      (label cfg-25)
      (if a0-11
          (set! s5-1 #t)
          )
      (if v1-3
          (return 0)
          )
      (let ((v1-11 (new 'static 'boxed-array :type symbol :length 0 :allocated-length 10)))
        (countdown (a0-15 10)
          (set! (-> v1-11 a0-15) #f)
          )
        (dotimes (a0-18 10)
          (when (-> this target a0-18 name)
            (set! (-> v1-11 a0-18) (-> this target a0-18 name))
            (dotimes (a1-17 10)
              (let ((a2-13 (-> *level* level a1-17)))
                (if (and (!= (-> a2-13 status) 'inactive) (= (-> a2-13 name) (-> this target a0-18 name)))
                    (set! (-> v1-11 a0-18) #f)
                    )
                )
              )
            )
          )
        (let ((s4-1 -1))
          (dotimes (a0-21 10)
            (when (-> v1-11 a0-21)
              (set! s4-1 a0-21)
              (goto cfg-53)
              )
            )
          (label cfg-53)
          (when (!= s4-1 -1)
            (when (and (or s5-1 (not (check-busy *load-dgo-rpc*))) (not (load-in-progress? *level*)))
              (format 0 "Adding level ~A~%" (-> this target s4-1 name))
              (let ((s3-1 (level-get-for-use *level* (-> this target s4-1 name) 'loaded)))
                (when (and s5-1 (-> this target s4-1 display?))
                  (format 0 "Waiting for level to load~%")
                  (while (or (= (-> s3-1 status) 'loading) (= (-> s3-1 status) 'loading-bt) (= (-> s3-1 status) 'login))
                    (load-continue s3-1)
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  (dotimes (s5-2 10)
    (when (-> this target s5-2 name)
      (dotimes (s4-2 11)
        (let ((s3-2 (-> *level* level s4-2)))
          (when (!= (-> s3-2 status) 'inactive)
            (when (= (-> s3-2 name) (-> this target s5-2 name))
              (when (!= (-> s3-2 display?) (-> this target s5-2 display?))
                (cond
                  ((not (-> s3-2 display?))
                   (cond
                     ((or (= (-> s3-2 status) 'loaded) (= (-> s3-2 status) 'active))
                      (format 0 "Displaying level ~A [~A]~%" (-> this target s5-2 name) (-> this target s5-2 display?))
                      (level-get-for-use *level* (-> s3-2 info name) 'active)
                      (set! (-> s3-2 display?) (-> this target s5-2 display?))
                      )
                     (else
                       (if (and (logtest? (-> s3-2 info level-flags) (level-flags lf11))
                                (!= (-> this target s5-2 display?) 'display-no-wait)
                                )
                           (send-event *target* 'loading)
                           )
                       (if (and (= *cheat-mode* 'debug) (not *display-capture-mode*))
                           (format *stdcon* "display on for ~A but level is loading~%" (-> this target s5-2 name))
                           )
                       )
                     )
                   )
                  ((not (-> this target s5-2 display?))
                   (set! (-> s3-2 display?) #f)
                   (format 0 "Turning level ~A off~%" (-> s3-2 name))
                   (deactivate s3-2)
                   )
                  (else
                    (format
                      0
                      "Setting level ~A display command to ~A~%"
                      (-> this target s5-2 name)
                      (-> this target s5-2 display?)
                      )
                    (set! (-> s3-2 display?) (-> this target s5-2 display?))
                    )
                  )
                )
              (when (!= (-> s3-2 force-all-visible?) (-> this target s5-2 force-vis?))
                (set! (-> s3-2 force-all-visible?) (-> this target s5-2 force-vis?))
                (format
                  0
                  "Setting force-all-visible?[~A] to ~A~%"
                  (-> this target s5-2 name)
                  (-> this target s5-2 force-vis?)
                  )
                )
              (when (!= (-> s3-2 force-inside?) (-> this target s5-2 force-inside?))
                (format
                  0
                  "Setting force-inside?[~A] ~A->~A~%"
                  (-> this target s5-2 name)
                  (-> s3-2 force-inside?)
                  (-> this target s5-2 force-inside?)
                  )
                (set! (-> s3-2 force-inside?) (-> this target s5-2 force-inside?))
                )
              )
            )
          )
        )
      )
    )
  (when (-> *level* border?)
    (let ((v1-131 (the-as level #f))
          (a0-55 0)
          )
      (dotimes (a1-35 (-> *level* length))
        (let ((a2-32 (-> *level* level a1-35)))
          (when (= (-> a2-32 status) 'active)
            (when (and (-> a2-32 inside-boxes?) (not (null? (-> a2-32 info continues))))
              (if (= (-> a2-32 name) (-> this vis-nick))
                  (goto cfg-137)
                  )
              (if (or (not v1-131) (not (logtest? (-> a2-32 info level-flags) (level-flags lf1))))
                  (set! v1-131 a2-32)
                  )
              (+! a0-55 1)
              )
            )
          )
        )
      (if (and (>= a0-55 1) (!= (-> v1-131 name) (-> this vis-nick)))
          (want-vis-level this (-> v1-131 name))
          )
      )
    )
  (label cfg-137)
  (update-sound-banks this (-> *level* sound-bank))
  0
  )

;; definition for method 16 of type level-group
;; WARN: Return type mismatch int vs none.
(defmethod assign-draw-indices ((this level-group))
  "Assign the order for levels to be drawn."
  (local-vars (t0-3 symbol))
  (set! (-> this draw-level-count) 0)
  (dotimes (v1-0 11)
    (let ((f0-0 100000.0)
          (a1-1 (the-as level #f))
          )
      (dotimes (a2-0 (-> this length))
        (let ((a3-3 (-> this level a2-0)))
          (when (= (-> a3-3 status) 'active)
            (set! t0-3 (and (< (-> a3-3 draw-priority) f0-0) (begin
                                                               (dotimes (t0-4 (-> this draw-level-count))
                                                                 (when (= a3-3 (-> this draw-level t0-4))
                                                                   (set! t0-3 #f)
                                                                   (goto cfg-14)
                                                                   )
                                                                 )
                                                               #t
                                                               )
                            )
                  )
            (label cfg-14)
            (when t0-3
              (set! a1-1 a3-3)
              (set! f0-0 (-> a1-1 draw-priority))
              )
            )
          )
        )
      (when a1-1
        (set! (-> this draw-level (-> this draw-level-count)) a1-1)
        (set! (-> a1-1 draw-index) (-> this draw-level-count))
        (+! (-> this draw-level-count) 1)
        )
      )
    )
  (while (< (-> this draw-level-count) 11)
    (set! (-> this draw-level (-> this draw-level-count)) #f)
    (+! (-> this draw-level-count) 1)
    )
  (set! (-> this draw-level 10) (-> this level-default))
  (set! (-> (&-> this level-default draw-index) 0) 10)
  (dotimes (v1-13 11)
    (let ((a2-9 (-> this level v1-13)))
      (if a2-9
          (set! (-> this draw-index-map v1-13) (the-as uint (-> a2-9 draw-index)))
          )
      )
    )
  0
  (none)
  )

;; definition for method 19 of type level-group
;; WARN: Return type mismatch int vs none.
(defmethod level-update ((this level-group))
  "Per-frame update of the level system."
  (local-vars (v1-109 symbol))
  (camera-pos)
  (new 'static 'boxed-array :type symbol :length 0 :allocated-length 10)
  (update *setting-control*)
  (update *gui-control* #t)
  (update *art-control* #t)
  (clear-rec *art-control*)
  (dotimes (s5-0 10)
    (load-continue (-> this level s5-0))
    )
  (dotimes (s5-1 (-> this length))
    (let ((s4-0 (-> this level s5-1)))
      (when (= (-> s4-0 status) 'active)
        (let* ((a0-7 s4-0)
               (t9-6 (method-of-object a0-7 inside-bsp?))
               )
          (-> *math-camera* trans)
          (set! (-> s4-0 inside-boxes?) (the-as basic (t9-6 a0-7)))
          )
        (if (-> s4-0 inside-boxes?)
            (set! (-> s4-0 meta-inside?) #t)
            )
        )
      )
    )
  (update! *load-state*)
  (let ((s5-2 (level-get-target-inside this)))
    (dotimes (s4-1 (-> this length))
      (let ((s3-0 (-> this level s4-1)))
        (when (= (-> s3-0 status) 'active)
          (when (-> s3-0 inside-boxes?)
            (dotimes (v1-41 (-> this length))
              (let ((a0-14 (-> this level v1-41)))
                (when (= (-> a0-14 status) 'active)
                  (if (and (!= s3-0 a0-14) (not (-> a0-14 inside-boxes?)))
                      (set! (-> a0-14 meta-inside?) #f)
                      )
                  )
                )
              )
            )
          (when (and (= s3-0 s5-2)
                     (begin
                       (set! (-> *setting-control* user-default music) (-> s3-0 info music-bank))
                       (set! (-> *setting-control* user-default sound-reverb) (-> s3-0 info sound-reverb))
                       #t
                       )
                     (or (-> *level* border?) (logtest? (-> *game-info* current-continue flags) (continue-flags change-continue)))
                     (and (or (and (!= (-> s3-0 name) (-> *game-info* current-continue level))
                                   (or (not (logtest? (level-flags lf18) (-> s3-0 info level-flags)))
                                       (!= (-> s3-0 info taskname) (-> (lookup-level-info (-> *game-info* current-continue level)) taskname))
                                       )
                                   )
                              (logtest? (-> *game-info* current-continue flags) (continue-flags change-continue))
                              )
                          (not (null? (-> s3-0 info continues)))
                          (-> *setting-control* user-current allow-continue)
                          )
                     )
            (let ((s2-1 (car (-> s3-0 info continues))))
              (let* ((s1-0 (target-pos 0))
                     (s3-1 (-> s3-0 info continues))
                     (s0-0 (car s3-1))
                     )
                (while (not (null? s3-1))
                  (when (and (or (< (vector-vector-distance s1-0 (-> (the-as continue-point s0-0) trans))
                                    (vector-vector-distance s1-0 (-> (the-as continue-point s2-1) trans))
                                    )
                                 (string= (-> *game-info* current-continue name) (-> (the-as continue-point s0-0) name))
                                 )
                             (not (logtest? (-> (the-as continue-point s0-0) flags) (continue-flags change-continue no-auto)))
                             )
                    (set! s2-1 s0-0)
                    (if (string= (-> *game-info* current-continue name) (-> (the-as continue-point s0-0) name))
                        (goto cfg-62)
                        )
                    )
                  (set! s3-1 (cdr s3-1))
                  (set! s0-0 (car s3-1))
                  )
                )
              (label cfg-62)
              (if (and s2-1 (not (logtest? (-> (the-as continue-point s2-1) flags) (continue-flags change-continue no-auto))))
                  (set-continue! *game-info* (the-as basic s2-1) #f)
                  )
              )
            )
          )
        )
      )
    )
  (dotimes (v1-94 (-> this length))
    (let ((a0-48 (-> this level v1-94)))
      (when (= (-> a0-48 status) 'active)
        (set! (-> a0-48 vis-self-index) 0)
        0
        )
      )
    )
  (when (and (not *display-capture-mode*) (= *cheat-mode* 'debug))
    (dotimes (s5-3 (-> this length))
      (let ((v1-104 (-> this level s5-3)))
        (when (= (-> v1-104 status) 'active)
          (if (and (= (-> v1-104 status) 'active)
                   (!= (-> v1-104 display?) 'special)
                   (nonzero? (-> v1-104 bsp cam-outside-bsp))
                   )
              (format *stdcon* "~3Loutside of bsp ~S~%~0L" (-> v1-104 name))
              )
          )
        )
      )
    )
  (countdown (v1-108 10)
    (when (-> this level v1-108 inside-boxes?)
      (set! v1-109 #f)
      (goto cfg-96)
      )
    )
  (set! v1-109 #t)
  (label cfg-96)
  (cond
    (v1-109
      0
      )
    (else
      (dotimes (s5-4 (-> this length))
        (let ((s4-2 (-> this level s5-4)))
          (when (= (-> s4-2 status) 'active)
            (dotimes (s3-2 8)
              (let ((s2-2 (-> s4-2 vis-info s3-2)))
                (when s2-2
                  (set! (-> s2-2 flags) (the-as vis-info-flag (logclear (-> s2-2 flags) (vis-info-flag vis-valid))))
                  (cond
                    ((= s3-2 (-> s4-2 vis-self-index))
                     (set! (-> s2-2 from-bsp) (-> s4-2 bsp))
                     )
                    (else
                      (let ((v1-123 (level-get this (-> s2-2 from-level))))
                        (set! (-> s2-2 from-bsp) (if v1-123
                                                     (-> v1-123 bsp)
                                                     )
                              )
                        )
                      )
                    )
                  )
                )
              )
            (let ((v1-126 #f))
              (cond
                ((= (-> s4-2 display?) 'display-self)
                 (let ((v1-130 (-> s4-2 vis-info (-> s4-2 vis-self-index))))
                   (if v1-130
                       (set! (-> v1-130 flags) (the-as vis-info-flag (logior (vis-info-flag vis-valid) (-> v1-130 flags))))
                       )
                   )
                 )
                ((and (-> s4-2 inside-boxes?) (not v1-126))
                 (let ((v1-135 (-> s4-2 vis-info (-> s4-2 vis-self-index))))
                   (if v1-135
                       (set! (-> v1-135 flags) (the-as vis-info-flag (logior (vis-info-flag vis-valid) (-> v1-135 flags))))
                       )
                   )
                 )
                )
              )
            )
          )
        )
      )
    )
  (assign-draw-indices this)
  (when (or *display-level-border* *display-texture-distances* *display-texture-download* *display-split-box-info*)
    (when *display-level-border*
      (format
        *stdcon*
        "  want: ~A ~A/~A   ~A ~A/~A~%"
        (-> *load-state* want 0 name)
        (-> *load-state* want 0 display?)
        (-> *load-state* want 0 force-vis?)
        (-> *load-state* want 1 name)
        (-> *load-state* want 1 display?)
        (-> *load-state* want 1 force-vis?)
        )
      (let ((t9-20 format)
            (a0-86 *stdcon*)
            (a1-30 "  nick ~A cur ~S  cont ~A~%~%")
            (a2-6 (-> *load-state* vis-nick))
            (v1-156 (and *target* (-> *target* current-level) (-> *target* current-level name)))
            )
        (t9-20
          a0-86
          a1-30
          a2-6
          (if v1-156
              v1-156
              )
          (-> *game-info* current-continue name)
          )
        )
      )
    (dotimes (s5-5 11)
      (let ((s4-3 (-> this level s5-5)))
        (when (or (= (-> s4-3 status) 'active) (= (-> s4-3 status) 'reserved))
          (format
            *stdcon*
            "~A: ~S ~A~%"
            (-> s4-3 name)
            (if (-> s4-3 inside-boxes?)
                "inside"
                )
            (-> s4-3 display?)
            )
          (when *display-texture-distances*
            (format *stdcon* "~10Htfrag: ~8,,0m" (-> s4-3 closest-object 0))
            (format *stdcon* "~140Hshrub: ~8,,0m" (-> s4-3 closest-object 2))
            (format *stdcon* "~272Halpha: ~8,,0m~%" (-> s4-3 closest-object 3))
            (format *stdcon* "~27Htie: ~8,,0m" (-> s4-3 tie-min-dist))
            (format *stdcon* "~140Hfg-tf: ~8,,0m" (-> s4-3 fg-tfrag-min-dist))
            (format *stdcon* "~270Hfg-pr: ~8,,0m~%" (-> s4-3 fg-prim-min-dist))
            (format *stdcon* "~10Hfg-wa: ~8,,0m" (-> s4-3 fg-warp-min-dist))
            (format *stdcon* "~140Hfg-sh: ~8,,0m" (-> s4-3 fg-shrub-min-dist))
            (format *stdcon* "~267Hfg-p2: ~8,,0m~%" (-> s4-3 fg-prim2-min-dist))
            )
          (when *display-texture-download*
            (format
              *stdcon*
              "~30Htf: ~8D~134Hpr: ~8D~252Hsh: ~8D~370Hhd: ~8D~%"
              (-> s4-3 upload-size 0)
              (-> s4-3 upload-size 1)
              (-> s4-3 upload-size 2)
              (-> s4-3 upload-size 8)
              )
            (format
              *stdcon*
              "~30Hal: ~8D~131Hwa: ~8D~252Hsp: ~8D~370Hwp: ~8D~%"
              (-> s4-3 upload-size 3)
              (-> s4-3 upload-size 4)
              (-> s4-3 upload-size 7)
              (-> s4-3 upload-size 5)
              )
            (format *stdcon* "~30Hp2: ~8D~131Hhf: ~8D~%~1K" (-> s4-3 upload-size 6) (-> s4-3 upload-size 10))
            )
          (if *display-split-box-info*
              (debug-print-region-splitbox s4-3 (-> *math-camera* trans) *stdcon*)
              )
          )
        )
      )
    )
  (when (and (-> this disk-load-timing?) (-> this load-level))
    (let ((s5-6 format)
          (s4-4 *stdcon*)
          (s3-3 "~0Kload ~16S ~5S ~5DK  ~5,,2fs  ~5,,2fs~1K ~5,,0f k/s~%")
          (s2-3 (-> this load-level))
          (v1-188 (lookup-level-info (-> this load-level)))
          )
      (s5-6
        s4-4
        s3-3
        s2-3
        (if v1-188
            (-> v1-188 nickname)
            ""
            )
        (shr (-> this load-size) 10)
        (-> this load-time)
        (-> this load-login-time)
        (if (= (-> this load-time) 0.0)
            0
            (* 0.0009765625 (/ (the float (-> this load-size)) (-> this load-time)))
            )
        )
      )
    )
  (let ((v1-194 (- #x2000000 (the-as int (-> global current)))))
    (if (and (not *debug-segment*) (or (< v1-194 #x4000) (= *cheat-mode* 'debug)))
        (format
          *stdcon*
          "~3Lglobal heap fatally low at ~D.~DK free~%~0L"
          (sar v1-194 10)
          (/ (logand v1-194 1023) 103)
          )
        )
    )
  0
  (none)
  )

;; definition (debug) for function show-level
;; WARN: Return type mismatch int vs none.
(defun-debug show-level ((arg0 symbol))
  (set! (-> *setting-control* user-default border-mode) #t)
  (let ((s5-0 (new 'stack-no-clear 'array 'symbol 10)))
    (set! (-> s5-0 9) #f)
    (set! (-> s5-0 8) #f)
    (set! (-> s5-0 7) #f)
    (set! (-> s5-0 6) #f)
    (set! (-> s5-0 5) #f)
    (set! (-> s5-0 4) #f)
    (set! (-> s5-0 3) #f)
    (set! (-> s5-0 2) #f)
    (set! (-> s5-0 1) arg0)
    (set! (-> s5-0 0) (-> (level-get-target-inside *level*) name))
    (want-levels *load-state* s5-0)
    )
  (want-display-level *load-state* arg0 'display)
  0
  (none)
  )

;; failed to figure out what this is:
(when (zero? (-> *level* level0 art-group))
  (kmemopen global "level-struct")
  (let ((gp-0 *level*))
    (set! (-> gp-0 loading-level) (-> gp-0 level-default))
    (dotimes (s5-0 10)
      (let ((s4-0 (-> gp-0 level s5-0)))
        (set! (-> s4-0 art-group) (new 'global 'load-dir-art-group 100 s4-0))
        (set! (-> s4-0 vis-bits) (malloc 'global 2048))
        (vis-clear s4-0)
        (set! (-> s4-0 tfrag-masks) (new 'global 'texture-masks-array 1))
        (set! (-> s4-0 tfrag-dists) (malloc 'global 4))
        (set! (-> s4-0 shrub-masks) (new 'global 'texture-masks-array 1))
        (set! (-> s4-0 shrub-dists) (malloc 'global 4))
        (set! (-> s4-0 alpha-masks) (new 'global 'texture-masks-array 1))
        (set! (-> s4-0 alpha-dists) (malloc 'global 4))
        (set! (-> s4-0 water-masks) (new 'global 'texture-masks-array 1))
        (set! (-> s4-0 water-dists) (malloc 'global 4))
        (clear-mood-context (-> s4-0 mood-context))
        )
      )
    (set! (-> (&-> gp-0 level-default art-group) 0) (new 'global 'load-dir-art-group 512 (-> gp-0 level-default)))
    (dotimes (v1-38 11)
      (let ((a0-55 (-> gp-0 level v1-38)))
        (dotimes (a1-50 11)
          (set! (-> a0-55 texture-anim-array a1-50) #f)
          (set! (-> a0-55 eye-slot-lowres a1-50) (the-as uint 0))
          (set! (-> a0-55 eye-slot-highres a1-50) (the-as uint 0))
          )
        (set! (-> a0-55 borrow-from-level) #f)
        (dotimes (a1-53 5)
          (set! (-> a0-55 borrow-level a1-53) #f)
          )
        )
      )
    (set! (-> (&-> gp-0 level-default texture-anim-array 9) 0) *sky-texture-anim-array*)
    (set! (-> (&-> gp-0 level-default texture-anim-array 1) 0) *darkjak-texture-anim-array*)
    (set! (-> (&-> gp-0 level-default texture-anim-array 4) 0) *default-water-texture-anim-array*)
    (set! (-> (&-> gp-0 level-default texture-anim-array 5) 0) *default-warp-texture-anim-array*)
    (set! (-> (&-> gp-0 level-default draw-priority) 0) 20.0)
    (set! (-> (&-> gp-0 level-default info) 0) default-level)
    (set! (-> *kernel-context* login-level-index) (-> (&-> gp-0 level-default index) 0))
    (set! *default-level* (-> gp-0 level-default))
    )
  (kmemclose)
  )
