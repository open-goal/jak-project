;;-*-Lisp-*-
(in-package goal)

;; definition of type nav-mesh-work-debug
(deftype nav-mesh-work-debug (structure)
  "Debug outputs for the nav-mesh assembly functions"
  ((debug-vec1    vector  :inline)
   (debug-vec2    vector  :inline)
   (debug-vec3    vector  :inline)
   (debug-vec4    vector  :inline)
   (debug-vec5    vector  :inline)
   (debug-vec6    vector  :inline)
   (debug-vec7    vector  :inline)
   (debug-vec8    vector  :inline)
   (debug-vec9    vector  :inline)
   (debug-vec10   vector  :inline)
   (debug-vec11   vector  :inline)
   (debug-vec12   vector  :inline)
   (sphere-array  sphere  16 :inline)
   )
  )

;; definition for method 3 of type nav-mesh-work-debug
(defmethod inspect ((this nav-mesh-work-debug))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'nav-mesh-work-debug)
  (format #t "~1Tdebug-vec1: ~`vector`P~%" (-> this debug-vec1))
  (format #t "~1Tdebug-vec2: ~`vector`P~%" (-> this debug-vec2))
  (format #t "~1Tdebug-vec3: ~`vector`P~%" (-> this debug-vec3))
  (format #t "~1Tdebug-vec4: ~`vector`P~%" (-> this debug-vec4))
  (format #t "~1Tdebug-vec5: ~`vector`P~%" (-> this debug-vec5))
  (format #t "~1Tdebug-vec6: ~`vector`P~%" (-> this debug-vec6))
  (format #t "~1Tdebug-vec7: ~`vector`P~%" (-> this debug-vec7))
  (format #t "~1Tdebug-vec8: ~`vector`P~%" (-> this debug-vec8))
  (format #t "~1Tdebug-vec9: ~`vector`P~%" (-> this debug-vec9))
  (format #t "~1Tdebug-vec10: ~`vector`P~%" (-> this debug-vec10))
  (format #t "~1Tdebug-vec11: ~`vector`P~%" (-> this debug-vec11))
  (format #t "~1Tdebug-vec12: ~`vector`P~%" (-> this debug-vec12))
  (format #t "~1Tsphere-array[16] @ #x~X~%" (-> this sphere-array))
  (label cfg-4)
  this
  )

;; definition of type nav-mesh-work
(deftype nav-mesh-work (structure)
  "Workspace for nav-mesh processing functions."
  ((vert0-table             int8    4)
   (vert1-table             int8    4)
   (edge-mask-table         uint8   3)
   (pad0                    uint32)
   (deg-to-rad              float)
   (rad-to-deg              float)
   (nav-poly-min-dist       float)
   (nav-poly-epsilon        float)
   (sphere-array            sphere  16 :inline)
   (debug                   nav-mesh-work-debug)
   (work-struct-in-scratch  int8)
   (mesh-struct-in-scratch  int8)
   (polys-in-scratch        int8)
   (mesh                    nav-mesh)
   (nav                     basic)
   (poly0                   nav-poly)
   (poly1                   nav-poly)
   (poly-id                 int32)
   )
  )

;; definition for method 3 of type nav-mesh-work
(defmethod inspect ((this nav-mesh-work))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'nav-mesh-work)
  (format #t "~1Tvert0-table[4] @ #x~X~%" (-> this vert0-table))
  (format #t "~1Tvert1-table[4] @ #x~X~%" (-> this vert1-table))
  (format #t "~1Tedge-mask-table[3] @ #x~X~%" (-> this edge-mask-table))
  (format #t "~1Tpad0: ~D~%" (-> this pad0))
  (format #t "~1Tdeg-to-rad: ~f~%" (-> this deg-to-rad))
  (format #t "~1Trad-to-deg: ~f~%" (-> this rad-to-deg))
  (format #t "~1Tnav-poly-min-dist: ~f~%" (-> this nav-poly-min-dist))
  (format #t "~1Tnav-poly-epsilon: ~f~%" (-> this nav-poly-epsilon))
  (format #t "~1Tsphere-array[16] @ #x~X~%" (-> this sphere-array))
  (format #t "~1Tdebug: #<nav-mesh-work-debug @ #x~X>~%" (-> this debug))
  (format #t "~1Twork-struct-in-scratch: ~D~%" (-> this work-struct-in-scratch))
  (format #t "~1Tmesh-struct-in-scratch: ~D~%" (-> this mesh-struct-in-scratch))
  (format #t "~1Tpolys-in-scratch: ~D~%" (-> this polys-in-scratch))
  (format #t "~1Tmesh: ~A~%" (-> this mesh))
  (format #t "~1Tnav: ~A~%" (-> this nav))
  (format #t "~1Tpoly0: ~A~%" (-> this poly0))
  (format #t "~1Tpoly1: ~A~%" (-> this poly1))
  (format #t "~1Tpoly-id: ~D~%" (-> this poly-id))
  (label cfg-4)
  this
  )

;; definition of type nav-mesh-link
(deftype nav-mesh-link (structure)
  "Link between two different meshes"
  ((id                   uint32)
   (dest-mesh-id         uint32)
   (src-link-poly-id     uint8)
   (src-switch-poly-id   uint8)
   (dest-link-poly-id    uint8)
   (dest-switch-poly-id  uint8)
   (dest-mesh            nav-mesh)
   )
  )

;; definition for method 3 of type nav-mesh-link
(defmethod inspect ((this nav-mesh-link))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'nav-mesh-link)
  (format #t "~1Tid: ~D~%" (-> this id))
  (format #t "~1Tdest-mesh-id: ~D~%" (-> this dest-mesh-id))
  (format #t "~1Tsrc-link-poly-id: ~D~%" (-> this src-link-poly-id))
  (format #t "~1Tsrc-switch-poly-id: ~D~%" (-> this src-switch-poly-id))
  (format #t "~1Tdest-link-poly-id: ~D~%" (-> this dest-link-poly-id))
  (format #t "~1Tdest-switch-poly-id: ~D~%" (-> this dest-switch-poly-id))
  (format #t "~1Tdest-mesh: ~A~%" (-> this dest-mesh))
  (label cfg-4)
  this
  )

;; definition of type nav-poly
(deftype nav-poly (structure)
  "Polygon within a nav-mesh. Can be a tri or quad.
Based on the implementation of point-poly-intersection?, these should likely be convex."
  ((data          uint8   64        :offset   0)
   (vertex        vector  4 :inline :overlay-at (-> data 0))
   (vertex0       vector  :inline   :overlay-at (-> vertex 0))
   (vertex1       vector  :inline   :overlay-at (-> vertex 1))
   (vertex2       vector  :inline   :overlay-at (-> vertex 2))
   (vertex3       vector  :inline   :overlay-at (-> vertex 3))
   (id            uint8             :overlay-at (-> data 12))
   (pat           uint8             :overlay-at (-> data 13))
   (vertex-count  uint8             :overlay-at (-> data 14))
   (link          uint8             :overlay-at (-> data 15))
   (adj-poly      uint8   4         :overlay-at (-> data 28))
   (adj-poly0     uint8             :overlay-at (-> adj-poly 0))
   (adj-poly1     uint8             :overlay-at (-> adj-poly 1))
   (adj-poly2     uint8             :overlay-at (-> adj-poly 2))
   (adj-poly3     uint8             :overlay-at (-> adj-poly 3))
   (min-y         float             :overlay-at (-> data 44))
   (max-y         float             :overlay-at (-> data 60))
   )
  )

;; definition for method 3 of type nav-poly
(defmethod inspect ((this nav-poly))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'nav-poly)
  (format #t "~1Tdata[64] @ #x~X~%" (-> this vertex))
  (format #t "~1Tvertex[4] @ #x~X~%" (-> this vertex))
  (format #t "~1Tvertex0: ~`vector`P~%" (-> this vertex))
  (format #t "~1Tvertex1: ~`vector`P~%" (-> this vertex1))
  (format #t "~1Tvertex2: ~`vector`P~%" (-> this vertex2))
  (format #t "~1Tvertex3: ~`vector`P~%" (-> this vertex3))
  (format #t "~1Tid: ~D~%" (-> this id))
  (format #t "~1Tpat: ~D~%" (-> this pat))
  (format #t "~1Tvertex-count: ~D~%" (-> this vertex-count))
  (format #t "~1Tlink: ~D~%" (-> this link))
  (format #t "~1Tadj-poly[4] @ #x~X~%" (&-> this vertex1 w))
  (format #t "~1Tadj-poly0: ~D~%" (-> this adj-poly0))
  (format #t "~1Tadj-poly1: ~D~%" (-> this adj-poly1))
  (format #t "~1Tadj-poly2: ~D~%" (-> this adj-poly2))
  (format #t "~1Tadj-poly3: ~D~%" (-> this adj-poly3))
  (format #t "~1Tmin-y: ~f~%" (-> this vertex2 w))
  (format #t "~1Tmax-y: ~f~%" (-> this vertex3 w))
  (label cfg-4)
  this
  )

;; definition of type nav-vertex
(deftype nav-vertex (vector)
  ()
  )

;; definition for method 3 of type nav-vertex
;; INFO: Used lq/sq
(defmethod inspect ((this nav-vertex))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'nav-vertex)
  (format #t "~1Tdata[4] @ #x~X~%" (&-> this x))
  (format #t "~1Tx: ~f~%" (-> this x))
  (format #t "~1Ty: ~f~%" (-> this y))
  (format #t "~1Tz: ~f~%" (-> this z))
  (format #t "~1Tw: ~f~%" (-> this w))
  (format #t "~1Tquad: ~D~%" (-> this quad))
  (label cfg-4)
  this
  )

;; definition of type nav-sphere
(deftype nav-sphere (structure)
  ((trans  sphere  :inline)
   )
  )

;; definition for method 3 of type nav-sphere
(defmethod inspect ((this nav-sphere))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'nav-sphere)
  (format #t "~1Ttrans: #<sphere @ #x~X>~%" (-> this trans))
  (label cfg-4)
  this
  )

;; definition of type nav-ray
(deftype nav-ray (structure)
  ((current-pos   vector  :inline)
   (dir           vector  :inline)
   (dest-pos      vector  :inline)
   (current-poly  nav-poly)
   (next-poly     nav-poly)
   (len           meters)
   (last-edge     int8)
   (ignore        uint8)
   (terminated    symbol)
   (reached-dest  symbol)
   (hit-boundary  symbol)
   (hit-gap       symbol)
   )
  )

;; definition for method 3 of type nav-ray
(defmethod inspect ((this nav-ray))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'nav-ray)
  (format #t "~1Tcurrent-pos: #<vector @ #x~X>~%" (-> this current-pos))
  (format #t "~1Tdir: #<vector @ #x~X>~%" (-> this dir))
  (format #t "~1Tdest-pos: #<vector @ #x~X>~%" (-> this dest-pos))
  (format #t "~1Tcurrent-poly: #<nav-poly @ #x~X>~%" (-> this current-poly))
  (format #t "~1Tnext-poly: #<nav-poly @ #x~X>~%" (-> this next-poly))
  (format #t "~1Tlen: (meters ~m)~%" (-> this len))
  (format #t "~1Tlast-edge: ~D~%" (-> this last-edge))
  (format #t "~1Tignore: ~D~%" (-> this ignore))
  (format #t "~1Tterminated: ~A~%" (-> this terminated))
  (format #t "~1Treached-dest: ~A~%" (-> this reached-dest))
  (format #t "~1Thit-boundary: ~A~%" (-> this hit-boundary))
  (format #t "~1Thit-gap: ~A~%" (-> this hit-gap))
  (label cfg-4)
  this
  )

;; definition of type nav-route-portal
(deftype nav-route-portal (structure)
  ((vertex      nav-vertex  2 :inline)
   (next-poly   nav-poly)
   (edge-index  int8)
   )
  )

;; definition for method 3 of type nav-route-portal
(defmethod inspect ((this nav-route-portal))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'nav-route-portal)
  (format #t "~1Tvertex[2] @ #x~X~%" (-> this vertex))
  (format #t "~1Tnext-poly: #<nav-poly @ #x~X>~%" (-> this next-poly))
  (format #t "~1Tedge-index: ~D~%" (-> this edge-index))
  (label cfg-4)
  this
  )

;; definition of type nav-find-poly-parms
(deftype nav-find-poly-parms (structure)
  ((point          vector  :inline)
   (y-threshold    float)
   (ignore         uint8)
   (poly           nav-poly)
   (dist           float)
   (point-inside?  symbol)
   )
  )

;; definition for method 3 of type nav-find-poly-parms
(defmethod inspect ((this nav-find-poly-parms))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'nav-find-poly-parms)
  (format #t "~1Tpoint: #<vector @ #x~X>~%" (-> this point))
  (format #t "~1Ty-threshold: ~f~%" (-> this y-threshold))
  (format #t "~1Tignore: ~D~%" (-> this ignore))
  (format #t "~1Tpoly: #<nav-poly @ #x~X>~%" (-> this poly))
  (format #t "~1Tdist: ~f~%" (-> this dist))
  (format #t "~1Tpoint-inside?: ~A~%" (-> this point-inside?))
  (label cfg-4)
  this
  )

;; definition of type clamp-travel-vector-to-mesh-return-info
(deftype clamp-travel-vector-to-mesh-return-info (structure)
  ((found-boundary   symbol)
   (intersection     vector  :inline)
   (boundary-normal  vector  :inline)
   (prev-normal      vector  :inline)
   (next-normal      vector  :inline)
   (poly             nav-poly)
   (gap-poly         nav-poly)
   (edge             int8)
   (ignore           uint8)
   (vert-prev        vector  :inline)
   (vert-0           vector  :inline)
   (vert-1           vector  :inline)
   (vert-next        vector  :inline)
   )
  )

;; definition for method 3 of type clamp-travel-vector-to-mesh-return-info
(defmethod inspect ((this clamp-travel-vector-to-mesh-return-info))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'clamp-travel-vector-to-mesh-return-info)
  (format #t "~1Tfound-boundary: ~A~%" (-> this found-boundary))
  (format #t "~1Tintersection: #<vector @ #x~X>~%" (-> this intersection))
  (format #t "~1Tboundary-normal: #<vector @ #x~X>~%" (-> this boundary-normal))
  (format #t "~1Tprev-normal: #<vector @ #x~X>~%" (-> this prev-normal))
  (format #t "~1Tnext-normal: #<vector @ #x~X>~%" (-> this next-normal))
  (format #t "~1Tpoly: #<nav-poly @ #x~X>~%" (-> this poly))
  (format #t "~1Tgap-poly: #<nav-poly @ #x~X>~%" (-> this gap-poly))
  (format #t "~1Tedge: ~D~%" (-> this edge))
  (format #t "~1Tignore: ~D~%" (-> this ignore))
  (format #t "~1Tvert-prev: #<vector @ #x~X>~%" (-> this vert-prev))
  (format #t "~1Tvert-0: #<vector @ #x~X>~%" (-> this vert-0))
  (format #t "~1Tvert-1: #<vector @ #x~X>~%" (-> this vert-1))
  (format #t "~1Tvert-next: #<vector @ #x~X>~%" (-> this vert-next))
  (label cfg-4)
  this
  )

;; definition of type nav-mesh
(deftype nav-mesh (basic)
  "Mesh used for creature/enemy navigation."
  ((work                   nav-mesh-work)
   (poly-array             (inline-array nav-poly))
   (static-sphere-count    uint8)
   (poly-count             uint8)
   (nav-control-count      uint8)
   (max-nav-control-count  uint8)
   (route                  (pointer uint8))
   (poly-hash              grid-hash)
   (nav-control-array      (inline-array nav-control))
   (sphere-hash            sphere-hash)
   (static-sphere          (inline-array sphere))
   (user-list              engine)
   (next-nav-mesh          surface)
   (prev-nav-mesh          surface)
   (bounds                 sphere  :inline)
   (origin                 vector  :inline :overlay-at (-> bounds data 0))
   (entity                 entity)
   (link-array             (inline-array nav-mesh-link))
   (link-count             uint8)
   (flags                  nav-mesh-flag)
   (pad1                   uint8   2)
   (nearest-y-threshold    meters)
   (water-max-height       meters)
   (pad2                   uint32  7)
   )
  (:methods
    (debug-draw (_type_) none)
    (nav-mesh-method-10 (_type_ vector vector nav-poly) nav-poly)
    (nav-mesh-method-11 (_type_ vector) nav-poly)
    (nav-mesh-method-12 (_type_ vector float nav-poly) symbol)
    (poly-centroid (_type_ nav-poly vector) vector)
    (poly-centroid-local (_type_ nav-poly vector) vector)
    (lookup-poly-on-route-to-target (_type_ nav-poly nav-poly) nav-poly)
    (get-route-portal (_type_ nav-poly nav-poly nav-route-portal) (inline-array nav-vertex))
    (initialize-mesh! (_type_) none)
    (advance-ray-to-nearest-poly-edge-or-dest! (_type_ nav-ray) none)
    (try-move-along-ray (_type_ nav-poly vector vector float) meters)
    (clamp-vector-to-mesh-cross-gaps (_type_ vector nav-poly vector float symbol clamp-travel-vector-to-mesh-return-info) none)
    (clamp-vector-to-mesh-no-gaps (_type_ vector nav-poly vector clamp-travel-vector-to-mesh-return-info) none)
    (set-normals-from-adjacent-bounds (_type_ clamp-travel-vector-to-mesh-return-info) none)
    (find-adjacent-bounds-one (_type_ vector nav-poly int int) none)
    (compute-bounding-box-from-vertices (_type_ vector vector) none)
    (init-from-entity (_type_ entity-nav-mesh) none)
    (handle-birth (_type_) none)
    (handle-kill (_type_) none)
    (update-navigation (_type_) none)
    (new-nav-control (_type_) nav-control)
    (remove-nav-control (_type_ nav-control) none)
    (add-process-drawable-to-nav-mesh (_type_ process-drawable symbol) none)
    (remove-process-drawable (_type_ process-drawable) none)
    (change-to (_type_ process-drawable) none)
    (link-by-id (_type_ uint) symbol)
    (unlink-by-id (_type_ uint) symbol)
    (nav-mesh-method-36 (_type_ vector vector float) float)
    (nav-mesh-method-37 (_type_ vector vector float) float)
    (nav-mesh-method-38 (_type_ nav-poly) none)
    (debug-draw-poly (_type_ nav-poly rgba) none)
    (point-in-poly? (_type_ nav-poly vector) symbol)
    (nav-mesh-method-41 (_type_ nav-poly vector vector vector (pointer nav-poly)) vector)
    (closest-point-on-boundary (_type_ nav-poly vector vector) vector)
    (project-point-onto-plane-of-poly-local (_type_ nav-poly vector vector vector) none)
    (project-point-into-poly-2d (_type_ nav-poly vector vector) vector)
    (nav-mesh-method-45 (_type_ nav-poly) nav-poly)
    (nav-mesh-method-46 (_type_ nav-poly) nav-poly)
    (is-in-mesh-local? (_type_ vector float float) symbol)
    (link-to-other-mesh (_type_ nav-mesh-link) symbol)
    (unlink-mesh (_type_ nav-mesh-link) none)
    )
  )

;; definition for method 3 of type nav-mesh
(defmethod inspect ((this nav-mesh))
  (when (not this)
    (set! this this)
    (goto cfg-8)
    )
  (format #t "[~8x] ~A~%" this (-> this type))
  (format #t "~1Twork: #<nav-mesh-work @ #x~X>~%" (-> this work))
  (format #t "~1Tpoly-array: #x~X~%" (-> this poly-array))
  (format #t "~1Tstatic-sphere-count: ~D~%" (-> this static-sphere-count))
  (format #t "~1Tpoly-count: ~D~%" (-> this poly-count))
  (format #t "~1Tnav-control-count: ~D~%" (-> this nav-control-count))
  (format #t "~1Tmax-nav-control-count: ~D~%" (-> this max-nav-control-count))
  (format #t "~1Troute: #x~X~%" (-> this route))
  (format #t "~1Tpoly-hash: ~A~%" (-> this poly-hash))
  (format #t "~1Tnav-control-array: #x~X~%" (-> this nav-control-array))
  (format #t "~1Tsphere-hash: ~A~%" (-> this sphere-hash))
  (format #t "~1Tstatic-sphere: #x~X~%" (-> this static-sphere))
  (format #t "~1Tuser-list: ~A~%" (-> this user-list))
  (format #t "~1Tnext-nav-mesh: ~A~%" (-> this next-nav-mesh))
  (format #t "~1Tprev-nav-mesh: ~A~%" (-> this prev-nav-mesh))
  (format #t "~1Tbounds: ~`sphere`P~%" (-> this bounds))
  (format #t "~1Torigin: #<vector @ #x~X>~%" (-> this bounds))
  (format #t "~1Tentity: ~A~%" (-> this entity))
  (format #t "~1Tlink-array: #x~X~%" (-> this link-array))
  (format #t "~1Tlink-count: ~D~%" (-> this link-count))
  (format #t "~1Tflags: #x~X : (nav-mesh-flag " (-> this flags))
  (let ((s5-0 (-> this flags)))
    (if (= (logand s5-0 (nav-mesh-flag dummy)) (nav-mesh-flag dummy))
        (format #t "dummy ")
        )
    (if (= (logand s5-0 (nav-mesh-flag water)) (nav-mesh-flag water))
        (format #t "water ")
        )
    )
  (format #t ")~%")
  (format #t "~1Tpad1[2] @ #x~X~%" (-> this pad1))
  (format #t "~1Tnearest-y-threshold: (meters ~m)~%" (-> this nearest-y-threshold))
  (format #t "~1Twater-max-height: (meters ~m)~%" (-> this water-max-height))
  (format #t "~1Tpad2[7] @ #x~X~%" (-> this pad2))
  (label cfg-8)
  this
  )

;; definition for function vector-normalize-unity!
(defun vector-normalize-unity! ((arg0 vector))
  "Normalize a vector (xyz only) in place."
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (init-vf0-vector)
    (let ((v0-0 arg0))
      (let ((f0-0 1.0))
        (.lvf vf1 (&-> v0-0 quad))
        (.mul.vf vf2 vf1 vf1 :mask #b111)
        (let ((v1-1 f0-0))
          (.mov vf3 v1-1)
          )
        )
      (.mul.x.vf acc vf0 vf2 :mask #b1000)
      (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
      (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
      (.isqrt.vf Q vf3 vf2 :fsf #b0 :ftf #b11)
      (.wait.vf)
      (.mul.vf vf1 vf1 Q :mask #b111)
      (.nop.vf)
      (.nop.vf)
      (.nop.vf)
      (.svf (&-> v0-0 quad) vf1)
      v0-0
      )
    )
  )

;; definition for function vector-normalize-unity-copy!
;; INFO: Used lq/sq
(defun vector-normalize-unity-copy! ((arg0 vector) (arg1 vector))
  "Normalize a vector (xyz only)"
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (init-vf0-vector)
    (set! (-> arg0 quad) (-> arg1 quad))
    (let ((v0-0 arg0))
      (let ((f0-0 1.0))
        (.lvf vf1 (&-> v0-0 quad))
        (.mul.vf vf2 vf1 vf1 :mask #b111)
        (let ((v1-2 f0-0))
          (.mov vf3 v1-2)
          )
        )
      (.mul.x.vf acc vf0 vf2 :mask #b1000)
      (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
      (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
      (.isqrt.vf Q vf3 vf2 :fsf #b0 :ftf #b11)
      (.wait.vf)
      (.mul.vf vf1 vf1 Q :mask #b111)
      (.nop.vf)
      (.nop.vf)
      (.nop.vf)
      (.svf (&-> v0-0 quad) vf1)
      v0-0
      )
    )
  )

;; definition (debug) for function debug-validate-current-poly
(defun-debug debug-validate-current-poly ()
  "Not implemented."
  #f
  )

;; definition for function init-ray
;; WARN: Return type mismatch int vs none.
(defun init-ray ((arg0 nav-ray))
  "Set up a nav-ray. Assumes that dest-pos and current-pos are set."
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (init-vf0-vector)
    (vector-! (-> arg0 dir) (-> arg0 dest-pos) (-> arg0 current-pos))
    (set! (-> arg0 dir y) 0.0)
    (let ((v1-1 (-> arg0 dir)))
      (let ((f0-1 1.0))
        (.lvf vf1 (&-> v1-1 quad))
        (.mul.vf vf2 vf1 vf1 :mask #b111)
        (let ((a1-2 f0-1))
          (.mov vf3 a1-2)
          )
        )
      (.mul.x.vf acc vf0 vf2 :mask #b1000)
      (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
      (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
      (.isqrt.vf Q vf3 vf2 :fsf #b0 :ftf #b11)
      (.wait.vf)
      (.mul.vf vf1 vf1 Q :mask #b111)
      (.nop.vf)
      (.nop.vf)
      (.nop.vf)
      (.svf (&-> v1-1 quad) vf1)
      )
    (set! (-> arg0 next-poly) #f)
    (set! (-> arg0 len) 0.0)
    (set! (-> arg0 last-edge) -1)
    (set! (-> arg0 terminated) #f)
    (set! (-> arg0 reached-dest) #f)
    (set! (-> arg0 hit-boundary) #f)
    (set! (-> arg0 hit-gap) #f)
    (set! (-> arg0 ignore) (the-as uint 3))
    0
    (none)
    )
  )

;; definition for function point-poly-intersection?
(defun point-poly-intersection? ((mesh nav-mesh) (pt vector) (num-verts int) (verts (inline-array vector)))
  "Check if a point is inside a poly."
  (let ((v1-1 (-> mesh work vert0-table))
        (a0-2 (-> mesh work vert1-table))
        )
    (dotimes (t0-0 num-verts)
      (let* ((t1-3 (-> verts (-> v1-1 t0-0)))
             (t2-3 (-> verts (-> a0-2 t0-0)))
             (f0-1 (- (-> t1-3 z) (-> t2-3 z)))
             (f1-2 (- (-> t2-3 x) (-> t1-3 x)))
             (f2-2 (- (-> pt x) (-> t1-3 x)))
             (f3-2 (- (-> pt z) (-> t1-3 z)))
             (f0-3 (+ (* f2-2 f0-1) (* f3-2 f1-2)))
             )
        (if (< 0.0 f0-3)
            (return #f)
            )
        )
      )
    )
  #t
  )

;; definition for method 40 of type nav-mesh
(defmethod point-in-poly? ((this nav-mesh) (arg0 nav-poly) (arg1 vector))
  "Check if a point is inside a poly of this mesh"
  (let* ((a3-0 this)
         (v1-0 arg1)
         (a0-1 (-> arg0 vertex-count))
         (a1-1 (-> arg0 vertex))
         (a2-2 (-> a3-0 work vert0-table))
         (a3-2 (-> a3-0 work vert1-table))
         )
    (dotimes (t0-0 (the-as int a0-1))
      (let* ((t1-3 (-> a1-1 (-> a2-2 t0-0)))
             (t2-3 (-> a1-1 (-> a3-2 t0-0)))
             (f0-1 (- (-> t1-3 z) (-> t2-3 z)))
             (f1-2 (- (-> t2-3 x) (-> t1-3 x)))
             (f2-2 (- (-> v1-0 x) (-> t1-3 x)))
             (f3-2 (- (-> v1-0 z) (-> t1-3 z)))
             (f0-3 (+ (* f2-2 f0-1) (* f3-2 f1-2)))
             )
        (if (< 0.0 f0-3)
            (return #f)
            )
        )
      )
    )
  #t
  )

;; definition for method 42 of type nav-mesh
;; INFO: Used lq/sq
(defmethod closest-point-on-boundary ((this nav-mesh) (arg0 nav-poly) (arg1 vector) (arg2 vector))
  "Find the point on the polygon edge that is closest to the query point."
  (local-vars (sv-48 vector) (sv-52 vector) (sv-56 number))
  (set! sv-48 (new 'stack-no-clear 'vector))
  (set! sv-52 (new 'stack-no-clear 'vector))
  (set! sv-56 10000000000000000000000000000000000000.0)
  (let* ((s3-0 (-> arg0 vertex-count))
         (v1-3 (the-as int (+ s3-0 -1)))
         )
    (dotimes (s2-0 (the-as int s3-0))
      (let ((f0-1 (vector-segment-distance-point! arg2 (-> arg0 vertex v1-3) (-> arg0 vertex s2-0) sv-48)))
        (when (< f0-1 (the-as float sv-56))
          (set! sv-56 f0-1)
          (set! (-> sv-52 quad) (-> sv-48 quad))
          )
        )
      (set! v1-3 s2-0)
      )
    )
  (set! (-> arg1 quad) (-> sv-52 quad))
  arg1
  )

;; definition for method 44 of type nav-mesh
;; INFO: Used lq/sq
(defmethod project-point-into-poly-2d ((this nav-mesh) (arg0 nav-poly) (arg1 vector) (arg2 vector))
  "Find the point in the polygon closest to the query point."
  (local-vars (sv-48 vector) (sv-52 vector) (sv-56 number))
  (cond
    ((point-in-poly? this arg0 arg2)
     (set! (-> arg1 quad) (-> arg2 quad))
     )
    (else
      (let ((s5-1 arg1))
        (set! sv-48 (new 'stack-no-clear 'vector))
        (set! sv-52 (new 'stack-no-clear 'vector))
        (set! sv-56 10000000000000000000000000000000000000.0)
        (let* ((s2-0 (-> arg0 vertex-count))
               (v1-6 (the-as int (+ s2-0 -1)))
               )
          (dotimes (s1-0 (the-as int s2-0))
            (let ((f0-1 (vector-segment-distance-point! arg2 (-> arg0 vertex v1-6) (-> arg0 vertex s1-0) sv-48)))
              (when (< f0-1 (the-as float sv-56))
                (set! sv-56 f0-1)
                (set! (-> sv-52 quad) (-> sv-48 quad))
                )
              )
            (set! v1-6 s1-0)
            )
          )
        (set! (-> s5-1 quad) (-> sv-52 quad))
        )
      )
    )
  arg1
  )

;; definition for method 18 of type nav-mesh
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod advance-ray-to-nearest-poly-edge-or-dest! ((this nav-mesh) (arg0 nav-ray))
  (local-vars
    (sv-16 int)
    (sv-24 nav-mesh-work)
    (sv-28 nav-poly)
    (sv-32 uint)
    (sv-36 (pointer int8))
    (sv-40 (pointer int8))
    (sv-44 float)
    (sv-48 float)
    (sv-52 vector)
    (sv-56 vector)
    (sv-60 float)
    (sv-64 float)
    (sv-68 uint)
    )
  (set! sv-16 -1)
  (set! sv-24 (-> this work))
  (set! sv-28 (-> arg0 current-poly))
  (set! sv-32 (-> arg0 current-poly vertex-count))
  (set! sv-36 (-> this work vert0-table))
  (set! sv-40 (-> this work vert1-table))
  (set! sv-44 (- (-> arg0 dest-pos x) (-> arg0 current-pos x)))
  (set! sv-48 (- (-> arg0 dest-pos z) (-> arg0 current-pos z)))
  (dotimes (v1-9 (the-as int sv-32))
    (set! sv-52 (-> sv-28 vertex (-> sv-36 v1-9)))
    (set! sv-56 (-> sv-28 vertex (-> sv-40 v1-9)))
    (set! sv-60 (- (-> sv-52 z) (-> sv-56 z)))
    (set! sv-64 (- (-> sv-56 x) (-> sv-52 x)))
    (let ((f0-10 (+ (* sv-44 sv-60) (* sv-48 sv-64))))
      (when (< 0.0 f0-10)
        (let ((f1-10
                (+ (* sv-60 (- (-> sv-52 x) (-> arg0 current-pos x))) (* sv-64 (- (-> sv-52 z) (-> arg0 current-pos z))))
                )
              )
          (when (< f1-10 f0-10)
            (set! sv-16 v1-9)
            (let ((f0-12 (fmax 0.0 (/ f1-10 f0-10))))
              (set! sv-44 (* sv-44 f0-12))
              (set! sv-48 (* sv-48 f0-12))
              )
            )
          )
        )
      )
    )
  (let ((f0-16 (+ (* sv-44 (-> arg0 dir x)) (* sv-48 (-> arg0 dir z)))))
    (+! (-> arg0 len) f0-16)
    )
  0
  (set! (-> arg0 next-poly) #f)
  (cond
    ((= sv-16 -1)
     (set! (-> arg0 current-pos quad) (-> arg0 dest-pos quad))
     (set! (-> arg0 reached-dest) #t)
     (set! (-> arg0 terminated) #t)
     )
    (else
      (+! (-> arg0 current-pos x) sv-44)
      (+! (-> arg0 current-pos z) sv-48)
      (set! sv-68 (-> sv-28 adj-poly sv-16))
      (if (!= sv-68 255)
          (set! (-> arg0 next-poly) (-> this poly-array sv-68))
          )
      (cond
        ((and (-> arg0 next-poly) (not (logtest? (-> arg0 next-poly pat) (-> arg0 ignore))))
         (set! (-> arg0 current-poly) (-> arg0 next-poly))
         )
        (else
          (set! (-> arg0 last-edge) sv-16)
          (if (-> arg0 next-poly)
              (set! (-> arg0 hit-gap) #t)
              (set! (-> arg0 hit-boundary) #t)
              )
          (set! (-> arg0 terminated) #t)
          )
        )
      )
    )
  0
  (none)
  )

;; definition (debug) for function nav-sphere-from-cam
;; WARN: Return type mismatch int vs none.
(defun-debug nav-sphere-from-cam ()
  "Print out a SPHEREM from the current camera position, possibly used by their level-building tool."
  (let ((v1-0 (camera-pos)))
    (format #t "SPHEREM(~4,,1M, ~4,,1M, ~4,,1M, 1.0)~%" (-> v1-0 x) (-> v1-0 y) (-> v1-0 z))
    )
  0
  (none)
  )
