;;-*-Lisp-*-
(in-package goal)

;; definition for function sphere-cull
;; ERROR: Bad vector register dependency: vf16
;; ERROR: Bad vector register dependency: vf17
;; ERROR: Bad vector register dependency: vf18
;; ERROR: Bad vector register dependency: vf19
(defun sphere-cull ((arg0 vector))
  "Is this sphere visible? Uses cached camera matrix registers, so use with care."
  (local-vars (v1-0 uint128) (v1-1 uint128) (v1-2 uint128))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf10 :class vf)
         (vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf10 (&-> arg0 quad))
    (.mul.x.vf acc vf16 vf10)
    (.add.mul.y.vf acc vf17 vf10 acc)
    (.add.mul.z.vf acc vf18 vf10 acc)
    (.sub.mul.w.vf vf9 vf19 vf0 acc)
    (.add.w.vf vf9 vf9 vf10)
    (.mov v1-0 vf9)
    (.pcgtw v1-1 0 v1-0)
    (.ppach v1-2 (the-as uint128 0) v1-1)
    (zero? (the-as int v1-2))
    )
  )

;; definition for function guard-band-cull
;; ERROR: Bad vector register dependency: vf20
;; ERROR: Bad vector register dependency: vf21
;; ERROR: Bad vector register dependency: vf22
;; ERROR: Bad vector register dependency: vf23
(defun guard-band-cull ((arg0 vector))
  "Is this sphere within the guard band, and maybe needs clipping?  Uses cached camera matrix registers, so use with care."
  (local-vars (v1-0 uint128) (v1-1 uint128) (v1-2 uint128))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf10 :class vf)
         (vf20 :class vf)
         (vf21 :class vf)
         (vf22 :class vf)
         (vf23 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf10 (&-> arg0 quad))
    (.mul.x.vf acc vf20 vf10)
    (.add.mul.y.vf acc vf21 vf10 acc)
    (.add.mul.z.vf acc vf22 vf10 acc)
    (.sub.mul.w.vf vf9 vf23 vf0 acc)
    (.sub.w.vf vf9 vf9 vf10)
    (.mov v1-0 vf9)
    (.pcgtw v1-1 0 v1-0)
    (.ppach v1-2 (the-as uint128 0) v1-1)
    (nonzero? (the-as int v1-2))
    )
  )

;; definition for function sphere-in-view-frustum?
(defun sphere-in-view-frustum? ((arg0 sphere))
  "Check if sphere is in view frustum. Uses math-camera, so doesn't need register setup."
  (local-vars (v1-1 uint128) (v1-2 uint128) (v1-3 uint128))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (let ((v1-0 *math-camera*))
      (.lvf vf6 (&-> arg0 quad))
      (.lvf vf1 (&-> v1-0 plane 0 quad))
      (.lvf vf2 (&-> v1-0 plane 1 quad))
      (.lvf vf3 (&-> v1-0 plane 2 quad))
      (.lvf vf4 (&-> v1-0 plane 3 quad))
      )
    (.mul.x.vf acc vf1 vf6)
    (.add.mul.y.vf acc vf2 vf6 acc)
    (.add.mul.z.vf acc vf3 vf6 acc)
    (.sub.mul.w.vf vf5 vf4 vf0 acc)
    (.add.w.vf vf5 vf5 vf6)
    (.mov v1-1 vf5)
    (.pcgtw v1-2 0 v1-1)
    (.ppach v1-3 (the-as uint128 0) v1-2)
    (zero? (the-as int v1-3))
    )
  )

;; definition for function line-in-view-frustum?
(defun line-in-view-frustum? ((arg0 vector) (arg1 vector))
  "Check if line is in view frustum. Uses math-camera, so doesn't need register setup."
  (local-vars (v1-1 uint128) (v1-2 uint128) (v1-3 uint128) (a0-1 uint128) (a0-2 uint128) (a0-3 uint128))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf10 :class vf)
         (vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (let ((v1-0 *math-camera*))
      (.lvf vf9 (&-> arg0 quad))
      (.lvf vf10 (&-> arg1 quad))
      (.lvf vf16 (&-> v1-0 plane 0 quad))
      (.lvf vf17 (&-> v1-0 plane 1 quad))
      (.lvf vf18 (&-> v1-0 plane 2 quad))
      (.lvf vf19 (&-> v1-0 plane 3 quad))
      )
    (.mul.x.vf acc vf16 vf9)
    (.add.mul.y.vf acc vf17 vf9 acc)
    (.add.mul.z.vf acc vf18 vf9 acc)
    (.sub.mul.w.vf vf9 vf19 vf0 acc)
    (.mul.x.vf acc vf16 vf10)
    (.add.mul.y.vf acc vf17 vf10 acc)
    (.add.mul.z.vf acc vf18 vf10 acc)
    (.sub.mul.w.vf vf10 vf19 vf0 acc)
    (.mov v1-1 vf9)
    (.pcgtw v1-2 0 v1-1)
    (.ppach v1-3 (the-as uint128 0) v1-2)
    (.mov a0-1 vf10)
    (.pcgtw a0-2 0 a0-1)
    (.ppach a0-3 (the-as uint128 0) a0-2)
    (not (logtest? (the-as int v1-3) (the-as int a0-3)))
    )
  )

;; definition for function vis-cull
;; ERROR: failed type prop at 3: Could not figure out load: (set! v1 (l.b (+ v1 #x3800)))
;; WARN: Return type mismatch none vs symbol.
;; ERROR: Unsupported inline assembly instruction kind - [addiu a0, a0, 56]
(defun vis-cull ((a0-0 int))
  "Check if object is visible by ID with precomputed visibility. Requres scratchpad to have vis-bits loaded."
  (local-vars (v0-0 none) (v1-0 int) (v1-1 int) (v1-2 none) (v1-3 none) (a0-1 none) (a0-2 none) (a1-0 int))
  (set! v1-0 #x70000000)
  (shift-arith-right-32 a1-0 a0-0 3)
  (set! v1-1 (+ a1-0 v1-0))
  (set! v1-2 (the-as none (l.b (+ v1-1 #x3800))))
  (set! a0-1 (the-as none (logand a0-0 7)))
  (.addiu a0-2 a0-1 56)
  (set! v1-3 (the-as none (sll v1-2 a0-2)))
  (set! v0-0 (the-as none (<0.si v1-3)))
  (ret-value v0-0)
  )

;; definition (debug) for function vis-cull-debug
;; ERROR: Failed load: (set! v1-2 (l.b (+ v1-1 #x3800))) at op 2
;; ERROR: Unsupported inline assembly instruction kind - [addiu a0, a0, 56]
(defun-debug vis-cull-debug ((arg0 work-area) (arg1 int))
  (local-vars (v1-0 int) (a0-2 int))
  (shift-arith-right-32 v1-0 arg1 3)
  (let ((v1-2 (l.b (+ v1-0 (the-as int arg0) #x3800))))
    (let ((a0-1 (logand arg1 7)))
      (.addiu a0-2 a0-1 56)
      )
    (< (shl v1-2 a0-2) 0)
    )
  )

;; definition for function error-sphere
;; WARN: Return type mismatch int vs none.
(defun error-sphere ((arg0 drawable-error) (arg1 string))
  "Draw an error sphere and text for a drawable-error."
  (when *artist-error-spheres*
    (when (vis-cull (-> arg0 id))
      (when (sphere-cull (-> arg0 bsphere))
        (add-debug-sphere
          #t
          (bucket-id debug)
          (-> arg0 bsphere)
          (-> arg0 bsphere w)
          (new 'static 'rgba :r #x80 :a #x80)
          )
        (add-debug-text-3d
          #t
          (bucket-id debug-no-zbuf1)
          arg1
          (-> arg0 bsphere)
          (font-color white)
          (the-as vector2h #f)
          )
        )
      )
    )
  0
  (none)
  )

;; definition for method 9 of type drawable
(defmethod login ((this drawable))
  "Initialize the object after it is loaded."
  this
  )

;; definition for method 10 of type drawable
;; WARN: Return type mismatch int vs none.
(defmethod draw ((this drawable))
  "Draw the drawable, and typically its children.
   This usually means adding stuff to a list to be drawn later, rather than expensive drawing here."
  0
  (none)
  )

;; definition for method 11 of type drawable
;; WARN: Return type mismatch int vs none.
(defmethod drawable-method-11 ((this drawable))
  0
  (none)
  )

;; definition for method 12 of type drawable
;; WARN: Return type mismatch int vs none.
(defmethod drawable-method-12 ((this drawable))
  0
  (none)
  )

;; definition for method 16 of type drawable
;; WARN: Return type mismatch int vs none.
(defmethod collect-regions ((this drawable) (arg0 sphere) (arg1 int) (arg2 region-prim-list))
  "Fill the region-prim-list with regions that intersect the sphere."
  0
  (none)
  )

;; definition for method 13 of type drawable
;; WARN: Return type mismatch int vs none.
(defmethod collect-stats ((this drawable))
  "Collect triangle/perf statistics for rendering.
   This is only called when viewing stats.
   The vis-bits and culling registers are loaded during this time."
  0
  (none)
  )

;; definition for method 14 of type drawable
;; WARN: Return type mismatch int vs none.
(defmethod debug-draw ((this drawable))
  "Debug-draw a drawable and its children. Typically uses the debug-draw functions."
  0
  (none)
  )

;; definition for method 10 of type drawable-error
;; WARN: Return type mismatch int vs none.
(defmethod draw ((this drawable-error))
  "Draw the drawable, and typically its children.
   This usually means adding stuff to a list to be drawn later, rather than expensive drawing here."
  (error-sphere this (-> this name))
  0
  (none)
  )

;; definition for method 15 of type drawable
(defmethod unpack-vis ((this drawable) (arg0 (pointer int8)) (arg1 (pointer int8)))
  arg1
  )

;; definition for symbol *edit-instance*, type string
(define *edit-instance* (the-as string #f))

;; this part is debug only
(when *debug-segment*
;; definition for symbol *instance-mem-usage*, type memory-usage-block
(define *instance-mem-usage* (new 'debug 'memory-usage-block))

)
;; definition for function find-instance-by-name-level
(defun find-instance-by-name-level ((arg0 string) (arg1 level))
  "Find shrub or tie prototype by name in a level.
   Yes it says instance. No it does not return an instance."
  (let ((s5-0 (-> arg1 bsp drawable-trees)))
    (dotimes (s4-0 (-> s5-0 length))
      (let ((v1-3 (-> s5-0 trees s4-0)))
        (case (-> v1-3 type)
          ((drawable-tree-instance-shrub)
           (let ((s3-0 (-> (the-as drawable-tree-instance-shrub v1-3) info prototype-inline-array-shrub)))
             (dotimes (s2-0 (-> s3-0 length))
               (if (string= arg0 (-> s3-0 data s2-0 name))
                   (return (-> s3-0 data s2-0))
                   )
               )
             )
           )
          ((drawable-tree-instance-tie)
           (let ((s3-1 (-> (the-as drawable-tree-instance-tie v1-3) prototypes prototype-array-tie)))
             (dotimes (s2-1 (-> s3-1 length))
               (if (string= arg0 (-> s3-1 array-data s2-1 name))
                   (return (-> s3-1 array-data s2-1))
                   )
               )
             )
           )
          )
        )
      )
    )
  (the-as prototype-bucket #f)
  )

;; definition for function find-instance-by-name
(defun find-instance-by-name ((arg0 string))
  "Find shrub or tie prototype by name in any level.
   Yes it says instance. No it does not return an instance."
  (dotimes (s5-0 (-> *level* length))
    (let ((a1-0 (-> *level* level s5-0)))
      (when (= (-> a1-0 status) 'active)
        (let ((a0-4 (find-instance-by-name-level arg0 a1-0)))
          (if a0-4
              (return a0-4)
              )
          )
        )
      )
    )
  (the-as prototype-bucket #f)
  )

;; definition for function prototypes-game-visible-set!
(defun prototypes-game-visible-set! ((arg0 pair) (arg1 symbol) (arg2 level))
  "Disable collision/visibilty of tie/shrub based on a list of prototype names.
   Only looks in the given level."
  (let ((a0-1 (car arg0)))
    (while (not (null? arg0))
      (let ((v1-0 (find-instance-by-name-level (the-as string a0-1) arg2)))
        (when v1-0
          (if arg1
              (logclear! (-> v1-0 flags) (prototype-flags visible no-collide))
              (logior! (-> v1-0 flags) (prototype-flags visible no-collide))
              )
          )
        )
      (set! arg0 (cdr arg0))
      (set! a0-1 (car arg0))
      )
    )
  0
  )

;; definition (debug) for function find-instance-by-index
(defun-debug find-instance-by-index ((arg0 type) (arg1 int) (arg2 bsp-header))
  (dotimes (v1-0 (-> *level* length))
    (let ((a3-3 (-> *level* level v1-0)))
      (when (= (-> a3-3 status) 'active)
        (let ((a3-4 (-> a3-3 bsp)))
          (when (or (not arg2) (= a3-4 arg2))
            (let ((a3-5 (-> a3-4 drawable-trees)))
              (dotimes (t0-5 (-> a3-5 length))
                (let ((t1-3 (-> a3-5 trees t0-5)))
                  (case (-> t1-3 type)
                    ((drawable-tree-instance-shrub)
                     (when (= arg0 (-> t1-3 type))
                       (let ((v1-2 (-> (the-as drawable-tree-instance-shrub t1-3) info prototype-inline-array-shrub)))
                         (return (-> v1-2 data arg1))
                         )
                       )
                     )
                    ((drawable-tree-instance-tie)
                     (when (= arg0 (-> t1-3 type))
                       (let ((v1-5 (-> (the-as drawable-tree-instance-tie t1-3) prototypes prototype-array-tie)))
                         (return (-> v1-5 array-data arg1))
                         )
                       )
                     )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  (the-as prototype-bucket #f)
  )

;; definition (debug) for function prototype-bucket-type
(defun-debug prototype-bucket-type ((arg0 prototype-bucket))
  (case (-> arg0 geometry 1 type)
    ((prototype-shrubbery shrubbery)
     instance-shrubbery
     )
    ((prototype-tie prototype-tie tie-fragment)
     instance-tie
     )
    )
  )

;; definition (debug) for function prototype-bucket-recalc-fields
(defun-debug prototype-bucket-recalc-fields ((arg0 prototype-bucket))
  (case (prototype-bucket-type arg0)
    ((instance-shrubbery)
     (set! (-> arg0 rdists x) (/ 1.0 (- (-> arg0 dists w) (-> arg0 dists x))))
     )
    (else
      (set! (-> arg0 dists z) (+ (-> arg0 dists x) (* 0.33333334 (- (-> arg0 dists w) (-> arg0 dists x)))))
      (set! (-> arg0 rdists x) (/ 1.0 (- (-> arg0 dists z) (-> arg0 dists x))))
      )
    )
  (set! (-> arg0 rdists z) (/ 1.0 (- (-> arg0 dists w) (-> arg0 dists z))))
  (set! (-> arg0 dists y) (* 0.5 (-> arg0 dists x)))
  (set! (-> arg0 rdists y) (/ 1.0 (-> arg0 dists y)))
  arg0
  )

;; definition (debug) for function print-prototype-list
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defun-debug print-prototype-list ()
  (local-vars (sv-16 (function prototype-bucket-shrub memory-usage-block int prototype-bucket-shrub)))
  (dotimes (gp-0 (-> *level* length))
    (let ((s5-0 (-> *level* level gp-0)))
      (when (= (-> s5-0 status) 'active)
        (format #t "-------- level ~S~%" (-> s5-0 name))
        (let ((s5-1 (-> s5-0 bsp drawable-trees)))
          (dotimes (s4-0 (-> s5-1 length))
            (let ((v1-8 (-> s5-1 trees s4-0)))
              (case (-> v1-8 type)
                ((drawable-tree-instance-shrub)
                 (let ((s3-0 (-> (the-as drawable-tree-instance-shrub v1-8) info prototype-inline-array-shrub)))
                   (dotimes (s2-0 (-> s3-0 length))
                     0
                     (let ((s1-0 (-> s3-0 data s2-0)))
                       (dotimes (s0-0 4)
                         (reset! *instance-mem-usage*)
                         (if (nonzero? (-> s1-0 geometry s0-0))
                             (mem-usage (-> s1-0 geometry s0-0) *instance-mem-usage* 0)
                             )
                         )
                       (let ((s0-1 s1-0))
                         (set! sv-16 (method-of-object s0-1 mem-usage))
                         (let ((a1-4 (reset! *instance-mem-usage*))
                               (a2-2 0)
                               )
                           (sv-16 s0-1 a1-4 a2-2)
                           )
                         )
                       (let ((v1-29 (calculate-total *instance-mem-usage*)))
                         (format
                           #t
                           " ~-48S~4D   shrub ~5,,2fK   ~4,,2fK~%"
                           (-> s1-0 name)
                           (-> s1-0 in-level)
                           (* 0.0009765625 (the float v1-29))
                           (* 0.0009765625 (the float (* (the-as uint 80) (-> s1-0 in-level))))
                           )
                         )
                       )
                     )
                   )
                 )
                ((drawable-tree-instance-tie)
                 (let ((s3-1 (-> (the-as drawable-tree-instance-tie v1-8) prototypes prototype-array-tie)))
                   (dotimes (s2-1 (-> s3-1 length))
                     0
                     (let ((s1-1 (-> s3-1 array-data s2-1)))
                       (reset! *instance-mem-usage*)
                       (dotimes (s0-2 4)
                         (when (nonzero? (-> s1-1 tie-geom s0-2))
                           (let* ((a0-13 (-> s1-1 tie-geom s0-2))
                                  (t9-8 (method-of-object a0-13 mem-usage))
                                  (a1-7 *instance-mem-usage*)
                                  (v1-47 s0-2)
                                  )
                             (t9-8 a0-13 a1-7 (logior (cond
                                                        ((= v1-47 1)
                                                         4
                                                         )
                                                        ((= v1-47 2)
                                                         8
                                                         )
                                                        ((= v1-47 3)
                                                         16
                                                         )
                                                        (else
                                                          0
                                                          )
                                                        )
                                                      2
                                                      )
                                   )
                             )
                           )
                         )
                       (mem-usage s1-1 *instance-mem-usage* 0)
                       (let ((v1-54 (calculate-total *instance-mem-usage*)))
                         (format
                           #t
                           " ~-48S~4D   tie   ~5,,2fK   ~4,,2fK~%"
                           (-> s1-1 name)
                           (-> s1-1 in-level)
                           (* 0.0009765625 (the float v1-54))
                           (* 0.0009765625 (the float (* (-> s1-1 in-level) 64)))
                           )
                         )
                       )
                     )
                   )
                 )
                )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

;; definition (debug) for function draw-instance-info
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defun-debug draw-instance-info ((arg0 string))
  (local-vars
    (sv-16 uint)
    (sv-32 uint)
    (sv-48 uint)
    (sv-64 int)
    (sv-80 int)
    (sv-96 int)
    (sv-112 int)
    (sv-128 int)
    (sv-144 int)
    )
  (when (and *display-instance-info* *edit-instance*)
    (let ((s5-0 (find-instance-by-name *edit-instance*)))
      (when s5-0
        (dotimes (s4-0 (-> *level* length))
          (let ((v1-5 (-> *level* level s4-0)))
            (when (= (-> v1-5 status) 'active)
              (let ((s3-0 (-> v1-5 bsp drawable-trees)))
                (dotimes (s2-0 (-> s3-0 length))
                  (let ((v1-9 (-> s3-0 trees s2-0)))
                    (case (-> v1-9 type)
                      ((drawable-tree-instance-shrub)
                       )
                      ((drawable-tree-instance-tie)
                       (let ((s1-0 (-> (the-as
                                         drawable-tree-instance-tie
                                         (+ (* (+ (-> (the-as drawable-tree-instance-tie v1-9) length) -1) 4) (the-as int v1-9))
                                         )
                                       data
                                       0
                                       )
                                   )
                             )
                         (dotimes (s0-0 (-> (the-as drawable-inline-array-instance-tie s1-0) length))
                           (if (string= (-> (the-as drawable-inline-array-instance-tie s1-0) data s0-0 bucket-ptr name) *edit-instance*)
                               (add-debug-sphere
                                 #t
                                 (bucket-id debug-no-zbuf1)
                                 (the-as
                                   vector
                                   (+ (the-as uint (-> (the-as drawable-inline-array-instance-tie s1-0) data 0 bsphere)) (* s0-0 64))
                                   )
                                 (-> (the-as drawable-inline-array-instance-tie s1-0) data s0-0 bsphere w)
                                 (new 'static 'rgba :g #xff :a #x80)
                                 )
                               )
                           )
                         )
                       )
                      )
                    )
                  )
                )
              )
            )
          )
        (let ((s2-1 (prototype-bucket-type s5-0)))
          (let ((s4-1 0))
            0
            (cond
              ((= s2-1 instance-shrubbery)
               (set! s4-1 80)
               )
              ((= s2-1 instance-tie)
               (reset! *instance-mem-usage*)
               (dotimes (s4-2 4)
                 (when (nonzero? (-> s5-0 geometry s4-2))
                   (let* ((a0-17 (-> s5-0 geometry s4-2))
                          (t9-5 (method-of-object a0-17 mem-usage))
                          (a1-6 *instance-mem-usage*)
                          (v1-40 s4-2)
                          )
                     (t9-5 a0-17 a1-6 (logior (cond
                                                ((= v1-40 1)
                                                 4
                                                 )
                                                ((= v1-40 2)
                                                 8
                                                 )
                                                ((= v1-40 3)
                                                 16
                                                 )
                                                (else
                                                  0
                                                  )
                                                )
                                              2
                                              )
                           )
                     )
                   )
                 )
               (set! s4-1 (+ (calculate-total *instance-mem-usage*) 64))
               )
              )
            (mem-usage s5-0 (reset! *instance-mem-usage*) 0)
            (let ((v1-50 (calculate-total *instance-mem-usage*)))
              (format
                arg0
                "~%~A ~A b @ #x~X ~,,2fK/~,,2fK~%"
                s2-1
                (-> s5-0 name)
                s5-0
                (* 0.0009765625 (the float v1-50))
                (* 0.0009765625 (the float s4-1))
                )
              )
            )
          (format arg0 "near: ~m  mid: ~m  far: ~m~%" (-> s5-0 dists x) (-> s5-0 dists z) (-> s5-0 dists w))
          (let ((s3-2 0)
                (s4-3 0)
                )
            (cond
              ((= s2-1 instance-shrubbery)
               (let ((f30-0 0.0))
                 (format
                   arg0
                   "usage: vis: ~D  shrub: ~D  trans-shrub ~D  bill: ~D   in level: ~D~%"
                   (-> (the-as prototype-bucket-shrub s5-0) count 0)
                   (-> (the-as prototype-bucket-shrub s5-0) count 1)
                   (-> (the-as prototype-bucket-shrub s5-0) count 2)
                   (-> (the-as prototype-bucket-shrub s5-0) count 3)
                   (-> (the-as prototype-bucket-shrub s5-0) in-level)
                   )
                 (format arg0 "~%frag#     tris   dverts   strlen  tex~%")
                 (let ((s1-2 (the-as prototype-shrubbery (-> (the-as prototype-bucket-shrub s5-0) geometry 1)))
                       (s2-2 (+ (-> (the-as prototype-bucket-shrub s5-0) count 1) (-> (the-as prototype-bucket-shrub s5-0) count 2)))
                       )
                   (dotimes (s0-1 (-> s1-2 length))
                     (set! sv-16 (shrub-num-tris (-> s1-2 data s0-1)))
                     (set! sv-32 (-> s1-2 data s0-1 header data 2))
                     (set! sv-48 (-> s1-2 data s0-1 header data 0))
                     (format
                       arg0
                       "~5D     ~4D    ~5D   ~6f    ~D~%"
                       s0-1
                       sv-16
                       sv-32
                       (/ (* 2.0 (the float sv-16)) (the float (- sv-32 sv-16)))
                       sv-48
                       )
                     (+! s3-2 sv-16)
                     (+! s4-3 sv-32)
                     (set! f30-0
                           (+ 29.0
                              (* 5.5 (the float (- sv-32 sv-16)))
                              (* 22.0 (the float sv-48))
                              (* 8.0 (the float sv-32))
                              (* 53.0 (the float (/ (+ s2-2 9) (the-as uint 10))))
                              (* (the float s2-2) (+ 15.0 (* 5.0 (the float sv-48)) (* 13.5 (the float sv-32))))
                              f30-0
                              )
                           )
                     )
                   (format
                     arg0
                     "total     ~4D    ~5D   ~6f    ~D  speed: ~f~%"
                     s3-2
                     s4-3
                     (/ (* 2.0 (the float s3-2)) (the float (- s4-3 s3-2)))
                     (-> s5-0 utextures)
                     (/ f30-0 (* (the float s2-2) (the float s3-2)))
                     )
                   )
                 )
               )
              ((= s2-1 instance-tie)
               (set! sv-144 0)
               (let ((s1-3 0)
                     (s0-2 0)
                     (s2-3 0)
                     )
                 (format arg0 "~%level   visible  frags   tris   dverts   strlen  tex  ttris~%")
                 (set! sv-64 1)
                 (set! sv-80 3)
                 (while (>= sv-80 sv-64)
                   (let ((v1-100 (-> (the-as prototype-bucket-tie s5-0) tie-geom sv-64)))
                     (set! sv-96 0)
                     (set! sv-112 0)
                     (set! sv-128 0)
                     (dotimes (a0-36 (-> v1-100 length))
                       (set! sv-96 (+ sv-96 (-> v1-100 data a0-36 debug num-tris)))
                       (set! sv-112 (+ sv-112 (-> v1-100 data a0-36 debug num-dverts)))
                       (set! sv-128 (+ sv-128 (-> v1-100 data a0-36 tex-count)))
                       )
                     (set! sv-144 (+ sv-144 (-> (the-as prototype-bucket-tie s5-0) count sv-64)))
                     (format
                       arg0
                       "~5D  ~7D  ~5D   ~5D"
                       sv-64
                       (-> (the-as prototype-bucket-tie s5-0) count sv-64)
                       (-> v1-100 length)
                       sv-96
                       )
                     )
                   (format
                     arg0
                     "    ~5D   ~6f  ~3D  ~5D~%"
                     sv-112
                     (/ (* 2.0 (the float sv-96)) (the float (- sv-112 sv-96)))
                     sv-128
                     (* (the-as uint sv-96) (-> (the-as prototype-bucket-tie s5-0) count sv-64))
                     )
                   (+! s1-3 (* (the-as uint sv-96) (-> (the-as prototype-bucket-tie s5-0) count sv-64)))
                   (+! s0-2 (* (the-as uint sv-112) (-> (the-as prototype-bucket-tie s5-0) count sv-64)))
                   (+! s3-2 sv-96)
                   (+! s4-3 sv-112)
                   (+! s2-3 sv-128)
                   (set! sv-64 (+ sv-64 1))
                   )
                 (let ((t9-20 format)
                       (a0-52 arg0)
                       (a1-28 "total  ~7D/~3D      ~5D")
                       (a3-12 (-> s5-0 in-level))
                       )
                   (t9-20 a0-52 a1-28 sv-144 a3-12 s3-2)
                   )
                 (format
                   arg0
                   "    ~5D   ~6f  ~3D  ~5D~%"
                   s4-3
                   (/ (* 2.0 (the float s1-3)) (the float (- s0-2 s1-3)))
                   s2-3
                   s1-3
                   )
                 )
               )
              )
            )
          )
        )
      )
    )
  (none)
  )

;; definition (debug) for function set-shadow-by-name
;; WARN: Return type mismatch uint vs none.
(defun-debug set-shadow-by-name ((arg0 string) (arg1 int) (arg2 int))
  "Modify the shadow values for a process."
  (let ((v1-0 (process-by-name arg0 *active-pool*)))
    (when v1-0
      (let ((v1-1 (-> (the-as process-drawable v1-0) draw)))
        (cond
          ((< arg2 16)
           (logior! (-> v1-1 shadow-mask) (ash 1 arg1))
           (logclear! (-> v1-1 shadow-values) (ash 15 (* arg1 4)))
           (logior! (-> v1-1 shadow-values) (ash arg2 (* arg1 4)))
           )
          (else
            (logclear! (-> v1-1 shadow-mask) (ash 1 arg1))
            (logclear! (-> v1-1 shadow-values) (ash 15 (* arg1 4)))
            )
          )
        )
      )
    )
  (none)
  )

;; definition (debug) for function get-shadow-by-name
;; WARN: Return type mismatch object vs none.
(defun-debug get-shadow-by-name ((arg0 string))
  "Print to stdout the mask/values for the given process shadows"
  (let ((v1-0 (process-by-name arg0 *active-pool*)))
    (when v1-0
      (let ((s5-0 (-> (the-as process-drawable v1-0) draw)))
        (format 0 "actor ~s {~%" arg0)
        (format 0 "	SHADOW_MASK(0x~02x)~%" (-> s5-0 shadow-mask))
        (format 0 "	SHADOW_VALUES(0x~08x)~%" (-> s5-0 shadow-values))
        )
      (format 0 "}~%")
      )
    )
  (none)
  )

;; definition (debug) for function teleport-camera-by-name
;; WARN: Return type mismatch object vs none.
(defun-debug teleport-camera-by-name ((arg0 string))
  "Move camera to entity by name"
  (let* ((gp-0 (entity-by-name arg0))
         (v1-0 (if (type? gp-0 entity-actor)
                   gp-0
                   )
               )
         )
    (if (and v1-0 *camera*)
        (send-event *camera* 'teleport-to-vector-start-string (-> v1-0 trans))
        )
    )
  (none)
  )

;; definition (debug) for function teleport-camera-by-pos
;; WARN: Return type mismatch object vs none.
(defun-debug teleport-camera-by-pos ((arg0 float) (arg1 float) (arg2 float))
  "Move camera to position"
  (let ((v1-0 (new 'stack-no-clear 'vector)))
    (when *camera*
      (set-vector! v1-0 (* 4096.0 arg0) (* 4096.0 arg1) (* 4096.0 arg2) 1.0)
      (send-event *camera* 'teleport-to-vector-start-string v1-0)
      )
    )
  (none)
  )

;; definition for function calc-vu1-shadow
;; INFO: Used lq/sq
;; WARN: Return type mismatch float vs none.
(defun calc-vu1-shadow ((arg0 light-group) (arg1 draw-control))
  "Update shadow-ctrl based on lights"
  (rlet ((acc :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (let ((s4-0 (new 'stack-no-clear 'vector))
          (s5-0 (-> arg1 shadow-ctrl settings shadow-dir))
          (f30-0 (-> arg1 shadow-ctrl settings shadow-dir w))
          )
      (.lvf vf1 (&-> arg0 dir0 direction quad))
      (.lvf vf2 (&-> arg0 dir1 direction quad))
      (.lvf vf3 (&-> arg0 dir2 direction quad))
      (.lvf vf4 (&-> arg0 dir0 extra quad))
      (.lvf vf5 (&-> arg0 dir1 extra quad))
      (.lvf vf6 (&-> arg0 dir2 extra quad))
      (.mul.x.vf acc vf1 vf4)
      (.add.mul.x.vf acc vf2 vf5 acc)
      (.add.mul.x.vf vf1 vf3 vf6 acc)
      (.svf (&-> s4-0 quad) vf1)
      (vector-normalize! s4-0 -1.0)
      (when (< (- (-> s4-0 y)) 0.9063)
        (let* ((f0-2 0.4226)
               (f1-1 (-> s4-0 x))
               (f1-3 (* f1-1 f1-1))
               (f2-0 (-> s4-0 z))
               (f0-3 (/ f0-2 (sqrtf (+ f1-3 (* f2-0 f2-0)))))
               )
          (set! (-> s4-0 x) (* (-> s4-0 x) f0-3))
          (set! (-> s4-0 y) -0.9063)
          (set! (-> s4-0 z) (* (-> s4-0 z) f0-3))
          )
        )
      (cond
        ((logtest? (-> arg1 shadow-ctrl settings flags) (shadow-flags shdf08))
         (set! (-> s5-0 quad) (-> s4-0 quad))
         )
        (else
          (when (not (paused?))
            (vector-seek! s5-0 s4-0 (* 0.2 (seconds-per-frame)))
            (vector-normalize! s5-0 1.0)
            )
          )
        )
      (set! (-> arg1 shadow-ctrl settings shadow-dir w) f30-0)
      )
    (none)
    )
  )

;; definition for function calc-shadow-masks
;; WARN: Return type mismatch symbol vs none.
;; ERROR: Unsupported inline assembly instruction kind - [srl v1, v1, 24]
(defun calc-shadow-masks ((arg0 light-group) (arg1 draw-control) (arg2 uint))
  (local-vars (v1-25 uint) (v1-26 int) (sv-64 light-hash) (sv-68 vector) (sv-72 mood-context) (sv-76 pointer))
  (let ((s5-0 (the-as (array float) (new 'stack 'boxed-array float 6))))
    (let ((v1-1 (-> arg1 shadow-mask))
          (a0-2 (-> arg1 shadow-values))
          )
      (dotimes (a1-2 5)
        (if (not (logtest? v1-1 (ash 1 a1-2)))
            (set! (-> s5-0 a1-2) 1.0)
            (set! (-> s5-0 a1-2) (* 0.0625 (the float (logand (ash a0-2 (* -4 a1-2)) 15))))
            )
        )
      )
    (when (or (and (>= (the-as int arg2) 10) (< (the-as int arg2) 18))
              (and (>= (the-as int arg2) 30) (< (the-as int arg2) 38))
              )
      (dotimes (s3-1 (-> *level* length))
        (let ((v1-10 (-> *level* level s3-1)))
          (when (= (-> v1-10 status) 'active)
            (set! sv-64 (-> v1-10 light-hash))
            (set! sv-68 (-> arg1 origin))
            (set! sv-72 (-> v1-10 mood-context))
            (when (nonzero? sv-64)
              (let ((v1-13 (light-hash-get-bucket-index sv-64 (-> arg1 origin))))
                (when (!= v1-13 -1)
                  (let ((s2-0 (-> sv-64 bucket-array v1-13)))
                    (set! sv-76 (+ (+ (-> s2-0 index) 0) (the-as uint (-> sv-64 index-array))))
                    (dotimes (s1-0 (the-as int (-> s2-0 count)))
                      (let ((s0-0 (-> sv-64 light-sphere-array (-> (the-as (pointer uint8) (&+ sv-76 s1-0))))))
                        (when (= (-> s0-0 palette-index) -2)
                          (let* ((f0-3 (-> s0-0 bsphere w))
                                 (f28-0 (* f0-3 (-> s0-0 decay-start)))
                                 (f26-0 (- f0-3 f28-0))
                                 (f0-8 (fmax 0.0 (fmin 1.0 (/ (- (vector-vector-distance (-> s0-0 bsphere) sv-68) f28-0) f26-0))))
                                 )
                            (when (!= f0-8 1.0)
                              (.srl v1-26 v1-25 24)
                              (let ((a0-26 (shr (shl (-> s0-0 shadow) 40) 40)))
                                (dotimes (a1-6 5)
                                  (when (logtest? v1-26 (ash 1 a1-6))
                                    (let ((f1-5 (* 0.0625 (the float (logand (ash a0-26 (* -4 a1-6)) 15)))))
                                      1.0
                                      (set! (-> s5-0 a1-6) (fmin (-> s5-0 a1-6) (+ f1-5 (* (- 1.0 f1-5) f0-8))))
                                      )
                                    )
                                  )
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    (dotimes (v1-35 4)
      (when (nonzero? (-> arg0 lights v1-35 mask))
        (let ((a0-36 (-> arg0 lights v1-35 palette-index)))
          (set! (-> arg0 lights v1-35 extra x) (* (-> arg0 lights v1-35 extra x) (-> s5-0 a0-36)))
          )
        )
      )
    )
  (none)
  )

;; definition for function calc-realtime-lights
;; WARN: Return type mismatch symbol vs none.
(defun calc-realtime-lights ((arg0 light-group) (arg1 draw-control) (arg2 uint))
  (local-vars (sv-16 light-hash) (sv-20 vector) (sv-24 mood-context))
  (when (or (and (>= (the-as int arg2) 10) (< (the-as int arg2) 18))
            (and (>= (the-as int arg2) 30) (< (the-as int arg2) 38))
            )
    (dotimes (s4-0 (-> *level* length))
      (let ((v1-5 (-> *level* level s4-0)))
        (when (= (-> v1-5 status) 'active)
          (set! sv-16 (-> v1-5 light-hash))
          (set! sv-20 (-> arg1 origin))
          (set! sv-24 (-> v1-5 mood-context))
          (when (nonzero? sv-16)
            (let ((v1-8 (light-hash-get-bucket-index sv-16 (-> arg1 origin))))
              (when (!= v1-8 -1)
                (let* ((s3-0 (-> sv-16 bucket-array v1-8))
                       (s2-0 (+ (+ (-> s3-0 index) 0) (the-as uint (-> sv-16 index-array))))
                       )
                  (dotimes (s1-0 (the-as int (-> s3-0 count)))
                    (let* ((a1-3 (-> sv-16 light-sphere-array (-> (the-as (pointer uint8) (&+ s2-0 s1-0)))))
                           (v1-14 (-> a1-3 palette-index))
                           (f0-1 (if (= v1-14 -1)
                                     1.0
                                     (-> sv-24 times v1-14 w)
                                     )
                                 )
                           )
                      (if (not (or (= (-> a1-3 palette-index) -2) (= (* (-> a1-3 brightness) f0-1) 0.0)))
                          (add-light-sphere-to-light-group arg0 a1-3 sv-20 sv-24)
                          )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  (none)
  )

;; definition for function calc-vu1-lights
;; WARN: Return type mismatch int vs none.
(defun calc-vu1-lights ((arg0 vu-lights) (arg1 draw-control) (arg2 symbol))
  (local-vars (v1-44 float))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (let ((s4-0 *time-of-day-context*))
      (cond
        ((logtest? (-> arg1 global-effect) (draw-control-global-effect title-light))
         (when (not (-> s4-0 title-updated))
           (set! (-> s4-0 title-updated) #t)
           (let ((s2-1 (-> *math-camera* inv-camera-rot))
                 (a1-1 (new 'static 'vector :x 0.612 :y 0.5 :z -0.612))
                 (s3-0 (new 'static 'vector :x -0.696 :y 0.174 :z 0.696))
                 )
             (vector-matrix*! (the-as vector (-> s4-0 title-light-group)) a1-1 s2-1)
             (vector-matrix*! (the-as vector (-> s4-0 title-light-group dir1)) s3-0 s2-1)
             )
           )
         (vu-lights<-light-group! arg0 (-> s4-0 title-light-group))
         )
        ((logtest? (-> arg1 global-effect) (draw-control-global-effect rim-lights))
         (let ((s1-0 (-> *math-camera* inv-camera-rot))
               (a1-4 (new 'static 'vector :x 0.77455187 :y 0.44725248 :z 0.44725248))
               (s3-1 (new 'static 'vector :x -0.77455187 :y 0.44725248 :z 0.44725248))
               (s2-2 (new 'static 'vector :y -0.8944 :z 0.4472))
               (s4-1 (-> s4-0 rim-light-group))
               )
           (vector-matrix*! (the-as vector (-> s4-1 dir0)) a1-4 s1-0)
           (vector-matrix*! (the-as vector (-> s4-1 dir1)) s3-1 s1-0)
           (vector-matrix*! (the-as vector (-> s4-1 dir2)) s2-2 s1-0)
           (vu-lights<-light-group! arg0 s4-1)
           )
         )
        ((logtest? (-> arg1 global-effect) (draw-control-global-effect rim-lights2))
         (let ((s1-1 (-> *math-camera* inv-camera-rot))
               (a1-8 (new 'static 'vector :x 0.77455187 :y 0.44725248 :z 0.44725248))
               (s3-2 (new 'static 'vector :x -0.77455187 :y 0.44725248 :z 0.44725248))
               (s2-3 (new 'static 'vector :y -0.8944 :z 0.4472))
               (s4-2 (-> s4-0 rim-light-group2))
               )
           (vector-matrix*! (the-as vector (-> s4-2 dir0)) a1-8 s1-1)
           (vector-matrix*! (the-as vector (-> s4-2 dir1)) s3-2 s1-1)
           (vector-matrix*! (the-as vector (-> s4-2 dir2)) s2-3 s1-1)
           (vu-lights<-light-group! arg0 s4-2)
           )
         )
        ((logtest? (-> arg1 global-effect) (draw-control-global-effect rim-lights3))
         (let ((s1-2 (-> *math-camera* inv-camera-rot))
               (a1-12 (new 'static 'vector :x 0.77455187 :y 0.44725248 :z 0.44725248))
               (s3-3 (new 'static 'vector :x -0.77455187 :y 0.44725248 :z 0.44725248))
               (s2-4 (new 'static 'vector :y -0.8944 :z 0.4472))
               (s4-3 (-> s4-0 rim-light-group3))
               )
           (vector-matrix*! (the-as vector (-> s4-3 dir0)) a1-12 s1-2)
           (vector-matrix*! (the-as vector (-> s4-3 dir1)) s3-3 s1-2)
           (vector-matrix*! (the-as vector (-> s4-3 dir2)) s2-4 s1-2)
           (vu-lights<-light-group! arg0 s4-3)
           )
         )
        (else
          (let ((v1-20 (-> arg1 level-index))
                (s1-3 (-> arg1 light-index))
                (s3-4 (new 'stack-no-clear 'light-group))
                )
            (if (and (>= v1-20 (the-as uint 10)) (< s1-3 (the-as uint 20)))
                (+! s1-3 20)
                )
            (let ((v1-22 (+ (the-as uint (-> *level* level0 mood-context)) (* (the-as uint 5424) v1-20))))
              (cond
                ((< s1-3 (the-as uint 8))
                 (quad-copy! (the-as pointer s3-4) (the-as pointer (+ (* (the-as uint 192) s1-3) 112 v1-22)) 12)
                 )
                ((< s1-3 (the-as uint 18))
                 (quad-copy! (the-as pointer s3-4) (the-as pointer (+ (* (the-as uint 192) (+ s1-3 -10)) 112 v1-22)) 12)
                 )
                ((< s1-3 (the-as uint 28))
                 (quad-copy! (the-as pointer s3-4) (the-as pointer (-> s4-0 light-group (+ s1-3 -20))) 12)
                 )
                ((< s1-3 (the-as uint 38))
                 (quad-copy! (the-as pointer s3-4) (the-as pointer (-> s4-0 light-group (+ s1-3 -30))) 12)
                 )
                )
              )
            (calc-shadow-masks s3-4 arg1 s1-3)
            (calc-realtime-lights s3-4 arg1 s1-3)
            (vu-lights<-light-group! arg0 s3-4)
            (if (and arg2
                     (nonzero? (-> arg1 shadow-ctrl))
                     (-> arg1 shadow-ctrl)
                     (not (logtest? (-> arg1 shadow-ctrl settings flags) (shadow-flags disable-draw)))
                     (not (logtest? (-> arg1 shadow-ctrl settings flags) (shadow-flags shdf07)))
                     )
                (calc-vu1-shadow s3-4 arg1)
                )
            )
          )
        )
      )
    (.lvf vf5 (&-> arg1 color-mult quad))
    (.lvf vf6 (&-> arg1 color-emissive quad))
    (.lvf vf1 (&-> arg0 color 0 quad))
    (.lvf vf2 (&-> arg0 color 1 quad))
    (.lvf vf3 (&-> arg0 color 2 quad))
    (.lvf vf4 (&-> arg0 ambient quad))
    (.mul.vf vf4 vf4 vf5)
    (.mul.vf vf1 vf1 vf5)
    (.mul.vf vf2 vf2 vf5)
    (.mul.vf vf3 vf3 vf5)
    (.add.vf vf4 vf4 vf6)
    (.svf (&-> arg0 color 0 quad) vf1)
    (.svf (&-> arg0 color 1 quad) vf2)
    (.svf (&-> arg0 color 2 quad) vf3)
    (.svf (&-> arg0 ambient quad) vf4)
    (.mov v1-44 vf4)
    0
    (none)
    )
  )

;; definition for function dma-add-process-drawable
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
;; WARN: Function dma-add-process-drawable has a return type of none, but the expression builder found a return statement.
(defun dma-add-process-drawable ((arg0 process-drawable) (arg1 draw-control) (arg2 symbol) (arg3 dma-buffer))
  "Generate DMA for foreground object, calculate lights/shadows, etc."
  (local-vars (a0-41 int) (a0-43 int) (a3-9 uint128) (sv-16 process-drawable))
  (with-pp
    (rlet ((acc :class vf)
           (Q :class vf)
           (vf0 :class vf)
           (vf15 :class vf)
           (vf16 :class vf)
           (vf17 :class vf)
           (vf18 :class vf)
           (vf19 :class vf)
           (vf20 :class vf)
           (vf21 :class vf)
           (vf22 :class vf)
           (vf23 :class vf)
           (vf24 :class vf)
           (vf25 :class vf)
           (vf26 :class vf)
           (vf27 :class vf)
           (vf28 :class vf)
           (vf29 :class vf)
           )
      (init-vf0-vector)
      (set! sv-16 arg0)
      (let* ((v1-1 (-> *perf-stats* data 50))
             (a0-1 (-> v1-1 ctrl))
             )
        (+! (-> v1-1 count) 1)
        (b! (zero? a0-1) cfg-2 :delay (nop!))
        (.mtc0 Perf 0)
        (.sync.l)
        (.sync.p)
        (.mtpc pcr0 0)
        (.mtpc pcr1 0)
        (.sync.l)
        (.sync.p)
        (.mtc0 Perf a0-1)
        )
      (.sync.l)
      (.sync.p)
      (label cfg-2)
      0
      (when (get-menu-mode *blit-displays-work*)
        (if (not (logtest? (-> arg1 status) (draw-control-status hud)))
            (return #f)
            )
        )
      (logclear! (-> arg1 status) (draw-control-status on-screen))
      (when (not (logtest? (-> arg1 status) (draw-control-status no-draw no-draw-temp uninited)))
        (let ((s3-0 (-> (the-as foreground-work #x70000000) bounds))
              (s4-0 (-> (the-as foreground-work #x70000000) lights))
              )
          (.lvf vf16 (&-> arg1 origin quad))
          (.svf (&-> s3-0 quad) vf16)
          (when (or (sphere-in-view-frustum? s3-0) (logtest? (-> arg1 status) (draw-control-status no-bounds-check)))
            (calc-vu1-lights s4-0 arg1 #t)
            (let ((at-0 *math-camera*))
              (.lvf vf16 (&-> at-0 plane 0 quad))
              (.lvf vf17 (&-> at-0 plane 1 quad))
              (.lvf vf18 (&-> at-0 plane 2 quad))
              (.lvf vf19 (&-> at-0 plane 3 quad))
              (.lvf vf20 (&-> at-0 guard-plane 0 quad))
              (.lvf vf21 (&-> at-0 guard-plane 1 quad))
              (.lvf vf22 (&-> at-0 guard-plane 2 quad))
              (.lvf vf23 (&-> at-0 guard-plane 3 quad))
              (.lvf vf24 (&-> at-0 camera-rot rvec quad))
              (.lvf vf25 (&-> at-0 camera-rot uvec quad))
              (.lvf vf26 (&-> at-0 camera-rot fvec quad))
              (.lvf vf27 (&-> at-0 camera-rot trans quad))
              )
            (let ((v1-20 (-> (the-as foreground-work #x70000000) distance)))
              (.lvf vf15 (&-> s3-0 quad))
              (.mul.w.vf acc vf27 vf0)
              (.add.mul.x.vf acc vf24 vf15 acc)
              (.add.mul.y.vf acc vf25 vf15 acc)
              (.add.mul.z.vf vf15 vf26 vf15 acc :mask #b111)
              (.mul.vf vf28 vf15 vf15)
              (.max.w.vf vf29 vf0 vf0)
              (.add.y.vf acc vf28 vf28)
              (.add.mul.z.vf vf28 vf29 vf28 acc :mask #b1)
              (.sqrt.vf Q vf28 :ftf #b0)
              (.sub.w.vf vf28 vf0 vf15 :mask #b1000)
              (.wait.vf)
              (.add.vf vf15 vf28 Q :mask #b1000)
              (.svf (&-> v1-20 quad) vf15)
              (when (< 0.0 (+ (-> v1-20 z) (-> arg1 bounds w)))
                (let ((s4-1 0))
                  (let ((f30-0 (-> v1-20 w)))
                    (if (and *debug-segment* (-> *screen-shot-work* highres-enable))
                        (set! f30-0 0.0)
                        )
                    (set! (-> arg1 distance) f30-0)
                    (when (nonzero? (-> arg1 lod-set max-lod))
                      (cond
                        ((>= (-> arg1 force-lod) 0)
                         (set! s4-1 (-> arg1 force-lod))
                         (if (< (-> arg1 lod-set lod (-> arg1 lod-set max-lod) dist) f30-0)
                             (return #f)
                             )
                         )
                        (else
                          (while (and (< s4-1 (-> arg1 lod-set max-lod)) (< (-> arg1 lod-set lod s4-1 dist) f30-0))
                            (+! s4-1 1)
                            )
                          )
                        )
                      )
                    (if (and (< (-> arg1 lod-set lod s4-1 dist) f30-0) (< (-> arg1 force-lod) 0))
                        (return #f)
                        )
                    (let ((v1-49 (-> *level* level (-> arg1 level-index)))
                          (f0-5 (* f30-0 (-> *math-camera* fov-correction-factor)))
                          (a0-18 (-> arg1 mgeo header texture-usage-group))
                          )
                      (dotimes (a1-4 7)
                        (let ((a2-2 (+ a1-4 12)))
                          (if (not (logtest? (-> arg1 status) (draw-control-status no-closest-distance)))
                              (set! (-> v1-49 closest-object a2-2) (fmin (-> v1-49 closest-object a2-2) f30-0))
                              )
                          )
                        (let ((t0-0 (cond
                                      ((>= f0-5 (-> a0-18 data a1-4 data 0 dist))
                                       0
                                       )
                                      ((>= f0-5 (-> a0-18 data a1-4 data 1 dist))
                                       1
                                       )
                                      (else
                                        2
                                        )
                                      )
                                    )
                              (a2-12 (+ a1-4 12))
                              )
                          (let ((a3-8 (-> v1-49 texture-mask a2-12 mask quad))
                                (t0-3 (-> (the-as (pointer int128) (+ (the-as uint a0-18) (* 48 a1-4) (* t0-0 16))) 0))
                                )
                            (.por a3-9 a3-8 t0-3)
                            )
                          (set! (-> v1-49 texture-mask a2-12 mask quad) a3-9)
                          )
                        )
                      )
                    (if (or (guard-band-cull s3-0) (< f30-0 (* 1.2 (-> *math-camera* d))))
                        (logior! (-> arg1 status) (draw-control-status close-to-screen))
                        (logclear! (-> arg1 status) (draw-control-status close-to-screen))
                        )
                    (logior! (-> arg1 status) (draw-control-status on-screen))
                    (if (logtest? (-> arg1 status) (draw-control-status no-draw-bounds no-draw-bounds2))
                        (return #f)
                        )
                    (set! (-> pp clock) (-> sv-16 clock))
                    (if (or (= s4-1 (-> arg1 cur-lod)) (logtest? (-> arg1 status) (draw-control-status lod-set)))
                        (foreground-draw arg1 arg3 f30-0)
                        )
                    )
                  (when (and (< s4-1 (-> arg1 cur-lod)) (logtest? (-> arg1 status) (draw-control-status math-skel)))
                    (let ((s5-1 *matrix-engine*))
                      (when (= (-> s5-1 length) (-> s5-1 allocated-length))
                        (format 0 "Matrix engine is too small!~%")
                        (format *stdcon* "Matrix engine is too small!~%")
                        (break!)
                        0
                        )
                      (set! (-> s5-1 (-> s5-1 length)) (process->handle sv-16))
                      (+! (-> s5-1 length) 1)
                      )
                    )
                  (lod-set! arg1 s4-1)
                  )
                (logior! (-> arg1 status) (draw-control-status lod-set))
                )
              )
            )
          )
        )
      (let ((v1-88 (-> *perf-stats* data 50)))
        (b! (zero? (-> v1-88 ctrl)) cfg-79 :delay (nop!))
        (.mtc0 Perf 0)
        (.sync.l)
        (.sync.p)
        (.mfpc a0-41 pcr0)
        (+! (-> v1-88 accum0) a0-41)
        (.mfpc a0-43 pcr1)
        (+! (-> v1-88 accum1) a0-43)
        )
      (label cfg-79)
      0
      0
      (none)
      )
    )
  )

;; definition for symbol *hud-lights*, type vu-lights
(define *hud-lights* (new 'global 'vu-lights))

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* direction 0) 1.0 0.0 0.0 1.0)

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* direction 1) 0.0 1.0 0.0 1.0)

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* direction 2) 0.0 0.0 1.0 1.0)

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* color 0) 0.0 0.0 0.0 1.0)

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* color 1) 0.0 0.0 0.0 1.0)

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* color 2) 0.5 0.5 0.5 1.0)

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* ambient) 0.5 0.5 0.5 1.0)

;; definition for function dma-add-process-drawable-hud
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defun dma-add-process-drawable-hud ((arg0 process-drawable) (arg1 draw-control) (arg2 float) (arg3 dma-buffer))
  "Special version of dma-add-process-drawable for drawing hud foreground objects"
  (local-vars (a3-4 uint128))
  (logclear! (-> arg1 status) (draw-control-status on-screen))
  (when (not (logtest? (-> arg1 status) (draw-control-status no-draw no-draw-temp uninited)))
    (let ((v1-6 (-> (the-as foreground-work #x70000000) lights))
          (a0-3 *hud-lights*)
          )
      (set! (-> v1-6 direction 0 quad) (-> a0-3 direction 0 quad))
      (set! (-> v1-6 direction 1 quad) (-> a0-3 direction 1 quad))
      (set! (-> v1-6 direction 2 quad) (-> a0-3 direction 2 quad))
      (set! (-> v1-6 color 0 quad) (-> a0-3 color 0 quad))
      (set! (-> v1-6 color 1 quad) (-> a0-3 color 1 quad))
      (set! (-> v1-6 color 2 quad) (-> a0-3 color 2 quad))
      (set! (-> v1-6 ambient quad) (-> a0-3 ambient quad))
      )
    (lod-set! arg1 0)
    (logior! (-> arg1 status) (draw-control-status on-screen))
    (foreground-draw-hud arg1 arg3 arg2)
    (let ((v1-12 (-> *level* level-default))
          (a0-9 (-> arg1 mgeo header texture-usage-group))
          )
      (dotimes (a1-9 7)
        (let ((a2-1 (+ a1-9 12)))
          (let ((a3-3 (-> v1-12 texture-mask a2-1 mask quad))
                (t0-3 (-> a0-9 data a1-9 data 2 mask quad))
                )
            (.por a3-4 a3-3 t0-3)
            )
          (set! (-> v1-12 texture-mask a2-1 mask quad) a3-4)
          )
        )
      )
    )
  0
  (none)
  )

;; definition for function add-process-drawable
;; WARN: Return type mismatch symbol vs none.
(defun add-process-drawable ((arg0 process-drawable) (arg1 draw-control) (arg2 symbol) (arg3 dma-buffer))
  "Foreground engine function to generate dma for a process-drawable."
  ((-> arg1 dma-add-func) arg0 arg1 arg2 arg3)
  (none)
  )

;; definition for function foreground-engine-execute
;; WARN: Return type mismatch int vs none.
;; ERROR: Unsupported inline assembly instruction kind - [cache dxwbin v1, 0]
;; ERROR: Unsupported inline assembly instruction kind - [cache dxwbin v1, 1]
(defun foreground-engine-execute ((arg0 engine))
  "Draw all foreground objects!"
  (when (> (length arg0) 0)
    (let ((gp-0 (-> *display* frames (-> *display* on-screen) global-buf base)))
      (when *debug-segment*
        (let ((s4-0 (-> *display* frames (-> *display* on-screen) profile-array data 0))
              (v1-16 'foreground)
              (s3-0 *profile-foreground-color*)
              )
          (when (and *dproc* *debug-segment*)
            (let ((s2-0 (-> s4-0 data (-> s4-0 count))))
              (let ((s1-0 (-> s4-0 base-time)))
                (set! (-> s2-0 name) v1-16)
                (set! (-> s2-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s1-0))))
                )
              (set! (-> s2-0 depth) (the-as uint (-> s4-0 depth)))
              (set! (-> s2-0 color) s3-0)
              (set! (-> s4-0 segment (-> s4-0 depth)) s2-0)
              )
            (set! (-> s4-0 count) (min 1023 (+ (-> s4-0 count) 1)))
            (+! (-> s4-0 depth) 1)
            (set! (-> s4-0 max-depth) (max (-> s4-0 max-depth) (-> s4-0 depth)))
            )
          )
        0
        )
      (let ((s4-1 (-> *display* frames (-> *display* on-screen) global-buf)))
        (let ((v1-34 (-> s4-1 base)))
          (.sync.l)
          (.cache dxwbin v1-34 0)
          (.sync.l)
          (.cache dxwbin v1-34 1)
          )
        (.sync.l)
        0
        (foreground-init)
        (execute-connections arg0 s4-1)
        )
      (foreground-wrapup)
      (when *debug-segment*
        (let ((s5-1 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
          (when (and *dproc* *debug-segment*)
            (let* ((v1-49 (+ (-> s5-1 depth) -1))
                   (s4-2 (-> s5-1 segment v1-49))
                   (s3-1 (-> s5-1 base-time))
                   )
              (when (>= v1-49 0)
                (set! (-> s4-2 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-1))))
                (+! (-> s5-1 depth) -1)
                )
              )
            )
          )
        0
        )
      (let ((v1-54 *dma-mem-usage*))
        (when (nonzero? v1-54)
          (set! (-> v1-54 length) (max 36 (-> v1-54 length)))
          (set! (-> v1-54 data 35 name) "pris-fragment")
          (+! (-> v1-54 data 35 count) 1)
          (+! (-> v1-54 data 35 used)
              (&- (-> *display* frames (-> *display* on-screen) global-buf base) (the-as uint gp-0))
              )
          (set! (-> v1-54 data 35 total) (-> v1-54 data 35 used))
          )
        )
      )
    )
  0
  (none)
  )

;; definition (debug) for function main-debug-hook
(defun-debug main-debug-hook ()
  "Run debug engine, collision renderer."
  (when (not (or (= *master-mode* 'menu) (= *master-mode* 'progress)))
    (let ((a0-3 *col-rend*))
      (if (-> a0-3 draw?)
          (draw a0-3)
          )
      )
    (execute-connections *debug-engine* #f)
    (draw-instance-info *stdcon*)
    )
  (none)
  )

;; definition for symbol *debug-hook*, type pair
(define *debug-hook* (cons main-debug-hook '()))

;; definition for symbol *add-sphere*, type symbol
(define *add-sphere* #f)

;; definition for symbol *generic-effect-mode*, type int
(define *generic-effect-mode* 0)

;; definition for function foreground-initialize-engines
;; WARN: Return type mismatch symbol vs none.
(defun foreground-initialize-engines ()
  "Initialize shadow chains prior to foreground drawing."
  (let ((v1-0 *shadow-globals*))
    (dotimes (a0-0 3)
      (let ((a1-2 (-> v1-0 bucket a0-0)))
        (set! (-> a1-2 first) (the-as pointer 0))
        (set! (-> a1-2 next) (the-as pointer 0))
        (set! (-> a1-2 shadow-color) (cond
                                       ((zero? a0-0)
                                        (new 'static 'rgba :r #xf0 :g #xf0 :b #xf0 :a #x80)
                                        )
                                       ((= a0-0 1)
                                        (the-as rgba (-> *setting-control* user-current spotlight-color))
                                        )
                                       (else
                                         (the-as rgba (-> *setting-control* user-current highlight-color))
                                         )
                                       )
              )
        (set! (-> a1-2 constants) (the-as shadow-vu1-constants 0))
        )
      )
    )
  (none)
  )

;; definition for function foreground-execute-cpu-vu0-engines
(defun foreground-execute-cpu-vu0-engines ()
  "Run foreground drawing code on EE/VU0 (bones, generic merc, part of shadow, lightning, prim)"
  (let ((gp-0 (-> *display* frames (-> *display* on-screen) global-buf)))
    (bones-init gp-0)
    (bones-mtx-calc-execute)
    (generic-merc-execute-all gp-0)
    (shadow-execute-all gp-0)
    )
  (lightning-draw-all)
  (prim-engine-execute)
  (none)
  )

;; definition for function real-main-draw-hook
;; WARN: Return type mismatch int vs none.
(defun real-main-draw-hook ()
  "Do all drawing! Called by main loop to run drawing for a frame.
   Note that this also dispatches collide events, updates actors, etc.
   It's a bit more than just drawing."
  (local-vars (a0-115 int) (a0-117 int))
  (with-pp
    (let ((v1-5 (-> *display* frames (-> *display* on-screen) global-buf)))
      (set! (-> v1-5 end) (&- (-> v1-5 end) (the-as uint (* (shr (+ (-> *display* mem-reserve-size) 8255) 6) 64))))
      )
    (when *display-bug-report*
      (let ((v1-13 (-> *display* frames (-> *display* on-screen) global-buf)))
        (&+! (-> v1-13 end) -262144)
        )
      )
    (set! (-> *display* dma-buffer-overflow) #f)
    (set! (-> *display* mem-reserve-size) (the-as uint 0))
    (when *slow-frame-rate*
      (dotimes (v1-18 #xc3500)
        (nop!)
        (nop!)
        (nop!)
        (nop!)
        (nop!)
        (nop!)
        )
      )
    "Function to be executed to set up for engine dma"
    (set! (-> *display* vu1-enable-user) (-> *display* vu1-enable-user-menu))
    (set! (-> *texture-pool* texture-enable-user) (-> *texture-pool* texture-enable-user-menu))
    (when *debug-segment*
      (when (and *stats-memory* (!= *master-mode* 'menu))
        (cond
          (*stats-memory-short*
            (dotimes (gp-0 (-> *level* length))
              (let ((s5-0 (-> *level* level gp-0)))
                (if (= (-> s5-0 status) 'active)
                    (print-mem-usage (compute-memory-usage! s5-0 #f) s5-0 *stdcon*)
                    )
                )
              )
            )
          (else
            (let ((gp-1 (-> *level* level *stats-memory-level-index*)))
              (if (and gp-1 (= (-> gp-1 status) 'active))
                  (print-mem-usage (compute-memory-usage! gp-1 #f) gp-1 *stdcon*)
                  )
              )
            )
          )
        )
      (reset! *dma-mem-usage*)
      )
    (foreground-initialize-engines)
    (reset! *prim-work*)
    (let ((gp-2 (-> pp clock)))
      (if (= (-> *time-of-day-context* mode) (time-of-day-palette-id unk3))
          (set! (-> pp clock) (-> *display* bg-clock))
          (set! (-> pp clock) (-> *display* real-clock))
          )
      (if (not (paused?))
          (update-wind *wind-work* *wind-scales*)
          )
      (update-time-of-day *time-of-day-context*)
      (set! (-> pp clock) gp-2)
      )
    (when *debug-segment*
      (let ((gp-3 (-> *display* frames (-> *display* on-screen) profile-array data 0))
            (v1-73 'sky)
            (s5-1 *profile-sky-color*)
            )
        (when (and *dproc* *debug-segment*)
          (let ((s4-0 (-> gp-3 data (-> gp-3 count))))
            (let ((s3-0 (-> gp-3 base-time)))
              (set! (-> s4-0 name) v1-73)
              (set! (-> s4-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-0))))
              )
            (set! (-> s4-0 depth) (the-as uint (-> gp-3 depth)))
            (set! (-> s4-0 color) s5-1)
            (set! (-> gp-3 segment (-> gp-3 depth)) s4-0)
            )
          (set! (-> gp-3 count) (min 1023 (+ (-> gp-3 count) 1)))
          (+! (-> gp-3 depth) 1)
          (set! (-> gp-3 max-depth) (max (-> gp-3 max-depth) (-> gp-3 depth)))
          )
        )
      0
      )
    (if (-> *sky-work* draw-vortex)
        (draw-vortex)
        (draw *sky-work*)
        )
    (flush-cache 0)
    (when *debug-segment*
      (let ((gp-4 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
        (when (and *dproc* *debug-segment*)
          (let* ((v1-102 (+ (-> gp-4 depth) -1))
                 (s5-2 (-> gp-4 segment v1-102))
                 (s4-1 (-> gp-4 base-time))
                 )
            (when (>= v1-102 0)
              (set! (-> s5-2 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-1))))
              (+! (-> gp-4 depth) -1)
              )
            )
          )
        )
      0
      )
    (let ((gp-5 (-> pp clock)))
      (if (= (-> *time-of-day-context* mode) (time-of-day-palette-id unk3))
          (set! (-> pp clock) (-> *display* bg-clock))
          (set! (-> pp clock) (-> *display* real-clock))
          )
      (when *debug-segment*
        (let ((s5-3 (-> *display* frames (-> *display* on-screen) profile-array data 0))
              (v1-120 'ocean)
              (s4-2 *profile-ocean-color*)
              )
          (when (and *dproc* *debug-segment*)
            (let ((s3-1 (-> s5-3 data (-> s5-3 count))))
              (let ((s2-0 (-> s5-3 base-time)))
                (set! (-> s3-1 name) v1-120)
                (set! (-> s3-1 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s2-0))))
                )
              (set! (-> s3-1 depth) (the-as uint (-> s5-3 depth)))
              (set! (-> s3-1 color) s4-2)
              (set! (-> s5-3 segment (-> s5-3 depth)) s3-1)
              )
            (set! (-> s5-3 count) (min 1023 (+ (-> s5-3 count) 1)))
            (+! (-> s5-3 depth) 1)
            (set! (-> s5-3 max-depth) (max (-> s5-3 max-depth) (-> s5-3 depth)))
            )
          )
        0
        )
      (draw! *ocean*)
      (if *ocean-map*
          (update-map *ocean*)
          )
      (when *debug-segment*
        (let ((s5-4 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
          (when (and *dproc* *debug-segment*)
            (let* ((v1-150 (+ (-> s5-4 depth) -1))
                   (s4-3 (-> s5-4 segment v1-150))
                   (s3-2 (-> s5-4 base-time))
                   )
              (when (>= v1-150 0)
                (set! (-> s4-3 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-2))))
                (+! (-> s5-4 depth) -1)
                )
              )
            )
          )
        0
        )
      (set! (-> pp clock) gp-5)
      )
    (foreground-engine-execute *foreground-draw-engine*)
    (let ((gp-6 (-> pp clock)))
      (if (= (-> *time-of-day-context* mode) (time-of-day-palette-id unk3))
          (set! (-> pp clock) (-> *display* bg-clock))
          (set! (-> pp clock) (-> *display* real-clock))
          )
      (foreground-execute-cpu-vu0-engines)
      (set! (-> pp clock) gp-6)
      )
    (when *add-sphere*
      )
    (if (not (paused?))
        (execute-part-engine)
        )
    (when (logtest? (vu1-renderer-mask sprite) (-> *display* vu1-enable-user))
      (if (not (get-screen-copied *blit-displays-work*))
          (sprite-draw *display*)
          )
      )
    (when *debug-segment*
      (debug-draw-actors *level* *display-actor-marks*)
      (collide-shape-draw-debug-marks)
      )
    (when *display-trail-graph*
      (let ((a0-67 *trail-graph*))
        (if a0-67
            (debug-draw a0-67)
            )
        )
      )
    (send-events-for-touching-shapes *touching-list*)
    (free-nodes *touching-list*)
    (prepare *collide-rider-pool*)
    (send-all! *event-queue*)
    (when *debug-segment*
      (let ((gp-7 (-> *display* frames (-> *display* on-screen) profile-array data 0))
            (v1-200 'actors)
            (s5-5 *profile-actors-color*)
            )
        (when (and *dproc* *debug-segment*)
          (let ((s4-4 (-> gp-7 data (-> gp-7 count))))
            (let ((s3-3 (-> gp-7 base-time)))
              (set! (-> s4-4 name) v1-200)
              (set! (-> s4-4 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-3))))
              )
            (set! (-> s4-4 depth) (the-as uint (-> gp-7 depth)))
            (set! (-> s4-4 color) s5-5)
            (set! (-> gp-7 segment (-> gp-7 depth)) s4-4)
            )
          (set! (-> gp-7 count) (min 1023 (+ (-> gp-7 count) 1)))
          (+! (-> gp-7 depth) 1)
          (set! (-> gp-7 max-depth) (max (-> gp-7 max-depth) (-> gp-7 depth)))
          )
        )
      0
      )
    (actors-update *level*)
    (when *debug-segment*
      (let ((gp-8 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
        (when (and *dproc* *debug-segment*)
          (let* ((v1-226 (+ (-> gp-8 depth) -1))
                 (s5-6 (-> gp-8 segment v1-226))
                 (s4-5 (-> gp-8 base-time))
                 )
            (when (>= v1-226 0)
              (set! (-> s5-6 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-5))))
              (+! (-> gp-8 depth) -1)
              )
            )
          )
        )
      0
      )
    (when *debug-segment*
      (let ((gp-9 (-> *display* frames (-> *display* on-screen) profile-array data 0))
            (v1-239 'nav)
            (s5-7 *profile-nav-color*)
            )
        (when (and *dproc* *debug-segment*)
          (let ((s4-6 (-> gp-9 data (-> gp-9 count))))
            (let ((s3-4 (-> gp-9 base-time)))
              (set! (-> s4-6 name) v1-239)
              (set! (-> s4-6 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-4))))
              )
            (set! (-> s4-6 depth) (the-as uint (-> gp-9 depth)))
            (set! (-> s4-6 color) s5-7)
            (set! (-> gp-9 segment (-> gp-9 depth)) s4-6)
            )
          (set! (-> gp-9 count) (min 1023 (+ (-> gp-9 count) 1)))
          (+! (-> gp-9 depth) 1)
          (set! (-> gp-9 max-depth) (max (-> gp-9 max-depth) (-> gp-9 depth)))
          )
        )
      0
      )
    (update-nav-meshes-method *level*)
    (when *debug-segment*
      (let ((gp-10 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
        (when (and *dproc* *debug-segment*)
          (let* ((v1-265 (+ (-> gp-10 depth) -1))
                 (s5-8 (-> gp-10 segment v1-265))
                 (s4-7 (-> gp-10 base-time))
                 )
            (when (>= v1-265 0)
              (set! (-> s5-8 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-7))))
              (+! (-> gp-10 depth) -1)
              )
            )
          )
        )
      0
      )
    (when *debug-segment*
      (let ((gp-11 (-> *display* frames (-> *display* on-screen) profile-array data 0))
            (v1-278 'background)
            (s5-9 *profile-background-color*)
            )
        (when (and *dproc* *debug-segment*)
          (let ((s4-8 (-> gp-11 data (-> gp-11 count))))
            (let ((s3-5 (-> gp-11 base-time)))
              (set! (-> s4-8 name) v1-278)
              (set! (-> s4-8 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-5))))
              )
            (set! (-> s4-8 depth) (the-as uint (-> gp-11 depth)))
            (set! (-> s4-8 color) s5-9)
            (set! (-> gp-11 segment (-> gp-11 depth)) s4-8)
            )
          (set! (-> gp-11 count) (min 1023 (+ (-> gp-11 count) 1)))
          (+! (-> gp-11 depth) 1)
          (set! (-> gp-11 max-depth) (max (-> gp-11 max-depth) (-> gp-11 depth)))
          )
        )
      0
      )
    (init-background)
    (execute-connections *background-draw-engine* #f)
    (let* ((v1-294 (-> *perf-stats* data 40))
           (a0-113 (-> v1-294 ctrl))
           )
      (+! (-> v1-294 count) 1)
      (b! (zero? a0-113) cfg-122 :delay (nop!))
      (.mtc0 Perf 0)
      (.sync.l)
      (.sync.p)
      (.mtpc pcr0 0)
      (.mtpc pcr1 0)
      (.sync.l)
      (.sync.p)
      (.mtc0 Perf a0-113)
      )
    (.sync.l)
    (.sync.p)
    (label cfg-122)
    0
    (finish-background)
    (let ((v1-297 (-> *perf-stats* data 40)))
      (b! (zero? (-> v1-297 ctrl)) cfg-124 :delay (nop!))
      (.mtc0 Perf 0)
      (.sync.l)
      (.sync.p)
      (.mfpc a0-115 pcr0)
      (+! (-> v1-297 accum0) a0-115)
      (.mfpc a0-117 pcr1)
      (+! (-> v1-297 accum1) a0-117)
      )
    (label cfg-124)
    0
    (update-wait-stats
      (-> *perf-stats* data 40)
      (-> *background-work* wait-to-vu0)
      (the-as uint 0)
      (the-as uint 0)
      )
    (when *debug-segment*
      (let ((gp-12 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
        (when (and *dproc* *debug-segment*)
          (let* ((v1-314 (+ (-> gp-12 depth) -1))
                 (s5-10 (-> gp-12 segment v1-314))
                 (s4-9 (-> gp-12 base-time))
                 )
            (when (>= v1-314 0)
              (set! (-> s5-10 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-9))))
              (+! (-> gp-12 depth) -1)
              )
            )
          )
        )
      0
      )
    (end-perf-stat-collection)
    (when (and (!= *master-mode* 'menu) *stats-poly*)
      (dotimes (gp-13 (-> *level* length))
        (let ((v1-326 (-> *level* level gp-13)))
          (if (= (-> v1-326 status) 'active)
              (collect-stats (-> v1-326 bsp))
              )
          )
        )
      (print-terrain-stats)
      )
    (when (not (paused?))
      (if (and (!= *master-mode* 'menu) *stats-perf*)
          (print-perf-stats)
          )
      (if (and (!= *master-mode* 'menu) *stats-collide*)
          (print-collide-stats)
          )
      )
    (start-perf-stat-collection)
    0
    (none)
    )
  )

;; definition for function main-draw-hook
(defun main-draw-hook ()
  "Wrapper of real-main-draw-hook"
  (real-main-draw-hook)
  (none)
  )

;; definition for symbol *draw-hook*, type (function none)
(define *draw-hook* main-draw-hook)

;; definition for function default-init-buffer
;; WARN: Return type mismatch symbol vs none.
(defun default-init-buffer ((arg0 bucket-id) (arg1 gs-zbuf) (arg2 gs-test))
  "Initialize DMA chain for a bucket."
  (let ((v1-0 *display*)
        (t0-0 16)
        )
    (+! (-> v1-0 mem-reserve-size) t0-0)
    (when (not (-> v1-0 dma-buffer-overflow))
      (let ((t1-0 (-> v1-0 frames (-> v1-0 on-screen) global-buf)))
        (if (< (-> t1-0 real-buffer-end) (the-as int (&+ (-> t1-0 base) t0-0)))
            (set! (-> v1-0 dma-buffer-overflow) #t)
            )
        )
      (when (not (-> v1-0 dma-buffer-overflow))
        (let ((v1-8 (-> *display* frames (-> *display* on-screen) bucket-group arg0)))
          (when (!= v1-8 (-> v1-8 last))
            (let* ((a0-8 (-> *display* frames (-> *display* on-screen) global-buf))
                   (a3-15 (-> a0-8 base))
                   )
              (let ((t0-2 *display*)
                    (t1-2 176)
                    )
                (+! (-> t0-2 mem-reserve-size) t1-2)
                (when (not (-> t0-2 dma-buffer-overflow))
                  (let ((t3-0 (-> t0-2 frames (-> t0-2 on-screen) global-buf)))
                    (if (< (-> t3-0 real-buffer-end) (the-as int (&+ (-> t3-0 base) t1-2)))
                        (set! (-> t0-2 dma-buffer-overflow) #t)
                        )
                    )
                  (if (not (-> t0-2 dma-buffer-overflow))
                      (dma-buffer-add-gs-set-flusha a0-8
                                                    (zbuf-1 arg1)
                                                    (test-1 arg2)
                                                    (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1))
                                                    (pabe 0)
                                                    (clamp-1 (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp)))
                                                    (tex1-1 (new 'static 'gs-tex1 :mmag #x1 :mmin #x1))
                                                    (texa (new 'static 'gs-texa :ta1 #x80))
                                                    (texclut (new 'static 'gs-texclut :cbw #x4))
                                                    (fogcol *fog-color*)
                                                    )
                      )
                  )
                )
              (let ((a1-17 (the-as dma-packet (-> a0-8 base))))
                (set! (-> a1-17 dma) (new 'static 'dma-tag :id (dma-tag-id next) :addr (-> v1-8 next)))
                (set! (-> a1-17 vif0) (new 'static 'vif-tag))
                (set! (-> a1-17 vif1) (new 'static 'vif-tag))
                (set! (-> a0-8 base) (the-as pointer (&+ a1-17 16)))
                )
              (set! (-> v1-8 next) (the-as uint a3-15))
              )
            )
          )
        )
      )
    )
  (none)
  )

;; definition for function default-end-buffer
;; WARN: Return type mismatch symbol vs none.
(defun default-end-buffer ((arg0 bucket-id) (arg1 gs-zbuf) (arg2 gs-test))
  "Add DMA data at the end of a bucket to reset settings."
  (let ((v1-0 *display*)
        (a3-0 16)
        )
    (+! (-> v1-0 mem-reserve-size) a3-0)
    (when (not (-> v1-0 dma-buffer-overflow))
      (let ((t1-0 (-> v1-0 frames (-> v1-0 on-screen) global-buf)))
        (if (< (-> t1-0 real-buffer-end) (the-as int (&+ (-> t1-0 base) a3-0)))
            (set! (-> v1-0 dma-buffer-overflow) #t)
            )
        )
      (when (not (-> v1-0 dma-buffer-overflow))
        (let ((v1-8 (-> *display* frames (-> *display* on-screen) bucket-group arg0)))
          (when (!= v1-8 (-> v1-8 last))
            (let* ((a3-6 (-> *display* frames (-> *display* on-screen) global-buf))
                   (a0-8 (-> a3-6 base))
                   )
              (let ((t0-11 *display*)
                    (t1-2 176)
                    )
                (+! (-> t0-11 mem-reserve-size) t1-2)
                (when (not (-> t0-11 dma-buffer-overflow))
                  (let ((t3-0 (-> t0-11 frames (-> t0-11 on-screen) global-buf)))
                    (if (< (-> t3-0 real-buffer-end) (the-as int (&+ (-> t3-0 base) t1-2)))
                        (set! (-> t0-11 dma-buffer-overflow) #t)
                        )
                    )
                  (if (not (-> t0-11 dma-buffer-overflow))
                      (dma-buffer-add-gs-set-flusha a3-6
                                                    (zbuf-1 arg1)
                                                    (test-1 arg2)
                                                    (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1))
                                                    (pabe 0)
                                                    (clamp-1 (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp)))
                                                    (tex1-1 (new 'static 'gs-tex1 :mmag #x1 :mmin #x1))
                                                    (texa (new 'static 'gs-texa :ta1 #x80))
                                                    (texclut (new 'static 'gs-texclut :cbw #x4))
                                                    (fogcol *fog-color*)
                                                    )
                      )
                  )
                )
              (let ((t0-16 (-> a3-6 base)))
                (let ((a1-17 (the-as dma-packet (-> a3-6 base))))
                  (set! (-> a1-17 dma) (new 'static 'dma-tag :id (dma-tag-id next)))
                  (set! (-> a1-17 vif0) (new 'static 'vif-tag))
                  (set! (-> a1-17 vif1) (new 'static 'vif-tag))
                  (set! (-> a3-6 base) (the-as pointer (&+ a1-17 16)))
                  )
                (set! (-> (the-as (pointer uint32) (-> v1-8 last)) 1) (the-as uint a0-8))
                (set! (-> v1-8 last) (the-as (pointer dma-tag) t0-16))
                )
              )
            )
          )
        )
      )
    )
  (none)
  )

;; definition (debug) for function screen-shot-scale
;; WARN: Return type mismatch int vs none.
(defun-debug screen-shot-scale ((arg0 int) (arg1 string))
  (set! (-> *screen-shot-work* size) arg0)
  (set! (-> *screen-shot-work* name) arg1)
  (set! *display-profile* #f)
  0
  (none)
  )

;; definition (debug) for function screen-shot
;; WARN: Return type mismatch int vs none.
(defun-debug screen-shot ()
  "Take a screenshot."
  (screen-shot-scale 1 "image")
  0
  (none)
  )

;; definition for function display-frame-start
;; WARN: Return type mismatch display vs none.
(defun display-frame-start ((arg0 display) (arg1 int) (arg2 float))
  "Advance clocks, poll pads/mouse, set up buckets."
  (set! (-> (the-as vif-bank #x10003c00) err me0) 1)
  (set-time-ratios *display* 1.0)
  (tick! (-> arg0 frame-clock))
  (tick! (-> arg0 real-frame-clock))
  (set-time-ratios *display* arg2)
  (tick! (-> arg0 session-clock))
  (tick! (-> arg0 game-clock))
  (tick! (-> arg0 total-game-clock))
  (tick! (-> arg0 base-clock))
  (tick! (-> arg0 real-clock))
  (tick! (-> arg0 target-clock))
  (tick! (-> arg0 camera-clock))
  (tick! (-> arg0 entity-clock))
  (tick! (-> arg0 bg-clock))
  (tick! (-> arg0 user0-clock))
  (tick! (-> arg0 user1-clock))
  (tick! (-> arg0 user2-clock))
  (tick! (-> arg0 user3-clock))
  (tick! (-> arg0 user4-clock))
  (tick! (-> arg0 user5-clock))
  (tick! (-> arg0 user6-clock))
  (tick! (-> arg0 user7-clock))
  (tick! (-> arg0 user8-clock))
  (tick! (-> arg0 user9-clock))
  (set! (-> arg0 bg-clock frame-counter) (the-as time-frame (mod (-> arg0 bg-clock frame-counter) #x69780)))
  (tick! (-> arg0 part-clock))
  (when (and (nonzero? *screen-shot-work*) (!= (-> *screen-shot-work* count) -1))
    (let ((v1-61 (-> *screen-shot-work* size)))
      (if (!= (-> *screen-shot-work* count) (* v1-61 v1-61))
          (store-image *screen-shot-work*)
          )
      )
    (+! (-> *screen-shot-work* count) -1)
    (if (= (-> *screen-shot-work* count) -1)
        (set! (-> *screen-shot-work* size) -1)
        )
    )
  (let ((s5-1 (-> arg0 frames arg1)))
    (if *sync-dma*
        (sync-path 0 0)
        )
    (let ((v1-75 (-> s5-1 global-buf)))
      (set! (-> v1-75 base) (-> v1-75 data))
      (set! (-> v1-75 end) (the-as pointer (+ (+ (-> v1-75 allocated-length) 28) (the-as int v1-75))))
      )
    (when *debug-segment*
      (let ((v1-78 (-> s5-1 debug-buf)))
        (set! (-> v1-78 base) (-> v1-78 data))
        (set! (-> v1-78 end) (the-as pointer (+ (+ (-> v1-78 allocated-length) 28) (the-as int v1-78))))
        )
      )
    (let ((v1-79 (-> s5-1 calc-buf)))
      (set! (-> v1-79 base) (-> v1-79 data))
      (set! (-> v1-79 end) (the-as pointer (+ (+ (-> v1-79 allocated-length) 28) (the-as int v1-79))))
      )
    (*pre-draw-hook* (-> s5-1 calc-buf))
    (when (not (paused?))
      (clear *stdcon1*)
      (debug-reset-buffers)
      (clear! *simple-sprite-system*)
      )
    (set! (-> s5-1 bucket-group) (dma-buffer-add-buckets (-> s5-1 calc-buf) 586))
    )
  (service-cpads)
  (service-mouse)
  (service-keybd)
  (execute-connections *pad-engine* #f)
  (none)
  )

;; definition for function display-frame-finish
(defun display-frame-finish ((arg0 display))
  "Do final texture remaps, sync DMA (wait for previous rendering to finish), and finalize DMA chain."
  (local-vars (a0-54 int) (a0-56 int))
  (with-pp
    (let* ((s4-0 (-> arg0 frames (-> arg0 on-screen)))
           (s5-0 (-> s4-0 calc-buf))
           )
      (-> s4-0 global-buf base)
      (tfrag-vu1-init-buffers)
      (tie-vu1-init-buffers)
      (merc-vu1-init-buffers)
      (emerc-vu1-init-buffers)
      (generic-vu1-init-buffers)
      (when *debug-segment*
        (let ((s3-0 (-> *display* frames (-> *display* on-screen) profile-array data 0))
              (v1-12 'texture)
              (s2-0 *profile-texture-color*)
              )
          (when (and *dproc* *debug-segment*)
            (let ((s1-0 (-> s3-0 data (-> s3-0 count))))
              (let ((s0-0 (-> s3-0 base-time)))
                (set! (-> s1-0 name) v1-12)
                (set! (-> s1-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s0-0))))
                )
              (set! (-> s1-0 depth) (the-as uint (-> s3-0 depth)))
              (set! (-> s1-0 color) s2-0)
              (set! (-> s3-0 segment (-> s3-0 depth)) s1-0)
              )
            (set! (-> s3-0 count) (min 1023 (+ (-> s3-0 count) 1)))
            (+! (-> s3-0 depth) 1)
            (set! (-> s3-0 max-depth) (max (-> s3-0 max-depth) (-> s3-0 depth)))
            )
          )
        0
        )
      (when (-> *texture-pool* update-sprites-flag)
        (update-sprites *texture-pool*)
        (particle-adgif-cache-flush)
        (remap-all-particles)
        )
      (let ((s3-1 (-> pp clock)))
        (if (= (-> *time-of-day-context* mode) (time-of-day-palette-id unk3))
            (set! (-> pp clock) (-> arg0 bg-clock))
            (set! (-> pp clock) (-> arg0 real-clock))
            )
        (upload-textures *texture-pool*)
        (set! (-> pp clock) s3-1)
        )
      (if (-> *texture-pool* update-flag)
          (update-warp-and-hud *texture-pool*)
          )
      (-> arg0 frames (-> arg0 on-screen) global-buf)
      (update-eyes)
      (when *debug-segment*
        (let ((s3-2 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
          (when (and *dproc* *debug-segment*)
            (let* ((v1-56 (+ (-> s3-2 depth) -1))
                   (s2-1 (-> s3-2 segment v1-56))
                   (s1-1 (-> s3-2 base-time))
                   )
              (when (>= v1-56 0)
                (set! (-> s2-1 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s1-1))))
                (+! (-> s3-2 depth) -1)
                )
              )
            )
          )
        0
        )
      (when *debug-segment*
        (when *debug-segment*
          (let ((s3-3 (-> *display* frames (-> *display* on-screen) profile-array data 0))
                (v1-71 'debug)
                (s2-2 *profile-debug-color*)
                )
            (when (and *dproc* *debug-segment*)
              (let ((s1-2 (-> s3-3 data (-> s3-3 count))))
                (let ((s0-1 (-> s3-3 base-time)))
                  (set! (-> s1-2 name) v1-71)
                  (set! (-> s1-2 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s0-1))))
                  )
                (set! (-> s1-2 depth) (the-as uint (-> s3-3 depth)))
                (set! (-> s1-2 color) s2-2)
                (set! (-> s3-3 segment (-> s3-3 depth)) s1-2)
                )
              (set! (-> s3-3 count) (min 1023 (+ (-> s3-3 count) 1)))
              (+! (-> s3-3 depth) 1)
              (set! (-> s3-3 max-depth) (max (-> s3-3 max-depth) (-> s3-3 depth)))
              )
            )
          0
          )
        (debug-draw-buffers)
        (when *debug-segment*
          (let ((s3-4 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
            (when (and *dproc* *debug-segment*)
              (let* ((v1-95 (+ (-> s3-4 depth) -1))
                     (s2-3 (-> s3-4 segment v1-95))
                     (s1-3 (-> s3-4 base-time))
                     )
                (when (>= v1-95 0)
                  (set! (-> s2-3 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s1-3))))
                  (+! (-> s3-4 depth) -1)
                  )
                )
              )
            )
          0
          )
        (when *debug-segment*
          (let ((s3-5 (-> *display* frames (-> *display* on-screen) profile-array data 0))
                (v1-108 'gs-sync)
                (s2-4 *profile-gs-sync-color*)
                )
            (when (and *dproc* *debug-segment*)
              (let ((s1-4 (-> s3-5 data (-> s3-5 count))))
                (let ((s0-2 (-> s3-5 base-time)))
                  (set! (-> s1-4 name) v1-108)
                  (set! (-> s1-4 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s0-2))))
                  )
                (set! (-> s1-4 depth) (the-as uint (-> s3-5 depth)))
                (set! (-> s1-4 color) s2-4)
                (set! (-> s3-5 segment (-> s3-5 depth)) s1-4)
                )
              (set! (-> s3-5 count) (min 1023 (+ (-> s3-5 count) 1)))
              (+! (-> s3-5 depth) 1)
              (set! (-> s3-5 max-depth) (max (-> s3-5 max-depth) (-> s3-5 depth)))
              )
            )
          0
          )
        (when (nonzero? (sync-path 0 0))
          (*dma-timeout-hook*)
          (reset-vif1-path)
          (nop!)
          (nop!)
          0
          )
        (when *debug-segment*
          (let ((s3-6 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
            (when (and *dproc* *debug-segment*)
              (let* ((v1-134 (+ (-> s3-6 depth) -1))
                     (s2-5 (-> s3-6 segment v1-134))
                     (s1-5 (-> s3-6 base-time))
                     )
                (when (>= v1-134 0)
                  (set! (-> s2-5 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s1-5))))
                  (+! (-> s3-6 depth) -1)
                  )
                )
              )
            )
          0
          )
        (let ((s3-7 (-> arg0 frames (-> arg0 on-screen) profile-array data 0)))
          (when (and *dproc* *debug-segment*)
            (let* ((v1-148 (+ (-> s3-7 depth) -1))
                   (s2-6 (-> s3-7 segment v1-148))
                   (s1-6 (-> s3-7 base-time))
                   )
              (when (>= v1-148 0)
                (set! (-> s2-6 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s1-6))))
                (+! (-> s3-7 depth) -1)
                )
              )
            )
          )
        0
        (let ((v1-155 (-> *perf-stats* data)))
          (b! (zero? (-> v1-155 0 ctrl)) cfg-63 :delay (nop!))
          (.mtc0 Perf 0)
          (.sync.l)
          (.sync.p)
          (.mfpc a0-54 pcr0)
          (+! (-> v1-155 0 accum0) a0-54)
          (.mfpc a0-56 pcr1)
          (+! (-> v1-155 0 accum1) a0-56)
          )
        (label cfg-63)
        0
        (with-dma-buffer-add-bucket ((s2-7 (-> arg0 frames (-> arg0 on-screen) debug-buf))
                                     (bucket-id debug-no-zbuf2)
                                     )
          (when (and (or *display-profile* *stats-profile-bars*) (not *display-capture-mode*))
            (postprocess-data! (-> arg0 frames (-> arg0 on-screen) profile-array))
            (let ((a2-0 7))
              (if *display-profile*
                  (draw-bars! *profile-array* s2-7 a2-0)
                  )
              )
            (if (and (!= *master-mode* 'menu) *stats-profile-bars*)
                (draw-text! *profile-array*)
                )
            )
          (when *display-deci-count*
            (let ((s1-7 draw-string-xy))
              (format (clear *temp-string*) "~D" *deci-count*)
              (s1-7 *temp-string* s2-7 448 210 (font-color default) (font-flags shadow kerning))
              )
            )
          (display-file-info)
          )
        )
      (let ((s3-9 6)
            (s2-8 583)
            )
        (while (>= s2-8 s3-9)
          (default-end-buffer
            (the-as bucket-id s3-9)
            (new 'static 'gs-zbuf :zbp #x130 :psm (gs-psm ct24))
            (new 'static 'gs-test :zte #x1 :ztst (gs-ztest greater-equal))
            )
          (+! s3-9 1)
          )
        )
      (default-init-buffer
        (bucket-id debug-no-zbuf1)
        (new 'static 'gs-zbuf :zbp #x130 :psm (gs-psm ct24) :zmsk #x1)
        (new 'static 'gs-test :zte #x1 :ztst (gs-ztest always))
        )
      (default-init-buffer
        (bucket-id debug-no-zbuf2)
        (new 'static 'gs-zbuf :zbp #x130 :psm (gs-psm ct24) :zmsk #x1)
        (new 'static 'gs-test :zte #x1 :ztst (gs-ztest always))
        )
      (default-init-buffer
        (bucket-id tex-hud-pris2)
        (new 'static 'gs-zbuf :zbp #x130 :psm (gs-psm ct24) :zmsk #x1)
        (new 'static 'gs-test :zte #x1 :ztst (gs-ztest always))
        )
      (default-init-buffer
        (bucket-id hfrag)
        (new 'static 'gs-zbuf :zbp #x130 :psm (gs-psm ct24))
        (new 'static 'gs-test :zte #x1 :ztst (gs-ztest always))
        )
      (*post-draw-hook* (-> arg0 frames (-> arg0 on-screen) calc-buf))
      (let ((v1-199 *display*)
            (a0-75 16)
            )
        (+! (-> v1-199 mem-reserve-size) a0-75)
        (when (not (-> v1-199 dma-buffer-overflow))
          (let ((a2-9 (-> v1-199 frames (-> v1-199 on-screen) global-buf)))
            (if (< (-> a2-9 real-buffer-end) (the-as int (&+ (-> a2-9 base) a0-75)))
                (set! (-> v1-199 dma-buffer-overflow) #t)
                )
            )
          (when (not (-> v1-199 dma-buffer-overflow))
            (let* ((v1-201 s5-0)
                   (a0-79 (the-as dma-packet (-> v1-201 base)))
                   )
              (set! (-> a0-79 dma) (new 'static 'dma-tag :id (dma-tag-id cnt)))
              (set! (-> a0-79 vif0) (new 'static 'vif-tag :imm #x24b :cmd (vif-cmd mark)))
              (set! (-> a0-79 vif1) (new 'static 'vif-tag :cmd (vif-cmd flushe) :irq #x1 :msk #x1))
              (set! (-> v1-201 base) (the-as pointer (&+ a0-79 16)))
              )
            )
          )
        )
      (dma-buffer-patch-buckets (the-as dma-bucket (-> s4-0 bucket-group)) 586)
      (let ((v1-202 *display*)
            (a0-81 16)
            )
        (+! (-> v1-202 mem-reserve-size) a0-81)
        (when (not (-> v1-202 dma-buffer-overflow))
          (let ((a2-11 (-> v1-202 frames (-> v1-202 on-screen) global-buf)))
            (if (< (-> a2-11 real-buffer-end) (the-as int (&+ (-> a2-11 base) a0-81)))
                (set! (-> v1-202 dma-buffer-overflow) #t)
                )
            )
          (when (not (-> v1-202 dma-buffer-overflow))
            (let* ((v1-204 s5-0)
                   (a0-85 (-> v1-204 base))
                   )
              (set! (-> (the-as (pointer int64) a0-85)) #x70000000)
              (set! (-> (the-as (pointer uint64) a0-85) 1) (the-as uint 0))
              (set! (-> v1-204 base) (&+ a0-85 16))
              )
            )
          )
        )
      (flush-cache 0)
      (when (not (paused?))
        (when *stats-buffer*
          (let* ((a0-87 (-> s4-0 global-buf))
                 (v1-208 (-> s5-0 base))
                 (a2-13 (-> s5-0 data))
                 (s4-1 (-> a0-87 base))
                 (s5-1 (-> a0-87 data))
                 (s3-10 (-> a0-87 end))
                 )
            (format *stdcon* "~0kvu1 buf = ~d~%" (&- v1-208 (the-as uint a2-13)))
            (format *stdcon* "~0kglobal buf = ~d~%" (&- s4-1 (the-as uint s5-1)))
            (format *stdcon* "~0kbase = #x~x~%" s4-1)
            (format *stdcon* "~0kend = #x~x~%" s3-10)
            )
          )
        )
      )
    arg0
    )
  )

;; definition for function determine-pause-mode
;; WARN: Return type mismatch int vs none.
(defun determine-pause-mode ()
  "Update pause modes"
  (when (and (or (not *progress-process*) (can-go-back? (-> *progress-process* 0)))
             (or (!= *master-mode* 'freeze) (and *debug-segment* (cpad-pressed? 0 select start) (cpad-hold? 0 l3)))
             )
    (if (or (cpad-pressed? 0 select start)
            (cond
              ((= *master-mode* 'menu)
               (cpad-pressed? 0 r3 r2 triangle circle)
               )
              (*cam-layout*
                #f
                )
              (else
                #f
                )
              )
            (or (and (logtest? (-> *cpad-list* cpads 0 valid) 128)
                     (= *master-mode* 'game)
                     (>= (-> *display* base-clock frame-counter) (-> *game-info* blackout-time))
                     (= (-> *setting-control* user-current bg-a) 0.0)
                     (and (= (-> *setting-control* user-current bg-a-force) 0.0)
                          (< (seconds 1003) (-> *display* real-clock frame-counter))
                          )
                     )
                (and (cpad-pressed? 0 r2) (or (= *master-mode* 'pause) (= *master-mode* 'menu)))
                *pause-lock*
                )
            )
        (toggle-pause)
        )
    )
  (if (and *progress-process* (!= *master-mode* 'progress))
      (deactivate-progress)
      )
  0
  (none)
  )

;; definition for function calc-ratio
(defun calc-ratio ((arg0 int) (arg1 int))
  (let ((f0-1 (the float (sar (- arg0 arg1) 48))))
    (if (< f0-1 0.0)
        (set! f0-1 (+ 65536.0 f0-1))
        )
    (/ f0-1 (the float *ticks-per-frame*))
    )
  )

;; definition for function display-sync
(defun display-sync ((arg0 display))
  (sync-path 0 0)
  (let* ((s4-0 (-> arg0 last-screen))
         (s2-0 (shl (timer-count (the-as timer-bank #x10000800)) 48))
         (s5-0 (shl (-> arg0 frames s4-0 start-time) 48))
         (a1-1 (shl (-> arg0 vblank-start-time 0) 48))
         (s1-0 (shl (-> arg0 vblank-start-time 1) 48))
         )
    (set! *ticks-per-frame* (max 9000 (min #x2ee0 (sar (- s1-0 a1-1) 48))))
    (let ((f28-0 (the float *ticks-per-frame*))
          (s3-0 (sar (- s2-0 s5-0) 48))
          (f30-1 (fmax 1.0 (calc-ratio (the-as int s2-0) (the-as int s5-0))))
          )
      (/ (the float (sar (- s2-0 (the-as uint s1-0)) 48)) f28-0)
      (let ((f28-1 (/ (the float (sar (- s2-0 (the-as uint s1-0)) 48)) f28-0))
            (f26-0 (fmax 1.0 (fmin 4.0 (-> *display* dog-ratio))))
            )
        (if (< (the-as int s3-0) 0)
            (set! s3-0 (+ #x10000 s3-0))
            )
        (set! (-> arg0 frames s4-0 run-time) s3-0)
        (set! f30-1 (cond
                      ((-> arg0 run-half-speed)
                       (syncv 0)
                       (let ((a0-8 (shl (timer-count (the-as timer-bank #x10000800)) 48)))
                         (if (and (< (calc-ratio (the-as int a0-8) (the-as int s5-0)) 2.0) (< f28-1 0.9))
                             (syncv 0)
                             )
                         )
                       2.0
                       )
                      ((< 1.0 f30-1)
                       (when (> (-> arg0 force-sync) 0)
                         (syncv 0)
                         (+! (-> arg0 force-sync) -1)
                         (let ((a0-12 (shl (timer-count (the-as timer-bank #x10000800)) 48)))
                           (set! f30-1 (calc-ratio (the-as int a0-12) (the-as int s5-0)))
                           )
                         )
                       f30-1
                       )
                      ((and (= f30-1 1.0) (< f30-1 f26-0))
                       (while (< f30-1 f26-0)
                         (let ((a0-14 (shl (timer-count (the-as timer-bank #x10000800)) 48)))
                           (set! f30-1 (calc-ratio (the-as int a0-14) (the-as int s5-0)))
                           )
                         (if (< f30-1 0.0)
                             (set! f30-1 f26-0)
                             )
                         )
                       1.0
                       )
                      (else
                        (if (< f28-1 0.9)
                            (syncv 0)
                            )
                        f30-1
                        )
                      )
              )
        )
      (let ((s4-1 (-> arg0 on-screen)))
        (let ((v1-50 (timer-count (the-as timer-bank #x10000800))))
          (let ((a0-19 (sar (- (shl v1-50 48) s5-0) 48)))
            (if (< (the-as int a0-19) 0)
                (set! a0-19 (+ #x10000 a0-19))
                )
            (+! (-> arg0 total-run-time) a0-19)
            )
          (set! (-> arg0 frames s4-1 start-time) v1-50)
          )
        (set-graphics-mode)
        (let ((s5-1 (-> arg0 frames s4-1 calc-buf)))
          (when (nonzero? (dma-buffer-length s5-1))
            (+! s4-1 1)
            (if (< 1 s4-1)
                (set! s4-1 0)
                )
            (set! (-> arg0 last-screen) (-> arg0 on-screen))
            (set! (-> arg0 on-screen) s4-1)
            (when *debug-segment*
              (set! *profile-interrupt-segment* (-> *display* frames (-> *display* last-screen) profile-array data 1))
              (set! (-> *profile-interrupt-segment* depth) 0)
              (set! (-> *profile-interrupt-segment* max-depth) 1)
              )
            (if (not (-> *display* dma-buffer-overflow))
                (dma-buffer-send-chain (the-as dma-bank-source #x10009000) s5-1)
                )
            )
          )
        (determine-pause-mode)
        (when (and (nonzero? *screen-shot-work*) (= (-> *screen-shot-work* count) -1) (!= (-> *screen-shot-work* size) -1))
          (let ((v1-82 (-> *screen-shot-work* size)))
            (set! (-> *screen-shot-work* count) (* v1-82 v1-82))
            )
          (set-master-mode 'pause)
          )
        (display-frame-start arg0 s4-1 f30-1)
        )
      )
    )
  (none)
  )
