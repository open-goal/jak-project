;;-*-Lisp-*-
(in-package goal)

;; definition for function palette-select-special
;; INFO: Used lq/sq
(defun palette-select-special ((arg0 mood-context-core3))
  (dotimes (v1-0 8)
    (cond
      ((logtest? (-> *time-of-day-context* mode) (ash 16 v1-0))
       (if (-> *time-of-day-context* overide-enable)
           (set! (-> arg0 times v1-0 quad) (-> *time-of-day-context* times v1-0 quad))
           (set! (-> arg0 times v1-0 w) 1.0)
           )
       )
      (else
        (set! (-> arg0 times v1-0 w) 0.0)
        )
      )
    )
  #f
  )

;; definition for function clear-mood-times
(defun clear-mood-times ((mood-ctx mood-context))
  (dotimes (idx 8)
    (set! (-> mood-ctx times idx w) 0.0)
    )
  #f
  )

;; definition for function update-mood-itimes
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defun update-mood-itimes ((arg0 mood-context))
  (local-vars
    (v1-0 uint128)
    (v1-1 uint128)
    (v1-2 uint128)
    (v1-3 uint128)
    (a1-0 uint128)
    (a1-1 uint128)
    (a1-2 uint128)
    (a1-3 uint128)
    (a2-0 uint128)
    (a2-1 uint128)
    (a3-0 uint128)
    (a3-1 uint128)
    (t0-0 uint128)
    (t0-1 uint128)
    (t1-0 uint128)
    (t1-1 uint128)
    (t2-0 uint128)
    (t2-1 uint128)
    (t3-0 uint128)
    (t3-1 uint128)
    )
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         )
    (nop!)
    (nop!)
    (.lvf vf1 (&-> arg0 times 0 quad))
    (nop!)
    (.lvf vf2 (&-> arg0 times 1 quad))
    (.mul.w.vf vf1 vf1 vf1 :mask #b111)
    (.lvf vf3 (&-> arg0 times 2 quad))
    (.mul.w.vf vf2 vf2 vf2 :mask #b111)
    (.lvf vf4 (&-> arg0 times 3 quad))
    (.mul.w.vf vf3 vf3 vf3 :mask #b111)
    (.lvf vf5 (&-> arg0 times 4 quad))
    (.mul.w.vf vf4 vf4 vf4 :mask #b111)
    (.lvf vf6 (&-> arg0 times 5 quad))
    (.mul.w.vf vf5 vf5 vf5 :mask #b111)
    (.lvf vf7 (&-> arg0 times 6 quad))
    (.mul.w.vf vf6 vf6 vf6 :mask #b111)
    (.lvf vf8 (&-> arg0 times 7 quad))
    (.mul.w.vf vf7 vf7 vf7 :mask #b111)
    (nop!)
    (.mul.w.vf vf8 vf8 vf8 :mask #b111)
    (nop!)
    (vftoi12.xyzw vf1 vf1)
    (nop!)
    (vftoi12.xyzw vf2 vf2)
    (nop!)
    (vftoi12.xyzw vf3 vf3)
    (nop!)
    (vftoi12.xyzw vf4 vf4)
    (nop!)
    (vftoi12.xyzw vf5 vf5)
    (nop!)
    (vftoi12.xyzw vf6 vf6)
    (nop!)
    (vftoi12.xyzw vf7 vf7)
    (nop!)
    (vftoi12.xyzw vf8 vf8)
    (nop!)
    (.mov v1-0 vf1)
    (nop!)
    (.mov a1-0 vf2)
    (nop!)
    (.mov a2-0 vf3)
    (.pw.sra v1-1 v1-0 6)
    (.mov a3-0 vf4)
    (.pw.sra a1-1 a1-0 6)
    (.mov t0-0 vf5)
    (.pw.sra a2-1 a2-0 6)
    (.mov t1-0 vf6)
    (.pw.sra a3-1 a3-0 6)
    (.mov t2-0 vf7)
    (.pw.sra t0-1 t0-0 6)
    (.mov t3-0 vf8)
    (.pw.sra t1-1 t1-0 6)
    (.pw.sra t2-1 t2-0 6)
    (nop!)
    (.pw.sra t3-1 t3-0 6)
    (nop!)
    (.ppach v1-2 a1-1 v1-1)
    (nop!)
    (.ppach a1-2 a3-1 a2-1)
    (set! (-> arg0 itimes 0 quad) v1-2)
    (.ppach v1-3 t1-1 t0-1)
    (set! (-> arg0 itimes 1 quad) a1-2)
    (.ppach a1-3 t3-1 t2-1)
    (set! (-> arg0 itimes 2 quad) v1-3)
    (nop!)
    (set! (-> arg0 itimes 3 quad) a1-3)
    0
    (none)
    )
  )

;; definition for function update-mood-direction
;; INFO: Used lq/sq
;; ERROR: Expression building failed: In update-mood-direction: Failed to match non-power of two case: t3-14
(defun update-mood-direction ((arg0 mood-context-core3) (arg1 mood-table) (arg2 float))
  (local-vars
    (v0-0 pointer)
    (v0-1 float)
    (v1-0 mood-channel-group)
    (v1-3 int)
    (v1-4 float)
    (v1-5 float)
    (v1-6 float)
    (v1-7 symbol)
    (v1-8 symbol)
    (v1-9 float)
    (v1-12 float)
    (v1-13 symbol)
    (v1-14 symbol)
    (v1-15 float)
    (v1-17 float)
    (v1-19 float)
    (v1-20 symbol)
    (v1-21 symbol)
    (v1-22 float)
    (v1-24 float)
    (v1-26 light-group)
    (v1-27 light-group)
    (v1-28 light-group)
    (v1-29 light-group)
    (v1-30 light-group)
    (v1-31 light-group)
    (a0-1 light-group)
    (a1-1 int)
    (a1-2 float)
    (a1-3 (inline-array light-group))
    (a2-1 mood-direction-table)
    (a2-2 int)
    (a3-0 int)
    (t0-0 int)
    (t0-1 int)
    (t1-0 int)
    (t2-0 light-group)
    (t2-1 float)
    (t2-2 int)
    (t3-7 int)
    (t3-8 int)
    (t3-9 light)
    (t3-10 int)
    (t3-11 int)
    (t3-12 int)
    (t3-13 light-group)
    (t3-14 int)
    (t3-15 rgbaf)
    (t3-16 int)
    (t3-17 int)
    (t3-18 int)
    (t3-19 int)
    (t4-5 int)
    (t4-6 int)
    (t4-7 light)
    (t4-8 int)
    (t4-9 int)
    (t4-10 light)
    (t4-11 int)
    (t4-12 int)
    (t4-13 int)
    (t4-14 int)
    (t4-15 vector)
    (t4-16 uint128)
    (t4-17 int)
    (t4-18 int)
    (t4-19 int)
    (t4-20 int)
    (t4-21 int)
    (t4-22 vector)
    (t4-23 uint128)
    (t9-0 (function pointer pointer int pointer))
    (f0-0 float)
    (f0-1 int)
    (f0-2 float)
    (f0-3 float)
    (f0-4 float)
    (f0-5 float)
    (f1-0 int)
    (f1-1 float)
    (f1-2 float)
    (f1-3 float)
    (f1-4 float)
    (f1-5 float)
    (f1-6 float)
    (f1-7 float)
    (f1-8 float)
    (f1-9 float)
    (f1-10 float)
    (f1-11 float)
    (f1-12 float)
    (f1-13 float)
    (f2-0 float)
    (f2-1 float)
    (f2-2 float)
    (f2-3 float)
    (f2-6 float)
    (f2-7 float)
    (f2-8 float)
    (f2-9 float)
    (f2-10 float)
    (f2-11 float)
    (f2-12 float)
    (f2-13 float)
    (f2-14 float)
    (f2-15 float)
    (f2-16 float)
    (f3-3 float)
    (f3-4 float)
    (f3-5 float)
    (f3-6 float)
    (f3-7 float)
    (f3-8 float)
    (f3-9 float)
    (f3-10 float)
    (sv-16 light-group)
    )
  (cond
    ((begin
       (set! v1-0 (-> arg1 mood-channel-group))
       (set! a2-1 (-> arg1 mood-direction-table))
       (set! f0-0 arg2)
       (set! f0-1 (the int arg2))
       (set! a3-0 (the int arg2))
       (set! a1-1 (+ a3-0 1))
       (set! t0-0 24)
       (set! t0-1 (mod (+ a3-0 1) 24))
       (set! f0-2 arg2)
       (set! f1-0 (gpr->fpr a3-0))
       (set! f1-1 (the float a3-0))
       (set! f0-3 (- arg2 (the float a3-0)))
       (set! a1-2 1.0)
       (set! f1-2 1.0)
       (set! f1-3 (- 1.0 f0-3))
       (set! t1-0 0)
       (set! a1-3 (-> arg0 light-group))
       (set! t2-0 (-> arg0 light-group 1))
       (set! sv-16 t2-0)
       (set! t2-1 1.0)
       (set! f2-0 1.0)
       (set! (-> a1-3 0 ambi extra x) f2-0)
       (set! f2-1 0.0)
       (set! (-> a1-3 0 dir0 extra x) f2-1)
       (set! f2-2 0.0)
       (set! (-> a1-3 0 dir1 extra x) f2-2)
       (set! f2-3 0.0)
       (set! (-> a1-3 0 dir2 extra x) f2-3)
       (set! t2-2 0)
       (while (<.si t2-2 4)
         (when (!= f2-6 0.0)
           (set! t3-7 48)
           (set! t3-8 (* 48 t1-0))
           (set! t3-9 (-> a1-3 0 lights t1-0))
           (set! (-> a1-3 0 lights t1-0 extra x) f2-6)
           (set! t3-10 2)
           (set! t3-11 (ash 2 t2-2))
           (set! t4-5 48)
           (set! t4-6 (* 48 t1-0))
           (set! t4-7 (-> a1-3 0 lights t1-0))
           (set! (-> a1-3 0 lights t1-0 mask) (the-as uint t3-11))
           (set! t3-12 (+ t2-2 1))
           (set! t4-8 48)
           (set! t4-9 (* 48 t1-0))
           (set! t4-10 (-> a1-3 0 lights t1-0))
           (set! (-> a1-3 0 lights t1-0 palette-index) t3-12)
           (set! t3-13 (-> a1-3 0))
           (set! t4-11 48)
           (set! t4-12 (* 48 t1-0))
           (set! t3-14 (+ (the-as uint (-> a1-3 0)) (* 48 t1-0)))
           (set! t4-13 (* t2-2 16))
           (set! t4-14 (+ (* t2-2 16) 0))
           (set! t4-15 (-> a2-1 data t2-2))
           (set! t4-16 (-> a2-1 data t2-2 quad))
           (set! (dynamic-array-field-access t3-14 lights PLACEHOLDER direction quad) t4-16)
           (set! t3-15 (-> a1-3 0 dir0 color))
           (set! t4-17 48)
           (set! t4-18 (*.si t4-17 t1-0))
           (set! t3-16 (+ t3-15 t4-18))
           (set! t4-19 (+ t2-2 1))
           (set! t4-20 (sll t4-19 4))
           (set! t4-21 (+ t4-20 1648))
           (set! t4-22 (+ t4-21 arg0))
           (set! t4-23 (-> t4-22 quad))
           (set! (the-as (pointer uint128) (-> (the-as (pointer uint128) t3-16))) t4-23)
           (set! t3-17 (+ t2-2 1))
           (set! t3-18 (sll t3-17 4))
           (set! t3-19 (+ arg0 t3-18))
           (set! (dynamic-array-field-access t3-19 times PLACEHOLDER w) f2-6)
           (set! t1-0 (+ t1-0 1))
           (set! t3-20 t1-0)
           )
         (set! t2-2 (+ t2-2 1))
         )
       (set! v1-3 1)
       (set! (-> a1-3 0 ambi mask) (the-as uint v1-3))
       (set! (-> a1-3 0 ambi palette-index) 0)
       (set! t9-0 mem-copy!)
       (set! a0-1 sv-16)
       (set! a2-2 192)
       (call! a0-1 a1-3 a2-2)
       (set! v1-4 1.0)
       (set! f0-4 (gpr->fpr v1-4))
       (set! v1-5 1.1)
       (set! f1-4 (gpr->fpr v1-5))
       (set! v1-6 6.0)
       (set! f2-7 (gpr->fpr v1-6))
       (set! f3-3 (gpr->fpr arg2))
       (set! v1-7 (>=.s f2-7 f3-3))
       (or v1-7
           (begin (set! f2-8 (gpr->fpr arg2)) (set! v1-9 18.0) (set! f3-4 (gpr->fpr v1-9)) (set! v1-8 (>=.s f2-8 f3-4)))
           )
       v1-8
       )
     (set! f0-4 f1-4)
     (set! v1-11 (fpr->gpr f0-4))
     )
    ((begin
       (and (begin
              (set! v1-12 6.0)
              (set! f2-9 (gpr->fpr v1-12))
              (set! f3-5 (gpr->fpr arg2))
              (set! v1-13 (<.s f2-9 f3-5))
              v1-13
              )
            (begin
              (set! f2-10 (gpr->fpr arg2))
              (set! v1-15 7.0)
              (set! f3-6 (gpr->fpr v1-15))
              (set! v1-14 (<.s f2-10 f3-6))
              )
            )
       v1-14
       )
     (set! f1-5 (-.s f1-4 f0-4))
     (set! v1-17 7.0)
     (set! f2-11 (gpr->fpr v1-17))
     (set! f3-7 (gpr->fpr arg2))
     (set! f2-12 (-.s f2-11 f3-7))
     (set! f1-6 (*.s f1-5 f2-12))
     (set! f0-4 (+.s f0-4 f1-6))
     (set! v1-18 (fpr->gpr f0-4))
     )
    ((begin
       (and (begin
              (set! v1-19 17.0)
              (set! f2-13 (gpr->fpr v1-19))
              (set! f3-8 (gpr->fpr arg2))
              (set! v1-20 (<.s f2-13 f3-8))
              v1-20
              )
            (begin
              (set! f2-14 (gpr->fpr arg2))
              (set! v1-22 18.0)
              (set! f3-9 (gpr->fpr v1-22))
              (set! v1-21 (<.s f2-14 f3-9))
              )
            )
       v1-21
       )
     (set! f1-7 (-.s f1-4 f0-4))
     (set! v1-24 -17.0)
     (set! f2-15 (gpr->fpr v1-24))
     (set! f3-10 (gpr->fpr arg2))
     (set! f2-16 (+.s f2-15 f3-10))
     (set! f1-8 (*.s f1-7 f2-16))
     (set! f0-4 (+.s f0-4 f1-8))
     (set! v1-25 (fpr->gpr f0-4))
     )
    )
  (set! v1-26 sv-16)
  (set! f1-9 (-> v1-26 dir0 extra x))
  (set! f1-10 (*.s f1-9 f0-4))
  (set! v1-27 sv-16)
  (set! (-> v1-27 dir0 extra x) f1-10)
  (set! v1-28 sv-16)
  (set! f1-11 (-> v1-28 dir1 extra x))
  (set! f1-12 (*.s f1-11 f0-4))
  (set! v1-29 sv-16)
  (set! (-> v1-29 dir1 extra x) f1-12)
  (set! v1-30 sv-16)
  (set! f1-13 (-> v1-30 dir2 extra x))
  (set! f0-5 (*.s f1-13 f0-4))
  (set! v1-31 sv-16)
  (set! (-> v1-31 dir2 extra x) f0-5)
  (set! v0-1 (fpr->gpr f0-5))
  (ret-value v0-1)
  )

;; definition for function update-mood-exterior
;; INFO: Used lq/sq
(defun update-mood-exterior ((arg0 mood-context-core3) (arg1 mood-table) (arg2 float) (arg3 int))
  (local-vars (v0-1 object) (sv-32 mood-color) (sv-48 mood-color) (sv-64 vector))
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      0
      0
      0.0
      (let* ((v1-3 (the int arg2))
             (f0-4 (- arg2 (the float v1-3)))
             (f1-3 (- 1.0 f0-4))
             (a0-6 (/ v1-3 24))
             (v1-7 (-> arg1 mood-interp-table hour (- v1-3 (* 24 a0-6))))
             (s3-0 (-> v1-7 snapshot1))
             (s2-0 (-> v1-7 snapshot2))
             (f30-0 (+ (* f1-3 (-> v1-7 morph-start)) (* f0-4 (-> v1-7 morph-end))))
             )
        (set! v0-1
              (cond
                ((and (-> *level* level arg3 bsp)
                      (nonzero? (-> *level* level arg3 bsp))
                      (not (-> *level* level arg3 bsp ambients))
                      )
                 (set! v0-1 (-> arg0 times))
                 (set! (-> (the-as (inline-array vector) v0-1) 0 x) 1.0)
                 (set! (-> (the-as (inline-array vector) v0-1) 0 y) 1.0)
                 (set! (-> (the-as (inline-array vector) v0-1) 0 z) 1.0)
                 (set! (-> (the-as (inline-array vector) v0-1) 0 w) 1.0)
                 v0-1
                 )
                ((= s3-0 s2-0)
                 (let ((a2-1 (-> arg1 mood-color-table data s3-0))
                       (v1-26 (-> arg0 times))
                       (a1-2 (-> arg0 times 1))
                       (a0-16 (-> arg0 light-group))
                       )
                   (set! (-> v1-26 0 quad) (-> a2-1 amb-color quad))
                   (set! (-> a1-2 quad) (-> a2-1 lgt-color quad))
                   (set! (-> arg0 times 2 quad) (-> a1-2 quad))
                   (set! (-> arg0 times 3 quad) (-> a1-2 quad))
                   (set! (-> arg0 times 4 quad) (-> a1-2 quad))
                   (set! (-> a0-16 0 ambi color quad) (-> v1-26 0 quad))
                   )
                 (set! (-> arg0 current-sky-color quad) (-> arg1 mood-sky-table data s3-0 quad))
                 (mem-copy! (the-as pointer (-> arg0 current-fog)) (the-as pointer (-> arg1 mood-fog-table data s3-0)) 48)
                 )
                (else
                  (set! sv-32 (-> arg1 mood-color-table data s3-0))
                  (set! sv-48 (-> arg1 mood-color-table data s2-0))
                  (let ((s1-0 (-> arg0 times)))
                    (set! sv-64 (-> arg0 times 1))
                    (let ((s0-0 (-> arg0 light-group)))
                      (vector4-lerp! (the-as vector s1-0) (-> sv-32 amb-color) (-> sv-48 amb-color) f30-0)
                      (vector4-lerp! sv-64 (-> sv-32 lgt-color) (-> sv-48 lgt-color) f30-0)
                      (set! (-> arg0 times 2 quad) (-> sv-64 quad))
                      (set! (-> arg0 times 3 quad) (-> sv-64 quad))
                      (set! (-> arg0 times 4 quad) (-> sv-64 quad))
                      (set! (-> s0-0 0 ambi color quad) (-> s1-0 0 quad))
                      )
                    )
                  (vector4-lerp!
                    (-> arg0 current-sky-color)
                    (-> arg1 mood-sky-table data s3-0)
                    (-> arg1 mood-sky-table data s2-0)
                    f30-0
                    )
                  (vector4-array-lerp!
                    (the-as (inline-array vector4) (-> arg0 current-fog))
                    (the-as (inline-array vector4) (-> arg1 mood-fog-table data s3-0))
                    (the-as (inline-array vector4) (-> arg1 mood-fog-table data s2-0))
                    f30-0
                    3
                    )
                  )
                )
              )
        )
      (set-vector! (-> arg0 current-prt-color) 0.0 0.0 0.0 0.0)
      (set-vector! (-> arg0 current-env-color) 0.0 0.0 0.0 0.0)
      (let ((f0-18 (-> *mood-control* lightning-flash))
            (a0-36 (-> *mood-control* lightning-index))
            )
        (when (and (!= f0-18 0.0) (< a0-36 4))
          (let ((v1-64 (new 'stack-no-clear 'vector))
                (a0-40 (-> arg0 times (+ a0-36 1)))
                )
            (set-vector! v1-64 f0-18 f0-18 f0-18 0.0)
            (vector+! a0-40 a0-40 v1-64)
            )
          )
        )
      (update-mood-direction arg0 arg1 arg2)
      )
    )
  )

;; definition for function copy-mood-exterior
;; INFO: Used lq/sq
(defun copy-mood-exterior ((arg0 mood-context))
  (set! (-> *time-of-day-context* exterior-level) (the-as basic #t))
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (let ((v1-2 (the-as object arg0))
            (a1-4 (the-as structure (-> *level* level-default mood-context)))
            )
        (dotimes (a2-1 31)
          (set! (-> (the-as (inline-array vector) v1-2) 0 quad)
                (-> (the-as mood-context a1-4) current-fog fog-color quad)
                )
          (set! v1-2 (-> (the-as (inline-array vector) v1-2) 1))
          (set! a1-4 (-> (the-as mood-context a1-4) current-fog fog-dists))
          )
        )
      (let ((v1-5 (the-as object (-> arg0 times)))
            (a0-2 (the-as object (-> *level* level-default mood-context times)))
            )
        (dotimes (a1-6 5)
          (set! (-> (the-as (inline-array vector) v1-5) 0 quad) (-> (the-as (inline-array vector) a0-2) 0 quad))
          (set! v1-5 (-> (the-as (inline-array vector) v1-5) 1))
          (set! a0-2 (-> (the-as (inline-array vector) a0-2) 1))
          )
        )
      #f
      )
    )
  )

;; definition for function copy-mood-exterior-ambi
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defun copy-mood-exterior-ambi ((arg0 mood-context) (arg1 symbol))
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (let ((v1-1 (the-as structure arg0))
            (a2-3 (the-as structure (-> *level* level-default mood-context)))
            )
        (dotimes (a3-1 31)
          (set! (-> (the-as mood-context v1-1) current-fog fog-color quad)
                (-> (the-as mood-context a2-3) current-fog fog-color quad)
                )
          (set! v1-1 (-> (the-as mood-context v1-1) current-fog fog-dists))
          (set! a2-3 (-> (the-as mood-context a2-3) current-fog fog-dists))
          )
        )
      (set! (-> arg0 times 0 quad) (-> *level* level-default mood-context times 0 quad))
      (vector+!
        (the-as vector (-> arg0 times))
        (the-as vector (-> arg0 times))
        (-> *level* level-default mood-context times 1)
        )
      (when arg1
        (set! (-> arg0 times 1 quad) (-> *level* level-default mood-context times 1 quad))
        (set! (-> arg0 times 1 w) 1.0)
        )
      )
    )
  (none)
  )

;; definition for function clear-mood-context
;; INFO: Used lq/sq
(defun clear-mood-context ((arg0 mood-context))
  (let ((v1-0 arg0))
    (dotimes (a1-0 123)
      (set! (-> v1-0 data a1-0) (the-as uint128 0))
      )
    )
  (dotimes (v1-3 8)
    (set-vector! (-> arg0 times v1-3) 1.0 1.0 1.0 0.0)
    )
  #f
  )

;; definition for function update-mood-interior
;; INFO: Used lq/sq
(defun update-mood-interior ((arg0 mood-context) (arg1 symbol))
  (let ((v1-0 (-> arg0 light-group)))
    (cond
      (arg1
        (set! (-> arg0 current-fog fog-color quad) (-> *level* level-default mood-context current-fog fog-color quad))
        (set-vector! (-> arg0 current-fog fog-dists) 98304.0 3072000.0 255.0 150.0)
        (set-vector! (-> arg0 current-fog erase-color) 0.0 0.0 0.0 128.0)
        )
      (else
        (let ((a1-4 (-> arg0 current-fog)))
          (set! (-> a1-4 fog-color x) 150.0)
          (set! (-> a1-4 fog-color y) 165.0)
          (set! (-> a1-4 fog-color z) 220.0)
          (set! (-> a1-4 fog-color w) 128.0)
          )
        (set-vector! (-> arg0 current-fog fog-dists) 2048000.0 12288000.0 255.0 150.0)
        (set-vector! (-> arg0 current-fog erase-color) 0.0 0.0 0.0 128.0)
        )
      )
    (set-vector! (-> arg0 current-prt-color) 0.0 0.0 0.0 0.0)
    (set-vector! (-> arg0 current-env-color) 96.0 96.0 96.0 128.0)
    (set-vector! (-> arg0 current-sky-color) 0.0 0.0 0.0 1.0)
    (let ((a0-2 (-> v1-0 0)))
      (set! (-> a0-2 dir0 direction x) 0.0)
      (set! (-> a0-2 dir0 direction y) 1.0)
      (set! (-> a0-2 dir0 direction z) 0.0)
      (set! (-> a0-2 dir0 direction w) 0.0)
      )
    (set-vector! (-> v1-0 0 dir0 color) 0.667 0.667 0.667 1.0)
    (set-vector! (-> v1-0 0 ambi color) 0.333 0.333 0.333 1.0)
    (set! (-> v1-0 0 dir0 extra x) 1.0)
    (set! (-> v1-0 0 dir1 extra x) 0.0)
    (set! (-> v1-0 0 dir2 extra x) 0.0)
    (set! (-> v1-0 0 ambi extra x) 1.0)
    )
  )

;; definition for function update-mood-interior-ambient
;; INFO: Used lq/sq
(defun update-mood-interior-ambient ((arg0 mood-context) (arg1 symbol) (arg2 float))
  (update-mood-interior arg0 arg1)
  (set! (-> arg0 times 0 quad) (-> *level* level-default mood-context times 0 quad))
  (vector+float*!
    (the-as vector (-> arg0 times))
    (the-as vector (-> arg0 times))
    (-> *level* level-default mood-context times 1)
    arg2
    )
  )

;; definition for function update-mood-flames
(defbehavior update-mood-flames time-of-day-proc ((arg0 mood-context) (arg1 int) (arg2 int) (arg3 int) (arg4 float) (arg5 float) (arg6 float))
  (let* ((gp-0 (the-as flames-state (+ (+ arg3 1840) (the-as int arg0))))
         (s4-0 (+ (-> gp-0 index) arg1))
         (f0-0 (-> gp-0 time))
         (v1-2 (-> gp-0 length))
         (s0-0 (-> gp-0 height))
         )
    (dotimes (a0-1 arg2)
      (set! (-> arg0 times (+ arg1 a0-1) w) arg4)
      )
    (cond
      ((>= f0-0 (the float v1-2))
       (set! (-> gp-0 index) (the-as uint (the int (rand-vu-float-range 0.0 (+ -0.01 (the float arg2))))))
       (set! (-> gp-0 time) 0.0)
       (set! (-> gp-0 length) (the-as uint (the int (* (rand-vu-float-range 7.0 15.0) arg6))))
       (set! (-> gp-0 height) (the-as uint (the int (rand-vu-float-range 0.0 255.0))))
       (set! (-> arg0 times s4-0 w) arg4)
       )
      (else
        (let ((f0-14 (sin (* 32768.0 (/ f0-0 (the float v1-2))))))
          (set! (-> arg0 times s4-0 w) (+ (* (the float s0-0) f0-14 arg5) arg4))
          )
        (if (not (paused?))
            (set! (-> gp-0 time) (+ (-> gp-0 time) (if (= (-> *display* bg-clock clock-ratio) 0.0)
                                                       1.0
                                                       (-> self clock time-adjust-ratio)
                                                       )
                                    )
                  )
            )
        )
      )
    )
  )

;; definition for symbol *flash0*, type (array float)
(define *flash0*
  (new 'static 'boxed-array :type float 1.0 0.0 0.5 1.0 0.5 0.0 0.5 0.35 0.4 0.35 0.25 0.1 0.04)
  )

;; definition for symbol *flash1*, type (array float)
(define *flash1* (new 'static 'boxed-array :type float 1.0 0.8 0.0 1.0 0.5 1.0 0.4 0.2 0.1))

;; definition for symbol *flash2*, type (array float)
(define *flash2* (new 'static 'boxed-array :type float 1.0 0.9 0.8 0.7 0.0 0.0 1.0 0.0 1.0 0.5))

;; definition for symbol *flash3*, type (array float)
(define *flash3* (new 'static 'boxed-array :type float 0.5 0.0 1.0 0.9 1.0 0.8 0.3 0.0 0.0 0.5 0.1 0.5 0.35))

;; definition for symbol *flash4*, type (array float)
(define *flash4*
  (new 'static 'boxed-array :type float 1.0 0.0 1.0 0.0 1.0 0.9 0.8 0.7 0.6 0.5 0.4 0.3 0.2 0.5 0.4 0.3 0.2 0.1)
  )

;; definition for symbol *flash5*, type (array float)
(define *flash5* (new 'static 'boxed-array :type float
                   1.0
                   0.0
                   1.0
                   0.0
                   1.0
                   0.95
                   0.9
                   0.85
                   0.8
                   0.75
                   0.7
                   0.65
                   0.6
                   0.55
                   0.5
                   0.45
                   0.4
                   0.35
                   0.3
                   0.25
                   0.2
                   0.5
                   0.45
                   0.4
                   0.35
                   0.3
                   0.25
                   0.2
                   0.15
                   0.1
                   0.05
                   )
        )

;; definition for symbol *flash6*, type (array float)
(define *flash6*
  (new 'static 'boxed-array :type float 1.0 0.0 1.0 0.0 0.5 0.0 0.5 0.35 0.0 0.0 1.0 0.0 0.2 0.1)
  )

;; definition for symbol *flash7*, type (array float)
(define *flash7*
  (new 'static 'boxed-array :type float 1.0 0.8 0.3 0.0 0.6 0.5 0.4 0.3 0.2 0.5 0.4 0.3 0.2 0.1)
  )

;; definition for function update-mood-light
(defun update-mood-light ((arg0 mood-context) (arg1 int) (arg2 int) (arg3 float) (arg4 float) (arg5 float) (arg6 float) (arg7 float))
  (with-pp
    (let* ((gp-0 (the-as light-state (+ (+ arg2 1840) (the-as int arg0))))
           (f0-0 512.0)
           (f1-1 (+ (-> gp-0 time) arg6))
           (f26-0 (* f0-0 (- f1-1 (* (the float (the int (/ f1-1 256.0))) 256.0))))
           (f30-1 (+ (fabs arg3) (* (cos f26-0) arg4)))
           (f28-0 (-> gp-0 fade))
           )
      (cond
        ((or (>= arg5 18.0) (>= 6.0 arg5))
         (set! f28-0 (cond
                       ((< arg3 0.0)
                        (if (not (paused?))
                            (set! f28-0 (seek f28-0 1.0 (* 2.0 (seconds-per-frame))))
                            )
                        f28-0
                        )
                       (else
                         1.0
                         )
                       )
               )
         (set! (-> gp-0 fade) f28-0)
         (set! (-> arg0 times arg1 w) (* f30-1 f28-0))
         (when (not (paused?))
           (let ((f0-10 (-> gp-0 time)))
             (set! arg7 (cond
                          ((= (-> *display* bg-clock clock-ratio) 0.0)
                           (empty)
                           arg7
                           )
                          (else
                            (* arg7 (-> pp clock time-adjust-ratio))
                            )
                          )
                   )
             (set! (-> gp-0 time) (+ f0-10 arg7))
             )
           )
         )
        ((= f28-0 1.0)
         (cond
           ((< f26-0 3640.889)
            (set! (-> arg0 times arg1 w) f30-1)
            (set! (-> gp-0 fade) 0.99)
            )
           (else
             (set! (-> arg0 times arg1 w) f30-1)
             )
           )
         (if (not (paused?))
             (set! (-> gp-0 time) (+ (-> gp-0 time) (if (= (-> *display* bg-clock clock-ratio) 0.0)
                                                        arg7
                                                        (* arg7 (-> pp clock time-adjust-ratio))
                                                        )
                                     )
                   )
             )
         )
        ((and (< f28-0 1.0) (< 0.0 f28-0))
         (set! (-> arg0 times arg1 w) f28-0)
         (when (not (paused?))
           (if (< 0.75 f28-0)
               (set! (-> gp-0 fade) (- (-> gp-0 fade) (/ (-> pp clock time-adjust-ratio) 25)))
               (set! (-> gp-0 fade) (- (-> gp-0 fade) (/ (-> pp clock time-adjust-ratio) 50)))
               )
           )
         )
        (else
          (set! (-> gp-0 fade) 0.0)
          (set! (-> gp-0 time) 0.0)
          )
        )
      )
    )
  )

;; definition of type lava-state
(deftype lava-state (structure)
  ((lava  float)
   )
  )

;; definition for method 3 of type lava-state
(defmethod inspect ((this lava-state))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'lava-state)
  (format #t "~1Tlava: ~f~%" (-> this lava))
  (label cfg-4)
  this
  )

;; definition for function update-mood-lava
(defun update-mood-lava ((arg0 mood-context) (arg1 int) (arg2 int) (arg3 float) (arg4 float) (arg5 float) (arg6 float) (arg7 float))
  (let ((gp-0 (+ (+ arg2 1840) (the-as int arg0))))
    (let ((f0-1 (cos (-> (the-as (pointer float) gp-0)))))
      (set! (-> arg0 times arg1 w) (+ arg3 (* f0-1 arg4)))
      (set! (-> arg0 times (+ arg1 1) w) (+ arg3 (* (- f0-1) arg4)))
      )
    (if (not (paused?))
        (set! (-> (the-as (pointer float) gp-0)) (+ (-> (the-as (pointer float) gp-0)) arg5))
        )
    )
  )

;; definition for function update-mood-flicker
;; WARN: Return type mismatch int vs none.
(defun update-mood-flicker ((arg0 mood-context) (arg1 int) (arg2 int))
  (let ((gp-0 (the-as flicker-state (+ (+ arg2 1840) (the-as int arg0)))))
    (cond
      ((nonzero? (-> gp-0 flicker-on))
       (set! (-> arg0 times arg1 w) 1.0)
       (if (not (paused?))
           (+! (-> gp-0 flicker-on) -1)
           )
       )
      ((nonzero? (-> gp-0 flicker-off))
       (if (not (paused?))
           (+! (-> gp-0 flicker-off) -1)
           )
       )
      (else
        (set! (-> gp-0 flicker-on) (the-as uint (the int (rand-vu-float-range 2.0 20.0))))
        (if (zero? (the int (rand-vu-float-range 0.0 3.0)))
            (set! (-> gp-0 flicker-off) (the-as uint (the int (rand-vu-float-range 2.0 120.0))))
            (set! (-> gp-0 flicker-off) (the-as uint (the int (rand-vu-float-range 2.0 20.0))))
            )
        )
      )
    )
  (none)
  )

;; definition for function update-mood-florescent
(defun update-mood-florescent ((arg0 mood-context) (arg1 int) (arg2 int))
  (let ((gp-0 (the-as florescent-state (+ (+ arg2 1840) (the-as int arg0)))))
    (set! (-> arg0 times arg1 w) (-> gp-0 value))
    (when (not (paused?))
      (cond
        ((zero? (-> gp-0 delay))
         (set! (-> gp-0 delay2) (the int (rand-vu-float-range 10.0 60.0)))
         (set! (-> gp-0 delay) (the int (rand-vu-float-range 60.0 120.0)))
         )
        (else
          (+! (-> gp-0 delay) -1)
          )
        )
      (cond
        ((>= (-> gp-0 delay2) (-> gp-0 delay))
         (set! (-> gp-0 value) (rand-vu-float-range 1.0 1.5))
         )
        ((< (-> gp-0 delay2) (-> gp-0 delay))
         (set! (-> gp-0 value) 1.5)
         )
        )
      )
    )
  )

;; definition for function update-mood-electricity
;; WARN: Return type mismatch float vs none.
(defun update-mood-electricity ((arg0 mood-context) (arg1 int) (arg2 int) (arg3 float) (arg4 float))
  (let ((gp-0 (the-as electricity-state (+ (+ arg2 1840) (the-as int arg0)))))
    (set! (-> arg0 times arg1 w) (* (-> gp-0 value) (-> gp-0 scale)))
    (if (not (paused?))
        (set! (-> gp-0 value) (rand-vu-float-range arg3 arg4))
        )
    )
  (none)
  )

;; definition for function update-mood-pulse
;; WARN: Return type mismatch float vs none.
(defun update-mood-pulse ((arg0 mood-context) (arg1 int) (arg2 int) (arg3 float) (arg4 float) (arg5 float) (arg6 float))
  (let ((gp-0 (the-as pulse-state (+ (+ arg2 1840) (the-as int arg0)))))
    (set! (-> arg0 times arg1 w)
          (fmin 1.9921875 (* (+ arg3 (* (cos (+ (-> gp-0 pulse) arg6)) arg4)) (-> gp-0 brightness)))
          )
    (when (not (paused?))
      (+! (-> gp-0 pulse) arg5)
      (seek! (-> gp-0 brightness) (-> gp-0 target-brightness) (* (-> gp-0 speed) (seconds-per-frame)))
      )
    )
  (none)
  )

;; definition for function update-mood-strobe
(defun update-mood-strobe ((arg0 mood-context) (arg1 int) (arg2 int) (arg3 int) (arg4 float))
  (let ((gp-0 (+ (+ arg2 1840) (the-as int arg0))))
    (let ((a2-1 (the int (-> (the-as (pointer float) gp-0)))))
      (if (logtest? arg3 (ash 1 a2-1))
          (set! (-> arg0 times arg1 w) 1.0)
          (set! (-> arg0 times arg1 w) 0.3)
          )
      )
    (when (not (paused?))
      (let ((f0-5 (+ (-> (the-as (pointer float) gp-0)) arg4)))
        (set! (-> (the-as (pointer float) gp-0)) (- f0-5 (* (the float (the int (/ f0-5 32.0))) 32.0)))
        )
      )
    )
  )

;; definition for function update-mood-caustics
(defun update-mood-caustics ((arg0 mood-context) (arg1 int) (arg2 float) (arg3 float) (arg4 float) (arg5 float))
  (let ((f0-2 (sin (+ arg2 arg3))))
    (set! (-> arg0 times arg1 w) (+ arg4 (* f0-2 arg5)))
    )
  )

;; definition for function overide-mood-fog
;; WARN: Return type mismatch symbol vs none.
(defun overide-mood-fog ((arg0 mood-context) (arg1 float) (arg2 int) (arg3 float))
  0
  0
  0.0
  (let* ((v1-3 (-> *mood-control* mood-interp-table))
         (a0-1 (the int arg1))
         (f0-4 (- arg1 (the float a0-1)))
         (f1-3 (- 1.0 f0-4))
         (a1-3 (/ a0-1 24))
         (a0-5 (-> v1-3 hour (- a0-1 (* 24 a1-3))))
         (a1-5 (-> a0-5 snapshot1))
         (v1-4 (-> a0-5 snapshot2))
         (f0-6 (+ (* f1-3 (-> a0-5 morph-start)) (* f0-4 (-> a0-5 morph-end))))
         )
    (if (= a1-5 v1-4)
        (mem-copy! (the-as pointer (-> arg0 current-fog)) (the-as pointer (+ (* 48 a1-5) 0 arg2)) 48)
        (vector4-array-lerp!
          (the-as (inline-array vector4) (-> arg0 current-fog))
          (the-as (inline-array vector4) (+ (* 48 a1-5) 0 arg2))
          (the-as (inline-array vector4) (+ (* 48 v1-4) 0 arg2))
          f0-6
          3
          )
        )
    )
  (if (!= arg3 0.0)
      (vector4-array-lerp!
        (the-as (inline-array vector4) (-> arg0 current-fog))
        (the-as (inline-array vector4) (-> arg0 current-fog))
        (the-as (inline-array vector4) (-> *level* level-default mood-context))
        arg3
        3
        )
      )
  (none)
  )

;; definition for function overide-mood-color
;; INFO: Used lq/sq
;; WARN: Return type mismatch rgbaf vs none.
(defun overide-mood-color ((arg0 mood-context) (arg1 float) (arg2 int) (arg3 float))
  0
  0
  0.0
  (let* ((v1-3 (-> *mood-control* mood-interp-table))
         (a0-1 (the int arg1))
         (f0-4 (- arg1 (the float a0-1)))
         (f1-3 (- 1.0 f0-4))
         (a1-3 (/ a0-1 24))
         (a1-5 (-> v1-3 hour (- a0-1 (* 24 a1-3))))
         (a0-5 (-> a1-5 snapshot1))
         (v1-4 (-> a1-5 snapshot2))
         (f30-0 (+ (* f1-3 (-> a1-5 morph-start)) (* f0-4 (-> a1-5 morph-end))))
         )
    (cond
      ((= a0-5 v1-4)
       (let ((a0-6 (+ (* a0-5 32) 0 arg2))
             (a1-7 (-> arg0 times))
             (v1-7 (-> arg0 times 1))
             )
         (set! (-> a1-7 0 quad) (-> (the-as (inline-array vector) (+ a0-6 16)) 0 quad))
         (set! (-> v1-7 quad) (-> (the-as (inline-array vector) (+ a0-6 0)) 0 quad))
         (set! (-> arg0 times 2 quad) (-> v1-7 quad))
         (set! (-> arg0 times 3 quad) (-> v1-7 quad))
         (set! (-> arg0 times 4 quad) (-> v1-7 quad))
         )
       )
      (else
        (let ((s3-0 (+ (* a0-5 32) 0 arg2))
              (s2-0 (+ (* v1-4 32) 0 arg2))
              (a0-14 (-> arg0 times))
              (s4-0 (-> arg0 times 1))
              )
          (vector4-lerp! (the-as vector a0-14) (the-as vector (+ s3-0 16)) (the-as vector (+ s2-0 16)) f30-0)
          (vector4-lerp! s4-0 (the-as vector (+ s3-0 0)) (the-as vector (+ s2-0 0)) f30-0)
          (set! (-> arg0 times 2 quad) (-> s4-0 quad))
          (set! (-> arg0 times 3 quad) (-> s4-0 quad))
          (set! (-> arg0 times 4 quad) (-> s4-0 quad))
          )
        )
      )
    )
  (let ((s4-1 (-> arg0 light-group)))
    (let ((s3-1 (-> *level* level-default mood-context)))
      (if (!= arg3 0.0)
          (vector4-array-lerp!
            (the-as (inline-array vector4) (-> arg0 times))
            (the-as (inline-array vector4) (-> arg0 times))
            (the-as (inline-array vector4) (-> s3-1 times))
            arg3
            5
            )
          )
      (dotimes (v1-17 5)
        (set! (-> arg0 times v1-17 w) (-> (the-as mood-context (+ (the-as uint s3-1) (* v1-17 16))) times 0 w))
        )
      )
    (set! (-> s4-1 0 ambi color quad) (-> arg0 times 0 quad))
    (set! (-> s4-1 0 dir0 color quad) (-> arg0 times 1 quad))
    (set! (-> s4-1 0 dir1 color quad) (-> arg0 times 2 quad))
    (set! (-> s4-1 0 dir2 color quad) (-> arg0 times 3 quad))
    )
  (none)
  )

;; definition for method 16 of type mood-control
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod apply-mood-clouds-and-fog ((this mood-control) (arg0 mood-control-work))
  (let ((v1-0 (-> this mood-fog-table)))
    (dotimes (a0-1 24)
      (set! (-> v1-0 _data a0-1) (the-as uint128 0))
      )
    )
  (let ((s4-0 (-> this mood-fog-table)))
    (let ((f30-0 (- 1.0 (-> arg0 interp cloud))))
      (when (!= f30-0 0.0)
        (let ((f0-4 (* (- 1.0 (-> arg0 interp fog)) f30-0))
              (a2-0 (-> this fogs (-> arg0 index 0)))
              )
          (if (!= f0-4 0.0)
              (vector4-array-madd!
                (the-as (inline-array vector4) s4-0)
                (the-as (inline-array vector4) s4-0)
                (the-as (inline-array vector4) a2-0)
                f0-4
                24
                )
              )
          )
        (let ((f0-6 (* (-> arg0 interp fog) f30-0))
              (a2-1 (-> this fogs (-> arg0 index 1)))
              )
          (if (!= f0-6 0.0)
              (vector4-array-madd!
                (the-as (inline-array vector4) s4-0)
                (the-as (inline-array vector4) s4-0)
                (the-as (inline-array vector4) a2-1)
                f0-6
                24
                )
              )
          )
        )
      )
    (let ((f30-1 (-> arg0 interp cloud)))
      (when (!= f30-1 0.0)
        (let ((f0-10 (* (- 1.0 (-> arg0 interp fog)) f30-1))
              (a2-2 (-> this fogs (-> arg0 index 2)))
              )
          (if (!= f0-10 0.0)
              (vector4-array-madd!
                (the-as (inline-array vector4) s4-0)
                (the-as (inline-array vector4) s4-0)
                (the-as (inline-array vector4) a2-2)
                f0-10
                24
                )
              )
          )
        (let ((f0-12 (* (-> arg0 interp fog) f30-1))
              (a2-3 (-> this fogs (-> arg0 index 3)))
              )
          (if (!= f0-12 0.0)
              (vector4-array-madd!
                (the-as (inline-array vector4) s4-0)
                (the-as (inline-array vector4) s4-0)
                (the-as (inline-array vector4) a2-3)
                f0-12
                24
                )
              )
          )
        )
      )
    )
  (let ((f0-13 (-> *time-of-day-context* fog-mult))
        (v1-29 (-> this mood-fog-table))
        )
    (dotimes (a0-6 8)
      (set! (-> v1-29 data a0-6 fog-dists y) (* (-> v1-29 data a0-6 fog-dists y) f0-13))
      )
    )
  0
  (none)
  )

;; definition for method 17 of type mood-control
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod apply-mood-fog ((this mood-control)
                          (arg0 mood-control-work)
                          (arg1 mood-color-table)
                          (arg2 mood-color-table)
                          (arg3 mood-color-table)
                          (arg4 float)
                          )
  (let ((v1-0 (-> this mood-fog-table)))
    (dotimes (a1-1 24)
      (set! (-> v1-0 _data a1-1) (the-as uint128 0))
      )
    )
  (let ((s4-0 (-> this mood-fog-table))
        (f0-1 (fmax 0.0 (fmin 1.0 (* 5.0 (- 0.2 arg4)))))
        (f30-0 (if (>= 0.2 arg4)
                   (fmax 0.0 (fmin 1.0 (* 5.0 arg4)))
                   (- 1.0 (fmax 0.0 (fmin 1.0 (* 1.25 (+ -0.2 arg4)))))
                   )
               )
        (f28-0 (fmax 0.0 (fmin 1.0 (* 1.25 (+ -0.2 arg4)))))
        )
    (if (!= f0-1 0.0)
        (vector4-array-madd!
          (the-as (inline-array vector4) s4-0)
          (the-as (inline-array vector4) s4-0)
          (the-as (inline-array vector4) arg1)
          f0-1
          24
          )
        )
    (if (!= f30-0 0.0)
        (vector4-array-madd!
          (the-as (inline-array vector4) s4-0)
          (the-as (inline-array vector4) s4-0)
          (the-as (inline-array vector4) arg2)
          f30-0
          24
          )
        )
    (if (!= f28-0 0.0)
        (vector4-array-madd!
          (the-as (inline-array vector4) s4-0)
          (the-as (inline-array vector4) s4-0)
          (the-as (inline-array vector4) arg3)
          f28-0
          24
          )
        )
    )
  0
  (none)
  )

;; definition for method 18 of type mood-control
;; WARN: Return type mismatch int vs none.
(defmethod apply-fog-height ((this mood-control) (arg0 mood-control-work) (arg1 float) (arg2 float) (arg3 float) (arg4 float))
  (cond
    ((= arg4 0.2)
     (set-fog-height! arg2)
     )
    ((< arg4 0.2)
     (set-fog-height! (lerp arg1 arg2 (* 5.0 arg4)))
     )
    (else
      (set-fog-height! (lerp arg2 arg3 (* 1.25 (+ -0.2 arg4))))
      )
    )
  0
  (none)
  )

;; definition for method 19 of type mood-control
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod apply-mood-colors ((this mood-control) (arg0 mood-control-work))
  (let ((v1-0 (-> this mood-color-table)))
    (dotimes (a0-1 16)
      (set! (-> v1-0 _data a0-1) (the-as uint128 0))
      )
    )
  (let ((s4-0 (-> this mood-color-table)))
    (let ((f0-1 (- 1.0 (-> arg0 color-interp)))
          (a2-0 (-> this colors (-> arg0 color-index 0)))
          )
      (if (!= f0-1 0.0)
          (vector4-array-madd!
            (the-as (inline-array vector4) s4-0)
            (the-as (inline-array vector4) s4-0)
            (the-as (inline-array vector4) a2-0)
            f0-1
            16
            )
          )
      )
    (let ((f0-2 (-> arg0 color-interp))
          (a2-1 (-> this colors (-> arg0 color-index 1)))
          )
      (if (!= f0-2 0.0)
          (vector4-array-madd!
            (the-as (inline-array vector4) s4-0)
            (the-as (inline-array vector4) s4-0)
            (the-as (inline-array vector4) a2-1)
            f0-2
            16
            )
          )
      )
    )
  0
  (none)
  )

;; definition for method 20 of type mood-control
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod mood-control-method-20 ((this mood-control)
                                  (arg0 mood-control-work)
                                  (arg1 mood-color-table)
                                  (arg2 mood-color-table)
                                  (arg3 mood-color-table)
                                  (arg4 float)
                                  )
  (let ((v1-0 (-> this mood-color-table)))
    (dotimes (a1-1 16)
      (set! (-> v1-0 _data a1-1) (the-as uint128 0))
      )
    )
  (let ((s4-0 (-> this mood-color-table))
        (f0-1 (fmax 0.0 (fmin 1.0 (* 5.0 (- 0.2 arg4)))))
        (f30-0 (if (>= 0.2 arg4)
                   (fmax 0.0 (fmin 1.0 (* 5.0 arg4)))
                   (- 1.0 (fmax 0.0 (fmin 1.0 (* 1.25 (+ -0.2 arg4)))))
                   )
               )
        (f28-0 (fmax 0.0 (fmin 1.0 (* 1.25 (+ -0.2 arg4)))))
        )
    (if (!= f0-1 0.0)
        (vector4-array-madd!
          (the-as (inline-array vector4) s4-0)
          (the-as (inline-array vector4) s4-0)
          (the-as (inline-array vector4) arg1)
          f0-1
          16
          )
        )
    (if (!= f30-0 0.0)
        (vector4-array-madd!
          (the-as (inline-array vector4) s4-0)
          (the-as (inline-array vector4) s4-0)
          (the-as (inline-array vector4) arg2)
          f30-0
          16
          )
        )
    (if (!= f28-0 0.0)
        (vector4-array-madd!
          (the-as (inline-array vector4) s4-0)
          (the-as (inline-array vector4) s4-0)
          (the-as (inline-array vector4) arg3)
          f28-0
          16
          )
        )
    )
  0
  (none)
  )

;; definition for method 21 of type mood-control
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod apply-mood-channels ((this mood-control) (arg0 mood-control-work))
  (let ((v1-0 (-> this mood-channel-group)))
    (dotimes (a0-1 24)
      (set! (-> v1-0 data 0 vecs a0-1 quad) (the-as uint128 0))
      )
    )
  (let ((s4-0 (-> this mood-channel-group)))
    (let ((f0-1 (- 1.0 (-> arg0 channel-interp)))
          (a2-0 (-> this channels (-> arg0 channel-index 0)))
          )
      (if (!= f0-1 0.0)
          (vector4-array-madd!
            (the-as (inline-array vector4) s4-0)
            (the-as (inline-array vector4) s4-0)
            (the-as (inline-array vector4) a2-0)
            f0-1
            24
            )
          )
      )
    (let ((f0-2 (-> arg0 channel-interp))
          (a2-1 (-> this channels (-> arg0 channel-index 1)))
          )
      (if (!= f0-2 0.0)
          (vector4-array-madd!
            (the-as (inline-array vector4) s4-0)
            (the-as (inline-array vector4) s4-0)
            (the-as (inline-array vector4) a2-1)
            f0-2
            24
            )
          )
      )
    )
  0
  (none)
  )

;; definition for method 22 of type mood-control
;; WARN: Return type mismatch int vs none.
(defmethod adjust-num-clouds ((this mood-control) (arg0 mood-control-work))
  (let ((v1-0 (-> this mood-clouds)))
    (set! (-> v1-0 cloud-min) 0.0)
    (set! (-> v1-0 cloud-max) 0.0)
    (let ((f0-3 (- 1.0 (-> arg0 cloud-interp)))
          (a2-4 (-> this clouds (-> arg0 cloud-index 0)))
          )
      (when (!= f0-3 0.0)
        (set! (-> v1-0 cloud-min) (* (-> a2-4 cloud-min) f0-3))
        (set! (-> v1-0 cloud-max) (* (-> a2-4 cloud-max) f0-3))
        )
      )
    (let ((f0-5 (-> arg0 cloud-interp))
          (a0-2 (-> this clouds (-> arg0 cloud-index 1)))
          )
      (when (!= f0-5 0.0)
        (+! (-> v1-0 cloud-min) (* (-> a0-2 cloud-min) f0-5))
        (+! (-> v1-0 cloud-max) (* (-> a0-2 cloud-max) f0-5))
        )
      )
    )
  0
  (none)
  )

;; definition for method 24 of type mood-control
;; WARN: Return type mismatch int vs none.
(defmethod play-or-stop-lightning-sfx! ((this mood-control) (arg0 sound-spec) (arg1 vector))
  (vector+! (new 'stack-no-clear 'vector) arg1 (math-camera-pos))
  (cond
    ((or (load-in-progress? *level*) (movie?))
     (when (nonzero? (-> this lightning-id))
       (sound-stop (-> this lightning-id))
       (set! (-> this lightning-id) (new 'static 'sound-id))
       0
       )
     )
    (else
      (when (nonzero? (-> this lightning-id))
        (sound-stop (-> this lightning-id))
        (set! (-> this lightning-id) (new 'static 'sound-id))
        0
        )
      (set! (-> this lightning-id) (sound-play-by-spec arg0 (new-sound-id) arg1))
      )
    )
  (none)
  )

;; definition for method 23 of type mood-control
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defmethod gen-lightning-and-thunder! ((this mood-control) (arg0 int))
  (local-vars (a1-2 (array float)))
  (let ((v1-3 (-> this mood-channel-group data (-> this lightning-index)))
        (a1-1 (-> this lightning-val))
        (a0-4 (/ (-> this lightning-time) 2))
        (f0-0 (-> this lightning-time2))
        )
    (set! (-> this lightning-flash) 0.0)
    (cond
      ((>= 0.0 f0-0)
       (cond
         ((zero? a1-1)
          (set! a1-2 *flash0*)
          )
         ((= a1-1 1)
          (set! a1-2 *flash1*)
          )
         ((= a1-1 2)
          (set! a1-2 *flash2*)
          )
         ((= a1-1 3)
          (set! a1-2 *flash3*)
          )
         ((= a1-1 4)
          (set! a1-2 *flash4*)
          )
         ((= a1-1 5)
          (set! a1-2 *flash5*)
          )
         ((= a1-1 6)
          (set! a1-2 *flash6*)
          )
         (else
           (set! a1-2 *flash7*)
           )
         )
       (cond
         ((< a0-4 (-> a1-2 length))
          (let ((f30-0 (-> a1-2 a0-4))
                (s5-0 (new 'stack-no-clear 'vector))
                )
            (cond
              ((= (-> this lightning-index) 4)
               (set! (-> this lightning-flash) f30-0)
               )
              ((= (-> this lightning-index) 5)
               (set! (-> this lightning-flash) f30-0)
               (dotimes (s4-0 8)
                 (set-vector! s5-0 255.0 255.0 255.0 128.0)
                 (vector4-lerp!
                   (the-as vector (-> this mood-fog-table data s4-0))
                   (the-as vector (-> this mood-fog-table data s4-0))
                   s5-0
                   f30-0
                   )
                 )
               )
              (else
                (set! (-> this lightning-flash) (* 1.9921875 f30-0))
                (let ((a0-17 (-> v1-3 data)))
                  (set! (-> a0-17 0) 1.0)
                  (set! (-> a0-17 1) 1.0)
                  (set! (-> a0-17 2) 1.0)
                  (set! (-> a0-17 3) 1.0)
                  )
                (set! (-> (the-as vector (&-> v1-3 data 4)) quad) (-> (the-as vector (-> v1-3 data)) quad))
                (set! (-> (the-as vector (&-> v1-3 data 8)) quad) (-> (the-as vector (-> v1-3 data)) quad))
                (set! (-> (the-as vector (&-> v1-3 data 12)) quad) (-> (the-as vector (-> v1-3 data)) quad))
                (set! (-> (the-as vector (&-> v1-3 data 16)) quad) (-> (the-as vector (-> v1-3 data)) quad))
                (set! (-> (the-as vector (&-> v1-3 data 20)) quad) (-> (the-as vector (-> v1-3 data)) quad))
                )
              )
            )
          (if (not (paused?))
              (+! (-> this lightning-time) 1)
              )
          )
         (else
           (level-get-target-inside *level*)
           (cond
             ((!= (-> this lightning-time3) 0.0)
              (set! (-> this lightning-time2) (-> this lightning-time3))
              (set! (-> this lightning-time3) 0.0)
              )
             (else
               (set! (-> this lightning-time2) (rand-vu-float-range 5.0 10.0))
               )
             )
           )
         )
       )
      (else
        (when (not (paused?))
          (set! (-> this lightning-time2) (- (-> this lightning-time2) (seconds-per-frame)))
          (when (>= 0.0 (-> this lightning-time2))
            (when (= (-> this lightning-time3) 0.0)
              (set! (-> this lightning-index) (mod (the-as int (rand-uint31-gen *random-generator*)) 6))
              (set! (-> this lightning-val) (the-as int (logand (rand-uint31-gen *random-generator*) 7)))
              )
            (set! (-> this lightning-time) 0)
            (cond
              ((zero? (-> this lightning-index))
               (play-or-stop-lightning-sfx!
                 this
                 (static-sound-spec "thunder-b" :group 0)
                 (new 'static 'vector :x 37109760.0 :y 16261120.0 :z 5857280.0)
                 )
               )
              ((= (-> this lightning-index) 1)
               (play-or-stop-lightning-sfx!
                 this
                 (static-sound-spec "thunder-b" :group 0)
                 (new 'static 'vector :x 20480000.0 :y 33341440.0 :z 12124160.0)
                 )
               )
              ((= (-> this lightning-index) 2)
               (play-or-stop-lightning-sfx!
                 this
                 (static-sound-spec "thunder-b" :group 0)
                 (new 'static 'vector :x -20480000.0 :y 33341440.0 :z 12124160.0)
                 )
               )
              ((= (-> this lightning-index) 3)
               (play-or-stop-lightning-sfx!
                 this
                 (static-sound-spec "thunder-b" :group 0)
                 (new 'static 'vector :x -37109760.0 :y 16261120.0 :z 5857280.0)
                 )
               )
              ((= (-> this lightning-index) 4)
               (play-or-stop-lightning-sfx!
                 this
                 (static-sound-spec "thunder-c" :group 0)
                 (new 'static 'vector :y 40960000.0)
                 )
               )
              ((= (-> this lightning-index) 5)
               (play-or-stop-lightning-sfx!
                 this
                 (static-sound-spec "thunder-a" :group 0)
                 (new 'static 'vector :y 40960000.0)
                 )
               )
              )
            )
          )
        )
      )
    )
  (none)
  )

;; definition for method 15 of type mood-control
;; WARN: Return type mismatch int vs none.
(defmethod set-lightning-time! ((this mood-control) (arg0 int) (arg1 int) (arg2 float))
  (set! (-> this lightning-index) arg0)
  (set! (-> this lightning-val) arg1)
  (set! (-> this lightning-time2) (seconds-per-frame))
  (set! (-> this lightning-time3) arg2)
  0
  (none)
  )

;; definition for method 9 of type mood-control
;; WARN: Return type mismatch int vs none.
(defmethod init-weather! ((this mood-control))
  (local-vars (v1-32 int) (a1-12 object))
  (let ((s5-0 (level-get-target-inside *level*)))
    (when s5-0
      (set! (-> this mood-direction-table) *mood-direction-table*)
      (let ((s4-0 (new 'stack-no-clear 'mood-control-work)))
        (let ((s3-0 this))
          (cond
            ((and (-> s3-0 overide-weather-flag) (not (movie?)) (= (-> s3-0 current-special-interp) 0.0))
             (set! (-> s4-0 weather cloud) (* 2.0 (fmax 0.0 (fmin 1.0 (-> this overide cloud)))))
             (set! (-> s4-0 weather fog) (* 2.0 (-> this overide fog)))
             )
            (else
              (set! (-> s4-0 weather cloud) (* 2.0 (fmax 0.0 (fmin 1.0 (-> this current-interp cloud)))))
              (set! (-> s4-0 weather fog) (* 2.0 (fmax 0.0 (fmin 1.0 (-> this current-interp fog)))))
              )
            )
          )
        (set! (-> s4-0 iweather cloud) (the int (-> s4-0 weather cloud)))
        (let ((f0-12 (- (-> s4-0 weather cloud) (the float (-> s4-0 iweather cloud)))))
          (cond
            ((zero? (-> s4-0 iweather cloud))
             (if (< f0-12 0.5)
                 (set! (-> s4-0 interp cloud) 0.0)
                 (set! (-> s4-0 interp cloud) (* 2.0 (+ -0.5 f0-12)))
                 )
             )
            (else
              (set! (-> s4-0 interp cloud) f0-12)
              )
            )
          )
        (set! (-> s4-0 iweather fog) (the int (-> s4-0 weather fog)))
        (set! (-> s4-0 interp fog) (- (-> s4-0 weather fog) (the float (-> s4-0 iweather fog))))
        (let ((a0-2 (-> s4-0 iweather fog))
              (v1-23 (-> s4-0 iweather cloud))
              )
          (set! (-> s4-0 index 0) (+ (* 3 v1-23) a0-2))
          (set! (-> s4-0 index 1) (+ a0-2 1 (* 3 v1-23)))
          (set! (-> s4-0 index 2) (+ (* 3 (+ v1-23 1)) a0-2))
          (set! (-> s4-0 index 3) (+ a0-2 1 (* 3 (+ v1-23 1))))
          )
        (let ((v1-27 (-> s4-0 iweather cloud)))
          (set! (-> s4-0 color-interp) (-> s4-0 interp cloud))
          (set! (-> s4-0 color-index 0) v1-27)
          (set! (-> s4-0 color-index 1) (+ v1-27 1))
          )
        0
        (let ((f0-22 (- (-> s4-0 weather cloud) (the float (-> s4-0 iweather cloud)))))
          (cond
            ((zero? (-> s4-0 iweather cloud))
             (set! (-> s4-0 channel-interp) 0.0)
             (set! v1-32 0)
             )
            ((= (-> s4-0 iweather cloud) 2)
             (set! (-> s4-0 channel-interp) 0.0)
             (set! v1-32 2)
             )
            ((< f0-22 0.5)
             (set! (-> s4-0 channel-interp) (* 2.0 f0-22))
             (set! v1-32 0)
             )
            (else
              (set! (-> s4-0 channel-interp) (* 2.0 (+ -0.5 f0-22)))
              (set! v1-32 1)
              )
            )
          )
        (set! (-> s4-0 channel-index 0) v1-32)
        (set! (-> s4-0 channel-index 1) (+ v1-32 1))
        (let* ((s3-1 this)
               (f0-33 (if (and (-> s3-1 overide-weather-flag) (and (not (movie?)) (= (-> s3-1 current-special-interp) 0.0)))
                          (* 8.0 (-> this overide cloud))
                          (* 8.0 (fmax 0.0 (fmin 1.0 (-> this current-interp cloud))))
                          )
                      )
               (v1-45 (the int f0-33))
               )
          (set! (-> s4-0 cloud-interp) (- f0-33 (the float v1-45)))
          (set! (-> s4-0 cloud-index 0) v1-45)
          (set! (-> s4-0 cloud-index 1) (+ v1-45 1))
          )
        (cond
          ((= (-> *time-of-day-context* special-mood) 'desert)
           (apply-mood-fog
             this
             s4-0
             (the-as mood-color-table *desert-mood-fog-table*)
             (the-as mood-color-table *sandstorm-start-mood-fog-table*)
             (the-as mood-color-table *sandstorm-end-mood-fog-table*)
             (-> this current-special-interp)
             )
           (mood-control-method-20
             this
             s4-0
             *desert-mood-color-table*
             *sandstorm-start-mood-color-table*
             *sandstorm-end-mood-color-table*
             (-> this current-special-interp)
             )
           (apply-fog-height this s4-0 327680.0 614400.0 4096000.0 (-> this current-special-interp))
           (set! a1-12 s4-0)
           (adjust-num-clouds this (the-as mood-control-work a1-12))
           )
          (else
            (apply-mood-clouds-and-fog this s4-0)
            (apply-mood-colors this s4-0)
            (apply-mood-channels this s4-0)
            (set! a1-12 s4-0)
            (adjust-num-clouds this (the-as mood-control-work a1-12))
            )
          )
        )
      (when (not (or (paused?) (let ((s4-1 this))
                                 (and (-> s4-1 overide-weather-flag) (not (movie?)) (= (-> s4-1 current-special-interp) 0.0))
                                 )
                     )
                 )
        (when (!= (-> this time-until-random cloud) -99.0)
          (set! (-> this target-interp cloud)
                (fmax (fmin (-> this target-interp cloud) (-> this range max-cloud)) (-> this range min-cloud))
                )
          (let ((t9-13 seek)
                (a0-19 (-> this current-interp cloud))
                )
            (set! a1-12 (-> this target-interp cloud))
            (set! (-> this current-interp cloud)
                  (t9-13 a0-19 (the-as float a1-12) (* (/ 1.0 (-> this speed-interp cloud)) (seconds-per-frame)))
                  )
            )
          )
        (when (!= (-> this time-until-random fog) -99.0)
          (set! (-> this target-interp fog)
                (fmax (fmin (-> this target-interp fog) (-> this range max-fog)) (-> this range min-fog))
                )
          (let ((t9-14 seek)
                (a0-20 (-> this current-interp fog))
                )
            (set! a1-12 (-> this target-interp fog))
            (set! (-> this current-interp fog)
                  (t9-14 a0-20 (the-as float a1-12) (* (/ 1.0 (-> this speed-interp fog)) (seconds-per-frame)))
                  )
            )
          )
        (when (!= (-> this time-until-random cloud) -99.0)
          (set! (-> this time-until-random cloud) (- (-> this time-until-random cloud) (* 300.0 (seconds-per-frame))))
          (when (< (-> this time-until-random cloud) 0.0)
            (set! (-> this time-until-random cloud)
                  (rand-vu-float-range (-> this time-until-random-min cloud) (-> this time-until-random-max cloud))
                  )
            (let ((f30-0 (rand-vu-float-range (-> this range min-cloud) (-> this range max-cloud)))
                  (f28-0 (rand-vu-float-range (-> this range min-cloud) (-> this range max-cloud)))
                  (f26-0 (rand-vu-float-range (-> this range min-cloud) (-> this range max-cloud)))
                  (f24-0 (rand-vu-float-range (-> this range min-cloud) (-> this range max-cloud)))
                  (f2-11 (rand-vu-float-range (-> this range min-cloud) (-> this range max-cloud)))
                  )
              (set! (-> this target-interp cloud) (fmax 0.0 (+ -0.25 (* 0.25 (+ f30-0 f28-0 f26-0 f24-0 f2-11)))))
              )
            (let ((t9-21 rand-vu-float-range)
                  (a0-27 30.0)
                  )
              (set! a1-12 120.0)
              (set! (-> this speed-interp cloud) (t9-21 a0-27 (the-as float a1-12)))
              )
            (when (and (< 0.0 (-> *setting-control* user-current rain))
                       (< (-> this target-interp cloud) 0.5)
                       (< 0.25 (-> this target-interp cloud))
                       (or (< (-> this target-interp fog) 0.25) (< 0.75 (-> this target-interp fog)))
                       )
              (set! (-> this speed-interp fog) (fabs (/ (* 1.25 (-> this current-interp fog) (-> this speed-interp cloud))
                                                        (+ -0.75 (-> this current-interp cloud))
                                                        )
                                                     )
                    )
              (set! (-> this target-interp fog) 0.5)
              (set! (-> this time-until-random fog) (-> this time-until-random cloud))
              )
            )
          )
        (when (!= (-> this time-until-random fog) -99.0)
          (set! (-> this time-until-random fog) (- (-> this time-until-random fog) (* 300.0 (seconds-per-frame))))
          (when (< (-> this time-until-random fog) 0.0)
            (set! (-> this time-until-random fog)
                  (rand-vu-float-range (-> this time-until-random-min fog) (-> this time-until-random-max fog))
                  )
            (let ((f30-1 (rand-vu-float-range (-> this range min-fog) (-> this range max-fog)))
                  (f28-1 (rand-vu-float-range (-> this range min-fog) (-> this range max-fog)))
                  (f26-1 (rand-vu-float-range (-> this range min-fog) (-> this range max-fog)))
                  (f24-1 (rand-vu-float-range (-> this range min-fog) (-> this range max-fog)))
                  (f0-108 (rand-vu-float-range (-> this range min-fog) (-> this range max-fog)))
                  )
              (set! (-> this target-interp fog) (* 0.2 (+ f30-1 f28-1 f26-1 f24-1 f0-108)))
              )
            (let ((t9-28 rand-vu-float-range)
                  (a0-34 30.0)
                  )
              (set! a1-12 120.0)
              (set! (-> this speed-interp fog) (t9-28 a0-34 (the-as float a1-12)))
              )
            )
          )
        )
      (when (logtest? (game-secrets bad-weather) (-> *game-info* secrets))
        (set! (-> this current-interp cloud) 1.0)
        (set! (-> this current-interp fog) 1.0)
        )
      (let* ((s4-2 this)
             (f30-2 (if (and (-> s4-2 overide-weather-flag) (and (not (movie?)) (= (-> s4-2 current-special-interp) 0.0)))
                        (-> this overide cloud)
                        (-> this current-interp cloud)
                        )
                    )
             (s4-3 this)
             (f26-2 (if (and (-> s4-3 overide-weather-flag) (and (not (movie?)) (= (-> s4-3 current-special-interp) 0.0)))
                        (-> this overide fog)
                        (-> this current-interp fog)
                        )
                    )
             (f28-2 (fmin (-> s5-0 info max-rain) (-> *time-of-day-context* max-rain)))
             )
        (set! (-> this sound-pitch) (* 1.442695 (logf (-> *display* bg-clock clock-ratio))))
        (let* ((f0-125 (fmax 0.0 (fmin (* 4.0 (fmax 0.0 (+ -0.5 f26-2)) (fmax 0.0 (+ -0.5 f30-2))) f28-2)))
               (f30-3 (fmin 0.75 f0-125))
               )
          (set! (-> *setting-control* user-default rain) f30-3)
          (level-get-target-inside *level*)
          (cond
            ((and (< 0.0 (-> *setting-control* user-current rain)) (!= *master-mode* 'progress))
             (gen-lightning-and-thunder! this (the-as int a1-12))
             (cond
               ((zero? (-> this rain-id))
                (set! (-> this rain-id) (sound-play-by-name
                                          (static-sound-name "rain-hiss")
                                          (new-sound-id)
                                          (the int (* 1024.0 f30-3))
                                          (the int (* 1524.0 (-> this sound-pitch)))
                                          0
                                          (sound-group)
                                          #t
                                          )
                      )
                )
               (else
                 (when *sound-player-enable*
                   (let ((v1-146 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
                     (set! (-> v1-146 command) (sound-command set-param))
                     (set! (-> v1-146 id) (-> this rain-id))
                     (set! (-> v1-146 params volume) (the int (* 1024.0 f30-3)))
                     (set! (-> v1-146 params pitch-mod) (the int (* 1524.0 (-> this sound-pitch))))
                     (set! (-> v1-146 params mask) (the-as uint 3))
                     (-> v1-146 id)
                     )
                   )
                 )
               )
             )
            (else
              (set! (-> this lightning-flash) 0.0)
              (when (nonzero? (-> this rain-id))
                (sound-stop (-> this rain-id))
                (set! (-> this rain-id) (new 'static 'sound-id))
                0
                )
              )
            )
          )
        )
      (if (and (not (paused?)) (not (-> *game-info* dust-storm)))
          (seek!
            (-> this current-special-interp)
            (-> this target-special-interp)
            (* (-> this rate-special-interp) (seconds-per-frame))
            )
          )
      (when (-> this display-flag)
        (let ((s5-2 this))
          (cond
            ((and (-> s5-2 overide-weather-flag) (not (movie?)) (= (-> s5-2 current-special-interp) 0.0))
             (format *stdcon* "overide cloud ~f~%" (-> this overide cloud))
             (format *stdcon* "overide fog ~f~%" (-> this overide fog))
             )
            (else
              (format *stdcon* "time until random cloud ~f~%" (/ (-> this time-until-random cloud) 300))
              (format *stdcon* "current cloud ~f~%" (-> this current-interp cloud))
              (format *stdcon* "target cloud ~f~%" (-> this target-interp cloud))
              (format *stdcon* "speed cloud ~f~%" (* (/ 1.0 (-> this speed-interp cloud)) (seconds-per-frame)))
              (format *stdcon* "time until random fog ~f~%" (/ (-> this time-until-random fog) 300))
              (format *stdcon* "current fog ~f~%" (-> this current-interp fog))
              (format *stdcon* "target fog ~f~%" (-> this target-interp fog))
              (format *stdcon* "speed fog ~f~%" (* (/ 1.0 (-> this speed-interp fog)) (seconds-per-frame)))
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

;; definition for method 10 of type mood-control
;; WARN: Return type mismatch int vs none.
(defmethod set-cloud-and-fog-interp! ((this mood-control) (arg0 float) (arg1 float) (arg2 float) (arg3 float))
  (set! (-> this target-interp cloud) arg0)
  (set! (-> this target-interp fog) arg1)
  (set! (-> this speed-interp cloud) arg2)
  (set! (-> this speed-interp fog) arg3)
  (if (= arg2 0.0)
      (set! (-> this current-interp cloud) arg0)
      )
  (if (= arg3 0.0)
      (set! (-> this current-interp fog) arg1)
      )
  0
  (none)
  )

;; definition for method 11 of type mood-control
;; WARN: Return type mismatch int vs none.
(defmethod update-mood-range! ((this mood-control) (arg0 float) (arg1 float) (arg2 float) (arg3 float))
  (set! (-> this range min-cloud) arg0)
  (set! (-> this range max-cloud) arg1)
  (set! (-> this range min-fog) arg2)
  (set! (-> this range max-fog) arg3)
  0
  (none)
  )

;; definition for method 12 of type mood-control
;; WARN: Return type mismatch int vs none.
(defmethod set-time-for-random-weather! ((this mood-control) (arg0 float) (arg1 float))
  (set! (-> this time-until-random cloud) arg0)
  (set! (-> this time-until-random fog) arg1)
  0
  (none)
  )
