;;-*-Lisp-*-
(in-package goal)

;; definition for method 9 of type billboard
(defmethod login ((this billboard))
  "Initialize the object after it is loaded."
  (adgif-shader-login (-> this flat))
  this
  )

;; definition for method 8 of type billboard
(defmethod mem-usage ((this billboard) (usage memory-usage-block) (flags int))
  (set! (-> usage length) (max 34 (-> usage length)))
  (set! (-> usage data 33 name) "billboard")
  (+! (-> usage data 33 count) 1)
  (let ((v1-6 (asize-of this)))
    (+! (-> usage data 33 used) v1-6)
    (+! (-> usage data 33 total) (logand -16 (+ v1-6 15)))
    )
  this
  )

;; definition for function mem-usage-shrub-walk
(defun mem-usage-shrub-walk ((arg0 draw-node) (arg1 int) (arg2 memory-usage-block) (arg3 int))
  "Walk the shrub tree and compute memory usagbe for draw nodes and shrub instances."
  (set! (-> arg2 length) (max 65 (-> arg2 length)))
  (set! (-> arg2 data 64 name) "draw-node")
  (+! (-> arg2 data 64 count) arg1)
  (let ((v1-5 (* arg1 32)))
    (+! (-> arg2 data 64 used) v1-5)
    (+! (-> arg2 data 64 total) (logand -16 (+ v1-5 15)))
    )
  (let ((s2-0 arg0))
    (dotimes (s1-0 arg1)
      (let ((a1-2 (-> s2-0 child-count)))
        (cond
          ((logtest? (-> s2-0 flags) 1)
           (mem-usage-shrub-walk (the-as draw-node (-> s2-0 child)) (the-as int a1-2) arg2 arg3)
           )
          (else
            (set! (-> arg2 length) (max 35 (-> arg2 length)))
            (set! (-> arg2 data 34 name) "instance-shrubbery")
            (+! (-> arg2 data 34 count) a1-2)
            (let ((v1-18 (* (the-as uint 80) a1-2)))
              (+! (-> arg2 data 34 used) v1-18)
              (+! (-> arg2 data 34 total) (logand -16 (+ v1-18 15)))
              )
            )
          )
        )
      (&+! s2-0 32)
      )
    )
  arg0
  )

;; definition for method 8 of type drawable-tree-instance-shrub
(defmethod mem-usage ((this drawable-tree-instance-shrub) (usage memory-usage-block) (flags int))
  (set! (-> usage length) (max 1 (-> usage length)))
  (set! (-> usage data 0 name) "drawable-group")
  (+! (-> usage data 0 count) 1)
  (let ((v1-5 32))
    (+! (-> usage data 0 used) v1-5)
    (+! (-> usage data 0 total) (logand -16 (+ v1-5 15)))
    )
  (when (nonzero? (-> this colors-added))
    (set! (-> usage length) (max 33 (-> usage length)))
    (set! (-> usage data 32 name) "shrubbery-pal")
    (+! (-> usage data 32 count) 1)
    (let ((v1-17 (asize-of (-> this colors-added))))
      (+! (-> usage data 32 used) v1-17)
      (+! (-> usage data 32 total) (logand -16 (+ v1-17 15)))
      )
    )
  (mem-usage-shrub-walk
    (the-as draw-node (&+ (-> this data 0) 32))
    (-> (the-as drawable-group (-> this data 0)) length)
    usage
    flags
    )
  (mem-usage (-> this info prototype-inline-array-shrub) usage (logior flags 1))
  this
  )

;; definition for method 9 of type generic-shrub-fragment
(defmethod login ((this generic-shrub-fragment))
  "Initialize the object after it is loaded."
  (let ((s5-0 (/ (-> this cnt-qwc) (the-as uint 5))))
    (dotimes (s4-0 (the-as int s5-0))
      (adgif-shader-login-no-remap (-> this textures s4-0))
      )
    )
  this
  )

;; definition for method 8 of type generic-shrub-fragment
(defmethod mem-usage ((this generic-shrub-fragment) (usage memory-usage-block) (flags int))
  (set! (-> usage length) (max 27 (-> usage length)))
  (set! (-> usage data 25 name) "generic-shrub")
  (+! (-> usage data 25 count) 1)
  (let ((v1-6 (asize-of this)))
    (+! (-> usage data 25 used) v1-6)
    (+! (-> usage data 25 total) (logand -16 (+ v1-6 15)))
    )
  (set! (-> usage data 26 name) "generic-shrub-data")
  (+! (-> usage data 26 count) 1)
  (let ((v1-17 (* (+ (-> this cnt-qwc) (-> this vtx-qwc) (-> this col-qwc) (-> this stq-qwc)) 16)))
    (+! (-> usage data 26 used) v1-17)
    (+! (-> usage data 26 total) (logand -16 (+ v1-17 15)))
    )
  this
  )

;; definition for method 3 of type prototype-shrubbery
(defmethod inspect ((this prototype-shrubbery))
  (format #t "[~8x] ~A~%" this (-> this type))
  (format #t "~Tlength: ~D~%" (-> this length))
  (format #t "~Tdata[~D]: @ #x~X~%" (-> this length) (-> this data))
  (dotimes (s5-0 (-> this length))
    (format #t "~T  [~D] ~A~%" s5-0 (-> this data s5-0))
    )
  this
  )

;; definition for method 8 of type prototype-shrubbery
(defmethod mem-usage ((this prototype-shrubbery) (usage memory-usage-block) (flags int))
  (set! (-> usage length) (max 1 (-> usage length)))
  (set! (-> usage data 0 name) "drawable-group")
  (+! (-> usage data 0 count) 1)
  (let ((v1-5 32))
    (+! (-> usage data 0 used) v1-5)
    (+! (-> usage data 0 total) (logand -16 (+ v1-5 15)))
    )
  (dotimes (s3-0 (-> this length))
    (mem-usage (-> this data s3-0) usage flags)
    )
  this
  )

;; definition for method 9 of type prototype-shrubbery
(defmethod login ((this prototype-shrubbery))
  "Initialize the object after it is loaded."
  (dotimes (s5-0 (-> this length))
    (login (-> this data s5-0))
    )
  this
  )

;; definition for method 5 of type prototype-shrubbery
;; WARN: Return type mismatch uint vs int.
(defmethod asize-of ((this prototype-shrubbery))
  (the-as int (+ (-> prototype-shrubbery size) (* (+ (-> this length) -1) 32)))
  )

;; definition for method 9 of type prototype-generic-shrub
(defmethod login ((this prototype-generic-shrub))
  "Initialize the object after it is loaded."
  (dotimes (s5-0 (-> this length))
    (login (-> this data s5-0))
    )
  this
  )

;; definition for method 9 of type shrubbery
(defmethod login ((this shrubbery))
  "Initialize the object after it is loaded."
  (let ((s5-0 (* (-> this header data 0) 2)))
    (dotimes (s4-0 (the-as int s5-0))
      (let ((v1-3 (adgif-shader-login-no-remap (-> this textures s4-0))))
        (when v1-3
          (dotimes (a0-5 3)
            (dotimes (a1-0 3)
              (set! (-> (the-as (pointer int32) (+ (+ (* a0-5 16) (* a1-0 4)) (the-as int *texture-masks*))))
                    (logior (-> (the-as (pointer int32) (+ (* a1-0 4) (the-as int *texture-masks*) (* a0-5 16))) 0)
                            (-> (the-as (pointer int32) (+ (* a1-0 4) (the-as int v1-3) (* a0-5 16))) 15)
                            )
                    )
              )
            (set! (-> *texture-masks* data a0-5 dist)
                  (fmax (-> *texture-masks* data a0-5 dist) (-> v1-3 masks data a0-5 dist))
                  )
            )
          )
        )
      )
    )
  (shrubbery-login-post-texture this)
  this
  )

;; definition for method 8 of type shrubbery
(defmethod mem-usage ((this shrubbery) (usage memory-usage-block) (flags int))
  (set! (-> usage length) (max 28 (-> usage length)))
  (set! (-> usage data 27 name) "shrubbery")
  (+! (-> usage data 27 count) 1)
  (let ((v1-6 (asize-of this)))
    (+! (-> usage data 27 used) v1-6)
    (+! (-> usage data 27 total) (logand -16 (+ v1-6 15)))
    )
  (set! (-> usage length) (max 30 (-> usage length)))
  (set! (-> usage data 29 name) "shrubbery-vertex")
  (+! (-> usage data 29 count) 1)
  (let ((v1-16 (* (-> this vtx-qwc) 16)))
    (+! (-> usage data 29 used) v1-16)
    (+! (-> usage data 29 total) (logand -16 (+ v1-16 15)))
    )
  (set! (-> usage length) (max 31 (-> usage length)))
  (set! (-> usage data 30 name) "shrubbery-color")
  (+! (-> usage data 30 count) 1)
  (let ((v1-26 (* (-> this col-qwc) 16)))
    (+! (-> usage data 30 used) v1-26)
    (+! (-> usage data 30 total) (logand -16 (+ v1-26 15)))
    )
  (set! (-> usage length) (max 29 (-> usage length)))
  (set! (-> usage data 28 name) "shrubbery-object")
  (+! (-> usage data 28 count) 1)
  (let ((v1-36 (* (-> this obj-qwc) 16)))
    (+! (-> usage data 28 used) v1-36)
    (+! (-> usage data 28 total) (logand -16 (+ v1-36 15)))
    )
  (set! (-> usage length) (max 32 (-> usage length)))
  (set! (-> usage data 31 name) "shrubbery-stq")
  (+! (-> usage data 31 count) 1)
  (let ((v1-46 (* (-> this stq-qwc) 16)))
    (+! (-> usage data 31 used) v1-46)
    (+! (-> usage data 31 total) (logand -16 (+ v1-46 15)))
    )
  this
  )

;; definition (debug) for function highres-shrub-login
;; WARN: Return type mismatch int vs none.
(defun-debug highres-shrub-login ((arg0 draw-node))
  "Set draw-node's distance to max, to force to always draw."
  (set! (-> arg0 distance) 40960000.0)
  (when (logtest? (-> arg0 flags) 1)
    (dotimes (s5-0 (the-as int (-> arg0 child-count)))
      (let ((a0-2 (+ (+ (* s5-0 32) 32) (the-as int (-> arg0 child)))))
        (highres-shrub-login (the-as draw-node a0-2))
        )
      )
    )
  0
  (none)
  )

;; definition for method 9 of type drawable-tree-instance-shrub
(defmethod login ((this drawable-tree-instance-shrub))
  "Initialize the object after it is loaded."
  (when (and *debug-segment* (-> *screen-shot-work* highres-enable))
    (dotimes (s5-0 (-> this length))
      (let ((a0-1 (-> this data s5-0)))
        (highres-shrub-login (the-as draw-node a0-1))
        )
      )
    )
  (if (nonzero? (-> this info prototype-inline-array-shrub))
      (login (-> this info prototype-inline-array-shrub))
      )
  this
  )

;; definition for symbol shrub-vu1-block, type vu-function
(define shrub-vu1-block (new 'static 'vu-function :length #x26a :qlength #x135))

;; definition for function shrub-num-tris
(defun shrub-num-tris ((arg0 shrubbery))
  "Get the number of triangles in this shrubbery."
  (- (-> arg0 header data 2) (* (-> arg0 header data 1) 2))
  )

;; definition for function shrub-make-perspective-matrix
;; INFO: Used lq/sq
(defun shrub-make-perspective-matrix ((arg0 matrix) (arg1 matrix))
  "Create shrub drawing matrix."
  (let* ((v1-0 arg0)
         (t0-0 arg1)
         (a1-1 (-> t0-0 rvec quad))
         (a2-0 (-> t0-0 uvec quad))
         (a3-0 (-> t0-0 fvec quad))
         (t0-1 (-> t0-0 trans quad))
         )
    (set! (-> v1-0 rvec quad) a1-1)
    (set! (-> v1-0 uvec quad) a2-0)
    (set! (-> v1-0 fvec quad) a3-0)
    (set! (-> v1-0 trans quad) t0-1)
    )
  (let ((f0-1 (/ 1.0 (-> *math-camera* pfog0))))
    (set! (-> arg0 rvec w) (* (-> arg0 rvec w) f0-1))
    (set! (-> arg0 uvec w) (* (-> arg0 uvec w) f0-1))
    (set! (-> arg0 fvec w) (* (-> arg0 fvec w) f0-1))
    (set! (-> arg0 trans w) (* (-> arg0 trans w) f0-1))
    )
  (+! (-> arg0 rvec x) (* (-> arg0 rvec w) (-> *math-camera* hvdf-off x)))
  (+! (-> arg0 uvec x) (* (-> arg0 uvec w) (-> *math-camera* hvdf-off x)))
  (+! (-> arg0 fvec x) (* (-> arg0 fvec w) (-> *math-camera* hvdf-off x)))
  (+! (-> arg0 trans x) (* (-> arg0 trans w) (-> *math-camera* hvdf-off x)))
  (+! (-> arg0 rvec y) (* (-> arg0 rvec w) (-> *math-camera* hvdf-off y)))
  (+! (-> arg0 uvec y) (* (-> arg0 uvec w) (-> *math-camera* hvdf-off y)))
  (+! (-> arg0 fvec y) (* (-> arg0 fvec w) (-> *math-camera* hvdf-off y)))
  (+! (-> arg0 trans y) (* (-> arg0 trans w) (-> *math-camera* hvdf-off y)))
  (+! (-> arg0 rvec z) (* (-> arg0 rvec w) (-> *math-camera* hvdf-off z)))
  (+! (-> arg0 uvec z) (* (-> arg0 uvec w) (-> *math-camera* hvdf-off z)))
  (+! (-> arg0 fvec z) (* (-> arg0 fvec w) (-> *math-camera* hvdf-off z)))
  (+! (-> arg0 trans z) (* (-> arg0 trans w) (-> *math-camera* hvdf-off z)))
  arg0
  )

;; definition for function shrub-init-view-data
(defun shrub-init-view-data ((arg0 shrub-view-data))
  "Initialize shrub drawing constants."
  (set! (-> arg0 texture-giftag tag) (new 'static 'gif-tag64 :nloop #x1 :nreg #x4))
  (set! (-> arg0 texture-giftag regs) (new 'static 'gif-tag-regs
                                        :regs0 (gif-reg-id a+d)
                                        :regs1 (gif-reg-id a+d)
                                        :regs2 (gif-reg-id a+d)
                                        :regs3 (gif-reg-id a+d)
                                        )
        )
  (set! (-> arg0 texture-giftag word 3) (the-as uint #x40a00000))
  (set! (-> arg0 consts x) 25167696.0)
  (set! (-> arg0 consts y) 8388608.0)
  (set! (-> arg0 consts z) (-> *math-camera* pfog0))
  (set! (-> arg0 consts w) (-> *math-camera* pfog1))
  (set! (-> arg0 fog-clamp x) (-> *math-camera* fog-min))
  (set! (-> arg0 fog-clamp y) (-> *math-camera* fog-max))
  #f
  )

;; definition for function shrub-upload-view-data
(defun shrub-upload-view-data ((arg0 dma-buffer))
  "Create DMA to set shrub vu1 constants."
  (let ((s5-0 3))
    (let* ((v1-0 arg0)
           (a0-1 (the-as dma-packet (-> v1-0 base)))
           )
      (set! (-> a0-1 dma) (new 'static 'dma-tag :id (dma-tag-id cnt) :qwc s5-0))
      (set! (-> a0-1 vif0) (new 'static 'vif-tag :imm #x404 :cmd (vif-cmd stcycl)))
      (set! (-> a0-1 vif1) (new 'static 'vif-tag :cmd (vif-cmd unpack-v4-32) :num s5-0))
      (set! (-> v1-0 base) (the-as pointer (&+ a0-1 16)))
      )
    (shrub-init-view-data (the-as shrub-view-data (-> arg0 base)))
    (&+! (-> arg0 base) (* s5-0 16))
    )
  #f
  )

;; definition for function shrub-time
(defun shrub-time ((arg0 int) (arg1 int) (arg2 int) (arg3 int) (arg4 int))
  "Unknown. Maybe rough cycle count for a shrub fragment?"
  (+ (* arg0 8) 29 (* 22 arg2) (* 11 arg1) (* (+ (* arg4 2) 15 (* 5 arg2) (* 13 arg0)) arg3) 53)
  )

;; definition for function shrub-do-init-frame
(defun shrub-do-init-frame ((arg0 dma-buffer))
  "Set up DMA to set up VU1 for shrub rendering."
  (dma-buffer-add-vu-function arg0 shrub-vu1-block 1)
  (shrub-upload-view-data arg0)
  (let* ((v1-0 arg0)
         (a0-3 (the-as object (-> v1-0 base)))
         )
    (set! (-> (the-as dma-packet a0-3) dma) (new 'static 'dma-tag :id (dma-tag-id cnt)))
    (set! (-> (the-as dma-packet a0-3) vif0) (new 'static 'vif-tag :cmd (vif-cmd mscalf) :msk #x1 :imm #x0))
    (set! (-> (the-as dma-packet a0-3) vif1) (new 'static 'vif-tag :cmd (vif-cmd flushe) :msk #x1))
    (set! (-> v1-0 base) (&+ (the-as pointer a0-3) 16))
    )
  (let* ((v1-1 arg0)
         (a0-5 (the-as object (-> v1-1 base)))
         )
    (set! (-> (the-as dma-packet a0-5) dma) (new 'static 'dma-tag :qwc #x3 :id (dma-tag-id cnt)))
    (set! (-> (the-as dma-packet a0-5) vif0) (new 'static 'vif-tag))
    (set! (-> (the-as dma-packet a0-5) vif1) (new 'static 'vif-tag))
    (set! (-> v1-1 base) (&+ (the-as pointer a0-5) 16))
    )
  (let ((v1-2 (-> arg0 base)))
    (set! (-> (the-as (pointer vif-tag) v1-2) 0) (new 'static 'vif-tag :cmd (vif-cmd strow) :msk #x1))
    (set! (-> (the-as (pointer uint32) v1-2) 1) (the-as uint #x8080))
    (set! (-> (the-as (pointer uint32) v1-2) 2) (the-as uint #x8080))
    (set! (-> (the-as (pointer uint32) v1-2) 3) (the-as uint #x8080))
    (set! (-> (the-as (pointer uint32) v1-2) 4) (the-as uint 0))
    (set! (-> (the-as (pointer vif-tag) v1-2) 5) (new 'static 'vif-tag :cmd (vif-cmd stcol) :msk #x1))
    (set! (-> (the-as (pointer uint32) v1-2) 6) (the-as uint 4096))
    (set! (-> (the-as (pointer uint32) v1-2) 7) (the-as uint 4096))
    (set! (-> (the-as (pointer uint32) v1-2) 8) (the-as uint 4096))
    (set! (-> (the-as (pointer uint32) v1-2) 9) (the-as uint 4096))
    (set! (-> (the-as (pointer vif-tag) v1-2) 10) (new 'static 'vif-tag :cmd (vif-cmd stmask)))
    (set! (-> (the-as (pointer uint32) v1-2) 11) (the-as uint #xa0a0a0a0))
    (set! (-> arg0 base) (&+ v1-2 48))
    )
  (set! *shrub-state* 2)
  #f
  )

;; definition for function shrub-init-frame
(defun shrub-init-frame ((arg0 dma-buffer) (arg1 gs-test))
  "Set up DMA to set up VU1 and GS for shrub rendering."
  (shrub-do-init-frame arg0)
  (let* ((v1-0 arg0)
         (a0-2 (the-as object (-> v1-0 base)))
         )
    (set! (-> (the-as dma-packet a0-2) dma) (new 'static 'dma-tag :qwc #x2 :id (dma-tag-id cnt)))
    (set! (-> (the-as dma-packet a0-2) vif0) (new 'static 'vif-tag))
    (set! (-> (the-as dma-packet a0-2) vif1) (new 'static 'vif-tag :imm #x2 :cmd (vif-cmd direct) :msk #x1))
    (set! (-> v1-0 base) (&+ (the-as pointer a0-2) 16))
    )
  (let* ((v1-1 arg0)
         (a0-4 (the-as object (-> v1-1 base)))
         )
    (set! (-> (the-as gs-gif-tag a0-4) tag) (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x1))
    (set! (-> (the-as gs-gif-tag a0-4) regs) GIF_REGS_ALL_AD)
    (set! (-> v1-1 base) (&+ (the-as pointer a0-4) 16))
    )
  (let ((v1-2 (-> arg0 base)))
    (set! (-> (the-as (pointer gs-test) v1-2) 0) arg1)
    (set! (-> (the-as (pointer gs-reg64) v1-2) 1) (gs-reg64 test-1))
    (set! (-> arg0 base) (&+ v1-2 16))
    )
  #f
  )

;; definition for function shrub-upload-model
(defun shrub-upload-model ((arg0 shrubbery) (arg1 dma-buffer) (arg2 int))
  "Set up DMA to upload a single shrub model."
  (let* ((v1-0 arg1)
         (a3-0 (the-as object (-> v1-0 base)))
         )
    (set! (-> (the-as dma-packet a3-0) dma)
          (new 'static 'dma-tag
            :id (dma-tag-id ref)
            :addr (the-as int (-> arg0 bsphere x))
            :qwc (+ (-> arg0 obj-qwc) (-> arg0 vtx-qwc) (-> arg0 col-qwc) (-> arg0 stq-qwc))
            )
          )
    (set! (-> (the-as dma-packet a3-0) vif0) (new 'static 'vif-tag :cmd (vif-cmd base) :imm *shrub-state*))
    (set! (-> (the-as dma-packet a3-0) vif1) (new 'static 'vif-tag :cmd (vif-cmd offset)))
    (set! (-> v1-0 base) (&+ (the-as pointer a3-0) 16))
    )
  (cond
    ((= arg2 1)
     (let* ((v1-2 arg1)
            (a0-9 (the-as object (-> v1-2 base)))
            )
       (set! (-> (the-as dma-packet a0-9) dma) (new 'static 'dma-tag :id (dma-tag-id cnt)))
       (set! (-> (the-as dma-packet a0-9) vif0) (new 'static 'vif-tag))
       (set! (-> (the-as dma-packet a0-9) vif1) (new 'static 'vif-tag :cmd (vif-cmd mscal) :msk #x1 :imm #x11))
       (set! (-> v1-2 base) (&+ (the-as pointer a0-9) 16))
       )
     )
    (else
      (let* ((v1-3 arg1)
             (a0-11 (the-as object (-> v1-3 base)))
             )
        (set! (-> (the-as dma-packet a0-11) dma) (new 'static 'dma-tag :id (dma-tag-id cnt)))
        (set! (-> (the-as dma-packet a0-11) vif0) (new 'static 'vif-tag))
        (set! (-> (the-as dma-packet a0-11) vif1) (new 'static 'vif-tag :cmd (vif-cmd mscal) :msk #x1 :imm #x15))
        (set! (-> v1-3 base) (&+ (the-as pointer a0-11) 16))
        )
      )
    )
  (set! *shrub-state* (- 164 *shrub-state*))
  #f
  )

;; definition for function draw-inline-array-instance-shrub
;; ERROR: function was not converted to expressions. Cannot decompile.

;; definition for function draw-prototype-inline-array-shrub
;; INFO: Used lq/sq
;; ERROR: Failed load: (set! a2-11 (l.d (+ a0-14 96))) at op 102
(defun draw-prototype-inline-array-shrub ((arg0 int) (arg1 (inline-array prototype-bucket-shrub)))
  (local-vars
    (sv-16 drawable)
    (sv-32 uint)
    (sv-48 int)
    (sv-64 drawable)
    (sv-80 int)
    (sv-96 uint)
    (sv-112 drawable)
    (sv-128 int)
    )
  (let ((v1-0 (the-as object arg1))
        (a0-6 (-> *display* frames (-> *display* on-screen) global-buf))
        )
    (countdown (a1-2 arg0)
      (when (nonzero? (-> (the-as prototype-bucket-shrub v1-0) count 1))
        (let ((a2-2 (-> a0-6 base)))
          (set! (-> (the-as (pointer uint128) a2-2))
                (-> *instance-shrub-work* count-tmpl (-> (the-as prototype-bucket-shrub v1-0) mod-count 1) quad)
                )
          (set! (-> (the-as (pointer uint64) a2-2))
                (logior (logand (-> (the-as (pointer uint64) a2-2)) (the-as uint #x80000000ffffffff))
                        (shr (shl (-> (the-as prototype-bucket-shrub v1-0) next 1) 33) 1)
                        )
                )
          (set! (-> (the-as prototype-bucket-shrub v1-0) next 1) (the-as uint a2-2))
          )
        (&+! (-> a0-6 base) 16)
        )
      (when (nonzero? (-> (the-as prototype-bucket-shrub v1-0) count 2))
        (let ((a2-7 (-> a0-6 base)))
          (set! (-> (the-as (pointer uint128) a2-7))
                (-> *instance-shrub-work* count-tmpl (-> (the-as prototype-bucket-shrub v1-0) mod-count 2) quad)
                )
          (set! (-> (the-as (pointer uint64) a2-7))
                (logior (logand (-> (the-as (pointer uint64) a2-7)) (the-as uint #x80000000ffffffff))
                        (shr (shl (-> (the-as prototype-bucket-shrub v1-0) next 2) 33) 1)
                        )
                )
          (set! (-> (the-as prototype-bucket-shrub v1-0) next 2) (the-as uint a2-7))
          )
        (&+! (-> a0-6 base) 16)
        )
      (set! v1-0 (&+ (the-as prototype-bucket-shrub v1-0) 112))
      )
    )
  (when (logtest? (vu1-renderer-mask shrub-near) (-> *display* vu1-enable-user))
    (when (nonzero? (-> *instance-shrub-work* near-count))
      (let ((s4-0 (-> *display* frames (-> *display* on-screen) global-buf base)))
        (with-dma-buffer-add-bucket ((s2-0 (-> *display* frames (-> *display* on-screen) global-buf))
                                     (-> (new 'static 'array bucket-id 12
                                           (bucket-id shrub-near-l0-shrub)
                                           (bucket-id shrub-near-l1-shrub)
                                           (bucket-id shrub-near-l2-shrub)
                                           (bucket-id shrub-near-l3-shrub)
                                           (bucket-id shrub-near-l4-shrub)
                                           (bucket-id shrub-near-l5-shrub)
                                           (bucket-id shrub-near-l6-shrub)
                                           (bucket-id shrub-near-l7-shrub)
                                           (bucket-id shrub-near-l8-shrub)
                                           (bucket-id shrub-near-l9-shrub)
                                           (bucket-id bucket0)
                                           (bucket-id bucket0)
                                           )
                                         *draw-index*
                                         )
                                     )
          (generic-init-buf s2-0 (new 'static 'gs-zbuf :zbp #x130 :psm (gs-psm ct24)))
          (generic-add-shrub-constants s2-0 #x5026b 60 61)
          (let ((a0-14 (+ (+ (-> *instance-shrub-work* current-shrub-near-packet) 5152) (the-as uint *instance-shrub-work*)))
                (v1-23 (-> s2-0 base))
                (a1-7 (+ (-> *instance-shrub-work* near-last) 176))
                )
            (let ((a2-13 (logior (logand (l.d (+ a0-14 96)) (the-as uint #x80000000ffffffff))
                                 (shr (shl (-> *instance-shrub-work* near-next) 33) 1)
                                 )
                         )
                  )
              (s.d! (+ a0-14 96) a2-13)
              )
            (let ((a2-14 (l.q (+ a0-14 96)))
                  (a3-18 (l.q (+ a0-14 112)))
                  (a0-15 (l.q (+ a0-14 128)))
                  )
              (set! (-> (the-as (pointer uint128) v1-23)) a2-14)
              (s.q! (+ v1-23 16) a3-18)
              (s.q! (+ v1-23 32) a0-15)
              )
            (let ((v1-24 (&+ v1-23 48)))
              (s.w! (+ a1-7 4) v1-24)
              (set! (-> s2-0 base) v1-24)
              )
            )
          )
        (let ((v1-34 *dma-mem-usage*))
          (when (nonzero? v1-34)
            (set! (-> v1-34 length) (max 28 (-> v1-34 length)))
            (set! (-> v1-34 data 27 name) "shrubbery")
            (+! (-> v1-34 data 27 count) 1)
            (+! (-> v1-34 data 27 used)
                (&- (-> *display* frames (-> *display* on-screen) global-buf base) (the-as uint s4-0))
                )
            (set! (-> v1-34 data 27 total) (-> v1-34 data 27 used))
            )
          )
        )
      )
    (when (nonzero? (-> *instance-shrub-work* near-trans-count))
      (let ((s4-1 (-> *display* frames (-> *display* on-screen) global-buf base)))
        (with-dma-buffer-add-bucket ((s2-1 (-> *display* frames (-> *display* on-screen) global-buf))
                                     (-> (new 'static 'array bucket-id 12
                                           (bucket-id shrub-near-trans-l0-shrub)
                                           (bucket-id shrub-near-trans-l1-shrub)
                                           (bucket-id shrub-near-trans-l2-shrub)
                                           (bucket-id shrub-near-trans-l3-shrub)
                                           (bucket-id shrub-near-trans-l4-shrub)
                                           (bucket-id shrub-near-trans-l5-shrub)
                                           (bucket-id shrub-near-trans-l6-shrub)
                                           (bucket-id shrub-near-trans-l7-shrub)
                                           (bucket-id shrub-near-trans-l8-shrub)
                                           (bucket-id shrub-near-trans-l9-shrub)
                                           (bucket-id bucket0)
                                           (bucket-id bucket0)
                                           )
                                         *draw-index*
                                         )
                                     )
          (generic-init-buf s2-1 (new 'static 'gs-zbuf :zbp #x130 :psm (gs-psm ct24)))
          (generic-add-shrub-constants s2-1 #x51001 124 125)
          (let ((a0-26
                  (+ (+ (-> *instance-shrub-work* current-shrub-near-trans-packet) 5152) (the-as uint *instance-shrub-work*))
                  )
                (v1-51 (-> s2-1 base))
                (a1-24 (+ (-> *instance-shrub-work* near-trans-last) 176))
                )
            (let ((a2-28 (logior (logand (l.d (+ a0-26 96)) (the-as uint #x80000000ffffffff))
                                 (shr (shl (-> *instance-shrub-work* near-trans-next) 33) 1)
                                 )
                         )
                  )
              (s.d! (+ a0-26 96) a2-28)
              )
            (let ((a2-29 (l.q (+ a0-26 96)))
                  (a3-27 (l.q (+ a0-26 112)))
                  (a0-27 (l.q (+ a0-26 128)))
                  )
              (set! (-> (the-as (pointer uint128) v1-51)) a2-29)
              (s.q! (+ v1-51 16) a3-27)
              (s.q! (+ v1-51 32) a0-27)
              )
            (let ((v1-52 (&+ v1-51 48)))
              (s.w! (+ a1-24 4) v1-52)
              (set! (-> s2-1 base) v1-52)
              )
            )
          )
        (let ((v1-62 *dma-mem-usage*))
          (when (nonzero? v1-62)
            (set! (-> v1-62 length) (max 28 (-> v1-62 length)))
            (set! (-> v1-62 data 27 name) "shrubbery")
            (+! (-> v1-62 data 27 count) 1)
            (+! (-> v1-62 data 27 used)
                (&- (-> *display* frames (-> *display* on-screen) global-buf base) (the-as uint s4-1))
                )
            (set! (-> v1-62 data 27 total) (-> v1-62 data 27 used))
            )
          )
        )
      )
    )
  (when (logtest? (vu1-renderer-mask shrubbery) (-> *display* vu1-enable-user))
    (let ((s4-2 (-> *display* frames (-> *display* on-screen) global-buf base)))
      (with-dma-buffer-add-bucket ((s2-2 (-> *display* frames (-> *display* on-screen) global-buf))
                                   (-> (new 'static 'array bucket-id 12
                                         (bucket-id shrub-l0-shrub)
                                         (bucket-id shrub-l1-shrub)
                                         (bucket-id shrub-l2-shrub)
                                         (bucket-id shrub-l3-shrub)
                                         (bucket-id shrub-l4-shrub)
                                         (bucket-id shrub-l5-shrub)
                                         (bucket-id shrub-l6-shrub)
                                         (bucket-id shrub-l7-shrub)
                                         (bucket-id shrub-l8-shrub)
                                         (bucket-id shrub-l9-shrub)
                                         (bucket-id bucket0)
                                         (bucket-id bucket0)
                                         )
                                       *draw-index*
                                       )
                                   )
        (shrub-init-frame s2-2 (new 'static 'gs-test
                                 :ate #x1
                                 :atst (gs-atest greater-equal)
                                 :aref #x26
                                 :zte #x1
                                 :ztst (gs-ztest greater-equal)
                                 )
                          )
        (let ((s1-0 (the-as prototype-bucket-shrub arg1)))
          (countdown (s0-0 arg0)
            (when (nonzero? (-> s1-0 count 1))
              (if (logtest? (-> s1-0 flags) (prototype-flags tpage-alpha))
                  (set! sv-16 (-> s1-0 geometry 2))
                  (set! sv-16 (-> s1-0 geometry 1))
                  )
              (set! sv-32 (-> s1-0 next 1))
              (if (logtest? (-> s1-0 flags) (prototype-flags tpage-alpha))
                  (set! sv-48 #x51001)
                  (set! sv-48 #x5026b)
                  )
              (set! sv-64 (&+ sv-16 32))
              (set! sv-80 0)
              (while (< sv-80 (-> (the-as prototype-shrubbery sv-16) length))
                (shrub-upload-model
                  (the-as shrubbery sv-64)
                  s2-2
                  (the-as int (-> *instance-shrub-work* start-bank (-> s1-0 mod-count 1)))
                  )
                (if (zero? sv-80)
                    (dma-buffer-add-gs-set s2-2 (test-1 sv-48))
                    )
                (let* ((v1-98 s2-2)
                       (a0-44 (-> v1-98 base))
                       )
                  (set! (-> (the-as (pointer uint64) a0-44)) (logior #x50000000 (shr (shl sv-32 33) 1)))
                  (s.w! (+ a0-44 8) 0)
                  (s.w! (+ a0-44 12) 0)
                  (set! (-> v1-98 base) (&+ a0-44 16))
                  )
                (set! sv-64 (&+ sv-64 32))
                (set! sv-80 (+ sv-80 1))
                )
              )
            (&+! s1-0 112)
            )
          )
        )
      (let ((v1-117 *dma-mem-usage*))
        (when (nonzero? v1-117)
          (set! (-> v1-117 length) (max 28 (-> v1-117 length)))
          (set! (-> v1-117 data 27 name) "shrubbery")
          (+! (-> v1-117 data 27 count) 1)
          (+! (-> v1-117 data 27 used)
              (&- (-> *display* frames (-> *display* on-screen) global-buf base) (the-as uint s4-2))
              )
          (set! (-> v1-117 data 27 total) (-> v1-117 data 27 used))
          )
        )
      )
    )
  (when (logtest? (vu1-renderer-mask shrub-vanish) (-> *display* vu1-enable-user))
    (let ((s4-3 (-> *display* frames (-> *display* on-screen) global-buf base)))
      (with-dma-buffer-add-bucket ((s2-3 (-> *display* frames (-> *display* on-screen) global-buf))
                                   (-> (new 'static 'array bucket-id 12
                                         (bucket-id shrub-vanish-l0-shrub)
                                         (bucket-id shrub-vanish-l1-shrub)
                                         (bucket-id shrub-vanish-l2-shrub)
                                         (bucket-id shrub-vanish-l3-shrub)
                                         (bucket-id shrub-vanish-l4-shrub)
                                         (bucket-id shrub-vanish-l5-shrub)
                                         (bucket-id shrub-vanish-l6-shrub)
                                         (bucket-id shrub-vanish-l7-shrub)
                                         (bucket-id shrub-vanish-l8-shrub)
                                         (bucket-id shrub-vanish-l9-shrub)
                                         (bucket-id bucket0)
                                         (bucket-id bucket0)
                                         )
                                       *draw-index*
                                       )
                                   )
        (shrub-init-frame s2-3 (new 'static 'gs-test
                                 :ate #x1
                                 :atst (gs-atest greater-equal)
                                 :aref #x26
                                 :afail #x1
                                 :zte #x1
                                 :ztst (gs-ztest greater-equal)
                                 )
                          )
        (let ((s1-1 (the-as prototype-bucket-shrub arg1)))
          (countdown (s0-1 arg0)
            (when (nonzero? (-> s1-1 count 2))
              (let ((v1-134 (-> s1-1 geometry 2)))
                (set! sv-96 (-> s1-1 next 2))
                (set! sv-112 (&+ v1-134 32))
                (set! sv-128 (-> (the-as prototype-shrubbery v1-134) length))
                )
              (while (nonzero? sv-128)
                (set! sv-128 (+ sv-128 -1))
                (shrub-upload-model
                  (the-as shrubbery sv-112)
                  s2-3
                  (the-as int (-> *instance-shrub-work* start-bank (-> s1-1 mod-count 2)))
                  )
                (let* ((v1-140 s2-3)
                       (a0-60 (-> v1-140 base))
                       )
                  (set! (-> (the-as (pointer uint64) a0-60)) (logior #x50000000 (shr (shl sv-96 33) 1)))
                  (s.w! (+ a0-60 8) 0)
                  (s.w! (+ a0-60 12) 0)
                  (set! (-> v1-140 base) (&+ a0-60 16))
                  )
                (set! sv-112 (&+ sv-112 32))
                )
              )
            (&+! s1-1 112)
            )
          )
        )
      (let ((v1-157 *dma-mem-usage*))
        (when (nonzero? v1-157)
          (set! (-> v1-157 length) (max 28 (-> v1-157 length)))
          (set! (-> v1-157 data 27 name) "shrubbery")
          (+! (-> v1-157 data 27 count) 1)
          (+! (-> v1-157 data 27 used)
              (&- (-> *display* frames (-> *display* on-screen) global-buf base) (the-as uint s4-3))
              )
          (set! (-> v1-157 data 27 total) (-> v1-157 data 27 used))
          )
        )
      )
    )
  (when (logtest? (vu1-renderer-mask billboard) (-> *display* vu1-enable-user))
    (let* ((s4-4 (-> *display* frames (-> *display* on-screen) global-buf base))
           (v1-171 (-> *display* frames (-> *display* on-screen) global-buf))
           (a2-70 (-> v1-171 base))
           )
      (dma-buffer-add-gs-set v1-171 (test-1 (new 'static 'gs-test
                                              :ate #x1
                                              :atst (gs-atest greater-equal)
                                              :aref #x80
                                              :afail #x1
                                              :zte #x1
                                              :ztst (gs-ztest greater-equal)
                                              )
                                            )
                             )
      (let ((a0-73 (-> v1-171 base)))
        (while (nonzero? arg0)
          (+! arg0 -1)
          (when (nonzero? (-> (the-as prototype-bucket-shrub arg1) count 3))
            (set! (-> *instance-shrub-work* adgif-tmpl dma-vif dma addr) (-> (the-as prototype-bucket-shrub arg1) next 3))
            (set! (-> (the-as (pointer uint128) a0-73)) (-> *instance-shrub-work* adgif-tmpl dma-vif quad))
            (let ((a1-91 (-> *instance-shrub-work* adgif-tmpl quad 1)))
              (s.q! (+ a0-73 16) a1-91)
              )
            (let ((a1-92 (the-as prototype-bucket-shrub (-> (the-as prototype-bucket-shrub arg1) geometry 3))))
              (let ((a3-46 (-> a1-92 dists quad)))
                (s.q! (+ a0-73 32) a3-46)
                )
              (let ((a3-47 (-> a1-92 rdists quad)))
                (s.q! (+ a0-73 48) a3-47)
                )
              (let ((a3-48 (-> a1-92 next-clear)))
                (s.q! (+ a0-73 64) a3-48)
                )
              (let ((a3-49 (-> a1-92 count-quad)))
                (s.q! (+ a0-73 80) a3-49)
                )
              (let ((a1-93 (-> a1-92 last-clear)))
                (s.q! (+ a0-73 96) a1-93)
                )
              )
            (&+! a0-73 112)
            (set! (-> (the-as prototype-bucket-shrub arg1) last 3 dma addr) (the-as int a0-73))
            )
          (set! arg1 (the-as (inline-array prototype-bucket-shrub) (&+ (the-as prototype-bucket-shrub arg1) 112)))
          )
        (set! (-> v1-171 base) a0-73)
        )
      (let* ((a3-54 (-> v1-171 base))
             (v0-12 (when (!= a2-70 a3-54)
                      (let ((a0-74 (-> v1-171 base)))
                        (set! (-> (the-as (pointer int64) a0-74)) #x20000000)
                        (s.w! (+ a0-74 8) 0)
                        (s.w! (+ a0-74 12) 0)
                        (set! (-> v1-171 base) (&+ a0-74 16))
                        )
                      (dma-bucket-insert-tag
                        (-> *display* frames (-> *display* on-screen) bucket-group)
                        (-> (new 'static 'array bucket-id 12
                              (bucket-id billboard-l0-shrub)
                              (bucket-id billboard-l1-shrub)
                              (bucket-id billboard-l2-shrub)
                              (bucket-id billboard-l3-shrub)
                              (bucket-id billboard-l4-shrub)
                              (bucket-id billboard-l5-shrub)
                              (bucket-id billboard-l6-shrub)
                              (bucket-id billboard-l7-shrub)
                              (bucket-id billboard-l8-shrub)
                              (bucket-id billboard-l9-shrub)
                              (bucket-id bucket0)
                              (bucket-id bucket0)
                              )
                            *draw-index*
                            )
                        a2-70
                        (the-as (pointer dma-tag) a3-54)
                        )
                      )
                    )
             )
        (let ((v1-179 *dma-mem-usage*))
          (when (nonzero? v1-179)
            (set! (-> v1-179 length) (max 34 (-> v1-179 length)))
            (set! (-> v1-179 data 33 name) "billboard")
            (+! (-> v1-179 data 33 count) 1)
            (+! (-> v1-179 data 33 used)
                (&- (-> *display* frames (-> *display* on-screen) global-buf base) (the-as uint s4-4))
                )
            (set! (-> v1-179 data 33 total) (-> v1-179 data 33 used))
            )
          )
        v0-12
        )
      )
    )
  )

;; definition for function draw-drawable-tree-instance-shrub
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defun draw-drawable-tree-instance-shrub ((arg0 drawable-tree-instance-shrub) (arg1 level))
  "Draw a shrub tree!"
  (local-vars (a0-4 int) (a0-6 int) (a0-11 int) (a0-13 int))
  (set! (-> *instance-shrub-work* texture-dists) (the-as uint (-> arg1 bsp shrub-closest)))
  (set! (-> *instance-shrub-work* near-last) (the-as uint 0))
  (set! (-> *instance-shrub-work* near-next) (the-as uint 0))
  (set! (-> *instance-shrub-work* near-count) (the-as uint 0))
  (set! (-> *instance-shrub-work* near-trans-last) (the-as uint 0))
  (set! (-> *instance-shrub-work* near-trans-next) (the-as uint 0))
  (set! (-> *instance-shrub-work* near-trans-count) (the-as uint 0))
  (set! (-> *instance-shrub-work* wind-vectors) (-> arg0 info wind-vectors))
  (set! (-> *instance-shrub-work* wait-to-spr) (the-as uint 0))
  (set! (-> *instance-shrub-work* wait-from-spr) (the-as uint 0))
  (when (logtest? (vu1-renderer-mask shrubbery shrub-near billboard shrub-vanish) (-> *display* vu1-enable-user))
    (let* ((v1-16 (-> arg0 info prototype-inline-array-shrub))
           (s5-0 (-> v1-16 length))
           (s4-0 (-> v1-16 data))
           )
      (countdown (a1-5 s5-0)
        (let ((a2-3 (-> v1-16 data a1-5)))
          (set! (-> a2-3 next-clear) (the-as uint128 0))
          (set! (-> a2-3 last-clear) (the-as uint128 0))
          (set! (-> a2-3 count-clear) (the-as uint 0))
          )
        0
        )
      (let ((v1-24 (-> *display* frames (-> *display* on-screen) global-buf)))
        (when (nonzero? (-> arg0 length))
          (let ((gp-0 (-> *display* frames (-> *display* on-screen) global-buf base)))
            (let* ((a1-16 (-> *perf-stats* data 44))
                   (a2-6 (-> a1-16 ctrl))
                   )
              (+! (-> a1-16 count) 1)
              (b! (zero? a2-6) cfg-7 :delay (nop!))
              (.mtc0 Perf 0)
              (.sync.l)
              (.sync.p)
              (.mtpc pcr0 0)
              (.mtpc pcr1 0)
              (.sync.l)
              (.sync.p)
              (.mtc0 Perf a2-6)
              )
            (.sync.l)
            (.sync.p)
            (label cfg-7)
            0
            (draw-inline-array-instance-shrub
              v1-24
              (&+ (-> arg0 data 0) 32)
              (-> (the-as drawable-group (-> arg0 data 0)) length)
              s4-0
              )
            (let ((v1-26 (-> *perf-stats* data 44)))
              (b! (zero? (-> v1-26 ctrl)) cfg-9 :delay (nop!))
              (.mtc0 Perf 0)
              (.sync.l)
              (.sync.p)
              (.mfpc a0-4 pcr0)
              (+! (-> v1-26 accum0) a0-4)
              (.mfpc a0-6 pcr1)
              (+! (-> v1-26 accum1) a0-6)
              )
            (label cfg-9)
            0
            (let* ((v1-29 (-> *perf-stats* data 45))
                   (a0-8 (-> v1-29 ctrl))
                   )
              (+! (-> v1-29 count) 1)
              (b! (zero? a0-8) cfg-11 :delay (nop!))
              (.mtc0 Perf 0)
              (.sync.l)
              (.sync.p)
              (.mtpc pcr0 0)
              (.mtpc pcr1 0)
              (.sync.l)
              (.sync.p)
              (.mtc0 Perf a0-8)
              )
            (.sync.l)
            (.sync.p)
            (label cfg-11)
            0
            (draw-prototype-inline-array-shrub s5-0 s4-0)
            (let ((v1-32 (-> *perf-stats* data 45)))
              (b! (zero? (-> v1-32 ctrl)) cfg-13 :delay (nop!))
              (.mtc0 Perf 0)
              (.sync.l)
              (.sync.p)
              (.mfpc a0-11 pcr0)
              (+! (-> v1-32 accum0) a0-11)
              (.mfpc a0-13 pcr1)
              (+! (-> v1-32 accum1) a0-13)
              )
            (label cfg-13)
            0
            (let ((v1-33 *dma-mem-usage*))
              (when (nonzero? v1-33)
                (set! (-> v1-33 length) (max 28 (-> v1-33 length)))
                (set! (-> v1-33 data 27 name) "shrubbery")
                (+! (-> v1-33 data 27 count) 1)
                (+! (-> v1-33 data 27 used)
                    (&- (-> *display* frames (-> *display* on-screen) global-buf base) (the-as uint gp-0))
                    )
                (set! (-> v1-33 data 27 total) (-> v1-33 data 27 used))
                )
              )
            )
          )
        )
      )
    (update-wait-stats
      (-> *perf-stats* data 44)
      (the-as uint 0)
      (-> *instance-shrub-work* wait-to-spr)
      (-> *instance-shrub-work* wait-from-spr)
      )
    )
  0
  (none)
  )

;; definition for method 10 of type drawable-tree-instance-shrub
;; WARN: Return type mismatch int vs none.
(defmethod draw ((this drawable-tree-instance-shrub))
  "Draw the drawable, and typically its children.
   This usually means adding stuff to a list to be drawn later, rather than expensive drawing here."
  (let ((v1-1 (-> *background-work* shrub-tree-count))
        (a1-3 (-> *level* draw-level *draw-index*))
        )
    (set! (-> *background-work* shrub-trees v1-1) this)
    (set! (-> *background-work* shrub-levels v1-1) a1-3)
    )
  (+! (-> *background-work* shrub-tree-count) 1)
  0
  (none)
  )

;; definition for method 15 of type drawable-tree-instance-shrub
(defmethod unpack-vis ((this drawable-tree-instance-shrub) (arg0 (pointer int8)) (arg1 (pointer int8)))
  arg1
  )

;; definition for method 13 of type drawable-tree-instance-shrub
;; WARN: Return type mismatch int vs none.
(defmethod collect-stats ((this drawable-tree-instance-shrub))
  "Collect triangle/perf statistics for rendering.
   This is only called when viewing stats.
   The vis-bits and culling registers are loaded during this time."
  (when (logtest? (vu1-renderer-mask shrubbery shrub-near billboard shrub-vanish) (-> *display* vu1-enable-user))
    (let* ((v1-4 (-> this info prototype-inline-array-shrub))
           (gp-0 (the-as object (-> v1-4 data)))
           )
      (countdown (s5-0 (-> v1-4 length))
        (when (logtest? (vu1-renderer-mask shrub-near) (-> *display* vu1-enable-user))
          (let ((v1-8 (-> (the-as prototype-bucket-shrub gp-0) count 0))
                (a1-2 (-> (the-as prototype-bucket-shrub gp-0) geometry 0))
                )
            (when (nonzero? v1-8)
              (let ((a0-4 (-> (the-as drawable-group a1-2) length)))
                (+! (-> *terrain-stats* shrub groups) 1)
                (+! (-> *terrain-stats* shrub fragments) (* a0-4 (the-as int v1-8)))
                )
              (+! (-> *terrain-stats* shrub instances) v1-8)
              )
            )
          )
        (when (logtest? (vu1-renderer-mask shrubbery) (-> *display* vu1-enable-user))
          (let ((s4-0 (-> (the-as prototype-bucket-shrub gp-0) count 1))
                (v1-13 (-> (the-as prototype-bucket-shrub gp-0) geometry 1))
                )
            (when (nonzero? s4-0)
              (let ((s3-0 (&+ v1-13 32))
                    (s2-0 (-> (the-as drawable-group v1-13) length))
                    )
                (+! (-> *terrain-stats* shrub groups) 1)
                (+! (-> *terrain-stats* shrub fragments) s2-0)
                (+! (-> *terrain-stats* shrub instances) s4-0)
                (while (nonzero? s2-0)
                  (+! s2-0 -1)
                  (let ((a0-17 (* (shrub-num-tris (the-as shrubbery s3-0)) s4-0))
                        (v1-25 (* (-> (the-as shrubbery s3-0) header data 2) s4-0))
                        )
                    (+! (-> *terrain-stats* shrub tris) a0-17)
                    (+! (-> *terrain-stats* shrub dverts) v1-25)
                    )
                  (&+! s3-0 32)
                  )
                )
              )
            )
          )
        (when (logtest? (vu1-renderer-mask shrub-vanish) (-> *display* vu1-enable-user))
          (let ((s4-1 (-> (the-as prototype-bucket-shrub gp-0) count 2))
                (v1-31 (-> (the-as prototype-bucket-shrub gp-0) geometry 2))
                )
            (when (nonzero? s4-1)
              (let ((s3-1 (&+ v1-31 32))
                    (s2-1 (-> (the-as drawable-group v1-31) length))
                    )
                (+! (-> *terrain-stats* trans-shrub groups) 1)
                (+! (-> *terrain-stats* trans-shrub fragments) s2-1)
                (+! (-> *terrain-stats* trans-shrub instances) s4-1)
                (while (nonzero? s2-1)
                  (+! s2-1 -1)
                  (let ((a0-30 (* (shrub-num-tris (the-as shrubbery s3-1)) s4-1))
                        (v1-43 (* (-> (the-as shrubbery s3-1) header data 2) s4-1))
                        )
                    (+! (-> *terrain-stats* trans-shrub tris) a0-30)
                    (+! (-> *terrain-stats* trans-shrub dverts) v1-43)
                    )
                  (&+! s3-1 32)
                  )
                )
              )
            )
          )
        (when (logtest? (vu1-renderer-mask billboard) (-> *display* vu1-enable-user))
          (let ((v1-49 (-> (the-as prototype-bucket-shrub gp-0) count 3)))
            (when (nonzero? v1-49)
              (+! (-> *terrain-stats* billboard groups) 1)
              (+! (-> *terrain-stats* billboard instances) v1-49)
              (+! (-> *terrain-stats* billboard tris) (* v1-49 2))
              (+! (-> *terrain-stats* billboard dverts) (* v1-49 4))
              )
            )
          )
        (set! gp-0 (-> (the-as (inline-array prototype-bucket-shrub) gp-0) 1))
        )
      )
    )
  0
  (none)
  )

;; definition of type dma-test
(deftype dma-test (structure)
  ((data  qword  101 :inline)
   )
  )

;; definition for method 3 of type dma-test
(defmethod inspect ((this dma-test))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'dma-test)
  (format #t "~1Tdata[101] @ #x~X~%" (-> this data))
  (label cfg-4)
  this
  )

;; definition for symbol *dma-test*, type dma-test
(define *dma-test* (new 'global 'dma-test))

;; definition of type dma-test-work
(deftype dma-test-work (structure)
  ((upload  dma-packet  :inline)
   (end     dma-packet  :inline)
   )
  )

;; definition for method 3 of type dma-test-work
(defmethod inspect ((this dma-test-work))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'dma-test-work)
  (format #t "~1Tupload: #<dma-packet @ #x~X>~%" (-> this upload))
  (format #t "~1Tend: #<dma-packet @ #x~X>~%" (-> this end))
  (label cfg-4)
  this
  )

;; definition for symbol *dma-test-work*, type dma-test-work
(define *dma-test-work*
  (new 'static 'dma-test-work
    :upload (new 'static 'dma-packet :dma (new 'static 'dma-tag :qwc #x20 :id (dma-tag-id ref)))
    :end (new 'static 'dma-packet :dma (new 'static 'dma-tag :id (dma-tag-id end)))
    )
  )

;; definition for function init-dma-test
;; INFO: Used lq/sq
;; WARN: Return type mismatch uint128 vs none.
;; ERROR: Failed store: (s.q! (+ v1-0 1616) v0-0) at op 29
(defun init-dma-test ()
  (let ((a0-0 *dma-test-work*)
        (v1-0 *dma-test*)
        )
    (let ((a1-6 (-> *display* frames (-> *display* on-screen) calc-buf base)))
      (dotimes (a2-1 100)
        (set! (-> a0-0 upload dma addr) (the-as int a1-6))
        (set! (-> v1-0 data a2-1 quad) (-> a0-0 upload quad))
        (&+! a1-6 256)
        )
      )
    (let ((v0-0 (-> a0-0 end quad)))
      (s.q! (+ v1-0 1616) v0-0)
      )
    )
  (none)
  )

;; failed to figure out what this is:
(init-dma-test)

;; definition for function dma-test-func
;; ERROR: function was not converted to expressions. Cannot decompile.

;; definition for function move-test-func
;; ERROR: function was not converted to expressions. Cannot decompile.




