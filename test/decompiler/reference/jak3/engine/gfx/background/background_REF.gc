;;-*-Lisp-*-
(in-package goal)

;; definition for symbol *background-work*, type background-work
(define *background-work* (new 'global 'background-work))

;; definition for symbol background-vu0-block, type vu-function
(define background-vu0-block (new 'static 'vu-function :length 59 :qlength 30))

;; definition for function background-upload-vu0
;; WARN: Return type mismatch int vs none.
(defun background-upload-vu0 ()
  "Upload VU0 functions for background. (believed unused?)"
  (upload-vu0-program background-vu0-block (&-> *background-work* wait-to-vu0))
  0
  (none)
  )

;; definition for function init-background
;; WARN: Return type mismatch int vs none.
(defun init-background ()
  "Reset lists of trees to draw for background rendering."
  (dotimes (v1-0 8)
    (set! (-> *background-work* tfrag-trees v1-0) #f)
    (set! (-> *background-work* tfrag-trans-trees v1-0) #f)
    (set! (-> *background-work* tfrag-water-trees v1-0) #f)
    )
  (set! (-> *background-work* tfrag-tree-count) 0)
  (set! (-> *background-work* tfrag-trans-tree-count) 0)
  (set! (-> *background-work* tfrag-water-tree-count) 0)
  (set! (-> *background-work* shrub-tree-count) 0)
  (set! (-> *background-work* tie-tree-count) 0)
  (set! (-> *background-work* wait-to-vu0) (the-as uint 0))
  0
  (none)
  )

;; definition for function upload-vis-bits
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defun upload-vis-bits ((arg0 level) (arg1 level) (arg2 bsp-header))
  "Upload vis data to the scratchpad."
  (let ((v1-2 (/ (+ (-> arg2 visible-list-length) 15) 16)))
    (let ((a0-1 (-> arg0 vis-bits))
          (a1-1 (the-as (pointer uinteger) (-> arg2 all-visible-list)))
          (a2-2 (the-as (pointer uint128) (+ #x3800 #x70000000)))
          )
      (b! (not *artist-flip-visible*) cfg-5 :delay (nop!))
      (nop!)
      (nop!)
      (label cfg-2)
      (let ((a3-2 (-> (the-as (pointer uint128) a0-1))))
        (&+! a0-1 16)
        (let ((t0-0 (-> (the-as (pointer uint128) a1-1) 0)))
          (set! a1-1 (&-> (the-as (pointer uint8) a1-1) 16))
          (nop!)
          (nop!)
          (let ((a3-3 (logxor a3-2 (the-as uint t0-0))))
            (+! v1-2 -1)
            (set! (-> a2-2 0) a3-3)
            )
          )
        )
      (set! a2-2 (&-> a2-2 1))
      (b! (> v1-2 0) cfg-2 :delay (nop!))
      0
      (b! #t cfg-8 :delay (nop!))
      (nop!)
      (label cfg-5)
      (nop!)
      (nop!)
      (label cfg-6)
      (let ((a1-2 (-> (the-as (pointer uint128) a0-1))))
        (&+! a0-1 16)
        (nop!)
        (+! v1-2 -1)
        (set! (-> a2-2 0) a1-2)
        )
      (set! a2-2 (&-> a2-2 1))
      )
    (b! (> v1-2 0) cfg-6 :delay (nop!))
    )
  0
  (label cfg-8)
  (none)
  )

;; definition for function set-background-regs!
;; ERROR: function was not converted to expressions. Cannot decompile.

;; definition for function set-tie-quard-planes!
;; INFO: Used lq/sq
;; WARN: Return type mismatch plane vs none.
(defun set-tie-quard-planes! ((arg0 level))
  "Set up TIE work guard planes."
  (cond
    ((logtest? (-> arg0 info level-flags) (level-flags use-camera-other))
     (set! (-> *instance-tie-work* guard-plane 0 quad) (-> *math-camera* guard-plane-other 0 quad))
     (set! (-> *instance-tie-work* guard-plane 1 quad) (-> *math-camera* guard-plane-other 1 quad))
     (set! (-> *instance-tie-work* guard-plane 2 quad) (-> *math-camera* guard-plane-other 2 quad))
     (set! (-> *instance-tie-work* guard-plane 3 quad) (-> *math-camera* guard-plane-other 3 quad))
     )
    (else
      (set! (-> *instance-tie-work* guard-plane 0 quad) (-> *math-camera* guard-plane 0 quad))
      (set! (-> *instance-tie-work* guard-plane 1 quad) (-> *math-camera* guard-plane 1 quad))
      (set! (-> *instance-tie-work* guard-plane 2 quad) (-> *math-camera* guard-plane 2 quad))
      (set! (-> *instance-tie-work* guard-plane 3 quad) (-> *math-camera* guard-plane 3 quad))
      )
    )
  (none)
  )

;; definition for function set-shrub-quard-planes!
;; INFO: Used lq/sq
;; WARN: Return type mismatch plane vs none.
(defun set-shrub-quard-planes! ((arg0 level))
  "Set shrub work guard planes."
  (cond
    ((logtest? (-> arg0 info level-flags) (level-flags use-camera-other))
     (set! (-> *instance-shrub-work* guard-plane 0 quad) (-> *math-camera* guard-plane-other 0 quad))
     (set! (-> *instance-shrub-work* guard-plane 1 quad) (-> *math-camera* guard-plane-other 1 quad))
     (set! (-> *instance-shrub-work* guard-plane 2 quad) (-> *math-camera* guard-plane-other 2 quad))
     (set! (-> *instance-shrub-work* guard-plane 3 quad) (-> *math-camera* guard-plane-other 3 quad))
     )
    (else
      (set! (-> *instance-shrub-work* guard-plane 0 quad) (-> *math-camera* guard-plane 0 quad))
      (set! (-> *instance-shrub-work* guard-plane 1 quad) (-> *math-camera* guard-plane 1 quad))
      (set! (-> *instance-shrub-work* guard-plane 2 quad) (-> *math-camera* guard-plane 2 quad))
      (set! (-> *instance-shrub-work* guard-plane 3 quad) (-> *math-camera* guard-plane 3 quad))
      )
    )
  (none)
  )

;; definition for function set-subdivide-settings!
(defun set-subdivide-settings! ((arg0 level))
  "Set subdivide settings from the level."
  (if *artist-use-menu-subdiv*
      (update-subdivide-settings! *subdivide-settings* *math-camera* 11)
      (update-subdivide-settings! *subdivide-settings* *math-camera* (-> arg0 index))
      )
  (none)
  )

;; definition for function finish-background
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
;; WARN: Function finish-background has a return type of none, but the expression builder found a return statement.
(defun finish-background ()
  "Run all renderers for background data added."
  (if (get-menu-mode *blit-displays-work*)
      (return #f)
      )
  (when (not (paused?))
    (flush-cache 0)
    (dotimes (gp-0 (-> *level* length))
      (let ((v1-8 (-> *level* level gp-0)))
        (when (= (-> v1-8 status) 'active)
          (-> v1-8 bsp wind-array)
          (if (nonzero? (-> v1-8 bsp wind-array-length))
              (level-update-wind *wind-work*)
              )
          )
        )
      )
    )
  (background-upload-vu0)
  (dotimes (v1-14 (-> *level* length))
    (let ((a0-12 (-> *level* level v1-14)))
      (when (= (-> a0-12 status) 'active)
        (let ((a0-13 (-> a0-12 bsp)))
          (when (nonzero? (-> a0-13 tfrag-masks))
            (dotimes (a1-7 (-> a0-13 tfrag-masks length))
              (set! (-> a0-13 tfrag-closest a1-7) 4095996000.0)
              )
            )
          (when (nonzero? (-> a0-13 shrub-masks))
            (dotimes (a1-12 (-> a0-13 shrub-masks length))
              (set! (-> a0-13 shrub-closest a1-12) 4095996000.0)
              )
            )
          (when (nonzero? (-> a0-13 alpha-masks))
            (dotimes (a1-17 (-> a0-13 alpha-masks length))
              (set! (-> a0-13 alpha-closest a1-17) 4095996000.0)
              )
            )
          (when (nonzero? (-> a0-13 water-masks))
            (dotimes (a1-22 (-> a0-13 water-masks length))
              (set! (-> a0-13 water-closest a1-22) 4095996000.0)
              )
            )
          )
        )
      )
    )
  (when (nonzero? (-> *background-work* shrub-tree-count))
    (when *debug-segment*
      (let ((gp-1 (-> *display* frames (-> *display* on-screen) profile-array data 0))
            (v1-27 'shrubbery)
            (s5-0 *profile-shrubbery-color*)
            )
        (when (and *dproc* *debug-segment*)
          (let ((s4-0 (-> gp-1 data (-> gp-1 count))))
            (let ((s3-0 (-> gp-1 base-time)))
              (set! (-> s4-0 name) v1-27)
              (set! (-> s4-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-0))))
              )
            (set! (-> s4-0 depth) (the-as uint (-> gp-1 depth)))
            (set! (-> s4-0 color) s5-0)
            (set! (-> gp-1 segment (-> gp-1 depth)) s4-0)
            )
          (set! (-> gp-1 count) (min 1023 (+ (-> gp-1 count) 1)))
          (+! (-> gp-1 depth) 1)
          (set! (-> gp-1 max-depth) (max (-> gp-1 max-depth) (-> gp-1 depth)))
          )
        )
      0
      )
    (dotimes (gp-2 (-> *background-work* shrub-tree-count))
      (set! *draw-index* (-> *background-work* shrub-levels gp-2 draw-index))
      (flush-cache 0)
      (let ((s5-1 (-> *background-work* shrub-trees gp-2))
            (s4-1 (-> *background-work* shrub-levels gp-2))
            )
        (if (nonzero? (-> s5-1 colors-added))
            (time-of-day-interp-colors
              (-> *instance-shrub-work* colors)
              (the-as uint (-> s5-1 colors-added))
              (-> s4-1 mood-context)
              )
            )
        (set-background-regs! s4-1)
        (set-shrub-quard-planes! s4-1)
        (draw-drawable-tree-instance-shrub s5-1 s4-1)
        )
      )
    (when *debug-segment*
      (let ((gp-3 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
        (when (and *dproc* *debug-segment*)
          (let* ((v1-68 (+ (-> gp-3 depth) -1))
                 (s5-2 (-> gp-3 segment v1-68))
                 (s4-2 (-> gp-3 base-time))
                 )
            (when (>= v1-68 0)
              (set! (-> s5-2 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-2))))
              (+! (-> gp-3 depth) -1)
              )
            )
          )
        )
      0
      )
    )
  (let ((gp-4 (the-as level #f)))
    (when (or (nonzero? (-> *background-work* tfrag-tree-count))
              (nonzero? (-> *background-work* tfrag-trans-tree-count))
              (nonzero? (-> *background-work* tfrag-water-tree-count))
              )
      (let ((s5-5 (max
                    (max (-> *background-work* tfrag-tree-count) (-> *background-work* tfrag-trans-tree-count))
                    (-> *background-work* tfrag-water-tree-count)
                    )
                  )
            (s4-3 (the-as time-of-day-palette #f))
            )
        (when *debug-segment*
          (let ((s3-1 (-> *display* frames (-> *display* on-screen) profile-array data 0))
                (v1-94 'tfrag)
                (s2-0 *profile-tfrag-color*)
                )
            (when (and *dproc* *debug-segment*)
              (let ((s1-0 (-> s3-1 data (-> s3-1 count))))
                (let ((s0-0 (-> s3-1 base-time)))
                  (set! (-> s1-0 name) v1-94)
                  (set! (-> s1-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s0-0))))
                  )
                (set! (-> s1-0 depth) (the-as uint (-> s3-1 depth)))
                (set! (-> s1-0 color) s2-0)
                (set! (-> s3-1 segment (-> s3-1 depth)) s1-0)
                )
              (set! (-> s3-1 count) (min 1023 (+ (-> s3-1 count) 1)))
              (+! (-> s3-1 depth) 1)
              (set! (-> s3-1 max-depth) (max (-> s3-1 max-depth) (-> s3-1 depth)))
              )
            )
          0
          )
        (dotimes (s3-2 s5-5)
          (let ((s2-1 (-> *background-work* tfrag-trees s3-2)))
            (when s2-1
              (let ((s1-1 (-> *background-work* tfrag-levels s3-2)))
                (let ((a2-23 (-> s1-1 bsp))
                      (s0-1 (-> s2-1 time-of-day-pal))
                      )
                  (upload-vis-bits s1-1 gp-4 a2-23)
                  (set-subdivide-settings! s1-1)
                  (when (not (or (zero? s0-1) (= s4-3 s0-1)))
                    (flush-cache 0)
                    (time-of-day-interp-colors-scratch (the-as (pointer rgba) (+ 6144 #x70000000)) s0-1 (-> s1-1 mood-context))
                    (set! s4-3 s0-1)
                    )
                  )
                (set! *draw-index* (-> s1-1 draw-index))
                (set! (-> *tfrag-work* min-dist z) 4095996000.0)
                (set-background-regs! s1-1)
                )
              (draw-drawable-tree-tfrag s2-1)
              (set! (-> *level* draw-level *draw-index* closest-object 0) (-> *tfrag-work* min-dist z))
              )
            )
          (let ((s2-2 (-> *background-work* tfrag-trans-trees s3-2)))
            (when s2-2
              (let ((s1-2 (-> *background-work* tfrag-trans-levels s3-2)))
                (let ((a2-25 (-> s1-2 bsp))
                      (s0-2 (-> s2-2 time-of-day-pal))
                      )
                  (upload-vis-bits s1-2 gp-4 a2-25)
                  (set-subdivide-settings! s1-2)
                  (when (not (or (zero? s0-2) (= s4-3 s0-2)))
                    (flush-cache 0)
                    (time-of-day-interp-colors-scratch (the-as (pointer rgba) (+ 6144 #x70000000)) s0-2 (-> s1-2 mood-context))
                    (set! s4-3 s0-2)
                    )
                  )
                (set! *draw-index* (-> s1-2 draw-index))
                (set! (-> *tfrag-work* min-dist z) 4095996000.0)
                (set-background-regs! s1-2)
                )
              (draw-drawable-tree-tfrag-trans s2-2)
              (set! (-> *level* draw-level *draw-index* closest-object 3) (-> *tfrag-work* min-dist z))
              )
            )
          (let ((s2-3 (-> *background-work* tfrag-water-trees s3-2)))
            (when s2-3
              (let ((s1-3 (-> *background-work* tfrag-water-levels s3-2)))
                (let ((a2-27 (-> s1-3 bsp))
                      (s0-3 (-> s2-3 time-of-day-pal))
                      )
                  (upload-vis-bits s1-3 gp-4 a2-27)
                  (set-subdivide-settings! s1-3)
                  (when (not (or (zero? s0-3) (= s4-3 s0-3)))
                    (flush-cache 0)
                    (time-of-day-interp-colors-scratch (the-as (pointer rgba) (+ 6144 #x70000000)) s0-3 (-> s1-3 mood-context))
                    (set! s4-3 s0-3)
                    )
                  )
                (set! *draw-index* (-> s1-3 draw-index))
                (set! (-> *tfrag-work* min-dist z) 4095996000.0)
                (set-background-regs! s1-3)
                )
              (draw-drawable-tree-tfrag-water s2-3)
              (set! (-> *level* draw-level *draw-index* closest-object 4) (-> *tfrag-work* min-dist z))
              )
            )
          )
        )
      (when *debug-segment*
        (let ((s5-6 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
          (when (and *dproc* *debug-segment*)
            (let* ((v1-174 (+ (-> s5-6 depth) -1))
                   (s4-4 (-> s5-6 segment v1-174))
                   (s3-3 (-> s5-6 base-time))
                   )
              (when (>= v1-174 0)
                (set! (-> s4-4 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-3))))
                (+! (-> s5-6 depth) -1)
                )
              )
            )
          )
        0
        )
      )
    (when (nonzero? (-> *background-work* tie-tree-count))
      (set! (-> *instance-tie-work* tod-env-color quad) (-> *time-of-day-context* current-env-color quad))
      (when *debug-segment*
        (let ((s5-7 (-> *display* frames (-> *display* on-screen) profile-array data 0))
              (v1-192 'tie)
              (s4-5 *profile-tie-color*)
              )
          (when (and *dproc* *debug-segment*)
            (let ((s3-4 (-> s5-7 data (-> s5-7 count))))
              (let ((s2-4 (-> s5-7 base-time)))
                (set! (-> s3-4 name) v1-192)
                (set! (-> s3-4 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s2-4))))
                )
              (set! (-> s3-4 depth) (the-as uint (-> s5-7 depth)))
              (set! (-> s3-4 color) s4-5)
              (set! (-> s5-7 segment (-> s5-7 depth)) s3-4)
              )
            (set! (-> s5-7 count) (min 1023 (+ (-> s5-7 count) 1)))
            (+! (-> s5-7 depth) 1)
            (set! (-> s5-7 max-depth) (max (-> s5-7 max-depth) (-> s5-7 depth)))
            )
          )
        0
        )
      (dotimes (s5-8 (-> *background-work* tie-tree-count))
        (let ((s4-6 (-> *background-work* tie-levels s5-8)))
          (let ((a2-29 (-> s4-6 bsp)))
            (when (!= s4-6 gp-4)
              (set! (-> *instance-tie-work* min-dist x) 4095996000.0)
              (upload-vis-bits s4-6 gp-4 a2-29)
              (set-subdivide-settings! s4-6)
              (set! gp-4 s4-6)
              )
            )
          (set! *draw-index* (-> s4-6 draw-index))
          (set! (-> *prototype-tie-work* mood) (-> s4-6 mood-context))
          (set-background-regs! s4-6)
          (set-tie-quard-planes! s4-6)
          (tie-scissor-make-perspective-matrix
            (-> *instance-tie-work* tie-scissor-perspective-matrix)
            (if (logtest? (-> s4-6 info level-flags) (level-flags use-camera-other))
                (-> *math-camera* camera-temp-other)
                (-> *math-camera* camera-temp)
                )
            )
          (draw-drawable-tree-instance-tie (-> *background-work* tie-trees s5-8) s4-6)
          )
        (set! (-> *background-work* tie-generic s5-8) (the-as basic (-> *prototype-tie-work* generic-next)))
        (set! (-> *background-work* tie-generic-trans s5-8)
              (the-as basic (-> *prototype-tie-work* generic-trans-next))
              )
        )
      (when *debug-segment*
        (let ((gp-5 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
          (when (and *dproc* *debug-segment*)
            (let* ((v1-240 (+ (-> gp-5 depth) -1))
                   (s5-9 (-> gp-5 segment v1-240))
                   (s4-7 (-> gp-5 base-time))
                   )
              (when (>= v1-240 0)
                (set! (-> s5-9 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-7))))
                (+! (-> gp-5 depth) -1)
                )
              )
            )
          )
        0
        )
      )
    )
  (let ((a0-116 (-> *display* frames (-> *display* on-screen) global-buf)))
    (when (< (-> a0-116 real-buffer-end) (the-as int (-> a0-116 base)))
      (break!)
      0
      )
    )
  (dotimes (gp-6 (-> *level* draw-level-count))
    (let ((s5-10 (-> *level* draw-level gp-6)))
      (when (and s5-10 (= (-> s5-10 status) 'active))
        (when (and (nonzero? (-> s5-10 bsp hfrag-drawable)) (= (-> s5-10 display?) 'display))
          (when *debug-segment*
            (let ((s4-8 (-> *display* frames (-> *display* on-screen) profile-array data 0))
                  (v1-271 'hfrag)
                  (s3-5 *profile-hfrag-color*)
                  )
              (when (and *dproc* *debug-segment*)
                (let ((s2-5 (-> s4-8 data (-> s4-8 count))))
                  (let ((s1-4 (-> s4-8 base-time)))
                    (set! (-> s2-5 name) v1-271)
                    (set! (-> s2-5 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s1-4))))
                    )
                  (set! (-> s2-5 depth) (the-as uint (-> s4-8 depth)))
                  (set! (-> s2-5 color) s3-5)
                  (set! (-> s4-8 segment (-> s4-8 depth)) s2-5)
                  )
                (set! (-> s4-8 count) (min 1023 (+ (-> s4-8 count) 1)))
                (+! (-> s4-8 depth) 1)
                (set! (-> s4-8 max-depth) (max (-> s4-8 max-depth) (-> s4-8 depth)))
                )
              )
            0
            )
          (set! *draw-index* (-> s5-10 draw-index))
          (let ((s4-9 (-> *display* frames (-> *display* on-screen) global-buf base)))
            (draw (-> s5-10 bsp hfrag-drawable))
            (let ((v1-293 *dma-mem-usage*))
              (when (nonzero? v1-293)
                (set! (-> v1-293 length) (max 44 (-> v1-293 length)))
                (set! (-> v1-293 data 43 name) "hfragment")
                (+! (-> v1-293 data 43 count) 1)
                (+! (-> v1-293 data 43 used)
                    (&- (-> *display* frames (-> *display* on-screen) global-buf base) (the-as uint s4-9))
                    )
                (set! (-> v1-293 data 43 total) (-> v1-293 data 43 used))
                )
              )
            )
          (when *debug-segment*
            (let ((s5-11 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
              (when (and *dproc* *debug-segment*)
                (let* ((v1-305 (+ (-> s5-11 depth) -1))
                       (s4-10 (-> s5-11 segment v1-305))
                       (s3-6 (-> s5-11 base-time))
                       )
                  (when (>= v1-305 0)
                    (set! (-> s4-10 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-6))))
                    (+! (-> s5-11 depth) -1)
                    )
                  )
                )
              )
            0
            )
          )
        )
      )
    )
  (let ((a0-139 (-> *display* frames (-> *display* on-screen) global-buf)))
    (when (< (-> a0-139 real-buffer-end) (the-as int (-> a0-139 base)))
      (break!)
      0
      )
    )
  (dotimes (v1-323 (-> *level* length))
    (let ((a1-55 (-> *level* level v1-323)))
      (when (= (-> a1-55 status) 'active)
        (let ((a0-145 (-> a1-55 bsp)))
          (when (nonzero? (-> a0-145 tfrag-masks))
            (let ((a2-43 (-> a1-55 texture-mask)))
              (dotimes (a3-5 (-> a0-145 tfrag-masks length))
                (let ((f0-12 (* (-> a0-145 tfrag-closest a3-5) (-> *math-camera* fov-correction-factor))))
                  (when (!= f0-12 4095996000.0)
                    (let ((t0-8 (-> a0-145 tfrag-masks data a3-5)))
                      (dotimes (t1-2 3)
                        (when (or (= t1-2 2) (>= f0-12 (-> t0-8 data t1-2 dist)))
                          (dotimes (t2-5 3)
                            (logior!
                              (-> (&-> a2-43 0 mask data t2-5) 0)
                              (-> (the-as (pointer int32) (+ (* t2-5 4) (the-as int t0-8) (* t1-2 16))) 0)
                              )
                            )
                          (goto cfg-176)
                          )
                        )
                      )
                    )
                  )
                (label cfg-176)
                )
              )
            )
          (when (nonzero? (-> a0-145 shrub-masks))
            (let ((a2-48 (-> a1-55 texture-mask 2)))
              (dotimes (a3-6 (-> a0-145 shrub-masks length))
                (let ((f0-14 (* (-> a0-145 shrub-closest a3-6) (-> *math-camera* fov-correction-factor))))
                  (when (!= f0-14 4095996000.0)
                    (let ((t0-24 (-> a0-145 shrub-masks data a3-6)))
                      (dotimes (t1-5 3)
                        (when (or (= t1-5 2) (>= f0-14 (-> t0-24 data t1-5 dist)))
                          (dotimes (t2-11 3)
                            (logior!
                              (-> a2-48 mask data t2-11)
                              (-> (the-as (pointer int32) (+ (* t2-11 4) (the-as int t0-24) (* t1-5 16))) 0)
                              )
                            )
                          (goto cfg-196)
                          )
                        )
                      )
                    )
                  )
                (label cfg-196)
                )
              )
            )
          (when (nonzero? (-> a0-145 alpha-masks))
            (let ((a2-53 (-> a1-55 texture-mask 3)))
              (dotimes (a3-7 (-> a0-145 alpha-masks length))
                (let ((f0-16 (* (-> a0-145 alpha-closest a3-7) (-> *math-camera* fov-correction-factor))))
                  (when (!= f0-16 4095996000.0)
                    (let ((t0-40 (-> a0-145 alpha-masks data a3-7)))
                      (dotimes (t1-8 3)
                        (when (or (= t1-8 2) (>= f0-16 (-> t0-40 data t1-8 dist)))
                          (dotimes (t2-17 3)
                            (logior!
                              (-> a2-53 mask data t2-17)
                              (-> (the-as (pointer int32) (+ (* t2-17 4) (the-as int t0-40) (* t1-8 16))) 0)
                              )
                            )
                          (goto cfg-216)
                          )
                        )
                      )
                    )
                  )
                (label cfg-216)
                )
              )
            )
          (when (nonzero? (-> a0-145 water-masks))
            (let ((a1-56 (-> a1-55 texture-mask 4)))
              (dotimes (a2-58 (-> a0-145 water-masks length))
                (let ((f0-18 (* (-> a0-145 water-closest a2-58) (-> *math-camera* fov-correction-factor))))
                  (when (!= f0-18 4095996000.0)
                    (let ((a3-16 (-> a0-145 water-masks data a2-58)))
                      (dotimes (t0-50 3)
                        (when (or (= t0-50 2) (>= f0-18 (-> a3-16 data t0-50 dist)))
                          (dotimes (t1-14 3)
                            (logior!
                              (-> a1-56 mask data t1-14)
                              (-> (the-as (pointer int32) (+ (* t1-14 4) (the-as int a3-16) (* t0-50 16))) 0)
                              )
                            )
                          (goto cfg-236)
                          )
                        )
                      )
                    )
                  )
                (label cfg-236)
                )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )
