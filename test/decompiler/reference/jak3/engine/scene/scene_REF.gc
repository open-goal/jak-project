;;-*-Lisp-*-
(in-package goal)

;; definition of type scene-stage
(deftype scene-stage (process-hidden)
  ()
  )

;; definition for method 3 of type scene-stage
(defmethod inspect ((this scene-stage))
  (when (not this)
    (set! this this)
    (goto cfg-68)
    )
  (format #t "[~8x] ~A~%" this (-> this type))
  (format #t "~1Tname: ~A~%" (-> this name))
  (format #t "~1Tmask: #x~X : (process-mask " (-> this mask))
  (let ((s5-0 (-> this mask)))
    (if (= (logand s5-0 (process-mask process-tree)) (process-mask process-tree))
        (format #t "process-tree ")
        )
    (if (= (logand s5-0 (process-mask target)) (process-mask target))
        (format #t "target ")
        )
    (if (= (logand (process-mask collectable) s5-0) (process-mask collectable))
        (format #t "collectable ")
        )
    (if (= (logand (process-mask projectile) s5-0) (process-mask projectile))
        (format #t "projectile ")
        )
    (if (= (logand s5-0 (process-mask sleep-code)) (process-mask sleep-code))
        (format #t "sleep-code ")
        )
    (if (= (logand s5-0 (process-mask actor-pause)) (process-mask actor-pause))
        (format #t "actor-pause ")
        )
    (if (= (logand (process-mask metalhead) s5-0) (shl #x8000 16))
        (format #t "metalhead ")
        )
    (if (= (logand (process-mask bot) s5-0) (process-mask bot))
        (format #t "bot ")
        )
    (if (= (logand (process-mask vehicle) s5-0) (process-mask vehicle))
        (format #t "vehicle ")
        )
    (if (= (logand (process-mask enemy) s5-0) (process-mask enemy))
        (format #t "enemy ")
        )
    (if (= (logand (process-mask entity) s5-0) (process-mask entity))
        (format #t "entity ")
        )
    (if (= (logand s5-0 (process-mask heap-shrunk)) (process-mask heap-shrunk))
        (format #t "heap-shrunk ")
        )
    (if (= (logand (process-mask sidekick) s5-0) (process-mask sidekick))
        (format #t "sidekick ")
        )
    (if (= (logand s5-0 (process-mask going)) (process-mask going))
        (format #t "going ")
        )
    (if (= (logand s5-0 (process-mask execute)) (process-mask execute))
        (format #t "execute ")
        )
    (if (= (logand (process-mask civilian) s5-0) (process-mask civilian))
        (format #t "civilian ")
        )
    (if (= (logand (process-mask death) s5-0) (process-mask death))
        (format #t "death ")
        )
    (if (= (logand (process-mask guard) s5-0) (process-mask guard))
        (format #t "guard ")
        )
    (if (= (logand s5-0 (process-mask no-kill)) (process-mask no-kill))
        (format #t "no-kill ")
        )
    (if (= (logand (process-mask kg-robot) s5-0) (process-mask kg-robot))
        (format #t "kg-robot ")
        )
    (if (= (logand (process-mask platform) s5-0) (process-mask platform))
        (format #t "platform ")
        )
    (if (= (logand s5-0 (process-mask freeze)) (process-mask freeze))
        (format #t "freeze ")
        )
    (if (= (logand s5-0 (process-mask sleep)) (process-mask sleep))
        (format #t "sleep ")
        )
    (if (= (logand s5-0 (process-mask progress)) (process-mask progress))
        (format #t "progress ")
        )
    (if (= (logand s5-0 (process-mask menu)) (process-mask menu))
        (format #t "menu ")
        )
    (if (= (logand (process-mask camera) s5-0) (process-mask camera))
        (format #t "camera ")
        )
    (if (= (logand (process-mask ambient) s5-0) (process-mask ambient))
        (format #t "ambient ")
        )
    (if (= (logand s5-0 (process-mask dark-effect)) (process-mask dark-effect))
        (format #t "dark-effect ")
        )
    (if (= (logand (process-mask crate) s5-0) (process-mask crate))
        (format #t "crate ")
        )
    (if (= (logand s5-0 (process-mask kernel-run)) (process-mask kernel-run))
        (format #t "kernel-run ")
        )
    (if (= (logand s5-0 (process-mask movie)) (process-mask movie))
        (format #t "movie ")
        )
    (if (= (logand s5-0 (process-mask pause)) (process-mask pause))
        (format #t "pause ")
        )
    )
  (format #t ")~%")
  (format #t "~1Tclock: ~A~%" (-> this clock))
  (format #t "~1Tparent: #x~X~%" (-> this parent))
  (format #t "~1Tbrother: #x~X~%" (-> this brother))
  (format #t "~1Tchild: #x~X~%" (-> this child))
  (format #t "~1Tppointer: #x~X~%" (-> this ppointer))
  (format #t "~1Tself: ~A~%" (-> this self))
  (format #t "~1Tpool: ~A~%" (-> this pool))
  (format #t "~1Tstatus: ~A~%" (-> this status))
  (format #t "~1Tpid: ~D~%" (-> this pid))
  (format #t "~1Tmain-thread: ~A~%" (-> this main-thread))
  (format #t "~1Ttop-thread: ~A~%" (-> this top-thread))
  (format #t "~1Tentity: ~A~%" (-> this entity))
  (format #t "~1Tlevel: ~A~%" (-> this level))
  (format #t "~1Tstate: ~A~%" (-> this state))
  (format #t "~1Tprev-state: ~A~%" (-> this prev-state))
  (format #t "~1Tnext-state: ~A~%" (-> this next-state))
  (format #t "~1Tstate-stack: ~A~%" (-> this state-stack))
  (format #t "~1Ttrans-hook: ~A~%" (-> this trans-hook))
  (format #t "~1Tpost-hook: ~A~%" (-> this post-hook))
  (format #t "~1Tevent-hook: ~A~%" (-> this event-hook))
  (format #t "~1Tallocated-length: ~D~%" (-> this allocated-length))
  (format #t "~1Theap-base: #x~X~%" (-> this heap-base))
  (format #t "~1Theap-top: #x~X~%" (-> this heap-top))
  (format #t "~1Theap-cur: #x~X~%" (-> this heap-cur))
  (format #t "~1Tstack-frame-top: ~A~%" (-> this stack-frame-top))
  (format #t "~1Theap: #<kheap @ #x~X>~%" (&-> this heap-base))
  (format #t "~1Tconnection-list: ~`connectable`P~%" (-> this connection-list))
  (format #t "~1Tstack[0] @ #x~X~%" (-> this stack))
  (label cfg-68)
  this
  )

;; definition for method 2 of type scene
(defmethod print ((this scene))
  (format #t "#<scene ~A ~A @ #x~X>" (-> this art-group) (-> this anim) this)
  this
  )

;; definition for method 16 of type scene
(defmethod init-spool-by-scene! ((this scene) (arg0 spool-anim))
  (set! (-> arg0 name) (-> this anim))
  (set! (-> arg0 anim-name) (-> this anim))
  (set! (-> arg0 parts) (-> this parts))
  (set! (-> arg0 command-list) (-> this command-list))
  arg0
  )

;; definition for function scene-decode-continue
;; WARN: Return type mismatch basic vs continue-point.
(defun scene-decode-continue ((arg0 basic))
  (the-as continue-point (cond
                           ((not arg0)
                            (the-as basic #f)
                            )
                           ((= (-> arg0 type) continue-point)
                            arg0
                            )
                           ((= (-> arg0 type) string)
                            (get-continue-by-name *game-info* (the-as string arg0))
                            )
                           (else
                             (the-as basic #f)
                             )
                           )
          )
  )

;; definition for method 9 of type scene-actor
;; INFO: Used lq/sq
(defmethod setup-manipy-for-scene! ((this scene-actor) (arg0 scene-player))
  (local-vars (s4-0 (pointer process)) (sv-96 process))
  (let ((s2-0 (if (-> this level)
                  (level-get *level* (-> this level))
                  (-> *level* level-default)
                  )
              )
        )
    (cond
      ((not s2-0)
       (-> *level* level-default)
       (set! s4-0 (the-as (pointer process) #f))
       (goto cfg-260)
       )
      ((= (-> s2-0 status) 'reserved)
       )
      ((!= (-> s2-0 status) 'active)
       (set! s4-0 (the-as (pointer process) #f))
       (goto cfg-260)
       )
      )
    (let* ((s4-1 (art-group-get-by-name *level* (-> this art-group) (the-as (pointer level) #f)))
           (s3-0 (if (type? s4-1 skeleton-group)
                     s4-1
                     )
                 )
           (s0-0 (-> arg0 level))
           (s1-0
             (cond
               ((or (string= (-> this name) "jak-highres")
                    (string= (-> this name) "jak-highres-prison")
                    (string= (-> this name) "darkjak-highres")
                    )
                'jakb
                )
               ((string= (-> this name) "jakc-highres")
                'jakc
                )
               )
             )
           )
      (set! (-> arg0 level) #f)
      (set! s4-0
            (when s3-0
              (let ((s2-1 (if (and (nonzero? (-> s2-0 entity)) (> (-> s2-0 entity length) 0))
                              (-> s2-0 entity data 0 entity)
                              (-> arg0 entity)
                              )
                          )
                    )
                (set! sv-96 (get-process *default-dead-pool* manipy #x20000 0))
                (set! s4-0 (when sv-96
                             (let ((t9-8 (method-of-type manipy activate)))
                               (t9-8 (the-as manipy sv-96) arg0 (-> this name) (the-as pointer #x70004000))
                               )
                             (run-now-in-process
                               sv-96
                               manipy-init
                               (-> arg0 root trans)
                               s2-1
                               s3-0
                               #f
                               (if (and s1-0 (logtest? (game-secrets big-head little-head) (-> *game-info* secrets)))
                                   1
                                   0
                                   )
                               )
                             (-> sv-96 ppointer)
                             )
                      )
                (set! (-> arg0 level) s0-0)
                (send-event (ppointer->process s4-0) 'anim-mode 'clone-anim)
                (send-event (ppointer->process s4-0) 'blend-shape #t)
                (send-event (ppointer->process s4-0) 'prefix (-> this prefix))
                (cond
                  ((zero? (-> this light-index))
                   (if (zero? (-> (the-as skeleton-group s3-0) light-index))
                       (send-event (ppointer->process s4-0) 'light-index 80)
                       )
                   )
                  (else
                    (send-event (ppointer->process s4-0) 'light-index (* (-> this light-index) 8))
                    )
                  )
                (send-event (ppointer->process s4-0) 'shadow-disable-smooth #t)
                (if (nonzero? (-> this shadow-mask))
                    (send-event (ppointer->process s4-0) 'shadow-mask (* (-> this shadow-mask) 8))
                    )
                (if (nonzero? (-> this shadow-values))
                    (send-event (ppointer->process s4-0) 'shadow-values (* (-> this shadow-values) 8))
                    )
                (if (and s4-0 (not (logtest? (-> this flags) 1)) (nonzero? (-> (the-as process-drawable (-> s4-0 0)) draw)))
                    (logior! (-> (the-as process-drawable (-> s4-0 0)) draw status) (draw-control-status no-draw-bounds))
                    )
                (if (-> this shadow-volume-joint)
                    (send-event (ppointer->process s4-0) 'shadow-volume (-> this shadow-volume-joint) (-> this shadow-flags))
                    )
                (when (or (nonzero? (-> this draw-seg)) (nonzero? (-> this no-draw-seg)))
                  (send-event (ppointer->process s4-0) 'segment 0 (* (-> this no-draw-seg) 8))
                  (send-event (ppointer->process s4-0) 'segment (* (-> this draw-seg) 8) 0)
                  )
                (when (and s1-0 s4-0 (nonzero? (-> (the-as process-drawable (-> s4-0 0)) draw)))
                  (cond
                    ((= s1-0 'jakb)
                     (if (not (-> *setting-control* user-current beard))
                         (send-event (ppointer->process s4-0) 'segment 0 16)
                         )
                     )
                    ((= s1-0 'jakc)
                     (if (not (-> *setting-control* user-current beard))
                         (send-event (ppointer->process s4-0) 'segment 0 32)
                         )
                     (if (not (logtest? (game-feature armor0) (-> *game-info* features)))
                         (send-event (ppointer->process s4-0) 'segment 0 16)
                         )
                     (if (not (logtest? (game-feature armor1) (-> *game-info* features)))
                         (send-event (ppointer->process s4-0) 'segment 0 256)
                         )
                     (if (not (logtest? (game-feature armor2) (-> *game-info* features)))
                         (send-event (ppointer->process s4-0) 'segment 0 2048)
                         )
                     (if (not (logtest? (game-feature armor3) (-> *game-info* features)))
                         (send-event (ppointer->process s4-0) 'segment 0 4096)
                         )
                     (let ((v0-28 (log2 (the-as int (-> (the-as process-drawable (-> s4-0 0)) draw mgeo seg-table (log2 16))))))
                       (logior! (-> (the-as process-drawable (-> s4-0 0)) draw mgeo effect v0-28 effect-usage) 8)
                       )
                     )
                    )
                  (when (nonzero? (-> (the-as manipy (-> s4-0 0)) joint 0))
                    (cond
                      ((logtest? (game-secrets little-head) (-> *game-info* secrets))
                       (mode-set! (-> (the-as manipy (-> s4-0 0)) joint 0) (joint-mod-mode joint-set*))
                       (trs-set!
                         (-> (the-as manipy (-> s4-0 0)) joint 0)
                         (the-as vector #f)
                         (the-as quaternion #f)
                         (new 'static 'vector :x 0.4 :y 0.4 :z 0.4 :w 1.0)
                         )
                       )
                      ((logtest? (game-secrets big-head) (-> *game-info* secrets))
                       (mode-set! (-> (the-as manipy (-> s4-0 0)) joint 0) (joint-mod-mode joint-set*))
                       (trs-set!
                         (-> (the-as manipy (-> s4-0 0)) joint 0)
                         (the-as vector #f)
                         (the-as quaternion #f)
                         (new 'static 'vector :x 2.0 :y 2.0 :z 2.0 :w 1.0)
                         )
                       )
                      )
                    )
                  )
                (when (and s4-0 (logtest? (-> this flags) 2))
                  (let ((s1-2 (process-spawn
                                manipy
                                :init manipy-init
                                (-> arg0 root trans)
                                s2-1
                                s3-0
                                #f
                                0
                                :name (-> this name)
                                :to (ppointer->process s4-0)
                                :stack-size #x20000
                                :unk 0
                                )
                              )
                        )
                    (send-event (ppointer->process s1-2) 'mirror #t)
                    (send-event (ppointer->process s1-2) 'anim-mode 'mirror)
                    (if (nonzero? (-> this light-index))
                        (send-event (ppointer->process s1-2) 'light-index (* (-> this light-index) 8))
                        )
                    (send-event (ppointer->process s4-0) 'shadow-disable-smooth #t)
                    (if (nonzero? (-> this shadow-mask))
                        (send-event (ppointer->process s1-2) 'shadow-mask (* (-> this shadow-mask) 8))
                        )
                    (if (nonzero? (-> this shadow-values))
                        (send-event (ppointer->process s1-2) 'shadow-values (* (-> this shadow-values) 8))
                        )
                    (if (and s1-2 (not (logtest? (-> this flags) 1)) (nonzero? (-> (the-as process-drawable (-> s1-2 0)) draw)))
                        (logior! (-> (the-as process-drawable (-> s1-2 0)) draw status) (draw-control-status no-draw-bounds))
                        )
                    (if (-> this shadow-volume-joint)
                        (send-event (ppointer->process s1-2) 'shadow-volume (-> this shadow-volume-joint) (-> this shadow-flags))
                        )
                    (if (or (nonzero? (-> this draw-seg)) (nonzero? (-> this no-draw-seg)))
                        (send-event (ppointer->process s1-2) 'segment (* (-> this draw-seg) 8) (* (-> this no-draw-seg) 8))
                        )
                    )
                  )
                )
              (when (and s4-0 (nonzero? (-> this camera)))
                (cond
                  ((handle->process (-> arg0 camera))
                   (change-parent (handle->process (-> arg0 camera)) (ppointer->process s4-0))
                   (send-event (handle->process (-> arg0 camera)) 'target (ppointer->process s4-0))
                   (send-event (handle->process (-> arg0 camera)) 'joint (* (-> this camera) 8))
                   )
                  (else
                    (let ((v1-341 (process-spawn
                                    othercam
                                    (ppointer->process s4-0)
                                    (-> this camera)
                                    #t
                                    'scene-player
                                    :name "othercam"
                                    :to (ppointer->process s4-0)
                                    )
                                  )
                          )
                      (if v1-341
                          (set! (-> arg0 camera) (ppointer->handle v1-341))
                          )
                      )
                    )
                  )
                )
              s4-0
              )
            )
      )
    )
  (label cfg-260)
  s4-0
  )

;; definition for method 10 of type scene-player
(defmethod deactivate ((this scene-player))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (set! *debug-menu-scene-play* (the-as object #f))
  (set! *scene-player* (the-as (pointer scene-player) #f))
  (kill-persister *setting-control* (the-as engine-pers 'blackout) 'bg-a-force)
  (kill-persister *setting-control* (the-as engine-pers 'blur-a) 'blur-a)
  ((method-of-type process-drawable deactivate) this)
  (none)
  )

;; definition for method 7 of type scene-player
;; WARN: Return type mismatch process-drawable vs scene-player.
(defmethod relocate ((this scene-player) (offset int))
  (let ((v1-0 *kernel-context*))
    (set! (-> v1-0 relocating-process) this)
    (set! (-> v1-0 relocating-min) (the-as int (&-> this type)))
    (set! (-> v1-0 relocating-max)
          (the-as int (+ (+ (-> this allocated-length) -4 (-> process size)) (the-as int this)))
          )
    (set! (-> v1-0 relocating-offset) offset)
    )
  (let ((v1-2 (-> this scene-list)))
    (if (and (>= (the-as int v1-2) (-> *kernel-context* relocating-min))
             (< (the-as int v1-2) (-> *kernel-context* relocating-max))
             )
        (&+! (-> this scene-list) offset)
        )
    )
  (the-as scene-player ((method-of-type process-drawable relocate) this offset))
  )

;; definition for method 25 of type scene-player
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
;; WARN: disable def twice: 288. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
;; WARN: disable def twice: 365. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod scene-player-method-25 ((this scene-player) (arg0 float) (arg1 float))
  (local-vars
    (v1-12 symbol)
    (v1-47 symbol)
    (v1-73 symbol)
    (v1-105 symbol)
    (sv-96 object)
    (sv-112 object)
    (sv-128 object)
    (sv-144 object)
    (sv-160 object)
    (sv-176 object)
    (sv-192 object)
    (sv-208 object)
    (sv-224 object)
    )
  (dotimes (s3-0 (-> this scene actor length))
    (let ((s2-0 (-> this scene actor s3-0)))
      (let* ((s1-0 (-> s2-0 draw-frames))
             (s0-0 (car s1-0))
             )
        (while (not (null? s1-0))
          (when (and (pair? s0-0)
                     (let ((a0-4 (car s0-0)))
                       (set! sv-96 (car (cdr s0-0)))
                       (or (= a0-4 'min) (>= arg0 (command-get-float a0-4 0.0)))
                       )
                     (or (= sv-96 'max) (< arg0 (command-get-float (car (cdr s0-0)) 0.0)))
                     )
            (set! v1-12 #t)
            (goto cfg-20)
            )
          (set! s1-0 (cdr s1-0))
          (set! s0-0 (car s1-0))
          )
        )
      (set! v1-12 #f)
      (label cfg-20)
      (cond
        (v1-12
          (if (not (handle->process (-> s2-0 process)))
              (set! (-> s2-0 process) (ppointer->handle (setup-manipy-for-scene! s2-0 this)))
              )
          (let ((s1-1 (handle->process (-> s2-0 process))))
            (when (and s1-1 (nonzero? (-> (the-as process-drawable s1-1) draw)))
              (let ((s0-1 (-> s2-0 scissor-frames)))
                (set! sv-112 (car s0-1))
                (while (not (null? s0-1))
                  (when (and (pair? sv-112)
                             (let ((a0-21 (car sv-112)))
                               (set! sv-128 (car (cdr sv-112)))
                               (or (= a0-21 'min) (>= arg0 (command-get-float a0-21 0.0)))
                               )
                             (or (= sv-128 'max) (< arg0 (command-get-float (car (cdr sv-112)) 0.0)))
                             )
                    (set! v1-47 #t)
                    (goto cfg-59)
                    )
                  (set! s0-1 (cdr s0-1))
                  (set! sv-112 (car s0-1))
                  )
                )
              (set! v1-47 #f)
              (label cfg-59)
              (if v1-47
                  (logclear! (-> (the-as process-drawable s1-1) draw status) (draw-control-status force-vu1))
                  (logior! (-> (the-as process-drawable s1-1) draw status) (draw-control-status force-vu1))
                  )
              (let ((s0-2 (-> s2-0 shadow-frames)))
                (set! sv-144 (car s0-2))
                (while (not (null? s0-2))
                  (when (and (pair? sv-144)
                             (let ((a0-30 (car sv-144)))
                               (set! sv-160 (car (cdr sv-144)))
                               (or (= a0-30 'min) (>= arg0 (command-get-float a0-30 0.0)))
                               )
                             (or (= sv-160 'max) (< arg0 (command-get-float (car (cdr sv-144)) 0.0)))
                             )
                    (set! v1-73 #t)
                    (goto cfg-81)
                    )
                  (set! s0-2 (cdr s0-2))
                  (set! sv-144 (car s0-2))
                  )
                )
              (set! v1-73 #f)
              (label cfg-81)
              (if v1-73
                  (send-event s1-1 'shadow #t)
                  (send-event s1-1 'shadow #f)
                  )
              (let ((s0-3 (-> s2-0 cloth-reset-frames)))
                (set! sv-192 (car s0-3))
                (while (not (null? s0-3))
                  (let ((v1-97 (cond
                                 ((pair? sv-192)
                                  (let ((a0-38 (car sv-192)))
                                    (set! sv-176 (car (cdr sv-192)))
                                    (and (or (= a0-38 'min) (>= arg0 (+ -1.0 (command-get-float a0-38 0.0))))
                                         (or (= sv-176 'max) (< arg0 (+ 1.0 (command-get-float (car (cdr sv-192)) 0.0))))
                                         )
                                    )
                                  )
                                 (else
                                   (let* ((t9-11 command-get-float)
                                          (a1-18 0.0)
                                          (f0-10 (t9-11 sv-192 a1-18))
                                          )
                                     (and (< arg1 f0-10) (>= arg0 f0-10))
                                     )
                                   )
                                 )
                               )
                        )
                    (when v1-97
                      (set! v1-105 #t)
                      (goto cfg-113)
                      )
                    )
                  (set! s0-3 (cdr s0-3))
                  (set! sv-192 (car s0-3))
                  )
                )
              (set! v1-105 #f)
              (label cfg-113)
              (if v1-105
                  (process-drawable-cloth-command (the-as process-drawable s1-1) '(scene-reset-frame))
                  )
              (let* ((s2-1 (-> s2-0 cloth-commands))
                     (s0-4 (car s2-1))
                     )
                (while (not (null? s2-1))
                  (when (pair? s0-4)
                    (set! sv-224 (car s0-4))
                    (let ((v1-121 (cond
                                    ((pair? sv-224)
                                     (let ((a0-44 (car sv-224)))
                                       (set! sv-208 (car (cdr sv-224)))
                                       (and (or (= a0-44 'min) (>= arg0 (command-get-float a0-44 0.0)))
                                            (or (= sv-208 'max) (< arg0 (command-get-float (car (cdr sv-224)) 0.0)))
                                            )
                                       )
                                     )
                                    (else
                                      (let* ((t9-15 command-get-float)
                                             (a1-23 0.0)
                                             (f0-13 (t9-15 sv-224 a1-23))
                                             )
                                        (and (< arg1 f0-13) (>= arg0 f0-13))
                                        )
                                      )
                                    )
                                  )
                          )
                      (if v1-121
                          (process-drawable-cloth-command (the-as process-drawable s1-1) (cdr s0-4))
                          )
                      )
                    )
                  (set! s2-1 (cdr s2-1))
                  (set! s0-4 (car s2-1))
                  )
                )
              )
            )
          0
          )
        ((handle->process (-> s2-0 process))
         (deactivate (handle->process (-> s2-0 process)))
         )
        )
      )
    )
  0
  (none)
  )

;; definition for function scene-lookup
;; WARN: Return type mismatch basic vs scene.
(defun scene-lookup ((arg0 basic))
  (the-as
    scene
    (case (-> arg0 type)
      ((string)
       (let ((s5-0 (art-group-get-by-name *level* (the-as string arg0) (the-as (pointer level) #f))))
         (when (type? s5-0 scene)
           (let ((gp-0 (get-level-by-heap-ptr-and-status *level* (the-as pointer s5-0) 'active)))
             (when (and s5-0 gp-0)
               (let ((s4-0 (scene-decode-continue (-> s5-0 data 15))))
                 (when s4-0
                   (dotimes (s3-0 (-> s4-0 want-count))
                     (if (= (-> gp-0 name) (-> s4-0 want s3-0 name))
                         (goto cfg-25)
                         )
                     (let ((v1-14 (lookup-level-info (-> s4-0 want s3-0 name))))
                       (if (and v1-14 (-> v1-14 borrow) (-> v1-14 borrow alias) (member (-> gp-0 name) (-> v1-14 borrow alias)))
                           (goto cfg-25)
                           )
                       )
                     )
                   (format
                     0
                     "WARNING: can not find scene level ~A in continue ~A, dropping scene until after load~%"
                     (-> gp-0 name)
                     (-> s4-0 name)
                     )
                   (return (the-as scene #f))
                   )
                 )
               )
             )
           (label cfg-25)
           s5-0
           )
         )
       )
      ((scene)
       arg0
       )
      )
    )
  )

;; definition for method 24 of type scene-player
(defmethod scene-player-method-24 ((this scene-player) (arg0 scene) (arg1 symbol))
  (when (= (-> arg0 type) string)
    (let ((v1-2 (scene-lookup arg0)))
      (if v1-2
          (set! arg0 v1-2)
          )
      )
    )
  (when (or (not arg0) (!= (-> arg0 type) scene))
    (format 0 "ERROR: SCENE: scene-player can not find scene ~A~%" arg0)
    (go process-drawable-art-error "scene-list format")
    )
  (when arg1
    (let ((s4-1 (get-level-by-heap-ptr-and-status *level* (the-as pointer arg0) 'active)))
      (init-spool-by-scene! arg0 (-> this anim))
      (set! (-> this level) s4-1)
      )
    (set! (-> this scene) arg0)
    )
  arg0
  )

;; definition for method 23 of type scene-player
;; WARN: Return type mismatch int vs none.
(defmethod scene-player-method-23 ((this scene-player) (arg0 string) (arg1 symbol))
  (let ((gp-0 (scene-player-method-24 this (the-as scene arg0) #t)))
    (when (logtest? (-> gp-0 scene-flags) (scene-flags scf3))
      (let ((a0-2 *traffic-manager*))
        (send-event a0-2 'restore-default-settings)
        )
      )
    (send-event *target* 'draw (logtest? (-> gp-0 scene-flags) (scene-flags scf0)))
    (let ((s3-0 (entity-by-name (-> gp-0 entity))))
      (when (and (-> gp-0 entity) (not s3-0))
        (format 0 "ERROR: SCENE: scene ~A can not find entity ~A~%" (-> gp-0 name) (-> gp-0 entity))
        (go process-drawable-art-error (-> gp-0 entity))
        )
      (set! (-> this main-entity) (the-as entity-actor s3-0))
      (cond
        (s3-0
          (process-drawable-from-entity! this (-> this main-entity))
          (logclear! (-> this mask) (process-mask actor-pause))
          )
        (else
          (vector-reset! (-> this root trans))
          (quaternion-identity! (-> this root quat))
          )
        )
      )
    (let ((s3-1 (load-to-heap-by-name (-> *level* level-default art-group) (-> gp-0 art-group) 'load global 0)))
      (when (not s3-1)
        (format 0 "ERROR: SCENE: scene ~A can not find art-group ~A~%" (-> gp-0 name) (-> gp-0 art-group))
        (go process-drawable-art-error (-> gp-0 art-group))
        )
      (set! (-> this draw art-group) s3-1)
      (countdown (v1-31 (-> s3-1 length))
        (when (-> s3-1 data v1-31)
          (cond
            ((= (-> s3-1 data v1-31 type) merc-ctrl)
             (set! (-> this draw mgeo) (the-as merc-ctrl (-> s3-1 data v1-31)))
             )
            ((= (-> s3-1 data v1-31 type) art-joint-geo)
             (set! (-> this draw jgeo) (the-as art-joint-geo (-> s3-1 data v1-31)))
             )
            )
          )
        )
      )
    (cond
      ((< (+ (-> this scene-index) 1) (-> this scene-list length))
       (let ((a0-34 (scene-player-method-24 this (-> this scene-list (+ (-> this scene-index) 1)) #f)))
         (cond
           (a0-34
             (init-spool-by-scene! a0-34 (-> this next-anim))
             )
           (else
             (set! (-> this next-anim anim-name) (the-as string 0))
             0
             )
           )
         )
       )
      (else
        (set! (-> this next-anim anim-name) (the-as string 0))
        0
        )
      )
    (dotimes (s3-2 (-> gp-0 actor length))
      (let ((s2-0 (-> gp-0 actor s3-2)))
        (set! (-> s2-0 process) (the-as handle #f))
        (let ((s1-0 (if (-> s2-0 level)
                        (level-get *level* (-> s2-0 level))
                        (-> *level* level-default)
                        )
                    )
              (v1-53 (when level
                       (let ((s0-0 (art-group-get-by-name *level* (-> s2-0 art-group) (the-as (pointer level) #f))))
                         (if (type? s0-0 skeleton-group)
                             s0-0
                             )
                         )
                       )
                     )
              )
          (cond
            ((or (not s1-0) (not (or (= (-> s1-0 status) 'active) (= (-> s1-0 status) 'reserved))))
             (format
               0
               "ERROR: SCENE: scene actor ~A can not find an active level ~A~%"
               (-> s2-0 art-group)
               (-> s2-0 level)
               )
             )
            ((not v1-53)
             (format
               0
               "ERROR: SCENE: scene actor ~A can not find skeleton-group ~A~%"
               (-> s2-0 art-group)
               (-> s2-0 art-group)
               )
             )
            (else
              (load-to-heap-by-name (-> s1-0 art-group) (the-as string (-> v1-53 data 0)) 'load global 0)
              )
            )
          )
        )
      )
    (process-entity-status! this (entity-perm-status no-kill) #t)
    (when arg1
      (kill-persister *setting-control* (the-as engine-pers 'fail-sfx-volume) 'sfx-volume)
      (kill-persister *setting-control* (the-as engine-pers 'fail-dialog-volume) 'dialog-volume)
      (kill-persister *setting-control* (the-as engine-pers 'fail-music-volume) 'music-volume)
      (set-setting! 'region-mode #f 0.0 0)
      (set-setting! 'process-mask 'set 0.0 (-> gp-0 mask-to-clear))
      (if (logtest? (-> gp-0 mask-to-clear) (process-mask movie))
          (set-setting! 'letterbox 'abs 1.0 0)
          )
      (set-setting! 'sound-bank-load #f 0.0 0)
      (set-setting! 'movie (process->ppointer this) 0.0 0)
      (set-setting! 'movie-name (-> gp-0 name) 0.0 0)
      (let ((f30-0 (if (>= (-> gp-0 music-volume) 0.0)
                       (-> gp-0 music-volume)
                       (-> *setting-control* user-current music-volume-movie)
                       )
                   )
            )
        (set-setting! 'music-volume 'rel f30-0 0)
        (set-setting!
          'sfx-volume
          'rel
          (if (>= (-> gp-0 sfx-volume) 0.0)
              (-> gp-0 sfx-volume)
              (-> *setting-control* user-current sfx-volume-movie)
              )
          0
          )
        (set-setting!
          'ambient-volume
          'rel
          (if (>= (-> gp-0 ambient-volume) 0.0)
              (-> gp-0 ambient-volume)
              (-> *setting-control* user-current ambient-volume-movie)
              )
          0
          )
        (when (nonzero? (the int (-> gp-0 music-delay)))
          (set-setting! 'music-volume 'abs 0.0 0)
          (set! f30-0 0.0)
          )
        (remove-setting! 'music)
        (if (= f30-0 0.0)
            (set-setting! 'music #f 0.0 0)
            )
        )
      (set-setting! 'gem #f 0.0 0)
      (set-setting! 'citizen-fights #f 0.0 0)
      (apply-settings *setting-control*)
      )
    )
  0
  (none)
  )

;; definition of type subtitle-work
(deftype subtitle-work (structure)
  ((draw-tmpl  dma-gif-packet  :inline)
   (color0     vector4w        :inline)
   (color1     vector4w        :inline)
   )
  )

;; definition for method 3 of type subtitle-work
(defmethod inspect ((this subtitle-work))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'subtitle-work)
  (format #t "~1Tdraw-tmpl: #<dma-gif-packet @ #x~X>~%" (-> this draw-tmpl))
  (format #t "~1Tcolor0: #<vector4w @ #x~X>~%" (-> this color0))
  (format #t "~1Tcolor1: #<vector4w @ #x~X>~%" (-> this color1))
  (label cfg-4)
  this
  )

;; definition for symbol *subtitle-work*, type subtitle-work
(define *subtitle-work* (new 'static 'subtitle-work
                          :draw-tmpl (new 'static 'dma-gif-packet
                            :dma-vif (new 'static 'dma-packet
                              :dma (new 'static 'dma-tag :qwc #x6 :id (dma-tag-id cnt))
                              :vif1 (new 'static 'vif-tag :imm #x6 :cmd (vif-cmd direct) :msk #x1)
                              )
                            :gif (new 'static 'array uint64 2 #x50ab400000008001 #x53531)
                            )
                          :color0 (new 'static 'vector4w :w #x80)
                          :color1 (new 'static 'vector4w :x #x80 :y #x80 :z #x80 :w #x80)
                          )
        )

;; definition for function draw-subtitle-image
;; INFO: Used lq/sq
;; WARN: Return type mismatch pointer vs none.
(defun draw-subtitle-image ((arg0 subtitle-image) (arg1 font-context))
  (local-vars (sv-16 pointer) (sv-32 int))
  (let ((gp-0 (-> arg0 width))
        (s5-0 (-> arg0 height))
        )
    (let ((s4-0 (-> *display* frames (-> *display* on-screen) global-buf)))
      (set! sv-16 (-> s4-0 base))
      (unpack-comp-rle (the-as (pointer int8) sv-16) (the-as (pointer int8) (-> arg0 data)))
      (&+! (-> s4-0 base) (logand -16 (+ (shr (* gp-0 s5-0) 1) 15)))
      )
    (with-dma-buffer-add-bucket ((s3-0 (-> *display* frames (-> *display* on-screen) global-buf))
                                 (bucket-id hud-draw-pris2)
                                 )
      (upload-vram-data s3-0 0 (-> arg0 palette) 2 8)
      (let ((s0-0 20))
        (dma-buffer-add-gs-set s3-0
                               (bitbltbuf (new 'static 'gs-bitbltbuf :dbp #x1 :dbw (shr gp-0 6) :dpsm s0-0))
                               (trxpos (new 'static 'gs-trxpos))
                               (trxreg (new 'static 'gs-trxreg :rrw gp-0 :rrh s5-0))
                               (trxdir (new 'static 'gs-trxdir))
                               )
        (let ((t9-2 dma-buffer-add-ref-texture)
              (a0-13 s3-0)
              (a2-8 gp-0)
              (a3-1 s5-0)
              (t0-1 s0-0)
              )
          (t9-2 a0-13 sv-16 (the-as int a2-8) (the-as int a3-1) (the-as gs-psm t0-1))
          )
        (set! sv-32 (+ (log2 (the-as int (+ gp-0 -1))) 1))
        (let ((v1-17 (+ (log2 (the-as int (+ s5-0 -1))) 1)))
          (dma-buffer-add-gs-set s3-0
                                 (test-1 (new 'static 'gs-test :ate #x1 :afail #x3 :zte #x1 :ztst (gs-ztest always)))
                                 (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1))
                                 (tex0-1 (new 'static 'gs-tex0 :tbp0 #x1 :tcc #x1 :cld #x1 :psm s0-0 :th v1-17 :tw sv-32 :tbw (shr gp-0 6)))
                                 (tex1-1 (new 'static 'gs-tex1))
                                 (clamp-1 (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp)))
                                 (texflush 0)
                                 )
          )
        )
      (let* ((v1-28 (-> s3-0 base))
             (a2-23
               (+ (- 1793 (the-as int (shr (-> arg0 width) 1))) (the int (+ (-> arg1 origin x) (/ (-> arg1 width) 2))))
               )
             (a3-8 (+ (the int (-> arg1 origin y)) 1841))
             (a0-23 (+ a2-23 (-> arg0 width)))
             (a1-33 (+ a3-8 (-> arg0 height)))
             )
        (set! (-> (the-as (pointer uint128) v1-28) 0) (-> *subtitle-work* draw-tmpl dma-vif quad))
        (set! (-> (the-as (pointer uint128) v1-28) 1) (-> *subtitle-work* draw-tmpl quad 1))
        (set! (-> (the-as (pointer uint128) v1-28) 2) (-> *subtitle-work* color0 quad))
        (set-vector! (the-as vector4w (&+ v1-28 48)) 0 0 0 0)
        (set-vector! (the-as vector4w (&+ v1-28 64)) (the-as int (* a2-23 16)) (* a3-8 16) 0 0)
        (set-vector! (the-as vector4w (&+ v1-28 80)) (the-as int (* gp-0 16)) (the-as int (* s5-0 16)) 0 0)
        (set-vector! (the-as vector4w (&+ v1-28 96)) (the-as int (* a0-23 16)) (* a1-33 16) 0 0)
        )
      (&+! (-> s3-0 base) 112)
      (let* ((v1-32 (-> s3-0 base))
             (a1-38
               (+ (- 1792 (the-as int (shr (-> arg0 width) 1))) (the int (+ (-> arg1 origin x) (/ (-> arg1 width) 2))))
               )
             (a3-11 (+ (the int (-> arg1 origin y)) 1840))
             (a0-30 (+ a1-38 (-> arg0 width)))
             (a2-28 (+ a3-11 (-> arg0 height)))
             )
        (set! (-> (the-as (pointer uint128) v1-32) 0) (-> *subtitle-work* draw-tmpl dma-vif quad))
        (set! (-> (the-as (pointer uint128) v1-32) 1) (-> *subtitle-work* draw-tmpl quad 1))
        (set! (-> (the-as (pointer uint128) v1-32) 2) (-> *subtitle-work* color1 quad))
        (set-vector! (the-as vector4w (&+ v1-32 48)) 0 0 0 0)
        (set-vector! (the-as vector4w (&+ v1-32 64)) (the-as int (* a1-38 16)) (* a3-11 16) 0 0)
        (set-vector! (the-as vector4w (&+ v1-32 80)) (the-as int (* gp-0 16)) (the-as int (* s5-0 16)) 0 0)
        (set-vector! (the-as vector4w (&+ v1-32 96)) (the-as int (* a0-30 16)) (* a2-28 16) 0 0)
        )
      (&+! (-> s3-0 base) 112)
      (set-dirty-mask! (-> *level* level-default) 8 (the-as int (* gp-0 s5-0)) 256)
      )
    )
  (none)
  )

;; definition for function process-drawable-draw-subtitles
;; WARN: Return type mismatch int vs none.
(defbehavior process-drawable-draw-subtitles process-drawable ()
  (when (and (nonzero? (-> self skel))
             (> (-> self skel active-channels) 0)
             (-> *setting-control* user-current subtitle)
             )
    (let ((v1-9 (-> self skel root-channel 0 frame-group)))
      (when v1-9
        (let ((gp-0 (res-lump-struct (-> v1-9 extra) 'subtitle-range (array subtitle-range))))
          (when gp-0
            (let ((f30-0 (ja-aframe-num 0))
                  (s5-0 (the-as int (-> *setting-control* user-current subtitle-language)))
                  )
              (if (and (= (the-as language-enum s5-0) (language-enum english)) (= (scf-get-territory) 1))
                  (set! s5-0 11)
                  )
              (dotimes (s4-0 (-> gp-0 length))
                (let ((v1-16 (-> gp-0 s4-0)))
                  (when (and (>= f30-0 (-> v1-16 start-frame)) (< f30-0 (-> v1-16 end-frame)))
                    (let ((s3-0 (-> v1-16 message s5-0)))
                      (when (and s3-0 (nonzero? s3-0))
                        (let ((s2-0
                                (new 'stack 'font-context *font-default-matrix* 20 290 0.0 (font-color default) (font-flags shadow kerning))
                                )
                              )
                          (let ((v1-20 s2-0))
                            (set! (-> v1-20 width) (the float 465))
                            )
                          (let ((v1-21 s2-0))
                            (set! (-> v1-21 height) (the float 70))
                            )
                          (let ((v1-22 s2-0))
                            (set! (-> v1-22 scale) 0.5)
                            )
                          (set! (-> s2-0 flags) (font-flags shadow kerning middle large))
                          (case (-> s3-0 type)
                            ((string)
                             (when (= (-> *setting-control* user-default subtitle-language) (language-enum korean))
                               (set! s3-0 (convert-korean-text (the-as string s3-0)))
                               (let ((v1-27 s2-0))
                                 (set! (-> v1-27 scale) 0.6)
                                 )
                               )
                             (when (= (-> *setting-control* user-default subtitle-language) (language-enum russian))
                               (let ((v1-30 s2-0))
                                 (set! (-> v1-30 scale) 0.75)
                                 )
                               )
                             (set! (-> s2-0 flags) (font-flags kerning middle middle-vert large))
                             (+! (-> s2-0 origin x) -1.0)
                             (+! (-> s2-0 origin y) -1.0)
                             (set! (-> s2-0 color) (font-color font-color-39))
                             (+! (-> s2-0 origin x) 1.0)
                             (+! (-> s2-0 origin y) 1.0)
                             (set! (-> s2-0 color) (font-color default))
                             (set! (-> s2-0 flags) (font-flags shadow kerning middle middle-vert large))
                             (print-game-text (the-as string s3-0) s2-0 #f 44 (bucket-id hud-draw-pris2))
                             (gui-control-method-12
                               *gui-control*
                               self
                               (gui-channel subtitle)
                               (gui-action play)
                               "scene"
                               0
                               81920.0
                               (new 'static 'sound-id)
                               )
                             )
                            ((subtitle-image)
                             (draw-subtitle-image (the-as subtitle-image s3-0) s2-0)
                             )
                            (else
                              (if *debug-segment*
                                  (format *stdcon* "unknown message ~A~%" s3-0)
                                  )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate wait (scene-player)
  :virtual #t
  :enter (behavior ((arg0 symbol))
    (set-time! (-> self state-time))
    (if (= (-> *game-info* demo-state) 101)
        (set-setting! 'audio-language #f 0.0 5)
        )
    (when (or (-> self scene) (-> self preload-continue))
      (let ((gp-0 (scene-decode-continue (if (-> self scene)
                                             (-> self scene load-point)
                                             (-> self preload-continue)
                                             )
                                         )
                  )
            )
        (when gp-0
          (when (-> self scene)
            (set-setting! 'borrow (-> self scene borrow) 0.0 0)
            (apply-settings *setting-control*)
            )
          (cond
            ((and *target*
                  (zero? (-> self scene-index))
                  (or (not (-> self scene))
                      (!= (status-of-level-and-borrows *level* (-> gp-0 vis-nick) #f) 'active)
                      (logtest? (-> self scene scene-flags) (scene-flags scf5))
                      )
                  )
             (send-event *target* 'continue gp-0)
             )
            (else
              (let ((a0-16 (lookup-level-info (-> gp-0 vis-nick))))
                (set! (-> *load-state* vis-nick) (if a0-16
                                                     (-> a0-16 name)
                                                     )
                      )
                )
              (dotimes (v1-28 10)
                (cond
                  ((< v1-28 (-> gp-0 want-count))
                   (set! (-> *load-state* want v1-28 name) (-> gp-0 want v1-28 name))
                   (set! (-> *load-state* want v1-28 display?) (-> gp-0 want v1-28 display?))
                   )
                  (else
                    (set! (-> *load-state* want v1-28 name) #f)
                    (set! (-> *load-state* want v1-28 display?) #f)
                    )
                  )
                (set! (-> *load-state* want v1-28 force-vis?) #f)
                (set! (-> *load-state* want v1-28 force-inside?) #f)
                )
              (update-task-masks 'event)
              )
            )
          )
        )
      )
    )
  :trans (behavior ()
    (if (and (-> self scene) (nonzero? (-> self anim anim-name)) (not (load-in-progress? *level*)))
        (gui-control-method-12
          *gui-control*
          self
          (gui-channel art-load)
          (gui-action queue)
          (-> self anim name)
          0
          -1.0
          (new 'static 'sound-id)
          )
        )
    (set! (-> *ACTOR-bank* birth-max) 1000)
    )
  :code (behavior ((arg0 symbol))
    (local-vars (v1-18 symbol) (v1-124 symbol))
    (when (and (-> self scene) (zero? (-> self scene wait-max-time)))
      (while *progress-process*
        (suspend)
        )
      (set-setting! 'allow-progress #f 0.0 0)
      (set-setting! 'bg-a-force 'abs 1.0 0)
      (apply-settings *setting-control*)
      )
    (if (or (not *target*)
            (or (focus-test? *target* grabbed)
                (begin
                  (dotimes (v1-17 10)
                    (when (and (-> *target* current-level) (= (-> *load-state* target v1-17 name) (-> *target* current-level name)))
                      (set! v1-18 #f)
                      (goto cfg-22)
                      )
                    )
                  #t
                  (set! v1-18 #t)
                  (label cfg-22)
                  (or v1-18 (not (-> self scene)))
                  )
                )
            )
        (set! arg0 #f)
        )
    (while (and arg0
                (or (focus-test? *target* in-air)
                    (and (-> *target* next-state) (= (-> *target* next-state name) 'target-flop-hit-ground))
                    )
                (-> self scene)
                (not (time-elapsed? (-> self state-time) (-> self scene wait-air-time)))
                )
      (suspend)
      )
    (suspend)
    (let ((s5-0 (current-time)))
      (when (and *target* (not (logtest? (-> *target* focus-status) (focus-status grabbed))))
        (label cfg-47)
        (send-event *target* 'end-mode 'freeze 'force)
        (when (not (process-grab? *target* #f))
          (suspend)
          (goto cfg-47)
          )
        )
      (process-entity-status! self (entity-perm-status no-kill) #t)
      (until (not (or (-> *setting-control* user-current talking)
                      (-> *setting-control* user-current spooling)
                      (-> *setting-control* user-current hint)
                      (-> *setting-control* user-current ambient)
                      )
                  )
        (set-setting! 'allow-progress #f 0.0 0)
        (apply-settings *setting-control*)
        (dotimes (s4-0 2)
          (while (or (-> *setting-control* user-current talking)
                     (-> *setting-control* user-current spooling)
                     (-> *setting-control* user-current hint)
                     (-> *setting-control* user-current ambient)
                     (or (and (-> *setting-control* user-current movie)
                              (!= (-> *setting-control* user-current movie) (process->ppointer self))
                              )
                         *progress-process*
                         (!= (get-status *gui-control* (-> self gui-id)) 3)
                         )
                     )
            (suspend)
            )
          )
        (when arg0
          (while (and (-> self scene) (not (or (time-elapsed? s5-0 (-> self scene wait-ground-time))
                                               (time-elapsed? (-> self state-time) (-> self scene wait-max-time))
                                               )
                                           )
                      )
            (suspend)
            )
          )
        (remove-setting! 'movie)
        (remove-setting! 'sound-bank-load)
        (remove-setting! 'movie-name)
        (remove-setting! 'bg-a-force)
        (apply-settings *setting-control*)
        (set-blackout-frames (seconds 0.1))
        (suspend)
        (set-blackout-frames (seconds 0.1))
        (suspend)
        )
      )
    (send-event *target* 'trans 'save (-> self old-target-pos))
    (let ((gp-1 *load-state*))
      (when gp-1
        (dotimes (s5-1 2)
          (while (begin
                   (dotimes (s4-1 10)
                     (when (not (or (not (-> gp-1 want s4-1 name))
                                    (not (-> gp-1 want s4-1 display?))
                                    (= (status-of-level-and-borrows *level* (-> gp-1 want s4-1 name) 'all) 'active)
                                    )
                                )
                       (set! v1-124 #t)
                       (goto cfg-114)
                       )
                     )
                   (set! v1-124 #f)
                   (label cfg-114)
                   v1-124
                   )
            (set-blackout-frames (seconds 0.1))
            (suspend)
            )
          (when (and (zero? s5-1) (< (-> self scene-index) (-> self scene-list length)))
            (scene-player-method-24 self (-> self scene-list (-> self scene-index)) #t)
            (when (-> self scene)
              (set-setting! 'borrow (-> self scene borrow) 0.0 0)
              (apply-settings *setting-control*)
              )
            )
          )
        )
      )
    (when (and *target* (focus-test? *target* in-head flut light board pilot mech dark))
      (send-event *target* 'change-mode 'normal)
      (set-action!
        *gui-control*
        (gui-action stop)
        (the-as sound-id 1)
        (gui-channel jak)
        (gui-action none)
        (the-as string #f)
        (the-as (function gui-connection symbol) #f)
        (the-as process #f)
        )
      (set-action!
        *gui-control*
        (gui-action stop)
        (the-as sound-id 1)
        (gui-channel jak-mode)
        (gui-action none)
        (the-as string #f)
        (the-as (function gui-connection symbol) #f)
        (the-as process #f)
        )
      (set-action!
        *gui-control*
        (gui-action stop)
        (the-as sound-id 1)
        (gui-channel jak-effect-1)
        (gui-action none)
        (the-as string #f)
        (the-as (function gui-connection symbol) #f)
        (the-as process #f)
        )
      (set-action!
        *gui-control*
        (gui-action stop)
        (the-as sound-id 1)
        (gui-channel jak-effect-2)
        (gui-action none)
        (the-as string #f)
        (the-as (function gui-connection symbol) #f)
        (the-as process #f)
        )
      )
    (when (< (-> self scene-index) (-> self scene-list length))
      (scene-player-method-24 self (-> self scene-list (-> self scene-index)) #t)
      (while (and (-> self scene)
                  (nonzero? (-> self anim anim-name))
                  (let ((v1-175 (file-status *art-control* (-> self anim name) 0)))
                    (or (not (or (= v1-175 'active) (= v1-175 'locked)))
                        (let* ((a1-32
                                 (lookup-gui-connection-id *gui-control* (-> self anim anim-name) (gui-channel art-load) (gui-action none))
                                 )
                               (v1-181 (get-status *gui-control* a1-32))
                               )
                          (not (or (= v1-181 (gui-status ready)) (= v1-181 (gui-status active))))
                          )
                        )
                    )
                  )
        (set-blackout-frames (seconds 0.1))
        (suspend)
        )
      )
    (go-virtual play-anim)
    )
  )

;; failed to figure out what this is:
(defstate release (scene-player)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('user-data-set!)
       (let ((v0-0 (-> block param 0)))
         (set! (-> self user-data) v0-0)
         v0-0
         )
       )
      (('user-data)
       (-> self user-data)
       )
      )
    )
  :code (behavior ()
    (remove-setting! 'borrow)
    (when (scene-select?)
      (remove-setting! 'audio-language)
      (logclear! (-> self mask) (process-mask pause progress))
      (set-blackout-frames (seconds 0.05))
      (set-setting! 'music-volume 'abs 0.0 0)
      (set-setting! 'sfx-volume 'abs 0.0 0)
      (set-setting! 'ambient-volume 'abs 0.0 0)
      (set-setting! 'allow-pause #f 0.0 0)
      (set-setting! 'allow-progress #f 0.0 0)
      (setup
        *screen-filter*
        (new 'static 'vector)
        (new 'static 'vector :w 128.0)
        (* 30.0 (seconds-per-frame))
        (bucket-id tex-hud-pris2)
        #x3fffff
        #x33001
        #t
        )
      (suspend-for (seconds 0.05)
        )
      (set! (-> *setting-control* user-current bg-a) 0.0)
      (remove-setting! 'movie)
      (remove-setting! 'movie-name)
      (while (or (-> *setting-control* user-current movie)
                 (not *target*)
                 (or (!= (-> *setting-control* user-current bg-a) 0.0) (load-in-progress? *level*))
                 )
        (suspend)
        )
      (set! (-> *game-info* blackout-time) 0)
      (set! (-> *game-info* demo-state) (the-as uint 1))
      (set! (-> *setting-control* user-current bg-a-force) 0.0)
      (set-setting! 'allow-progress #t 0.0 0)
      (remove-setting! 'process-mask)
      (remove-setting! 'letterbox)
      (apply-settings *setting-control*)
      (send-event *target* 'draw #t)
      (send-event *target* 'trans 'reset)
      (send-event *target* 'change-mode 'normal)
      (activate-progress *dproc* 'select-scene-special)
      (dotimes (gp-1 5)
        (suspend)
        )
      (disable *screen-filter*)
      (deactivate self)
      )
    (when (< (-> self scene-index) (+ (-> self scene-list length) -1))
      (set! (-> self scene-index) (+ (-> self scene-list length) -1))
      (scene-player-method-24 self (-> self scene-list (-> self scene-index)) #t)
      )
    (let ((gp-2 (or (not (-> self scene)) (if (= (-> self blackout-end) 'none)
                                              (logtest? (-> self scene scene-flags) (scene-flags scf2))
                                              (-> self blackout-end)
                                              )
                    )
                )
          )
      (if gp-2
          (set-blackout-frames (seconds 0.1))
          )
      (send-event *target* 'draw #t)
      (send-event *target* 'trans 'reset)
      (suspend)
      (while (not (process-release? *target*))
        (suspend)
        (if gp-2
            (set-blackout-frames (seconds 0.1))
            )
        )
      (if gp-2
          (set-blackout-frames (seconds 0.1))
          )
      )
    (when (nonzero? (the int (-> self scene music-delay)))
      (persist-with-delay
        *setting-control*
        'music-volume-movie
        (the-as time-frame (the int (-> self scene music-delay)))
        'music-volume
        'abs
        0.0
        0
        )
      (persist-with-delay
        *setting-control*
        'music-delay
        (the-as time-frame (the int (-> self scene music-delay)))
        'music
        #f
        0.0
        0
        )
      )
    (cond
      ((and *target* (-> self scene) (or (-> self end-point) (-> self scene end-point)))
       (let ((t9-32 scene-decode-continue)
             (a0-37 (-> self end-point))
             )
         (set! a0-37 (cond
                       (a0-37
                         (empty)
                         a0-37
                         )
                       (else
                         (-> self scene end-point)
                         )
                       )
               )
         (let ((gp-4 (t9-32 a0-37)))
           (when gp-4
             (persist-with-delay
               *setting-control*
               'fail-sfx-volume
               (seconds 10)
               'sfx-volume
               'abs
               (-> *setting-control* user-target sfx-volume)
               0
               )
             (persist-with-delay
               *setting-control*
               'fail-music-volume
               (seconds 10)
               'music-volume
               'abs
               (-> *setting-control* user-target music-volume)
               0
               )
             (persist-with-delay
               *setting-control*
               'fail-dialog-volume
               (seconds 10)
               'dialog-volume
               'abs
               (-> *setting-control* user-target dialog-volume)
               0
               )
             (set-continue! *game-info* gp-4 #f)
             (send-event *target* 'continue gp-4)
             )
           )
         )
       )
      (else
        (send-event *target* 'trans 'restore (-> self old-target-pos))
        )
      )
    (if (and (-> self scene) (logtest? (-> self scene scene-flags) (scene-flags scf4)))
        (auto-save-user)
        )
    (when (and (-> self scene) (-> self scene on-complete))
      (while (and *target* (focus-test? *target* teleporting))
        (suspend)
        )
      (script-eval (-> self scene on-complete))
      )
    )
  )

;; failed to figure out what this is:
(defstate play-anim (scene-player)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (v0-0 object))
    (case message
      (('trans-hook)
       (set! v0-0 (-> block param 0))
       (set! (-> self new-trans-hook) (the-as (function none) v0-0))
       v0-0
       )
      (('eval)
       ((the-as (function scene-player none) (-> block param 0)) self)
       )
      (('abort)
       (set! (-> self aborted?) #t)
       (set-blackout-frames (seconds 0.2))
       (let ((a0-9 (-> self anim)))
         (when (and a0-9 (= (-> *setting-control* user-current spooling) (process->ppointer self)))
           (ja-abort-spooled-anim a0-9 (the-as art-joint-anim #f) -1)
           (ja-channel-set! 0)
           )
         )
       (go-virtual release)
       )
      (('change-entity)
       (let ((v1-9 (entity-by-name (the-as string (-> block param 0)))))
         (set! (-> self main-entity) (the-as entity-actor v1-9))
         (cond
           (v1-9
             (process-drawable-from-entity! self (-> self main-entity))
             (set! v0-0 (logclear (-> self mask) (process-mask actor-pause)))
             (set! (-> self mask) (the-as process-mask v0-0))
             v0-0
             )
           (else
             (format 0 "ERROR: SCENE: scene ~A can not find entity ~A~%" (-> self scene name) (-> block param 0))
             (vector-reset! (-> self root trans))
             (quaternion-identity! (-> self root quat))
             )
           )
         )
       )
      (('user-data-set!)
       (set! v0-0 (-> block param 0))
       (set! (-> self user-data) (the-as uint v0-0))
       v0-0
       )
      (('user-data)
       (-> self user-data)
       )
      )
    )
  :enter (behavior ()
    (set-setting! 'ambient-wind-scalar #f 0.0 0)
    (if (and (logtest? (-> self scene scene-flags) (scene-flags scf6)) *rigid-body-queue-manager*)
        (change-parent self *rigid-body-queue-manager*)
        )
    )
  :exit (behavior ()
    (while (-> self child)
      (deactivate (-> self child 0))
      )
    (kill-current-talker '() '(daxter voicebox message) 'exit)
    (set! (-> *setting-control* user-current bg-a) 0.0)
    (kill-persister *setting-control* (the-as engine-pers 'bg-a) 'bg-a)
    (kill-persister *setting-control* (the-as engine-pers 'bg-a-speed) 'bg-a-speed)
    (if (not (and (-> self next-state) (= (-> self next-state name) 'wait)))
        (remove-setting! 'borrow)
        )
    (remove-setting! 'gem)
    (apply-settings *setting-control*)
    )
  :trans (behavior ()
    (if (!= (-> self cur-trans-hook) (-> self new-trans-hook))
        (set! (-> self cur-trans-hook) (-> self new-trans-hook))
        )
    (cond
      ((not (-> *setting-control* user-current spooling))
       (if (and (-> self scene) (nonzero? (-> self anim anim-name)))
           (gui-control-method-12
             *gui-control*
             self
             (gui-channel art-load)
             (gui-action queue)
             (-> self anim name)
             0
             -1.0
             (new 'static 'sound-id)
             )
           )
       )
      (else
        (if (and (-> self scene) (nonzero? (-> self next-anim anim-name)))
            (gui-control-method-12
              *gui-control*
              self
              (gui-channel art-load)
              (gui-action queue)
              (-> self next-anim name)
              0
              -1.0
              (new 'static 'sound-id)
              )
            )
        )
      )
    (when (logtest? (-> self scene scene-flags) (scene-flags scf6))
      (let ((v1-26 (handle->process (-> *target* pilot vehicle))))
        (when v1-26
          (set! (-> self root trans quad) (-> (the-as process-drawable v1-26) root trans quad))
          (quaternion-copy! (-> self root quat) (-> (the-as process-drawable v1-26) root quat))
          )
        )
      )
    (if (and (-> self scene) (-> self scene on-running))
        (script-eval (-> self scene on-running))
        )
    (when (and (logtest? (-> self scene scene-flags) (scene-flags scf8))
               (not (-> self preload-sound))
               (-> self scene)
               (-> self scene end-point)
               (< 10.0 (ja-aframe-num 0))
               )
      (let ((t9-6 scene-decode-continue)
            (a0-20 (-> self end-point))
            )
        (set! a0-20 (cond
                      (a0-20
                        (empty)
                        a0-20
                        )
                      (else
                        (-> self scene end-point)
                        )
                      )
              )
        (let ((v1-49 (t9-6 a0-20)))
          (when v1-49
            (dotimes (a0-22 3)
              (set! (-> *load-state* want-sound a0-22 name) (-> v1-49 want-sound a0-22))
              (set! (-> *load-state* want-sound a0-22 mode) (sound-bank-mode unknown))
              (set! (-> *backup-load-state* want-sound a0-22 name) (-> v1-49 want-sound a0-22))
              (set! (-> *backup-load-state* want-sound a0-22 mode) (sound-bank-mode unknown))
              )
            (remove-setting! 'sound-bank-load)
            (add-borrow-levels *load-state*)
            )
          )
        )
      (set! (-> self preload-sound) (the-as basic #t))
      )
    ((-> self cur-trans-hook))
    )
  :code (behavior ()
    (local-vars (a0-29 symbol))
    (when (or *debug-menu-scene-play* (and (scene-select?) (-> self scene) (nonzero? (-> self scene scene-task))))
      (task-node-open! (the-as game-task-node (-> self scene scene-task)) 'event)
      (logior! (-> self mask) (process-mask no-kill))
      (if (not (logtest? (-> self scene scene-flags) (scene-flags scf6)))
          (reset-actors 'debug)
          )
      (logclear! (-> self mask) (process-mask no-kill))
      )
    (dotimes (gp-0 2)
      (let ((v1-17 (-> *art-control* buffer gp-0)))
        (if (= (-> v1-17 status) 'active)
            (link-art-to-master (-> v1-17 art-group))
            )
        )
      )
    (while (and (< (-> self scene-index) (-> self scene-list length)) (not (-> self aborted?)))
      (scene-player-method-23 self (the-as string (-> self scene-list (-> self scene-index))) #t)
      (kill-persister *setting-control* (the-as engine-pers 'title-control-scene) 'render)
      (set-blackout-frames (seconds 0.1))
      (suspend)
      (set-blackout-frames (seconds 0.1))
      (suspend)
      (when (not (-> *setting-control* user-current border-mode))
        (set! (-> *setting-control* user-default border-mode) #t)
        (set! (-> *level* play?) (-> *setting-control* user-default border-mode))
        (apply-settings *setting-control*)
        )
      (scene-player-method-25 self 0.0 -1.0)
      (set! (-> self cur-speed) 0.0)
      (set-time! (-> self scene-start-time))
      (ja-play-spooled-anim
        (-> self anim)
        (the-as art-joint-anim #f)
        (the-as art-joint-anim #f)
        (the-as
          (function process-drawable symbol)
          (if (logtest? (-> self scene scene-flags) (scene-flags scf1))
              (lambda :behavior scene-player () (when (cpad-pressed? 0 triangle)
                                                  (set! (-> self aborted?) #t)
                                                  (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
                                                  (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
                                                  #t
                                                  )
                                             )
              false-func
              )
          )
        (if (logtest? (-> self scene scene-flags) (scene-flags scf7))
            (spooler-flags)
            (spooler-flags blackout-on-stall)
            )
        )
      (while (-> self child)
        (deactivate (-> self child 0))
        )
      (+! (-> self scene-index) 1)
      (when (and (< (-> self scene-index) (-> self scene-list length)) (not (-> self aborted?)))
        (let ((v1-61 (scene-player-method-24 self (-> self scene-list (-> self scene-index)) #t)))
          (when v1-61
            (let ((a0-26 (scene-decode-continue (-> v1-61 load-point))))
              (set! a0-29 (when (and a0-26 (logtest? (-> a0-26 flags) (continue-flags scene-wait)))
                            (go-virtual wait a0-29)
                            a0-29
                            )
                    )
              )
            )
          )
        )
      )
    (if (and (-> self wait) *target* (focus-test? *target* grabbed))
        (go-virtual release)
        )
    )
  :post (behavior ()
    (when (-> self scene)
      (let ((gp-0 (-> self scene cut-list))
            (s5-0 (-> self skel root-channel 0 frame-group))
            )
        (when (not (or (null? gp-0) (not s5-0) (zero? s5-0)))
          (let ((v1-8 (the int (ja-frame-num 0)))
                (a0-2 (car gp-0))
                )
            (while (not (null? gp-0))
              (let ((f0-5 (/ (- (the float (/ (the-as int a0-2) 8)) (-> s5-0 artist-base)) (-> s5-0 artist-step))))
                (when (= v1-8 (if (= f0-5 (the float (the int f0-5)))
                                  (+ (the int f0-5) -1)
                                  (the int f0-5)
                                  )
                         )
                  (set! (-> self skel root-channel 0 frame-num) (the float (the int (-> self skel root-channel 0 frame-num))))
                  (set! (-> self pre-cut-frame) (the-as basic #t))
                  )
                )
              (set! gp-0 (cdr gp-0))
              (set! a0-2 (car gp-0))
              )
            )
          )
        )
      (if (-> self pre-cut-frame)
          (set! (-> self pre-cut-frame) #f)
          )
      )
    (when (and (-> self scene) (nonzero? (-> self skel active-channels)))
      (when (and (< (ja-aframe-num 0) 2.0)
                 (< (-> *display* base-clock frame-counter) (-> *game-info* blackout-time))
                 (logtest? (-> self skel status) (joint-control-status valid-spooled-frame))
                 )
        (set-blackout-frames 0)
        (set-blackout-frames (seconds 0.017))
        )
      (scene-player-method-25 self (ja-aframe-num 0) (-> self last-frame))
      (set! (-> self last-frame) (ja-aframe-num 0))
      (set! (-> self dma-max)
            (the-as uint (max
                           (the-as int (-> self dma-max))
                           (* (dma-buffer-length (-> *display* frames (-> *display* last-screen) global-buf)) 16)
                           )
                    )
            )
      (let ((gp-4 *display-scene-control*))
        (when (nonzero? gp-4)
          (if (logtest? gp-4 (scene-controls bounds-spheres))
              (debug-print-channels (-> self skel) (the-as symbol *stdcon*))
              )
          (if (logtest? gp-4 (scene-controls actors))
              (format *stdcon* "anim ~-30S " (-> self scene anim))
              )
          (if (logtest? gp-4 (scene-controls actor-marks))
              (format
                *stdcon*
                "dma ~DK / ~DK"
                (shr (* (dma-buffer-length (-> *display* frames (-> *display* last-screen) global-buf)) 16) 10)
                (shr (-> self dma-max) 10)
                )
              )
          (if (logtest? gp-4 (scene-controls actors actor-marks))
              (format *stdcon* "~%")
              )
          (when (logtest? gp-4 (scene-controls special-fma-spheres))
            (dotimes (s5-3 (-> self scene actor length))
              (let* ((s4-1 (handle->process (-> self scene actor s5-3 process)))
                     (v1-66 (if (type? s4-1 process-drawable)
                                (the-as process-drawable s4-1)
                                )
                            )
                     )
                (if (and v1-66 (nonzero? (-> v1-66 draw)))
                    (add-debug-sphere
                      #t
                      (bucket-id debug-no-zbuf1)
                      (-> v1-66 draw origin)
                      (-> v1-66 draw bounds w)
                      (new 'static 'rgba :b #xff :a #x80)
                      )
                    )
                )
              )
            )
          (when (logtest? gp-4 (scene-controls scene-controls-7))
            (dotimes (s5-4 (-> self scene actor length))
              (let* ((s4-2 (handle->process (-> self scene actor s5-4 process)))
                     (v1-82 (if (type? s4-2 process-drawable)
                                (the-as process-drawable s4-2)
                                )
                            )
                     )
                (if (and v1-82 (nonzero? (-> v1-82 draw)))
                    (format
                      *stdcon*
                      "~0K  ~-30S  ~S d:~4,,0m r:~4,,0m~1K~%"
                      (-> self scene actor s5-4 art-group)
                      (if (logtest? (-> v1-82 draw status) (draw-control-status on-screen))
                          "os"
                          "  "
                          )
                      (-> v1-82 draw distance)
                      (-> v1-82 draw bounds w)
                      )
                    )
                )
              )
            )
          (when (logtest? gp-4 (scene-controls scene-controls-8))
            (dotimes (gp-5 (-> self scene actor length))
              (let* ((s5-5 (handle->process (-> self scene actor gp-5 process)))
                     (v1-97 (if (type? s5-5 process-drawable)
                                (the-as process-drawable s5-5)
                                )
                            )
                     )
                (if (and v1-97 (nonzero? (-> v1-97 draw)))
                    (add-debug-text-3d
                      #t
                      (bucket-id debug-no-zbuf1)
                      (-> v1-97 name)
                      (-> v1-97 draw origin)
                      (font-color yellow)
                      (new 'static 'vector2h :y 8)
                      )
                    )
                )
              )
            )
          )
        )
      )
    (when (cpad-pressed? 0 square)
      (set! (-> *setting-control* user-default subtitle) (not (-> *setting-control* user-default subtitle)))
      (set-time! (-> self subtitle-change-time))
      )
    (when (and (not (time-elapsed? (-> self subtitle-change-time) (seconds 2)))
               (< (mod (- (current-time) (-> self subtitle-change-time)) 300) 210)
               )
      (let ((gp-6
              (new 'stack 'font-context *font-default-matrix* 36 60 0.0 (font-color default) (font-flags shadow kerning))
              )
            )
        (let ((v1-124 gp-6))
          (set! (-> v1-124 width) (the float 440))
          )
        (let ((v1-125 gp-6))
          (set! (-> v1-125 height) (the float 48))
          )
        (let ((v1-126 gp-6))
          (set! (-> v1-126 scale) 0.5)
          )
        (set! (-> gp-6 flags) (font-flags shadow kerning middle large))
        (print-game-text
          (lookup-text!
            *common-text*
            (if (-> *setting-control* user-default subtitle)
                (text-id text-020b)
                (text-id text-020c)
                )
            #f
            )
          gp-6
          #f
          44
          (bucket-id hud-draw-pris2)
          )
        )
      )
    (process-drawable-draw-subtitles)
    (when (-> self scene)
      (let ((gp-7
              (lookup-gui-connection *gui-control* self (gui-channel art-load) (-> self scene anim) (new 'static 'sound-id))
              )
            )
        (when (and (= *cheat-mode* 'debug) (!= *external-cam-mode* 'pad-0))
          (cond
            ((cpad-hold? 0 r1)
             (if (cpad-pressed? 0 circle)
                 (set-time! (-> self speed-press-time))
                 )
             (seek!
               (-> self speed-change-speed)
               8.0
               (* (lerp-scale 0.01 0.3 (the float (- (current-time) (-> self speed-press-time))) 0.0 300.0)
                  (-> self clock time-adjust-ratio)
                  )
               )
             )
            ((cpad-hold? 0 l1)
             (if (cpad-pressed? 0 square)
                 (set-time! (-> self speed-press-time))
                 )
             (seek!
               (-> self speed-change-speed)
               -8.0
               (* (lerp-scale 0.01 0.3 (the float (- (current-time) (-> self speed-press-time))) 0.0 300.0)
                  (-> self clock time-adjust-ratio)
                  )
               )
             )
            ((cpad-hold? 0 x)
             (when (cpad-pressed? 0 x)
               (set-time! (-> self speed-press-time))
               (cond
                 ((= (-> self cur-speed) 0.0)
                  (set! (-> self speed-change-speed) -1000.0)
                  )
                 (else
                   (set! (-> self targ-speed) 0.0)
                   (set! (-> self speed-change-speed) 0.0)
                   )
                 )
               )
             )
            (else
              (set! (-> self speed-change-speed) 0.0)
              )
            )
          )
        (cond
          ((not gp-7)
           )
          ((= (-> self cur-speed) -1000.0)
           (format *stdcon* "scene paused~%")
           (when (!= (-> self targ-speed) -1000.0)
             (sound-continue (-> gp-7 id))
             (when *sound-player-enable*
               (let ((v1-190 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
                 (set! (-> v1-190 command) (sound-command set-param))
                 (set! (-> v1-190 id) (-> gp-7 id))
                 (set! (-> v1-190 params pitch-mod) 0)
                 (set! (-> v1-190 params mask) (the-as uint 2))
                 (-> v1-190 id)
                 )
               )
             (set! (-> self targ-speed) 0.0)
             (set! (-> self cur-speed) 0.0)
             (set-time! (-> self speed-change-time))
             )
           )
          ((= (-> self speed-change-speed) -1000.0)
           (when (!= (-> self cur-speed) -1000.0)
             (set-time! (-> self speed-change-time))
             (set! (-> self targ-speed) -1000.0)
             (set! (-> self cur-speed) -1000.0)
             (sound-pause (-> gp-7 id))
             )
           )
          (else
            (set! (-> self targ-speed)
                  (fmax -10.0 (fmin 10.0 (+ (-> self targ-speed) (* (-> self speed-change-speed) (seconds-per-frame)))))
                  )
            (if (and (= *cheat-mode* 'debug) (not (time-elapsed? (-> self speed-change-time) (seconds 3))))
                (format
                  *stdcon*
                  "id ~d speed ~f~%"
                  (if gp-7
                      (the-as int (-> gp-7 id))
                      0
                      )
                  (-> self targ-speed)
                  )
                )
            (cond
              ((!= (-> self targ-speed) 0.0)
               )
              ((logtest? (game-secrets fast-movie) (-> *game-info* secrets))
               (set! (-> self targ-speed) 0.2)
               )
              ((logtest? (game-secrets slow-movie) (-> *game-info* secrets))
               (set! (-> self targ-speed) -0.2)
               )
              )
            (when (and gp-7 (and (!= (-> self targ-speed) (-> self cur-speed))
                                 (< (-> self speed-change-time) (current-time))
                                 (time-elapsed? (-> self scene-start-time) (seconds 1))
                                 )
                       )
              (when *sound-player-enable*
                (let ((v1-229 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
                  (set! (-> v1-229 command) (sound-command set-param))
                  (set! (-> v1-229 id) (-> gp-7 id))
                  (set! (-> v1-229 params pitch-mod) (the int (* 1524.0 (-> self targ-speed))))
                  (set! (-> v1-229 params mask) (the-as uint 2))
                  (-> v1-229 id)
                  )
                )
              (set! (-> self cur-speed) (-> self targ-speed))
              (set-time! (-> self speed-change-time))
              )
            )
          )
        )
      )
    )
  )

;; definition for function scene-player-init
;; WARN: Return type mismatch object vs none.
;; INFO: Process stack size was changed from 512 to 1024
(defbehavior scene-player-init scene-player ((arg0 object) (arg1 symbol) (arg2 string))
  (process-entity-set! self (the-as entity #f))
  (stack-size-set! (-> self main-thread) 1024)
  (set! (-> self root) (new 'process 'trsqv))
  (case (rtype-of arg0)
    ((array)
     (set! (-> self scene-list) (new 'process 'boxed-array scene (-> (the-as (array scene) arg0) length)))
     (dotimes (v1-7 (-> self scene-list length))
       (set! (-> self scene-list v1-7) (-> (the-as (array scene) arg0) v1-7))
       )
     )
    ((pair)
     (let ((s3-0 (method-of-type array new))
           (s2-0 'process)
           (s1-0 array)
           (s0-0 scene)
           (a0-14 arg0)
           )
       (set! (-> self scene-list)
             (the-as (array scene) (s3-0 s2-0 s1-0 s0-0 ((method-of-type (rtype-of a0-14) length) a0-14)))
             )
       )
     (dotimes (s3-1 (-> self scene-list length))
       (set! (-> self scene-list s3-1) (the-as scene (ref arg0 s3-1)))
       )
     )
    (else
      (set! (-> self scene-list) (new 'process 'boxed-array scene 1))
      (set! (-> self scene-list 0) (the-as scene arg0))
      )
    )
  (set! (-> self preload-continue) arg2)
  (set! (-> self camera) (the-as handle #f))
  (set! (-> self wait) arg1)
  (set! (-> self pre-cut-frame) #f)
  (set! (-> self aborted?) #f)
  (set! (-> self blackout-end) (the-as basic 'none))
  (set! (-> self end-point) #f)
  (set! (-> self preload-sound) #f)
  (set! (-> self draw) (new 'process 'draw-control self #f))
  (set! (-> self skel) (new 'process 'joint-control 48))
  (set! (-> self anim) (new 'static 'spool-anim))
  (set! (-> self next-anim) (new 'static 'spool-anim))
  (dotimes (s4-1 (-> self scene-list length))
    (let ((v1-30 (scene-lookup (-> self scene-list s4-1))))
      (if v1-30
          (set! (-> self scene-list s4-1) v1-30)
          )
      )
    )
  (cond
    ((= (-> self scene-list (-> self scene-index) type) scene)
     (set! (-> self scene) (-> self scene-list (-> self scene-index)))
     (if (-> self scene)
         (init-spool-by-scene! (-> self scene) (-> self anim))
         )
     )
    (else
      (set-blackout-frames (seconds 0.2))
      (set! (-> self scene) #f)
      )
    )
  (set! (-> self gui-id) (add-process
                           *gui-control*
                           self
                           (gui-channel movie)
                           (gui-action play)
                           (the-as string (cond
                                            ((= (rtype-of arg0) string)
                                             (empty)
                                             arg0
                                             )
                                            (else
                                              "movie"
                                              )
                                            )
                                   )
                           -99.0
                           0
                           )
        )
  (set! *scene-player* (the-as (pointer scene-player) (process->ppointer self)))
  (set! *display-entity-errors* #f)
  (set-setting! 'speech-control #f 0.0 0)
  (set-setting! 'allow-progress #f 0.0 0)
  (if (or (= (cond
               ((-> self scene)
                (if (>= (-> self scene music-volume) 0.0)
                    (-> self scene music-volume)
                    (-> *setting-control* user-current music-volume-movie)
                    )
                )
               (else
                 0.0
                 )
               )
             0.0
             )
          (not (-> *setting-control* user-current music))
          (!= (-> *setting-control* user-target music) (-> *setting-control* user-current music))
          )
      (set-setting! 'music #f 0.0 0)
      )
  (apply-settings *setting-control*)
  (set! (-> self new-trans-hook) nothing)
  (set! (-> self cur-trans-hook) nothing)
  (go-virtual wait arg1)
  (none)
  )

;; definition for method 17 of type scene
(defmethod load-scene ((this scene))
  (let ((v1-1 (-> *level* loading-level)))
    (if v1-1
        (set-loaded-art (-> v1-1 art-group) this)
        )
    )
  this
  )
