;;-*-Lisp-*-
(in-package goal)

;; definition of type cam-point-watch-bank
(deftype cam-point-watch-bank (basic)
  ((speed      float)
   (rot-speed  degrees)
   )
  )

;; definition for method 3 of type cam-point-watch-bank
(defmethod inspect ((this cam-point-watch-bank))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this (-> this type))
  (format #t "~1Tspeed: ~f~%" (-> this speed))
  (format #t "~1Trot-speed: (deg ~r)~%" (-> this rot-speed))
  (label cfg-4)
  this
  )

;; definition for symbol *CAM_POINT_WATCH-bank*, type cam-point-watch-bank
(define *CAM_POINT_WATCH-bank* (new 'static 'cam-point-watch-bank :speed 1600.0 :rot-speed (degrees 0.6)))

;; failed to figure out what this is:
(defstate cam-point-watch (camera-slave)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('teleport)
       #f
       )
      (else
        (cam-standard-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self pivot-rad) 40960.0)
      (set! (-> self blend-from-type) (camera-blend-from-type unknown-1))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-1))
      )
    )
  :code (behavior ()
    (until #f
      (let ((s5-0 (new-stack-vector0))
            (gp-0 (new-stack-vector0))
            )
        (when (not (logtest? (-> *camera* settings master-options) (cam-master-options IGNORE_ANALOG)))
          (let ((f28-0 (analog-input (the-as int (-> *cpad-list* cpads 0 leftx)) 128.0 48.0 110.0 -1.0))
                (f30-0 (analog-input (the-as int (-> *cpad-list* cpads 0 lefty)) 128.0 48.0 110.0 -1.0))
                (f26-0 (analog-input (the-as int (-> *cpad-list* cpads 0 rightx)) 128.0 48.0 110.0 -1.0))
                (f0-0 (analog-input (the-as int (-> *cpad-list* cpads 0 righty)) 128.0 48.0 110.0 -1.0))
                )
            (cond
              ((cpad-hold? (-> *CAMERA-bank* joypad) r2)
               (set! (-> s5-0 y) (- (-> s5-0 y) (* 0.2 (-> *CAM_POINT_WATCH-bank* rot-speed) (- f26-0))))
               (set! (-> s5-0 x) (- (-> s5-0 x) (* 0.2 (-> *CAM_POINT_WATCH-bank* rot-speed) (- f0-0))))
               (+! (-> gp-0 x) (* 0.2 (-> *CAM_POINT_WATCH-bank* speed) f28-0))
               (+! (-> gp-0 z) (* 0.2 (-> *CAM_POINT_WATCH-bank* speed) f30-0))
               )
              (else
                (set! (-> s5-0 y) (- (-> s5-0 y) (* 2.0 (-> *CAM_POINT_WATCH-bank* rot-speed) (- f26-0))))
                (set! (-> s5-0 x) (- (-> s5-0 x) (* 2.0 (-> *CAM_POINT_WATCH-bank* rot-speed) (- f0-0))))
                (+! (-> gp-0 x) (* 2.0 (-> *CAM_POINT_WATCH-bank* speed) f28-0))
                (+! (-> gp-0 z) (* 2.0 (-> *CAM_POINT_WATCH-bank* speed) f30-0))
                )
              )
            )
          (let ((s4-0 (new-stack-vector0)))
            (let ((s3-0 (new 'stack-no-clear 'matrix)))
              (set! (-> s3-0 rvec quad) (the-as uint128 0))
              (set! (-> s3-0 uvec quad) (the-as uint128 0))
              (set! (-> s3-0 fvec quad) (the-as uint128 0))
              (set! (-> s3-0 trans quad) (the-as uint128 0))
              (matrix-axis-angle! s3-0 (the-as vector (-> self tracking)) (- (-> s5-0 x)))
              (vector-matrix*! s4-0 (-> self tracking inv-mat fvec) s3-0)
              (matrix-axis-angle! s3-0 (-> *camera* local-down) (- (-> s5-0 y)))
              (vector-matrix*! s4-0 s4-0 s3-0)
              )
            (forward-down->inv-matrix (the-as matrix (-> self tracking)) s4-0 (-> *camera* local-down))
            )
          (set! (-> self pivot-rad) (- (-> self pivot-rad) (-> gp-0 z)))
          (if (< (-> self pivot-rad) 4096.0)
              (set! (-> self pivot-rad) 4096.0)
              )
          (set-vector! gp-0 0.0 0.0 (- (-> self pivot-rad)) 1.0)
          (vector-matrix*! (-> self trans) gp-0 (the-as matrix (-> self tracking)))
          )
        )
      (suspend)
      0
      )
    #f
    )
  )

;; definition of type cam-free-bank
(deftype cam-free-bank (basic)
  ((speed      float)
   (rot-speed  degrees)
   )
  )

;; definition for method 3 of type cam-free-bank
(defmethod inspect ((this cam-free-bank))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this (-> this type))
  (format #t "~1Tspeed: ~f~%" (-> this speed))
  (format #t "~1Trot-speed: (deg ~r)~%" (-> this rot-speed))
  (label cfg-4)
  this
  )

;; definition for symbol *CAM_FREE-bank*, type cam-free-bank
(define *CAM_FREE-bank* (new 'static 'cam-free-bank :speed 1600.0 :rot-speed (degrees 0.6)))

;; definition for function cam-mouse-input
(defun cam-mouse-input ((arg0 matrix) (arg1 vector) (arg2 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((v1-0 (new 'stack-no-clear 'vector)))
      (vector-! v1-0 (the-as vector (-> *mouse* pos)) (-> *mouse* pos 1))
      (if (< (-> *camera* interest-dist) 409.6)
          (set! (-> *camera* interest-dist) 409.6)
          )
      (let ((s3-0 (new 'stack-no-clear 'vector))
            (s2-0 (new 'stack-no-clear 'vector))
            )
        (let ((a0-9 (new 'stack-no-clear 'vector)))
          0.0
          (let ((a1-3 a0-9))
            (let ((a2-4 (-> *math-camera* trans)))
              (let ((a3-0 (-> arg0 fvec)))
                (let ((t0-1 (-> *camera* interest-dist)))
                  (.mov vf7 t0-1)
                  )
                (.lvf vf5 (&-> a3-0 quad))
                )
              (.lvf vf4 (&-> a2-4 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a1-3 quad) vf6)
            )
          (vector-! s3-0 (-> *math-camera* trans) a0-9)
          )
        (vector-length s3-0)
        (cond
          ((mouse-hold? left)
           (let ((f30-0 (* 72.81778 (-> *mouse* speedy)))
                 (f28-0 (* -72.81778 (-> *mouse* speedx)))
                 )
             (let ((a2-8 (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) (-> arg0 rvec) f30-0)))
               (vector-orient-by-quat! s2-0 s3-0 a2-8)
               )
             (let ((a2-10 (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) *y-vector* f28-0)))
               (vector-orient-by-quat! s2-0 s2-0 a2-10)
               )
             (vector-! s2-0 s2-0 s3-0)
             (vector-matrix*! s2-0 s2-0 (matrix-4x4-inverse! (new 'stack-no-clear 'matrix) arg0))
             (+! (-> arg2 x) (-> s2-0 x))
             (+! (-> arg2 y) (-> s2-0 y))
             (+! (-> arg2 z) (-> s2-0 z))
             (+! (-> arg1 x) f30-0)
             (set! (-> arg1 y) (+ (-> arg1 y) f28-0))
             )
           )
          ((mouse-hold? right)
           (+! (-> arg2 z) (* (-> v1-0 x) (-> *CAM_FREE-bank* speed)))
           (set! (-> *camera* interest-dist) (- (-> *camera* interest-dist) (* (-> *CAM_FREE-bank* speed) (-> v1-0 x))))
           (if (< (-> *camera* interest-dist) 409.6)
               (set! (-> *camera* interest-dist) 409.6)
               )
           (when (< -8192.0 (vector-dot (-> arg0 fvec) s3-0))
             (let ((t0-2 (new 'static 'vector :w 1.0)))
               (let ((v1-18 t0-2))
                 (let ((a0-33 (-> *setting-control* cam-current mouse-tumble-point)))
                   (let ((a1-12 (-> arg0 fvec)))
                     (let ((a2-13 8192.0))
                       (.mov vf7 a2-13)
                       )
                     (.lvf vf5 (&-> a1-12 quad))
                     )
                   (.lvf vf4 (&-> a0-33 quad))
                   )
                 (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                 (.mul.x.vf acc vf5 vf7 :mask #b111)
                 (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                 (.svf (&-> v1-18 quad) vf6)
                 )
               (set-setting! 'mouse-tumble-point 'abs t0-2 0)
               )
             )
           )
          ((mouse-hold? middle)
           (+! (-> arg2 x) (* (-> v1-0 x) (-> *CAM_FREE-bank* speed)))
           (+! (-> arg2 y) (* (-> v1-0 y) (-> *CAM_FREE-bank* speed)))
           (new 'static 'vector :w 1.0)
           #f
           )
          )
        )
      )
    )
  )

;; definition for function cam-free-floating-input
(defun cam-free-floating-input ((arg0 matrix) (arg1 vector) (arg2 vector) (arg3 int) (arg4 int))
  (with-pp
    (when *camera*
      (if (-> *setting-control* cam-current mouse-input)
          (cam-mouse-input arg0 arg1 arg2)
          )
      (let ((s3-0 (and (-> *setting-control* cam-current cpad1-skip-buttons) (= arg4 1)))
            (f30-0 (-> *CAM_FREE-bank* speed))
            )
        (if *camera-turbo-free*
            (set! f30-0 (* 10.0 f30-0))
            )
        (cond
          ((logtest? (-> *camera* settings master-options) (cam-master-options IGNORE_ANALOG))
           )
          ((cpad-hold? arg4 r2)
           (when (logtest? (-> *camera* settings master-options) (cam-master-options READ_BUTTONS))
             (if (cpad-hold? arg4 r1)
                 (+! (-> arg2 y)
                     (+ (* 0.2 f30-0)
                        (analog-input (the-as int (-> *cpad-list* cpads arg4 abutton 9)) 0.0 32.0 230.0 (* 0.2 f30-0))
                        )
                     )
                 )
             )
           (when (logtest? (-> *camera* settings master-options) (cam-master-options READ_BUTTONS))
             (if (cpad-hold? arg4 l1)
                 (set! (-> arg2 y)
                       (- (-> arg2 y)
                          (+ (* 0.2 f30-0)
                             (analog-input (the-as int (-> *cpad-list* cpads arg4 abutton 8)) 0.0 32.0 230.0 (* 0.2 f30-0))
                             )
                          )
                       )
                 )
             )
           )
          (else
            (when (logtest? (-> *camera* settings master-options) (cam-master-options READ_BUTTONS))
              (if (cpad-hold? arg4 r1)
                  (+! (-> arg2 y)
                      (+ f30-0 (analog-input (the-as int (-> *cpad-list* cpads arg4 abutton 9)) 0.0 32.0 230.0 f30-0))
                      )
                  )
              )
            (when (logtest? (-> *camera* settings master-options) (cam-master-options READ_BUTTONS))
              (if (cpad-hold? arg4 l1)
                  (set! (-> arg2 y)
                        (- (-> arg2 y)
                           (+ f30-0 (analog-input (the-as int (-> *cpad-list* cpads arg4 abutton 8)) 0.0 32.0 230.0 f30-0))
                           )
                        )
                  )
              )
            )
          )
        (when (not (logtest? (-> *camera* settings master-options) (cam-master-options IGNORE_ANALOG)))
          (let ((f26-2 (analog-input
                         (the-as int (-> (the-as cpad-list (+ (* arg4 4) (the-as int *cpad-list*))) cpads 0 leftx))
                         128.0
                         48.0
                         110.0
                         -1.0
                         )
                       )
                (f28-4 (analog-input
                         (the-as int (-> (the-as cpad-list (+ (* arg4 4) (the-as int *cpad-list*))) cpads 0 lefty))
                         128.0
                         48.0
                         110.0
                         -1.0
                         )
                       )
                (f24-0 (analog-input
                         (the-as int (-> (the-as cpad-list (+ (* arg4 4) (the-as int *cpad-list*))) cpads 0 rightx))
                         128.0
                         48.0
                         110.0
                         -1.0
                         )
                       )
                (f0-19 (analog-input
                         (the-as int (-> (the-as cpad-list (+ (* arg4 4) (the-as int *cpad-list*))) cpads 0 righty))
                         128.0
                         48.0
                         110.0
                         -1.0
                         )
                       )
                )
            (cond
              ((and (not s3-0)
                    (logtest? (-> (the-as cpad-list (+ (* arg4 4) (the-as int *cpad-list*))) cpads 0 button0-abs 0)
                              (pad-buttons r2)
                              )
                    )
               (cond
                 ((logtest? (-> (the-as cpad-list (+ (* arg4 4) (the-as int *cpad-list*))) cpads 0 button0-abs 0)
                            (pad-buttons l2)
                            )
                  (set! (-> arg1 y) (- (-> arg1 y) (* 0.5 (-> *CAM_FREE-bank* rot-speed) (- f24-0))))
                  (set! (-> arg1 x) (- (-> arg1 x) (* 0.5 (-> *CAM_FREE-bank* rot-speed) (- f0-19))))
                  )
                 (else
                   (set! (-> arg1 y) (- (-> arg1 y) (* (- f24-0) (-> *CAM_FREE-bank* rot-speed))))
                   (set! (-> arg1 x) (- (-> arg1 x) (* (- f0-19) (-> *CAM_FREE-bank* rot-speed))))
                   )
                 )
               (+! (-> arg2 x) (* 0.2 f30-0 f26-2))
               (+! (-> arg2 z) (* 0.2 f30-0 f28-4))
               )
              ((and (not s3-0) (cpad-hold? arg4 l2))
               (+! (-> arg2 x) (* f26-2 f30-0))
               (+! (-> arg2 y) (* f0-19 f30-0))
               (+! (-> arg2 z) (* f28-4 f30-0))
               )
              (else
                (set! (-> arg1 y) (- (-> arg1 y) (* 2.0 (-> *CAM_FREE-bank* rot-speed) (- f24-0))))
                (set! (-> arg1 x) (- (-> arg1 x) (* 2.0 (-> *CAM_FREE-bank* rot-speed) (- f0-19))))
                (+! (-> arg2 x) (* 2.0 f30-0 f26-2))
                (+! (-> arg2 z) (* 2.0 f30-0 f28-4))
                )
              )
            )
          )
        )
      (when (not (-> *setting-control* cam-current mouse-input))
        (vector-float*! arg1 arg1 (-> pp clock time-adjust-ratio))
        (vector-float*! arg2 arg2 (-> pp clock time-adjust-ratio))
        )
      )
    )
  )

;; definition of type camera-free-floating-move-info
(deftype camera-free-floating-move-info (structure)
  ((rv  vector  :inline)
   (tv  vector  :inline)
   (up  vector  :inline)
   (tm  matrix  :inline)
   )
  )

;; definition for method 3 of type camera-free-floating-move-info
(defmethod inspect ((this camera-free-floating-move-info))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'camera-free-floating-move-info)
  (format #t "~1Trv: #<vector @ #x~X>~%" (-> this rv))
  (format #t "~1Ttv: #<vector @ #x~X>~%" (-> this tv))
  (format #t "~1Tup: #<vector @ #x~X>~%" (-> this up))
  (format #t "~1Ttm: #<matrix @ #x~X>~%" (-> this tm))
  (label cfg-4)
  this
  )

;; definition for function cam-free-floating-move
(defun cam-free-floating-move ((arg0 matrix) (arg1 vector) (arg2 vector) (arg3 int))
  (if (logtest? (-> *cpad-list* cpads arg3 valid) 128)
      (return (the-as vector #f))
      )
  (if (= *master-mode* 'menu)
      (return (the-as vector #f))
      )
  (let ((s3-0 (new 'stack 'camera-free-floating-move-info)))
    (cam-free-floating-input arg0 (-> s3-0 rv) (-> s3-0 tv) (the-as int (not arg2)) arg3)
    (vector-matrix*! (-> s3-0 tv) (-> s3-0 tv) arg0)
    (cond
      (arg2
        (matrix-axis-angle! (-> s3-0 tm) arg2 (-> s3-0 rv y))
        (matrix*! arg0 arg0 (-> s3-0 tm))
        (cond
          ((< (vector-dot (-> arg0 uvec) arg2) 0.0)
           (forward-down->inv-matrix arg0 (-> arg0 fvec) arg2)
           )
          (else
            (vector-negate! (-> s3-0 up) arg2)
            (forward-down->inv-matrix arg0 (-> arg0 fvec) (-> s3-0 up))
            )
          )
        )
      (else
        (matrix-axis-angle! (-> s3-0 tm) (-> arg0 uvec) (- (-> s3-0 rv y)))
        (matrix*! arg0 arg0 (-> s3-0 tm))
        )
      )
    (matrix-axis-angle! (-> s3-0 tm) (-> arg0 rvec) (- (-> s3-0 rv x)))
    (matrix*! arg0 arg0 (-> s3-0 tm))
    (matrix-axis-angle! (-> s3-0 tm) (-> arg0 fvec) (- (-> s3-0 rv z)))
    (matrix*! arg0 arg0 (-> s3-0 tm))
    (vector+! arg1 arg1 (-> s3-0 tv))
    )
  )

;; failed to figure out what this is:
(defstate cam-free-floating (camera-slave)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('teleport)
       #f
       )
      (else
        (cam-standard-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self blend-from-type) (camera-blend-from-type unknown-1))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-1))
      (send-event *camera-combiner* 'stop-tracking)
      )
    )
  :code (behavior ()
    (until #f
      (let ((gp-0 (-> *camera* local-down)))
        (if (logtest? (-> self options) (cam-slave-options-u32 ALLOW_Z_ROT))
            (set! gp-0 (the-as vector #f))
            )
        (when (not (-> *setting-control* cam-current mouse-input))
          (if *amy-cam*
              (matrix-rotate-y! (the-as matrix (-> self tracking)) 32768.0)
              )
          (cam-free-floating-move
            (the-as matrix (-> self tracking))
            (-> self trans)
            gp-0
            (the-as int (-> *CAMERA-bank* joypad))
            )
          (when *amy-cam*
            (matrix-rotate-y! (the-as matrix (-> self tracking)) 32768.0)
            (let ((a1-4 (matrix-rotate-x! (new 'stack-no-clear 'matrix) 16384.0)))
              (matrix*! (the-as matrix (-> self tracking)) a1-4 (the-as matrix (-> self tracking)))
              )
            )
          )
        )
      (suspend)
      )
    #f
    )
  )




