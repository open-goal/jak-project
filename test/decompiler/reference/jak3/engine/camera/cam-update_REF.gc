;;-*-Lisp-*-
(in-package goal)

;; definition for function plane-from-points
(defun plane-from-points ((arg0 (inline-array plane)) (arg1 vector) (arg2 vector) (arg3 vector) (arg4 int))
  (let ((s4-0 (new 'stack-no-clear 'vector)))
    (vector-cross! s4-0 arg1 arg2)
    (vector-normalize! s4-0 1.0)
    (set! (-> s4-0 w) (vector-dot s4-0 arg3))
    (set! (-> (&-> arg0 0 data arg4) 0) (-> s4-0 x))
    (set! (-> (&-> arg0 0 data arg4) 4) (-> s4-0 y))
    (set! (-> (&-> arg0 0 data arg4) 8) (-> s4-0 z))
    (set! (-> (&-> arg0 0 data arg4) 12) (-> s4-0 w))
    )
  )

;; definition for function set-point
(defun set-point ((arg0 vector) (arg1 float) (arg2 float) (arg3 float))
  (set! (-> arg0 x) arg1)
  (set! (-> arg0 y) arg2)
  (set! (-> arg0 z) arg3)
  (set! (-> arg0 w) 1.0)
  )

;; definition for function update-view-planes
;; INFO: Used lq/sq
(defun update-view-planes ((arg0 math-camera) (arg1 (inline-array plane)) (arg2 float) (arg3 matrix))
  (local-vars (sv-240 vector))
  (when (not *artist-fix-frustum*)
    (let ((s5-0 (new 'stack 'view-frustum)))
      (let ((f30-0 (* arg2 (-> arg0 x-ratio) (-> arg0 d)))
            (f26-0 (* arg2 (-> arg0 y-ratio) (-> arg0 d)))
            (f28-0 (* arg2 (-> arg0 x-ratio) (-> arg0 f)))
            (f24-0 (* arg2 (-> arg0 y-ratio) (-> arg0 f)))
            )
        (set-point (-> s5-0 hither-top-left) (- f30-0) f26-0 (-> arg0 d))
        (set-point (-> s5-0 hither-top-right) f30-0 f26-0 (-> arg0 d))
        (set-point (-> s5-0 hither-bottom-left) (- f30-0) (- f26-0) (-> arg0 d))
        (set-point (-> s5-0 hither-bottom-right) f30-0 (- f26-0) (-> arg0 d))
        (set-point (-> s5-0 yon-top-left) (- f28-0) f24-0 (-> arg0 f))
        (set-point (-> s5-0 yon-top-right) f28-0 f24-0 (-> arg0 f))
        (set-point (-> s5-0 yon-bottom-left) (- f28-0) (- f24-0) (-> arg0 f))
        (set-point (-> s5-0 yon-bottom-right) f28-0 (- f24-0) (-> arg0 f))
        )
      (vector-matrix*! (-> s5-0 hither-top-left) (-> s5-0 hither-top-left) arg3)
      (vector-matrix*! (-> s5-0 hither-top-right) (-> s5-0 hither-top-right) arg3)
      (vector-matrix*! (-> s5-0 hither-bottom-left) (-> s5-0 hither-bottom-left) arg3)
      (vector-matrix*! (-> s5-0 hither-bottom-right) (-> s5-0 hither-bottom-right) arg3)
      (vector-matrix*! (-> s5-0 yon-top-left) (-> s5-0 yon-top-left) arg3)
      (vector-matrix*! (-> s5-0 yon-top-right) (-> s5-0 yon-top-right) arg3)
      (vector-matrix*! (-> s5-0 yon-bottom-left) (-> s5-0 yon-bottom-left) arg3)
      (vector-matrix*! (-> s5-0 yon-bottom-right) (-> s5-0 yon-bottom-right) arg3)
      (when (= arg2 1.0)
        (let ((v1-4 *fog-texture-work*))
          (vector-! (the-as vector (-> v1-4 corner)) (-> s5-0 yon-top-left) (-> arg3 trans))
          (vector-! (-> v1-4 corner 1) (-> s5-0 yon-top-right) (-> arg3 trans))
          (vector-! (-> v1-4 corner 2) (-> s5-0 yon-bottom-left) (-> arg3 trans))
          (vector-! (-> v1-4 corner 3) (-> s5-0 yon-bottom-right) (-> arg3 trans))
          )
        )
      (let ((s2-1 (new-stack-vector0))
            (s3-1 (new-stack-vector0))
            (s1-0 (new-stack-vector0))
            (s0-0 (new-stack-vector0))
            )
        (set! (-> (new 'stack-no-clear 'vector) quad) (the-as uint128 0))
        (set! sv-240 (new 'stack-no-clear 'vector))
        (set! (-> sv-240 quad) (the-as uint128 0))
        (let ((v1-9 (-> arg3 trans quad)))
          (set! (-> sv-240 quad) v1-9)
          )
        (vector-! s2-1 (-> s5-0 yon-top-left) sv-240)
        (vector-! s3-1 (-> s5-0 yon-top-right) sv-240)
        (vector-! s1-0 (-> s5-0 yon-bottom-left) sv-240)
        (vector-! s0-0 (-> s5-0 yon-bottom-right) sv-240)
        (plane-from-points arg1 s2-1 s1-0 sv-240 0)
        (plane-from-points arg1 s0-0 s3-1 sv-240 1)
        (plane-from-points arg1 s3-1 s2-1 sv-240 2)
        (let ((t9-20 plane-from-points)
              (t0-3 3)
              )
          (t9-20 arg1 s1-0 s0-0 sv-240 t0-3)
          )
        )
      )
    )
  )

;; definition for symbol *update-leaf-when-outside-bsp*, type symbol
(define *update-leaf-when-outside-bsp* #t)

;; definition for function update-visible
;; INFO: Used lq/sq
(defun update-visible ((arg0 math-camera))
  (local-vars (s4-0 level-vis-info))
  (when (not *artist-fix-visible*)
    (dotimes (s5-0 (-> *level* length))
      (let ((v1-5 (-> *level* level s5-0)))
        (when (= (-> v1-5 status) 'active)
          (if (and (nonzero? (-> v1-5 bsp nodes)) (or *update-leaf-when-outside-bsp* (-> v1-5 inside-boxes?)))
              (bsp-camera-asm (-> v1-5 bsp) (-> arg0 trans))
              )
          )
        )
      )
    (dotimes (gp-1 (-> *level* length))
      (let ((s5-1 (-> *level* level gp-1)))
        (when (= (-> s5-1 status) 'active)
          (let ((a2-0 (/ (+ (-> s5-1 bsp visible-list-length) 15) 16)))
            (set! (-> s5-1 all-visible?) (if (-> s5-1 all-visible?)
                                             (-> s5-1 all-visible?)
                                             #t
                                             )
                  )
            (cond
              ((or (not (-> s5-1 force-all-visible?)) (-> s5-1 inside-boxes?))
               (cond
                 ((or *artist-all-visible* (not (-> s5-1 vis-info 0)))
                  (quad-copy! (-> s5-1 vis-bits) (-> s5-1 bsp all-visible-list) a2-0)
                  (if (= (-> s5-1 all-visible?) 'loading)
                      (set! (-> s5-1 all-visible?) #t)
                      )
                  )
                 ((begin
                    (set! s4-0 (-> s5-1 vis-info (-> s5-1 vis-self-index)))
                    (let ((v1-32 #f))
                      (when (and s4-0 (-> s4-0 from-bsp))
                        (set! v1-32 (logtest? (vis-info-flag vis-valid) (-> s4-0 flags)))
                        (if (< (-> s4-0 length) (-> s4-0 from-bsp current-leaf-idx))
                            (set! v1-32 #f)
                            )
                        )
                      v1-32
                      )
                    )
                  (if (!= (-> s5-1 all-visible?) 'loading)
                      (set! (-> s5-1 all-visible?) #f)
                      )
                  (when (update-vis! s5-1 s4-0 (-> s4-0 ramdisk) (the-as (pointer uint8) (-> s4-0 string-block)))
                    (countdown (v1-40 8)
                      (let ((a0-27 (-> s5-1 vis-info v1-40)))
                        (when a0-27
                          (if (!= a0-27 s4-0)
                              (set! (-> a0-27 current-vis-string) (the-as uint -1))
                              )
                          )
                        )
                      )
                    (set! (-> s5-1 all-visible?) #f)
                    )
                  )
                 ((and (= (-> s5-1 all-visible?) 'loading) (-> *level* play?))
                  )
                 (else
                   (quad-copy! (-> s5-1 vis-bits) (-> s5-1 bsp all-visible-list) a2-0)
                   )
                 )
               )
              (else
                (quad-copy! (-> s5-1 vis-bits) (-> s5-1 bsp all-visible-list) a2-0)
                )
              )
            )
          )
        )
      )
    )
  (let ((gp-2 0))
    (if (and *artist-fix-visible* (cpad-pressed? 0 r2))
        (set! *fix-visible-level-mask* (logand (+ *fix-visible-level-mask* 1) 127))
        )
    (dotimes (s5-2 (-> *level* length))
      (let ((s4-1 (-> *level* level s5-2)))
        (when (= (-> s4-1 status) 'active)
          (cond
            ((or *artist-fix-visible* *stats-bsp*)
             (set! (-> s4-1 render?) (not (logtest? *fix-visible-level-mask* (ash 1 gp-2))))
             (if (!= (-> s4-1 bsp visible-list-length) 4)
                 (format
                   *stdcon*
                   "~0kleaf-index ~8S ~C = ~d node ~d ~S ~S~%"
                   (-> s4-1 name)
                   (if (not (logtest? *fix-visible-level-mask* (ash 1 gp-2)))
                       88
                       32
                       )
                   (-> s4-1 bsp current-leaf-idx)
                   (-> s4-1 bsp cam-box-idx)
                   (if (zero? (-> s4-1 bsp cam-using-back))
                       "front"
                       "back"
                       )
                   (if (nonzero? (-> s4-1 bsp cam-outside-bsp))
                       "outside"
                       ""
                       )
                   )
                 )
             )
            (else
              (set! (-> s4-1 render?) #t)
              )
            )
          (when (and *artist-fix-visible* (not (logtest? *fix-visible-level-mask* (ash 1 gp-2))))
            (let ((s3-0 (-> s4-1 bsp current-leaf-idx))
                  (s2-0 (-> s4-1 bsp vis-spheres))
                  )
              (-> s4-1 bsp vis-spheres-length)
              (when (nonzero? s2-0)
                (dotimes (s1-0 (-> s2-0 length))
                  (let* ((v1-95 (the int (-> s2-0 data s1-0 w)))
                         (a0-45 (abs v1-95))
                         )
                    (when (= a0-45 s3-0)
                      (if (>= v1-95 0)
                          (add-debug-sphere #t (bucket-id debug) (-> s2-0 data s1-0) (meters 1) (new 'static 'rgba :b #xff :a #x80))
                          (add-debug-sphere #t (bucket-id debug) (-> s2-0 data s1-0) (meters 1) (new 'static 'rgba :r #xff :a #x80))
                          )
                      )
                    )
                  )
                )
              )
            (when (nonzero? (-> s4-1 bsp nodes))
              (let ((v1-109 (-> s4-1 bsp nodes (-> s4-1 bsp cam-box-idx)))
                    (a2-7 (new 'stack-no-clear 'vector))
                    )
                (set! (-> a2-7 quad) (-> s4-1 bsp bsp-offset quad))
                (let ((a3-6 (new 'stack-no-clear 'vector)))
                  (set! (-> a3-6 quad) (-> s4-1 bsp bsp-offset quad))
                  (cond
                    ((zero? (-> s4-1 bsp cam-using-back))
                     (+! (-> a2-7 x) (the float (* (-> v1-109 front-box-min x) (the int (-> s4-1 bsp bsp-scale x)))))
                     (+! (-> a2-7 y) (the float (* (-> v1-109 front-box-min y) (the int (-> s4-1 bsp bsp-scale y)))))
                     (+! (-> a2-7 z) (the float (* (-> v1-109 front-box-min z) (the int (-> s4-1 bsp bsp-scale z)))))
                     (+! (-> a3-6 x) (the float (* (-> v1-109 front-box-max x) (the int (-> s4-1 bsp bsp-scale x)))))
                     (+! (-> a3-6 y) (the float (* (-> v1-109 front-box-max y) (the int (-> s4-1 bsp bsp-scale y)))))
                     (+! (-> a3-6 z) (the float (* (-> v1-109 front-box-max z) (the int (-> s4-1 bsp bsp-scale z)))))
                     )
                    (else
                      (+! (-> a2-7 x) (the float (* (-> v1-109 back-box-min x) (the int (-> s4-1 bsp bsp-scale x)))))
                      (+! (-> a2-7 y) (the float (* (-> v1-109 back-box-min y) (the int (-> s4-1 bsp bsp-scale y)))))
                      (+! (-> a2-7 z) (the float (* (-> v1-109 back-box-min z) (the int (-> s4-1 bsp bsp-scale z)))))
                      (+! (-> a3-6 x) (the float (* (-> v1-109 back-box-max x) (the int (-> s4-1 bsp bsp-scale x)))))
                      (+! (-> a3-6 y) (the float (* (-> v1-109 back-box-max y) (the int (-> s4-1 bsp bsp-scale y)))))
                      (+! (-> a3-6 z) (the float (* (-> v1-109 back-box-max z) (the int (-> s4-1 bsp bsp-scale z)))))
                      )
                    )
                  (add-debug-box #t (bucket-id debug) a2-7 a3-6 (new 'static 'rgba :g #xff :b #xff :a #x80))
                  )
                )
              )
            )
          (if (!= (-> s4-1 bsp visible-list-length) 4)
              (+! gp-2 1)
              )
          )
        )
      )
    )
  #f
  )

;; definition for symbol *save-camera-inv-rot*, type matrix
(define *save-camera-inv-rot* (new 'global 'matrix))

;; failed to figure out what this is:
(matrix-identity! *save-camera-inv-rot*)

;; definition for function move-camera-from-pad
;; INFO: Used lq/sq
(defun move-camera-from-pad ((arg0 math-camera))
  (let ((v1-0 *external-cam-mode*)
        (s5-0 0)
        )
    (cond
      ((= v1-0 'locked)
       (set! v1-0 #f)
       )
      ((= v1-0 'pad-1)
       (set! s5-0 1)
       )
      ((not *camera-combiner*)
       (set! v1-0 'pad-0)
       )
      )
    (when v1-0
      (let ((a2-1
              (vector-negate-in-place! (vector-normalize-copy! (new-stack-vector0) (-> *standard-dynamics* gravity) 1.0))
              )
            )
        (if (= (vector-length a2-1) 0.0)
            (set! (-> a2-1 y) -1.0)
            )
        (if (logtest? *external-cam-options* (external-cam-option allow-z))
            (set! a2-1 (the-as vector #f))
            )
        (cam-free-floating-move *save-camera-inv-rot* (-> arg0 trans) a2-1 s5-0)
        )
      )
    )
  (let* ((a2-2 (-> *math-camera* inv-camera-rot))
         (a3-1 *save-camera-inv-rot*)
         (v1-14 (-> a3-1 rvec quad))
         (a0-13 (-> a3-1 uvec quad))
         (a1-2 (-> a3-1 fvec quad))
         (a3-2 (-> a3-1 trans quad))
         )
    (set! (-> a2-2 rvec quad) v1-14)
    (set! (-> a2-2 uvec quad) a0-13)
    (set! (-> a2-2 fvec quad) a1-2)
    (set! (-> a2-2 trans quad) a3-2)
    )
  arg0
  )

;; definition for function external-cam-reset!
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defun external-cam-reset! ()
  (when (not (movie?))
    (vector-reset! (-> *math-camera* trans))
    (matrix-identity! (-> *math-camera* inv-camera-rot))
    (when *camera-combiner*
      (let* ((v1-7 (-> *math-camera* inv-camera-rot))
             (a3-0 (-> *camera-combiner* inv-camera-rot))
             (a0-2 (-> a3-0 rvec quad))
             (a1-0 (-> a3-0 uvec quad))
             (a2-0 (-> a3-0 fvec quad))
             (a3-1 (-> a3-0 trans quad))
             )
        (set! (-> v1-7 rvec quad) a0-2)
        (set! (-> v1-7 uvec quad) a1-0)
        (set! (-> v1-7 fvec quad) a2-0)
        (set! (-> v1-7 trans quad) a3-1)
        )
      (set! (-> *math-camera* trans quad) (-> *camera-combiner* trans quad))
      )
    )
  0
  (none)
  )

;; definition for symbol *start-timer*, type int
(define *start-timer* (the-as int #f))

;; definition for symbol *timer-value*, type int
(define *timer-value* 0)

;; definition for symbol *start-pos*, type vector
(define *start-pos* (new 'global 'vector))

;; definition for function update-camera
;; INFO: Used lq/sq
(defun update-camera ()
  (with-pp
    (let ((gp-0 *math-camera*))
      (let* ((a2-0 (-> gp-0 prev-inv-camera-rot))
             (a3-0 (-> gp-0 inv-camera-rot))
             (v1-0 (-> a3-0 rvec quad))
             (a0-0 (-> a3-0 uvec quad))
             (a1-0 (-> a3-0 fvec quad))
             (a3-1 (-> a3-0 trans quad))
             )
        (set! (-> a2-0 rvec quad) v1-0)
        (set! (-> a2-0 uvec quad) a0-0)
        (set! (-> a2-0 fvec quad) a1-0)
        (set! (-> a2-0 trans quad) a3-1)
        )
      (set! (-> gp-0 prev-trans quad) (-> gp-0 trans quad))
      (when *start-timer*
        (when (= *timer-value* 180)
          (format
            #t
            "Player pos = ~F ~F ~F~%"
            (-> *target* control trans x)
            (-> *target* control trans y)
            (-> *target* control trans z)
            )
          (set! (-> *start-pos* quad) (-> *target* control trans quad))
          )
        (when (= *timer-value* 480)
          (format
            #t
            "Player pos = ~F ~F ~F~%"
            (-> *target* control trans x)
            (-> *target* control trans y)
            (-> *target* control trans z)
            )
          (format
            #t
            "Dist = ~F~%"
            (* 0.00024414062 (vector-vector-xz-distance (-> *target* control trans) *start-pos*))
            )
          (set! *start-timer* (the-as int #f))
          )
        (if (< 179 *timer-value*)
            (format *stdcon* "~%~%Time = ~D~%" *timer-value*)
            )
        (set! *timer-value* (+ *timer-value* 1))
        )
      (when (not *start-timer*)
        (set! *timer-value* 0)
        0
        )
      (let ((f0-9 (if (get-menu-mode *blit-displays-work*)
                      11650.845
                      (-> gp-0 fov)
                      )
                  )
            )
        (update-math-camera
          gp-0
          (-> *setting-control* user-current video-mode)
          (-> *setting-control* user-current aspect-ratio)
          f0-9
          )
        )
      (cond
        ((or (= *master-mode* 'pause) (or (= *master-mode* 'freeze) (= *master-mode* 'progress) *progress-process*))
         )
        ((>= *camera-look-through-other* 2)
         (set! *camera-look-through-other* 1)
         )
        ((and (= *camera-look-through-other* 1) (!= *master-mode* 'menu))
         (set! *camera-look-through-other* 0)
         0
         )
        )
      0.0
      0.0
      0.0
      (let ((s5-1 (new 'stack-no-clear 'vector))
            (s4-1 (-> pp clock))
            )
        (set! (-> pp clock) (-> *display* camera-clock))
        (update! *camera-smush-control*)
        (let ((f28-0 (get-no-update *camera-smush-control*)))
          (update! *camera-smush-control-horizontal*)
          (let ((f30-1 (get-no-update *camera-smush-control-horizontal*)))
            (update! *camera-smush-control-into*)
            (get-no-update *camera-smush-control-into*)
            (set! (-> pp clock) s4-1)
            (cond
              (*external-cam-mode*
                (move-camera-from-pad gp-0)
                )
              ((nonzero? *camera-look-through-other*)
               (set! (-> gp-0 fov) (-> *camera-other-fov* data))
               (set! (-> gp-0 trans quad) (-> *camera-other-trans* quad))
               (+! (-> gp-0 trans y) f28-0)
               (let* ((a2-6 (-> gp-0 inv-camera-rot))
                      (a3-5 *camera-other-matrix*)
                      (v1-76 (-> a3-5 rvec quad))
                      (a0-34 (-> a3-5 uvec quad))
                      (a1-7 (-> a3-5 fvec quad))
                      (a3-6 (-> a3-5 trans quad))
                      )
                 (set! (-> a2-6 rvec quad) v1-76)
                 (set! (-> a2-6 uvec quad) a0-34)
                 (set! (-> a2-6 fvec quad) a1-7)
                 (set! (-> a2-6 trans quad) a3-6)
                 )
               (let* ((a2-7 *save-camera-inv-rot*)
                      (a3-7 *camera-other-matrix*)
                      (v1-77 (-> a3-7 rvec quad))
                      (a0-35 (-> a3-7 uvec quad))
                      (a1-8 (-> a3-7 fvec quad))
                      (a3-8 (-> a3-7 trans quad))
                      )
                 (set! (-> a2-7 rvec quad) v1-77)
                 (set! (-> a2-7 uvec quad) a0-35)
                 (set! (-> a2-7 fvec quad) a1-8)
                 (set! (-> a2-7 trans quad) a3-8)
                 )
               )
              ((and *camera-combiner* (not *external-cam-mode*))
               (set! (-> gp-0 fov) (-> *camera-combiner* fov))
               (set! (-> gp-0 trans quad) (-> *camera-combiner* trans quad))
               (+! (-> gp-0 trans y) f28-0)
               (let* ((v1-84 (-> gp-0 inv-camera-rot))
                      (a3-9 (-> *camera-combiner* inv-camera-rot))
                      (a0-40 (-> a3-9 rvec quad))
                      (a1-9 (-> a3-9 uvec quad))
                      (a2-8 (-> a3-9 fvec quad))
                      (a3-10 (-> a3-9 trans quad))
                      )
                 (set! (-> v1-84 rvec quad) a0-40)
                 (set! (-> v1-84 uvec quad) a1-9)
                 (set! (-> v1-84 fvec quad) a2-8)
                 (set! (-> v1-84 trans quad) a3-10)
                 )
               (let* ((v1-85 *save-camera-inv-rot*)
                      (a3-11 (-> *camera-combiner* inv-camera-rot))
                      (a0-42 (-> a3-11 rvec quad))
                      (a1-10 (-> a3-11 uvec quad))
                      (a2-9 (-> a3-11 fvec quad))
                      (a3-12 (-> a3-11 trans quad))
                      )
                 (set! (-> v1-85 rvec quad) a0-42)
                 (set! (-> v1-85 uvec quad) a1-10)
                 (set! (-> v1-85 fvec quad) a2-9)
                 (set! (-> v1-85 trans quad) a3-12)
                 )
               )
              (*camera*
                (move-camera-from-pad gp-0)
                )
              )
            (when (or (nonzero? *camera-look-through-other*) (and *camera-combiner* (not *external-cam-mode*)))
              0.0
              (set-vector! s5-1 f30-1 0.0 0.0 1.0)
              (vector-rotate*! s5-1 s5-1 (-> gp-0 inv-camera-rot))
              (set! (-> s5-1 y) 0.0)
              (vector+! (-> gp-0 trans) (-> gp-0 trans) s5-1)
              )
            )
          )
        )
      (matrix-transpose! (-> gp-0 camera-rot) (-> gp-0 inv-camera-rot))
      (cond
        (*camera-no-mip-correction*
          (set! (-> gp-0 fov-correction-factor) 1.0)
          )
        (else
          (let ((f0-27 (fmin 11650.845 (-> gp-0 fov))))
            (set! (-> gp-0 fov-correction-factor) (* 0.00008583069 f0-27))
            )
          )
        )
      (if (< 0.0 (-> gp-0 smooth-t))
          (set! (-> gp-0 smooth-t) (- (-> gp-0 smooth-t) (-> gp-0 smooth-step)))
          )
      (cond
        ((< 0.0 (-> gp-0 smooth-t))
         (let ((s5-2 (new-stack-quaternion0)))
           (matrix->quaternion s5-2 (-> gp-0 inv-camera-rot))
           (quaternion-slerp! s5-2 s5-2 (-> gp-0 inv-camera-rot-smooth-from) (-> gp-0 smooth-t))
           (quaternion->matrix (-> gp-0 inv-camera-rot-smooth) s5-2)
           )
         )
        (else
          (let* ((a2-12 (-> gp-0 inv-camera-rot-smooth))
                 (a3-14 (-> gp-0 inv-camera-rot))
                 (v1-106 (-> a3-14 rvec quad))
                 (a0-51 (-> a3-14 uvec quad))
                 (a1-16 (-> a3-14 fvec quad))
                 (a3-15 (-> a3-14 trans quad))
                 )
            (set! (-> a2-12 rvec quad) v1-106)
            (set! (-> a2-12 uvec quad) a0-51)
            (set! (-> a2-12 fvec quad) a1-16)
            (set! (-> a2-12 trans quad) a3-15)
            )
          )
        )
      (when (and (!= *master-mode* 'menu) *display-camera-info*)
        (when *target*
          (let ((v1-112 (target-pos 0)))
            (format *stdcon* "targ pos ~M ~M ~M~%" (-> v1-112 x) (-> v1-112 y) (-> v1-112 z))
            )
          )
        (format
          *stdcon*
          "cam pos ~M ~M ~M fov ~R~%"
          (-> gp-0 trans x)
          (-> gp-0 trans y)
          (-> gp-0 trans z)
          (-> gp-0 fov)
          )
        (let ((v1-115 (-> *setting-control* cam-current)))
          (format
            *stdcon*
            "string info min-l ~M max-l ~M min-h ~M max-h ~M~%"
            (-> v1-115 string-min-length)
            (-> v1-115 string-max-length)
            (-> v1-115 string-min-height)
            (-> v1-115 string-max-height)
            )
          )
        )
      (when (zero? (-> gp-0 reset))
        (let* ((a2-16 (-> gp-0 prev-camera-temp))
               (a3-19 (-> gp-0 camera-temp))
               (v1-119 (-> a3-19 rvec quad))
               (a0-58 (-> a3-19 uvec quad))
               (a1-20 (-> a3-19 fvec quad))
               (a3-20 (-> a3-19 trans quad))
               )
          (set! (-> a2-16 rvec quad) v1-119)
          (set! (-> a2-16 uvec quad) a0-58)
          (set! (-> a2-16 fvec quad) a1-20)
          (set! (-> a2-16 trans quad) a3-20)
          )
        )
      (let ((s3-1 (-> gp-0 camera-temp))
            (s2-0 (-> gp-0 camera-rot))
            (s5-3 (-> gp-0 inv-camera-rot))
            (s4-2 (-> gp-0 trans))
            )
        (let ((s1-0 (new-stack-vector0)))
          (set! (-> s1-0 x) (- (-> s4-2 x)))
          (set! (-> s1-0 y) (- (-> s4-2 y)))
          (set! (-> s1-0 z) (- (-> s4-2 z)))
          (set! (-> s1-0 w) 1.0)
          (vector-matrix*! s1-0 s1-0 s2-0)
          (set! (-> s2-0 trans quad) (-> s1-0 quad))
          )
        (matrix*! s3-1 s2-0 (-> gp-0 perspective))
        (set! (-> s5-3 trans quad) (-> s4-2 quad))
        )
      (when (nonzero? (-> gp-0 reset))
        (let* ((a2-19 (-> gp-0 prev-camera-temp))
               (a3-21 (-> gp-0 camera-temp))
               (v1-125 (-> a3-21 rvec quad))
               (a0-61 (-> a3-21 uvec quad))
               (a1-23 (-> a3-21 fvec quad))
               (a3-22 (-> a3-21 trans quad))
               )
          (set! (-> a2-19 rvec quad) v1-125)
          (set! (-> a2-19 uvec quad) a0-61)
          (set! (-> a2-19 fvec quad) a1-23)
          (set! (-> a2-19 trans quad) a3-22)
          )
        (set! (-> gp-0 reset) 0)
        0
        )
      (let ((f1-5 (-> gp-0 fog-min))
            (f0-52 (-> gp-0 fog-max))
            )
        (let ((f2-0 (-> gp-0 d)))
          (set! (-> *instance-tie-work* hmge-d x) f1-5)
          (set! (-> *instance-tie-work* hmge-d y) f0-52)
          (set! (-> *instance-tie-work* hmge-d z) (* 32.0 f2-0))
          (set! (-> *instance-tie-work* hmge-d w) (* f2-0 (-> gp-0 hmge-scale w)))
          (let ((v1-132 (-> gp-0 hvdf-off quad)))
            (set! (-> *instance-tie-work* hvdf-offset quad) v1-132)
            )
          (set! (-> *instance-shrub-work* hmge-d x) f1-5)
          (set! (-> *instance-shrub-work* hmge-d y) f0-52)
          (set! (-> *instance-shrub-work* hmge-d z) (* 3.0 f2-0))
          (set! (-> *instance-shrub-work* hmge-d w) (* f2-0 (-> gp-0 hmge-scale w)))
          (set! (-> *instance-shrub-work* billboard-const x) (/ (-> gp-0 x-pix) (* f2-0 (-> gp-0 x-ratio))))
          (set! (-> *instance-shrub-work* billboard-const y) (/ (-> gp-0 y-pix) (* f2-0 (-> gp-0 y-ratio))))
          )
        (set! (-> *instance-shrub-work* billboard-const z) f1-5)
        (set! (-> *instance-shrub-work* billboard-const w) f0-52)
        )
      (set! (-> *instance-shrub-work* constants w) (the-as float (-> gp-0 vis-gifs 0)))
      (let ((a0-63 (-> gp-0 hvdf-off quad)))
        (set! (-> *instance-shrub-work* hvdf-offset quad) a0-63)
        )
      (update-view-planes gp-0 (-> gp-0 plane) 1.0 (-> gp-0 inv-camera-rot))
      (update-view-planes gp-0 (-> gp-0 guard-plane) 2.0 (-> gp-0 inv-camera-rot))
      (shrub-make-perspective-matrix (-> gp-0 shrub-mat) (-> gp-0 camera-temp))
      (update-visible gp-0)
      (when (-> *time-of-day-context* use-camera-other)
        (let ((s4-3 (-> gp-0 camera-rot))
              (s0-0 (-> gp-0 camera-rot-other-sky))
              (s5-4 (-> gp-0 camera-rot-other-sprite))
              (s3-2 (-> gp-0 camera-rot-other))
              (s2-1 (-> gp-0 inv-camera-rot-other))
              (s1-1 (-> gp-0 camera-temp-other))
              )
          (quaternion->matrix s0-0 (-> gp-0 quat-other))
          (mem-copy! (the-as pointer s5-4) (the-as pointer s0-0) 64)
          (set! (-> s5-4 trans quad) (-> gp-0 trans-other quad))
          (set! (-> s5-4 trans w) 1.0)
          (matrix*! s3-2 s5-4 s4-3)
          (matrix-inverse-of-rot-trans! s2-1 s3-2)
          (matrix*! s1-1 s3-2 (-> gp-0 perspective))
          (update-view-planes gp-0 (-> gp-0 plane-other) 1.0 s2-1)
          (update-view-planes gp-0 (-> gp-0 guard-plane-other) 2.0 s2-1)
          (shrub-make-perspective-matrix (-> gp-0 shrub-mat-other) s1-1)
          )
        )
      )
    #f
    )
  )

;; definition (debug) for function move-level-by-name
(defun-debug move-level-by-name ((arg0 symbol) (arg1 float) (arg2 float) (arg3 float))
  (let ((v1-1 (level-get *level* arg0)))
    (when v1-1
      (logior! (-> v1-1 info level-flags) (level-flags use-camera-other))
      (let ((v0-1 (-> *math-camera* trans-other)))
        (set! (-> v0-1 x) (* 4096.0 arg1))
        (set! (-> v0-1 y) (* 4096.0 arg2))
        (set! (-> v0-1 z) (* 4096.0 arg3))
        (set! (-> v0-1 w) 1.0)
        v0-1
        )
      )
    )
  )

;; definition for function execute-cam-post-hook-engine
(defun execute-cam-post-hook-engine ()
  (let* ((gp-0 *cam-post-hook-engine*)
         (s5-0 (-> gp-0 alive-list next0))
         (s4-0 (-> s5-0 next0))
         )
    (while (!= s5-0 (-> gp-0 alive-list-end))
      ((the-as (function object object object object object) (-> (the-as connection s5-0) param0))
       (get-process (the-as connection s5-0))
       (-> (the-as connection s5-0) param1)
       (-> (the-as connection s5-0) param2)
       (-> (the-as connection s5-0) param2)
       )
      (set! s5-0 s4-0)
      (set! s4-0 (-> s4-0 next0))
      )
    )
  0
  )
