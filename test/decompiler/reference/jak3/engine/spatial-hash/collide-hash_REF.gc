;;-*-Lisp-*-
(in-package goal)

;; definition for function add-collide-debug-box
;; WARN: Return type mismatch symbol vs none.
(defun add-collide-debug-box ((arg0 vector) (arg1 rgba))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (let ((a3-0 (new 'stack-no-clear 'bounding-box)))
      (nop!)
      (.lvf vf1 (&-> arg0 quad))
      (.sub.w.vf vf2 vf1 vf1)
      (nop!)
      (.add.w.vf vf3 vf1 vf1)
      (nop!)
      (nop!)
      (.svf (&-> a3-0 min quad) vf2)
      (nop!)
      (.svf (&-> a3-0 max quad) vf3)
      (add-debug-box #t (bucket-id debug) (-> a3-0 min) (-> a3-0 max) arg1)
      )
    (none)
    )
  )

;; definition (debug) for function print-collide-cache-tri-count
;; WARN: Return type mismatch object vs none.
(defun-debug print-collide-cache-tri-count ()
  (let ((gp-0 0)
        (s4-0 0)
        (s5-0 0)
        (s3-0 0)
        )
    (let ((v1-0 *collide-cache*))
      (dotimes (a0-0 (-> v1-0 num-tris))
        (case (-> v1-0 tris a0-0 pat mode)
          (((pat-mode ground))
           (+! gp-0 1)
           )
          (((pat-mode wall))
           (+! s5-0 1)
           )
          (((pat-mode obstacle))
           (+! s4-0 1)
           )
          (else
            (+! s3-0 1)
            )
          )
        )
      (format *stdcon* "tris ~d (~4,,1f%) " (-> v1-0 num-tris) (* 0.2173913 (the float (-> v1-0 num-tris))))
      )
    (format *stdcon* "(ground ~d, wall ~d, obstacle ~d, other ~d)~%" gp-0 s5-0 s4-0 s3-0)
    )
  (none)
  )

;; definition (debug) for function print-exceeded-max-cache-tris
;; WARN: Return type mismatch int vs none.
(defun-debug print-exceeded-max-cache-tris ()
  (with-pp
    (when (not (or *already-printed-exeeded-max-cache-tris* *display-capture-mode*))
      (set! *already-printed-exeeded-max-cache-tris* #t)
      (if pp
          (format *stdcon* "Exceeded collide cache max # of tris (~s)!~%" (-> pp name))
          (format *stdcon* "Exceeded collide cache max # of tris!~%")
          )
      (print-collide-cache-tri-count)
      )
    0
    (none)
    )
  )

;; definition for method 11 of type collide-hash
;; INFO: function output is handled by mips2c
(defmethod-mips2c "(method 11 collide-hash)" 11 collide-hash)

;; definition for method 12 of type collide-hash
;; INFO: function output is handled by mips2c
(defmethod-mips2c "(method 12 collide-hash)" 12 collide-hash)

;; definition for function fill-bg-using-box-new
;; INFO: function output is handled by mips2c
(def-mips2c fill-bg-using-box-new (function collide-cache object collide-query none))

;; definition for function fill-bg-using-line-sphere-new
;; INFO: function output is handled by mips2c
(def-mips2c fill-bg-using-line-sphere-new (function collide-cache object collide-query none))

;; definition for function collide-list-fill-bg-using-box
;; INFO: Used lq/sq
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Stack slot offset 640 signed mismatch
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Stack slot offset 640 signed mismatch
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Stack slot offset 640 signed mismatch
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Stack slot offset 640 signed mismatch
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Return type mismatch int vs none.
(defun collide-list-fill-bg-using-box ((arg0 collide-cache) (arg1 collide-list) (arg2 collide-query))
  (local-vars
    (v1-12 uint128)
    (v1-14 uint128)
    (v1-15 uint128)
    (a0-10 uint128)
    (a0-11 uint128)
    (a1-3 uint128)
    (a2-3 uint128)
    (a2-4 uint128)
    (sv-16 int)
    (sv-20 collide-list)
    (sv-640 int)
    )
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf12 :class vf)
         (vf13 :class vf)
         (vf14 :class vf)
         (vf16 :class vf)
         (vf17 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (set! sv-16 (-> arg1 num-items))
    (set! sv-20 arg1)
    (dotimes (s4-0 sv-16)
      (let ((s3-0 (-> sv-20 items s4-0 mesh)))
        (cond
          ((= (-> s3-0 type) instance-tie)
           (let* ((v1-4 s3-0)
                  (s1-0 (-> v1-4 bucket-ptr))
                  )
             (when (not (or (logtest? (-> s1-0 flags) (prototype-flags no-collide))
                            (logtest? (-> v1-4 flags) (instance-flags no-collide))
                            )
                        )
               (if *collide-list-boxes*
                   (add-collide-debug-box (-> s3-0 bsphere) (new 'static 'rgba :r #xff :a #x80))
                   )
               (let ((s0-0 (new 'stack-no-clear 'matrix))
                     (s2-0 (new 'stack-no-clear 'collide-query))
                     )
                 (mem-copy! (the-as pointer s2-0) (the-as pointer arg2) 540)
                 (nop!)
                 (nop!)
                 (let ((v1-11 (the-as uint128 (-> s3-0 origin long 3))))
                   (nop!)
                   (let ((a2-2 (the-as uint128 (-> s3-0 origin long 0))))
                     (.pextlh v1-12 v1-11 0)
                     (let ((a0-9 (the-as uint128 (-> s3-0 origin long 1))))
                       (.pw.sra a1-3 v1-12 10)
                       (let ((v1-13 (the-as uint128 (-> s3-0 origin long 2))))
                         (.pextlh a2-3 a2-2 0)
                         (nop!)
                         (.pw.sra a2-4 a2-3 16)
                         (nop!)
                         (.pextlh a0-10 a0-9 0)
                         (.mov vf4 a1-3)
                         (.pw.sra a0-11 a0-10 16)
                         (.mov vf1 a2-4)
                         (.pextlh v1-14 v1-13 0)
                         )
                       )
                     )
                   )
                 (.mov vf2 a0-11)
                 (.pw.sra v1-15 v1-14 16)
                 (.lvf vf5 (&-> s3-0 bsphere quad))
                 (nop!)
                 (.mov vf3 v1-15)
                 (.itof.vf vf4 vf4)
                 (nop!)
                 (vitof12.xyzw vf1 vf1)
                 (nop!)
                 (vitof12.xyzw vf2 vf2)
                 (nop!)
                 (vitof12.xyzw vf3 vf3)
                 (nop!)
                 (.add.vf vf4 vf4 vf5 :mask #b111)
                 (nop!)
                 (nop!)
                 (.svf (&-> s2-0 instance-mat rvec quad) vf1)
                 (nop!)
                 (.svf (&-> s2-0 instance-mat uvec quad) vf2)
                 (nop!)
                 (.svf (&-> s2-0 instance-mat fvec quad) vf3)
                 (nop!)
                 (.svf (&-> s2-0 instance-mat trans quad) vf4)
                 (matrix-4x4-inverse! s0-0 (-> s2-0 instance-mat))
                 (nop!)
                 (nop!)
                 (.lvf vf7 (&-> arg2 bbox min quad))
                 (nop!)
                 (.lvf vf14 (&-> arg2 bbox max quad))
                 (nop!)
                 (.lvf vf1 (&-> s0-0 rvec quad))
                 (nop!)
                 (.lvf vf2 (&-> s0-0 uvec quad))
                 (nop!)
                 (.lvf vf3 (&-> s0-0 fvec quad))
                 (nop!)
                 (.lvf vf4 (&-> s0-0 trans quad))
                 (.mul.w.vf acc vf4 vf0)
                 (nop!)
                 (.add.mul.x.vf acc vf1 vf7 acc)
                 (nop!)
                 (.add.mul.y.vf acc vf2 vf7 acc)
                 (nop!)
                 (.add.mul.z.vf vf8 vf3 vf14 acc)
                 (nop!)
                 (.mul.w.vf acc vf4 vf0)
                 (nop!)
                 (.add.mul.x.vf acc vf1 vf7 acc)
                 (nop!)
                 (.add.mul.y.vf acc vf2 vf14 acc)
                 (nop!)
                 (.add.mul.z.vf vf9 vf3 vf7 acc)
                 (nop!)
                 (.mul.w.vf acc vf4 vf0)
                 (nop!)
                 (.add.mul.x.vf acc vf1 vf7 acc)
                 (nop!)
                 (.add.mul.y.vf acc vf2 vf14 acc)
                 (nop!)
                 (.add.mul.z.vf vf10 vf3 vf14 acc)
                 (nop!)
                 (.min.vf vf5 vf8 vf9)
                 (nop!)
                 (.max.vf vf6 vf8 vf9)
                 (nop!)
                 (.mul.w.vf acc vf4 vf0)
                 (nop!)
                 (.add.mul.x.vf acc vf1 vf14 acc)
                 (nop!)
                 (.add.mul.y.vf acc vf2 vf7 acc)
                 (nop!)
                 (.add.mul.z.vf vf11 vf3 vf7 acc)
                 (nop!)
                 (.min.vf vf5 vf5 vf10)
                 (nop!)
                 (.max.vf vf6 vf6 vf10)
                 (nop!)
                 (.mul.w.vf acc vf4 vf0)
                 (nop!)
                 (.add.mul.x.vf acc vf1 vf14 acc)
                 (nop!)
                 (.add.mul.y.vf acc vf2 vf7 acc)
                 (nop!)
                 (.add.mul.z.vf vf12 vf3 vf14 acc)
                 (nop!)
                 (.min.vf vf5 vf5 vf11)
                 (nop!)
                 (.max.vf vf6 vf6 vf11)
                 (nop!)
                 (.mul.w.vf acc vf4 vf0)
                 (nop!)
                 (.add.mul.x.vf acc vf1 vf14 acc)
                 (nop!)
                 (.add.mul.y.vf acc vf2 vf14 acc)
                 (nop!)
                 (.add.mul.z.vf vf13 vf3 vf7 acc)
                 (nop!)
                 (.min.vf vf5 vf5 vf12)
                 (nop!)
                 (.max.vf vf6 vf6 vf12)
                 (nop!)
                 (.mul.w.vf acc vf4 vf0)
                 (nop!)
                 (.add.mul.x.vf acc vf1 vf14 acc)
                 (nop!)
                 (.add.mul.y.vf acc vf2 vf14 acc)
                 (nop!)
                 (.add.mul.z.vf vf14 vf3 vf14 acc)
                 (nop!)
                 (.min.vf vf5 vf5 vf13)
                 (nop!)
                 (.max.vf vf6 vf6 vf13)
                 (nop!)
                 (.mul.w.vf acc vf4 vf0)
                 (nop!)
                 (.add.mul.x.vf acc vf1 vf7 acc)
                 (nop!)
                 (.add.mul.y.vf acc vf2 vf7 acc)
                 (nop!)
                 (.add.mul.z.vf vf7 vf3 vf7 acc)
                 (nop!)
                 (.min.vf vf5 vf5 vf14)
                 (nop!)
                 (.max.vf vf6 vf6 vf14)
                 (nop!)
                 (.min.vf vf5 vf5 vf7)
                 (nop!)
                 (.max.vf vf6 vf6 vf7)
                 (nop!)
                 (.ftoi.vf vf16 vf5)
                 (nop!)
                 (.ftoi.vf vf17 vf6)
                 (nop!)
                 (nop!)
                 (.svf (&-> s2-0 bbox min quad) vf5)
                 (nop!)
                 (.svf (&-> s2-0 bbox max quad) vf6)
                 (nop!)
                 (.svf (&-> s2-0 bbox4w min quad) vf16)
                 (nop!)
                 (.svf (&-> s2-0 bbox4w max quad) vf17)
                 (let ((s1-1 (-> s1-0 collide-hash-fragment-array)))
                   (set! sv-640 (-> s1-1 length))
                   (set! (-> s2-0 instance-ptr) s3-0)
                   (dotimes (s3-1 sv-640)
                     (set! (-> (the-as collide-hash-scratch #x70000000) collidable-bits 0) (the-as uint128 0))
                     (set! (-> (the-as collide-hash-scratch #x70000000) collidable-bits 1) (the-as uint128 0))
                     (set! (-> (the-as collide-hash-scratch #x70000000) tris) (the-as uint 0))
                     (fill-bg-using-box-new arg0 (-> s1-1 fragments s3-1) s2-0)
                     (+! (-> *collide-stats* tris) (-> (the-as collide-hash-scratch #x70000000) tris))
                     )
                   )
                 )
               )
             )
           )
          (else
            (if *collide-list-boxes*
                (add-collide-debug-box (-> s3-0 bsphere) (new 'static 'rgba :r #xff :g #xff :a #x80))
                )
            (set! (-> (the-as collide-hash-scratch #x70000000) collidable-bits 0) (the-as uint128 0))
            (set! (-> (the-as collide-hash-scratch #x70000000) collidable-bits 1) (the-as uint128 0))
            (set! (-> arg2 instance-ptr) #f)
            (set! (-> (the-as collide-hash-scratch #x70000000) tris) (the-as uint 0))
            (fill-bg-using-box-new arg0 s3-0 arg2)
            (+! (-> *collide-stats* tris) (-> (the-as collide-hash-scratch #x70000000) tris))
            )
          )
        )
      )
    0
    (none)
    )
  )

;; definition for function collide-list-fill-bg-using-line-sphere
;; INFO: Used lq/sq
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Stack slot offset 640 signed mismatch
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Stack slot offset 640 signed mismatch
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Stack slot offset 640 signed mismatch
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Stack slot offset 640 signed mismatch
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Return type mismatch int vs none.
;; ERROR: Unsupported inline assembly instruction kind - [sll v1, v1, 16]
(defun collide-list-fill-bg-using-line-sphere ((arg0 collide-cache) (arg1 collide-list) (arg2 collide-query))
  (local-vars
    (v1-12 uint128)
    (v1-14 uint128)
    (v1-15 uint128)
    (v1-17 number)
    (v1-26 float)
    (a0-10 uint128)
    (a0-11 uint128)
    (a1-3 uint128)
    (a2-3 uint128)
    (a2-4 uint128)
    (sv-16 int)
    (sv-640 int)
    )
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (set! sv-16 (-> arg1 num-items))
    (dotimes (s3-0 sv-16)
      (let ((s2-0 (-> arg1 items s3-0 mesh)))
        (cond
          ((= (-> s2-0 type) instance-tie)
           (let ((v1-4 s2-0))
             (when (not (or (logtest? (-> v1-4 bucket-ptr flags) (prototype-flags no-collide))
                            (logtest? (-> v1-4 flags) (instance-flags no-collide))
                            )
                        )
               (if *collide-list-boxes*
                   (add-collide-debug-box (-> s2-0 bsphere) (new 'static 'rgba :r #xff :a #x80))
                   )
               (let ((s0-0 (new 'stack-no-clear 'matrix))
                     (s1-0 (new 'stack-no-clear 'collide-query))
                     )
                 (mem-copy! (the-as pointer s1-0) (the-as pointer arg2) 540)
                 (nop!)
                 (let ((v1-11 (the-as uint128 (-> s2-0 origin long 3))))
                   (nop!)
                   (let ((a2-2 (the-as uint128 (-> s2-0 origin long 0))))
                     (.pextlh v1-12 v1-11 0)
                     (let ((a0-9 (the-as uint128 (-> s2-0 origin long 1))))
                       (.pw.sra a1-3 v1-12 10)
                       (let ((v1-13 (the-as uint128 (-> s2-0 origin long 2))))
                         (.pextlh a2-3 a2-2 0)
                         (nop!)
                         (.pw.sra a2-4 a2-3 16)
                         (nop!)
                         (.pextlh a0-10 a0-9 0)
                         (.mov vf4 a1-3)
                         (.pw.sra a0-11 a0-10 16)
                         (.mov vf1 a2-4)
                         (.pextlh v1-14 v1-13 0)
                         )
                       )
                     )
                   )
                 (.mov vf2 a0-11)
                 (.pw.sra v1-15 v1-14 16)
                 (.lvf vf5 (&-> s2-0 bsphere quad))
                 (nop!)
                 (.mov vf3 v1-15)
                 (.itof.vf vf4 vf4)
                 (nop!)
                 (vitof12.xyzw vf1 vf1)
                 (nop!)
                 (vitof12.xyzw vf2 vf2)
                 (nop!)
                 (vitof12.xyzw vf3 vf3)
                 (nop!)
                 (.add.vf vf4 vf4 vf5 :mask #b111)
                 (nop!)
                 (nop!)
                 (.svf (&-> s1-0 instance-mat rvec quad) vf1)
                 (nop!)
                 (.svf (&-> s1-0 instance-mat uvec quad) vf2)
                 (nop!)
                 (.svf (&-> s1-0 instance-mat fvec quad) vf3)
                 (nop!)
                 (.svf (&-> s1-0 instance-mat trans quad) vf4)
                 (matrix-4x4-inverse! s0-0 (-> s1-0 instance-mat))
                 (nop!)
                 (nop!)
                 (.lvf vf7 (&-> arg2 start-pos quad))
                 (nop!)
                 (.lvf vf8 (&-> arg2 move-dist quad))
                 (nop!)
                 (.lvf vf1 (&-> s0-0 rvec quad))
                 (nop!)
                 (.lvf vf2 (&-> s0-0 uvec quad))
                 (nop!)
                 (.lvf vf3 (&-> s0-0 fvec quad))
                 (nop!)
                 (.lvf vf4 (&-> s0-0 trans quad))
                 (.add.vf vf8 vf7 vf8)
                 (let ((v1-16 (-> s2-0 rmin-scale)))
                   (.mul.x.vf acc vf1 vf7)
                   (let ((f2-0 (-> arg2 radius)))
                     (.add.mul.y.vf acc vf2 vf7 acc)
                     (.sll v1-17 v1-16 16)
                     (.add.mul.z.vf acc vf3 vf7 acc)
                     (let ((f1-0 (the-as float v1-17)))
                       (.add.mul.w.vf vf7 vf4 vf0 acc)
                       (nop!)
                       (.mul.x.vf acc vf1 vf8)
                       (let ((f2-1 (* f2-0 f1-0)))
                         (.add.mul.y.vf acc vf2 vf8 acc)
                         (nop!)
                         (.add.mul.z.vf acc vf3 vf8 acc)
                         (nop!)
                         (.add.mul.w.vf vf8 vf4 vf0 acc)
                         (nop!)
                         (nop!)
                         (.svf (&-> s1-0 start-pos quad) vf7)
                         (.min.vf vf5 vf7 vf8)
                         (set! (-> s1-0 radius) f2-1)
                         )
                       )
                     )
                   )
                 (.max.vf vf6 vf7 vf8)
                 (nop!)
                 (nop!)
                 (.lvf vf9 (&-> s1-0 exit-planes 0 quad))
                 (.sub.vf vf8 vf8 vf7)
                 (nop!)
                 (.sub.w.vf vf5 vf5 vf9)
                 (nop!)
                 (.add.w.vf vf6 vf6 vf9)
                 (nop!)
                 (nop!)
                 (.svf (&-> s1-0 move-dist quad) vf8)
                 (.ftoi.vf vf10 vf5)
                 (nop!)
                 (.ftoi.vf vf11 vf6)
                 (nop!)
                 (nop!)
                 (.svf (&-> s1-0 bbox min quad) vf5)
                 (nop!)
                 (.svf (&-> s1-0 bbox max quad) vf6)
                 (nop!)
                 (.svf (&-> s1-0 bbox4w min quad) vf10)
                 (nop!)
                 (.svf (&-> s1-0 bbox4w max quad) vf11)
                 (set! (-> s1-0 rlength x) (if (= (-> s1-0 move-dist x) 0.0)
                                               0.0
                                               (/ 1.0 (-> s1-0 move-dist x))
                                               )
                       )
                 (set! (-> s1-0 rlength y) (if (= (-> s1-0 move-dist y) 0.0)
                                               0.0
                                               (/ 1.0 (-> s1-0 move-dist y))
                                               )
                       )
                 (set! (-> s1-0 rlength z) (if (= (-> s1-0 move-dist z) 0.0)
                                               0.0
                                               (/ 1.0 (-> s1-0 move-dist z))
                                               )
                       )
                 (let ((f0-12 1.0))
                   (.lvf vf1 (&-> (-> s1-0 move-dist) quad))
                   (.add.w.vf vf2 vf0 vf0 :mask #b1)
                   (.mul.vf vf1 vf1 vf1)
                   (.mul.x.vf acc vf2 vf1 :mask #b1)
                   (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
                   (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
                   (.mov v1-26 vf1)
                   (set! (-> s1-0 rlength w) (/ f0-12 v1-26))
                   )
                 (set! (-> s1-0 exit-planes 0 x) (if (< 0.0 (-> s1-0 move-dist x))
                                                     0.0
                                                     100000000000000000000000000000000000000.0
                                                     )
                       )
                 (set! (-> s1-0 exit-planes 0 y) (if (< 0.0 (-> s1-0 move-dist y))
                                                     0.0
                                                     100000000000000000000000000000000000000.0
                                                     )
                       )
                 (set! (-> s1-0 exit-planes 0 z) (if (< 0.0 (-> s1-0 move-dist z))
                                                     0.0
                                                     100000000000000000000000000000000000000.0
                                                     )
                       )
                 (set! (-> s1-0 exit-planes 1 x) (if (< (-> s1-0 move-dist x) 0.0)
                                                     0.0
                                                     100000000000000000000000000000000000000.0
                                                     )
                       )
                 (set! (-> s1-0 exit-planes 1 y) (if (< (-> s1-0 move-dist y) 0.0)
                                                     0.0
                                                     100000000000000000000000000000000000000.0
                                                     )
                       )
                 (set! (-> s1-0 exit-planes 1 z) (if (< (-> s1-0 move-dist z) 0.0)
                                                     0.0
                                                     100000000000000000000000000000000000000.0
                                                     )
                       )
                 (let ((s0-1 (-> s2-0 bucket-ptr collide-hash-fragment-array)))
                   (set! sv-640 (-> s0-1 length))
                   (set! (-> s1-0 instance-ptr) s2-0)
                   (dotimes (s2-1 sv-640)
                     (set! (-> (the-as collide-hash-scratch #x70000000) collidable-bits 0) (the-as uint128 0))
                     (set! (-> (the-as collide-hash-scratch #x70000000) collidable-bits 1) (the-as uint128 0))
                     (set! (-> (the-as collide-hash-scratch #x70000000) tris) (the-as uint 0))
                     (fill-bg-using-line-sphere-new arg0 (-> s0-1 fragments s2-1) s1-0)
                     (+! (-> *collide-stats* tris) (-> (the-as collide-hash-scratch #x70000000) tris))
                     )
                   )
                 )
               )
             )
           )
          (else
            (if *collide-list-boxes*
                (add-collide-debug-box (-> s2-0 bsphere) (new 'static 'rgba :r #xff :g #xff :a #x80))
                )
            (set! (-> (the-as collide-hash-scratch #x70000000) collidable-bits 0) (the-as uint128 0))
            (set! (-> (the-as collide-hash-scratch #x70000000) collidable-bits 1) (the-as uint128 0))
            (set! (-> arg2 instance-ptr) #f)
            (set! (-> (the-as collide-hash-scratch #x70000000) tris) (the-as uint 0))
            (fill-bg-using-line-sphere-new arg0 s2-0 arg2)
            (+! (-> *collide-stats* tris) (-> (the-as collide-hash-scratch #x70000000) tris))
            )
          )
        )
      )
    0
    (none)
    )
  )

;; definition for method 8 of type collide-hash
;; INFO: Used lq/sq
(defmethod mem-usage ((this collide-hash) (usage memory-usage-block) (flags int))
  (set! (-> usage length) (max 52 (-> usage length)))
  (set! (-> usage data 51 name) "collision")
  (+! (-> usage data 51 count) 1)
  (let ((v1-8 (+ (* (-> this num-items) 8) 96 (* (-> this num-buckets) 4))))
    (+! (-> usage data 51 used) v1-8)
    (+! (-> usage data 51 total) (logand -16 (+ v1-8 15)))
    )
  (dotimes (v1-12 (the-as int (-> this qwc-id-bits)))
    (set! (-> (the-as collide-hash-scratch #x70000000) collidable-bits v1-12) (the-as uint128 0))
    )
  (dotimes (s3-0 (the-as int (-> this num-items)))
    (let* ((a0-11 (-> this item-array s3-0 id))
           (v1-17 (shr a0-11 5))
           )
      (when (not (logtest? (-> (the-as collide-hash-scratch #x70000000) id-bits v1-17) (ash 1 (the-as int (logand a0-11 31))))
                 )
        (logior! (-> (the-as collide-hash-scratch #x70000000) id-bits v1-17) (ash 1 (the-as int (logand a0-11 31))))
        (if (= (-> this item-array s3-0 collidable type) collide-hash-fragment)
            (mem-usage (-> this item-array s3-0 collidable) usage flags)
            )
        )
      )
    )
  this
  )

;; definition for method 8 of type collide-hash-fragment
(defmethod mem-usage ((this collide-hash-fragment) (usage memory-usage-block) (flags int))
  (cond
    ((logtest? flags 1)
     (set! (-> usage length) (max 59 (-> usage length)))
     (set! (-> usage data 56 name) "prototype-fragment")
     (+! (-> usage data 56 count) 1)
     (set! (-> usage data 57 name) "prototype-poly")
     (+! (-> usage data 57 count) (-> this stats num-polys))
     (set! (-> usage data 58 name) "prototype-vertex")
     (+! (-> usage data 58 count) (-> this stats num-verts))
     (let ((a3-0 (+ (-> this num-indices) 112 (* (-> this num-buckets) 4)))
           (a2-6 (* (-> this stats num-polys) 4))
           (v1-16 (* (the-as uint 6) (-> this stats num-verts)))
           )
       (+! (-> usage data 56 used) a3-0)
       (+! (-> usage data 56 total) (- (logand -16 (+ v1-16 15 a2-6 a3-0)) (the-as int (+ a2-6 v1-16))))
       (+! (-> usage data 57 used) a2-6)
       (+! (-> usage data 57 total) a2-6)
       (+! (-> usage data 58 used) v1-16)
       (+! (-> usage data 58 total) v1-16)
       )
     )
    (else
      (set! (-> usage length) (max 55 (-> usage length)))
      (set! (-> usage data 52 name) "collision-fragment")
      (+! (-> usage data 52 count) 1)
      (set! (-> usage data 53 name) "collision-poly")
      (+! (-> usage data 53 count) (-> this stats num-polys))
      (set! (-> usage data 54 name) "collision-vertex")
      (+! (-> usage data 54 count) (-> this stats num-verts))
      (let ((a3-8 (+ (-> this num-indices) 112 (* (-> this num-buckets) 4)))
            (a2-16 (* (-> this stats num-polys) 4))
            (v1-33 (* (the-as uint 6) (-> this stats num-verts)))
            )
        (+! (-> usage data 52 used) a3-8)
        (+! (-> usage data 52 total) (- (logand -16 (+ v1-33 15 a2-16 a3-8)) (the-as int (+ a2-16 v1-33))))
        (+! (-> usage data 53 used) a2-16)
        (+! (-> usage data 53 total) a2-16)
        (+! (-> usage data 54 used) v1-33)
        (+! (-> usage data 54 total) v1-33)
        )
      )
    )
  this
  )

;; definition for method 8 of type collide-hash-fragment-array
(defmethod mem-usage ((this collide-hash-fragment-array) (usage memory-usage-block) (flags int))
  (set! (-> usage length) (max 56 (-> usage length)))
  (set! (-> usage data 55 name) "prototype-collision")
  (+! (-> usage data 55 count) 1)
  (let ((v1-6 (asize-of this)))
    (+! (-> usage data 55 used) v1-6)
    (+! (-> usage data 55 total) (logand -16 (+ v1-6 15)))
    )
  (dotimes (s3-0 (-> this length))
    (mem-usage (-> this fragments s3-0) usage flags)
    )
  this
  )
