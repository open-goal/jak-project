;;-*-Lisp-*-
(in-package goal)

;; definition for symbol *mech-exploder-params*, type joint-exploder-static-params
(define *mech-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 18 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 19 :parent-joint-index -1)
      )
    :collide-spec (collide-spec backgnd)
    )
  )

;; definition for function check-turn-on-shield
(defun check-turn-on-shield ((arg0 target))
  (when (cpad-hold? (-> arg0 control cpad number) circle)
    (if (handle->process (-> arg0 mech shield-handle))
        (go target-mech-shield)
        )
    )
  )

;; failed to figure out what this is:
(defstate target-mech-start (target)
  :event target-mech-handler
  :exit target-mech-exit
  :code target-mech-init
  :post target-post
  )

;; definition for function mech-can-throw?
;; WARN: Return type mismatch object vs symbol.
(defbehavior mech-can-throw? target ()
  (let ((v1-1 (vector-float*! (new 'stack-no-clear 'vector) (-> self control local-normal) 0.0)))
    (vector+float*! v1-1 v1-1 (-> self control c-R-w fvec) 20480.0)
    (the-as symbol (send-event (handle->process (-> self carry other)) 'can-drop? v1-1))
    )
  )

;; failed to figure out what this is:
(defstate target-mech-stance (target)
  :event target-mech-handler
  :enter (behavior ()
    (set! (-> self control mod-surface) *mech-stance-mods*)
    (set! (-> self control mod-surface turnvv) 40049.777)
    (set! (-> self control did-move-to-pole-or-max-jump-height) 0.0)
    (rot->dir-targ! (-> self control))
    (set! (-> self mech jump-thrust-fuel) (-> *TARGET-bank* mech-jump-thrust-fuel))
    )
  :exit (behavior ()
    (target-effect-exit)
    (target-mech-exit)
    (rot->dir-targ! (-> self control))
    )
  :trans (behavior ()
    (check-turn-on-shield self)
    (when (not (cpad-hold? (-> self control cpad number) circle))
      (if (and (move-legs?)
               (and (< (fabs
                         (deg-diff (quaternion-y-angle (-> self control dir-targ)) (vector-y-angle (-> self control to-target-pt-xz)))
                         )
                       1820.4445
                       )
                    (time-elapsed? (-> self control time-of-last-zero-input) (seconds 0.05))
                    )
               )
          (go target-mech-walk)
          )
      (if (and (cpad-pressed? (-> self control cpad number) square) (can-hands? #t))
          (go target-mech-punch)
          )
      (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                         (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                         )
                                 (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                                 )
                         (pad-buttons x)
                         )
               (can-jump? #f)
               )
          (go
            target-mech-jump
            (-> *TARGET-bank* mech-jump-height-min)
            (-> *TARGET-bank* mech-jump-height-max)
            (the-as surface #f)
            )
          )
      (if (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                    (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                    )
                            (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                            )
                    (pad-buttons r1)
                    )
          (go target-mech-carry-pickup)
          )
      (if (and (or (cpad-pressed? (-> self control cpad number) triangle) (not (-> *setting-control* user-current pilot)))
               (target-mech-get-off?)
               )
          (go target-mech-shield)
          )
      )
    (fall-test target-mech-falling (-> *TARGET-bank* fall-height))
    )
  :code (behavior ()
    (let ((v1-2 (ja-group)))
      (when (not (and v1-2 (= v1-2 jakb-mech-turn90-ja)))
        (let ((v1-8 (ja-group)))
          (if (and v1-8 (= v1-8 jakb-mech-walk-ja))
              (sound-play "mech-stop")
              )
          )
        (ja-channel-push! 3 (seconds 0.2))
        (ja :group! jakb-mech-turn90-ja :dist 16384.0)
        (ja :chan 1 :group! jakb-mech-turn20-ja :dist 3640.889)
        (ja :chan 2 :group! jakb-mech-stance-ja :dist 0.0)
        )
      )
    (let ((f28-0 0.0)
          (f30-0 0.0)
          (gp-1 #f)
          )
      (until #f
        (let ((f26-0 (y-angle (-> self control))))
          (deg-diff f26-0 (quaternion-y-angle (-> self control dir-targ)))
          (suspend)
          (let ((f26-1 (* (deg-diff f26-0 (y-angle (-> self control))) (-> self clock frames-per-second))))
            (cond
              ((< 910.2222 (fabs f26-1))
               (set! f28-0 (seek f28-0 1.0 (* 16.0 (seconds-per-frame))))
               (set! gp-1 #t)
               )
              (else
                (set! f28-0 (seek f28-0 0.0 (* 6.0 (seconds-per-frame))))
                (when (and gp-1 (= f28-0 0.0))
                  (set! gp-1 #f)
                  (sound-play "mech-twitch")
                  )
                )
              )
            (set! f30-0 (seek f30-0 (lerp-scale 1.0 0.0 (fabs f26-1) 3640.889 16384.0) (* 10.0 (seconds-per-frame))))
            (let ((v1-41 (-> self skel effect)))
              (set! (-> v1-41 channel-offset) (cond
                                                ((< 0.8 (- 1.0 f28-0))
                                                 2
                                                 )
                                                ((< 0.5 f30-0)
                                                 1
                                                 )
                                                (else
                                                  0
                                                  )
                                                )
                    )
              )
            0
            (ja :num! (loop! (/ f26-1 (current-cycle-distance (-> self skel)))))
            (ja :chan 1 :num! (chan 0) :frame-interp0 f30-0 :frame-interp1 f30-0)
            (ja-no-eval :chan 1 :num! (loop! (/ f26-1 (current-cycle-distance (-> self skel)))))
            )
          )
        (let ((a0-44 (-> self skel root-channel 2)))
          (let ((f0-22 (- 1.0 f28-0)))
            (set! (-> a0-44 frame-interp 1) f0-22)
            (set! (-> a0-44 frame-interp 0) f0-22)
            )
          (set! (-> a0-44 param 0) 1.0)
          (joint-control-channel-group-eval! a0-44 (the-as art-joint-anim #f) num-func-loop!)
          )
        (can-play-stance-amibent?)
        )
      )
    #f
    )
  :post target-mech-post
  )

;; failed to figure out what this is:
(defstate target-mech-walk (target)
  :event target-mech-handler
  :enter (behavior ()
    (set! (-> self control mod-surface) *mech-walk-mods*)
    (set! (-> self control unknown-word04) (the-as uint #f))
    (set! (-> self control unknown-word04) (the-as uint 0.0))
    (set! (-> self mech jump-thrust-fuel) (-> *TARGET-bank* mech-jump-thrust-fuel))
    )
  :exit (behavior ()
    (target-effect-exit)
    (target-mech-exit)
    )
  :trans (behavior ()
    (check-turn-on-shield self)
    (if (and (cpad-pressed? (-> self control cpad number) square) (can-hands? #t))
        (go target-mech-punch)
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons x)
                       )
             (can-jump? #f)
             )
        (go
          target-mech-jump
          (-> *TARGET-bank* mech-jump-height-min)
          (-> *TARGET-bank* mech-jump-height-max)
          (the-as surface #f)
          )
        )
    (let ((gp-0 (ja-group))
          (f0-2 (ja-aframe-num 0))
          )
      (when (if (or (and (= gp-0 jakb-mech-walk-ja) (>= f0-2 5.5) (>= 9.5 f0-2))
                    (and (= gp-0 jakb-mech-walk-ja) (>= f0-2 20.5) (>= 24.5 f0-2))
                    )
                #t
                )
        (case (-> self control unknown-spool-anim00)
          (('punch)
           (go target-mech-punch)
           )
          (('jump)
           (if (can-jump? #f)
               (go
                 target-mech-jump
                 (-> *TARGET-bank* mech-jump-height-min)
                 (-> *TARGET-bank* mech-jump-height-max)
                 (the-as surface #f)
                 )
               (set! (-> self control unknown-word04) (the-as uint #f))
               )
           )
          )
        (when (and (< 5.0 (the-as float (-> self control unknown-word04)))
                   (= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
                   )
          (set-forward-vel 0.0)
          (go target-mech-stance)
          )
        (if (and (or (cpad-pressed? (-> self control cpad number) triangle) (not (-> *setting-control* user-current pilot)))
                 (target-mech-get-off?)
                 )
            (go target-mech-shield)
            )
        )
      )
    (if (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                  (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                  )
                          (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                          )
                  (pad-buttons r1)
                  )
        (go target-mech-carry-pickup)
        )
    (fall-test target-mech-falling (-> *TARGET-bank* fall-height))
    )
  :code (behavior ()
    (let ((f30-0 0.0)
          (f28-0 0.0)
          )
      (let ((f26-0 (cond
                     ((zero? (-> self mech walk-anim-leg))
                      (set! (-> self mech walk-anim-leg) 1)
                      7.0
                      )
                     (else
                       (set! (-> self mech walk-anim-leg) 0)
                       22.0
                       )
                     )
                   )
            (v1-7 (ja-group))
            )
        (when (not (and v1-7 (= v1-7 jakb-mech-walk-ja)))
          (ja-channel-push! 3 (seconds 0.1))
          (ja :group! jakb-mech-walk-ja
              :num! (identity (ja-aframe f26-0 0))
              :dist (-> *TARGET-bank* mech-walk-cycle-dist)
              )
          (ja :chan 1 :group! jakb-mech-run-ja :dist (-> *TARGET-bank* mech-run-cycle-dist))
          (ja :chan 2 :group! jakb-mech-stance-ja :dist 0.0)
          )
        )
      (until #f
        (if (< (-> self control ctrl-xz-vel) 8192.0)
            (set-forward-vel 8192.0)
            )
        (suspend)
        (let* ((f0-5 (current-cycle-distance (-> self skel)))
               (f26-1 (/ (-> self control ctrl-xz-vel) f0-5))
               )
          (set! (-> self control unknown-word04)
                (the-as uint (+ (the-as float (-> self control unknown-word04)) f26-1))
                )
          (set! f30-0
                (seek f30-0 (lerp-scale 0.0 1.0 (-> self control ctrl-xz-vel) 16384.0 32768.0) (* 2.0 (seconds-per-frame)))
                )
          (set! f28-0
                (seek f28-0 (lerp-scale 1.0 0.0 (-> self control ctrl-xz-vel) 0.0 12288.0) (* 2.0 (seconds-per-frame)))
                )
          (let ((v1-39 (-> self skel effect)))
            (set! (-> v1-39 channel-offset) (if (< 0.5 f30-0)
                                                1
                                                0
                                                )
                  )
            )
          0
          (ja :num! (loop! f26-1))
          )
        (ja :chan 1 :num! (chan 0) :frame-interp0 f30-0 :frame-interp1 f30-0)
        (ja :chan 2 :num! (chan 0) :frame-interp0 f28-0 :frame-interp1 f28-0)
        )
      )
    #f
    )
  :post target-mech-post
  )

;; definition for function target-mech-punch-pick
;; INFO: Used lq/sq
(defbehavior target-mech-punch-pick target ((arg0 symbol))
  (local-vars (sv-144 control-info) (sv-160 float))
  (combo-tracker-method-12
    (-> self control unknown-combo-tracker00)
    *null-vector*
    *null-vector*
    (the-as process #f)
    (current-time)
    )
  (let* ((s4-0 (get-trans self 3))
         (s2-0 (combo-tracker-method-13
                 (-> self control unknown-combo-tracker00)
                 (-> self control send-attack-dest)
                 s4-0
                 32768.0
                 (-> self control c-R-w fvec)
                 65536.0
                 )
               )
         (s5-0 (the-as art-element #f))
         )
    (when s2-0
      (let ((s3-0 (get-trans s2-0 3)))
        (set! sv-144 (-> self control))
        (let ((s0-0 s3-0)
              (s1-0 deg-diff)
              )
          (set! sv-160 (y-angle sv-144))
          (let* ((a1-4 (vector-y-angle (vector-! (new 'stack-no-clear 'vector) s0-0 (-> sv-144 trans))))
                 (f0-0 (s1-0 sv-160 a1-4))
                 )
            (cond
              ((>= f0-0 5461.3335)
               (set! (-> self mech walk-anim-leg) 0)
               0
               )
              ((>= -5461.3335 f0-0)
               (set! (-> self mech walk-anim-leg) 1)
               )
              (else
                (set! (-> self mech walk-anim-leg) 2)
                )
              )
            )
          )
        (when (< (vector-vector-distance s3-0 s4-0) 32768.0)
          (let ((a1-6 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-6 from) (process->ppointer self))
            (set! (-> a1-6 num-params) 0)
            (set! (-> a1-6 message) 'dont-face?)
            (if (not (send-event-function s2-0 a1-6))
                (forward-up-nopitch->quaternion
                  (-> self control dir-targ)
                  (vector-normalize! (vector-! (new 'stack-no-clear 'vector) s3-0 s4-0) 1.0)
                  (vector-y-quaternion! (new-stack-vector0) (-> self control dir-targ))
                  )
                )
            )
          )
        )
      )
    (let ((v1-29 (-> self mech walk-anim-leg)))
      (cond
        ((zero? v1-29)
         (set! (-> self mech walk-anim-leg) 1)
         (set! s5-0 jakb-mech-punch-l-ja)
         ((method-of-type impact-control initialize)
          (the-as impact-control (-> self mech state-impact))
          (ppointer->process (-> self manipy))
          7
          6963.2
          (logior (collide-spec mech-punch) (-> self control root-prim prim-core collide-with))
          )
         )
        ((= v1-29 1)
         (set! (-> self mech walk-anim-leg) 0)
         (set! s5-0 jakb-mech-punch-r-ja)
         ((method-of-type impact-control initialize)
          (the-as impact-control (-> self mech state-impact))
          (ppointer->process (-> self manipy))
          17
          6963.2
          (logior (collide-spec mech-punch) (-> self control root-prim prim-core collide-with))
          )
         )
        ((= v1-29 2)
         (set! (-> self mech walk-anim-leg) 0)
         (set! s5-0 jakb-mech-punch-b-ja)
         ((method-of-type impact-control initialize)
          (the-as impact-control (-> self mech state-impact))
          (ppointer->process (-> self manipy))
          39
          11141.12
          (logior (collide-spec mech-punch) (-> self control root-prim prim-core collide-with))
          )
         )
        ((= v1-29 3)
         (set! (-> self mech walk-anim-leg) 0)
         (set! s5-0 jakb-mech-punch-u-ja)
         ((method-of-type impact-control initialize)
          (the-as impact-control (-> self mech state-impact))
          (ppointer->process (-> self manipy))
          39
          11141.12
          (logior (collide-spec mech-punch) (-> self control root-prim prim-core collide-with))
          )
         )
        )
      )
    (ja-channel-push! 1 (seconds 0.1))
    (if (zero? arg0)
        (ja-no-eval :group! s5-0 :num! (seek!))
        (ja-no-eval :group! s5-0 :num! (seek!) :frame-num (ja-aframe 10.0 0))
        )
    )
  (-> self mech walk-anim-leg)
  )

;; failed to figure out what this is:
(defstate target-mech-punch (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (cond
      ((focus-test? self dangerous)
       (case message
         (('touched)
          (if ((method-of-type touching-shapes-entry prims-touching?)
               (the-as touching-shapes-entry (-> block param 0))
               (-> self control)
               (the-as uint 1920)
               )
              (target-send-attack
                proc
                (-> self control danger-mode)
                (the-as touching-shapes-entry (-> block param 0))
                (the-as int (-> self control target-attack-id))
                (the-as int (-> self control attack-count))
                (-> self control penetrate-using)
                )
              (target-mech-handler proc argc message block)
              )
          )
         (('impact-control)
          (when (-> self control danger-mode)
            (-> block param 1)
            (let* ((gp-1 (the-as object (-> block param 3)))
                   (s5-1 (-> (the-as collide-query gp-1) best-other-tri collide-ptr))
                   (s4-1 (if (type? s5-1 collide-shape-prim)
                             s5-1
                             )
                         )
                   (s3-1 (if s4-1
                             (-> (the-as collide-shape-prim s4-1) cshape process)
                             (the-as process-drawable #f)
                             )
                         )
                   (s5-2 (if (type? s3-1 process-focusable)
                             s3-1
                             )
                         )
                   )
              (if (and s4-1 (and (or (and s5-2 (focus-test? (the-as process-focusable s5-2) dead))
                                     (when (send-event
                                             (-> (the-as collide-shape-prim s4-1) cshape process)
                                             'attack
                                             #f
                                             (static-attack-info
                                               :mask (vehicle-impulse-factor)
                                               ((id (-> self control target-attack-id))
                                                (damage 200.0)
                                                (vehicle-damage-factor 1.0)
                                                (vehicle-impulse-factor 1.0)
                                                (mode (-> self control danger-mode))
                                                (count (-> self control attack-count))
                                                (penetrate-using (penetrate touch punch mech mech-punch))
                                                (intersection (-> (the-as collide-query gp-1) best-other-tri intersect))
                                                )
                                               )
                                             )
                                       (set! (-> self control send-attack-dest) (process->handle s5-2))
                                       (set-time! (-> self control send-attack-time))
                                       #t
                                       )
                                     )
                                 s5-2
                                 (focus-test? (the-as process-focusable s5-2) dead)
                                 )
                       )
                  (set! (-> self mech forward-vel) 0.0)
                  (set! (-> self mech forward-vel) -40960.0)
                  )
              (when (or (not s5-2) (= (-> self control send-attack-time) (current-time)))
                (cond
                  ((logtest? (-> *part-group-id-table* 12 flags) (sp-group-flag sp13))
                   (set! (-> *launch-matrix* trans quad) (-> (the-as collide-query gp-1) best-other-tri intersect quad))
                   (part-tracker-spawn part-tracker-subsampler :to self :group (-> *part-group-id-table* 12))
                   )
                  (else
                    (set! (-> *launch-matrix* trans quad) (-> (the-as collide-query gp-1) best-other-tri intersect quad))
                    (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 12))
                    )
                  )
                (sound-play "mech-punch-hit" :position (+ (the-as uint gp-1) 48))
                (activate! *camera-smush-control* 1638.4 15 75 1.0 0.9 (-> *display* camera-clock))
                )
              )
            )
          )
         (else
           (target-mech-handler proc argc message block)
           )
         )
       )
      (else
        (target-mech-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self control mod-surface) *mech-punch-mods*)
    (set! (-> self mech state-impact? 0) #f)
    (rot->dir-targ! (-> self control))
    )
  :exit (behavior ()
    (set! (-> *mech-punch-mods* turnvv) 0.0)
    (set! (-> self mech state-impact? 0) #f)
    (set-time! (-> self control last-running-attack-end-time))
    (target-exit)
    (target-mech-exit)
    )
  :code (behavior ()
    (set! (-> self mech forward-vel) (-> self control ctrl-xz-vel))
    1.0
    (let ((s5-0 #f)
          (gp-0 0)
          (s4-0 30)
          )
      (target-mech-punch-pick (the-as symbol gp-0))
      (until (ja-done? 0)
        (compute-alignment! (-> self align))
        (when (and (not (focus-test? self dangerous))
                   (let ((v1-10 (ja-group)))
                     (and v1-10 (or (= v1-10 jakb-mech-punch-l-ja)
                                    (= v1-10 jakb-mech-punch-r-ja)
                                    (= v1-10 jakb-mech-punch-b-ja)
                                    (= v1-10 jakb-mech-punch-u-ja)
                                    )
                          )
                     )
                   (>= (ja-aframe-num 0) 12.0)
                   )
          (target-start-attack)
          (target-danger-set! 'mech-punch #f)
          )
        (when (and (cpad-pressed? (-> self control cpad number) square) (< gp-0 2))
          (let ((s3-0 (ja-group))
                (f30-0 (ja-aframe-num 0))
                )
            (if (or (and (= s3-0 jakb-mech-punch-l-ja)
                         (>= f30-0 2.0)
                         (>= (the float (+ (-> (the-as art-joint-anim jakb-mech-punch-l-ja) frames num-frames) -1)) (ja-frame-num 0))
                         )
                    (and (= s3-0 jakb-mech-punch-r-ja)
                         (>= f30-0 2.0)
                         (>= (the float (+ (-> (the-as art-joint-anim jakb-mech-punch-r-ja) frames num-frames) -1)) (ja-frame-num 0))
                         )
                    (and (= s3-0 jakb-mech-punch-b-ja)
                         (>= f30-0 2.0)
                         (>= (the float (+ (-> (the-as art-joint-anim jakb-mech-punch-b-ja) frames num-frames) -1)) (ja-frame-num 0))
                         )
                    (and (= s3-0 jakb-mech-punch-u-ja)
                         (>= f30-0 2.0)
                         (>= (the float (+ (-> (the-as art-joint-anim jakb-mech-punch-u-ja) frames num-frames) -1)) (ja-frame-num 0))
                         )
                    )
                (set! s5-0 #t)
                )
            )
          )
        (when s5-0
          (let ((s3-1 (ja-group))
                (f30-2 (ja-aframe-num 0))
                )
            (when (or (and (= s3-1 jakb-mech-punch-l-ja)
                           (>= f30-2 21.0)
                           (>= (the float (+ (-> (the-as art-joint-anim jakb-mech-punch-l-ja) frames num-frames) -1)) (ja-frame-num 0))
                           )
                      (and (= s3-1 jakb-mech-punch-r-ja)
                           (>= f30-2 21.0)
                           (>= (the float (+ (-> (the-as art-joint-anim jakb-mech-punch-r-ja) frames num-frames) -1)) (ja-frame-num 0))
                           )
                      (and (= s3-1 jakb-mech-punch-b-ja)
                           (>= f30-2 21.0)
                           (>= (the float (+ (-> (the-as art-joint-anim jakb-mech-punch-b-ja) frames num-frames) -1)) (ja-frame-num 0))
                           )
                      (and (= s3-1 jakb-mech-punch-u-ja)
                           (>= f30-2 21.0)
                           (>= (the float (+ (-> (the-as art-joint-anim jakb-mech-punch-u-ja) frames num-frames) -1)) (ja-frame-num 0))
                           )
                      )
              (+! gp-0 1)
              (target-mech-punch-pick (the-as symbol gp-0))
              (set! (-> self state-time) (+ (current-time) (seconds -0.465)))
              (set! (-> self mech forward-vel) (fmax 0.0 (-> self mech forward-vel)))
              (set! s4-0 159)
              (set! s5-0 #f)
              )
            )
          )
        (let ((v1-142 (- (current-time) (-> self state-time)))
              (s3-2 #t)
              (f30-4 1.0)
              )
          (cond
            ((< (-> self mech forward-vel) 0.0)
             (seek! (-> self mech forward-vel) -0.04096 (* 122880.0 (seconds-per-frame)))
             )
            ((let ((a0-43 (ja-group)))
               (and a0-43 (or (= a0-43 jakb-mech-punch-b-ja) (= a0-43 jakb-mech-punch-u-ja)))
               )
             (cond
               ((< v1-142 (seconds 0.465))
                (set! s3-2 #f)
                )
               ((< v1-142 (seconds 0.53))
                (set! (-> self mech forward-vel) (lerp-scale 40960.0 81920.0 (the float v1-142) 139.8 159.98999))
                )
               (else
                 (set! (-> self mech forward-vel) (lerp-scale 81920.0 0.0 (the float v1-142) 159.98999 300.0))
                 )
               )
             )
            (else
              (let ((a0-50 (ja-group)))
                (cond
                  ((and a0-50 (= a0-50 jakb-mech-punch-l-ja))
                   (cond
                     ((< v1-142 (seconds 0.465))
                      (seek! (-> self mech forward-vel) 0.0 (* 20480.0 (seconds-per-frame)))
                      (set! s3-2 #f)
                      )
                     ((< v1-142 (seconds 0.53))
                      (set! (-> self mech forward-vel) (lerp-scale 20480.0 40960.0 (the float v1-142) 139.8 159.98999))
                      )
                     (else
                       (set! (-> self mech forward-vel) (lerp-scale 40960.0 0.0 (the float v1-142) 159.98999 300.0))
                       )
                     )
                   )
                  ((< v1-142 (seconds 0.465))
                   (seek! (-> self mech forward-vel) 0.0 (* 20480.0 (seconds-per-frame)))
                   (set! s3-2 #f)
                   )
                  ((< v1-142 (seconds 0.53))
                   (set! (-> self mech forward-vel) (lerp-scale 20480.0 40960.0 (the float v1-142) 139.8 159.98999))
                   )
                  (else
                    (set! (-> self mech forward-vel) (lerp-scale 40960.0 0.0 (the float v1-142) 159.98999 300.0))
                    )
                  )
                )
              )
            )
          (set! s3-2 (and (time-elapsed? (-> self state-time) s4-0) (and (>= (-> self mech forward-vel) 0.0) s3-2)))
          (set! (-> self mech state-impact? 0) s3-2)
          (set-forward-vel (-> self mech forward-vel))
          (when (< 20480.0 (vector-length (-> self control transv)))
            (do-effect (-> self skel effect) "effect-slide-poof" (ja-frame-num 0) 49)
            (do-effect (-> self skel effect) "effect-slide-poof" (ja-frame-num 0) 43)
            )
          (suspend)
          (ja :num! (seek! max (* (-> self control current-surface align-speed) f30-4)))
          )
        )
      )
    (go target-mech-stance)
    )
  :post target-mech-post
  )

;; failed to figure out what this is:
(defstate target-mech-falling (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (let ((v0-0 (target-mech-bonk-event-handler proc argc message block)))
      (cond
        (v0-0
          (empty)
          v0-0
          )
        (else
          (target-mech-handler proc argc message block)
          )
        )
      )
    )
  :enter (behavior ((arg0 symbol))
    (set-time! (-> self state-time))
    (set! (-> self control mod-surface) *mech-jump-mods*)
    (set! (-> self mech jump-thrust) 0.0)
    (let* ((v1-4 *game-info*)
           (v0-0 (+ (-> v1-4 attack-id) 1))
           )
      (set! (-> v1-4 attack-id) v0-0)
      (set! (-> self control target-attack-id) v0-0)
      )
    )
  :exit (behavior ()
    (set! (-> self mech jump-thrust) 0.0)
    (set! (-> self mech thruster-flame-width) 0.0)
    (set! (-> self mech thruster-flame-length) 0.0)
    (target-exit)
    (target-mech-exit)
    )
  :trans (behavior ()
    (local-vars (a0-0 none))
    (if (logtest? (-> self control status) (collide-status on-surface))
        (go target-mech-hit-ground (the-as symbol a0-0))
        )
    (let ((f0-0 (target-move-dist (-> *TARGET-bank* stuck-time)))
          (v1-9 (ja-group))
          )
      (when (if (and (and v1-9 (= v1-9 jakb-mech-jump-loop-ja))
                     (< f0-0 (-> *TARGET-bank* stuck-distance))
                     (and (time-elapsed? (-> self state-time) (seconds 2))
                          (not (and *cheat-mode* (cpad-hold? (-> self control cpad number) r2)))
                          )
                     )
                #t
                )
        (logior! (-> self control status) (collide-status on-surface))
        (go target-mech-hit-ground 'stuck)
        )
      )
    (let ((f30-0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
      (let ((f0-2 (-> self mech jump-thrust-fuel)))
        (cond
          ((cpad-hold? (-> self control cpad number) x)
           (cond
             ((= f0-2 0.0)
              (seek! (-> self mech jump-thrust) 0.0 (* 245760.0 (seconds-per-frame)))
              )
             ((!= f0-2 (-> *TARGET-bank* mech-jump-thrust-fuel))
              (let ((f28-0
                      (lerp-scale 122880.0 8192.0 (-> self mech jump-thrust-fuel) 600.0 (-> *TARGET-bank* mech-jump-thrust-fuel))
                      )
                    )
                (lerp-scale 409.6 8192.0 (-> self mech jump-thrust-fuel) 600.0 (-> *TARGET-bank* mech-jump-thrust-fuel))
                (seek!
                  (-> self mech jump-thrust)
                  (- (- (-> self control dynam gravity-length) f30-0) f28-0)
                  (* 8192000.0 (seconds-per-frame))
                  )
                )
              )
             (else
               (set! (-> self mech jump-thrust) 0.0)
               )
             )
           (seek! (-> self mech jump-thrust-fuel) 0.0 (the float (- (current-time) (-> self clock old-frame-counter))))
           )
          (else
            (seek! (-> self mech jump-thrust) 0.0 (* 491520.0 (seconds-per-frame)))
            )
          )
        )
      (let ((v1-72 (new-stack-vector0)))
        (let ((f0-29 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
          0.0
          (vector-! v1-72 (-> self control transv) (vector-float*! v1-72 (-> self control dynam gravity-normal) f0-29))
          )
        (let* ((f0-30 (vector-length v1-72))
               (f1-7 f0-30)
               (f2-2 (+ f30-0 (* (-> self mech jump-thrust) (seconds-per-frame))))
               )
          (vector+!
            (-> self control transv)
            (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-2)
            (vector-float*! v1-72 v1-72 (/ f0-30 f1-7))
            )
          )
        )
      )
    )
  :code (behavior ((arg0 symbol))
    (until #f
      (cond
        ((< 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
         (let ((v1-7 (ja-group)))
           (when (not (and v1-7 (= v1-7 jakb-mech-jump-thrust-ja)))
             (ja-channel-push! 1 (seconds 0.1))
             (ja :group! jakb-mech-jump-thrust-ja :num! min)
             )
           )
         (suspend)
         (ja :num! (loop! 0.75))
         )
        (else
          (let ((v1-22 (ja-group)))
            (when (not (and v1-22 (= v1-22 jakb-mech-jump-loop-ja)))
              (ja-channel-push! 1 (seconds 0.5))
              (ja :group! jakb-mech-jump-loop-ja :num! min)
              )
            )
          (suspend)
          (ja :num! (loop!))
          )
        )
      )
    #f
    )
  :post target-mech-post
  )

;; failed to figure out what this is:
(defstate target-mech-jump (target)
  :event (-> target-mech-falling event)
  :enter (behavior ((arg0 float) (arg1 float) (arg2 surface))
    (set-time! (-> self state-time))
    (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (let* ((v1-4 *game-info*)
           (a2-5 (+ (-> v1-4 attack-id) 1))
           )
      (set! (-> v1-4 attack-id) a2-5)
      (set! (-> self control target-attack-id) a2-5)
      )
    (set! (-> self mech jump-thrust) 0.0)
    (init-var-jump arg0 arg1 #t #f (-> self control transv) 2.0)
    (sound-play "mech-jump")
    (set! (-> self control unknown-symbol03) (the-as float arg2))
    (set! (-> self control mod-surface) *mech-jump-mods*)
    )
  :exit (-> target-mech-falling exit)
  :trans (-> target-mech-falling trans)
  :code (behavior ((arg0 float) (arg1 float) (arg2 surface))
    (let ((v1-2 (ja-group)))
      (if (and v1-2 (= v1-2 jakb-mech-jump-land-ja))
          (ja-channel-push! 1 (seconds 0.5))
          (ja-channel-push! 1 (seconds 0.05))
          )
      )
    ((the-as (function none) (-> target-mech-falling code)))
    )
  :post target-mech-post
  )

;; failed to figure out what this is:
(defstate target-mech-hit-ground (target)
  :event target-mech-handler
  :enter (behavior ((arg0 symbol))
    (let ((v1-0 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-0 command) (sound-command set-param))
      (set! (-> v1-0 id) (-> self mech thrust-sound-id))
      (set! (-> v1-0 params volume) -4)
      (set! (-> v1-0 auto-time) 48)
      (set! (-> v1-0 auto-from) 2)
      (set! (-> v1-0 params mask) (the-as uint 17))
      (-> v1-0 id)
      )
    (set! (-> self mech jump-thrust-fuel) (-> *TARGET-bank* mech-jump-thrust-fuel))
    (set-time! (-> self state-time))
    (cond
      ((= arg0 'stuck)
       )
      (else
        (target-land-effect)
        )
      )
    (set! (-> self control last-running-attack-end-time) 0)
    (set! (-> self control last-attack-end-time) 0)
    (if (!= (-> self control ground-pat material) (pat-material ice))
        (delete-back-vel)
        )
    (set! (-> self control mod-surface) *mech-stance-mods*)
    (start-bobbing!
      (-> self water)
      (lerp-scale 0.0 4096.0 (-> self control ground-impact-vel) 40960.0 102400.0)
      600
      1500
      )
    (activate! *camera-smush-control* 1638.4 15 75 1.0 0.9 (-> *display* camera-clock))
    )
  :exit (behavior ()
    (logclear! (-> self target-flags) (target-flags lleg-still rleg-still))
    (target-mech-exit)
    )
  :trans (behavior ()
    (if (and (cpad-pressed? (-> self control cpad number) square) (can-hands? #t))
        (go target-mech-punch)
        )
    (when (time-elapsed? (-> self state-time) (seconds 0.25))
      (if (move-legs?)
          (go target-mech-walk)
          )
      (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                         (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                         )
                                 (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                                 )
                         (pad-buttons x)
                         )
               (can-jump? #f)
               )
          (go
            target-mech-jump
            (-> *TARGET-bank* mech-jump-height-min)
            (-> *TARGET-bank* mech-jump-height-max)
            (the-as surface #f)
            )
          )
      (if (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                    (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                    )
                            (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                            )
                    (pad-buttons r1)
                    )
          (go target-mech-carry-pickup)
          )
      )
    (set-forward-vel 0.0)
    )
  :code (behavior ((arg0 symbol))
    (target-hit-ground-anim #f (are-still?))
    (go target-mech-stance)
    )
  :post target-mech-post
  )

;; failed to figure out what this is:
(defstate target-mech-hit (target)
  :event target-mech-handler
  :exit (behavior ()
    ((-> target-hit exit))
    (target-mech-exit)
    )
  :trans (behavior ()
    (when (= *cheat-mode* 'debug)
      (when (and (not *pause-lock*) (cpad-hold? (-> self control cpad number) r2))
        (set-time! (-> self control time-of-last-debug-heal))
        (pickup-collectable! (-> self fact) (pickup-type health) 100.0 (the-as handle #f))
        (go target-mech-stance)
        )
      )
    )
  :code (behavior ((arg0 symbol) (arg1 attack-info))
    (logclear! (-> self water flags) (water-flag jump-out))
    (set-time! (-> self state-time))
    (let ((gp-0 (-> self attack-info))
          (s5-0 (new 'stack-no-clear 'vector))
          )
      (let ((v1-4 gp-0))
        (set! (-> v1-4 attacker) (the-as handle #f))
        (set! (-> v1-4 mode) 'generic)
        (set! (-> v1-4 shove-back) 10240.0)
        (set! (-> v1-4 shove-up) 6144.0)
        (set! (-> v1-4 angle) #f)
        (set! (-> v1-4 trans quad) (-> self control trans quad))
        (set! (-> v1-4 control) 0.0)
        (set! (-> v1-4 invinc-time) (-> *TARGET-bank* hit-invulnerable-timeout))
        )
      (case arg0
        (('shove)
         (let ((v1-7 gp-0))
           (set! (-> v1-7 shove-back) (-> *TARGET-bank* smack-surface-dist))
           (set! (-> v1-7 shove-up) (-> *TARGET-bank* smack-surface-height))
           (set! (-> v1-7 angle) 'shove)
           )
         )
        )
      (combine! gp-0 arg1 self)
      (when (not (logtest? (-> gp-0 mask) (attack-mask vector)))
        (vector-z-quaternion! (-> gp-0 vector) (-> self control quat-for-control))
        (vector-xz-normalize! (-> gp-0 vector) (- (fabs (-> gp-0 shove-back))))
        (set! (-> gp-0 vector y) (-> gp-0 shove-up))
        )
      (set! (-> s5-0 quad) (-> gp-0 vector quad))
      (let ((f0-10 (vector-dot
                     (vector-normalize-copy! (new 'stack-no-clear 'vector) s5-0 1.0)
                     (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control quat-for-control))
                     )
                   )
            )
        (if (not (-> self attack-info angle))
            (set! (-> self attack-info angle) (if (>= 0.0 f0-10)
                                                  'front
                                                  'back
                                                  )
                  )
            )
        )
      (cond
        ((= arg0 'attack)
         (logior! (-> self focus-status) (focus-status hit))
         (set-time! (-> self game hit-time))
         (case (-> gp-0 mode)
           (('endlessfall)
            (cond
              ((= (-> self game mode) 'debug)
               (let ((s4-1 (new-stack-vector0)))
                 (set! (-> s4-1 quad) (-> self control last-trans-on-ground quad))
                 (ja-channel-set! 0)
                 (suspend-for (seconds 1)
                   )
                 (move-to-point! (-> self control) s4-1)
                 )
               (set! (-> self control camera-pos quad) (-> self control trans quad))
               (send-event *camera* 'teleport)
               (go target-mech-stance)
               )
              (else
                (pickup-collectable! (-> self fact) (pickup-type health) -1000.0 (the-as handle #f))
                (go target-mech-death (-> gp-0 mode))
                )
              )
            )
           )
         (target-hit-effect gp-0)
         (pickup-collectable! (-> self fact) (pickup-type health) -1000.0 (the-as handle #f))
         (go target-mech-death (-> gp-0 mode))
         )
        (else
          (case (-> gp-0 mode)
            (('burn 'burnup)
             (sound-play "get-burned")
             )
            )
          )
        )
      (set! (-> self control mod-surface) *smack-mods*)
      (let ((v1-63 (ja-group)))
        (when (not (and v1-63 (= v1-63 jakb-mech-hit-front-ja)))
          (ja-channel-push! 1 (seconds 0.075))
          (ja :group! jakb-mech-hit-front-ja :num! min)
          )
        )
      (target-hit-move gp-0 (target-hit-orient gp-0 s5-0) target-mech-falling-anim-trans 1.0)
      )
    (go target-mech-hit-ground #f)
    )
  :post (behavior ()
    (set! (-> self control dynam gravity-max) (-> self control standard-dynamics gravity-max))
    (set! (-> self control dynam gravity-length) (-> self control standard-dynamics gravity-length))
    (vector-float*!
      (-> self control dynam gravity)
      (-> self control dynam gravity-normal)
      (the-as float (-> self control dynam gravity-length))
      )
    (target-mech-post)
    )
  )

;; failed to figure out what this is:
(defstate target-mech-death (target)
  :event (-> target-death event)
  :exit (behavior ()
    (set! (-> self mech stick-off) #f)
    (target-mech-exit)
    ((-> target-death exit))
    )
  :trans (-> target-mech-hit trans)
  :code (behavior ((arg0 symbol))
    (set! (-> self mech stick-off) (the-as basic #t))
    (set! (-> self control unknown-word04) (the-as uint #f))
    (set! (-> self control did-move-to-pole-or-max-jump-height)
          (the-as float (send-event (handle->process (-> self attack-info attacker)) 'target 'die arg0))
          )
    (set! (-> self neck flex-blend) 0.0)
    (target-timed-invulnerable-off self 0)
    (logior! (-> self draw status) (draw-control-status no-draw-bounds))
    (set-setting! 'process-mask 'set 0.0 (process-mask platform projectile death))
    (apply-settings *setting-control*)
    (set! (-> self control transv quad) (the-as uint128 0))
    (logior! (-> self focus-status) (focus-status dead))
    (let ((s5-0 (-> self child)))
      (while s5-0
        (send-event (ppointer->process s5-0) 'notice 'die)
        (set! s5-0 (-> s5-0 0 brother))
        )
      )
    (cond
      ((or (= arg0 'none) (= arg0 'instant-death) (= arg0 'bot) (= arg0 'big-explosion))
       )
      ((= arg0 'grenade)
       (sound-play "explosion")
       )
      ((= arg0 'endlessfall)
       (sound-play "mech-death-fall")
       (set! (-> self control unknown-sound-id00)
             (add-process *gui-control* *target* (gui-channel daxter) (gui-action play) "mechfall" -99.0 0)
             )
       (sound-params-set! *gui-control* (-> self control unknown-sound-id00) #t -1 100 2 -1.0)
       (set-setting! 'mode-name 'cam-endlessfall 0.0 0)
       (logior! (-> self control pat-ignore-mask) (new 'static 'pat-surface :noendlessfall #x1))
       (logclear! (-> self water flags) (water-flag swim-ground))
       (let ((f0-2 (fmin -4096.0 (- (-> self control ground-impact-vel)))))
         (set! (-> self control unknown-word04) (the-as uint f0-2))
         (let ((v1-58 (new-stack-vector0)))
           (let ((f1-3 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
             0.0
             (vector-! v1-58 (-> self control transv) (vector-float*! v1-58 (-> self control dynam gravity-normal) f1-3))
             )
           (let* ((f1-4 (vector-length v1-58))
                  (f2-1 f1-4)
                  )
             (vector+!
               (-> self control transv)
               (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-2)
               (vector-float*! v1-58 v1-58 (/ f1-4 f2-1))
               )
             )
           )
         )
       (set! (-> self trans-hook)
             (lambda :behavior target
               ()
               (vector-seek! (-> self draw color-mult) *zero-vector* (seconds-per-frame))
               (let ((v1-2 (new-stack-vector0))
                     (f0-2 (the-as number (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
                     )
                 0.0
                 (vector-!
                   v1-2
                   (-> self control transv)
                   (vector-float*! v1-2 (-> self control dynam gravity-normal) (the-as float f0-2))
                   )
                 (let* ((f1-2 (vector-length v1-2))
                        (f2-0 f1-2)
                        )
                   (if (< (the-as float (-> self control unknown-word04)) (the-as float f0-2))
                       (set! f0-2 (-> self control unknown-word04))
                       )
                   (vector+!
                     (-> self control transv)
                     (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) (the-as float f0-2))
                     (vector-float*! v1-2 v1-2 (/ f1-2 f2-0))
                     )
                   )
                 )
               ((-> target-mech-hit trans))
               )
             )
       (ja-channel-push! 1 (seconds 0.3))
       (ja-no-eval :group! jakb-mech-jump-loop-ja :num! (loop! 0.5) :frame-num 0.0)
       (suspend-for (seconds 0.8)
         (ja :group! jakb-mech-jump-loop-ja :num! (loop! 0.5))
         )
       (remove-setting! 'mode-name)
       )
      (else
        (set! (-> self control mod-surface) *empty-mods*)
        (rot->dir-targ! (-> self control))
        (remove-setting! 'slave-options)
        (remove-setting! 'fov)
        (remove-setting! 'head-offset)
        (send-event *camera* 'set-dist #f #f)
        (set! (-> self burn-proc)
              (ppointer->handle
                (process-spawn-function process process-drawable-burn-effect 1200 :to (ppointer->process (-> self manipy)))
                )
              )
        (let ((gp-5 (if (zero? (rand-vu-int-count 2))
                        jakb-mech-death-a-ja
                        jakb-mech-death-b-ja
                        )
                    )
              )
          (ja-channel-push! 1 (seconds 0.1))
          (let ((f30-0 (if (logtest? (-> self water flags) (water-flag under-water))
                           0.55
                           1.0
                           )
                       )
                )
            (ja-no-eval :group! gp-5 :num! (seek! max f30-0) :frame-num 0.0)
            (until (ja-done? 0)
              (when (>= (- (-> *display* game-clock frame-counter) (-> self shock-effect-time)) (seconds 0.03))
                (set! (-> self shock-effect-time) (-> *display* game-clock frame-counter))
                (process-drawable-shock-effect
                  (ppointer->process (-> self manipy))
                  (-> *lightning-spec-id-table* 1)
                  lightning-probe-callback
                  (-> *part-id-table* 160)
                  0
                  0
                  40960.0
                  )
                )
              (suspend)
              (ja :num! (seek! max f30-0))
              )
            )
          )
        (sound-play "mech-eject")
        (cond
          ((logtest? (-> *part-group-id-table* 236 flags) (sp-group-flag sp13))
           (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
           (part-tracker-spawn part-tracker-subsampler :to self :group (-> *part-group-id-table* 236))
           )
          (else
            (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
            (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 236))
            )
          )
        (rot->dir-targ! (-> self control))
        (ja-post)
        (let ((gp-9 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
          (cond
            ((logtest? (-> self water flags) (water-flag under-water))
             (set! (-> gp-9 duration) (seconds 8))
             (set! (-> gp-9 gravity) -20480.0)
             (set! (-> gp-9 rot-speed) 4.2)
             (set-vector! (-> gp-9 fountain-rand-transv-lo) -20480.0 12288.0 -20480.0 1.0)
             (set-vector! (-> gp-9 fountain-rand-transv-hi) 20480.0 24576.0 20480.0 1.0)
             )
            (else
              (set! (-> gp-9 gravity) -204800.0)
              (set-vector! (-> gp-9 fountain-rand-transv-lo) -61440.0 12288.0 -61440.0 1.0)
              (set-vector! (-> gp-9 fountain-rand-transv-hi) 61440.0 49152.0 61440.0 1.0)
              )
            )
          (process-spawn
            joint-exploder
            (art-group-get-by-name *level* "skel-mech-explode" (the-as (pointer level) #f))
            41
            gp-9
            *mech-exploder-params*
            :name "joint-exploder"
            :to (ppointer->process (-> self manipy))
            :unk 0
            )
          )
        (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
        (logior! (-> self target-flags) (target-flags tf6))
        (set! (-> self alt-cam-pos quad) (-> self control trans quad))
        (set! (-> self post-hook) target-no-move-post)
        (ja-channel-set! 1)
        (ja-no-eval :group! jakb-death-painful-land-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (set! (-> self control transv quad) (the-as uint128 0))
          (vector-seek!
            (-> self draw color-mult)
            (new 'static 'vector :x 0.5 :y 0.5 :z 0.5 :w 1.0)
            (* 5.0 (seconds-per-frame))
            )
          (suspend)
          (ja :num! (seek!))
          )
        (suspend-for (seconds 2)
          )
        )
      )
    (set! (-> self control transv quad) (the-as uint128 0))
    (initialize! (-> self game) 'life (the-as game-save #f) (the-as string #f) (the-as resetter-spec #f))
    (if (!= (-> self game mode) 'play)
        (go target-jump 16384.0 16384.0 (the-as surface #f))
        )
    (set-time! (-> self state-time))
    (sleep-code)
    )
  :post target-mech-post
  )

;; definition for function target-mech-carry-update
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defbehavior target-mech-carry-update target ()
  (carry-info-method-9 (-> self carry))
  (when (and (= (-> self control collide-mode) 'mech-carry) (< (-> self control collide-mode-transition) 1.0))
    (let ((gp-0 (new 'stack-no-clear 'collide-query))
          (s5-0 (new 'stack-no-clear 'inline-array 'sphere 1))
          )
      (dotimes (s4-0 1)
        ((method-of-type sphere new) (the-as symbol (-> s5-0 s4-0)) sphere)
        )
      (let ((f30-0 (seek (-> self control collide-mode-transition) 1.0 (/ (-> self clock time-adjust-ratio) 10))))
        (set! (-> s5-0 0 quad) (-> self control collision-spheres 2 prim-core world-sphere quad))
        (set! (-> s5-0 0 r) (lerp-scale (-> *TARGET-bank* body-radius) 11468.8 f30-0 0.0 1.0))
        (let ((v1-17 gp-0))
          (set! (-> v1-17 best-dist) (the-as float s5-0))
          (set! (-> v1-17 best-other-prim) (the-as collide-shape-prim 1))
          (set! (-> v1-17 collide-with) (-> self control root-prim prim-core collide-with))
          (set! (-> v1-17 ignore-process0) #f)
          (set! (-> v1-17 ignore-process1) #f)
          (set! (-> v1-17 ignore-pat)
                (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                )
          (set! (-> v1-17 best-my-prim) (the-as collide-shape-prim #t))
          (set! (-> v1-17 action-mask) (collide-action solid))
          )
        (if (not (fill-and-probe-using-spheres *collide-cache* gp-0))
            (target-collide-set! 'mech-carry f30-0)
            )
        )
      )
    )
  (send-event (handle->process (-> self carry other)) 'carry (-> self carry))
  (none)
  )

;; definition for function target-mech-carry-post
(defbehavior target-mech-carry-post target ()
  (logior! (-> self focus-status) (focus-status carry))
  (target-mech-post)
  (target-mech-carry-update)
  (none)
  )

;; failed to figure out what this is:
(defstate target-mech-carry-pickup (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touched)
       (cond
         (((method-of-type touching-shapes-entry prims-touching?)
           (the-as touching-shapes-entry (-> block param 0))
           (-> self control)
           (the-as uint 1920)
           )
          (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-2 from) (process->ppointer self))
            (set! (-> a1-2 num-params) 0)
            (set! (-> a1-2 message) 'carry?)
            (let ((a1-3 (send-event-function proc a1-2)))
              (when a1-3
                (let ((f0-0 (distance-from-destination (-> self carry) (the-as carry-info a1-3))))
                  (when (and (>= f0-0 0.0) (< f0-0 (-> self carry other-value)))
                    (set! (-> self carry other) (process->handle proc))
                    (set! (-> self carry other-value) f0-0)
                    )
                  )
                )
              )
            )
          #f
          )
         (else
           (target-mech-handler proc argc message block)
           )
         )
       )
      (('change-mode 'end-mode)
       #f
       )
      (else
        (target-mech-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self control mod-surface) *mech-pickup-mods*)
    (set! (-> self mech stick-off) (the-as basic #t))
    (set-time! (-> self state-time))
    (set-forward-vel 0.0)
    (set! (-> self carry other) (the-as handle #f))
    (set! (-> self carry other-value) 100000000000.0)
    (set! (-> self carry max-distance) 32768.0)
    (set! (-> self carry mode) (carry-mode carry mech-carry mech-drag))
    (carry-info-method-9 (-> self carry))
    )
  :exit (behavior ()
    (when (not (and (-> self next-state) (let ((v1-3 (-> self next-state name)))
                                           (or (= v1-3 'target-mech-carry-stance)
                                               (= v1-3 'target-mech-carry-walk)
                                               (= v1-3 'target-mech-carry-drop)
                                               (= v1-3 'target-mech-carry-throw)
                                               (= v1-3 'target-mech-carry-jump)
                                               (= v1-3 'target-mech-carry-falling)
                                               (= v1-3 'target-mech-carry-hit-ground)
                                               (= v1-3 'target-mech-carry-throw)
                                               (= v1-3 'target-mech-carry-drag)
                                               (= v1-3 'target-mech-shield)
                                               )
                                           )
                    )
               )
      (logclear! (-> self focus-status) (focus-status carry))
      (send-event (handle->process (-> self carry other)) 'drop (-> self carry) *null-vector*)
      (target-collide-set! 'mech 0.0)
      (target-exit)
      )
    (set! (-> self mech stick-off) #f)
    (target-mech-exit)
    )
  :code (behavior ()
    (let ((f30-0 0.0)
          (f28-0 0.0)
          (gp-0 #f)
          )
      (ja-channel-push! 2 1)
      (ja :group! jakb-mech-carry-pickup-high-ja :num! min)
      (ja :chan 1 :group! jakb-mech-carry-pickup-low-ja :num! (chan 0) :frame-interp0 f30-0 :frame-interp1 f30-0)
      (suspend)
      (ja :num! (seek!))
      (ja :chan 1 :num! (chan 0))
      (target-danger-set! 'carry? #f)
      (suspend)
      (ja :num! (seek!))
      (ja :chan 1 :num! (chan 0))
      (format #t "carry picked ~A~%" (handle->process (-> self carry other)))
      (let ((a1-9 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-9 from) (process->ppointer self))
        (set! (-> a1-9 num-params) 0)
        (set! (-> a1-9 message) 'carry-info)
        (let ((s5-1 (the-as carry-info (send-event-function (handle->process (-> self carry other)) a1-9))))
          (cond
            (s5-1
              (let* ((s4-1 (vector-! (new 'stack-no-clear 'vector) (-> s5-1 point) (-> self control trans)))
                     (s3-0 (new-stack-vector0))
                     (f26-0 (vector-dot (-> self control local-normal) s4-1))
                     )
                0.0
                (vector-! s3-0 s4-1 (vector-float*! s3-0 (-> self control local-normal) f26-0))
                (let* ((f24-0 (vector-length s3-0))
                       (f22-0 f24-0)
                       )
                  (set! f28-0 (lerp-scale 1.0 0.0 f26-0 3072.0 7168.0))
                  (vector+!
                    s4-1
                    (vector-float*! s4-1 (-> self control local-normal) f26-0)
                    (vector-float*! s3-0 s3-0 (/ f24-0 f22-0))
                    )
                  )
                )
              (cond
                ((logtest? (-> s5-1 mode) (carry-mode mech-drag))
                 (sound-play "mech-drag-pikup")
                 (let ((s4-5 (vector-! (new 'stack-no-clear 'vector) (-> self carry point) (-> s5-1 point))))
                   (set! gp-0 #t)
                   (vector-xz-normalize! s4-5 (-> s5-1 max-pull))
                   (vector+! s4-5 s4-5 (-> s5-1 point))
                   )
                 (let* ((f26-1 (y-angle (-> s5-1 process 0 control)))
                        (f0-15 (vector-y-angle (vector-! (new 'stack-no-clear 'vector) (-> s5-1 point) (-> self carry point))))
                        (f0-21 (the float (the int (* 0.000061035156 (+ 73728.0 (deg- f0-15 f26-1))))))
                        (s5-2 (new 'stack-no-clear 'vector))
                        )
                   (set! (-> self carry face-dir) (the int f0-21))
                   (let ((f24-2 (the float (sar (shl (the int (* 16384.0 f0-21)) 48) 48))))
                     (set! (-> self control unknown-word04) (the-as uint (+ f26-1 f24-2)))
                     (set-vector! s5-2 (sin (+ f26-1 f24-2)) 0.0 (cos (+ f26-1 f24-2)) 1.0)
                     )
                   (forward-up-nopitch->quaternion
                     (-> self control dir-targ)
                     s5-2
                     (vector-y-quaternion! (new-stack-vector0) (-> self control dir-targ))
                     )
                   )
                 )
                (else
                  (sound-play "mech-drag-pikup")
                  (forward-up-nopitch->quaternion
                    (-> self control dir-targ)
                    (vector-normalize! (vector-! (new-stack-vector0) (-> s5-1 point) (-> self control trans)) 1.0)
                    (vector-y-quaternion! (new-stack-vector0) (-> self control dir-targ))
                    )
                  )
                )
              )
            (else
              (sound-play "mech-pickup-1")
              )
            )
          )
        )
      (target-danger-set! 'harmless #f)
      (cond
        (gp-0
          (ja-channel-push! 1 (seconds 0.01))
          (ja-no-eval :group! jakb-mech-drag-pickup-ja :num! (seek!) :frame-num 0.0)
          (until (ja-done? 0)
            (suspend)
            (ja :num! (seek!))
            )
          )
        (else
          (ja-no-eval :num! (seek! (ja-aframe 8.0 0)))
          (while (not (ja-done? 0))
            (set! f30-0 (seek f30-0 f28-0 (* 5.0 (seconds-per-frame))))
            (ja :chan 1 :frame-interp0 f30-0 :frame-interp1 f30-0)
            (suspend)
            (ja-eval)
            )
          )
        )
      (let ((s4-11 (new 'stack-no-clear 'vector))
            (s5-6 (new 'stack-no-clear 'vector))
            )
        (when (send-event (handle->process (-> self carry other)) 'pickup (-> self carry) s4-11 s5-6)
          (target-collide-set! 'mech-carry 0.0)
          (when gp-0
            (sound-play "mech-drag-grab")
            (let ((s3-6 (vector-! (new 'stack-no-clear 'vector) s4-11 (-> self control trans)))
                  (a1-37 (new 'stack-no-clear 'event-message-block))
                  )
              (set! (-> a1-37 from) (process->ppointer self))
              (set! (-> a1-37 num-params) 0)
              (set! (-> a1-37 message) 'carry-info)
              (let ((s4-12 (the-as carry-info (send-event-function (handle->process (-> self carry other)) a1-37))))
                (vector-flatten! s3-6 s3-6 s5-6)
                (let ((f0-43 (vector-length s3-6)))
                  (when (< 1228.8 f0-43)
                    (vector-normalize! s3-6 (+ -1228.8 f0-43))
                    (move-by-vector! (-> self control) s3-6)
                    (vector+! (-> s4-12 hold-trans) (-> s4-12 hold-trans) s3-6)
                    )
                  )
                )
              )
            (set-yaw-angle-clear-roll-pitch! (-> self control) (the-as float (-> self control unknown-word04)))
            (rot->dir-targ! (-> self control))
            (go target-mech-carry-drag)
            )
          (sound-play "mech-servo-up")
          (ja-no-eval :num! (seek!))
          (while (not (ja-done? 0))
            (set! f30-0 (seek f30-0 f28-0 (* 5.0 (seconds-per-frame))))
            (ja :chan 1 :frame-interp0 f30-0 :frame-interp1 f30-0)
            (suspend)
            (ja-eval)
            )
          (go target-mech-carry-stance)
          )
        )
      (cond
        (gp-0
          (ja-no-eval :num! (seek! 0.0))
          (while (not (ja-done? 0))
            (suspend)
            (ja-eval)
            )
          )
        (else
          (ja-no-eval :num! (seek! (ja-aframe 11.0 0)))
          (while (not (ja-done? 0))
            (ja :chan 1 :frame-interp0 f30-0 :frame-interp1 f30-0)
            (suspend)
            (ja-eval)
            )
          (suspend)
          (ja-no-eval :num! (seek! 0.0))
          (while (not (ja-done? 0))
            (ja :chan 1 :frame-interp0 f30-0 :frame-interp1 f30-0)
            (suspend)
            (ja-eval)
            )
          )
        )
      )
    (go target-mech-stance)
    )
  :post (behavior ()
    (target-mech-post)
    (carry-info-method-9 (-> self carry))
    (target-mech-carry-update)
    )
  )

;; failed to figure out what this is:
(defstate target-mech-carry-drop (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('change-mode 'end-mode)
       #f
       )
      (else
        (target-mech-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self control mod-surface) *mech-walk-mods*)
    (set-time! (-> self state-time))
    (set-forward-vel 0.0)
    (set! (-> self mech stick-off) (the-as basic #t))
    )
  :exit (-> target-mech-carry-pickup exit)
  :code (behavior ()
    (let ((f30-0 1.0)
          (gp-1 (sound-play "mech-servo-down"))
          )
      (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-1 from) (process->ppointer self))
        (set! (-> a1-1 num-params) 0)
        (set! (-> a1-1 message) 'carry-info)
        (let ((a0-8 (the-as carry-info (send-event-function (handle->process (-> self carry other)) a1-1))))
          (when a0-8
            (let ((s5-1 (new 'stack-no-clear 'vector)))
              (set! (-> s5-1 quad) (-> a0-8 point quad))
              (set! (-> s5-1 y) (- (-> s5-1 y) (-> a0-8 process 0 control root-prim prim-core world-sphere w)))
              (let ((s4-0 (new-stack-vector0))
                    (f28-0 (vector-dot (-> self control local-normal) s5-1))
                    )
                0.0
                (vector-! s4-0 s5-1 (vector-float*! s4-0 (-> self control local-normal) f28-0))
                (let* ((f26-0 (vector-length s4-0))
                       (f24-0 f26-0)
                       )
                  (set! f30-0 (lerp-scale 1.0 0.0 f28-0 3072.0 7168.0))
                  (vector+!
                    s5-1
                    (vector-float*! s5-1 (-> self control local-normal) f28-0)
                    (vector-float*! s4-0 s4-0 (/ f26-0 f24-0))
                    )
                  )
                )
              )
            )
          )
        )
      (ja-channel-push! 2 (seconds 0.1))
      (ja :group! jakb-mech-carry-pickup-high-ja :num! max)
      (ja :chan 1 :group! jakb-mech-carry-pickup-low-ja :num! (chan 0) :frame-interp0 f30-0 :frame-interp1 f30-0)
      (suspend)
      (ja-no-eval :num! (seek! (ja-aframe 8.0 0)))
      (while (not (ja-done? 0))
        (let ((a1-10 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-10 from) (process->ppointer self))
          (set! (-> a1-10 num-params) 0)
          (set! (-> a1-10 message) 'carry-info)
          (let ((s5-5 (the-as carry-info (send-event-function (handle->process (-> self carry other)) a1-10))))
            (when s5-5
              (if (< 20.0 (ja-aframe-num 0))
                  (seek! (-> s5-5 grab-trans-blend) 1.0 (* 2.0 (seconds-per-frame)))
                  )
              (let ((s3-0 (-> s5-5 process 0 control))
                    (s5-6 (new 'stack-no-clear 'collide-query))
                    )
                (let ((s4-1 (new 'stack-no-clear 'inline-array 'sphere 1)))
                  (dotimes (s2-0 1)
                    ((method-of-type sphere new) (the-as symbol (-> s4-1 s2-0)) sphere)
                    )
                  (set! (-> s4-1 0 quad) (-> s3-0 root-prim prim-core world-sphere quad))
                  (let ((v1-66 s5-6))
                    (set! (-> v1-66 best-dist) (the-as float s4-1))
                    (set! (-> v1-66 best-other-prim) (the-as collide-shape-prim 1))
                    (set! (-> v1-66 collide-with) (-> self control root-prim prim-core collide-with))
                    (set! (-> v1-66 ignore-process0) #f)
                    (set! (-> v1-66 ignore-process1) #f)
                    (set! (-> v1-66 ignore-pat)
                          (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                          )
                    (set! (-> v1-66 best-my-prim) (the-as collide-shape-prim #t))
                    (set! (-> v1-66 action-mask) (collide-action solid))
                    )
                  )
                (format 0 "frame: ~f~%" (ja-frame-num 0))
                (when (and (fill-and-probe-using-spheres *collide-cache* s5-6) (< 12.5 (ja-frame-num 0)))
                  (sound-play "mech-setdown")
                  (let ((v1-73 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
                    (set! (-> v1-73 command) (sound-command set-param))
                    (set! (-> v1-73 id) gp-1)
                    (set! (-> v1-73 params volume) -4)
                    (set! (-> v1-73 auto-time) 48)
                    (set! (-> v1-73 auto-from) 2)
                    (set! (-> v1-73 params mask) (the-as uint 17))
                    (-> v1-73 id)
                    )
                  (set! gp-1 (sound-play "mech-servo-up"))
                  (let ((v1-77 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
                    (set! (-> v1-77 command) (sound-command set-param))
                    (set! (-> v1-77 id) gp-1)
                    (set! (-> v1-77 params volume) -4)
                    (set! (-> v1-77 auto-time) 192)
                    (set! (-> v1-77 auto-from) 2)
                    (set! (-> v1-77 params mask) (the-as uint 17))
                    (-> v1-77 id)
                    )
                  (ja-no-eval :num! (seek!))
                  (while (not (ja-done? 0))
                    (suspend)
                    (ja-eval)
                    )
                  (go target-mech-carry-stance)
                  )
                )
              )
            )
          )
        (suspend)
        (ja-eval)
        )
      )
    (sound-play "mech-setdown")
    (let ((v1-93 (vector-float*! (new 'stack-no-clear 'vector) (-> self control local-normal) 0.0)))
      (vector+float*! v1-93 v1-93 (-> self control c-R-w fvec) 20480.0)
      (send-event (handle->process (-> self carry other)) 'drop (-> self carry) v1-93)
      )
    (target-collide-set! 'mech 0.0)
    (ja-no-eval :num! (seek! 0.0))
    (while (not (ja-done? 0))
      (suspend)
      (ja-eval)
      )
    (go target-mech-stance)
    )
  :post (-> target-mech-carry-pickup post)
  )

;; failed to figure out what this is:
(defstate target-mech-carry-stance (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('change-mode)
       (case (-> block param 0)
         (('falling)
          (if (and (-> self next-state) (= (-> self next-state name) 'target-mech-carry-drag))
              #f
              (go target-mech-carry-falling)
              )
          )
         (('grab)
          (if (not (-> block param 1))
              #t
              (go target-mech-grab)
              )
          )
         )
       )
      (else
        (target-mech-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self control mod-surface) *mech-stance-mods*)
    (set! (-> self control mod-surface turnvv) 20024.889)
    (set! (-> self control did-move-to-pole-or-max-jump-height) 0.0)
    (rot->dir-targ! (-> self control))
    (set-time! (-> self state-time))
    )
  :exit (behavior ()
    ((-> target-mech-carry-pickup exit))
    (rot->dir-targ! (-> self control))
    )
  :trans (behavior ()
    (if (and (move-legs?)
             (and (< (fabs
                       (deg-diff (quaternion-y-angle (-> self control dir-targ)) (vector-y-angle (-> self control to-target-pt-xz)))
                       )
                     1820.4445
                     )
                  (time-elapsed? (-> self control time-of-last-zero-input) (seconds 0.05))
                  )
             )
        (go target-mech-carry-walk)
        )
    (if (and (cpad-pressed? (-> self control cpad number) r1)
             (time-elapsed? (-> self carry pickup-time) (seconds 0.1))
             )
        (go target-mech-carry-drop)
        )
    (when (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                         (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                         )
                                 (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                                 )
                         (pad-buttons x)
                         )
               (can-jump? #f)
               )
      enter-state
      (let ((a0-24 (-> *TARGET-bank* mech-carry-jump-height-min))
            (a1-3 (-> *TARGET-bank* mech-carry-jump-height-max))
            )
        (go target-mech-carry-jump a0-24 a1-3)
        )
      )
    (if (and (cpad-pressed? (-> self control cpad number) square) (can-hands? #t) (mech-can-throw?))
        (go target-mech-carry-throw)
        )
    (fall-test (the-as (state object target) target-mech-carry-falling) (-> *TARGET-bank* fall-height))
    )
  :code (behavior ()
    (let ((v1-2 (ja-group)))
      (when (not (and v1-2 (= v1-2 jakb-mech-carry-turn45-ja)))
        (ja-channel-push! 2 (seconds 0.2))
        (ja :group! jakb-mech-carry-turn45-ja :dist 8192.0)
        (ja :chan 1 :group! jakb-mech-carry-stance-ja :dist 0.0)
        )
      )
    (let ((f30-0 0.0))
      (until #f
        (let ((f28-0 (y-angle (-> self control))))
          (deg-diff f28-0 (quaternion-y-angle (-> self control dir-targ)))
          (suspend)
          (let ((f28-1 (* (deg-diff f28-0 (y-angle (-> self control))) (-> self clock frames-per-second))))
            (set! f30-0 (if (< 910.2222 (fabs f28-1))
                            (seek f30-0 1.0 (* 16.0 (seconds-per-frame)))
                            (seek f30-0 0.0 (* 6.0 (seconds-per-frame)))
                            )
                  )
            (let* ((f0-9 (current-cycle-distance (-> self skel)))
                   (v1-26 (if (= f0-9 0.0)
                              0.0
                              (/ f28-1 f0-9)
                              )
                          )
                   (f0-11 v1-26)
                   )
              (ja :num! (loop! f0-11))
              )
            )
          )
        (let ((v1-32 (-> self skel root-channel 1))
              (f0-13 (- 1.0 f30-0))
              )
          (set! (-> v1-32 frame-interp 1) f0-13)
          (set! (-> v1-32 frame-interp 0) f0-13)
          )
        )
      )
    #f
    )
  :post target-mech-carry-post
  )

;; failed to figure out what this is:
(defstate target-mech-carry-walk (target)
  :event (-> target-mech-carry-stance event)
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self control mod-surface) *mech-carry-walk-mods*)
    (set! (-> self control unknown-word04) (the-as uint 0.0))
    )
  :exit (-> target-mech-carry-pickup exit)
  :trans (behavior ()
    (let ((gp-0 (ja-group))
          (f0-0 (ja-aframe-num 0))
          )
      (when (if (or (and (= gp-0 jakb-mech-carry-walk-ja) (>= f0-0 5.5) (>= 9.5 f0-0))
                    (and (= gp-0 jakb-mech-carry-walk-ja) (>= f0-0 20.5) (>= 24.5 f0-0))
                    )
                #t
                )
        (when (and (< 5.0 (the-as float (-> self control unknown-word04)))
                   (= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
                   )
          (set-forward-vel 0.0)
          (go target-mech-carry-stance)
          )
        )
      )
    (if (and (cpad-pressed? (-> self control cpad number) r1)
             (time-elapsed? (-> self carry pickup-time) (seconds 0.1))
             )
        (go target-mech-carry-drop)
        )
    (when (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                         (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                         )
                                 (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                                 )
                         (pad-buttons x)
                         )
               (can-jump? #f)
               )
      enter-state
      (let ((a0-24 (-> *TARGET-bank* mech-carry-jump-height-min))
            (a1-2 (-> *TARGET-bank* mech-carry-jump-height-max))
            )
        (go target-mech-carry-jump a0-24 a1-2)
        )
      )
    (if (and (cpad-pressed? (-> self control cpad number) square) (can-hands? #t) (mech-can-throw?))
        (go target-mech-carry-throw)
        )
    (fall-test (the-as (state object target) target-mech-carry-falling) (-> *TARGET-bank* fall-height))
    )
  :code (behavior ()
    (let ((f30-0 0.0))
      (let ((f28-0 (cond
                     ((zero? (-> self mech walk-anim-leg))
                      (set! (-> self mech walk-anim-leg) 1)
                      7.0
                      )
                     (else
                       (set! (-> self mech walk-anim-leg) 0)
                       22.0
                       )
                     )
                   )
            (v1-7 (ja-group))
            )
        (when (not (and v1-7 (= v1-7 jakb-mech-carry-walk-ja)))
          (ja-channel-push! 2 (seconds 0.1))
          (ja :group! jakb-mech-carry-walk-ja
              :num! (identity (ja-aframe f28-0 0))
              :dist (-> *TARGET-bank* mech-walk-carry-cycle-dist)
              )
          (ja :chan 1 :group! jakb-mech-carry-stance-ja :dist 0.0)
          )
        )
      (until #f
        (if (< (-> self control ctrl-xz-vel) 4096.0)
            (set-forward-vel 4096.0)
            )
        (suspend)
        (let* ((f0-4 (current-cycle-distance (-> self skel)))
               (f28-1 (/ (-> self control ctrl-xz-vel) f0-4))
               )
          (set! (-> self control unknown-word04)
                (the-as uint (+ (the-as float (-> self control unknown-word04)) f28-1))
                )
          (set! f30-0
                (seek f30-0 (lerp-scale 1.0 0.0 (-> self control ctrl-xz-vel) 0.0 8192.0) (* 2.0 (seconds-per-frame)))
                )
          (ja :num! (loop! f28-1))
          )
        (ja :chan 1 :num! (chan 0) :frame-interp0 f30-0 :frame-interp1 f30-0)
        )
      )
    #f
    )
  :post target-mech-carry-post
  )

;; failed to figure out what this is:
(defstate target-mech-carry-drag (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('push)
       (when (zero? (-> self control sliding-start-time))
         (set! (-> self control sliding-start-time) (+ (current-time) (the-as time-frame (-> block param 0))))
         (let ((v0-0 (the-as object #t)))
           (set! (-> self control unknown-word04) (the-as uint v0-0))
           v0-0
           )
         )
       )
      (('drop)
       (logclear! (-> *cpad-list* cpads (-> self control cpad number) button0-abs 0) (pad-buttons r1))
       (logclear! (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0) (pad-buttons r1))
       (send-event (handle->process (-> self carry other)) 'drop (-> self carry) *null-vector*)
       (target-collide-set! 'mech 0.0)
       (go target-mech-stance)
       )
      (else
        ((-> target-mech-carry-stance event) proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self control sliding-start-time) 0)
    (set! (-> self control unknown-word04) (the-as uint #f))
    (set! (-> self control mod-surface) *mech-carry-drag-mods*)
    (set-forward-vel 0.0)
    )
  :exit (behavior ()
    (set! (-> self mech jump-thrust) 0.0)
    (set! (-> self mech thruster-flame-width) 0.0)
    (set! (-> self mech thruster-flame-length) 0.0)
    (let ((v1-3 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-3 command) (sound-command set-param))
      (set! (-> v1-3 id) (-> self mech thrust-sound-id))
      (set! (-> v1-3 params volume) -4)
      (set! (-> v1-3 auto-time) 48)
      (set! (-> v1-3 auto-from) 2)
      (set! (-> v1-3 params mask) (the-as uint 17))
      (-> v1-3 id)
      )
    (let ((v1-5 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-5 command) (sound-command set-param))
      (set! (-> v1-5 id) (-> self mech drag-sound-id))
      (set! (-> v1-5 params volume) -4)
      (set! (-> v1-5 auto-time) 48)
      (set! (-> v1-5 auto-from) 2)
      (set! (-> v1-5 params mask) (the-as uint 17))
      (-> v1-5 id)
      )
    ((-> target-mech-carry-pickup exit))
    )
  :trans (behavior ()
    (when (and (not (cpad-hold? (-> self control cpad number) r1))
               (time-elapsed? (-> self carry pickup-time) (seconds 0.5))
               )
      (sound-play "mech-drag-off")
      (if (or (and (>= (-> self mech back-touch-time) (-> self state-time))
                   (< (vector-vector-distance (-> self control trans) (-> self mech back-touch-trans)) 4096.0)
                   )
              (let ((gp-1 (new 'stack-no-clear 'collide-query)))
                (let ((s5-1 (new 'stack-no-clear 'inline-array 'sphere 1)))
                  (dotimes (s4-0 1)
                    ((method-of-type sphere new) (the-as symbol (-> s5-1 s4-0)) sphere)
                    )
                  (set! (-> s5-1 0 quad) (-> self control collision-spheres 0 prim-core world-sphere quad))
                  (vector+float*! (the-as vector (-> s5-1 0)) (the-as vector (-> s5-1 0)) (-> self control c-R-w fvec) -4096.0)
                  (set! (-> s5-1 0 r) (-> self control collision-spheres 0 prim-core world-sphere w))
                  (let ((v1-30 gp-1))
                    (set! (-> v1-30 best-dist) (the-as float s5-1))
                    (set! (-> v1-30 best-other-prim) (the-as collide-shape-prim 1))
                    (set! (-> v1-30 collide-with) (-> self control root-prim prim-core collide-with))
                    (set! (-> v1-30 ignore-process0) #f)
                    (set! (-> v1-30 ignore-process1) #f)
                    (set! (-> v1-30 ignore-pat)
                          (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                          )
                    (set! (-> v1-30 best-my-prim) (the-as collide-shape-prim #t))
                    (set! (-> v1-30 action-mask) (collide-action solid))
                    )
                  )
                (fill-and-probe-using-spheres *collide-cache* gp-1)
                )
              )
          (send-event self 'push (seconds 0.5))
          (send-event self 'drop)
          )
      )
    )
  :code (behavior ()
    (let ((f28-0 0.0)
          (f30-0 0.0)
          )
      (until #f
        (let ((f0-2
                (* (vector-dot (-> self control to-target-pt-xz) (-> self control c-R-w fvec))
                   (-> self control turn-to-magnitude)
                   )
                )
              (f26-0 0.0)
              )
          (if (and (nonzero? (-> self control sliding-start-time)) (< (-> self control sliding-start-time) (current-time)))
              (send-event self 'drop)
              (set! f28-0 (cond
                            ((nonzero? (-> self control sliding-start-time))
                             (let ((v1-17 (ja-group)))
                               (when (not (and v1-17 (= v1-17 jakb-mech-push-ja)))
                                 (let ((v1-23 (ja-group)))
                                   (if (and v1-23 (= v1-23 jakb-mech-pull-ja))
                                       (set! f26-0 (ja-aframe-num 0))
                                       )
                                   )
                                 (sound-play "mech-drag-push")
                                 (ja-channel-push! 1 (seconds 0.3))
                                 (ja :group! jakb-mech-push-ja :num! (identity (ja-aframe f26-0 0)) :dist 16384.0)
                                 )
                               )
                             (when (-> self control unknown-spool-anim00)
                               (set! (-> self control unknown-word04) (the-as uint #f))
                               (set! f28-0 32768.0)
                               )
                             (seek f28-0 0.0 (* 65536.0 (seconds-per-frame)))
                             )
                            ((< 0.0 f0-2)
                             (let ((v1-47 (ja-group)))
                               (when (not (and v1-47 (= v1-47 jakb-mech-push-ja)))
                                 (let ((v1-53 (ja-group)))
                                   (if (and v1-53 (= v1-53 jakb-mech-pull-ja))
                                       (set! f26-0 (ja-aframe-num 0))
                                       )
                                   )
                                 (sound-play "mech-drag-push")
                                 (ja-channel-push! 1 (seconds 0.3))
                                 (ja :group! jakb-mech-push-ja :num! (identity (ja-aframe f26-0 0)) :dist 16384.0)
                                 )
                               )
                             (seek f28-0 49152.0 (* 24576.0 (seconds-per-frame)))
                             )
                            ((< f0-2 0.0)
                             (let ((v1-71 (ja-group)))
                               (when (not (and v1-71 (= v1-71 jakb-mech-pull-ja)))
                                 (let ((v1-77 (ja-group)))
                                   (if (and v1-77 (= v1-77 jakb-mech-push-ja))
                                       (set! f26-0 (ja-aframe-num 0))
                                       )
                                   )
                                 (sound-play "mech-drag-pull")
                                 (ja-channel-push! 1 (seconds 0.3))
                                 (ja :group! jakb-mech-pull-ja :num! (identity (ja-aframe f26-0 0)) :dist 16384.0)
                                 )
                               )
                             (seek f28-0 -49152.0 (* 24576.0 (seconds-per-frame)))
                             )
                            (else
                              (seek f28-0 0.0 (* 32768.0 (seconds-per-frame)))
                              )
                            )
                    )
              )
          )
        (set! f30-0
              (seek
                f30-0
                (lerp-scale
                  0.0
                  1.0
                  (* (vector-vector-distance (-> self control trans) (-> self control trans-old-old))
                     (-> self clock frames-per-second)
                     )
                  0.0
                  49152.0
                  )
                (* 2.0 (seconds-per-frame))
                )
              )
        (sound-play-by-name
          (static-sound-name "mech-drag-grind")
          (-> self mech drag-sound-id)
          (the int (* 1024.0 f30-0))
          0
          0
          (sound-group)
          #t
          )
        (set-forward-vel f28-0)
        (let* ((f0-24 (current-cycle-distance (-> self skel)))
               (f26-1 (/ f28-0 (* 2.0 f0-24)))
               )
          (seek!
            (-> self mech jump-thrust)
            (lerp-scale 0.0 245760.0 (fabs f28-0) 0.0 49152.0)
            (* 491520.0 (seconds-per-frame))
            )
          (let ((v1-114 (ja-group)))
            (if (and v1-114 (or (= v1-114 jakb-mech-push-ja) (= v1-114 jakb-mech-pull-ja)))
                (ja :num! (loop! f26-1))
                )
            )
          )
        (suspend)
        0
        )
      )
    #f
    )
  :post target-mech-carry-post
  )

;; failed to figure out what this is:
(defstate target-mech-carry-falling (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (let ((v0-0 (target-mech-bonk-event-handler proc argc message block)))
      (cond
        (v0-0
          (empty)
          v0-0
          )
        (else
          ((-> target-mech-carry-stance event) proc argc message block)
          )
        )
      )
    )
  :enter (behavior ()
    (set! (-> self control mod-surface) *mech-carry-jump-mods*)
    (set-time! (-> self state-time))
    )
  :exit (-> target-mech-carry-pickup exit)
  :trans (behavior ()
    (if (logtest? (-> self control status) (collide-status on-surface))
        (go target-mech-carry-hit-ground #f)
        )
    (when (if (and (< (target-move-dist (-> *TARGET-bank* stuck-time)) (-> *TARGET-bank* stuck-distance))
                   (time-elapsed? (-> self state-time) (seconds 0.05))
                   (not (and *cheat-mode* (cpad-hold? (-> self control cpad number) r2)))
                   )
              #t
              )
      (logior! (-> self control status) (collide-status on-surface))
      (go target-mech-carry-hit-ground 'stuck)
      )
    )
  :code (behavior ()
    (let ((v1-2 (ja-group)))
      (cond
        ((and v1-2 (= v1-2 jakb-mech-carry-jump-loop-ja))
         )
        (else
          (ja-channel-push! 1 (seconds 0.33))
          (ja :group! jakb-mech-carry-jump-loop-ja)
          (while (!= (-> self skel root-channel 0) (-> self skel channel))
            (suspend)
            )
          )
        )
      )
    (ja-no-eval :group! jakb-mech-carry-jump-loop-ja :num! (loop!) :frame-num 0.0)
    (until #f
      (suspend)
      (ja :group! jakb-mech-carry-jump-loop-ja :num! (loop!))
      )
    #f
    )
  :post target-mech-carry-post
  )

;; failed to figure out what this is:
(defstate target-mech-carry-hit-ground (target)
  :event (-> target-mech-carry-falling event)
  :enter (behavior ((arg0 symbol))
    (let ((v1-0 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-0 command) (sound-command set-param))
      (set! (-> v1-0 id) (-> self mech thrust-sound-id))
      (set! (-> v1-0 params volume) -4)
      (set! (-> v1-0 auto-time) 48)
      (set! (-> v1-0 auto-from) 2)
      (set! (-> v1-0 params mask) (the-as uint 17))
      (-> v1-0 id)
      )
    (rot->dir-targ! (-> self control))
    (cond
      ((= arg0 'stuck)
       )
      (else
        (target-land-effect)
        (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.3))
        )
      )
    (set! (-> self control last-running-attack-end-time) 0)
    (set! (-> self control last-attack-end-time) 0)
    (if (!= (-> self control ground-pat material) (pat-material ice))
        (delete-back-vel)
        )
    (set! (-> self control mod-surface) *mech-stance-mods*)
    (set! (-> self control mod-surface turnvv) 0.0)
    (start-bobbing!
      (-> self water)
      (lerp-scale 0.0 4096.0 (-> self control ground-impact-vel) 40960.0 102400.0)
      600
      1500
      )
    )
  :exit (behavior ()
    (logclear! (-> self target-flags) (target-flags lleg-still rleg-still))
    ((-> target-mech-carry-pickup exit))
    )
  :trans (behavior ()
    (when (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                         (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                         )
                                 (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                                 )
                         (pad-buttons x)
                         )
               (can-jump? #f)
               )
      enter-state
      (let ((a0-16 (-> *TARGET-bank* mech-carry-jump-height-min))
            (a1-2 (-> *TARGET-bank* mech-carry-jump-height-max))
            )
        (go target-mech-carry-jump a0-16 a1-2)
        )
      )
    (if (and (!= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
             (let ((v1-26 (ja-group)))
               (and (and v1-26 (= v1-26 jakb-mech-carry-jump-land-ja)) (>= (ja-aframe-num 0) 30.0))
               )
             )
        (go target-mech-carry-walk)
        )
    (fall-test (the-as (state object target) target-mech-carry-falling) (-> *TARGET-bank* fall-height))
    )
  :code (behavior ((arg0 symbol))
    (target-hit-ground-anim #f (are-still?))
    (go target-mech-carry-stance)
    )
  :post target-mech-carry-post
  )

;; failed to figure out what this is:
(defstate target-mech-carry-jump (target)
  :event (-> target-mech-carry-falling event)
  :enter (behavior ((arg0 float) (arg1 float))
    (set-time! (-> self state-time))
    (init-var-jump arg0 arg1 #t #f (-> self control transv) 2.0)
    (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (sound-play "mech-jump")
    (set! (-> self control mod-surface) *mech-carry-jump-mods*)
    (set! (-> self control unknown-float36)
          (fmax 0.0 (fmin 1.0 (* 0.00004359654 (+ -11468.8 (-> self control ctrl-xz-vel)))))
          )
    )
  :exit (behavior ()
    (rot->dir-targ! (-> self control))
    ((-> target-mech-carry-pickup exit))
    (set! (-> self mech jump-thrust) 0.0)
    (set! (-> self mech thruster-flame-width) 0.0)
    (set! (-> self mech thruster-flame-length) 0.0)
    (target-exit)
    )
  :trans (behavior ()
    (set! (-> self control unknown-float36)
          (fmax
            (-> self control unknown-float36)
            (* 0.003921569 (the float (-> *cpad-list* cpads (-> self control cpad number) abutton 6)))
            )
          )
    ((-> target-mech-carry-falling trans))
    (mod-var-jump #t #f (cpad-hold? (-> self control cpad number) x) (-> self control transv))
    (cond
      ((>= (vector-dot (-> self control dynam gravity-normal) (-> self control transv)) 0.0)
       (set! (-> self mech jump-thrust) 0.0)
       )
      (else
        (set! (-> self mech jump-thrust) 0.0)
        (set! (-> self mech thruster-flame-width) 0.0)
        (set! (-> self mech thruster-flame-length) 0.0)
        )
      )
    )
  :code (behavior ((arg0 float) (arg1 float))
    (ja-channel-push! 1 (seconds 0.05))
    (ja :group! jakb-mech-carry-jump-ja :num! min)
    (suspend)
    (ja :group! jakb-mech-carry-jump-ja :num! (+!))
    (suspend)
    (until (ja-done? 0)
      (let ((f30-0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
            (f0-4 (- 10.0 (ja-aframe-num 0)))
            (gp-1 (-> self skel root-channel 0))
            )
        (set! (-> gp-1 param 0) (the float (+ (-> gp-1 frame-group frames num-frames) -1)))
        (let ((v1-27 (and (< 0.0 f30-0) (< 0.0 f0-4))))
          (set! (-> gp-1 param 1)
                (if v1-27
                    (fmin (fmin 3.0 f0-4) (/ (* 5.0 f0-4) (the float (time-to-apex f30-0 -245760.0))))
                    1.8
                    )
                )
          )
        (joint-control-channel-group-eval! gp-1 (the-as art-joint-anim #f) num-func-seek!)
        )
      (suspend)
      )
    (go target-mech-carry-falling)
    )
  :post target-mech-carry-post
  )

;; failed to figure out what this is:
(defstate target-mech-carry-throw (target)
  :event (-> target-mech-carry-drop event)
  :enter (behavior ()
    (set! (-> self control mod-surface) *mech-walk-mods*)
    (set-time! (-> self state-time))
    (set-forward-vel 0.0)
    (set! (-> self mech stick-off) (the-as basic #t))
    )
  :exit (-> target-mech-carry-pickup exit)
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! jakb-mech-carry-throw-ja :num! (seek! (ja-aframe 16.0 0)) :frame-num 0.0)
    (until (ja-done? 0)
      (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-3 from) (process->ppointer self))
        (set! (-> a1-3 num-params) 0)
        (set! (-> a1-3 message) 'carry-info)
        (let ((gp-1 (the-as carry-info (send-event-function (handle->process (-> self carry other)) a1-3))))
          (if gp-1
              (seek! (-> gp-1 grab-trans-blend) 1.0 (* 4.0 (seconds-per-frame)))
              )
          )
        )
      (suspend)
      (ja :num! (seek! (ja-aframe 16.0 0)))
      )
    (let ((a1-7 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-7 from) (process->ppointer self))
      (set! (-> a1-7 num-params) 0)
      (set! (-> a1-7 message) 'carry-info)
      (let ((v1-30 (the-as carry-info (send-event-function (handle->process (-> self carry other)) a1-7))))
        (when v1-30
          (let ((s4-0 (-> v1-30 process 0 control))
                (gp-3 (new 'stack-no-clear 'collide-query))
                )
            (let ((s5-0 (new 'stack-no-clear 'inline-array 'sphere 1)))
              (dotimes (s3-0 1)
                ((method-of-type sphere new) (the-as symbol (-> s5-0 s3-0)) sphere)
                )
              (set! (-> s5-0 0 quad) (-> s4-0 root-prim prim-core world-sphere quad))
              (let ((v1-38 gp-3))
                (set! (-> v1-38 best-dist) (the-as float s5-0))
                (set! (-> v1-38 best-other-prim) (the-as collide-shape-prim 1))
                (set! (-> v1-38 collide-with) (-> self control root-prim prim-core collide-with))
                (set! (-> v1-38 ignore-process0) #f)
                (set! (-> v1-38 ignore-process1) #f)
                (set! (-> v1-38 ignore-pat)
                      (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                      )
                (set! (-> v1-38 best-my-prim) (the-as collide-shape-prim #t))
                (set! (-> v1-38 action-mask) (collide-action solid))
                )
              )
            (when (fill-and-probe-using-spheres *collide-cache* gp-3)
              (ja-no-eval :num! (seek! 0.0))
              (while (not (ja-done? 0))
                (suspend)
                (ja-eval)
                )
              (go target-mech-carry-stance)
              )
            )
          )
        )
      )
    (let ((v1-48 (vector-float*! (new 'stack-no-clear 'vector) (-> self control local-normal) 2048.0)))
      (vector+float*! v1-48 v1-48 (-> self control c-R-w fvec) 131072.0)
      (send-event (handle->process (-> self carry other)) 'drop (-> self carry) v1-48)
      )
    (target-collide-set! 'normal 0.0)
    (ja-no-eval :num! (seek!))
    (while (not (ja-done? 0))
      (suspend)
      (ja-eval)
      )
    (go target-mech-stance)
    )
  :post (-> target-mech-carry-pickup post)
  )

;; failed to figure out what this is:
(defstate target-mech-get-on (target)
  :event target-generic-event-handler
  :exit (behavior ()
    (target-mech-exit)
    (set! (-> self mech stick-off) #f)
    (set! (-> self neck flex-blend) 1.0)
    (logclear! (-> self target-flags) (target-flags tf5))
    )
  :code (behavior ((arg0 handle))
    (logior! (-> self target-flags) (target-flags tf5))
    (ja-channel-set! 1)
    (set! (-> self control mod-surface) *empty-mods*)
    (send-event (ppointer->process (-> self manipy)) 'draw #t)
    (set! (-> self neck flex-blend) 0.0)
    (set! (-> self control unknown-vector37 quad) (-> self control trans quad))
    (set! (-> self control unknown-vector38 quad) (-> self control trans quad))
    (set! (-> self control unknown-vector39 quad) (-> self control quat quad))
    (set! (-> self control unknown-vector40 quad) (-> self control quat quad))
    (let* ((gp-1 (handle->process arg0))
           (v1-23 (if (type? gp-1 process-drawable)
                      gp-1
                      )
                  )
           )
      (when v1-23
        (set! (-> self control unknown-vector38 quad) (-> (the-as process-drawable v1-23) root trans quad))
        (set! (-> self control unknown-vector40 quad) (-> (the-as process-drawable v1-23) root quat quad))
        )
      )
    (set! (-> self mech mech-trans quad) (-> self control unknown-vector38 quad))
    (quaternion-copy!
      (the-as quaternion (-> self mech mech-quat))
      (the-as quaternion (-> self control unknown-vector40))
      )
    (set! (-> self mech mech-scale quad) (-> self control scale quad))
    (set! (-> self mech stick-off) (the-as basic #t))
    (ja-no-eval :group! jakb-mech-get-on-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (let ((f30-0 (sin (lerp-scale 0.0 16384.0 (ja-aframe-num 0) 70.0 80.0))))
        (let ((f28-0 (lerp-scale 0.0 1.0 (ja-aframe-num 0) 70.0 80.0)))
          (vector-lerp!
            (-> self control trans)
            (-> self control unknown-vector37)
            (-> self control unknown-vector38)
            f30-0
            )
          (set! (-> self control trans y)
                (lerp (-> self control unknown-vector37 y) (-> self control unknown-vector38 y) f28-0)
                )
          )
        (quaternion-slerp!
          (-> self control quat-for-control)
          (the-as quaternion (-> self control unknown-vector39))
          (the-as quaternion (-> self control unknown-vector40))
          f30-0
          )
        )
      (rot->dir-targ! (-> self control))
      (set! (-> self alt-cam-pos quad) (-> self control camera-pos quad))
      (suspend)
      (ja :num! (seek!))
      )
    (go target-mech-stance)
    )
  :post (behavior ()
    (target-no-move-post)
    (target-mech-effect)
    )
  )

;; failed to figure out what this is:
(defstate target-mech-get-up (target)
  :event target-generic-event-handler
  :exit (behavior ()
    (target-mech-exit)
    (set! (-> self mech stick-off) #f)
    (set! (-> self neck flex-blend) 1.0)
    (logclear! (-> self target-flags) (target-flags tf5))
    )
  :code (behavior ((arg0 handle))
    (logior! (-> self target-flags) (target-flags tf5))
    (ja-channel-set! 1)
    (set! (-> self control mod-surface) *empty-mods*)
    (send-event (ppointer->process (-> self manipy)) 'draw #t)
    (set! (-> self neck flex-blend) 0.0)
    (set! (-> self control unknown-vector37 quad) (-> self control trans quad))
    (set! (-> self control unknown-vector38 quad) (-> self control trans quad))
    (set! (-> self control unknown-vector39 quad) (-> self control quat quad))
    (set! (-> self control unknown-vector40 quad) (-> self control quat quad))
    (let* ((gp-1 (handle->process arg0))
           (v1-23 (if (type? gp-1 process-drawable)
                      gp-1
                      )
                  )
           )
      (when v1-23
        (set! (-> self control unknown-vector38 quad) (-> (the-as process-drawable v1-23) root trans quad))
        (set! (-> self control unknown-vector40 quad) (-> (the-as process-drawable v1-23) root quat quad))
        )
      )
    (set! (-> self mech mech-trans quad) (-> self control unknown-vector38 quad))
    (quaternion-copy!
      (the-as quaternion (-> self mech mech-quat))
      (the-as quaternion (-> self control unknown-vector40))
      )
    (set! (-> self mech mech-scale quad) (-> self control scale quad))
    (set! (-> self mech stick-off) (the-as basic #t))
    (ja-no-eval :group! jakb-mech-get-on-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (let ((f30-0 (sin (lerp-scale 0.0 16384.0 (ja-aframe-num 0) 70.0 80.0))))
        (let ((f28-0 (lerp-scale 0.0 1.0 (ja-aframe-num 0) 70.0 80.0)))
          (vector-lerp!
            (-> self control trans)
            (-> self control unknown-vector37)
            (-> self control unknown-vector38)
            f30-0
            )
          (set! (-> self control trans y)
                (lerp (-> self control unknown-vector37 y) (-> self control unknown-vector38 y) f28-0)
                )
          )
        (quaternion-slerp!
          (-> self control quat-for-control)
          (the-as quaternion (-> self control unknown-vector39))
          (the-as quaternion (-> self control unknown-vector40))
          f30-0
          )
        )
      (rot->dir-targ! (-> self control))
      (set! (-> self alt-cam-pos quad) (-> self control camera-pos quad))
      (suspend)
      (ja :num! (seek!))
      )
    (go target-mech-stance)
    )
  :post (behavior ()
    (target-no-move-post)
    (target-mech-effect)
    )
  )

;; failed to figure out what this is:
(defstate target-mech-shield (target)
  :event target-mech-handler
  :enter (behavior ()
    (vector-reset! (-> self control transv))
    (set! (-> self mech stick-off) (the-as basic #t))
    (send-event (handle->process (-> self mech shield-handle)) 'enabled)
    )
  :exit (behavior ()
    (set! (-> self mech stick-off) #f)
    (send-event (handle->process (-> self mech shield-handle)) 'disabled)
    (sound-stop (-> self mech shield-sound-id))
    )
  :trans (behavior ()
    (sound-play "mech-shieldloop" :id (-> self mech shield-sound-id))
    (if (or (not (handle->process (-> self mech shield-handle)))
            (not (logtest? (-> *cpad-list* cpads (-> self control cpad number) button0-abs 0) (pad-buttons circle)))
            )
        (go target-mech-stance)
        )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! jakb-mech-get-off-ja :num! (seek! (ja-aframe 30.0 0)) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! (ja-aframe 30.0 0)))
      )
    (sleep-code)
    )
  :post target-mech-post
  )

;; failed to figure out what this is:
(defstate target-mech-get-off (target)
  :event target-generic-event-handler
  :exit (behavior ()
    ((-> target-mech-start exit))
    (logclear! (-> self target-flags) (target-flags tf5))
    )
  :code (behavior ()
    (logior! (-> self target-flags) (target-flags tf5))
    (set! (-> self control mod-surface) *empty-mods*)
    (rot->dir-targ! (-> self control))
    (set-setting! 'slave-options 'clear 0.0 (cam-slave-options BIKE_MODE))
    (remove-setting! 'fov)
    (remove-setting! 'head-offset)
    (send-event *camera* 'set-dist #f #f)
    (set! (-> self neck flex-blend) 0.0)
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! jakb-mech-get-off-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (when (< 51.0 (ja-aframe-num 0))
        (logior! (-> self target-flags) (target-flags tf6))
        (vector<-cspace! (-> self alt-cam-pos) (joint-node jakb-lod0-jg Rankle))
        )
      (suspend)
      (ja :num! (seek!))
      )
    (process-spawn
      mech
      :init mech-init
      (-> self mech entity)
      (-> self control trans)
      (process->handle self)
      (-> self mech shield-value)
      :name "mech"
      :to self
      )
    (rot->dir-targ! (-> self control))
    (ja-post)
    (let ((gp-1 (new 'stack-no-clear 'vector)))
      (vector<-cspace! gp-1 (joint-node jakb-lod0-jg main))
      (+! (-> gp-1 y) -9011.2)
      (move-to-point! (-> self control) gp-1)
      )
    (send-event *camera* 'ease-in)
    (ja-channel-set! 0)
    (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (let ((v1-66 (new-stack-vector0)))
      (let ((f0-13 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
        0.0
        (vector-! v1-66 (-> self control transv) (vector-float*! v1-66 (-> self control dynam gravity-normal) f0-13))
        )
      (let* ((f0-14 (vector-length v1-66))
             (f1-2 f0-14)
             (f2-0 -49152.0)
             (a0-36 (vector+!
                      (-> self control transv)
                      (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-0)
                      (vector-float*! v1-66 v1-66 (/ f0-14 f1-2))
                      )
                    )
             )
        (go target-falling a0-36)
        )
      )
    )
  :post (-> target-mech-get-on post)
  )

;; failed to figure out what this is:
(defstate target-mech-grab (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (cond
      ((and (= message 'query) (= (-> block param 0) 'mode))
       (-> self state name)
       )
      (else
        (case message
          (('end-mode)
           (case (-> block param 0)
             (('grab)
              (go target-mech-stance)
              )
             )
           )
          (('clone-anim)
           (go target-mech-clone-anim (process->handle (the-as process (-> block param 0))))
           )
          (else
            (target-generic-event-handler proc argc message block)
            )
          )
        )
      )
    )
  :enter (behavior ()
    (set! (-> self control mod-surface) *grab-mods*)
    (set! (-> self neck flex-blend) 0.0)
    (logior! (-> self target-flags) (target-flags tf2))
    (logior! (-> self focus-status) (focus-status grabbed))
    (set! (-> self mech stick-off) (the-as basic #t))
    (sound-stop (-> self mech engine-sound-id))
    (sound-stop (-> self mech thrust-sound-id))
    (sound-stop (-> self mech drag-sound-id))
    (sound-stop (-> self mech whine-sound-id))
    )
  :exit (behavior ()
    (target-effect-exit)
    (set! (-> self mech stick-off) #f)
    (logclear! (-> self target-flags) (target-flags tf2))
    (logclear! (-> self focus-status) (focus-status grabbed))
    (logclear! (-> self water flags) (water-flag jump-out))
    ((-> target-mech-start exit))
    )
  :code (-> target-mech-stance code)
  :post target-mech-post
  )

;; failed to figure out what this is:
(defstate target-mech-clone-anim (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (if (and (= message 'trans) (= (-> block param 0) 'restore))
        (set! (-> self control unknown-word04) (the-as uint #f))
        )
    ((-> target-mech-grab event) proc argc message block)
    )
  :enter (-> target-clone-anim enter)
  :exit (behavior ()
    (set! (-> self control draw-offset y) (the-as float (-> self control unknown-word04)))
    (set! (-> self control cspace-offset y) (-> self control draw-offset y))
    (send-event (ppointer->process (-> self sidekick)) 'matrix #f)
    ((-> target-clone-anim exit))
    ((-> target-mech-start exit))
    (vector-reset! (-> self control transv))
    )
  :code (behavior ((arg0 handle))
    (set! (-> self control unknown-word04) (the-as uint (-> self control draw-offset y)))
    (set! (-> self control draw-offset y) 0.0)
    (send-event (ppointer->process (-> self sidekick)) 'matrix 'play-anim)
    (clone-anim arg0 #t "")
    (go target-mech-stance)
    )
  :post (behavior ()
    (vector+! (-> self mech mech-trans) (-> self control trans) (-> self control cspace-offset))
    (quaternion-copy! (the-as quaternion (-> self mech mech-quat)) (-> self control quat))
    (set! (-> self mech mech-scale quad) (-> self control scale quad))
    (target-no-ja-move-post)
    )
  )
