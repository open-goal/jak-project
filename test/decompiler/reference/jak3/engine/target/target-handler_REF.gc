;;-*-Lisp-*-
(in-package goal)

;; definition for function target-shoved
(defbehavior target-shoved target ((arg0 meters) (arg1 meters) (arg2 process) (arg3 (state object object target)))
  (let ((s5-0 (new 'static 'attack-info)))
    (set! (-> s5-0 attacker) (process->handle arg2))
    (set! (-> s5-0 shove-back) arg0)
    (set! (-> s5-0 shove-up) arg1)
    (set! (-> s5-0 angle)
          (if (not (logtest? (logior (-> self control status) (-> self control old-status)) (collide-status on-surface)))
              'air
              'shove
              )
          )
    (set! (-> s5-0 mask) (attack-mask attacker shove-back shove-up angle))
    (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.1))
    (go arg3 'shove s5-0)
    )
  )

;; definition for function attack-mode-is-invinc
(defun attack-mode-is-invinc ((arg0 symbol) (arg1 symbol))
  (case arg1
    (('dark-eco-pool
       'endlessfall
       'melt
       'lava
       'fry
       'slime
       'bot
       'instant-death
       'grenade
       'drill-mech-master
       'centipede
       'drown-death
       'crush
       'death
       'tentacle
       )
     #t
     )
    )
  )

;; definition for function target-attacked
;; INFO: Used lq/sq
(defbehavior target-attacked target ((arg0 symbol)
                           (arg1 attack-info)
                           (arg2 process)
                           (arg3 touching-shapes-entry)
                           (arg4 (state symbol attack-info target))
                           )
  (let ((s4-0 (if (logtest? (-> arg1 mask) (attack-mask mode))
                  (-> arg1 mode)
                  )
              )
        (s2-0 arg0)
        )
    (when (or (and (not (focus-test? self hit)) (not (logtest? (target-flags disable-attacks) (-> self target-flags))))
              (= s4-0 'endlessfall)
              )
      (case s4-0
        (('endlessfall)
         (if (not (-> *setting-control* user-current endlessfall))
             (return #f)
             )
         )
        )
      (cond
        ((or (logtest? (target-flags tf2 tinvuln1 tinvuln2) (-> self target-flags))
             (and (or (logtest? (-> self target-flags) (target-flags tf4))
                      (logtest? (game-secrets invulnerable) (-> self game secrets))
                      )
                  (not (attack-mode-is-invinc 'normal s4-0))
                  )
             (or (when (< 0.0 (-> self fact shield-level))
                   (send-event (ppointer->process (-> self lightjak shield)) 'hit)
                   #t
                   )
                 (and (-> *setting-control* user-current board-trail)
                      (focus-test? self board)
                      (< 0.0 (-> self fact eco-green))
                      )
                 (and (= s4-0 'darkeco)
                      (and (and (= (-> self fact eco-type) 2) (>= (-> self fact eco-level) 1.0))
                           (or (logtest? (-> self target-flags) (target-flags tf15)) (focus-test? self dangerous))
                           )
                      )
                 )
             )
         (case arg0
           (('attack-or-shove)
            )
           (('attack-invinc)
            (set! arg0 'attack)
            )
           (else
             (return #f)
             )
           )
         )
        (else
          (case arg0
            (('attack-or-shove 'attack-invinc)
             (set! arg0 'attack)
             )
            )
          )
        )
      (mem-copy! (the-as pointer (-> self attack-info-rec)) (the-as pointer arg1) 168)
      (compute-intersect-info (-> self attack-info-rec) arg1 self arg2 arg3)
      (when (not (focus-test? self mech))
        (if (and (not (target-log-attack (-> self attack-info-rec) (if (logtest? (attack-mask test) (-> arg1 mask))
                                                                       'test
                                                                       'log
                                                                       )
                                         )
                      )
                 (!= s2-0 'attack-invinc)
                 )
            (return #f)
            )
        )
      (if (logtest? (attack-mask test) (-> arg1 mask))
          (return #t)
          )
      (set! (-> self control attacked-by-id) (the-as int (-> self attack-info-rec id)))
      (cond
        ((and (logtest? (-> self attack-info-rec mask) (attack-mask mode))
              (or (= (-> self attack-info-rec mode) 'damage) (= (-> self attack-info-rec mode) 'shock-no-interrupt))
              (not (and (= (-> self game mode) 'play) (>= 0.0 (- (-> self fact health) (-> self attack-info-rec damage)))))
              )
         (pickup-collectable!
           (-> self fact)
           (pickup-type health)
           (if (logtest? (attack-mask damage) (-> self attack-info-rec mask))
               (- (-> self attack-info-rec damage))
               (- (-> *FACT-bank* health-single-inc))
               )
           (the-as handle #f)
           )
         (cond
           ((logtest? (-> *part-group-id-table* 10 flags) (sp-group-flag sp13))
            (set! (-> *launch-matrix* trans quad)
                  (-> (the-as vector (if (logtest? (-> self attack-info-rec mask) (attack-mask intersection))
                                         (-> self attack-info-rec intersection)
                                         (the-as vector (-> self control root-prim prim-core))
                                         )
                              )
                      quad
                      )
                  )
            (part-tracker-spawn part-tracker-subsampler :to self :group (-> *part-group-id-table* 10))
            )
           (else
             (set! (-> *launch-matrix* trans quad)
                   (-> (the-as vector (if (logtest? (-> self attack-info-rec mask) (attack-mask intersection))
                                          (-> self attack-info-rec intersection)
                                          (the-as vector (-> self control root-prim prim-core))
                                          )
                               )
                       quad
                       )
                   )
             (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 10))
             )
           )
         (target-timed-invulnerable
           (if (logtest? (-> self attack-info-rec mask) (attack-mask invinc-time))
               (-> self attack-info-rec invinc-time)
               (-> *TARGET-bank* hit-invulnerable-timeout)
               )
           self
           1
           )
         (cpad-set-buzz! (-> *cpad-list* cpads 0) 0 255 (seconds 0.5))
         (case (-> self attack-info-rec mode)
           (('damage)
            (sound-play "oof")
            )
           (else
             (if (logtest? (-> *part-group-id-table* 67 flags) (sp-group-flag sp13))
                 (part-tracker-spawn
                   part-tracker-subsampler
                   :to self
                   :group (-> *part-group-id-table* 67)
                   :duration (seconds 1)
                   :target self
                   :mat-joint 6
                   )
                 (part-tracker-spawn
                   part-tracker
                   :to self
                   :group (-> *part-group-id-table* 67)
                   :duration (seconds 1)
                   :target self
                   :mat-joint 6
                   )
                 )
             (process-spawn-function
               process
               (lambda :behavior target
                 ()
                 (let ((gp-0 (current-time)))
                   (suspend-for (seconds 1)
                     (when (time-elapsed? gp-0 (seconds 0.03))
                       (set! gp-0 (current-time))
                       (process-drawable-shock-effect
                         *target*
                         (-> *lightning-spec-id-table* 1)
                         lightning-probe-callback
                         (-> *part-id-table* 160)
                         0
                         0
                         40960.0
                         )
                       )
                     )
                   )
                 (none)
                 )
               :to self
               )
             )
           )
         #t
         )
        (else
          (logior! (-> self focus-status) (focus-status ignore hit))
          (when (and (= (-> self game mode) 'play)
                     (and (or (and (>= 0.0 (- (-> self fact health) (-> self attack-info-rec damage)))
                                   (and (not (and (focus-test? self dark) (nonzero? (-> self darkjak))))
                                        (not (and (focus-test? self light) (nonzero? (-> self lightjak))))
                                        (not (and (focus-test? self flut) (= (-> self flut mode) 'normal)))
                                        )
                                   )
                              (attack-mode-is-invinc 'normal s4-0)
                              )
                          (= arg0 'attack)
                          )
                     )
            (logior! (-> self focus-status) (focus-status dead))
            (logior! (-> self target-flags) (target-flags disable-attacks))
            )
          (go arg4 arg0 (-> self attack-info-rec))
          )
        )
      )
    )
  )

;; definition for function target-got-impact-impulse
;; INFO: Used lq/sq
(defbehavior target-got-impact-impulse target ((arg0 rigid-body-impact))
  (when (< 20480.0 (-> arg0 impulse))
    (let ((v1-1 (new 'stack-no-clear 'vector)))
      (let ((f0-2 (fmin 81920.0 (* 0.333 (-> arg0 impulse)))))
        (vector-float*! v1-1 (-> arg0 normal) f0-2)
        (set! (-> v1-1 y) f0-2)
        )
      (send-event
        self
        'attack
        #f
        (static-attack-info
          :mask (vehicle-impulse-factor)
          ((id (new-attack-id)) (damage 2.0) (vehicle-damage-factor 1.0) (vehicle-impulse-factor 1.0) (vector v1-1))
          )
        )
      )
    (logior! (-> self control penetrated-by) (penetrate vehicle))
    #t
    )
  )

;; definition for function target-darkjak-effect-trans
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defbehavior target-darkjak-effect-trans target ((arg0 handle) (arg1 (pointer process-drawable)) (arg2 (pointer time-frame)) (arg3 time-frame))
  (local-vars (sv-112 vector) (sv-128 matrix))
  (let ((s2-0 sp-launch-particles-var)
        (s1-0 *sp-particle-system-2d*)
        (s0-0 (-> *part-id-table* 173))
        )
    (set! sv-128 *launch-matrix*)
    (set! sv-112 (-> sv-128 trans))
    (let ((v1-6 (-> (process-drawable-random-point! (ppointer->process arg1) (new 'stack-no-clear 'vector)) quad)))
      (set! (-> sv-112 quad) v1-6)
      )
    (let ((a3-1 #f)
          (t0-0 #f)
          (t1-0 1.0)
          )
      (s2-0 s1-0 s0-0 sv-128 (the-as sparticle-launch-state a3-1) (the-as sparticle-launch-control t0-0) t1-0)
      )
    )
  (send-event (ppointer->process arg1) 'color-effect 'dark (seconds 0.2))
  (when (time-elapsed? (-> arg2 0) (seconds 0.05))
    (set-time! (-> arg2 0))
    (cond
      ((and *target* (>= (-> *target* darkjak lightning-count) 10))
       )
      ((and (not (time-elapsed? arg3 (seconds 0.5))) (handle->process arg0))
       (if *target*
           (+! (-> *target* darkjak lightning-count) 2)
           )
       (process-drawable2-shock-effect
         (the-as process-drawable (handle->process arg0))
         (ppointer->process arg1)
         (-> *lightning-spec-id-table* 10)
         lightning-probe-callback
         (-> *part-id-table* 187)
         )
       )
      (else
        (if *target*
            (+! (-> *target* darkjak lightning-count) 2)
            )
        (send-event (handle->process arg0) 'color-effect 'shock (seconds 0.2))
        (process-drawable-shock-effect
          (ppointer->process arg1)
          (-> *lightning-spec-id-table* 10)
          lightning-probe-callback
          (-> *part-id-table* 187)
          0
          0
          40960.0
          )
        )
      )
    )
  (none)
  )

;; definition for function target-send-attack
;; INFO: Used lq/sq
;; WARN: Stack slot offset 96 signed mismatch
;; WARN: Stack slot offset 96 signed mismatch
;; WARN: Stack slot offset 96 signed mismatch
;; WARN: Stack slot offset 96 signed mismatch
;; WARN: Stack slot offset 96 signed mismatch
;; WARN: Stack slot offset 96 signed mismatch
;; WARN: Stack slot offset 96 signed mismatch
;; WARN: Stack slot offset 96 signed mismatch
;; WARN: Stack slot offset 96 signed mismatch
;; WARN: Stack slot offset 96 signed mismatch
;; WARN: Stack slot offset 96 signed mismatch
(defbehavior target-send-attack target ((arg0 process) (arg1 symbol) (arg2 touching-shapes-entry) (arg3 int) (arg4 int) (arg5 penetrate))
  (local-vars (sv-96 symbol) (sv-128 vector) (sv-132 touching-prims-entry) (sv-136 int) (sv-144 int))
  (set! sv-144 arg3)
  (let ((s1-0 arg4)
        (s0-0 arg5)
        )
    (if (and (= arg1 'bomb)
             (logtest? (process-mask guard) (-> arg0 mask))
             (not (-> *setting-control* user-current gun-target-guards?))
             )
        (return #f)
        )
    2.0
    0.0
    (let* ((f30-0 (penetrate-using->damage s0-0))
           (s2-0 arg0)
           (s5-0 (if (type? s2-0 process-focusable)
                     (the-as process-focusable s2-0)
                     )
                 )
           (s2-1 (and s5-0 (focus-test? s5-0 dead hit)))
           )
      (set! sv-96
            (the-as symbol (send-event
                             arg0
                             'attack
                             arg2
                             (static-attack-info :mask (vehicle-impulse-factor) ((id (the-as uint sv-144))
                                                                                 (damage f30-0)
                                                                                 (vehicle-damage-factor 1.0)
                                                                                 (vehicle-impulse-factor 1.0)
                                                                                 (mode arg1)
                                                                                 (count (the-as uint s1-0))
                                                                                 (penetrate-using s0-0)
                                                                                 )
                                                 )
                             )
                    )
            )
      (when sv-96
        (let ((v1-17 (new 'stack-no-clear 'vector)))
          (set! (-> v1-17 quad) (-> self control trans quad))
          (set! sv-128 v1-17)
          )
        (set! sv-132 (if arg2
                         (prims-touching? arg2 (-> self control) (the-as uint 256))
                         )
              )
        (set! sv-136 -1)
        (cond
          ((not arg2)
           )
          (sv-132
            (set! sv-136 1)
            (get-intersect-point sv-128 sv-132 (-> self control) arg2)
            )
          ((let ((v0-6 (prims-touching? arg2 (-> self control) (the-as uint 128))))
             (set! sv-132 v0-6)
             v0-6
             )
           (set! sv-136 0)
           (get-intersect-point sv-128 sv-132 (-> self control) arg2)
           )
          )
        (set! (-> self control send-attack-dest) (process->handle arg0))
        (set-time! (-> self control send-attack-time))
        (send-event self 'hit arg1 arg0 arg2 sv-128)
        (set! arg0 (and (and (focus-test? self dark)
                             (nonzero? (-> self darkjak))
                             (logtest? (-> self darkjak stage) (darkjak-stage active))
                             )
                        arg0
                        )
              )
        (when arg0
          (when (and s5-0 (not s2-1) (-> self control danger-mode) (not (logtest? (-> s5-0 mask) (process-mask dark-effect))))
            (logior! (-> s5-0 mask) (process-mask dark-effect))
            (process-spawn-function
              process
              (lambda :behavior target
                ((arg0 handle))
                (local-vars (sv-16 int))
                (let ((gp-0 (-> self parent)))
                  (let ((s4-0 (current-time)))
                    (set! sv-16 0)
                    (+! (-> self clock ref-count) -1)
                    (+! (-> gp-0 0 clock ref-count) 1)
                    (set! (-> self clock) (-> gp-0 0 clock))
                    (while (let ((v1-10 gp-0))
                             (and (or (focus-test?
                                        (the-as process-focusable (if v1-10
                                                                      (the-as process-focusable (-> v1-10 0 self))
                                                                      )
                                                )
                                        dead
                                        hit
                                        )
                                      (let ((v1-15 gp-0))
                                        (and (-> (the-as process (if v1-15
                                                                     (the-as process (-> v1-15 0 self))
                                                                     )
                                                         )
                                                 next-state
                                                 )
                                             (let ((v1-18 gp-0))
                                               (= (-> (the-as process (if v1-18
                                                                          (the-as process (-> v1-18 0 self))
                                                                          )
                                                              )
                                                      next-state
                                                      name
                                                      )
                                                  'knocked
                                                  )
                                               )
                                             )
                                        )
                                      )
                                  (not (time-elapsed? s4-0 (seconds 15)))
                                  (not (logtest? (-> (the-as process-focusable (-> gp-0 0)) draw status) (draw-control-status no-draw no-draw-temp))
                                       )
                                  )
                             )
                      (target-darkjak-effect-trans
                        arg0
                        (the-as (pointer process-drawable) gp-0)
                        (the-as (pointer time-frame) (& sv-16))
                        s4-0
                        )
                      (suspend)
                      )
                    )
                  (logclear! (-> gp-0 0 mask) (process-mask dark-effect))
                  (send-event (ppointer->process gp-0) 'color-effect #f 0)
                  )
                (none)
                )
              (process->handle self)
              :to s5-0
              )
            )
          )
        (let ((v1-57 arg1))
          (cond
            ((or (= v1-57 'spin) (= v1-57 'spin-air) (= v1-57 'board-spin) (= v1-57 'board-zap))
             (case sv-136
               ((1)
                (cond
                  ((logtest? (-> *part-group-id-table* 11 flags) (sp-group-flag sp13))
                   (set! (-> *launch-matrix* trans quad) (-> sv-128 quad))
                   (part-tracker-spawn part-tracker-subsampler :to self :group (-> *part-group-id-table* 11))
                   )
                  (else
                    (set! (-> *launch-matrix* trans quad) (-> sv-128 quad))
                    (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 11))
                    )
                  )
                )
               (else
                 (do-effect (-> self skel effect) "group-spin-hit" -1.0 49)
                 )
               )
             (play-effect-sound
               (-> self skel effect)
               (the-as symbol "sound")
               -1.0
               49
               (the-as basic #f)
               (cond
                 ((= arg1 'board-spin)
                  (static-sound-name "board-impact")
                  )
                 ((= arg1 'board-zap)
                  (static-sound-name "board-zap-hit")
                  )
                 ((using-gun? self)
                  (static-sound-name "gun-spin-hit")
                  )
                 (else
                   (static-sound-name "spin-hit")
                   )
                 )
               )
             (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 127 (seconds 0.2))
             )
            ((or (= v1-57 'get-on) (= v1-57 'darkjak))
             (let ((v1-105 sv-136))
               (when (or (zero? v1-105) (= v1-105 1))
                 (cond
                   ((logtest? (-> *part-group-id-table* 12 flags) (sp-group-flag sp13))
                    (set! (-> *launch-matrix* trans quad) (-> sv-128 quad))
                    (part-tracker-spawn part-tracker-subsampler :to self :group (-> *part-group-id-table* 12))
                    )
                   (else
                     (set! (-> *launch-matrix* trans quad) (-> sv-128 quad))
                     (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 12))
                     )
                   )
                 )
               )
             (play-effect-sound
               (-> self skel effect)
               (the-as symbol "sound")
               -1.0
               3
               (the-as basic #f)
               (static-sound-name "get-on-hit")
               )
             )
            ((= v1-57 'shield)
             (play-effect-sound
               (-> self skel effect)
               (the-as symbol "sound")
               -1.0
               3
               (the-as basic #f)
               (static-sound-name "shield-attack")
               )
             )
            ((or (= v1-57 'punch) (= v1-57 'dark-smack) (= v1-57 'mech-punch))
             (let ((v1-147 sv-136))
               (when (or (zero? v1-147) (= v1-147 1))
                 (cond
                   ((logtest? (-> *part-group-id-table* 12 flags) (sp-group-flag sp13))
                    (set! (-> *launch-matrix* trans quad) (-> sv-128 quad))
                    (part-tracker-spawn part-tracker-subsampler :to self :group (-> *part-group-id-table* 12))
                    )
                   (else
                     (set! (-> *launch-matrix* trans quad) (-> sv-128 quad))
                     (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 12))
                     )
                   )
                 )
               )
             (cond
               ((= arg1 'mech-punch)
                (play-effect-sound
                  (-> self skel effect)
                  (the-as symbol "sound")
                  -1.0
                  28
                  (the-as basic #f)
                  (static-sound-name "mech-punch-hit")
                  )
                )
               (else
                 (let ((name (if (using-gun? self)
                                 (the-as sound-name (static-sound-name "gun-punch-hit"))
                                 (the-as sound-name (static-sound-name "punch-hit"))
                                 )
                             )
                       )
                   (play-effect-sound
                     (-> self skel effect)
                     (the-as symbol "sound")
                     -1.0
                     28
                     (the-as basic #f)
                     (the-as sound-name name)
                     )
                   )
                 )
               )
             (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 178 (seconds 0.1))
             )
            ((= v1-57 'flip)
             (play-effect-sound
               (-> self skel effect)
               (the-as symbol "sound")
               -1.0
               49
               (the-as basic #f)
               (static-sound-name "punch-hit")
               )
             (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 127 (seconds 0.1))
             )
            ((= v1-57 'uppercut)
             (let ((v1-199 sv-136))
               (when (or (zero? v1-199) (= v1-199 1))
                 (cond
                   ((logtest? (-> *part-group-id-table* 12 flags) (sp-group-flag sp13))
                    (set! (-> *launch-matrix* trans quad) (-> sv-128 quad))
                    (part-tracker-spawn part-tracker-subsampler :to self :group (-> *part-group-id-table* 12))
                    )
                   (else
                     (set! (-> *launch-matrix* trans quad) (-> sv-128 quad))
                     (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 12))
                     )
                   )
                 )
               )
             (do-effect (-> self skel effect) "group-uppercut-hit" -1.0 28)
             (play-effect-sound
               (-> self skel effect)
               (the-as symbol "sound")
               -1.0
               28
               (the-as basic #f)
               (static-sound-name "uppercut-hit")
               )
             (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 178 (seconds 0.1))
             )
            ((or (= v1-57 'flop) (= v1-57 'flop-down))
             (do-effect (-> self skel effect) "group-flop-hit" -1.0 28)
             (do-effect (-> self skel effect) "group-flop-hit" -1.0 19)
             (play-effect-sound
               (-> self skel effect)
               (the-as symbol "sound")
               -1.0
               28
               (the-as basic #f)
               (static-sound-name "flop-hit")
               )
             (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 178 (seconds 0.1))
             )
            ((= v1-57 'flut-attack)
             (play-effect-sound
               (-> self skel effect)
               (the-as symbol "sound")
               -1.0
               28
               (the-as basic #f)
               (static-sound-name "flut-punch-hit")
               )
             (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.2))
             )
            ((= v1-57 'darkjak)
             (set-time! (-> self darkjak attack-time))
             (let* ((v1-256 *game-info*)
                    (a0-141 (+ (-> v1-256 attack-id) 1))
                    )
               (set! (-> v1-256 attack-id) a0-141)
               (set! (-> self darkjak attack-id) a0-141)
               a0-141
               )
             )
            ((= v1-57 'lightjak)
             (set-time! (-> self darkjak attack-time))
             (let* ((v1-260 *game-info*)
                    (a0-145 (+ (-> v1-260 attack-id) 1))
                    )
               (set! (-> v1-260 attack-id) a0-145)
               (set! (-> self darkjak attack-id) a0-145)
               a0-145
               )
             )
            )
          )
        )
      )
    )
  sv-96
  )

;; definition for function target-generic-event-handler
;; INFO: Used lq/sq
(defbehavior target-generic-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (v0-0 object) (a0-35 level-load-info) (a1-13 level-load-info))
  (case arg2
    (('get-pickup)
     (when (not (focus-test? self dead))
       (let ((s4-1 (-> arg3 param 0))
             (f28-0 (the-as float (-> arg3 param 1)))
             )
         (if (!= (pickup-collectable! (-> self fact) (the-as pickup-type s4-1) 0.0 (the-as handle #f))
                 (pickup-collectable! (-> self fact) (the-as pickup-type s4-1) f28-0 (process->handle arg0))
                 )
             #t
             'full
             )
         )
       )
     )
    (('test-pickup)
     (let ((a1-6 (-> arg3 param 0)))
       (pickup-collectable! (-> self fact) (the-as pickup-type a1-6) 0.0 (the-as handle #f))
       )
     )
    (('reset-pickup)
     (reset! (-> self fact) (the-as symbol (-> arg3 param 0)))
     )
    (('reset-collide)
     (cond
       ((-> self control collide-mode)
        (target-collide-set! (-> self control collide-mode) (-> self control collide-mode-transition))
        )
       ((-> self control danger-mode)
        (target-danger-set! (-> self control danger-mode) #f)
        )
       )
     )
    (('level-deactivate)
     (cond
       ((and (focus-test? self pilot) (let ((a0-19 (lookup-level-info (the-as symbol (-> arg3 param 0)))))
                                        (or (and a0-19 (logtest? (-> a0-19 level-flags) (level-flags end-mode)))
                                            (and (= (-> arg3 param 0) 'lctypatk) (-> self pilot as-daxter?))
                                            (= (-> arg3 param 0) 'desliz)
                                            )
                                        )
             )
        (ja-channel-set! 0)
        (target-gun-end-mode #t)
        (set! (-> self skel top-anim interp) 0.0)
        (let ((v1-34 (get-channel (-> self skel top-anim) 0)))
          (if v1-34
              (set! (-> v1-34 frame-interp 1) 0.0)
              )
          )
        (update (-> self skel top-anim))
        (cond
          ((focus-test? self teleporting)
           #f
           )
          ((focus-test? self grabbed)
           (set! (-> self event-hook) #f)
           (go target-grab 'stance)
           )
          (else
            (set! (-> self event-hook) #f)
            (go target-jump (-> *TARGET-bank* jump-height-min) (-> *TARGET-bank* jump-height-max) (the-as surface #f))
            )
          )
        )
       ((and (focus-test? self flut)
             (begin (set! a0-35 (lookup-level-info (the-as symbol (-> arg3 param 0)))) a0-35)
             (logtest? (-> a0-35 level-flags) (level-flags flut))
             )
        (ja-channel-set! 0)
        (target-gun-end-mode #t)
        (when (not (focus-test? self grabbed teleporting))
          (set! (-> self event-hook) #f)
          (go target-jump (-> *TARGET-bank* jump-height-min) (-> *TARGET-bank* jump-height-max) (the-as surface #f))
          )
        )
       ((and (focus-test? self mech)
             (begin (set! a1-13 (lookup-level-info (the-as symbol (-> arg3 param 0)))) a1-13)
             (logtest? (level-flags mech) (-> a1-13 level-flags))
             )
        (ja-channel-set! 0)
        (when (not (focus-test? self grabbed teleporting))
          (set! (-> self event-hook) #f)
          (go target-jump (-> *TARGET-bank* jump-height-min) (-> *TARGET-bank* jump-height-max) (the-as surface #f))
          )
        )
       )
     )
    (('level-enter)
     (let ((s5-1 (level-get *level* (the-as symbol (-> arg3 param 0)))))
       (when s5-1
         (let ((v1-66 (-> s5-1 info)))
           (set! (-> self fact buzzer) 0.0)
           (if (zero? (-> self game task-enter-times (-> v1-66 task-level)))
               (set! (-> self game task-enter-times (-> v1-66 task-level)) (-> *display* game-clock frame-counter))
               )
           )
         (let ((s4-2 (-> *game-info* sub-task-list)))
           (dotimes (s3-1 (-> s4-2 length))
             (when (nonzero? s3-1)
               (let ((s2-0 (-> s4-2 s3-1)))
                 (when (and (= (-> s5-1 info taskname) (-> s2-0 level))
                            (zero? (-> self game task-start-time (-> s2-0 task)))
                            (= s3-1 (-> *game-info* play-list (-> s2-0 task) play-node))
                            (or (logtest? (-> s2-0 flags) (game-task-node-flag closed)) (game-task-node-info-method-12 s2-0))
                            (not (task-complete? (-> self game) (-> s2-0 task)))
                            (not (logtest? (-> s2-0 flags) (game-task-node-flag utility-node)))
                            )
                   (when (zero? (-> self game task-start-time (-> s2-0 task)))
                     (format #t "--------------> set task start time for ~A~%" (-> s2-0 name))
                     (set! (-> self game task-start-time (-> s2-0 task)) (-> *display* game-clock frame-counter))
                     )
                   )
                 )
               )
             )
           )
         (update-task-masks 'level)
         (format #t "GAMEPLAY: enter ~A~%" (-> arg3 param 0))
         )
       )
     )
    (('get-attack-count)
     (set! v0-0 (+ (-> self control attack-count) (-> arg3 param 0)))
     (set! (-> self control attack-count) (the-as uint v0-0))
     v0-0
     )
    (('continue)
     (when (not (focus-test? self dead))
       (logior! (-> self focus-status) (focus-status teleporting))
       (go target-continue (the-as continue-point (-> arg3 param 0)))
       )
     )
    (('query)
     (case (-> arg3 param 0)
       (('powerup)
        (and (= (-> self fact eco-type) (-> arg3 param 1)) (< 0.0 (-> self fact eco-level)))
        )
       (('pickup)
        (pickup-collectable! (-> self fact) (the-as pickup-type (-> arg3 param 1)) 0.0 (the-as handle #f))
        )
       (('ground-height)
        (target-height-above-ground)
        )
       (('gun-type)
        (-> self gun gun-type)
        )
       )
     )
    (('release)
     (when (and (nonzero? (-> self gun)) (handle->process (-> self gun charge-active?)))
       (set! (-> self gun charge-active?) (the-as handle #f))
       (set! v0-0 (current-time))
       (set! (-> self gun fire-time) (the-as time-frame v0-0))
       v0-0
       )
     )
    (('trans)
     (case (-> arg3 param 0)
       (('save)
        (set! (-> self alt-cam-pos quad) (-> self control trans quad))
        (logior! (-> self target-flags) (target-flags tf12))
        (mem-copy! (the-as pointer (-> arg3 param 1)) (the-as pointer (-> self control trans)) 48)
        )
       (('restore)
        (logclear! (-> self target-flags) (target-flags tf12))
        (let ((gp-1 (-> arg3 param 1)))
          (move-to-point! (-> self control) (the-as vector (+ gp-1 0)))
          (quaternion-copy! (-> self control quat) (the-as quaternion (+ gp-1 16)))
          )
        (rot->dir-targ! (-> self control))
        (logior! (-> self control status) (collide-status on-surface on-ground touch-surface))
        (set! v0-0 (current-time))
        (set! (-> self control last-time-on-surface) (the-as time-frame v0-0))
        v0-0
        )
       (('reset)
        (set! v0-0 (logclear (-> self target-flags) (target-flags tf12)))
        (set! (-> self target-flags) (the-as target-flags v0-0))
        v0-0
        )
       )
     )
    (('effect)
     (target-powerup-effect (the-as symbol (-> arg3 param 0)))
     )
    (('color-effect)
     (set! (-> self color-effect) (the-as symbol (-> arg3 param 0)))
     (set-time! (-> self color-effect-start-time))
     (set! v0-0 (-> arg3 param 1))
     (set! (-> self color-effect-duration) (the-as time-frame v0-0))
     v0-0
     )
    (('do-effect)
     (do-effect (-> self skel effect) (the-as string (-> arg3 param 0)) (the-as float (-> arg3 param 1)) -1)
     (if (-> self sidekick)
         (do-effect
           (-> self sidekick 0 skel effect)
           (the-as string (-> arg3 param 0))
           (the-as float (-> arg3 param 1))
           -1
           )
         )
     )
    (('effect-control)
     #f
     )
    (('neck)
     (set! (-> self neck flex-blend) (the-as float (-> arg3 param 0)))
     (cond
       ((-> arg3 param 1)
        (logior! (-> self target-flags) (target-flags tf13))
        (set! (-> self alt-neck-pos quad) (-> (the-as vector (-> arg3 param 1)) quad))
        (look-at! (-> self neck) (-> self alt-neck-pos) 'force arg0)
        )
       (else
         (set! v0-0 (logclear (-> self target-flags) (target-flags tf13)))
         (set! (-> self target-flags) (the-as target-flags v0-0))
         v0-0
         )
       )
     )
    (('sidekick)
     (cond
       ((and (-> arg3 param 0) (not (-> self sidekick)))
        (let ((gp-2 (get-process *default-dead-pool* sidekick #x4000 1)))
          (set! v0-0 (when gp-2
                       (let ((t9-38 (method-of-type sidekick activate)))
                         (t9-38 (the-as sidekick gp-2) self "sidekick" (the-as pointer #x70004000))
                         )
                       (run-now-in-process gp-2 init-sidekick)
                       (-> gp-2 ppointer)
                       )
                )
          )
        (set! (-> self sidekick) (the-as (pointer sidekick) v0-0))
        v0-0
        )
       ((and (not (-> arg3 param 0)) (-> self sidekick))
        (deactivate (-> self sidekick 0))
        (set! (-> self sidekick) (the-as (pointer sidekick) #f))
        #f
        )
       )
     )
    (('manipy)
     (let ((v1-176 (get-continue-by-name (-> self game) (the-as string (-> arg3 param 1)))))
       (when (and v1-176 (not (-> self manipy)))
         (let ((t9-42 external-target-spawn)
               (a0-150 (-> v1-176 trans))
               (a1-38 (new 'stack-no-clear 'quaternion))
               )
           (set! (-> a1-38 x) (* 0.00003051851 (the float (-> v1-176 quat x))))
           (set! (-> a1-38 y) (* 0.00003051851 (the float (-> v1-176 quat y))))
           (set! (-> a1-38 z) (* 0.00003051851 (the float (-> v1-176 quat z))))
           (set! (-> a1-38 w) (* 0.00003051851 (the float (-> v1-176 quat w))))
           (let ((a2-23 self)
                 (a3-10 (-> arg3 param 2))
                 (v1-178 (-> arg3 param 0))
                 )
             (set! v0-0 (t9-42 a0-150 a1-38 a2-23 (the-as symbol a3-10) (cond
                                                                          ((= v1-178 'manual)
                                                                           (manipy-options mo0)
                                                                           )
                                                                          ((= v1-178 'auto)
                                                                           (manipy-options mo1)
                                                                           )
                                                                          (else
                                                                            (manipy-options)
                                                                            )
                                                                          )
                               )
                   )
             )
           )
         (set! (-> self manipy) (the-as (pointer manipy) v0-0))
         v0-0
         )
       )
     )
    (('blend-shape)
     (if (-> arg3 param 0)
         (logior! (-> self skel status) (joint-control-status blend-shape))
         (logclear! (-> self skel status) (joint-control-status blend-shape))
         )
     (let ((a1-39 (new 'stack-no-clear 'event-message-block)))
       (set! (-> a1-39 from) (process->ppointer arg0))
       (set! (-> a1-39 num-params) arg1)
       (set! (-> a1-39 message) arg2)
       (set! (-> a1-39 param 0) (-> arg3 param 0))
       (set! (-> a1-39 param 1) (-> arg3 param 1))
       (set! (-> a1-39 param 2) (-> arg3 param 2))
       (set! (-> a1-39 param 3) (-> arg3 param 3))
       (set! (-> a1-39 param 4) (-> arg3 param 4))
       (set! (-> a1-39 param 5) (-> arg3 param 5))
       (send-event-function (ppointer->process (-> self sidekick)) a1-39)
       )
     )
    (('shadow)
     (cond
       ((-> arg3 param 0)
        (let ((v1-196 (-> self draw shadow-ctrl)))
          (logclear! (-> v1-196 settings flags) (shadow-flags disable-draw))
          )
        0
        )
       (else
         (let ((v1-198 (-> self draw shadow-ctrl)))
           (logior! (-> v1-198 settings flags) (shadow-flags disable-draw))
           )
         0
         )
       )
     )
    (('rotate-y-angle)
     (quaternion-rotate-y!
       (-> self control quat-for-control)
       (-> self control quat-for-control)
       (the-as float (-> arg3 param 0))
       )
     (if (= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
         (rot->dir-targ! (-> self control))
         )
     )
    (('touched)
     (cond
       ((< 0.0 (-> self fact shield-level))
        (let ((s4-3 (-> self control penetrate-using)))
          (set! (-> self control penetrate-using) (penetrate touch shield))
          (set! v0-0 (target-send-attack
                       arg0
                       'shield
                       (the-as touching-shapes-entry (-> arg3 param 0))
                       (the-as int (-> self fact shield-attack-id))
                       0
                       (-> self control penetrate-using)
                       )
                )
          (set! (-> self control penetrate-using) s4-3)
          )
        v0-0
        )
       ((and (and (focus-test? self dark) (nonzero? (-> self darkjak)))
             (or (and (focus-test? self dark)
                      (nonzero? (-> self darkjak))
                      (logtest? (-> self darkjak stage) (darkjak-stage invinc))
                      )
                 (logtest? (process-mask crate) (-> arg0 mask))
                 )
             )
        (target-send-attack
          arg0
          'darkjak
          (the-as touching-shapes-entry (-> arg3 param 0))
          (the-as int (-> self darkjak attack-id))
          0
          (penetrate touch dark-skin)
          )
        )
       (else
         (send-event arg0 'touch (-> arg3 param 0))
         )
       )
     )
    (('dry)
     (set! (-> self water drip-wetness) 0.0)
     )
    (('reset-height)
     (set! (-> self control last-trans-any-surf quad) (-> self control trans quad))
     #f
     )
    (('draw)
     (cond
       ((-> arg3 param 0)
        (when (logtest? (-> self draw status) (draw-control-status no-draw))
          (logclear! (-> self draw status) (draw-control-status no-draw))
          (process-drawable-reset-all-cloth self)
          )
        )
       (else
         (logior! (-> self draw status) (draw-control-status no-draw))
         )
       )
     (let ((a1-46 (new 'stack-no-clear 'event-message-block)))
       (set! (-> a1-46 from) (process->ppointer arg0))
       (set! (-> a1-46 num-params) arg1)
       (set! (-> a1-46 message) arg2)
       (set! (-> a1-46 param 0) (-> arg3 param 0))
       (set! (-> a1-46 param 1) (-> arg3 param 1))
       (set! (-> a1-46 param 2) (-> arg3 param 2))
       (set! (-> a1-46 param 3) (-> arg3 param 3))
       (set! (-> a1-46 param 4) (-> arg3 param 4))
       (set! (-> a1-46 param 5) (-> arg3 param 5))
       (send-event-function (ppointer->process (-> self manipy)) a1-46)
       )
     )
    (('draw-vehicle)
     (when (nonzero? (-> self pilot))
       (if (-> arg3 param 0)
           (send-event (handle->process (-> self pilot vehicle)) 'unhide)
           (send-event (handle->process (-> self pilot vehicle)) 'hide)
           )
       )
     )
    (('no-load-wait)
     (set! v0-0 (+ (current-time) (the-as time-frame (-> arg3 param 0))))
     (set! (-> self no-load-wait) (the-as time-frame v0-0))
     v0-0
     )
    (('no-look-around)
     (set! (-> self no-look-around-wait) (+ (current-time) (the-as time-frame (-> arg3 param 0))))
     (if (and (-> self next-state) (= (-> self next-state name) 'target-look-around))
         (send-event self 'end-mode 'in-head)
         )
     )
    (('change-state)
     (go
       (the-as (state object object object object target) (-> arg3 param 0))
       (-> arg3 param 1)
       (-> arg3 param 2)
       (-> arg3 param 3)
       (-> arg3 param 4)
       )
     )
    (('tobot)
     (set! v0-0 (-> arg3 param 0))
     (set! (-> self tobot?) (the-as symbol v0-0))
     v0-0
     )
    (('carry-info)
     (-> self carry)
     )
    (('gun-type)
     (cond
       ((-> arg3 param 0)
        (target-gun-type-set! (the-as pickup-type (-> arg3 param 0)))
        )
       (else
         (set! v0-0 #t)
         (set! (-> self gun put-away?) (the-as symbol v0-0))
         v0-0
         )
       )
     )
    (('kill-vehicle)
     (if (nonzero? (-> self pilot))
         (send-event (handle->process (-> self pilot vehicle)) 'go-die)
         )
     )
    (('get-notify)
     (set! v0-0 (process->handle (the-as process (-> arg3 param 0))))
     (set! (-> self notify) (the-as handle v0-0))
     v0-0
     )
    (('invulnerable)
     (target-timed-invulnerable (the-as time-frame (-> arg3 param 0)) self 2)
     #t
     )
    )
  )

;; definition for function target-standard-event-handler
;; INFO: Used lq/sq
(defbehavior target-standard-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (at-0 int) (v1-317 object))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((v1-0 arg2))
      (b! (not (or (= v1-0 'attack) (= v1-0 'attack-or-shove) (= v1-0 'attack-invinc))) cfg-7 :delay (nop!))
      (let ((v0-0
              (target-attacked
                arg2
                (the-as attack-info (-> arg3 param 1))
                arg0
                (the-as touching-shapes-entry (-> arg3 param 0))
                target-hit
                )
              )
            )
        (b! #t cfg-435 :delay (nop!))
        (label cfg-7)
        (b! (!= v1-0 'shove) cfg-21 :delay (nop!))
        (set! v0-0 (when (not (and (-> self next-state) (= (-> self next-state name) 'target-hit)))
                     (mem-copy! (the-as pointer (-> self attack-info-rec)) (the-as pointer (-> arg3 param 1)) 168)
                     (when (not (logtest? (-> self attack-info-rec mask) (attack-mask attacker)))
                       (set! (-> self attack-info-rec attacker) (process->handle arg0))
                       (logior! (-> self attack-info-rec mask) (attack-mask attacker))
                       )
                     (go target-hit 'shove (-> self attack-info-rec))
                     )
              )
        (b! #t cfg-435 :delay (nop!))
        (label cfg-21)
        (set! v0-0
              (cond
                ((= v1-0 'push-trans)
                 (let ((v1-15 (-> self control additional-decaying-velocity)))
                   (.lvf vf1 (&-> (the-as vector (-> arg3 param 0)) quad))
                   (let ((f0-0 (-> self clock frames-per-second)))
                     (.mov at-0 f0-0)
                     )
                   (.mov vf2 at-0)
                   (.mov.vf vf1 vf0 :mask #b1000)
                   (.mul.x.vf vf1 vf1 vf2 :mask #b111)
                   (.svf (&-> v1-15 quad) vf1)
                   )
                 (set-time! (-> self control additional-decaying-velocity-end-time))
                 (set! (-> self control additional-decaying-velocity-decay-start-time)
                       (+ (current-time) (the-as time-frame (-> arg3 param 1)))
                       )
                 #t
                 )
                ((= v1-0 'push-transv)
                 (set! (-> self control additional-decaying-velocity quad) (-> (the-as vector (-> arg3 param 0)) quad))
                 (set-time! (-> self control additional-decaying-velocity-end-time))
                 (set! (-> self control additional-decaying-velocity-decay-start-time)
                       (+ (current-time) (the-as time-frame (-> arg3 param 1)))
                       )
                 #t
                 )
                ((= v1-0 'launch)
                 (set! (-> self control transv quad) (-> (the-as vector (-> arg3 param 3)) quad))
                 (go
                   target-jump
                   (the-as float (-> arg3 param 0))
                   (the-as float (-> arg3 param 1))
                   (the-as surface (-> arg3 param 2))
                   )
                 )
                ((= v1-0 'launch-dir)
                 (when (not (focus-test? self board))
                   (set! (-> self control unknown-vector37 quad) (-> (the-as vector (-> arg3 param 0)) quad))
                   (set! (-> self control sliding-start-time) (the-as time-frame (-> arg3 param 1)))
                   (set! (-> self control unknown-word04) (the-as uint (the-as float (-> arg3 param 2))))
                   (go target-launch-dir)
                   )
                 )
                ((= v1-0 'powerup)
                 (if (and (and (-> self next-state)
                               (let ((v1-42 (-> self next-state name)))
                                 (or (= v1-42 'target-stance) (= v1-42 'target-walk) (= v1-42 'target-stance-look-around))
                                 )
                               )
                          (zero? (-> self ext-anim))
                          )
                     (go target-eco-powerup (the-as int (-> arg3 param 0)) (the-as float (-> arg3 param 1)))
                     )
                 )
                ((= v1-0 'loading)
                 (if (not (or (and (logtest? (-> self control mod-surface flags) (surface-flag air))
                                   (not (logtest? (-> self control status) (collide-status on-surface)))
                                   )
                              (or (logtest? (water-flag touch-water) (-> self water flags))
                                  (logtest? (-> self control status) (collide-status on-water))
                                  )
                              (or (logtest? (-> self target-flags) (target-flags tf1))
                                  (focus-test? self dead dangerous hit grabbed in-head edge-grab pole flut tube board pilot mech)
                                  (>= (-> self no-load-wait) (current-time))
                                  )
                              )
                          )
                     (go target-load-wait)
                     )
                 )
                ((begin
                   (b! (!= v1-0 'gun-combo) cfg-66 :delay (nop!))
                   (set! v0-0 #t)
                   (b! #t cfg-435 :delay (nop!))
                   (label cfg-66)
                   (b! (!= v1-0 'change-mode) cfg-283 :delay (nop!))
                   (let ((v1-63 (-> arg3 param 0)))
                     (b! (!= v1-63 'grab) cfg-73 :delay (empty-form))
                     (set! v0-0 (when (not (focus-test? self dead))
                                  (if (not (-> arg3 param 1))
                                      #t
                                      (go target-grab 'stance)
                                      )
                                  )
                           )
                     (b! #t cfg-282 :delay (nop!))
                     (label cfg-73)
                     (b! (!= v1-63 'grab-ride) cfg-84 :delay (empty-form))
                     (set! v0-0 (when (not (focus-test? self dead))
                                  (if (not (-> arg3 param 1))
                                      #t
                                      (go target-grab-ride (process->handle arg0))
                                      )
                                  )
                           )
                     (b! #t cfg-282 :delay (nop!))
                     (label cfg-84)
                     (b! (!= v1-63 'look-around) cfg-86 :delay (empty-form))
                     (set! v0-0 (go target-look-around))
                     (b! #t cfg-282 :delay (nop!))
                     (label cfg-86)
                     (b! (!= v1-63 'falling) cfg-88 :delay (empty-form))
                     (set! v0-0 (go target-falling #f))
                     (b! #t cfg-282 :delay (nop!))
                     (label cfg-88)
                     (b! (!= v1-63 'racer) cfg-97 :delay (empty-form))
                     (if *debug-segment*
                         (load-package "racerp" global)
                         )
                     (set! v0-0 (go target-racing-start (process->handle (the-as process (-> arg3 param 1)))))
                     (b! #t cfg-282 :delay (nop!))
                     (label cfg-97)
                     (b! (!= v1-63 'flut) cfg-110 :delay (empty-form))
                     (set! v0-0 (go
                                  target-flut-start
                                  (process->handle (the-as process (-> arg3 param 1)))
                                  (the-as symbol (if (>= arg1 3)
                                                     (-> arg3 param 2)
                                                     'normal
                                                     )
                                          )
                                  (if (>= arg1 4)
                                      (the-as int (-> arg3 param 3))
                                      -1
                                      )
                                  )
                           )
                     (b! #t cfg-282 :delay (nop!))
                     (label cfg-110)
                     (set! v0-0
                           (cond
                             ((= v1-63 'board)
                              (if (logtest? (logand (game-feature board) (-> *setting-control* user-current features)) (-> self game features))
                                  (go target-board-start (process->handle (the-as process (-> arg3 param 1))))
                                  )
                              )
                             ((or (= v1-63 'pilot) (= v1-63 'pilot-race) (= v1-63 'pilot-daxter) (= v1-63 'pilot-race-daxter))
                              (let ((s5-1 (the-as object (-> arg3 param 1))))
                                (when (not (the-as uint s5-1))
                                  (let ((s4-0 (new 'stack 'traffic-object-spawn-params)))
                                    (set! (-> s4-0 object-type) (traffic-type guard-a))
                                    (set! (-> s4-0 behavior) (the-as uint 4))
                                    (set! (-> s4-0 id) (the-as uint 0))
                                    (set! (-> s4-0 nav-mesh) #f)
                                    (set! (-> s4-0 nav-branch) #f)
                                    (set! (-> s4-0 proc) #f)
                                    (set! (-> s4-0 handle) (the-as handle #f))
                                    (set! (-> s4-0 user-data) (the-as uint 0))
                                    (set! (-> s4-0 flags) (traffic-spawn-flags tsf5 tsf6))
                                    (set! (-> s4-0 guard-type) (the-as uint 11))
                                    (set! (-> s4-0 entity) #f)
                                    (vector-reset! (-> s4-0 velocity))
                                    (set! (-> s4-0 position quad) (-> self control trans quad))
                                    (quaternion-copy! (-> s4-0 rotation) (-> self control quat))
                                    (set! (-> s4-0 id) (the-as uint 0))
                                    (let ((v1-101 (vehicle-spawn (the-as vehicle-type (-> arg3 param 2)) s4-0)))
                                      (if v1-101
                                          (set! s5-1 v1-101)
                                          )
                                      )
                                    )
                                  )
                                (when s5-1
                                  (let* ((v1-102 (-> arg3 param 0))
                                         (a2-8 (if (or (= v1-102 'pilot-daxter) (= v1-102 'pilot-race-daxter))
                                                   #t
                                                   #f
                                                   )
                                               )
                                         )
                                    (go target-pilot-start (process->handle s5-1) (the-as symbol (-> arg3 param 3)) a2-8)
                                    )
                                  )
                                )
                              )
                             ((= v1-63 'mech)
                              (go
                                target-mech-start
                                (process->handle (the-as process (-> arg3 param 1)))
                                (the-as float (if (>= arg1 2)
                                                  (the-as int (-> arg3 param 2))
                                                  #x42c80000
                                                  )
                                        )
                                #f
                                )
                              )
                             ((= v1-63 'indax)
                              (go target-indax-start (process->handle (the-as process (-> arg3 param 1))) (-> arg3 param 2))
                              )
                             ((= v1-63 'gun)
                              (when (logtest? (-> self game features) (game-feature gun))
                                (let ((gp-1 (-> arg3 param 2)))
                                  (cond
                                    ((using-gun? self)
                                     (when (nonzero? gp-1)
                                       (set! (-> self gun using-gun-type) (the-as pickup-type gp-1))
                                       gp-1
                                       )
                                     )
                                    (else
                                      (target-gun-init (the-as pickup-type gp-1))
                                      )
                                    )
                                  )
                                )
                              )
                             ((= v1-63 'tube)
                              (if (and (logtest? (-> self control status) (collide-status on-surface))
                                       (not (or (logtest? (water-flag touch-water) (-> self water flags))
                                                (logtest? (-> self control status) (collide-status on-water))
                                                )
                                            )
                                       )
                                  (go target-tube-start (process->handle (the-as process (-> arg3 param 1))))
                                  )
                              )
                             ((= v1-63 'turret)
                              (if (logtest? (-> self control status) (collide-status on-surface))
                                  (go target-turret-get-on (process->handle (the-as process (-> arg3 param 1))))
                                  )
                              )
                             ((= v1-63 'darkjak)
                              (cond
                                ((focus-test? self dead)
                                 #f
                                 )
                                ((and (not (and (focus-test? self dark) (nonzero? (-> self darkjak))))
                                      (and (logtest? (the-as game-feature (logand (game-feature darkjak) (-> *setting-control* user-current features)))
                                                     (-> self game features)
                                                     )
                                           (-> *setting-control* user-current darkjak)
                                           )
                                      )
                                 (go target-darkjak-get-on (the-as darkjak-stage (-> arg3 param 2)))
                                 )
                                ((logtest? (-> arg3 param 2) 1024)
                                 (logclear! (-> self darkjak stage) (darkjak-stage force-on))
                                 (set! v0-0 (+ (- (seconds 20) (-> self fact darkjak-start-time)) (current-time)))
                                 (set! (-> self fact darkjak-effect-time) (the-as time-frame v0-0))
                                 v0-0
                                 )
                                )
                              )
                             ((= v1-63 'lightjak)
                              (cond
                                ((focus-test? self dead)
                                 #f
                                 )
                                ((and (not (and (focus-test? self light) (nonzero? (-> self lightjak))))
                                      (and (logtest? (the-as game-feature (logand (game-feature lightjak) (-> *setting-control* user-current features)))
                                                     (-> self game features)
                                                     )
                                           (-> *setting-control* user-current lightjak)
                                           )
                                      )
                                 (go target-lightjak-get-on (the-as lightjak-stage (-> arg3 param 2)))
                                 )
                                ((logtest? (-> arg3 param 2) 256)
                                 (logclear! (-> self lightjak stage) (lightjak-stage ls0))
                                 (set! v0-0 (+ (- (seconds 20) (-> self fact lightjak-start-time)) (current-time)))
                                 (set! (-> self fact lightjak-effect-time) (the-as time-frame v0-0))
                                 v0-0
                                 )
                                )
                              )
                             ((= v1-63 'invisible)
                              (let ((a1-17 (if (>= arg1 2)
                                               (the-as int (-> arg3 param 2))
                                               (the-as int (-> *TARGET-bank* invisible-duration))
                                               )
                                           )
                                    )
                                (cond
                                  ((focus-test? self dead)
                                   #f
                                   )
                                  ((and (not (logtest? (target-flags invisible) (-> self target-flags)))
                                        (logtest? (the-as game-feature (logand (game-feature artifact-invis) (-> *setting-control* user-current features)))
                                                  (-> self game features)
                                                  )
                                        (zero? (-> self ext-anim))
                                        )
                                   (go target-invisible-get-on (process->handle arg0) (the-as time-frame a1-17))
                                   )
                                  )
                                )
                              )
                             ((= v1-63 'hide)
                              (go target-hide)
                              )
                             ((= v1-63 'blast-recover)
                              (if (= (-> self ext-anim) (target-anim default))
                                  (go target-blast-recover (the-as rigid-body-impact (-> arg3 param 1)))
                                  )
                              )
                             ((= v1-63 'normal)
                              (b!
                                (not (and (and (focus-test? self dark) (nonzero? (-> self darkjak)))
                                          (and (not (focus-test? self dead dangerous hit grabbed))
                                               (not (and (-> self next-state) (= (-> self next-state name) 'target-darkjak-get-off)))
                                               )
                                          )
                                     )
                                cfg-266
                                :delay (empty-form)
                                )
                              (set! v0-0 (go target-darkjak-get-off))
                              (b! #t cfg-282 :delay (nop!))
                              (label cfg-266)
                              (cond
                                ((and (and (focus-test? self light) (nonzero? (-> self lightjak)))
                                      (and (not (focus-test? self dead dangerous hit grabbed))
                                           (not (and (-> self next-state) (= (-> self next-state name) 'target-lightjak-get-off)))
                                           )
                                      )
                                 (go target-lightjak-get-off)
                                 )
                                ((logtest? (target-flags invisible) (-> self target-flags))
                                 (target-invisible-stop)
                                 )
                                )
                              )
                             )
                           )
                     )
                   (label cfg-282)
                   (b! #t cfg-435 :delay (nop!))
                   (label cfg-283)
                   (b! (!= v1-0 'end-mode) cfg-337 :delay (nop!))
                   (let ((v1-224 (-> arg3 param 0)))
                     (b! (!= v1-224 'gun) cfg-291 :delay (empty-form))
                     (set! v0-0 (if (and (using-gun? self) (target-gun-end-mode #t))
                                    (go target-stance)
                                    )
                           )
                     (b! #t cfg-336 :delay (nop!))
                     (label cfg-291)
                     (b! (!= v1-224 'darkjak) cfg-307 :delay (empty-form))
                     (set! v0-0
                           (if (and (and (focus-test? self dark) (nonzero? (-> self darkjak)))
                                    (and (not (focus-test? self dead dangerous hit grabbed))
                                         (not (and (-> self next-state) (= (-> self next-state name) 'target-darkjak-get-off)))
                                         )
                                    )
                               (go target-darkjak-get-off)
                               )
                           )
                     (b! #t cfg-336 :delay (nop!))
                     (label cfg-307)
                     (set! v0-0
                           (cond
                             ((= v1-224 'lightjak)
                              (if (and (and (focus-test? self light) (nonzero? (-> self lightjak)))
                                       (and (not (focus-test? self dead dangerous hit grabbed))
                                            (not (and (-> self next-state) (= (-> self next-state name) 'target-lightjak-get-off)))
                                            )
                                       )
                                  (go target-lightjak-get-off)
                                  )
                              )
                             ((= v1-224 'freeze)
                              (if (nonzero? (-> self lightjak))
                                  (send-event (handle->process (-> self lightjak freeze-control)) 'die (-> arg3 param 1))
                                  )
                              )
                             ((= v1-224 'invisible)
                              (target-invisible-stop)
                              )
                             )
                           )
                     )
                   (label cfg-336)
                   (b! #t cfg-435 :delay (nop!))
                   (label cfg-337)
                   (= v1-0 'gun)
                   )
                 (target-gun-fire (the-as pickup-type (-> arg3 param 0)))
                 )
                ((= v1-0 'darkjak)
                 (when (and (and (focus-test? self dark) (nonzero? (-> self darkjak))) (zero? (-> self darkjak want-stage)))
                   (let ((v1-266 (-> arg3 param 0)))
                     (when (logtest? v1-266 16)
                       (set! (-> self darkjak want-stage) (the-as darkjak-stage v1-266))
                       (go target-darkjak-bomb0)
                       )
                     )
                   )
                 )
                (else
                  (b! (!= v1-0 'play-anim) cfg-352 :delay (nop!))
                  (set! v0-0 (go target-play-anim (the-as string (-> arg3 param 0)) (the-as handle arg1)))
                  (b! #t cfg-435 :delay (nop!))
                  (label cfg-352)
                  (cond
                    ((= v1-0 'clone-anim)
                     (go target-clone-anim (process->handle (the-as process (-> arg3 param 0))))
                     )
                    ((= v1-0 'edge-grab)
                     (if (not (focus-test? self dead hit grabbed))
                         (go target-edge-grab)
                         )
                     )
                    ((= v1-0 'pilot-edge-grab)
                     (if (not (focus-test? self dead hit grabbed))
                         (go target-pilot-edge-grab (the-as pilot-edge-grab-info (-> arg3 param 0)))
                         )
                     )
                    ((= v1-0 'pole-grab)
                     (if (and (not (focus-test? self dead hit grabbed pole))
                              ((method-of-type touching-shapes-entry prims-touching?)
                               (the-as touching-shapes-entry (-> arg3 param 0))
                               (-> self control)
                               (the-as uint 2)
                               )
                              jakb-pole-cycle-ja
                              )
                         (go target-pole-cycle (process->handle arg0))
                         )
                     )
                    ((= v1-0 'ladder)
                     (if (and (not (focus-test? self dead hit grabbed pole))
                              (or (not (-> arg3 param 0)) ((method-of-type touching-shapes-entry prims-touching?)
                                                           (the-as touching-shapes-entry (-> arg3 param 0))
                                                           (-> self control)
                                                           (the-as uint 2)
                                                           )
                                  )
                              jakb-ladder-stance-ja
                              )
                         (go target-ladder-start (process->handle arg0))
                         )
                     )
                    ((= v1-0 'swim)
                     (if (not (or (= (-> self control mod-surface mode) 'swim)
                                  (= (-> self control mod-surface mode) 'dive)
                                  (and (-> self next-state) (= (-> self next-state name) 'target-hit))
                                  (focus-test? self dead hit grabbed)
                                  )
                              )
                         (go target-swim-stance)
                         )
                     )
                    (else
                      (b! (!= v1-0 'wade) cfg-428 :delay (nop!))
                      (set! v0-0
                            (if (and (!= (-> self control mod-surface mode) 'wade)
                                     (begin
                                       (let ((v1-316 (-> self next-state)))
                                         (b! (not v1-316) cfg-422 :likely-delay (set! v1-317 v1-316))
                                         )
                                       (let ((v1-319 (-> self next-state name)))
                                         (set! v1-317 (or (= v1-319 'target-stance) (= v1-319 'target-walk) (= v1-319 'target-stance-look-around)))
                                         )
                                       (label cfg-422)
                                       (and v1-317 (not (logtest? (-> self focus-status) (focus-status dead hit grabbed))))
                                       )
                                     )
                                (go target-wade-stance)
                                )
                            )
                      (b! #t cfg-435 :delay (nop!))
                      (label cfg-428)
                      (cond
                        ((= v1-0 'slide)
                         (if (not (focus-test? self dead hit grabbed on-water under-water))
                             (go target-slide-down-to-ground)
                             )
                         )
                        ((= v1-0 'impact-impulse)
                         (let ((a0-286 (-> arg3 param 0)))
                           (target-got-impact-impulse (the-as rigid-body-impact a0-286))
                           )
                         )
                        (else
                          (target-generic-event-handler arg0 arg1 arg2 arg3)
                          )
                        )
                      )
                    )
                  )
                )
              )
        (label cfg-435)
        v0-0
        )
      )
    )
  )

;; definition for function target-dangerous-event-handler
(defbehavior target-dangerous-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('touched)
     (cond
       ((< 0.0 (-> self fact shield-level))
        (let ((s4-1 (-> self control penetrate-using)))
          (set! (-> self control penetrate-using) (penetrate touch shield))
          (let ((v0-0 (the-as object (target-send-attack
                                       arg0
                                       'shield
                                       (the-as touching-shapes-entry (-> arg3 param 0))
                                       (the-as int (-> self fact shield-attack-id))
                                       0
                                       (-> self control penetrate-using)
                                       )
                              )
                      )
                )
            (set! (-> self control penetrate-using) s4-1)
            v0-0
            )
          )
        )
       (((method-of-type touching-shapes-entry prims-touching?)
         (the-as touching-shapes-entry (-> arg3 param 0))
         (-> self control)
         (the-as uint 1920)
         )
        (target-send-attack
          arg0
          (-> self control danger-mode)
          (the-as touching-shapes-entry (-> arg3 param 0))
          (the-as int (-> self control target-attack-id))
          (the-as int (-> self control attack-count))
          (-> self control penetrate-using)
          )
        )
       (else
         (target-standard-event-handler arg0 arg1 arg2 arg3)
         )
       )
     )
    (('attack 'attack-or-shove 'attack-invinc)
     (target-attacked
       arg2
       (the-as attack-info (-> arg3 param 1))
       arg0
       (the-as touching-shapes-entry (-> arg3 param 0))
       target-hit
       )
     )
    (else
      (target-standard-event-handler arg0 arg1 arg2 arg3)
      )
    )
  )

;; definition for function target-bonk-event-handler
;; INFO: Used lq/sq
(defbehavior target-bonk-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (let ((s4-0 (new 'stack-no-clear 'vector)))
    (cond
      ((and (= arg2 'touched)
            ((method-of-type touching-shapes-entry prims-touching?)
             (the-as touching-shapes-entry (-> arg3 param 0))
             (-> self control)
             (the-as uint 6)
             )
            (< (* 16384.0 (-> self clock time-adjust-ratio))
               (vector-dot
                 (-> self control dynam gravity-normal)
                 (vector-! (new 'stack-no-clear 'vector) (-> self control transv) (-> self control last-transv))
                 )
               )
            (begin
              (vector-normalize!
                (vector-!
                  s4-0
                  (the-as vector (-> self control collision-spheres 0 prim-core))
                  (-> self control actor-contact-pt)
                  )
                1.0
                )
              (< 0.01 (-> s4-0 y))
              )
            )
       (if (< 0.75 (-> s4-0 y))
           (send-event
             arg0
             'bonk
             (-> arg3 param 0)
             (fmax
               (-> self control ground-impact-vel)
               (- (vector-dot (-> self control transv) (-> self control dynam gravity-normal)))
               )
             )
           )
       (let ((f0-7 (vector-dot
                     (-> self control dynam gravity-normal)
                     (vector-! (new 'stack-no-clear 'vector) (-> self control highest-jump-mark) (-> self control trans))
                     )
                   )
             )
         (when (< (-> *TARGET-bank* fall-far) f0-7)
           (when (and (target-send-attack
                        arg0
                        'bonk
                        (the-as touching-shapes-entry (-> arg3 param 0))
                        (the-as int (-> self control target-attack-id))
                        (the-as int (-> self control attack-count))
                        (-> self control penetrate-using)
                        )
                      (not (logtest? (-> self focus-status) (focus-status dead hit)))
                      )
             (set! (-> self control last-trans-any-surf quad) (-> self control trans quad))
             (target-timed-invulnerable (seconds 0.1) self 1)
             (go target-jump (-> *TARGET-bank* jump-height-min) (-> *TARGET-bank* jump-height-max) (the-as surface #f))
             )
           )
         )
       #f
       )
      ((= arg2 'jump)
       (sound-play "jump-long")
       (go
         target-jump
         (the-as float (-> arg3 param 0))
         (the-as float (-> arg3 param 1))
         (the-as surface (-> arg3 param 2))
         )
       )
      )
    )
  )

;; definition for function target-jump-event-handler
(defbehavior target-jump-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (if (and (= arg2 'swim) (< 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
      (return #f)
      )
  (let ((v0-0 (target-bonk-event-handler arg0 arg1 arg2 arg3)))
    (cond
      (v0-0
        (empty)
        v0-0
        )
      (else
        (target-standard-event-handler arg0 arg1 arg2 arg3)
        )
      )
    )
  )

;; definition for function target-walk-event-handler
(defbehavior target-walk-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (let ((v0-0 (target-bonk-event-handler arg0 arg1 arg2 arg3)))
    (cond
      (v0-0
        (empty)
        v0-0
        )
      (else
        (target-standard-event-handler arg0 arg1 arg2 arg3)
        )
      )
    )
  )

;; definition for function target-exit
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defbehavior target-exit target ()
  (set! (-> self control mod-surface) *walk-mods*)
  (set! (-> self control anim-collide-offset-local quad) (the-as uint128 0))
  (set! (-> self control anim-collide-offset-world quad) (the-as uint128 0))
  (set! (-> self control old-anim-collide-offset-world quad) (the-as uint128 0))
  (set! (-> self control draw-offset quad) (the-as uint128 0))
  (set! (-> self control force-turn-to-strength) 0.0)
  (set! (-> self control bend-target) 0.0)
  (set! (-> self control bomb-scale) 0.0)
  (logclear!
    (-> self target-flags)
    (target-flags tf1 tf5 tf13 tf14 tf15 lleg-still rleg-still lleg-no-ik rleg-no-ik)
    )
  (logclear! (-> self focus-status) (focus-status hit grabbed in-head teleporting))
  (target-danger-set! 'harmless #f)
  (logior! (-> self water flags) (water-flag swim-ground))
  (logclear! (-> self water flags) (water-flag jump-out))
  (set! (-> self water drip-mult) 1.0)
  (set! (-> self neck flex-blend) 1.0)
  (set! (-> self neck base-joint) (the-as uint 6))
  (set! (-> self control duck-gun-tube-transision) 0.0)
  (logclear! (-> self skel status) (joint-control-status valid-spooled-frame))
  (logclear! (-> self control status) (collide-status touch-ceiling-sticky))
  (initialize (-> self control impact-ctrl) self -1 0.0 (collide-spec))
  (combo-tracker-method-12
    (-> self control unknown-combo-tracker00)
    *null-vector*
    *null-vector*
    (the-as process #f)
    0
    )
  0
  (none)
  )

;; definition for function target-state-hook-exit
;; WARN: Return type mismatch (function none) vs none.
(defbehavior target-state-hook-exit target ()
  (set! (-> self state-hook) (the-as (function none :behavior target) nothing))
  (none)
  )

;; definition for function target-effect-exit
;; WARN: Return type mismatch target-flags vs none.
(defbehavior target-effect-exit target ()
  (let ((v1-1 (-> self skel effect)))
    (set! (-> v1-1 channel-offset) 0)
    )
  0
  (logclear! (-> self target-flags) (target-flags lleg-still rleg-still lleg-no-ik rleg-no-ik))
  (none)
  )
