;;-*-Lisp-*-
(in-package goal)

;; failed to figure out what this is:
(defpartgroup group-lightjak-get-on-charge
  :id 174
  :duration (seconds 2)
  :linger-duration (seconds 2)
  :flags (sp0 sp4)
  :bounds (static-bspherem 0 0 0 10)
  :parts ((sp-item 630 :flags (is-3d))
    (sp-item 631 :flags (is-3d))
    (sp-item 632 :flags (is-3d))
    (sp-item 633 :flags (is-3d))
    (sp-item 634)
    )
  )

;; failed to figure out what this is:
(defpart 630
  :init-specs ((:texture (vol-light level-default-sprite))
    (:num 1.0)
    (:x (meters 0))
    (:y (meters 0))
    (:z (meters -2))
    (:scale-x (meters 3))
    (:rot-x (degrees 0))
    (:rot-y (degrees 0))
    (:rot-z (degrees 80))
    (:scale-y (meters 10))
    (:r 128.0)
    (:g 128.0)
    (:b 255.0)
    (:a 90.0 10.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-3 left-multiply-quat))
    (:rotate-x (degrees 0))
    (:rotate-y (degrees -90))
    (:rotate-z (degrees 90))
    )
  )

;; failed to figure out what this is:
(defpart 631
  :init-specs ((:texture (vol-light level-default-sprite))
    (:num 1.0)
    (:x (meters 0))
    (:y (meters 0))
    (:z (meters -2))
    (:scale-x (meters 3))
    (:rot-x (degrees 0))
    (:rot-y (degrees 0))
    (:rot-z (degrees 124.99999))
    (:scale-y (meters 10))
    (:r 128.0)
    (:g 128.0)
    (:b 255.0)
    (:a 90.0 10.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-3 left-multiply-quat))
    (:rotate-x (degrees 0))
    (:rotate-y (degrees -90))
    (:rotate-z (degrees 90))
    )
  )

;; failed to figure out what this is:
(defpart 632
  :init-specs ((:texture (vol-light level-default-sprite))
    (:num 1.0)
    (:x (meters 0))
    (:y (meters 0))
    (:z (meters -2))
    (:scale-x (meters 3))
    (:rot-x (degrees 0))
    (:rot-y (degrees 0))
    (:rot-z (degrees 35))
    (:scale-y (meters 10))
    (:r 128.0)
    (:g 128.0)
    (:b 255.0)
    (:a 90.0 10.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-3 left-multiply-quat))
    (:rotate-x (degrees 0))
    (:rotate-y (degrees -90))
    (:rotate-z (degrees 90))
    )
  )

;; failed to figure out what this is:
(defpart 633
  :init-specs ((:texture (vol-light level-default-sprite))
    (:num 1.0)
    (:x (meters 0))
    (:y (meters 0))
    (:z (meters -2))
    (:scale-x (meters 3))
    (:rot-x (degrees 0))
    (:rot-y (degrees 0))
    (:rot-z (degrees 170))
    (:scale-y (meters 10))
    (:r 128.0)
    (:g 128.0)
    (:b 255.0)
    (:a 90.0 10.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-3 left-multiply-quat))
    (:rotate-x (degrees 0))
    (:rotate-y (degrees -90))
    (:rotate-z (degrees 90))
    )
  )

;; failed to figure out what this is:
(defpart 634
  :init-specs ((:texture (diamond-star level-default-sprite))
    (:num 1.0)
    (:x (meters -0.5) (meters 1))
    (:y (meters 0) (meters 8))
    (:z (meters -0.5) (meters 1))
    (:scale-x (meters 0.1) (meters 0.4))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 128.0)
    (:b 128.0)
    (:a 0.0)
    (:vel-y (meters -0.00083333335) (meters -0.00083333335))
    (:fade-a 2.56)
    (:timer (seconds 1))
    (:flags (sp-cpuinfo-flag-3))
    (:next-time (seconds 0.167))
    (:next-launcher 635)
    (:conerot-x (degrees -50.000004) (degrees 100.00001))
    (:rotate-y (degrees 0) (degrees 3600))
    )
  )

;; failed to figure out what this is:
(defpart 635
  :init-specs ((:fade-a -0.85333335))
  )

;; failed to figure out what this is:
(defpartgroup group-lightjak-get-on
  :id 175
  :duration (seconds 0.5)
  :flags (sp0)
  :bounds (static-bspherem 0 0 0 640)
  :parts ((sp-item 636 :period (seconds 5) :length (seconds 0.017)))
  )

;; failed to figure out what this is:
(defpart 636
  :init-specs ((:texture (colorflash level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 20))
    (:rot-x (degrees 22.5))
    (:scale-y (meters 12))
    (:r 128.0)
    (:g 128.0)
    (:b 128.0)
    (:a 128.0)
    (:omega (degrees 6767.9995))
    (:scalevel-x (meters -0.13333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -1.6)
    (:fade-g -1.6)
    (:fade-b -1.6)
    (:timer (seconds 0.267))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 glow))
    (:userdata 4096.0)
    )
  )

;; failed to figure out what this is:
(defpartgroup group-lightjak-get-off
  :id 176
  :duration (seconds 0.5)
  :flags (sp0)
  :bounds (static-bspherem 0 0 0 640)
  :parts ((sp-item 637 :period (seconds 5) :length (seconds 0.017))
    (sp-item 638 :period (seconds 5) :length (seconds 0.017))
    (sp-item 639 :period (seconds 5) :length (seconds 0.085))
    )
  )

;; failed to figure out what this is:
(defpart 637
  :init-specs ((:texture (colorflash level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 20))
    (:rot-x (degrees 22.5))
    (:scale-y (meters 12))
    (:r 128.0)
    (:g 128.0)
    (:b 128.0)
    (:a 128.0)
    (:omega (degrees 6767.9995))
    (:scalevel-x (meters -0.13333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -1.6)
    (:fade-g -1.6)
    (:fade-b -1.6)
    (:timer (seconds 0.267))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 glow))
    (:userdata 4096.0)
    )
  )

;; failed to figure out what this is:
(defpart 638
  :init-specs ((:texture (rainbow-halo level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 10))
    (:rot-x (degrees 22.5))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 128.0)
    (:b 128.0)
    (:a 128.0)
    (:omega (degrees 6767.9995))
    (:scalevel-x (meters 0.033333335))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.85333335)
    (:fade-g -0.85333335)
    (:fade-b -0.85333335)
    (:timer (seconds 0.5))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 glow))
    (:userdata 4096.0)
    )
  )

;; failed to figure out what this is:
(defpart 639
  :init-specs ((:texture (middot level-default-sprite))
    (:num 60.0)
    (:y (meters -1.5) (meters 3))
    (:scale-x (meters 0.05) (meters 0.05))
    (:scale-y :copy scale-x)
    (:r 32.0 64.0)
    (:g :copy r)
    (:b 128.0)
    (:a 128.0 128.0)
    (:omega (degrees 0.045))
    (:vel-y (meters 0.016666668) (meters 0.033333335))
    (:accel-y (meters 0.00016666666) (meters 0.00066666666))
    (:friction 0.95 0.05)
    (:timer (seconds 3))
    (:flags (sp-cpuinfo-flag-0 sp-cpuinfo-flag-3))
    (:func 'sparticle-motion-blur)
    (:next-time (seconds 0.5))
    (:next-launcher 640)
    (:conerot-x (degrees 90) (degrees 180))
    (:rotate-y (degrees 0) (degrees 3600))
    )
  )

;; failed to figure out what this is:
(defpart 640
  :init-specs ((:scalevel-x (meters -0.00016666666) (meters -0.00016666666))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.425 -0.425)
    (:friction 0.99)
    (:next-time (seconds 0.017))
    (:next-launcher 641)
    )
  )

;; failed to figure out what this is:
(defpart 641
  :init-specs ((:accel-x (meters -0.0013333333) (meters 0.0026666666))
    (:accel-z (meters -0.0013333333) (meters 0.0026666666))
    (:next-time (seconds 0.085) (seconds 0.08))
    (:next-launcher 641)
    )
  )

;; failed to figure out what this is:
(defpartgroup group-lightjak-regen
  :id 177
  :duration (seconds 2)
  :linger-duration (seconds 2)
  :flags (sp0)
  :bounds (static-bspherem 0 0 0 40)
  :parts ((sp-item 642 :flags (is-3d))
    (sp-item 643 :flags (is-3d))
    (sp-item 644 :flags (is-3d))
    (sp-item 645 :flags (is-3d))
    (sp-item 646)
    (sp-item 647 :period (seconds 5) :length (seconds 1.5))
    )
  )

;; failed to figure out what this is:
(defpart 642
  :init-specs ((:texture (vol-light level-default-sprite))
    (:num 0.1 0.1)
    (:x (meters 0))
    (:y (meters 0))
    (:z (meters -5) (meters -1))
    (:scale-x (meters 3) (meters 1))
    (:rot-x (degrees 0))
    (:rot-y (degrees 0))
    (:rot-z (degrees 80))
    (:scale-y (meters 6))
    (:r 128.0)
    (:g 128.0)
    (:b 255.0)
    (:a 0.0)
    (:fade-a 1.28)
    (:timer (seconds 0.335))
    (:flags (sp-cpuinfo-flag-3 left-multiply-quat))
    (:next-time (seconds 0.167))
    (:next-launcher 648)
    (:rotate-x (degrees 0))
    (:rotate-y (degrees -90))
    (:rotate-z (degrees 90))
    )
  )

;; failed to figure out what this is:
(defpart 648
  :init-specs ((:fade-a -1.28))
  )

;; failed to figure out what this is:
(defpart 643
  :init-specs ((:texture (vol-light level-default-sprite))
    (:num 0.1 0.1)
    (:x (meters 0))
    (:y (meters 0))
    (:z (meters -5) (meters -1))
    (:scale-x (meters 3) (meters 1))
    (:rot-x (degrees 0))
    (:rot-y (degrees 0))
    (:rot-z (degrees 124.99999))
    (:scale-y (meters 6))
    (:r 128.0)
    (:g 128.0)
    (:b 255.0)
    (:a 0.0)
    (:fade-a 1.28)
    (:timer (seconds 0.335))
    (:flags (sp-cpuinfo-flag-3 left-multiply-quat))
    (:next-time (seconds 0.167))
    (:next-launcher 648)
    (:rotate-x (degrees 0))
    (:rotate-y (degrees -90))
    (:rotate-z (degrees 90))
    )
  )

;; failed to figure out what this is:
(defpart 644
  :init-specs ((:texture (vol-light level-default-sprite))
    (:num 0.1 0.1)
    (:x (meters 0))
    (:y (meters 0))
    (:z (meters -5) (meters -1))
    (:scale-x (meters 3) (meters 1))
    (:rot-x (degrees 0))
    (:rot-y (degrees 0))
    (:rot-z (degrees 35))
    (:scale-y (meters 6))
    (:r 128.0)
    (:g 128.0)
    (:b 255.0)
    (:a 0.0)
    (:rotvel-z (degrees 0.010000001))
    (:fade-a 1.28)
    (:timer (seconds 0.335))
    (:flags (sp-cpuinfo-flag-3 left-multiply-quat))
    (:next-time (seconds 0.167))
    (:next-launcher 648)
    (:rotate-x (degrees 0))
    (:rotate-y (degrees -90))
    (:rotate-z (degrees 90))
    )
  )

;; failed to figure out what this is:
(defpart 645
  :init-specs ((:texture (vol-light level-default-sprite))
    (:num 0.1 0.1)
    (:x (meters 0))
    (:y (meters 0))
    (:z (meters -5) (meters -1))
    (:scale-x (meters 3) (meters 1))
    (:rot-x (degrees 0))
    (:rot-y (degrees 0))
    (:rot-z (degrees 170))
    (:scale-y (meters 6))
    (:r 128.0)
    (:g 128.0)
    (:b 255.0)
    (:a 0.0)
    (:rotvel-z (degrees 0.010000001))
    (:fade-a 1.28)
    (:timer (seconds 0.335))
    (:flags (sp-cpuinfo-flag-3 left-multiply-quat))
    (:next-time (seconds 0.167))
    (:next-launcher 648)
    (:rotate-x (degrees 0))
    (:rotate-y (degrees -90))
    (:rotate-z (degrees 90))
    )
  )

;; failed to figure out what this is:
(defpart 646
  :init-specs ((:texture (diamond-star level-default-sprite))
    (:num 0.5 0.5)
    (:x (meters -0.5) (meters 1))
    (:y (meters 0) (meters 8))
    (:z (meters -0.5) (meters 1))
    (:scale-x (meters 0.1) (meters 0.4))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 128.0)
    (:b 128.0)
    (:a 0.0)
    (:vel-y (meters -0.00083333335) (meters -0.00083333335))
    (:fade-a 0.85333335)
    (:timer (seconds 1) (seconds 1.665))
    (:flags (sp-cpuinfo-flag-3))
    (:next-time (seconds 0.5))
    (:next-launcher 649)
    (:conerot-x (degrees -50.000004) (degrees 100.00001))
    (:rotate-y (degrees 0) (degrees 3600))
    )
  )

;; failed to figure out what this is:
(defpart 649
  :init-specs ((:fade-a -0.85333335))
  )

;; failed to figure out what this is:
(defpart 647
  :init-specs ((:texture (laser-hit2 level-default-sprite))
    (:num 1.0)
    (:y (meters 2))
    (:scale-x (meters 10) (meters 5))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 64.0)
    (:g 64.0)
    (:b 128.0)
    (:a 0.0)
    (:scalevel-x (meters -0.033333335) (meters -0.013333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-a 0.10666667 0.10666667)
    (:timer (seconds 1))
    (:flags (sp-cpuinfo-flag-0 sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    )
  )

;; failed to figure out what this is:
(defpart 650
  :init-specs ((:texture (glow-soft level-default-sprite))
    (:num 1.0)
    (:y (meters -0.025))
    (:scale-x (meters 0.2))
    (:rot-x (degrees 2.25))
    (:scale-y (meters 0.1))
    (:r 128.0)
    (:g 128.0)
    (:b 128.0)
    (:a 64.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 glow))
    (:userdata 409.6)
    )
  )

;; failed to figure out what this is:
(defpart 651
  :init-specs ((:texture (glow level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 10.5) (meters 0.25))
    (:rot-x (degrees 11.25))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 0.0 64.0)
    (:b 255.0)
    (:a 128.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:userdata 4096.0)
    )
  )

;; failed to figure out what this is:
(defpartgroup group-lightjak-shield-start
  :id 178
  :duration (seconds 0.5)
  :linger-duration (seconds 1)
  :flags (sp0 sp4 sp12)
  :bounds (static-bspherem 0 0 0 640)
  :parts ((sp-item 653 :flags (sp3) :binding 652)
    (sp-item 653 :flags (sp3) :binding 652)
    (sp-item 653 :flags (sp3) :binding 652)
    (sp-item 653 :flags (sp3) :binding 652)
    (sp-item 653 :flags (sp3) :binding 652)
    (sp-item 653 :flags (sp3) :binding 652)
    (sp-item 653 :flags (sp3) :binding 652)
    (sp-item 653 :flags (sp3) :binding 652)
    (sp-item 653 :flags (sp3) :binding 652)
    (sp-item 653 :flags (sp3) :binding 652)
    (sp-item 652 :flags (sp2))
    (sp-item 652 :flags (sp2))
    (sp-item 652 :flags (sp2))
    (sp-item 652 :flags (sp2))
    (sp-item 652 :flags (sp2))
    (sp-item 652 :flags (sp2))
    (sp-item 652 :flags (sp2))
    (sp-item 652 :flags (sp2))
    (sp-item 652 :flags (sp2))
    (sp-item 652 :flags (sp2))
    )
  )

;; failed to figure out what this is:
(defpart 653
  :init-specs ((:texture (middot level-default-sprite))
    (:num 1.0)
    (:y (meters -1) (meters 2))
    (:scale-x (meters 1))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 128.0)
    (:b 128.0)
    (:a 0.0)
    (:timer (seconds -0.005))
    (:func 'spt-func-relative-pos)
    )
  )

;; failed to figure out what this is:
(defpart 652
  :init-specs ((:texture (middot level-default-sprite))
    (:num 1.0 3.0)
    (:z (meters 2) (meters 1))
    (:scale-x (meters 0.05) (meters 0.05))
    (:rot-z (degrees 90))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 128.0)
    (:b 128.0)
    (:a 64.0 64.0)
    (:omega (degrees 0) (degrees 360))
    (:vel-x (meters -0.013333334) (meters -0.013333334))
    (:vel-y (meters 0.053333335))
    (:fade-a -0.42666668 -0.42666668)
    (:timer (seconds 1))
    (:flags (sp-cpuinfo-flag-2 ready-to-launch left-multiply-quat))
    )
  )

;; failed to figure out what this is:
(defpartgroup group-lightjak-shield-hit
  :id 179
  :duration (seconds 0.035)
  :linger-duration (seconds 1.5)
  :bounds (static-bspherem 0 0 0 2)
  :parts ((sp-item 654))
  )

;; failed to figure out what this is:
(defpart 654
  :init-specs ((:texture (lakedrop level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 6.1))
    (:rot-x (degrees 11.25))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 128.0)
    (:b 128.0)
    (:a 64.0)
    (:fade-a -0.21333334)
    (:timer (seconds 1))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 glow))
    (:userdata 4096.0)
    (:func 'sparticle-track-root)
    )
  )

;; failed to figure out what this is:
(defpartgroup group-lightjak-freeze-hands
  :id 180
  :duration (seconds 0.5)
  :linger-duration (seconds 1.5)
  :bounds (static-bspherem 0 0 0 2)
  :parts ((sp-item 655))
  )

;; failed to figure out what this is:
(defpart 655
  :init-specs ((:texture (glow-hotdot level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 1.5))
    (:scale-y :copy scale-x)
    (:r 32.0)
    (:g 32.0)
    (:b 128.0)
    (:a 128.0)
    (:scalevel-x (meters -0.01))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.64)
    (:fade-g -0.21333334)
    (:fade-b -0.85333335)
    (:timer (seconds 0.5))
    (:flags (sp-cpuinfo-flag-0 sp-cpuinfo-flag-3))
    (:rotate-y (degrees 0))
    )
  )

;; failed to figure out what this is:
(defpartgroup group-lightjak-freeze-burst
  :id 181
  :duration (seconds 0.035)
  :linger-duration (seconds 1.5)
  :flags (sp0)
  :bounds (static-bspherem 0 0 0 2)
  :parts ((sp-item 656 :flags (sp3)) (sp-item 657 :flags (sp3)) (sp-item 658 :flags (sp3 sp7)))
  )

;; failed to figure out what this is:
(defpart 658
  :init-specs ((:texture (starflash level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 5))
    (:rot-x (degrees 2250))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 255.0)
    (:omega (degrees 18011.25))
    (:scalevel-x (meters -0.125))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -6.375)
    (:timer (seconds 0.135))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 glow))
    (:userdata 409600.0)
    )
  )

;; failed to figure out what this is:
(defpart 657
  :init-specs ((:texture (middot level-default-sprite))
    (:num 100.0)
    (:scale-x (meters 0.1) (meters 0.1))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 128.0)
    (:omega (degrees 0.45))
    (:vel-y (meters 0.06666667) (meters 0.006666667))
    (:fade-a -0.21333334 -0.21333334)
    (:friction 0.94 0.04)
    (:timer (seconds 2))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:func 'sparticle-motion-blur)
    (:conerot-x (degrees 80) (degrees 20))
    (:rotate-y (degrees 0) (degrees 3600))
    )
  )

;; failed to figure out what this is:
(defpart 656
  :init-specs ((:texture (big-cloud level-default-sprite))
    (:num 30.0)
    (:scale-x (meters 1) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 0.0)
    (:g 40.0 40.0)
    (:b 128.0)
    (:a 32.0 32.0)
    (:vel-y (meters 0.033333335) (meters 0.1))
    (:scalevel-x (meters 0.006666667) (meters 0.033333335))
    (:scalevel-y :copy scalevel-x)
    (:fade-g -0.53333336)
    (:fade-a -0.42666668 -0.42666668)
    (:friction 0.93 0.02)
    (:timer (seconds 0.5))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:conerot-x (degrees 60) (degrees 40))
    (:rotate-y (degrees 0) (degrees 3600))
    )
  )

;; definition for function point-off-screen
;; INFO: Used lq/sq
(defun point-off-screen ((arg0 vector))
  (let ((s4-0 (new 'stack-no-clear 'vector))
        (s5-0 (new 'stack-no-clear 'vector))
        (s3-0 (new 'stack-no-clear 'vector))
        )
    (set-vector! s3-0 0.0 -280.0 0.0 1.0)
    (vector-! s4-0 (camera-pos) (target-pos 0))
    (set! (-> s4-0 y) 0.0)
    (vector-normalize! s4-0 1.0)
    (set! (-> s5-0 quad) (-> (target-pos 0) quad))
    (reverse-transform-point! arg0 s5-0 s4-0 s3-0)
    )
  arg0
  )

;; failed to figure out what this is:
(let ((v1-39 (copy *walk-mods* 'global)))
  (set! (-> v1-39 name) 'lightjak)
  (set! (-> v1-39 flags) (surface-flag gun-off))
  (set! *lightjak-trans-mods* v1-39)
  )

;; definition for function want-to-powerjak?
(defbehavior want-to-powerjak? target ()
  (and (or (cpad-hold? (-> self control cpad number) l2) (nonzero? (-> self lightjak get-on-latch)))
       (and (not *pause-lock*)
            (not (and (logtest? (-> self water flags) (water-flag under-water))
                      (not (logtest? (-> self water flags) (water-flag swim-ground)))
                      )
                 )
            (and (or (and (focus-test? self dark) (nonzero? (-> self darkjak)))
                     (not (logtest? (target-flags invisible) (-> self target-flags)))
                     )
                 (or (and (-> *setting-control* user-current darkjak)
                          (logtest? (the-as game-feature (logand (game-feature darkjak) (-> *setting-control* user-current features)))
                                    (-> self game features)
                                    )
                          (not (focus-test?
                                 self
                                 dead
                                 hit
                                 grabbed
                                 in-head
                                 under-water
                                 edge-grab
                                 pole
                                 flut
                                 tube
                                 light
                                 board
                                 pilot
                                 mech
                                 carry
                                 indax
                                 teleporting
                                 )
                               )
                          (time-elapsed? (-> self fact darkjak-start-time) (seconds 0.05))
                          )
                     (and (-> *setting-control* user-current lightjak)
                          (logtest? (the-as game-feature (logand (game-feature lightjak) (-> *setting-control* user-current features)))
                                    (-> self game features)
                                    )
                          (not (focus-test?
                                 self
                                 dead
                                 hit
                                 grabbed
                                 in-head
                                 under-water
                                 edge-grab
                                 pole
                                 flut
                                 tube
                                 board
                                 pilot
                                 mech
                                 dark
                                 carry
                                 indax
                                 teleporting
                                 )
                               )
                          (time-elapsed? (-> self fact lightjak-start-time) (seconds 0.05))
                          )
                     )
                 )
            )
       )
  )

;; failed to figure out what this is:
(defstate target-powerjak-get-on (target)
  :event target-standard-event-handler
  :exit (behavior ()
    (set! (-> self lightjak get-on-latch) (the-as uint 0))
    (logclear! (-> self target-flags) (target-flags lleg-still rleg-still))
    (logclear! (-> self target-flags) (target-flags tf4))
    (remove-setting! 'gun)
    (persist-with-delay *setting-control* 'gun (seconds 0.5) 'gun #f 0.0 0)
    (apply-settings *setting-control*)
    (target-gun-end-mode #t)
    )
  :code (behavior ()
    (logior! (-> self target-flags) (target-flags tf4))
    (set-time! (-> self state-time))
    (set! (-> self neck flex-blend) 0.0)
    (set! (-> self control mod-surface) *lightjak-trans-mods*)
    (set! (-> self lightjak get-on-latch) (the-as uint 0))
    (set! (-> self control unknown-word04)
          (the-as uint (and (focus-test? self light) (nonzero? (-> self lightjak))))
          )
    (target-gun-end-mode #f)
    (set-setting! 'gun #f 0.0 0)
    (apply-settings *setting-control*)
    (let ((gp-0
            (lambda :behavior target
              ((arg0 symbol))
              (show-hud 'hud-health)
              (cond
                ((and (or (and (focus-test? self light) (nonzero? (-> self lightjak)))
                          (and (focus-test? self dark) (nonzero? (-> self darkjak)))
                          )
                      (not (cpad-hold? (-> self control cpad number) l2))
                      (zero? (-> self lightjak get-on-latch))
                      )
                 (cond
                   ((-> self lightjak get-off-lock)
                    (go target-stance)
                    )
                   ((and (focus-test? self light) (nonzero? (-> self lightjak)))
                    (go target-lightjak-get-off)
                    )
                   ((and (focus-test? self dark) (nonzero? (-> self darkjak)))
                    (go target-darkjak-get-off)
                    )
                   )
                 )
                ((and (time-elapsed? (-> self state-time) (seconds 0.1))
                      (not (-> self lightjak get-off-lock))
                      (not (cpad-hold? (-> self control cpad number) l2))
                      (zero? (-> self lightjak get-on-latch))
                      (want-to-darkjak?)
                      )
                 (set! (-> self lightjak get-on-latch) (the-as uint 512))
                 )
                ((and (or (not (want-to-powerjak?))
                          (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control cpad number) r2))
                          (cpad-pressed? (-> self control cpad number) r2)
                          )
                      (time-elapsed? (-> self state-time) (seconds 0.05))
                      )
                 (go target-stance)
                 )
                ((and (cpad-pressed? (-> self control cpad number) triangle)
                      (let ((v1-77 #t))
                        (set! (-> self lightjak get-off-lock) v1-77)
                        v1-77
                        )
                      (logtest? (the-as game-feature (logand (game-feature lightjak-regen) (-> *setting-control* user-current features)))
                                (-> self game features)
                                )
                      (and (< (-> self fact health) (-> self fact health-max)) (want-to-lightjak?))
                      )
                 (set! (-> self lightjak get-on-latch) (the-as uint 8))
                 )
                ((and (cpad-pressed? (-> self control cpad number) x)
                      (let ((v1-96 #t))
                        (set! (-> self lightjak get-off-lock) v1-96)
                        v1-96
                        )
                      (logtest? (the-as game-feature (logand (game-feature lightjak-swoop) (-> *setting-control* user-current features)))
                                (-> self game features)
                                )
                      (>= (-> self game eco-pill-light) (-> *FACT-bank* lightjak-swoop-inc))
                      (= (-> self fact shield-level) 0.0)
                      (not (logtest? (-> self target-flags) (target-flags prevent-attack)))
                      (not (logtest? (-> self control current-surface flags) (surface-flag no-attack no-feet)))
                      (and (not (and (not (using-gun? self)) (!= (-> self skel top-anim interp) 0.0))) (want-to-lightjak?))
                      )
                 (set! (-> self lightjak get-on-latch) (the-as uint 16))
                 )
                ((and (cpad-pressed? (-> self control cpad number) square)
                      (let ((v1-126 #t))
                        (set! (-> self lightjak get-off-lock) v1-126)
                        v1-126
                        )
                      (logtest? (the-as game-feature (logand (game-feature lightjak-freeze) (-> *setting-control* user-current features)))
                                (-> self game features)
                                )
                      (>= (-> self game eco-pill-light) (-> *FACT-bank* lightjak-freeze-min))
                      (and (not (handle->process (-> self lightjak freeze-control))) (want-to-lightjak?))
                      )
                 (set! (-> self lightjak get-on-latch) (the-as uint 32))
                 )
                ((and (cpad-pressed? (-> self control cpad number) circle)
                      (let ((v1-149 #t))
                        (set! (-> self lightjak get-off-lock) v1-149)
                        v1-149
                        )
                      (logtest? (game-feature lightjak-shield) (-> self game features))
                      (>= (-> self game eco-pill-light) (-> *FACT-bank* lightjak-shield-inc))
                      (and (not (handle->process (-> self lightjak freeze-control))) (want-to-lightjak?))
                      )
                 (set! (-> self lightjak get-on-latch) (the-as uint 64))
                 )
                )
              (cond
                ((or (!= (-> self skel root-channel 0) (-> self skel channel))
                     (!= (-> self skel top-anim interp) 0.0)
                     (not arg0)
                     )
                 #f
                 )
                ((and (nonzero? (-> self lightjak get-on-latch)) (or (want-to-lightjak?) (want-to-darkjak?)))
                 (set! (-> self lightjak lightjak-before-powerjak) (the-as symbol (-> self control unknown-spool-anim00)))
                 (case (-> self lightjak get-on-latch)
                   ((512)
                    (go target-darkjak-get-on (darkjak-stage active))
                    )
                   ((8)
                    (if (and (focus-test? self light) (nonzero? (-> self lightjak)))
                        (go target-lightjak-regen 0)
                        (go target-lightjak-get-on (lightjak-stage ls2 regen))
                        )
                    )
                   ((16)
                    (cond
                      ((and (focus-test? self light) (nonzero? (-> self lightjak)))
                       (logior! (-> self lightjak stage) (lightjak-stage swoop))
                       (if (not (-> self lightjak wings))
                           (set! (-> self lightjak wings) (process-spawn wings :init wings-init 'open :name "wings" :to self))
                           )
                       (go target-stance)
                       )
                      (else
                        (go target-lightjak-get-on (lightjak-stage ls2 swoop))
                        )
                      )
                    )
                   ((32)
                    (if (and (focus-test? self light) (nonzero? (-> self lightjak)))
                        (go target-lightjak-freeze)
                        (go target-lightjak-get-on (lightjak-stage ls2 freeze))
                        )
                    )
                   ((64)
                    (if (and (focus-test? self light) (nonzero? (-> self lightjak)))
                        (go target-stance)
                        (go target-lightjak-get-on (lightjak-stage ls2 ls6))
                        )
                    )
                   )
                 )
                ((nonzero? (-> self lightjak get-on-latch))
                 (set! (-> self lightjak get-on-latch) (the-as uint 0))
                 0
                 )
                )
              )
            )
          )
      (set-forward-vel 0.0)
      (let ((s5-0 0))
        (while (not (logtest? (-> self control status) (collide-status on-surface)))
          (target-falling-anim-trans)
          (+! s5-0 (- (current-time) (-> self clock old-frame-counter)))
          (if (>= s5-0 300)
              (go target-falling #f)
              )
          (gp-0 #f)
          (suspend)
          )
        )
      (ja-channel-push! 1 (seconds 0.1))
      (ja-no-eval :group! jakb-powerjak-get-on-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (gp-0 #t)
        (suspend)
        (ja :num! (seek!))
        )
      (logclear! (-> self target-flags) (target-flags tf4))
      (until #f
        (ja-no-eval :group! jakb-powerjak-get-on-loop-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (gp-0 #t)
          (suspend)
          (ja :num! (seek!))
          )
        )
      )
    #f
    (go target-stance)
    )
  :post (-> target-grab post)
  )

;; definition for function target-lightjak-setup
;; WARN: Return type mismatch int vs none.
(defbehavior target-lightjak-setup target ((arg0 symbol))
  (when (zero? (-> self lightjak))
    (set! (-> self lightjak) (new 'process 'lightjak-info))
    (set! (-> self lightjak process) (process->ppointer self))
    (let* ((v1-4 (-> self game))
           (a0-5 (+ (-> v1-4 attack-id) 1))
           )
      (set! (-> v1-4 attack-id) a0-5)
      (set! (-> self lightjak attack-id) a0-5)
      )
    (set! (-> self lightjak tone) (the-as uint (new-sound-id)))
    (set! (-> self lightjak freeze-control) (the-as handle #f))
    (set! (-> self lightjak freeze-screen) (the-as handle #f))
    (set! (-> self lightjak wings) (the-as (pointer wings) #f))
    (set! (-> self lightjak shield) (the-as (pointer lightjak-shield) #f))
    (set! (-> self lightjak latch-out-time) 0)
    (set! (-> self lightjak mode-sound-bank) #f)
    (set! (-> self lightjak get-off-lock) #f)
    (set! (-> self lightjak lightjak-before-powerjak) #f)
    )
  0
  (none)
  )

;; definition for function want-to-lightjak?
(defbehavior want-to-lightjak? target ()
  (and (not *pause-lock*)
       (-> *setting-control* user-current lightjak)
       (logtest? (the-as game-feature (logand (game-feature lightjak) (-> *setting-control* user-current features)))
                 (-> self game features)
                 )
       (not (focus-test?
              self
              dead
              hit
              grabbed
              in-head
              under-water
              edge-grab
              pole
              flut
              tube
              board
              pilot
              mech
              dark
              carry
              indax
              teleporting
              )
            )
       (not (and (logtest? (-> self water flags) (water-flag under-water))
                 (not (logtest? (-> self water flags) (water-flag swim-ground)))
                 )
            )
       (and (and (time-elapsed? (-> self fact lightjak-start-time) (seconds 0.05)) (< 0.0 (-> self game eco-pill-light)))
            (zero? (-> self lightjak latch-out-time))
            (time-elapsed? (-> self lightjak regen-time) (seconds 0.3))
            )
       )
  )

;; definition for function target-lightjak-end-mode
;; WARN: Return type mismatch int vs none.
(defbehavior target-lightjak-end-mode target ((arg0 symbol))
  (when (and (focus-test? self light) (nonzero? (-> self lightjak)))
    (cond
      (arg0
        (set! (-> self lightjak get-off-lock) #f)
        (set! (-> self lightjak lightjak-before-powerjak) #f)
        (logclear! (-> self focus-status) (focus-status light))
        (send-event self 'reset-collide)
        (logclear! (-> self target-flags) (target-flags tf4))
        (remove-setting! 'sound-flava)
        (remove-setting! 'string-min-length)
        (remove-setting! 'string-max-length)
        (remove-setting! 'string-spline-max-move)
        (remove-setting! 'string-spline-accel)
        (remove-setting! 'string-spline-max-move-player)
        (remove-setting! 'string-spline-accel-player)
        (setting-control-method-14 *setting-control* (-> self lightjak mode-sound-bank))
        (set! (-> self lightjak mode-sound-bank) #f)
        (let ((v1-33 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-33 command) (sound-command set-param))
          (set! (-> v1-33 id) (the-as sound-id (-> self lightjak tone)))
          (set! (-> v1-33 params volume) -4)
          (set! (-> v1-33 auto-time) 120)
          (set! (-> v1-33 auto-from) 2)
          (set! (-> v1-33 params mask) (the-as uint 17))
          (-> v1-33 id)
          )
        (case (get-status *gui-control* (the-as sound-id (-> self lightjak on-off)))
          (((gui-status pending) (gui-status ready) (gui-status unknown))
           (set-action!
             *gui-control*
             (gui-action stop)
             (the-as sound-id (-> self lightjak on-off))
             (gui-channel none)
             (gui-action none)
             (the-as string #f)
             (the-as (function gui-connection symbol) #f)
             (the-as process #f)
             )
           )
          )
        (set! (-> self pending-ext-anim) (target-anim default))
        (if (< (-> self game eco-pill-light) 1.0)
            (send-event self 'get-pickup (pickup-type eco-pill-light) -1.0)
            )
        (let ((v1-53 (ja-group)))
          (when (not (and (and v1-53 (or (= v1-53 jakb-lightjak-get-off-ja) (= v1-53 jakb-lightjak-get-on-ja)))
                          (= (-> self skel root-channel 0) (-> self skel channel))
                          )
                     )
            (joint-control-cleanup
              (-> self skel)
              (-> self ext-anim-control heap)
              (the-as art-joint-anim jakb-stance-loop-ja)
              )
            (send-event (ppointer->process (-> self sidekick)) 'cleanup)
            )
          )
        (let ((a0-39 (ppointer->process (-> self lightjak wings))))
          (when a0-39
            (deactivate a0-39)
            (set! (-> self lightjak wings) (the-as (pointer wings) #f))
            )
          )
        (let ((a0-40 (ppointer->process (-> self lightjak shield))))
          (when a0-40
            (deactivate a0-40)
            (set! (-> self lightjak shield) (the-as (pointer lightjak-shield) #f))
            )
          )
        (remove-setting! 'attack)
        (set! (-> self fact shield-level) 0.0)
        (set! (-> self lightjak shield-start-time) 0)
        (remove-from-process *part-engine* self)
        (set! (-> self lightjak latch-out-time) 0)
        0
        )
      ((zero? (-> self lightjak latch-out-time))
       (when (!= (-> self lightjak-interp) 0.0)
         (case (get-status *gui-control* (the-as sound-id (-> self lightjak on-off)))
           (((gui-status pending) (gui-status ready) (gui-status active))
            )
           (else
             (set! (-> self lightjak on-off)
                   (the-as
                     uint
                     (add-process *gui-control* self (gui-channel jak-effect-1) (gui-action queue) "jak-onof" -99.0 0)
                     )
                   )
             )
           )
         )
       (set-time! (-> self lightjak latch-out-time))
       (send-event (ppointer->process (-> self lightjak wings)) 'end-mode)
       )
      )
    )
  0
  (none)
  )

;; definition for function target-lightjak-do-effect
;; INFO: Used lq/sq
(defbehavior target-lightjak-do-effect target ()
  (let ((f30-0 (-> self lightjak-interp)))
    (cond
      ((< 0.0 f30-0)
       (logior! (-> self target-effect) (target-effect te1))
       (logior! (-> self target-effect) (target-effect te4))
       (sound-play-by-name
         (static-sound-name "ltjak-chill")
         (the-as sound-id (-> self lightjak tone))
         (the int (* 1024.0 f30-0))
         0
         0
         (sound-group)
         (-> self control trans)
         )
       )
      (else
        (when (logtest? (-> self target-effect) (target-effect te1))
          (let ((v1-14 (get-status *gui-control* (the-as sound-id (-> self lightjak on-off)))))
            (cond
              ((= v1-14 (gui-status ready))
               (set-action!
                 *gui-control*
                 (gui-action play)
                 (the-as sound-id (-> self lightjak on-off))
                 (gui-channel none)
                 (gui-action none)
                 (the-as string #f)
                 (the-as (function gui-connection symbol) #f)
                 (the-as process #f)
                 )
               )
              ((and (= (-> *setting-control* user-current mode-sound-bank) 'modelit)
                    (= (-> *setting-control* user-target mode-sound-bank) 'modelit)
                    (not (or (focus-test? self board) (-> self board latch?)))
                    )
               (set-action!
                 *gui-control*
                 (gui-action stop)
                 (the-as sound-id (-> self lightjak on-off))
                 (gui-channel none)
                 (gui-action none)
                 (the-as string #f)
                 (the-as (function gui-connection symbol) #f)
                 (the-as process #f)
                 )
               (sound-play "ljak-off")
               )
              ((= v1-14 (gui-status pending))
               (set-action!
                 *gui-control*
                 (gui-action play)
                 (the-as sound-id (-> self lightjak on-off))
                 (gui-channel none)
                 (gui-action none)
                 (the-as string #f)
                 (the-as (function gui-connection symbol) #f)
                 (the-as process #f)
                 )
               )
              (else
                (set-action!
                  *gui-control*
                  (gui-action stop)
                  (the-as sound-id (-> self lightjak on-off))
                  (gui-channel none)
                  (gui-action none)
                  (the-as string #f)
                  (the-as (function gui-connection symbol) #f)
                  (the-as process #f)
                  )
                (add-process *gui-control* self (gui-channel jak-effect-2) (gui-action play) "jak-onof" -99.0 0)
                )
              )
            )
          (if (logtest? (-> *part-group-id-table* 176 flags) (sp-group-flag sp13))
              (part-tracker-spawn
                part-tracker-subsampler
                :to self
                :group (-> *part-group-id-table* 176)
                :target self
                :mat-joint 6
                )
              (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 176) :target self :mat-joint 6)
              )
          )
        (logclear! (-> self target-effect) (target-effect te1))
        (logclear! (-> self target-effect) (target-effect te4))
        )
      )
    (when (and (< 0.0 f30-0) (and (not (focus-test? self in-head))
                                  (not (logtest? (-> self draw status) (draw-control-status no-draw no-draw-temp)))
                                  (not (movie?))
                                  (< (-> *setting-control* user-current slow-time) 1.0)
                                  )
               )
      (let ((gp-3 (new 'stack-no-clear 'vector))
            (f30-1 (fmin 1.0 (-> self clock clock-ratio)))
            )
        (set! (-> (get-field-spec-by-id (-> *part-id-table* 623) (sp-field-id spt-a)) initial-valuef)
              (* 16.0 (- 1.0 (-> *setting-control* user-current slow-time)))
              )
        (launch-particles (-> *part-id-table* 623) (vector<-cspace! gp-3 (joint-node jakb-lod0-jg main)) :rate f30-1)
        (launch-particles
          (-> *part-id-table* 623)
          (vector<-cspace! gp-3 (joint-node jakb-lod0-jg upper_body))
          :rate f30-1
          )
        (launch-particles (-> *part-id-table* 623) (vector<-cspace! gp-3 (joint-node jakb-lod0-jg chest)) :rate f30-1)
        (launch-particles (-> *part-id-table* 623) (vector<-cspace! gp-3 (joint-node jakb-lod0-jg neckA)) :rate f30-1)
        (launch-particles
          (-> *part-id-table* 623)
          (vector<-cspace! gp-3 (joint-node jakb-lod0-jg MhairA))
          :rate f30-1
          )
        (launch-particles
          (-> *part-id-table* 623)
          (vector<-cspace! gp-3 (joint-node jakb-lod0-jg MhairB))
          :rate f30-1
          )
        (launch-particles
          (-> *part-id-table* 623)
          (vector<-cspace! gp-3 (joint-node jakb-lod0-jg Lshould))
          :rate f30-1
          )
        (launch-particles
          (-> *part-id-table* 623)
          (vector<-cspace! gp-3 (joint-node jakb-lod0-jg Rshould))
          :rate f30-1
          )
        (launch-particles (-> *part-id-table* 623) (vector<-cspace! gp-3 (joint-node jakb-lod0-jg Larm)) :rate f30-1)
        (launch-particles (-> *part-id-table* 623) (vector<-cspace! gp-3 (joint-node jakb-lod0-jg Rarm)) :rate f30-1)
        (launch-particles
          (-> *part-id-table* 623)
          (vector<-cspace! gp-3 (joint-node jakb-lod0-jg Lforarm))
          :rate f30-1
          )
        (launch-particles
          (-> *part-id-table* 623)
          (vector<-cspace! gp-3 (joint-node jakb-lod0-jg Rforarm))
          :rate f30-1
          )
        (launch-particles (-> *part-id-table* 623) (vector<-cspace! gp-3 (joint-node jakb-lod0-jg hips)) :rate f30-1)
        (launch-particles
          (-> *part-id-table* 623)
          (vector<-cspace! gp-3 (joint-node jakb-lod0-jg Lthigh))
          :rate f30-1
          )
        (launch-particles
          (-> *part-id-table* 623)
          (vector<-cspace! gp-3 (joint-node jakb-lod0-jg Rthigh))
          :rate f30-1
          )
        (launch-particles (-> *part-id-table* 623) (vector<-cspace! gp-3 (joint-node jakb-lod0-jg Lknee)) :rate f30-1)
        (launch-particles (-> *part-id-table* 623) (vector<-cspace! gp-3 (joint-node jakb-lod0-jg Rknee)) :rate f30-1)
        (launch-particles
          (-> *part-id-table* 623)
          (vector<-cspace! gp-3 (joint-node jakb-lod0-jg Lankle))
          :rate f30-1
          )
        (launch-particles
          (-> *part-id-table* 623)
          (vector<-cspace! gp-3 (joint-node jakb-lod0-jg Rankle))
          :rate f30-1
          )
        (launch-particles (-> *part-id-table* 623) (vector<-cspace! gp-3 (joint-node jakb-lod0-jg Ltoes)) :rate f30-1)
        (launch-particles (-> *part-id-table* 623) (vector<-cspace! gp-3 (joint-node jakb-lod0-jg Rtoes)) :rate f30-1)
        )
      )
    )
  (none)
  )

;; definition for function target-lightjak-process
;; WARN: Return type mismatch int vs none.
(defbehavior target-lightjak-process target ()
  (if (and (not (cpad-hold? (-> self control cpad number) l2))
           (not (and (-> self next-state) (= (-> self next-state name) 'target-powerjak-get-on)))
           )
      (set! (-> self lightjak get-off-lock) #f)
      )
  (cond
    ((nonzero? (-> self lightjak latch-out-time))
     (if (time-elapsed? (-> self lightjak latch-out-time) (seconds 0.4))
         (target-lightjak-end-mode #t)
         )
     )
    ((and (focus-test? self light) (nonzero? (-> self lightjak)))
     (let ((a1-0 'eco-red))
       (target-danger-set! (-> self control danger-mode) a1-0)
       )
     (update-transforms (-> self control))
     (let ((a1-1 (new 'stack-no-clear 'overlaps-others-params)))
       (set! (-> a1-1 options) (overlaps-others-options))
       (set! (-> a1-1 collide-with-filter) (the-as collide-spec -1))
       (set! (-> a1-1 tlist) *touching-list*)
       (find-overlapping-shapes (-> self control) a1-1)
       )
     (target-danger-set! (-> self control danger-mode) #f)
     (update-transforms (-> self control))
     (when (and (or (< (-> self game eco-pill-light) 1.0)
                    (not (-> *setting-control* user-current lightjak))
                    (not (logtest? (the-as game-feature (logand (game-feature lightjak) (-> *setting-control* user-current features)))
                                   (-> self game features)
                                   )
                         )
                    )
                (and (not (focus-test? self dead dangerous hit grabbed))
                     (not (and (-> self next-state)
                               (let ((v1-50 (-> self next-state name)))
                                 (or (= v1-50 'target-lightjak-get-on)
                                     (= v1-50 'target-lightjak-get-off)
                                     (= v1-50 'target-lightjak-swoop)
                                     (= v1-50 'target-lightjak-swoop-again)
                                     (= v1-50 'target-lightjak-swoop-falling)
                                     (= v1-50 'target-lightjak-freeze)
                                     (= v1-50 'target-lightjak-regen)
                                     )
                                 )
                               )
                          )
                     (or (not (logtest? (-> self lightjak stage) (lightjak-stage ls0 ls1)))
                         (not (-> *setting-control* user-current lightjak))
                         (not (logtest? (the-as game-feature (logand (game-feature lightjak) (-> *setting-control* user-current features)))
                                        (-> self game features)
                                        )
                              )
                         )
                     )
                )
       (if (and (and (-> self next-state) (let ((v1-61 (-> self next-state name)))
                                            (or (= v1-61 'target-stance) (= v1-61 'target-hit-ground))
                                            )
                     )
                (not (handle->process (-> self lightjak freeze-control)))
                )
           (go target-lightjak-get-off)
           (target-lightjak-end-mode #f)
           )
       )
     )
    (else
      (set! (-> self lightjak-interp) 0.0)
      )
    )
  (when (nonzero? (-> self lightjak shield-start-time))
    (set-time! (-> self fact shield-use-time))
    (set-time! (-> self water distort-time))
    (target-gun-end-mode #t)
    (if (-> self lightjak shield)
        (send-event (ppointer->process (-> self lightjak shield)) 'open)
        (set! (-> self lightjak shield)
              (process-spawn lightjak-shield :init lightjak-shield-init :name "lightjak-shield" :to self)
              )
        )
    (when (time-elapsed? (-> self lightjak shield-count-time) (seconds 0.33))
      (let* ((v1-93 (-> self game))
             (a0-46 (+ (-> v1-93 attack-id) 1))
             )
        (set! (-> v1-93 attack-id) a0-46)
        (set! (-> self fact shield-attack-id) a0-46)
        )
      (if (not (logtest? (-> self lightjak stage) (lightjak-stage ls1)))
          (send-event self 'get-pickup (pickup-type eco-pill-light) (/ (-> *FACT-bank* lightjak-shield-inc) -3))
          )
      (set-time! (-> self lightjak shield-count-time))
      )
    (when (not (and (and (focus-test? self light) (nonzero? (-> self lightjak)))
                    (and (logtest? (game-feature lightjak-shield) (-> self game features))
                         (or (cpad-hold? (-> self control cpad number) circle)
                             (and (and (focus-test? self light)
                                       (nonzero? (-> self lightjak))
                                       (logtest? (-> self lightjak stage) (lightjak-stage ls6))
                                       )
                                  (not (time-elapsed? (-> self lightjak start-time) (seconds 3)))
                                  )
                             )
                         (>= (-> self game eco-pill-light) (-> *FACT-bank* lightjak-shield-inc))
                         (not (handle->process (-> self lightjak freeze-control)))
                         )
                    )
               )
      (send-event (ppointer->process (-> self lightjak shield)) 'close)
      (set! (-> self fact shield-level) 0.0)
      (set! (-> self lightjak shield-start-time) 0)
      (remove-setting! 'attack)
      (apply-settings *setting-control*)
      )
    )
  (when (and (zero? (-> self lightjak shield-start-time))
             (zero? (-> self lightjak latch-out-time))
             (logtest? (game-feature lightjak-shield) (-> self game features))
             (and (focus-test? self light) (nonzero? (-> self lightjak)))
             (or (cpad-hold? (-> self control cpad number) circle)
                 (and (and (focus-test? self light)
                           (nonzero? (-> self lightjak))
                           (logtest? (-> self lightjak stage) (lightjak-stage ls6))
                           )
                      (not (time-elapsed? (-> self lightjak start-time) (seconds 3)))
                      )
                 )
             (>= (-> self game eco-pill-light) 1.0)
             (not (and (-> self next-state)
                       (let ((v1-189 (-> self next-state name)))
                         (or (= v1-189 'target-flop)
                             (= v1-189 'target-lightjak-freeze)
                             (= v1-189 'target-lightjak-shield)
                             (= v1-189 'target-lightjak-regen)
                             (= v1-189 'target-lightjak-get-off)
                             )
                         )
                       )
                  )
             (and (not (handle->process (-> self lightjak freeze-control)))
                  (= (-> self ext-anim) (target-anim light))
                  (time-elapsed? (-> self lightjak regen-time) (seconds 0.5))
                  )
             )
    (set-time! (-> self lightjak shield-start-time))
    (set! (-> self lightjak shield-count-time) 0)
    (set! (-> self fact shield-level) 1.0)
    (let* ((v1-205 (-> self game))
           (a0-94 (+ (-> v1-205 attack-id) 1))
           )
      (set! (-> v1-205 attack-id) a0-94)
      (set! (-> self fact shield-attack-id) a0-94)
      )
    (set-setting! 'attack #f 0.0 0)
    (apply-settings *setting-control*)
    (set! (-> self fact lightjak-effect-time)
          (+ (- (seconds 20) (-> self fact lightjak-start-time)) (current-time))
          )
    (when (and (time-elapsed? (-> self fact shield-use-time) (seconds 0.1))
               (and (-> self next-state) (let ((v1-221 (-> self next-state name)))
                                           (or (= v1-221 'target-stance)
                                               (= v1-221 'target-jump)
                                               (= v1-221 'target-falling)
                                               (= v1-221 'target-hit-ground)
                                               (= v1-221 'target-double-jump)
                                               )
                                           )
                    )
               (>= (-> self control last-time-on-surface) (-> self fact shield-start-time))
               )
      (set-time! (-> self fact shield-start-time))
      (go target-lightjak-shield)
      )
    )
  (target-lightjak-do-effect)
  0
  (none)
  )

;; failed to figure out what this is:
(defstate target-lightjak-get-on (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('lightjak)
       (when (zero? (-> self lightjak want-stage))
         (set! (-> self lightjak want-stage) (the-as lightjak-stage (-> block param 0)))
         #t
         )
       )
      (('touched)
       (if ((method-of-type touching-shapes-entry prims-touching?)
            (the-as touching-shapes-entry (-> block param 0))
            (-> self control)
            (the-as uint 1920)
            )
           (target-send-attack
             proc
             (-> self control danger-mode)
             (the-as touching-shapes-entry (-> block param 0))
             (the-as int (-> self control target-attack-id))
             (the-as int (-> self control attack-count))
             (-> self control penetrate-using)
             )
           (target-generic-event-handler proc argc message block)
           )
       )
      (('attack-invinc)
       (target-attacked
         message
         (the-as attack-info (-> block param 1))
         proc
         (the-as touching-shapes-entry (-> block param 0))
         target-hit
         )
       )
      (else
        (target-generic-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ((arg0 lightjak-stage))
    (set! (-> self control lightjak-sound-id) (new 'static 'sound-id))
    0
    )
  :exit (behavior ()
    (let ((v1-0 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-0 command) (sound-command set-param))
      (set! (-> v1-0 id) (-> self control unknown-sound-id00))
      (set! (-> v1-0 params volume) -4)
      (set! (-> v1-0 auto-time) 48)
      (set! (-> v1-0 auto-from) 2)
      (set! (-> v1-0 params mask) (the-as uint 17))
      (-> v1-0 id)
      )
    (when (nonzero? (-> self control lightjak-sound-id))
      (set-action!
        *gui-control*
        (gui-action fade)
        (-> self control lightjak-sound-id)
        (gui-channel none)
        (gui-action none)
        (the-as string #f)
        (the-as (function gui-connection symbol) #f)
        (the-as process #f)
        )
      (set! (-> self control lightjak-sound-id) (new 'static 'sound-id))
      0
      )
    (remove-setting! 'process-mask)
    (logclear! (-> self target-flags) (target-flags tf4))
    (logclear! (-> self target-flags) (target-flags lleg-still rleg-still))
    (set! (-> self lightjak-interp) 1.0)
    (target-danger-set! 'harmless #f)
    (set! (-> self control dynam gravity-max) (-> self control standard-dynamics gravity-max))
    (set! (-> self control dynam gravity-length) (-> self control standard-dynamics gravity-length))
    (remove-setting! 'gun)
    (persist-with-delay *setting-control* 'gun (seconds 0.5) 'gun #f 0.0 0)
    (apply-settings *setting-control*)
    (target-gun-end-mode #t)
    )
  :code (behavior ((arg0 lightjak-stage))
    (set! (-> self control unknown-sound-id00) (new 'static 'sound-id))
    (set-setting! 'gun #f 0.0 0)
    (apply-settings *setting-control*)
    (target-darkjak-end-mode #t)
    (send-event (handle->process (-> self notify)) 'notify 'attack 24)
    (set! (-> self lightjak stage) (logior arg0 (lightjak-stage ls2)))
    (set! (-> self neck flex-blend) 0.0)
    (set! (-> self control mod-surface) *lightjak-trans-mods*)
    (set-time! (-> self lightjak start-time))
    (set! (-> self lightjak attack-count) 0)
    (set! (-> self lightjak latch-out-time) 0)
    (logior! (-> self focus-status) (focus-status light))
    (set! (-> self pending-ext-anim) (target-anim light))
    (set-time! (-> self fact lightjak-start-time))
    (set! (-> self fact lightjak-effect-time) (seconds 20))
    (set! (-> self lightjak mode-sound-bank) (add-setting! 'mode-sound-bank 'modelit 0.0 0))
    (target-start-attack)
    (target-danger-set! 'get-on #f)
    (cond
      ((logtest? arg0 (lightjak-stage freeze))
       )
      (else
        (set-setting! 'process-mask 'set 0.0 (process-mask enemy platform projectile guard vehicle))
        )
      )
    (logior! (-> self target-flags) (target-flags tf4))
    (when (logtest? arg0 (lightjak-stage ls7))
      (set! (-> self post-hook) target-no-move-post)
      (while (!= (-> self ext-anim) (target-anim light))
        (if (= (-> self prev-state name) 'target-continue)
            (set-blackout-frames (seconds 0.1))
            )
        (suspend)
        )
      (if (and (not (-> self lightjak wings)) (logtest? arg0 (lightjak-stage swoop)))
          (set! (-> self lightjak wings) (process-spawn wings :init wings-init 'force :name "wings" :to self))
          )
      (go target-stance)
      )
    (set! (-> self control unknown-sound-id00) (sound-play "jak-suspend"))
    (set! (-> self lightjak on-off)
          (the-as
            uint
            (add-process *gui-control* self (gui-channel jak-effect-1) (gui-action queue) "jak-onof" -99.0 0)
            )
          )
    (set-forward-vel 0.0)
    (ja-channel-push! 1 (seconds 0.1))
    (let ((f30-0 (if (logtest? arg0 (lightjak-stage swoop))
                     2.0
                     1.0
                     )
                 )
          )
      (ja-no-eval :group! jakb-lightjak-get-on-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (compute-alignment! (-> self align))
        (align! (-> self align) (align-opts adjust-y-vel) 1.0 f30-0 1.0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (set! (-> self control dynam gravity-max) 0.0)
    (set! (-> self control dynam gravity-length) 0.0)
    (set! (-> self control transv quad) (the-as uint128 0))
    (let ((s5-2
            (if (logtest? (-> *part-group-id-table* 174 flags) (sp-group-flag sp13))
                (part-tracker-spawn
                  part-tracker-subsampler
                  :to self
                  :group (-> *part-group-id-table* 174)
                  :target self
                  :mat-joint 6
                  )
                (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 174) :target self :mat-joint 6)
                )
            )
          )
      (while (!= (-> self ext-anim) (target-anim light))
        (let ((v1-117 (point-off-screen (new 'stack-no-clear 'vector))))
          (set! (-> *part-id-table* 630 init-specs 9 initial-valuef)
                (* 1.1 (- (-> v1-117 y) (-> self control trans y)))
                )
          (set! (-> *part-id-table* 631 init-specs 9 initial-valuef)
                (* 1.1 (- (-> v1-117 y) (-> self control trans y)))
                )
          (set! (-> *part-id-table* 632 init-specs 9 initial-valuef)
                (* 1.1 (- (-> v1-117 y) (-> self control trans y)))
                )
          (set! (-> *part-id-table* 633 init-specs 9 initial-valuef)
                (* 1.1 (- (-> v1-117 y) (-> self control trans y)))
                )
          )
        (let ((v1-125 (ja-group)))
          (when (not (and v1-125 (= v1-125 jakb-lightjak-get-on-loop-ja)))
            (ja-channel-push! 1 (seconds 0.05))
            (ja :group! jakb-lightjak-get-on-loop-ja :num! min)
            )
          )
        (suspend)
        (ja :num! (loop!))
        )
      (send-event (ppointer->process s5-2) 'die)
      )
    (let ((v1-144 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-144 command) (sound-command set-param))
      (set! (-> v1-144 id) (-> self control unknown-sound-id00))
      (set! (-> v1-144 params volume) -4)
      (set! (-> v1-144 auto-time) 48)
      (set! (-> v1-144 auto-from) 2)
      (set! (-> v1-144 params mask) (the-as uint 17))
      (-> v1-144 id)
      )
    (set! (-> self control unknown-sound-id00) (new 'static 'sound-id))
    (set! (-> self lightjak-interp) 1.0)
    (add-connection
      *part-engine*
      self
      8
      self
      650
      (new 'static 'vector :x 278.528 :y 643.072 :z 757.76 :w 163840.0)
      )
    (add-connection
      *part-engine*
      self
      8
      self
      650
      (new 'static 'vector :x -278.528 :y 643.072 :z 757.76 :w 163840.0)
      )
    (let ((v1-154 (log2 (the-as int (-> self draw mgeo seg-table (log2 8))))))
      (logior! (-> self draw mgeo effect v1-154 effect-usage) 8)
      )
    (set-action!
      *gui-control*
      (gui-action play)
      (the-as sound-id (-> self lightjak on-off))
      (gui-channel none)
      (gui-action none)
      (the-as string #f)
      (the-as (function gui-connection symbol) #f)
      (the-as process #f)
      )
    (if (logtest? (-> *part-group-id-table* 175 flags) (sp-group-flag sp13))
        (part-tracker-spawn
          part-tracker-subsampler
          :to self
          :group (-> *part-group-id-table* 175)
          :target self
          :mat-joint 6
          )
        (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 175) :target self :mat-joint 6)
        )
    (cond
      ((logtest? arg0 (lightjak-stage regen))
       (go target-lightjak-regen (the-as int (-> self control lightjak-sound-id)))
       )
      ((logtest? arg0 (lightjak-stage freeze))
       (go target-lightjak-freeze)
       )
      (else
        (set! (-> self control dynam gravity-max) (-> self control standard-dynamics gravity-max))
        (set! (-> self control dynam gravity-length) (-> self control standard-dynamics gravity-length))
        )
      )
    (ja-no-eval :group! jakb-lightjak-get-on-out-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (if (and (not (-> self lightjak wings)) (logtest? arg0 (lightjak-stage swoop)))
        (set! (-> self lightjak wings) (process-spawn wings :init wings-init 'open :name "wings" :to self))
        )
    (ja-no-eval :group! jakb-lightjak-get-on-land-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (if (and (!= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0) (< 31.0 (ja-aframe-num 0)))
          (goto cfg-81)
          )
      (suspend)
      (ja :num! (seek!))
      )
    (label cfg-81)
    (go target-stance)
    )
  :post target-no-stick-post
  )

;; failed to figure out what this is:
(defstate target-lightjak-get-off (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('pole-grab 'lightjak 'slide 'wade 'launch 'edge-grab)
       #f
       )
      (('change-mode)
       (case (-> block param 0)
         (('grab)
          (when (not (focus-test? self dead))
            (if (not (-> block param 1))
                #t
                (go target-grab 'stance)
                )
            )
          )
         )
       )
      (('attack-invinc)
       (target-attacked
         message
         (the-as attack-info (-> block param 1))
         proc
         (the-as touching-shapes-entry (-> block param 0))
         target-hit
         )
       )
      (else
        (target-generic-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (logior! (-> self target-flags) (target-flags lleg-still rleg-still))
    (set! (-> self neck flex-blend) 0.0)
    (set! (-> self control mod-surface) *lightjak-trans-mods*)
    (case (get-status *gui-control* (the-as sound-id (-> self lightjak on-off)))
      (((gui-status pending) (gui-status ready) (gui-status active))
       )
      (else
        (set! (-> self lightjak on-off)
              (the-as
                uint
                (add-process *gui-control* self (gui-channel jak-effect-1) (gui-action queue) "jak-onof" -99.0 0)
                )
              )
        )
      )
    )
  :exit (behavior ()
    (logclear! (-> self target-flags) (target-flags lleg-still rleg-still))
    (target-lightjak-end-mode #t)
    )
  :trans (-> target-lightjak-get-on trans)
  :code (behavior ()
    (let ((v1-1 (-> self water flags)))
      (cond
        ((and (logtest? (water-flag touch-water) v1-1)
              (logtest? (water-flag under-water swimming) v1-1)
              (not (logtest? (focus-status mech) (-> self focus-status)))
              )
         (go target-swim-stance)
         )
        ((let ((v1-10 (ja-group)))
           (not (and v1-10 (= v1-10 jakb-lightjak-get-on-ja)))
           )
         (let ((gp-0 0))
           (while (not (logtest? (-> self control status) (collide-status on-surface)))
             (target-falling-anim-trans)
             (+! gp-0 (- (current-time) (-> self clock old-frame-counter)))
             (if (>= gp-0 300)
                 (go target-falling #f)
                 )
             (suspend)
             )
           )
         )
        )
      )
    (vector-reset! (-> self control transv))
    ((-> target-lightjak-get-off exit))
    (cond
      ((logtest? (-> self control status) (collide-status on-water))
       )
      (else
        (let ((v1-33 (ja-group)))
          (cond
            ((and v1-33 (= v1-33 jakb-lightjak-get-on-ja))
             (ja-no-eval :num! (seek! 0.0))
             (while (not (ja-done? 0))
               (seek! (-> self lightjak-interp) 0.0 (* 2.0 (seconds-per-frame)))
               (suspend)
               (ja-eval)
               )
             (ja-channel-push! 1 (seconds 0.1))
             )
            (else
              (if (-> self lightjak wings)
                  (sound-play "ltjak-wings-in")
                  )
              (ja-channel-push! 1 (seconds 0.05))
              (ja-no-eval :group! jakb-lightjak-get-off-ja :num! (seek!) :frame-num 0.0)
              (until (ja-done? 0)
                (set! (-> self lightjak-interp) (lerp-scale 1.0 0.0 (ja-aframe-num 0) 10.0 60.0))
                (if (and (>= (ja-aframe-num 0) 24.0)
                         (!= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
                         (= (-> self lightjak-interp) 0.0)
                         )
                    (goto cfg-49)
                    )
                (suspend)
                (ja :num! (seek!))
                )
              )
            )
          )
        )
      )
    (label cfg-49)
    (go target-stance)
    )
  :post (-> target-grab post)
  )

;; definition for symbol *lightjak-swoop-mods*, type surface
(define *lightjak-swoop-mods* (new 'static 'surface
                                :name 'swoop
                                :turnv 32768.0
                                :turnvf 90.0
                                :turnvv 18204.445
                                :turnvvf 30.0
                                :tiltv 32768.0
                                :tiltvf 150.0
                                :tiltvv 262144.0
                                :tiltvvf 15.0
                                :transv-max 32768.0
                                :target-speed 32768.0
                                :seek0 0.3
                                :seek90 0.3
                                :seek180 0.3
                                :fric 0.2
                                :nonlin-fric-dist 1.0
                                :slip-factor 1.0
                                :slide-factor 1.0
                                :slope-up-factor 1.0
                                :slope-down-factor 1.0
                                :slope-slip-angle 1.0
                                :impact-fric 1.0
                                :bend-factor 1.0
                                :bend-speed 1.0
                                :alignv 1.0
                                :slope-up-traction 1.0
                                :align-speed 1.0
                                :mode 'air
                                :flags (surface-flag check-edge air gun-off no-board)
                                )
        )

;; failed to figure out what this is:
(defstate target-lightjak-swoop (target)
  :event target-jump-event-handler
  :enter (behavior ((arg0 float))
    (set-time! (-> self state-time))
    (set-setting! 'gun #f 0.0 0)
    (set-setting! 'board #f 0.0 0)
    (apply-settings *setting-control*)
    (set! (-> self lightjak get-off-lock) #t)
    (set! (-> self fact lightjak-effect-time)
          (+ (- (seconds 20) (-> self fact lightjak-start-time)) (current-time))
          )
    (if (not (-> self lightjak wings))
        (set! (-> self lightjak wings) (process-spawn wings :init wings-init 'open :name "wings" :to self))
        )
    (when (and (-> self next-state) (= (-> self next-state name) 'target-lightjak-swoop))
      (if (not (logtest? (-> self lightjak stage) (lightjak-stage ls1)))
          (send-event self 'get-pickup (pickup-type eco-pill-light) (- (-> *FACT-bank* lightjak-swoop-inc)))
          )
      (send-event (ppointer->process (-> self lightjak wings)) 'open)
      )
    (set! (-> self control unknown-word04) (the-as uint #t))
    (set-time! (-> self control sliding-start-time))
    (set! (-> self control unknown-symbol03)
          (vector-dot (-> self control dynam gravity-normal) (-> self control transv))
          )
    (+! (-> self lightjak swoop-count) 1)
    (let ((f30-0 163840.0))
      (let ((f0-6 (if (and (-> self next-state) (= (-> self next-state name) 'target-lightjak-swoop))
                      1.4
                      (lerp-scale 0.0 1.0 (* arg0 arg0) 0.25 0.95)
                      )
                  )
            )
        (set! (-> self control unknown-float35) (* 0.0016666667 (* 285.0 f0-6) f30-0))
        )
      (set! (-> self control dynam gravity-max) 245760.0)
      (set! (-> self control dynam gravity-length) f30-0)
      )
    (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (set! (-> self control mod-surface) *lightjak-swoop-mods*)
    (set-setting! 'string-min-height 'low (meters 1) 0)
    (set-setting! 'string-max-height 'low (meters 10) 0)
    (set! (-> self control last-trans-any-surf quad) (-> self control trans quad))
    )
  :exit (behavior ()
    (remove-setting! 'board)
    (remove-setting! 'gun)
    (when (not (and (-> self next-state) (let ((v1-7 (-> self next-state name)))
                                           (or (= v1-7 'target-lightjak-swoop) (= v1-7 'target-lightjak-swoop-again))
                                           )
                    )
               )
      (set! (-> self control dynam gravity-max) (-> self control standard-dynamics gravity-max))
      (set! (-> self control dynam gravity-length) (-> self control standard-dynamics gravity-length))
      (remove-setting! 'string-min-height)
      (remove-setting! 'string-max-height)
      )
    (target-exit)
    )
  :trans (behavior ()
    (if (logtest? (-> self control status) (collide-status on-surface))
        (go target-hit-ground #f)
        )
    (if #t
        (set-time! (-> self control sliding-start-time))
        (set! (-> self control unknown-word04) (the-as uint #f))
        )
    (when (time-elapsed? (-> self control sliding-start-time) (seconds 0.2))
      (set! (-> self control dynam gravity-max) (-> self control standard-dynamics gravity-max))
      (set! (-> self control dynam gravity-length) (-> self control standard-dynamics gravity-length))
      )
    (if (or (and (< (vector-dot (-> self control dynam gravity-normal) (-> self control transv)) 0.0)
                 (and (< (target-height-above-ground) 4096.0)
                      (or (= (-> self control gspot-pat-surfce mode) (pat-mode ground))
                          (= (-> self control gspot-pat-surfce mode) (pat-mode halfpipe))
                          )
                      )
                 )
            (!= (-> self fact shield-level) 0.0)
            )
        (go target-lightjak-swoop-falling #f)
        )
    0
    )
  :code (behavior ((arg0 float))
    (sound-play "ltjak-flap")
    (ja-channel-push! 1 (seconds 0.05))
    (ja-no-eval :group! jakb-lightjak-swoop1-ja :num! (seek!) :frame-num 0.0)
    (let ((v1-16 (new-stack-vector0)))
      (let ((f0-5 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
        0.0
        (vector-! v1-16 (-> self control transv) (vector-float*! v1-16 (-> self control dynam gravity-normal) f0-5))
        )
      (let* ((f0-6 (vector-length v1-16))
             (f1-1 f0-6)
             (f2-0 (-> self control unknown-float35))
             )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-0)
          (vector-float*! v1-16 v1-16 (/ f0-6 f1-1))
          )
        )
      )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      (if (and (cpad-pressed? (-> self control cpad number) x) (time-elapsed? (-> self state-time) (seconds 0.5)))
          (go
            target-lightjak-swoop-again
            (* 0.0033333334 (the float (- (-> self control sliding-start-time) (-> self state-time))))
            )
          )
      )
    (go target-lightjak-swoop-falling #f)
    )
  :post target-post
  )

;; failed to figure out what this is:
(defstate target-lightjak-swoop-again (target)
  :event target-jump-event-handler
  :enter (-> target-lightjak-swoop enter)
  :exit (-> target-lightjak-swoop exit)
  :trans (-> target-lightjak-swoop trans)
  :code (behavior ((arg0 float))
    (sound-play "ltjak-flap")
    (let ((f30-0 44.0))
      (let ((a1-1 6))
        (let ((v1-4 (ja-group)))
          (cond
            ((and v1-4 (= v1-4 jakb-lightjak-swoop1-ja))
             (set! f30-0 (lerp-scale 48.0 44.0 (ja-aframe-num 0) 30.0 44.0))
             (set! a1-1 30)
             )
            ((let ((v1-11 (ja-group)))
               (and v1-11 (= v1-11 jakb-lightjak-swoop2-ja))
               )
             (set! f30-0 (lerp-scale 48.0 44.0 (ja-aframe-num 0) 54.0 74.0))
             (set! a1-1 30)
             )
            ((let ((v1-18 (ja-group)))
               (and v1-18 (or (= v1-18 jakb-lightjak-swoop-fall-ja) (= v1-18 jakb-lightjak-swoop-fall-loop-ja)))
               )
             (ja-channel-push! 1 (seconds 0.2))
             (ja-no-eval :group! jakb-lightjak-swoop2-ja :num! (seek! max 2.0) :frame-num (ja-aframe 69.0 0))
             (until (ja-done? 0)
               (let ((v1-37 (new-stack-vector0))
                     (f0-5 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                     )
                 0.0
                 (vector-! v1-37 (-> self control transv) (vector-float*! v1-37 (-> self control dynam gravity-normal) f0-5))
                 (let* ((f1-2 (vector-length v1-37))
                        (f2-0 f1-2)
                        (f0-6 (* 0.95 f0-5))
                        )
                   (vector+!
                     (-> self control transv)
                     (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-6)
                     (vector-float*! v1-37 v1-37 (/ f1-2 f2-0))
                     )
                   )
                 )
               (suspend)
               (ja :num! (seek! max 2.0))
               )
             (set! a1-1 0)
             )
            )
          )
        (ja-channel-push! 1 (the-as time-frame a1-1))
        )
      (ja-no-eval :group! jakb-lightjak-swoop2-ja :num! (seek!) :frame-num (ja-aframe f30-0 0))
      )
    (while (< (ja-aframe-num 0) 48.0)
      (suspend)
      (ja :num! (seek!))
      )
    (let ((v1-73 (new-stack-vector0)))
      (let ((f0-20 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
        0.0
        (vector-! v1-73 (-> self control transv) (vector-float*! v1-73 (-> self control dynam gravity-normal) f0-20))
        )
      (let* ((f0-21 (vector-length v1-73))
             (f1-5 f0-21)
             (f2-1 (-> self control unknown-float35))
             )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-1)
          (vector-float*! v1-73 v1-73 (/ f0-21 f1-5))
          )
        )
      )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      (if (and (cpad-pressed? (-> self control cpad number) x)
               (time-elapsed? (-> self state-time) (seconds 0.5))
               (and (>= (ja-aframe-num 0) 54.0) 0)
               )
          (go
            target-lightjak-swoop-again
            (* 0.0033333334 (the float (- (-> self control sliding-start-time) (-> self state-time))))
            )
          )
      )
    (go target-lightjak-swoop-falling #f)
    )
  :post target-post
  )

;; failed to figure out what this is:
(defstate target-lightjak-swoop-falling (target)
  :event target-jump-event-handler
  :enter (behavior ((arg0 symbol))
    (set-setting! 'gun #f 0.0 0)
    (set-setting! 'board #f 0.0 0)
    (apply-settings *setting-control*)
    (set! (-> self control mod-surface) *jump-mods*)
    (set! (-> self control unknown-word04) (the-as uint arg0))
    (set-time! (-> self state-time))
    )
  :exit (-> target-lightjak-swoop exit)
  :trans (behavior ()
    (if (and (cpad-pressed? (-> self control cpad number) x)
             (not (and (< (target-height-above-ground) 8192.0)
                       (or (= (-> self control gspot-pat-surfce mode) (pat-mode ground))
                           (= (-> self control gspot-pat-surfce mode) (pat-mode halfpipe))
                           )
                       )
                  )
             (= (-> self fact shield-level) 0.0)
             )
        (go target-lightjak-swoop-again 1.0)
        )
    (target-falling-trans
      (the-as symbol (-> self control unknown-spool-anim00))
      (the-as time-frame (if (= (-> self control unknown-spool-anim00) #f)
                             0
                             (the-as int (/ (the-as int (-> *TARGET-bank* stuck-time)) 2))
                             )
              )
      #f
      )
    )
  :code (behavior ((arg0 symbol))
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! jakb-lightjak-swoop-fall-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (until #f
      (ja-no-eval :group! jakb-lightjak-swoop-fall-loop-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post target-post
  )

;; definition of type freeze-screen
(deftype freeze-screen (process-drawable)
  ((anim-frame  float)
   (transition  float)
   (gui-id-1    sound-id)
   (gui-id-2    sound-id)
   )
  (:state-methods
    idle
    active
    (deactive symbol)
    die
    )
  (:methods
    (freeze-screen-method-24 (_type_) none)
    )
  )

;; definition for method 3 of type freeze-screen
(defmethod inspect ((this freeze-screen))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tanim-frame: ~f~%" (-> this anim-frame))
  (format #t "~2Ttransition: ~f~%" (-> this transition))
  (format #t "~2Tgui-id-1: ~D~%" (-> this gui-id-1))
  (format #t "~2Tgui-id-2: ~D~%" (-> this gui-id-2))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-freeze-screen collectables collectables-warp-time-lod0-jg collectables-warp-time-idle-ja
              ((collectables-warp-time-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 8)
              )

;; failed to figure out what this is:
(defstate idle (freeze-screen)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (set-time! (-> self state-time))
       (go-virtual active)
       )
      (('die)
       (go-virtual die)
       )
      (('untrigger)
       (if (-> block param 0)
           (go-virtual die)
           )
       )
      )
    )
  :enter (behavior ()
    (logior! (-> self draw status) (draw-control-status no-draw))
    (set! (-> self transition) 0.0)
    )
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate active (freeze-screen)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('untrigger)
       (go-virtual deactive (the-as symbol (-> block param 0)))
       )
      (('die)
       (go-virtual die)
       )
      )
    )
  :enter (behavior ()
    (logclear! (-> self draw status) (draw-control-status no-draw))
    )
  :code (behavior ()
    (until #f
      (set! (-> self anim-frame) (* 15.0 (- 1.0 (-> *setting-control* user-current slow-time))))
      (set! (-> self transition) (-> *setting-control* user-current slow-time))
      (ja :num-func num-func-identity :frame-num (-> self anim-frame))
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (freeze-screen-method-24 self)
    (ja-post)
    )
  )

;; failed to figure out what this is:
(defstate deactive (freeze-screen)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('die)
       (go-virtual die)
       )
      )
    )
  :code (behavior ((arg0 symbol))
    (until #f
      (set! (-> self anim-frame) (* 15.0 (- 1.0 (-> *setting-control* user-current slow-time))))
      (set! (-> self transition) (-> *setting-control* user-current slow-time))
      (when (= (-> self anim-frame) 15.0)
        (if arg0
            (go-virtual die)
            (go-virtual idle)
            )
        )
      (ja :num-func num-func-identity :frame-num (-> self anim-frame))
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (freeze-screen-method-24 self)
    (ja-post)
    )
  )

;; failed to figure out what this is:
(defstate die (freeze-screen)
  :virtual #t
  :code (behavior ()
    (suspend-for (seconds 1)
      (seek! (-> self transition) 0.0 (seconds-per-frame))
      )
    )
  )

;; definition for method 24 of type freeze-screen
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod freeze-screen-method-24 ((this freeze-screen))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s3-0 (camera-matrix))
          (s5-0 (new 'stack-no-clear 'vector))
          (gp-0 (new 'stack-no-clear 'vector))
          (f30-0 4096.0)
          )
      (let ((f0-4 (* 0.00013563369 (tan (/ (-> *math-camera* fov) 2)) f30-0)))
        (set-vector! (-> this root scale) f0-4 f0-4 f0-4 1.0)
        )
      (set! (-> gp-0 quad) (-> (camera-pos) quad))
      (vector-normalize-copy! s5-0 (-> s3-0 fvec) 1.0)
      (matrix->quaternion (-> this root quat) s3-0)
      (let ((v1-10 (-> this root trans)))
        (let ((a0-5 f30-0))
          (.mov vf7 a0-5)
          )
        (.lvf vf5 (&-> s5-0 quad))
        (.lvf vf4 (&-> gp-0 quad))
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> v1-10 quad) vf6)
        )
      )
    0
    (none)
    )
  )

;; definition for function freeze-screen-init
;; INFO: Used lq/sq
(defbehavior freeze-screen-init freeze-screen ((arg0 vector) (arg1 quaternion) (arg2 entity))
  (process-entity-set! self arg2)
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> arg0 quad))
  (quaternion-copy! (-> self root quat) arg1)
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-freeze-screen" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> self anim-frame) 15.0)
  (set! (-> self transition) 0.0)
  (set-vector! (-> self draw color-emissive) 0.0 0.0 0.0 0.0)
  (set-vector! (-> self draw color-emissive) 0.0 0.0 0.0 0.0)
  (logior! (-> self skel status) (joint-control-status blend-shape))
  (ja :group! collectables-warp-time-end-ja)
  (set-setting! 'freeze-screen #t 0.0 0)
  (go-virtual idle)
  )

;; definition for method 10 of type freeze-screen
(defmethod deactivate ((this freeze-screen))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (disable *screen-filter*)
  (call-parent-method this)
  (none)
  )

;; definition of type freeze-control
(deftype freeze-control (process)
  ((clock-pos      float)
   (freeze-screen  handle)
   (sound-id       sound-id)
   (tick-time      time-frame)
   (abort?         symbol)
   (freeze-id      sound-id)
   )
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type freeze-control
(defmethod inspect ((this freeze-control))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process inspect)))
    (t9-0 this)
    )
  (format #t "~2Tclock-pos: ~f~%" (-> this clock-pos))
  (format #t "~2Tfreeze-screen: ~D~%" (-> this freeze-screen))
  (format #t "~2Tsound-id: ~D~%" (-> this sound-id))
  (format #t "~2Ttick-time: ~D~%" (-> this tick-time))
  (format #t "~2Tabort?: ~A~%" (-> this abort?))
  (format #t "~2Tfreeze-id: ~D~%" (-> this freeze-id))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defstate idle (freeze-control)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('die)
       (let ((v0-0 (-> block param 0)))
         (set! (-> self abort?) (the-as symbol v0-0))
         v0-0
         )
       )
      )
    )
  :enter (behavior ()
    (set-setting! 'music-volume 'rel 0.5 0)
    (set-setting! 'sfx-volume 'rel 0.9 0)
    (set-setting! 'ambient-volume 'rel 0.9 0)
    (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-3 from) (process->ppointer self))
      (set! (-> a1-3 num-params) 1)
      (set! (-> a1-3 message) 'test-pickup)
      (set! (-> a1-3 param 0) (the-as uint 8))
      (let ((f0-0 (the-as float (send-event-function (ppointer->process (-> self parent)) a1-3))))
        (send-event
          (ppointer->process (-> self parent))
          'get-pickup
          (pickup-type eco-pill-light)
          (- (fmin (-> *FACT-bank* lightjak-freeze-inc) (+ -1.0 f0-0)))
          )
        )
      )
    (set-action!
      *gui-control*
      (gui-action play)
      (-> self sound-id)
      (gui-channel none)
      (gui-action none)
      (the-as string #f)
      (the-as (function gui-connection symbol) #f)
      (the-as process #f)
      )
    )
  :exit (behavior ()
    (update-rates! (-> *display* entity-clock) 1.0)
    (update-rates! (-> *display* bg-clock) 1.0)
    (update-rates! (-> *display* part-clock) 1.0)
    (update-rates! (-> *display* target-clock) 1.0)
    (send-event (handle->process (-> self freeze-screen)) 'untrigger #t)
    (let ((f30-0 1.0))
      (if (>= f30-0 (send-event (ppointer->process (-> self parent)) 'test-pickup (pickup-type eco-pill-light)))
          (send-event (ppointer->process (-> self parent)) 'get-pickup (pickup-type eco-pill-light) -100.0)
          )
      )
    (set-action!
      *gui-control*
      (gui-action fade)
      (-> self sound-id)
      (gui-channel none)
      (gui-action none)
      (the-as string #f)
      (the-as (function gui-connection symbol) #f)
      (the-as process #f)
      )
    (remove-setting! 'music-volume)
    (remove-setting! 'sfx-volume)
    (remove-setting! 'ambient-volume)
    )
  :code (behavior ()
    (set! (-> self clock-pos) 1.0)
    (suspend)
    (send-event (handle->process (-> self freeze-screen)) 'trigger)
    (while (< 0.05 (-> self clock-pos))
      (seek! (-> self clock-pos) 0.05 (seconds-per-frame))
      (suspend)
      )
    (let ((gp-0 (current-time)))
      (while (and (not (time-elapsed? gp-0 (the-as time-frame (-> *FACT-bank* lightjak-freeze-duration))))
                  (let ((v1-15 #x20000)
                        (a0-8 (-> self parent))
                        )
                    (logtest? (the-as focus-status v1-15)
                              (-> (the-as process-focusable (if a0-8
                                                                (the-as process-focusable (-> a0-8 0 self))
                                                                )
                                          )
                                  focus-status
                                  )
                              )
                    )
                  (not (-> self abort?))
                  )
        (suspend)
        )
      )
    (while (< (-> self clock-pos) 1.0)
      (case (-> self abort?)
        (('force)
         (return #f)
         )
        )
      (seek! (-> self clock-pos) 1.0 (* 2.0 (seconds-per-frame)))
      (suspend)
      )
    )
  :post (behavior ()
    (set-setting! 'slow-time 'abs (lerp-scale 1.0 0.0 (-> self clock-pos) 0.05 1.0) 0)
    (apply-settings *setting-control*)
    (format *stdebug* "freeze = ~,,2f   ~,,2~%" (-> self clock-pos) (-> *setting-control* user-current slow-time))
    (update-rates! (-> *display* entity-clock) (-> self clock-pos))
    (update-rates! (-> *display* bg-clock) (-> self clock-pos))
    (update-rates! (-> *display* target-clock) (- 1.0 (* 0.1 (- 1.0 (-> self clock-pos)))))
    )
  )

;; definition for function freeze-control-init
(defbehavior freeze-control-init freeze-control ((arg0 sound-id))
  (set! (-> self clock-pos) 1.0)
  (set! (-> self sound-id) arg0)
  (set! (-> self abort?) #f)
  (set! (-> self freeze-screen)
        (ppointer->handle
          (process-spawn
            freeze-screen
            :init freeze-screen-init
            (math-camera-pos)
            *null-vector*
            (-> self entity)
            :name "freeze-screen"
            :to *display-pool*
            )
          )
        )
  (set! (-> self freeze-id)
        (add-process *gui-control* self (gui-channel freeze) (gui-action play) "freeze" -99.0 0)
        )
  (go-virtual idle)
  )

;; definition of type freeze-watcher
(deftype freeze-watcher (process)
  ((parent     (pointer process-focusable) :override)
   (old-clock  clock)
   )
  (:state-methods
    (active clock)
    )
  )

;; definition for method 3 of type freeze-watcher
(defmethod inspect ((this freeze-watcher))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process inspect)))
    (t9-0 this)
    )
  (format #t "~2Told-clock: ~A~%" (-> this old-clock))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defstate active (freeze-watcher)
  :virtual #t
  :exit (behavior ()
    (+! (-> self parent 0 clock ref-count) -1)
    (+! (-> self old-clock ref-count) 1)
    (set! (-> self parent 0 clock) (-> self old-clock))
    )
  :code (behavior ((arg0 clock))
    (let ((s4-0 (-> self parent 0 clock))
          (gp-0 (current-time))
          )
      (copy! arg0 s4-0)
      (+! (-> s4-0 ref-count) -1)
      (+! (-> arg0 ref-count) 1)
      (set! (-> self parent 0 clock) arg0)
      (+! (-> self clock ref-count) -1)
      (+! (-> self parent 0 clock ref-count) 1)
      (set! (-> self clock) (-> self parent 0 clock))
      (while (let* ((s5-2 (ppointer->process (-> self parent)))
                    (v1-31 (if (type? s5-2 process-focusable)
                               s5-2
                               )
                           )
                    )
               (and v1-31
                    (or (focus-test? v1-31 dead hit) (and (-> v1-31 next-state) (let ((v1-34 (-> v1-31 next-state name)))
                                                                                  (or (= v1-34 'hit)
                                                                                      (= v1-34 'knocked)
                                                                                      (= v1-34 'knocked-recover)
                                                                                      (= v1-34 'die)
                                                                                      (= v1-34 'die-falling)
                                                                                      (= v1-34 'die-fast)
                                                                                      )
                                                                                  )
                                                          )
                        )
                    (not (time-elapsed? gp-0 (seconds 5)))
                    )
               )
        (update-rates! (-> self clock) (seek (-> self clock clock-ratio) 1.0 (* 4.0 (seconds-per-frame))))
        (format *stdebug* "watcher ~d ~f~%" (-> self clock index) (-> self clock clock-ratio))
        (suspend)
        )
      )
    (while (!= (-> self clock clock-ratio) (lerp-scale 1.0 0.05 (-> *setting-control* user-current slow-time) 0.0 1.0))
      (update-rates! (-> self clock) (seek
                                       (-> self clock clock-ratio)
                                       (lerp-scale 1.0 0.05 (-> *setting-control* user-current slow-time) 0.0 1.0)
                                       (* 4.0 (seconds-per-frame))
                                       )
                     )
      (format *stdebug* "watcher ~d ~f~%" (-> self clock index) (-> self clock clock-ratio))
      (suspend)
      )
    )
  )

;; definition for function freeze-watcher-init
(defbehavior freeze-watcher-init freeze-watcher ((arg0 clock))
  (set! (-> self old-clock) (-> self parent 0 clock))
  (go-virtual active arg0)
  )

;; definition for function freeze-hit-begin
;; WARN: Return type mismatch int vs none.
;; WARN: Function freeze-hit-begin has a return type of none, but the expression builder found a return statement.
(defbehavior freeze-hit-begin process ()
  (local-vars (gp-0 clock))
  (cond
    ((or (< (-> *setting-control* user-current slow-time) 0.01) (>= (-> self clock index) 12))
     )
    (else
      (if (>= (-> self clock index) 12)
          (return #f)
          )
      (dotimes (v1-12 10)
        (when (zero? (-> *display* clock (+ v1-12 12) ref-count))
          (set! gp-0 (-> *display* clock (+ v1-12 12)))
          (goto cfg-18)
          )
        )
      (return #f)
      (label cfg-18)
      (process-spawn freeze-watcher :init freeze-watcher-init gp-0 :name "freeze-watcher" :to self)
      )
    )
  0
  (none)
  )

;; definition for function freeze-hit-end
;; WARN: Return type mismatch int vs none.
(defbehavior freeze-hit-end process ()
  (let ((gp-0 (-> self child)))
    (while gp-0
      (send-event (ppointer->process gp-0) 'notice 'freeze-hit-end)
      (set! gp-0 (-> gp-0 0 brother))
      )
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate target-lightjak-freeze (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('pole-grab 'darkjak 'lightjak 'slide 'wade 'launch 'edge-grab 'jump 'shove 'attack 'attack-or-shove)
       #f
       )
      (('attack 'attack-or-shove 'swim)
       #f
       )
      (else
        (target-dangerous-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    (logior! (-> self target-flags) (target-flags tf4))
    (set! (-> self lightjak freeze-sound)
          (add-process *gui-control* self (gui-channel jak-mode) (gui-action queue) "ljfreeze" -99.0 0)
          )
    (set! (-> self lightjak get-off-lock) #t)
    )
  :exit (behavior ()
    (if (not (handle->process (-> self lightjak freeze-control)))
        (set-action!
          *gui-control*
          (gui-action stop)
          (-> self lightjak freeze-sound)
          (gui-channel none)
          (gui-action none)
          (the-as string #f)
          (the-as (function gui-connection symbol) #f)
          (the-as process #f)
          )
        )
    (logclear! (-> self target-flags) (target-flags tf4 tf6))
    (target-exit)
    )
  :code (behavior ()
    (send-event (handle->process (-> self notify)) 'notify 'attack 27)
    (set! (-> self neck flex-blend) 0.0)
    (set! (-> self alt-cam-pos quad) (-> self control trans quad))
    (if (logtest? (-> *part-group-id-table* 180 flags) (sp-group-flag sp13))
        (part-tracker-spawn
          part-tracker-subsampler
          :to self
          :group (-> *part-group-id-table* 180)
          :target self
          :mat-joint 19
          )
        (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 180) :target self :mat-joint 19)
        )
    (if (logtest? (-> *part-group-id-table* 180 flags) (sp-group-flag sp13))
        (part-tracker-spawn
          part-tracker-subsampler
          :to self
          :group (-> *part-group-id-table* 180)
          :target self
          :mat-joint 28
          )
        (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 180) :target self :mat-joint 28)
        )
    (set! (-> self control mod-surface) *roll-flip-mods*)
    (let ((f30-0 0.0))
      (if (time-elapsed? (-> self fact lightjak-start-time) (seconds 2))
          (set! f30-0 9.0)
          )
      (ja-channel-push! 1 (seconds 0.1))
      (ja-no-eval :group! jakb-lightjak-freeze-ja :num! (seek! (ja-aframe 20.0 0)) :frame-num (ja-aframe f30-0 0))
      )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! (ja-aframe 20.0 0)))
      )
    (cond
      ((logtest? (-> *part-group-id-table* 181 flags) (sp-group-flag sp13))
       (set! (-> *launch-matrix* trans quad)
             (-> (vector<-cspace! (new 'stack-no-clear 'vector) (joint-node jakb-lod0-jg sk_lhand)) quad)
             )
       (part-tracker-spawn part-tracker-subsampler :to self :group (-> *part-group-id-table* 181))
       )
      (else
        (set! (-> *launch-matrix* trans quad)
              (-> (vector<-cspace! (new 'stack-no-clear 'vector) (joint-node jakb-lod0-jg sk_lhand)) quad)
              )
        (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 181))
        )
      )
    (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.5))
    (activate! *camera-smush-control* 819.2 15 75 1.0 0.9 (-> *display* camera-clock))
    (set! (-> self lightjak freeze-control) (ppointer->handle (process-spawn
                                                                freeze-control
                                                                :init freeze-control-init
                                                                (-> self lightjak freeze-sound)
                                                                :name "freeze-control"
                                                                :to self
                                                                )
                                                              )
          )
    (ja-no-eval :num! (seek!))
    (while (not (ja-done? 0))
      (suspend)
      (ja-eval)
      )
    (go target-stance)
    )
  :post target-no-stick-post
  )

;; failed to figure out what this is:
(defstate target-lightjak-shield (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('pole-grab 'darkjak 'lightjak 'slide 'wade 'launch 'edge-grab 'jump 'shove 'attack 'attack-or-shove)
       #f
       )
      (('attack 'attack-or-shove 'swim)
       #f
       )
      (else
        (target-standard-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    (logior! (-> self target-flags) (target-flags tf4))
    (set! (-> self neck flex-blend) 0.0)
    (quaternion-copy! (-> self control unknown-quaternion04) (-> self control dir-targ))
    (set! (-> self lightjak get-off-lock) #t)
    )
  :exit (behavior ()
    (set! (-> self control dynam gravity-max) (-> self control standard-dynamics gravity-max))
    (set! (-> self control dynam gravity-length) (-> self control standard-dynamics gravity-length))
    (logclear! (-> self target-flags) (target-flags tf4 tf6))
    (target-exit)
    )
  :code (behavior ()
    (send-event (handle->process (-> self notify)) 'notify 'attack 28)
    (if (logtest? (-> self control status) (collide-status on-ground))
        (set! (-> self control mod-surface) *attack-mods*)
        (set! (-> self control mod-surface) *jump-attack-mods*)
        )
    (let ((f0-1 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
      (cond
        ((>= 0.0 f0-1)
         (let ((v1-19 (new-stack-vector0)))
           (let ((f0-3 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
             0.0
             (vector-! v1-19 (-> self control transv) (vector-float*! v1-19 (-> self control dynam gravity-normal) f0-3))
             )
           (let* ((f0-4 (vector-length v1-19))
                  (f1-2 f0-4)
                  (f2-0 33775.48)
                  )
             (vector+!
               (-> self control transv)
               (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-0)
               (vector-float*! v1-19 v1-19 (/ f0-4 f1-2))
               )
             )
           )
         )
        (else
          (let* ((f1-5 (/ f0-1 (* (-> self control dynam gravity-length) (seconds-per-frame))))
                 (f0-6 (* (/ f1-5 2) (seconds-per-frame) f0-1))
                 (v1-25 (new-stack-vector0))
                 )
            (let ((f1-9 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
              0.0
              (vector-! v1-25 (-> self control transv) (vector-float*! v1-25 (-> self control dynam gravity-normal) f1-9))
              )
            (let* ((f1-10 (vector-length v1-25))
                   (f2-5 f1-10)
                   (f0-10 (+ 1024.0 (sqrtf (* 245760.0 (+ 2048.0 f0-6)))))
                   )
              (vector+!
                (-> self control transv)
                (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-10)
                (vector-float*! v1-25 v1-25 (/ f1-10 f2-5))
                )
              )
            )
          )
        )
      )
    (set! (-> self control dynam gravity-length) 122880.0)
    (set! (-> self control last-trans-any-surf quad) (-> self control trans quad))
    (let ((gp-0 jakb-lightjak-shield-ja))
      (quaternion-rotate-y! (-> self control quat-for-control) (-> self control quat-for-control) -1365.3334)
      (ja-channel-push! 1 (seconds 0.05))
      (set! (-> self control unknown-sound-id01) (sound-play "spin-kick"))
      (ja-no-eval :group! gp-0 :num! (seek! max (-> self control current-surface align-speed)) :frame-num 0.0)
      )
    (until (ja-done? 0)
      (compute-alignment! (-> self align))
      (align! (-> self align) (align-opts adjust-quat) 1.0 1.0 1.0)
      (suspend)
      (ja :num! (seek! max (-> self control current-surface align-speed)))
      )
    (quaternion-rotate-y! (-> self control quat-for-control) (-> self control quat-for-control) -1365.3334)
    (if (logtest? (-> self control status) (collide-status on-surface))
        (go target-stance)
        (go target-falling #f)
        )
    )
  :post target-post
  )

;; failed to figure out what this is:
(let ((a0-106 (copy *jump-mods* 'global)))
  (set! (-> a0-106 flags) (surface-flag gun-off gun-fast-exit no-board))
  (set! *heal-mods* a0-106)
  )

;; failed to figure out what this is:
(defstate target-lightjak-regen (target)
  :event target-generic-event-handler
  :enter (behavior ((arg0 int))
    (logior! (-> self target-flags) (target-flags tf4))
    (set-setting! 'process-mask 'set 0.0 (process-mask enemy platform projectile guard vehicle))
    (set! (-> self control unknown-handle02) (the-as handle #f))
    (set-time! (-> self lightjak regen-start-time))
    (set! (-> self lightjak get-off-lock) #t)
    )
  :exit (behavior ()
    (logclear! (-> self target-flags) (target-flags tf4))
    (set-action!
      *gui-control*
      (gui-action fade)
      (-> self control unknown-sound-id00)
      (gui-channel none)
      (gui-action none)
      (the-as string #f)
      (the-as (function gui-connection symbol) #f)
      (the-as process #f)
      )
    (set! (-> self control dynam gravity-max) (-> self control standard-dynamics gravity-max))
    (set! (-> self control dynam gravity-length) (-> self control standard-dynamics gravity-length))
    (send-event (handle->process (-> self control unknown-handle02)) 'die)
    (remove-setting! 'process-mask)
    (target-exit)
    )
  :trans (behavior ()
    (set-time! (-> self lightjak regen-time))
    )
  :code (behavior ((arg0 int))
    (set-time! (-> self state-time))
    (sound-play "heal-rise")
    (if (nonzero? arg0)
        (set! (-> self control unknown-sound-id00) (the-as sound-id arg0))
        (set! (-> self control unknown-sound-id00)
              (add-process *gui-control* self (gui-channel jak-mode) (gui-action queue) "jak-heal" -99.0 0)
              )
        )
    (set! (-> self neck flex-blend) 0.0)
    (set! (-> self control mod-surface) *heal-mods*)
    (let ((f28-0 0.0))
      0
      0.0
      (let* ((f0-2 (-> self game eco-pill-light))
             (f26-0 (- (-> self fact health-max) (-> self fact health)))
             (f30-0 (/ (-> *FACT-bank* eco-pill-light-max-default) (-> self fact health-max)))
             (gp-1 (the int (fmin f26-0 (ceil (/ f0-2 f30-0)))))
             )
        (let ((v1-17 (ja-group)))
          (if (and v1-17 (= v1-17 jakb-lightjak-stance-ja))
              (ja-channel-push! 1 (seconds 0.05))
              (set! f28-0
                    (cond
                      ((and (logtest? (-> self control mod-surface flags) (surface-flag air))
                            (not (logtest? (-> self control status) (collide-status on-surface)))
                            )
                       (ja-channel-push! 1 (seconds 0.1))
                       14.0
                       )
                      (else
                        (set! f28-0 6.0)
                        (ja-channel-push! 1 (seconds 0.1))
                        f28-0
                        )
                      )
                    )
              )
          )
        (show-hud 'hud-health)
        (ja-no-eval :group! jakb-lightjak-heal-ja :num! (seek!) :frame-num (ja-aframe f28-0 0))
        (until (ja-done? 0)
          (compute-alignment! (-> self align))
          (align! (-> self align) (align-opts adjust-y-vel) 1.0 2.0 1.0)
          (set-forward-vel (* 0.6 (-> self control ctrl-xz-vel)))
          (suspend)
          (ja :num! (seek!))
          )
        (show-hud 'hud-health)
        (set-action!
          *gui-control*
          (gui-action play)
          (-> self control unknown-sound-id00)
          (gui-channel none)
          (gui-action none)
          (the-as string #f)
          (the-as (function gui-connection symbol) #f)
          (the-as process #f)
          )
        (let ((v1-64 (point-off-screen (new 'stack-no-clear 'vector))))
          (set! (-> *part-id-table* 642 init-specs 9 initial-valuef) (- (-> v1-64 y) (-> self control trans y)))
          (set! (-> *part-id-table* 643 init-specs 9 initial-valuef) (- (-> v1-64 y) (-> self control trans y)))
          (set! (-> *part-id-table* 644 init-specs 9 initial-valuef) (- (-> v1-64 y) (-> self control trans y)))
          (set! (-> *part-id-table* 645 init-specs 9 initial-valuef) (- (-> v1-64 y) (-> self control trans y)))
          )
        (set! (-> self control unknown-handle02)
              (ppointer->handle
                (cond
                  ((logtest? (-> *part-group-id-table* 177 flags) (sp-group-flag sp13))
                   (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
                   (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 177))
                   )
                  (else
                    (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
                    (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 177))
                    )
                  )
                )
              )
        (set! (-> self post-hook) target-no-stick-post)
        (set! (-> self control mod-surface) *jump-mods*)
        (set! (-> self control dynam gravity-max) 0.0)
        (set! (-> self control dynam gravity-length) 0.0)
        (let ((s5-4 0))
          (while (or (> gp-1 0) (< s5-4 2))
            (ja-no-eval :group! jakb-lightjak-heal-loop-ja :num! (seek!) :frame-num 0.0)
            (until (ja-done? 0)
              (when (and (>= (- (-> *display* game-clock frame-counter) (-> self fact eco-source-time)) (seconds 0.5)) (> gp-1 0))
                (set! (-> self fact eco-source-time) (-> *display* game-clock frame-counter))
                (set! (-> self fact eco-source) (process->handle self))
                (send-event self 'get-pickup (pickup-type health) 1.0)
                (if (not (logtest? (-> self lightjak stage) (lightjak-stage ls1)))
                    (send-event self 'get-pickup (pickup-type eco-pill-light) (- f30-0))
                    )
                (+! gp-1 -1)
                )
              (let ((v1-150 (point-off-screen (new 'stack-no-clear 'vector))))
                (set! (-> *part-id-table* 642 init-specs 9 initial-valuef) (- (-> v1-150 y) (-> self control trans y)))
                (set! (-> *part-id-table* 643 init-specs 9 initial-valuef) (- (-> v1-150 y) (-> self control trans y)))
                (set! (-> *part-id-table* 644 init-specs 9 initial-valuef) (- (-> v1-150 y) (-> self control trans y)))
                (set! (-> *part-id-table* 645 init-specs 9 initial-valuef) (- (-> v1-150 y) (-> self control trans y)))
                )
              (suspend)
              (ja :num! (seek!))
              )
            (+! s5-4 1)
            )
          )
        )
      )
    (set! (-> self control dynam gravity-max) (-> self control standard-dynamics gravity-max))
    (set! (-> self control dynam gravity-length) (-> self control standard-dynamics gravity-length))
    (cond
      ((>= 5734.4 (target-height-above-ground))
       (ja-channel-push! 1 (seconds 0.05))
       (ja-no-eval :group! jakb-lightjak-heal-end-ja :num! (seek!) :frame-num 0.0)
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek!))
         )
       (if (not (-> self lightjak lightjak-before-powerjak))
           (target-lightjak-end-mode #f)
           )
       (go target-stance)
       )
      (else
        (if (not (-> self lightjak lightjak-before-powerjak))
            (target-lightjak-end-mode #f)
            )
        (go target-falling 'target-lightjak-regen)
        )
      )
    )
  :post target-post
  )

;; failed to figure out what this is:
(defstate open (lightjak-shield)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('close)
       (go-virtual close)
       )
      (('hit)
       (go-virtual hit)
       )
      )
    )
  :code (behavior ()
    (if (logtest? (-> *part-group-id-table* 178 flags) (sp-group-flag sp13))
        (part-tracker-spawn
          part-tracker-subsampler
          :to self
          :group (-> *part-group-id-table* 178)
          :target self
          :mat-joint 3
          )
        (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 178) :target self :mat-joint 3)
        )
    (let ((v1-30 (ja-group)))
      (when (not (and v1-30 (= v1-30 jakb-shield-start-ja)))
        (ja-channel-push! 1 (seconds 0.1))
        (ja :group! jakb-shield-start-ja :num! min)
        )
      )
    (sound-play "shield-on")
    (while (not (ja-max? 0))
      (suspend)
      (set! (-> self fade) (/ (ja-frame-num 0) (the float (+ (-> (ja-group) frames num-frames) -1))))
      (ja :num! (seek!))
      )
    (until #f
      (ja-no-eval :group! jakb-shield-idle-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (let* ((gp-0 (ppointer->process (-> self parent)))
             (s3-0 (if (type? gp-0 process-focusable)
                       gp-0
                       )
                   )
             (s4-0 (camera-matrix))
             (s5-0 (new 'stack-no-clear 'vector))
             (gp-1 (new 'stack-no-clear 'vector))
             (f30-0 4096.0)
             )
        (let ((f0-0 3.0))
          (set-vector! (-> self root scale) f0-0 f0-0 f0-0 1.0)
          )
        (set! (-> gp-1 quad) (-> (get-trans s3-0 5) quad))
        (vector-normalize-copy! s5-0 (-> s4-0 fvec) 0.0)
        (matrix->quaternion (-> self root quat) s4-0)
        (let ((v1-11 (-> self root trans)))
          (let ((a0-5 f30-0))
            (.mov vf7 a0-5)
            )
          (.lvf vf5 (&-> s5-0 quad))
          (.lvf vf4 (&-> gp-1 quad))
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> v1-11 quad) vf6)
          )
        )
      (set! (-> self draw force-fade) (the-as uint (the int (* 128.0 (- 1.0 (-> self fade))))))
      (sound-play "ltjak-shield" :id (the-as sound-id (-> self tone)))
      (ja-post)
      )
    )
  )

;; failed to figure out what this is:
(defstate close (lightjak-shield)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('open)
       (go-virtual open)
       )
      )
    )
  :code (behavior ()
    (let ((v1-2 (ja-group)))
      (when (not (and v1-2 (= v1-2 jakb-shield-start-ja)))
        (ja-channel-push! 1 (seconds 0.1))
        (ja :group! jakb-shield-start-ja :num! max)
        )
      )
    (sound-play "shield-off")
    (while (not (ja-min? 0))
      (suspend)
      (set! (-> self fade) (/ (ja-frame-num 0) (the float (+ (-> (ja-group) frames num-frames) -1))))
      (ja :num! (seek! 0.0))
      )
    )
  :post (-> (method-of-type lightjak-shield open) post)
  )

;; failed to figure out what this is:
(defstate hit (lightjak-shield)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('close)
       (go-virtual close)
       )
      (('hit)
       (if (time-elapsed? (-> self state-time) (seconds 0.2))
           (go-virtual hit)
           )
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :code (behavior ()
    (if (not (logtest? (-> self parent 0 lightjak stage) (lightjak-stage ls1)))
        (send-event
          (ppointer->process (-> self parent))
          'get-pickup
          (pickup-type eco-pill-light)
          (- (-> *FACT-bank* lightjak-shield-hit-inc))
          )
        )
    (sound-play "shield-hit")
    (ja-channel-push! 1 (seconds 0.05))
    (if (logtest? (-> *part-group-id-table* 179 flags) (sp-group-flag sp13))
        (part-tracker-spawn
          part-tracker-subsampler
          :to self
          :group (-> *part-group-id-table* 179)
          :target self
          :mat-joint 3
          )
        (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 179) :target self :mat-joint 3)
        )
    (ja-no-eval :group! jakb-shield-hit-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (ja :group! jakb-shield-start-ja :num! max)
    (go-virtual open)
    )
  :post (-> (method-of-type lightjak-shield open) post)
  )

;; definition for function lightjak-shield-init
;; WARN: Return type mismatch object vs none.
(defbehavior lightjak-shield-init lightjak-shield ()
  (set! (-> self root) (new 'process 'trsqv))
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-jchar-shield" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (logior! (-> self skel status) (joint-control-status blend-shape eye-anim))
  (logior! (-> self draw status) (draw-control-status force-fade warp-cross-fade))
  (set! (-> self draw force-fade) (the-as uint 128))
  (set! (-> self fade) 0.0)
  (set! (-> self tone) (the-as rgba (new-sound-id)))
  (ja-channel-set! 1)
  (ja :group! jakb-shield-start-ja :num! min)
  (go-virtual open)
  (none)
  )

;; definition for method 10 of type lightjak-shield
(defmethod deactivate ((this lightjak-shield))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (set! (-> this parent 0 lightjak shield) (the-as (pointer lightjak-shield) #f))
  (let ((v1-3 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
    (set! (-> v1-3 command) (sound-command set-param))
    (set! (-> v1-3 id) (the-as sound-id (-> this tone)))
    (set! (-> v1-3 params volume) -4)
    (set! (-> v1-3 auto-time) 48)
    (set! (-> v1-3 auto-from) 2)
    (set! (-> v1-3 params mask) (the-as uint 17))
    (-> v1-3 id)
    )
  (call-parent-method this)
  (none)
  )
