;;-*-Lisp-*-
(in-package goal)

;; definition of type gun-red-shot
(deftype gun-red-shot (process-drawable)
  ((parent       (pointer gun)        :override)
   (root         collide-shape-moving :override)
   (probe-count  int32)
   (probe-mask   uint32)
   (actor-count  int32)
   (attack-id    uint32)
   (start-pos    vector                :inline)
   (start-dir    vector                :inline)
   (start-rot    vector                :inline)
   (probe-dir    vector                19 :inline)
   )
  (:state-methods
    blocked
    debug-idle
    idle
    )
  (:methods
    (init-probes! (_type_ collide-shape) none)
    (check-blocked? (_type_) symbol)
    (stub (_type_) none)
    (find-targets (_type_) none)
    (setup-probes (_type_) none)
    (do-collision (_type_ vector) none)
    (send-attack! (_type_ process-drawable touching-shapes-entry) none)
    )
  )

;; definition for method 3 of type gun-red-shot
(defmethod inspect ((this gun-red-shot))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tprobe-count: ~D~%" (-> this probe-count))
  (format #t "~2Tprobe-mask: ~D~%" (-> this probe-mask))
  (format #t "~2Tactor-count: ~D~%" (-> this actor-count))
  (format #t "~2Tattack-id: ~D~%" (-> this attack-id))
  (format #t "~2Tstart-pos: #<vector @ #x~X>~%" (-> this start-pos))
  (format #t "~2Tstart-dir: #<vector @ #x~X>~%" (-> this start-dir))
  (format #t "~2Tstart-rot: #<vector @ #x~X>~%" (-> this start-rot))
  (format #t "~2Tprobe-dir[19] @ #x~X~%" (-> this probe-dir))
  (label cfg-4)
  this
  )

;; definition of type gun-red-3-grenade
(deftype gun-red-3-grenade (projectile-bounce)
  ((blast-radius           float)
   (should-explode-soon?   symbol)
   (explode-tick-time      time-frame)
   (birth-time             time-frame)
   (immediate-detonation?  symbol)
   (explode-delay-time     time-frame)
   )
  (:state-methods
    impact-tiny
    )
  (:methods
    (check-should-explode (_type_) int)
    (go-impact (_type_) object)
    (find-and-damage-targets (_type_) object)
    )
  )

;; definition for method 3 of type gun-red-3-grenade
(defmethod inspect ((this gun-red-3-grenade))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type projectile-bounce inspect)))
    (t9-0 this)
    )
  (format #t "~2Tblast-radius: ~f~%" (-> this blast-radius))
  (format #t "~2Tshould-explode-soon?: ~A~%" (-> this should-explode-soon?))
  (format #t "~2Texplode-tick-time: ~D~%" (-> this explode-tick-time))
  (format #t "~2Tbirth-time: ~D~%" (-> this birth-time))
  (format #t "~2Timmediate-detonation?: ~A~%" (-> this immediate-detonation?))
  (format #t "~2Tattack-id: ~D~%" (-> this attack-id))
  (format #t "~2Texplode-delay-time: ~D~%" (-> this explode-delay-time))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-gun-red-3-grenade gun gun-grenade-lod0-jg gun-grenade-idle-ja
              ((gun-grenade-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 0.2)
              :texture-level 10
              )

;; definition for method 30 of type gun-red-3-grenade
;; WARN: Return type mismatch int vs none.
(defmethod setup-collision! ((this gun-red-3-grenade))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) projectile-bounce-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrate-using) (penetrate explode))
    (let ((v1-7 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-7 prim-core action) (collide-action solid))
      (set-vector! (-> v1-7 local-sphere) 0.0 0.0 0.0 819.2)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-7)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-10 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-10 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-10 prim-core collide-with))
      )
    (set! (-> s5-0 max-iteration-count) (the-as uint 2))
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> this root) s5-0)
    )
  (set-collide-with!
    (-> this root)
    (collide-spec backgnd crate civilian enemy obstacle vehicle-sphere hit-by-others-list pusher shield)
    )
  (set-collide-as! (-> this root) (collide-spec projectile))
  (set! (-> this root pat-ignore-mask)
        (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noproj #x1 :noendlessfall #x1 :board #x1)
        )
  (none)
  )

;; definition for method 36 of type gun-red-3-grenade
;; WARN: Return type mismatch symbol vs object.
(defmethod handle-proj-hit! ((this gun-red-3-grenade) (arg0 process) (arg1 event-message-block))
  (go (method-of-object this impact))
  #t
  )

;; definition for method 40 of type gun-red-3-grenade
(defmethod projectile-method-40 ((this gun-red-3-grenade))
  256
  )

;; definition for method 31 of type gun-red-3-grenade
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod init-proj-settings! ((this gun-red-3-grenade))
  (set! (-> this attack-mode) #f)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-gun-red-3-grenade" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (let ((t9-2 (method-of-type projectile-bounce init-proj-settings!)))
    (t9-2 this)
    )
  (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 204 (seconds 0.2))
  (sound-play "red3-fire")
  (let* ((v1-6 *game-info*)
         (a0-9 (+ (-> v1-6 attack-id) 1))
         )
    (set! (-> v1-6 attack-id) a0-9)
    (set! (-> this attack-id) a0-9)
    )
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 87) this))
  (set! (-> this blast-radius) 81920.0)
  (set! (-> this max-speed) 327680.0)
  (set! (-> this timeout) (seconds 3))
  (set! (-> this should-explode-soon?) #f)
  (set-time! (-> this birth-time))
  (let ((v1-15 (new 'stack-no-clear 'vector)))
    (set! (-> v1-15 x) 2.5)
    (set! (-> v1-15 y) 2.5)
    (set! (-> v1-15 z) 2.5)
    (set! (-> v1-15 w) 1.0)
    (set! (-> this root scale quad) (-> v1-15 quad))
    )
  (set! (-> this immediate-detonation?) #f)
  (let ((s5-2 (new 'stack-no-clear 'light-trail-tracker-spawn-params)))
    (set! (-> s5-2 tracked-obj) (process->handle this))
    (set! (-> s5-2 appearance) *red-shot-3-trail*)
    (set! (-> s5-2 max-num-crumbs) (the int (* 0.5 (the float (-> s5-2 appearance max-age)))))
    (set! (-> s5-2 track-immediately?) #t)
    (let* ((v1-28 (estimate-light-trail-mem-usage
                    (the-as uint (-> s5-2 max-num-crumbs))
                    (the-as uint (= (-> s5-2 appearance lie-mode) (lie-mode use-two-strips)))
                    )
                  )
           (s4-2 (get-process *default-dead-pool* light-trail-tracker-projectile (+ v1-28 8192) 1))
           )
      (when s4-2
        (let ((t9-9 (method-of-type process activate)))
          (t9-9 s4-2 this "light-trail" (the-as pointer #x70004000))
          )
        (run-now-in-process s4-2 light-trail-tracker-init-by-other s5-2)
        (-> s4-2 ppointer)
        )
      )
    )
  0
  (none)
  )

;; definition for method 32 of type gun-red-3-grenade
;; WARN: Return type mismatch int vs none.
(defmethod projectile-method-32 ((this gun-red-3-grenade))
  (cond
    ((not (do-fire-backcheck (-> this root trans) (-> this root transv)))
     (let ((v1-3 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> this root transv) 1.0)))
       (vector+float*! (-> this root trans) (-> this root trans) v1-3 -14336.0)
       )
     (set! (-> this immediate-detonation?) #t)
     (go (method-of-object this impact))
     )
    (else
      (call-parent-method this)
      )
    )
  0
  (none)
  )

;; definition for method 46 of type gun-red-3-grenade
(defmethod go-impact ((this gun-red-3-grenade))
  (cond
    ((-> this should-explode-soon?)
     (if (time-elapsed? (-> this explode-tick-time) (-> this explode-delay-time))
         (go (method-of-object this impact))
         )
     )
    (else
      (case (check-should-explode this)
        ((1)
         (set! (-> this should-explode-soon?) #t)
         (let ((v0-0 (the-as object (current-time))))
           (set! (-> this explode-tick-time) (the-as time-frame v0-0))
           v0-0
           )
         )
        ((2)
         (go (method-of-object this impact))
         )
        )
      )
    )
  )

;; definition for method 47 of type gun-red-3-grenade
;; INFO: Used lq/sq
(defmethod find-and-damage-targets ((this gun-red-3-grenade))
  (local-vars (v1-21 float) (v1-45 float))
  (with-pp
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (let ((s5-0 (new 'stack-no-clear 'vector))
            (a1-0 (new 'stack-no-clear 'event-message-block))
            )
        (set! (-> a1-0 from) (process->ppointer pp))
        (set! (-> a1-0 num-params) 0)
        (set! (-> a1-0 message) 'get-vehicle)
        (let ((s4-0 (send-event-function *target* a1-0)))
          (set! (-> s5-0 quad) (-> this root trans quad))
          (set! (-> s5-0 w) (-> this blast-radius))
          (let ((s3-0 (new 'stack-no-clear 'array 'collide-shape 384)))
            (countdown (s2-0 (fill-actor-list-for-box *actor-hash* s5-0 s3-0 384))
              (let* ((s1-0 (-> s3-0 s2-0))
                     (a0-8 (if (type? s1-0 collide-shape)
                               s1-0
                               )
                           )
                     )
                (when a0-8
                  (let* ((s0-0 (-> a0-8 process))
                         (s1-1 (if (type? s0-0 process-focusable)
                                   s0-0
                                   )
                               )
                         )
                    (when s1-1
                      (when (and (!= s4-0 s1-1)
                                 (not (focus-test? (the-as process-focusable s1-1) disable dead inactive))
                                 (logtest? (process-mask crate enemy guard vehicle civilian) (-> s1-1 mask))
                                 (nonzero? (-> (the-as process-focusable s1-1) root root-prim prim-core collide-with))
                                 )
                        (+! (-> *game-info* shots-hit 1) 1.0)
                        (let ((s0-2
                                (vector-! (new 'stack-no-clear 'vector) (get-trans (the-as process-focusable s1-1) 3) (-> this root trans))
                                )
                              )
                          0.0
                          (.lvf vf1 (&-> s0-2 quad))
                          (.add.w.vf vf2 vf0 vf0 :mask #b1)
                          (.mul.vf vf1 vf1 vf1)
                          (.mul.x.vf acc vf2 vf1 :mask #b1)
                          (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
                          (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
                          (.mov v1-21 vf1)
                          (let ((f0-4 v1-21)
                                (f1-1 (-> this blast-radius))
                                )
                            (if (>= (* f1-1 f1-1) f0-4)
                                (send-event
                                  s1-1
                                  'attack
                                  #f
                                  (static-attack-info :mask (vehicle-impulse-factor) ((id (-> this attack-id))
                                                                                      (damage 12.0)
                                                                                      (vehicle-damage-factor 3.0)
                                                                                      (vehicle-impulse-factor 1.0)
                                                                                      (mode 'explode)
                                                                                      (attacker-velocity s0-2)
                                                                                      (penetrate-using (penetrate explode))
                                                                                      )
                                                      )
                                  )
                                )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          (let* ((s2-1 *target*)
                 (s3-1 (if (type? s2-1 process-focusable)
                           s2-1
                           )
                       )
                 )
            (when (and s3-1 (< (vector-vector-distance (get-trans s3-1 0) s5-0) (-> s5-0 w)))
              (when (and (!= s4-0 s3-1)
                         (not (focus-test? s3-1 disable dead inactive))
                         (logtest? (process-mask crate enemy guard vehicle civilian) (-> s3-1 mask))
                         (nonzero? (-> s3-1 control root-prim prim-core collide-with))
                         )
                (+! (-> *game-info* shots-hit 1) 1.0)
                (let ((s5-2 (vector-! (new 'stack-no-clear 'vector) (get-trans s3-1 3) (-> this root trans))))
                  0.0
                  (.lvf vf1 (&-> s5-2 quad))
                  (.add.w.vf vf2 vf0 vf0 :mask #b1)
                  (.mul.vf vf1 vf1 vf1)
                  (.mul.x.vf acc vf2 vf1 :mask #b1)
                  (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
                  (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
                  (.mov v1-45 vf1)
                  (let ((f0-12 v1-45)
                        (f1-6 (-> this blast-radius))
                        )
                    (if (>= (* f1-6 f1-6) f0-12)
                        (send-event
                          s3-1
                          'attack
                          #f
                          (static-attack-info :mask (vehicle-impulse-factor) ((id (-> this attack-id))
                                                                              (damage 12.0)
                                                                              (vehicle-damage-factor 3.0)
                                                                              (vehicle-impulse-factor 1.0)
                                                                              (mode 'explode)
                                                                              (attacker-velocity s5-2)
                                                                              (penetrate-using (penetrate explode))
                                                                              )
                                              )
                          )
                        )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )

;; definition for method 45 of type gun-red-3-grenade
;; INFO: Used lq/sq
(defmethod check-should-explode ((this gun-red-3-grenade))
  (local-vars
    (sv-1680 vector)
    (sv-1684 vector)
    (sv-1688 float)
    (sv-1692 float)
    (sv-1696 symbol)
    (sv-1744 vector)
    (sv-1748 vector)
    (sv-1752 float)
    (sv-1756 float)
    (sv-1760 symbol)
    )
  (with-pp
    (let ((s4-0 (new 'stack-no-clear 'vector))
          (gp-0 #f)
          )
      (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-0 from) (process->ppointer pp))
        (set! (-> a1-0 num-params) 0)
        (set! (-> a1-0 message) 'get-vehicle)
        (let ((s3-0 (send-event-function *target* a1-0)))
          (set! (-> s4-0 quad) (-> this root trans quad))
          (set! (-> s4-0 w) (* 0.6666667 (-> this blast-radius)))
          (let ((s2-0 (new 'stack-no-clear 'array 'collide-shape 384)))
            (countdown (s1-0 (fill-actor-list-for-box *actor-hash* s4-0 s2-0 384))
              (let* ((s0-0 (-> s2-0 s1-0))
                     (a0-8 (if (type? s0-0 collide-shape)
                               s0-0
                               )
                           )
                     )
                (when a0-8
                  (let* ((s0-1 (-> a0-8 process))
                         (a0-10 (if (type? s0-1 process-focusable)
                                    s0-1
                                    )
                                )
                         )
                    (when a0-10
                      (when (and (!= s3-0 a0-10)
                                 (not (focus-test? (the-as process-focusable a0-10) disable dead inactive gun-no-target))
                                 (nonzero? (-> (the-as process-focusable a0-10) root root-prim prim-core collide-with))
                                 (or (logtest? (process-mask crate enemy vehicle civilian) (-> a0-10 mask))
                                     (and (logtest? (process-mask guard) (-> a0-10 mask)) (-> *setting-control* user-current gun-target-guards?))
                                     )
                                 )
                        (set! sv-1680
                              (vector-! (new 'stack-no-clear 'vector) (get-trans (the-as process-focusable a0-10) 3) (-> this root trans))
                              )
                        (set! sv-1684 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> this root transv) 1.0))
                        (set! sv-1688 (the-as float 0.0))
                        (set! sv-1692 (the-as float 0.0))
                        (set! sv-1696 (time-elapsed? (-> this birth-time) (seconds 0.05)))
                        (set! sv-1688 (vector-normalize-ret-len! sv-1680 1.0))
                        (set! sv-1692 (vector-dot sv-1680 sv-1684))
                        (when (< sv-1688 (-> s4-0 w))
                          (cond
                            ((and (< 0.0 sv-1692) sv-1696)
                             (set! gp-0 #t)
                             (set! (-> this explode-delay-time)
                                   (the-as time-frame (min 150 (the int (* 300.0 (/ sv-1688 (vector-length (-> this root transv))) sv-1692))))
                                   )
                             )
                            ((< sv-1688 8192.0)
                             (return 2)
                             )
                            ((and (not sv-1696) (< (seconds 0.05) (- (current-time) (-> this birth-time))))
                             (return 2)
                             )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          (let* ((s1-1 *target*)
                 (s2-1 (if (type? s1-1 process-focusable)
                           s1-1
                           )
                       )
                 )
            (when (and s2-1 (< (vector-vector-distance (get-trans s2-1 0) s4-0) (-> s4-0 w)))
              (when (and (!= s3-0 s2-1)
                         (not (focus-test? s2-1 disable dead inactive gun-no-target))
                         (nonzero? (-> s2-1 control root-prim prim-core collide-with))
                         (or (logtest? (process-mask crate enemy vehicle civilian) (-> s2-1 mask))
                             (and (logtest? (process-mask guard) (-> s2-1 mask)) (-> *setting-control* user-current gun-target-guards?))
                             )
                         )
                (set! sv-1744 (vector-! (new 'stack-no-clear 'vector) (get-trans s2-1 3) (-> this root trans)))
                (set! sv-1748 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> this root transv) 1.0))
                (set! sv-1752 (the-as float 0.0))
                (set! sv-1756 (the-as float 0.0))
                (set! sv-1760 (time-elapsed? (-> this birth-time) (seconds 0.05)))
                (set! sv-1752 (vector-normalize-ret-len! sv-1744 1.0))
                (set! sv-1756 (vector-dot sv-1744 sv-1748))
                (when (< sv-1752 (-> s4-0 w))
                  (cond
                    ((and (< 0.0 sv-1756) sv-1760)
                     (set! gp-0 #t)
                     (set! (-> this explode-delay-time)
                           (the-as time-frame (min 150 (the int (* 300.0 (/ sv-1752 (vector-length (-> this root transv))) sv-1756))))
                           )
                     )
                    ((< sv-1752 8192.0)
                     (return 2)
                     )
                    ((and (not sv-1760) (< (seconds 0.05) (- (current-time) (-> this birth-time))))
                     (return 2)
                     )
                    )
                  )
                )
              )
            )
          )
        )
      (if gp-0
          (return 1)
          (return 0)
          )
      )
    (the-as int 0)
    )
  )

;; definition for method 25 of type gun-red-3-grenade
(defmethod projectile-method-25 ((this gun-red-3-grenade))
  (spawn (-> this part) (-> this root trans))
  (if (logtest? (-> this root status) (collide-status touch-surface))
      (sound-play "red3-bounce")
      )
  (call-parent-method this)
  (none)
  )

;; definition for method 42 of type gun-red-3-grenade
(defmethod projectile-bounce-method-42 ((this gun-red-3-grenade))
  (spawn (-> this part) (-> this root trans))
  (call-parent-method this)
  (none)
  )

;; definition of type shockwave-collision-pt
(deftype shockwave-collision-pt (structure)
  ((collision-pt  vector  :inline)
   (normal        vector  :inline)
   (found?        symbol)
   (angle         degrees)
   )
  )

;; definition for method 3 of type shockwave-collision-pt
(defmethod inspect ((this shockwave-collision-pt))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'shockwave-collision-pt)
  (format #t "~1Tcollision-pt: #<vector @ #x~X>~%" (-> this collision-pt))
  (format #t "~1Tnormal: #<vector @ #x~X>~%" (-> this normal))
  (format #t "~1Tfound?: ~A~%" (-> this found?))
  (format #t "~1Tangle: ~f~%" (-> this angle))
  (label cfg-4)
  this
  )

;; definition of type gun-red-2-shockwave
(deftype gun-red-2-shockwave (process)
  ((origin                           vector                  :inline)
   (max-radius                       float)
   (strength                         float)
   (current-radius                   float)
   (current-intensity                float)
   (state-time                       time-frame)
   (alpha-scalar                     float)
   (base-damage                      float)
   (snd-charge                       sound-id)
   (min-charge-radius                float)
   (max-charge-radius                float)
   (total-charge-time                time-frame)
   (total-explode-time               time-frame)
   (ring-expansion-time              time-frame)
   (burst-expansion-time             time-frame)
   (warp-expansion-time              time-frame)
   (previously-attacked-targets      handle                  64)
   (num-previously-attacked-targets  int8)
   (start-pilot?                     symbol)
   (explosion-0                      handle)
   (explosion-1                      handle)
   (generate-order-array             uint8                   127)
   (current-stage-t                  float)
   (ammo-drained                     float)
   (eventual-collision-points        shockwave-collision-pt  128 :inline)
   (next-computed-collision-point    int8)
   (num-collision-pts-to-generate    int8)
   (show-scorch-marks?               symbol)
   (height-off-ground                float)
   (max-ground-radius                float)
   (current-ring-radius              float)
   (current-ring-alpha               float)
   (current-warp-radius              float)
   (current-warp-alpha               float)
   (current-burst-radius             float)
   (current-burst-alpha              float)
   (generating-marks?                symbol)
   (generated-particles?             symbol)
   (charge-part-tracker              handle)
   )
  (:state-methods
    charging
    explode
    die
    )
  (:methods
    (find-targets-and-attack! (_type_) none)
    (send-attack! (_type_ process-focusable symbol) none)
    (find-collision-point! (_type_) int)
    (generate-collision-points! (_type_) none)
    (adjust-height-and-radius (_type_) none)
    (gun-red-2-shockwave-method-22 (_type_ int int int int) none)
    (generate-shockwave-particles (_type_) none)
    (adjust-warp-radius-and-alpha (_type_) object)
    (adjust-ring-radius-and-alpha (_type_) none)
    (generate-order-array (_type_) none)
    (spawn-ring (_type_) none)
    )
  )

;; definition for method 3 of type gun-red-2-shockwave
(defmethod inspect ((this gun-red-2-shockwave))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process inspect)))
    (t9-0 this)
    )
  (format #t "~2Torigin: #<vector @ #x~X>~%" (-> this origin))
  (format #t "~2Tmax-radius: ~f~%" (-> this max-radius))
  (format #t "~2Tstrength: ~f~%" (-> this strength))
  (format #t "~2Tcurrent-radius: ~f~%" (-> this current-radius))
  (format #t "~2Tcurrent-intensity: ~f~%" (-> this current-intensity))
  (format #t "~2Tstate-time: ~D~%" (-> this state-time))
  (format #t "~2Talpha-scalar: ~f~%" (-> this alpha-scalar))
  (format #t "~2Tbase-damage: ~f~%" (-> this base-damage))
  (format #t "~2Tsnd-charge: ~D~%" (-> this snd-charge))
  (format #t "~2Tmin-charge-radius: ~f~%" (-> this min-charge-radius))
  (format #t "~2Tmax-charge-radius: ~f~%" (-> this max-charge-radius))
  (format #t "~2Ttotal-charge-time: ~D~%" (-> this total-charge-time))
  (format #t "~2Ttotal-explode-time: ~D~%" (-> this total-explode-time))
  (format #t "~2Tring-expansion-time: ~D~%" (-> this ring-expansion-time))
  (format #t "~2Tburst-expansion-time: ~D~%" (-> this burst-expansion-time))
  (format #t "~2Twarp-expansion-time: ~D~%" (-> this warp-expansion-time))
  (format #t "~2Tpreviously-attacked-targets[64] @ #x~X~%" (-> this previously-attacked-targets))
  (format #t "~2Tnum-previously-attacked-targets: ~D~%" (-> this num-previously-attacked-targets))
  (format #t "~2Tstart-pilot?: ~A~%" (-> this start-pilot?))
  (format #t "~2Texplosion-0: ~D~%" (-> this explosion-0))
  (format #t "~2Texplosion-1: ~D~%" (-> this explosion-1))
  (format #t "~2Tgenerate-order-array[127] @ #x~X~%" (-> this generate-order-array))
  (format #t "~2Tcurrent-stage-t: ~f~%" (-> this current-stage-t))
  (format #t "~2Tammo-drained: ~f~%" (-> this ammo-drained))
  (format #t "~2Teventual-collision-points[128] @ #x~X~%" (-> this eventual-collision-points))
  (format #t "~2Tnext-computed-collision-point: ~D~%" (-> this next-computed-collision-point))
  (format #t "~2Tnum-collision-pts-to-generate: ~D~%" (-> this num-collision-pts-to-generate))
  (format #t "~2Tshow-scorch-marks?: ~A~%" (-> this show-scorch-marks?))
  (format #t "~2Theight-off-ground: ~f~%" (-> this height-off-ground))
  (format #t "~2Tmax-ground-radius: ~f~%" (-> this max-ground-radius))
  (format #t "~2Tcurrent-ring-radius: ~f~%" (-> this current-ring-radius))
  (format #t "~2Tcurrent-ring-alpha: ~f~%" (-> this current-ring-alpha))
  (format #t "~2Tcurrent-warp-radius: ~f~%" (-> this current-warp-radius))
  (format #t "~2Tcurrent-warp-alpha: ~f~%" (-> this current-warp-alpha))
  (format #t "~2Tcurrent-burst-radius: ~f~%" (-> this current-burst-radius))
  (format #t "~2Tcurrent-burst-alpha: ~f~%" (-> this current-burst-alpha))
  (format #t "~2Tgenerating-marks?: ~A~%" (-> this generating-marks?))
  (format #t "~2Tgenerated-particles?: ~A~%" (-> this generated-particles?))
  (format #t "~2Tcharge-part-tracker: ~D~%" (-> this charge-part-tracker))
  (label cfg-4)
  this
  )

;; definition of type gun-red-2-shockwave-init-params
(deftype gun-red-2-shockwave-init-params (structure)
  ((pos         vector  :inline)
   (max-radius  float)
   (strength    float)
   )
  )

;; definition for method 3 of type gun-red-2-shockwave-init-params
(defmethod inspect ((this gun-red-2-shockwave-init-params))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'gun-red-2-shockwave-init-params)
  (format #t "~1Tpos: #<vector @ #x~X>~%" (-> this pos))
  (format #t "~1Tmax-radius: ~f~%" (-> this max-radius))
  (format #t "~1Tstrength: ~f~%" (-> this strength))
  (label cfg-4)
  this
  )

;; definition for function part-tracker-move-to-target-gun
;; INFO: Used lq/sq
;; WARN: Return type mismatch float vs none.
(defun part-tracker-move-to-target-gun ((arg0 part-tracker))
  (when *target*
    (set! (-> arg0 root trans quad) (-> *target* gun fire-point quad))
    (set! (-> arg0 root trans y) (+ 6553.6 (-> *target* control trans y)))
    )
  (none)
  )

;; definition for function gun-red-2-shockwave-init-by-other
;; INFO: Used lq/sq
(defbehavior gun-red-2-shockwave-init-by-other gun-red-2-shockwave ((arg0 gun-red-2-shockwave-init-params))
  (set! (-> self current-intensity) 0.0)
  (set! (-> self current-radius) 0.0)
  (set! (-> self current-warp-radius) 0.0)
  (set! (-> self current-burst-radius) 0.0)
  (set! (-> self height-off-ground) 0.0)
  (set! (-> self current-ring-radius) 0.0)
  (set! (-> self current-ring-alpha) 0.0)
  (set! (-> self total-explode-time) (seconds 0.7))
  (set! (-> self min-charge-radius) 12288.0)
  (set! (-> self max-charge-radius) 73728.0)
  (set! (-> self total-charge-time) (seconds 1))
  (set! (-> self base-damage) 5.0)
  (set! (-> self ring-expansion-time) (seconds 0.35))
  (set! (-> self burst-expansion-time) (seconds 0.3))
  (set! (-> self warp-expansion-time) (seconds 0.4))
  (set! (-> self explosion-0) (the-as handle #f))
  (set! (-> self explosion-1) (the-as handle #f))
  (set! (-> self ammo-drained) 0.0)
  (set! (-> self snd-charge) (new-sound-id))
  (set! (-> self num-previously-attacked-targets) 0)
  (set! (-> self start-pilot?) (the-as symbol (and *target* (focus-test? *target* pilot))))
  (set! (-> self charge-part-tracker)
        (ppointer->handle (cond
                            ((logtest? (-> *part-group-id-table* 109 flags) (sp-group-flag sp13))
                             (set! (-> *launch-matrix* trans quad) (-> self origin quad))
                             (part-tracker-spawn
                               part-tracker-subsampler
                               :to *entity-pool*
                               :group (-> *part-group-id-table* 109)
                               :callback (the-as (function part-tracker vector) part-tracker-move-to-target-gun)
                               )
                             )
                            (else
                              (set! (-> *launch-matrix* trans quad) (-> self origin quad))
                              (part-tracker-spawn
                                part-tracker
                                :to *entity-pool*
                                :group (-> *part-group-id-table* 109)
                                :callback (the-as (function part-tracker vector) part-tracker-move-to-target-gun)
                                )
                              )
                            )
                          )
        )
  (send-event (handle->process (-> self charge-part-tracker)) 'clock self)
  (dotimes (v1-49 64)
    (set! (-> self eventual-collision-points v1-49 found?) #f)
    )
  (set! (-> self next-computed-collision-point) 0)
  (set! (-> self show-scorch-marks?) #f)
  (set! (-> self generating-marks?) #f)
  (set! (-> self generated-particles?) #f)
  (go-virtual charging)
  )

;; definition for method 17 of type gun-red-2-shockwave
;; INFO: Used lq/sq
(defmethod find-targets-and-attack! ((this gun-red-2-shockwave))
  (local-vars
    (sv-32 vector)
    (sv-2672 (function vector vector float))
    (sv-2688 vector)
    (sv-2704 vector)
    (sv-2720 collide-query)
    )
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (set! sv-32 (new 'stack-no-clear 'vector))
    (set! (-> sv-32 quad) (-> this origin quad))
    (set! (-> sv-32 w) (-> this current-radius))
    (let ((s5-0 (new 'stack-no-clear 'array 'collide-shape 384)))
      (countdown (s4-0 (fill-actor-list-for-box *actor-hash* sv-32 s5-0 384))
        (let* ((s3-0 (-> s5-0 s4-0))
               (v1-6 (if (type? s3-0 collide-shape)
                         s3-0
                         )
                     )
               )
          (when v1-6
            (let* ((s2-0 (-> v1-6 process))
                   (s3-1 (if (type? s2-0 process-focusable)
                             s2-0
                             )
                         )
                   )
              (when s3-1
                (when (and (!= *target* s3-1)
                           (not (focus-test? (the-as process-focusable s3-1) disable dead inactive))
                           (or (logtest? (process-mask crate enemy vehicle civilian) (-> s3-1 mask))
                               (and (logtest? (process-mask guard) (-> s3-1 mask)) (-> *setting-control* user-current gun-target-guards?))
                               )
                           )
                  (let ((s2-1 #f))
                    (let ((s1-0 (process->handle s3-1)))
                      (dotimes (v1-18 (-> this num-previously-attacked-targets))
                        (when (= (-> this previously-attacked-targets v1-18) s1-0)
                          (set! s2-1 #t)
                          0
                          (goto cfg-29)
                          )
                        )
                      (label cfg-29)
                      (when (not s2-1)
                        (let ((s0-0 #f))
                          (set! sv-2672 vector-vector-xz-distance-squared)
                          (set! sv-2688 (-> this origin))
                          (let* ((a1-4 (get-trans (the-as process-focusable s3-1) 3))
                                 (f0-1 (sv-2672 sv-2688 a1-4))
                                 (f1-0 24576.0)
                                 )
                            (cond
                              ((< f0-1 (* f1-0 f1-0))
                               (set! s0-0 #t)
                               )
                              (else
                                (set! sv-2720 (new 'stack-no-clear 'collide-query))
                                (set! (-> sv-2720 start-pos quad) (-> this origin quad))
                                (set! sv-2704 (-> sv-2720 move-dist))
                                (let ((v1-35 (get-trans (the-as process-focusable s3-1) 3))
                                      (a0-26 (-> this origin))
                                      )
                                  (.lvf vf4 (&-> v1-35 quad))
                                  (.lvf vf5 (&-> a0-26 quad))
                                  )
                                (.mov.vf vf6 vf0 :mask #b1000)
                                (.sub.vf vf6 vf4 vf5 :mask #b111)
                                (.svf (&-> sv-2704 quad) vf6)
                                (let ((v1-37 sv-2720))
                                  (set! (-> v1-37 radius) 40.96)
                                  (set! (-> v1-37 collide-with) (collide-spec backgnd))
                                  (set! (-> v1-37 ignore-process0) #f)
                                  (set! (-> v1-37 ignore-process1) #f)
                                  (set! (-> v1-37 ignore-pat)
                                        (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                                        )
                                  (set! (-> v1-37 action-mask) (collide-action solid))
                                  )
                                (if (= (fill-and-probe-using-line-sphere *collide-cache* sv-2720) -100000000.0)
                                    (set! s0-0 #t)
                                    )
                                )
                              )
                            )
                          (when s0-0
                            (send-attack! this (the-as process-focusable s3-1) #t)
                            (set! (-> this previously-attacked-targets (-> this num-previously-attacked-targets)) (the-as handle s1-0))
                            (+! (-> this num-previously-attacked-targets) 1)
                            )
                          )
                        )
                      )
                    (if (and s2-1 (logtest? (process-mask vehicle) (-> s3-1 mask)))
                        (send-attack! this (the-as process-focusable s3-1) #f)
                        )
                    )
                  )
                )
              )
            )
          )
        )
      )
    (let* ((s4-1 *target*)
           (s5-1 (if (type? s4-1 process-focusable)
                     s4-1
                     )
                 )
           )
      (when (and s5-1 (< (vector-vector-distance (get-trans s5-1 0) sv-32) (-> sv-32 w)))
        (when (and (!= *target* s5-1)
                   (not (focus-test? s5-1 disable dead inactive))
                   (or (logtest? (process-mask crate enemy vehicle civilian) (-> s5-1 mask))
                       (and (logtest? (process-mask guard) (-> s5-1 mask)) (-> *setting-control* user-current gun-target-guards?))
                       )
                   )
          (let ((s4-3 #f))
            (let ((s3-2 (process->handle s5-1)))
              (dotimes (v1-68 (-> this num-previously-attacked-targets))
                (when (= (-> this previously-attacked-targets v1-68) s3-2)
                  (set! s4-3 #t)
                  0
                  (goto cfg-71)
                  )
                )
              (label cfg-71)
              (when (not s4-3)
                (let ((s2-2 #f))
                  (let ((f0-5 (vector-vector-xz-distance-squared (-> this origin) (get-trans s5-1 3)))
                        (f1-5 24576.0)
                        )
                    (cond
                      ((< f0-5 (* f1-5 f1-5))
                       (set! s2-2 #t)
                       )
                      (else
                        (let ((s1-2 (new 'stack-no-clear 'collide-query)))
                          (set! (-> s1-2 start-pos quad) (-> this origin quad))
                          (vector-! (-> s1-2 move-dist) (get-trans s5-1 3) (-> this origin))
                          (let ((v1-80 s1-2))
                            (set! (-> v1-80 radius) 40.96)
                            (set! (-> v1-80 collide-with) (collide-spec backgnd))
                            (set! (-> v1-80 ignore-process0) #f)
                            (set! (-> v1-80 ignore-process1) #f)
                            (set! (-> v1-80 ignore-pat)
                                  (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                                  )
                            (set! (-> v1-80 action-mask) (collide-action solid))
                            )
                          (if (= (fill-and-probe-using-line-sphere *collide-cache* s1-2) -100000000.0)
                              (set! s2-2 #t)
                              )
                          )
                        )
                      )
                    )
                  (when s2-2
                    (send-attack! this s5-1 #t)
                    (set! (-> this previously-attacked-targets (-> this num-previously-attacked-targets)) (the-as handle s3-2))
                    (+! (-> this num-previously-attacked-targets) 1)
                    )
                  )
                )
              )
            (if (and s4-3 (logtest? (process-mask vehicle) (-> s5-1 mask)))
                (send-attack! this s5-1 #f)
                )
            )
          )
        )
      )
    (none)
    )
  )

;; definition for method 18 of type gun-red-2-shockwave
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod send-attack! ((this gun-red-2-shockwave) (arg0 process-focusable) (arg1 symbol))
  (let* ((a0-2 (get-trans arg0 3))
         (v1-2 (vector-! (new 'stack-no-clear 'vector) a0-2 (-> this origin)))
         )
    0.0
    (set! (-> v1-2 y) 0.0)
    (let* ((f0-3 (* (-> this base-damage) (-> this current-intensity)))
           (f0-4 (fmax 1.0 f0-3))
           (a0-4 'eco-red)
           )
      (if (not arg1)
          (set! a0-4 'eco-red-shove)
          )
      (+! (-> *game-info* shots-hit 1) 1.0)
      (send-event arg0 'attack #f (static-attack-info
                                    :mask (vehicle-impulse-factor)
                                    ((id (new-attack-id))
                                     (damage f0-4)
                                     (vehicle-damage-factor 1.0)
                                     (vehicle-impulse-factor 1.0)
                                     (mode a0-4)
                                     (attacker-velocity v1-2)
                                     (control (-> this current-intensity))
                                     (penetrate-using (penetrate jak-red-shot jak-red-shockwave))
                                     )
                                    )
                  )
      )
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate charging (gun-red-2-shockwave)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (v0-0 float))
    (case message
      (('charge)
       (return (the-as object (-> self strength)))
       v0-0
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self ammo-drained) 0.0)
    )
  :exit (behavior ()
    (send-event (ppointer->process (-> self parent)) 'release)
    (send-event (handle->process (-> self charge-part-tracker)) 'die)
    (sound-stop (-> self snd-charge))
    )
  :trans (behavior ()
    (let ((t9-0 vector<-cspace!)
          (a0-0 (-> self origin))
          (v1-0 (-> self parent))
          )
      (t9-0 a0-0 (-> (the-as process-drawable (if v1-0
                                                  (the-as process-drawable (-> v1-0 0 self))
                                                  )
                             )
                     node-list
                     data
                     13
                     )
            )
      )
    (sound-play "red2-charge" :id (-> self snd-charge) :position (-> self origin))
    (let ((f0-0 (get-remaining-player-ammo (pickup-type ammo-red))))
      (if (< 0.0 f0-0)
          (set! (-> self strength)
                (fmin 1.0 (/ (the float (- (current-time) (-> self state-time))) (the float (-> self total-charge-time))))
                )
          )
      )
    (let ((f30-0 (cond
                   ((time-elapsed? (-> self state-time) (seconds 1))
                    5.0
                    )
                   ((time-elapsed? (-> self state-time) (seconds 0.75))
                    4.0
                    )
                   ((time-elapsed? (-> self state-time) (seconds 0.5))
                    3.0
                    )
                   ((time-elapsed? (-> self state-time) (seconds 0.25))
                    2.0
                    )
                   ((time-elapsed? (-> self state-time) (seconds 0.1))
                    1.0
                    )
                   (else
                     0.0
                     )
                   )
                 )
          )
      (when (< (-> self ammo-drained) f30-0)
        (let ((f0-5 (- f30-0 (-> self ammo-drained))))
          (adjust-player-ammo (- f0-5) (pickup-type ammo-red))
          )
        (set! (-> self ammo-drained) f30-0)
        )
      )
    (set! (-> *part-id-table* 372 init-specs 2 initial-valuef) (lerp 3276.8 8192.0 (-> self strength)))
    (set! (-> *part-id-table* 373 init-specs 2 initial-valuef) (lerp 8192.0 14336.0 (-> self strength)))
    (if (and (time-elapsed? (-> self state-time) (seconds 0.1))
             (or (not (cpad-hold? 0 r1))
                 (and *target*
                      (focus-test? *target* dead grabbed under-water pole flut board mech dark carry indax teleporting)
                      )
                 (and *target* (not (logtest? (focus-status in-head gun) (-> *target* focus-status))))
                 (and *target* (!= (-> self start-pilot?) (focus-test? *target* pilot)))
                 (not (-> *setting-control* user-current gun))
                 )
             )
        (go-virtual explode)
        )
    )
  :code sleep-code
  :post (behavior ()
    (set! (-> *last-player-pos* x) (-> *target* gun fire-point x))
    (set! (-> *last-player-pos* y) (+ 6553.6 (-> *target* control trans y)))
    (set! (-> *last-player-pos* z) (-> *target* gun fire-point z))
    )
  )

;; definition for function generate-shockwave-scorch-marks-3
;; WARN: Return type mismatch object vs none.
(defbehavior generate-shockwave-scorch-marks-3 gun-red-2-shockwave ((arg0 int))
  (let ((s4-0 (-> self eventual-collision-points arg0))
        (s5-0 (new 'stack-no-clear 'vector))
        )
    (set! (-> s5-0 x) 0.0)
    (set! (-> s5-0 y) 409.6)
    (set! (-> s5-0 z) 0.0)
    (set! (-> s5-0 w) 1.0)
    (when (-> s4-0 found?)
      (let ((gp-0 (new 'stack-no-clear 'matrix)))
        (let ((s3-1 (vector-! (new 'stack-no-clear 'vector) (-> s4-0 collision-pt) (-> self origin))))
          (set! (-> s3-1 y) 0.0)
          (vector-normalize! s3-1 1.0)
          (matrix-u-f-compose gp-0 (-> s4-0 normal) s3-1)
          )
        (vector+! (-> gp-0 trans) (-> s4-0 collision-pt) s5-0)
        (let ((v1-14
                (if (logtest? (-> *part-group-id-table* 89 flags) (sp-group-flag sp13))
                    (part-tracker-spawn
                      part-tracker-subsampler
                      :to *entity-pool*
                      :group (-> *part-group-id-table* 89)
                      :mat-joint gp-0
                      )
                    (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 89) :mat-joint gp-0)
                    )
                )
              )
          (send-event (ppointer->process v1-14) 'clock self)
          )
        )
      )
    )
  (none)
  )

;; definition for function generate-shockwave-scorch-marks-2
;; WARN: Return type mismatch symbol vs none.
(defbehavior generate-shockwave-scorch-marks-2 gun-red-2-shockwave ()
  (set! (-> self show-scorch-marks?) #t)
  (set! (-> self generating-marks?) #t)
  (let ((gp-0 0))
    (dotimes (s5-0 (-> self num-collision-pts-to-generate))
      (when (< 30 gp-0)
        (set! gp-0 0)
        (suspend)
        0
        )
      (+! gp-0 1)
      (generate-shockwave-scorch-marks-3 s5-0)
      )
    )
  (set! (-> self generating-marks?) #f)
  (none)
  )

;; failed to figure out what this is:
(defstate die (gun-red-2-shockwave)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :code (behavior ()
    (when (not (-> self show-scorch-marks?))
      (generate-collision-points! self)
      (generate-shockwave-scorch-marks-2)
      )
    )
  )

;; definition of type gun-red-2-explosion
(deftype gun-red-2-explosion (process-drawable)
  ()
  (:methods
    (gun-red-2-explosion-method-20 (_type_) none)
    )
  )

;; definition for method 3 of type gun-red-2-explosion
(defmethod inspect ((this gun-red-2-explosion))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 22 of type gun-red-2-shockwave
(defmethod gun-red-2-shockwave-method-22 ((this gun-red-2-shockwave) (arg0 int) (arg1 int) (arg2 int) (arg3 int))
  (when (< 1 (- arg1 arg0))
    (let ((s2-0 (/ (+ arg0 arg1) 2)))
      (let ((a0-4 (+ arg3 -1 (ash 1 arg2))))
        (set! (-> this generate-order-array a0-4) (the-as uint (+ s2-0 -1)))
        )
      (gun-red-2-shockwave-method-22 this arg0 s2-0 (+ arg2 1) (* arg3 2))
      (gun-red-2-shockwave-method-22 this s2-0 arg1 (+ arg2 1) (+ (* arg3 2) 1))
      )
    )
  (none)
  )

;; definition for method 19 of type gun-red-2-shockwave
;; INFO: Used lq/sq
;; WARN: Stack slot offset 564 signed mismatch
;; WARN: Stack slot offset 564 signed mismatch
;; WARN: Stack slot offset 564 signed mismatch
(defmethod find-collision-point! ((this gun-red-2-shockwave))
  (local-vars (sv-560 collide-query) (sv-564 int) (sv-608 vector) (sv-612 vector) (sv-616 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (if (>= (-> this next-computed-collision-point) (-> this num-collision-pts-to-generate))
        (return 0)
        )
    (set! sv-560 (new 'stack-no-clear 'collide-query))
    (set! sv-564 (-> this num-collision-pts-to-generate))
    (set! sv-608 (new 'stack-no-clear 'vector))
    (set! sv-612 (new 'stack-no-clear 'vector))
    (set! sv-616 (/ 65536.0 (the float (+ sv-564 -1))))
    (let ((f30-1
            (+ (* sv-616 (the float (-> this generate-order-array (-> this next-computed-collision-point))))
               (rand-vu-float-range (* -0.43478262 sv-616) (* 0.43478262 sv-616))
               )
            )
          )
      (set! (-> this eventual-collision-points (-> this next-computed-collision-point) angle) f30-1)
      (set-vector!
        sv-608
        (* (rand-vu-float-range 0.7 0.9) (-> this max-ground-radius) (cos f30-1))
        32768.0
        (* (rand-vu-float-range 0.7 0.9) (-> this max-ground-radius) (sin f30-1))
        1.0
        )
      )
    (vector+! (-> sv-560 start-pos) (-> this origin) sv-608)
    (set! (-> sv-560 start-pos y) (- (-> sv-560 start-pos y) (-> this height-off-ground)))
    (+! (-> sv-560 start-pos y) 20480.0)
    (set-vector! (-> sv-560 move-dist) 0.0 -65536.0 0.0 1.0)
    (let ((v1-29 sv-560))
      (set! (-> v1-29 radius) 40.96)
      (set! (-> v1-29 collide-with) (collide-spec backgnd hit-by-others-list pusher impenetrable-obj))
      (set! (-> v1-29 ignore-process0) #f)
      (set! (-> v1-29 ignore-process1) #f)
      (set! (-> v1-29 ignore-pat)
            (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
            )
      (set! (-> v1-29 action-mask) (collide-action solid))
      )
    (let ((f0-25 (fill-and-probe-using-line-sphere *collide-cache* sv-560)))
      (when (>= f0-25 0.0)
        (let ((v1-33 sv-612))
          (let ((a0-17 (-> sv-560 start-pos)))
            (let ((a1-7 (-> sv-560 move-dist)))
              (let ((a2-0 f0-25))
                (.mov vf7 a2-0)
                )
              (.lvf vf5 (&-> a1-7 quad))
              )
            (.lvf vf4 (&-> a0-17 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> v1-33 quad) vf6)
          )
        (set! (-> this eventual-collision-points (-> this next-computed-collision-point) collision-pt quad)
              (-> sv-612 quad)
              )
        (+! (-> this eventual-collision-points (-> this next-computed-collision-point) collision-pt y) 204.8)
        (set! (-> this eventual-collision-points (-> this next-computed-collision-point) found?) #t)
        (set! (-> (the-as
                    (pointer uint128)
                    (+ (the-as uint (-> this eventual-collision-points 0 normal)) (* 48 (-> this next-computed-collision-point)))
                    )
                  )
              (-> sv-560 best-other-tri normal quad)
              )
        (let ((s5-1 (new 'stack-no-clear 'vector))
              (s4-0 (new 'stack-no-clear 'vector))
              (s3-1 (vector-float*! (new 'stack-no-clear 'vector) (-> sv-560 best-other-tri normal) 3072.0))
              )
          (let ((s2-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> sv-560 best-other-tri normal) 1.0))
                (s1-0 (new 'stack-no-clear 'vector))
                )
            (vector-get-unique! s1-0 s2-0)
            (vector-cross! s5-1 s2-0 s1-0)
            )
          (vector-normalize! s5-1 1.0)
          (dotimes (s2-1 4)
            (vector-rotate-around-axis!
              s4-0
              (the-as quaternion s5-1)
              (* 16384.0 (the float s2-1))
              (-> sv-560 best-other-tri normal)
              )
            (vector-normalize! s4-0 10240.0)
            (vector+! s4-0 s4-0 s3-1)
            (vector+! (-> sv-560 start-pos) sv-612 s4-0)
            (vector-float*! (-> sv-560 move-dist) (-> sv-560 best-other-tri normal) -6144.0)
            (let ((v1-59 sv-560))
              (set! (-> v1-59 radius) 40.96)
              (set! (-> v1-59 collide-with) (collide-spec backgnd hit-by-others-list pusher impenetrable-obj))
              (set! (-> v1-59 ignore-process0) #f)
              (set! (-> v1-59 ignore-process1) #f)
              (set! (-> v1-59 ignore-pat)
                    (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                    )
              (set! (-> v1-59 action-mask) (collide-action solid))
              )
            (when (< (fill-and-probe-using-line-sphere *collide-cache* sv-560) 0.0)
              (set! (-> this eventual-collision-points (-> this next-computed-collision-point) found?) #f)
              0
              (goto cfg-11)
              )
            )
          )
        )
      )
    (label cfg-11)
    (let ((v0-0 (+ (-> this next-computed-collision-point) 1)))
      (set! (-> this next-computed-collision-point) v0-0)
      v0-0
      )
    )
  )

;; definition for method 20 of type gun-red-2-shockwave
;; WARN: Return type mismatch symbol vs none.
(defmethod generate-collision-points! ((this gun-red-2-shockwave))
  (while (< (-> this next-computed-collision-point) (-> this num-collision-pts-to-generate))
    (find-collision-point! this)
    )
  (none)
  )

;; definition for method 21 of type gun-red-2-shockwave
;; INFO: Used lq/sq
;; WARN: Return type mismatch float vs none.
(defmethod adjust-height-and-radius ((this gun-red-2-shockwave))
  (let ((a1-0 (new 'stack-no-clear 'collide-query)))
    (set! (-> a1-0 start-pos quad) (-> this origin quad))
    (set-vector! (-> a1-0 move-dist) 0.0 (* -1.0 (-> this max-radius)) 0.0 1.0)
    (let ((v1-2 a1-0))
      (set! (-> v1-2 radius) 40.96)
      (set! (-> v1-2 collide-with) (collide-spec backgnd hit-by-others-list pusher impenetrable-obj))
      (set! (-> v1-2 ignore-process0) #f)
      (set! (-> v1-2 ignore-process1) #f)
      (set! (-> v1-2 ignore-pat)
            (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
            )
      (set! (-> v1-2 action-mask) (collide-action solid))
      )
    (let ((f0-6 (fill-and-probe-using-line-sphere *collide-cache* a1-0)))
      (if (>= f0-6 0.0)
          (set! (-> this height-off-ground) (* f0-6 (-> this max-radius)))
          (set! (-> this height-off-ground) (-> this max-radius))
          )
      )
    )
  (set! (-> this max-ground-radius) (-> this max-radius))
  (none)
  )

;; failed to figure out what this is:
(defskelgroup skel-gun-red-sphere gun gun-red-sphere-lod0-jg gun-red-sphere-idle-ja
              ((gun-red-sphere-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 30)
              :texture-level 10
              :sort 4
              )

;; definition of type red-2-ring
(deftype red-2-ring (process-drawable)
  ((current-alpha  float)
   (pad            uint8  12)
   )
  (:state-methods
    active
    fading
    )
  (:methods
    (red-2-ring-method-22 () none)
    )
  )

;; definition for method 3 of type red-2-ring
(defmethod inspect ((this red-2-ring))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tcurrent-alpha: ~f~%" (-> this current-alpha))
  (format #t "~2Tstate-time: ~D~%" (-> this state-time))
  (label cfg-4)
  this
  )

;; definition of type red-2-ring-init-params
(deftype red-2-ring-init-params (structure)
  ((pos  vector  :inline)
   )
  )

;; definition for method 3 of type red-2-ring-init-params
(defmethod inspect ((this red-2-ring-init-params))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'red-2-ring-init-params)
  (format #t "~1Tpos: #<vector @ #x~X>~%" (-> this pos))
  (label cfg-4)
  this
  )

;; definition for function red-2-ring-event-handler
;; INFO: Used lq/sq
(defbehavior red-2-ring-event-handler red-2-ring ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('scale)
     (let ((v1-1 (the-as object (-> arg3 param 0)))
           (v0-0 (the-as object (-> self root scale)))
           )
       (set! (-> (the-as vector v0-0) quad) (-> (the-as vector v1-1) quad))
       v0-0
       )
     )
    (('alpha)
     (set! (-> self current-alpha) (the-as float (-> arg3 param 0)))
     )
    (('start-fade)
     (if (not (and (-> self next-state) (= (-> self next-state name) 'fading)))
         (go-virtual fading)
         )
     )
    )
  )

;; definition for function red-2-ring-init-by-other
;; INFO: Used lq/sq
(defbehavior red-2-ring-init-by-other red-2-ring ((arg0 red-2-ring-init-params))
  (set! (-> self root) (new 'process 'trsqv))
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-generic-blast" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> self root trans quad) (-> arg0 pos quad))
  (quaternion-identity! (-> self root quat))
  (go-virtual active)
  )

;; failed to figure out what this is:
(defstate active (red-2-ring)
  :virtual #t
  :event red-2-ring-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set-vector! (-> self root scale) 1.0 1.0 1.0 1.0)
    )
  :trans (behavior ()
    '()
    )
  :code (behavior ()
    (ja-channel-push! 1 0)
    (ja :group! (-> self draw art-group data 13) :num! zero)
    (let ((gp-0 (ja-num-frames 0)))
      (until #f
        (ja :group! (-> self draw art-group data 13)
            :num! (identity (lerp (the float gp-0) 0.0 (-> self current-alpha)))
            )
        (suspend)
        )
      )
    #f
    )
  :post (behavior ()
    (ja-post)
    )
  )

;; definition for method 23 of type gun-red-2-shockwave
;; INFO: Used lq/sq
;; WARN: Return type mismatch symbol vs none.
(defmethod generate-shockwave-particles ((this gun-red-2-shockwave))
  (local-vars (sv-160 int) (sv-176 shockwave-collision-pt))
  (when (and (not (-> this generated-particles?)) (time-elapsed? (-> this state-time) (seconds 0.067)))
    (set! (-> this generated-particles?) #t)
    (dotimes (s5-0 150)
      (let ((f26-0 (* 436.90668 (the float s5-0)))
            (s3-0 (new 'stack-no-clear 'vector))
            (s4-0 (new 'stack-no-clear 'vector))
            )
        (set! (-> s4-0 quad) (-> this origin quad))
        (set-vector! s3-0 (cos f26-0) 0.0 (sin f26-0) 1.0)
        (vector-normalize! s3-0 (* 0.9 (-> this max-ground-radius)))
        (let ((f30-0 (-> this origin y))
              (f24-0 -32768.0)
              (f28-0 (-> this origin y))
              (f22-0 32768.0)
              )
          0.0
          (let ((s0-0 0)
                (s2-1 (new 'stack-no-clear 'vector))
                (s1-0 (new 'stack-no-clear 'vector))
                )
            (set! sv-160 0)
            (while (< sv-160 (-> this next-computed-collision-point))
              (set! sv-176 (-> this eventual-collision-points sv-160))
              (when (-> sv-176 found?)
                (let ((f0-9 (deg- (-> sv-176 angle) f26-0)))
                  (cond
                    ((and (< f0-9 0.0) (< f24-0 f0-9))
                     (set! f24-0 f0-9)
                     (set! f30-0 (-> sv-176 collision-pt y))
                     (set! s0-0 (logior s0-0 1))
                     (set! (-> s2-1 quad) (-> sv-176 normal quad))
                     )
                    ((and (>= f0-9 0.0) (< f0-9 f22-0))
                     (set! f22-0 f0-9)
                     (set! f28-0 (-> sv-176 collision-pt y))
                     (set! s0-0 (logior s0-0 2))
                     (set! (-> s1-0 quad) (-> sv-176 normal quad))
                     )
                    )
                  )
                )
              (set! sv-160 (+ sv-160 1))
              )
            (let ((f26-1 0.0))
              (cond
                ((= s0-0 3)
                 (set! f26-1 (/ (* -1.0 f24-0) (- f22-0 f24-0)))
                 )
                ((= s0-0 2)
                 (set! f26-1 1.0)
                 )
                ((= s0-0 1)
                 (set! f26-1 0.0)
                 )
                )
              (when #t
                (let ((f0-12 (lerp f30-0 f28-0 f26-1)))
                  (set! (-> s4-0 y) (- (-> s4-0 y) (-> this height-off-ground)))
                  (set! (-> s3-0 y) (- f0-12 (-> s4-0 y)))
                  )
                (let ((s2-2 (vector-lerp! (new 'stack-no-clear 'vector) s2-1 s1-0 f26-1)))
                  (vector-normalize! s2-2 2048.0)
                  (vector+! s3-0 s3-0 s2-2)
                  )
                (vector-normalize! s3-0 1.0)
                (let ((s2-3 (new 'stack-no-clear 'matrix)))
                  (matrix-f-u-compose s2-3 s3-0 *up-vector*)
                  (set! (-> s2-3 trans quad) (-> s4-0 quad))
                  (launch-particles (-> *part-id-table* 353) s2-3 :origin-is-matrix #t)
                  )
                )
              )
            )
          )
        )
      )
    )
  (none)
  )

;; definition for method 24 of type gun-red-2-shockwave
(defmethod adjust-warp-radius-and-alpha ((this gun-red-2-shockwave))
  (let* ((f0-1 (/ (-> this max-radius) (-> this max-charge-radius)))
         (f0-3
           (/ (the float (- (current-time) (-> this state-time))) (* f0-1 (the float (-> this warp-expansion-time))))
           )
         (f0-4 (* f0-3 f0-3))
         )
    (set! (-> this current-warp-radius) (lerp (-> this min-charge-radius) (-> this max-radius) f0-4))
    )
  (let ((f0-7 (/ (-> this current-warp-radius) (-> this max-radius))))
    (if (< 1.0 f0-7)
        (set! (-> this current-warp-alpha) (fmax 0.0 (- 2.0 f0-7)))
        )
    )
  (let ((v1-8 (new 'stack-no-clear 'vector)))
    (set! (-> v1-8 x) (/ (-> this current-warp-radius) METER_LENGTH))
    (set! (-> v1-8 y) 1.0)
    (set! (-> v1-8 z) (/ (-> this current-warp-radius) METER_LENGTH))
    (set! (-> v1-8 w) 1.0)
    (send-event (handle->process (-> this explosion-1)) 'scale v1-8)
    )
  (send-event (handle->process (-> this explosion-1)) 'alpha (-> this current-warp-alpha))
  )

;; definition for method 25 of type gun-red-2-shockwave
;; WARN: Return type mismatch float vs none.
(defmethod adjust-ring-radius-and-alpha ((this gun-red-2-shockwave))
  (let ((f0-2 (/ (the float (- (current-time) (-> this state-time))) (the float (-> this ring-expansion-time)))))
    (set! (-> this current-ring-radius) (lerp (-> this min-charge-radius) (-> this max-charge-radius) f0-2))
    )
  (let ((f0-5 (/ (-> this current-ring-radius) (-> this max-radius))))
    (if (< 1.0 f0-5)
        (set! (-> this current-ring-alpha) (fmax 0.0 (- 1.7 f0-5)))
        )
    )
  (none)
  )

;; definition for method 26 of type gun-red-2-shockwave
;; WARN: Return type mismatch symbol vs none.
(defmethod generate-order-array ((this gun-red-2-shockwave))
  (gun-red-2-shockwave-method-22 this 0 (-> this num-collision-pts-to-generate) 0 0)
  (let ((a0-3 (log2 (-> this num-collision-pts-to-generate))))
    (when (< (ash 1 a0-3) (-> this num-collision-pts-to-generate))
      (let ((v1-7 (+ (ash 1 (+ (log2 (-> this num-collision-pts-to-generate)) 1)) -1))
            (a0-7 0)
            )
        (dotimes (a1-1 v1-7)
          (set! (-> this generate-order-array a0-7) (-> this generate-order-array a1-1))
          (if (nonzero? (-> this generate-order-array a0-7))
              (+! a0-7 1)
              )
          )
        )
      )
    )
  (none)
  )

;; failed to figure out what this is:
(when (or (zero? *impact-blur*) (!= loading-level global))
  (set! *impact-blur* (new 'loading-level 'curve2d-piecewise))
  (allocate! *impact-blur* 3 'loading-level #f)
  )

;; failed to figure out what this is:
(set! (-> *impact-blur* pts data 0 first) 0.0)

;; failed to figure out what this is:
(set! (-> *impact-blur* pts data 0 second) 0.0)

;; failed to figure out what this is:
(set! (-> *impact-blur* pts data 1 first) 0.2)

;; failed to figure out what this is:
(set! (-> *impact-blur* pts data 1 second) 1.0)

;; failed to figure out what this is:
(set! (-> *impact-blur* pts data 2 first) 1.0)

;; failed to figure out what this is:
(set! (-> *impact-blur* pts data 2 second) 0.0)

;; failed to figure out what this is:
(when (or (zero? *shockwave-blur-red-2*) (!= loading-level global))
  (set! *shockwave-blur-red-2* (new 'loading-level 'curve2d-piecewise))
  (allocate! *shockwave-blur-red-2* 5 'loading-level #f)
  )

;; failed to figure out what this is:
(set! (-> *shockwave-blur-red-2* pts data 0 first) 0.0)

;; failed to figure out what this is:
(set! (-> *shockwave-blur-red-2* pts data 0 second) 0.0)

;; failed to figure out what this is:
(set! (-> *shockwave-blur-red-2* pts data 1 first) 0.7)

;; failed to figure out what this is:
(set! (-> *shockwave-blur-red-2* pts data 1 second) 0.0)

;; failed to figure out what this is:
(set! (-> *shockwave-blur-red-2* pts data 2 first) 0.8)

;; failed to figure out what this is:
(set! (-> *shockwave-blur-red-2* pts data 2 second) 1.0)

;; failed to figure out what this is:
(set! (-> *shockwave-blur-red-2* pts data 3 first) 0.9)

;; failed to figure out what this is:
(set! (-> *shockwave-blur-red-2* pts data 3 second) 0.3)

;; failed to figure out what this is:
(set! (-> *shockwave-blur-red-2* pts data 4 first) 1.0)

;; failed to figure out what this is:
(set! (-> *shockwave-blur-red-2* pts data 4 second) 0.0)

;; definition for method 27 of type gun-red-2-shockwave
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod spawn-ring ((this gun-red-2-shockwave))
  (let ((v1-0 (new 'stack-no-clear 'vector)))
    (set! (-> v1-0 quad) (-> this origin quad))
    (set! (-> v1-0 y) (- (-> v1-0 y) (-> this height-off-ground)))
    (+! (-> v1-0 y) 2048.0)
    (+! (-> v1-0 y) -1433.6)
    (let ((s5-0 (new 'stack-no-clear 'red-2-ring-init-params)))
      (set! (-> s5-0 pos quad) (-> v1-0 quad))
      (let ((v1-3 (process-spawn red-2-ring s5-0 :name "red-2-ring" :to this)))
        (if v1-3
            (set! (-> this explosion-1) (ppointer->handle v1-3))
            )
        )
      )
    )
  (none)
  )

;; definition for method 10 of type gun-red-2-shockwave
(defmethod deactivate ((this gun-red-2-shockwave))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (setup-zoom-blur-2d *blit-displays-work* (-> this origin) 0 1.0 #f)
  (call-parent-method this)
  (none)
  )

;; failed to figure out what this is:
(defstate explode (gun-red-2-shockwave)
  :virtual #t
  :enter (behavior ()
    (let ((f30-0 (lerp 0.3 0.8 (-> self strength)))
          (a3-0 (the int (* 300.0 (lerp 0.1 0.4 (-> self strength)))))
          )
      (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 (the int (* 255.0 f30-0)) (the-as time-frame a3-0))
      )
    (sound-play "red2-shot")
    (set-time! (-> self state-time))
    (set! (-> self max-radius) (lerp (-> self min-charge-radius) (-> self max-charge-radius) (-> self strength)))
    (/ (-> self max-radius) (-> self max-charge-radius))
    (let ((f0-15 (/ (-> self max-radius) (meters 20))))
      0.0
      (let ((f1-5 (/ (* 2.0 (- (* 163840.0 f0-15) (-> self max-radius))) (* f0-15 f0-15))))
        (set! (-> *part-id-table* 353 init-specs 9 initial-valuef) (* 1.2 f1-5))
        )
      (let ((v1-15 (the int (* 150.0 f0-15))))
        (set! (-> *part-id-table* 354 init-specs 3 initial-valuef) (the-as float (+ v1-15 -25)))
        (set! (-> *part-id-table* 354 init-specs 3 random-rangef) (the-as float (+ v1-15 -5)))
        )
      )
    (adjust-height-and-radius self)
    (set! (-> self current-intensity) (-> self strength))
    (spawn-ring self)
    (set! (-> self num-collision-pts-to-generate)
          (the int (fmax 6.0 (fmin 64.0 (* 64.0 (/ (-> self max-ground-radius) (-> self max-charge-radius))))))
          )
    (generate-order-array self)
    (set! (-> self current-ring-alpha) 1.0)
    (set! (-> self current-burst-alpha) 1.0)
    (set! (-> self current-warp-alpha) 1.0)
    )
  :exit (behavior ()
    (setup-zoom-blur-2d *blit-displays-work* (-> self origin) 0 1.0 #f)
    )
  :trans (behavior ()
    (let ((f0-1
            (fmin 1.0 (/ (the float (- (current-time) (-> self state-time))) (the float (-> self total-explode-time))))
            )
          )
      (set! (-> self current-radius)
            (fmin (lerp (-> self min-charge-radius) (-> self max-charge-radius) f0-1) (-> self max-radius))
            )
      )
    (set! (-> self current-stage-t)
          (/ (- (-> self current-radius) (-> self min-charge-radius))
             (- (-> self max-radius) (-> self min-charge-radius))
             )
          )
    (set! (-> self current-intensity)
          (cond
            ((logtest? (game-secrets gun-upgrade-red-2) (-> *game-info* secrets))
             (let ((f0-8 (fmin (-> self current-stage-t) (* 1.5 (-> self current-stage-t) (-> self current-stage-t)))))
               (fmax 0.3 (lerp (-> self strength) 0.0 f0-8))
               )
             )
            (else
              (lerp (-> self strength) 0.0 (-> self current-stage-t))
              )
            )
          )
    (generate-shockwave-particles self)
    (adjust-ring-radius-and-alpha self)
    (adjust-warp-radius-and-alpha self)
    (let ((f0-14 (-> self current-stage-t)))
      0.0
      (let* ((f0-16 (- 1.0 (evaluate *impact-blur* f0-14 (loop-behavior use-default))))
             (f0-19 (lerp f0-16 1.0 (fmax 0.0 (- 0.5 (-> self strength)))))
             )
        (setup-zoom-blur-2d *blit-displays-work* (-> self origin) 2 (fmin 1.0 f0-19) #f)
        )
      )
    (if (< (-> self current-stage-t) 1.0)
        (find-targets-and-attack! self)
        )
    (cond
      ((and (not (-> self generating-marks?)) (-> self show-scorch-marks?) (>= 0.0 (-> self current-warp-alpha)))
       (go-virtual die)
       )
      ((and (not (-> self show-scorch-marks?))
            (< (-> self next-computed-collision-point) (-> self num-collision-pts-to-generate))
            )
       (find-collision-point! self)
       (find-collision-point! self)
       (find-collision-point! self)
       )
      )
    (if (and (not (-> self show-scorch-marks?))
             (time-elapsed? (-> self state-time) (the int (* 0.0036621094 (-> self max-radius))))
             )
        (set! (-> self show-scorch-marks?) #t)
        )
    )
  :code (behavior ()
    (while (not (-> self show-scorch-marks?))
      (suspend)
      )
    (generate-collision-points! self)
    (generate-shockwave-scorch-marks-2)
    (sleep-code)
    )
  :post (behavior ()
    (set-vector! (new 'stack-no-clear 'vector) 1.9 0.0 0.0 (-> self alpha-scalar))
    (set! (-> *part-id-table* 229 init-specs 2 initial-valuef) (* 2.0 (-> self current-ring-radius)))
    (set! (-> *part-id-table* 229 init-specs 7 initial-valuef) (* 128.0 (-> self current-ring-alpha)))
    (set! (-> *part-id-table* 226 init-specs 3 initial-valuef)
          (lerp 20480.0 24576.0 (/ (-> self max-radius) (-> self max-charge-radius)))
          )
    (set! (-> *part-id-table* 226 init-specs 3 initial-valuef)
          (/ (-> *part-id-table* 226 init-specs 3 initial-valuef) 2)
          )
    (set! (-> *part-id-table* 226 init-specs 3 random-rangef)
          (lerp 0.0 20480.0 (/ (-> self max-radius) (-> self max-charge-radius)))
          )
    (launch-particles (-> *part-id-table* 229) (-> self origin))
    )
  )

;; definition for function gun-fire-red-2
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs object.
(defbehavior gun-fire-red-2 target ()
  (let ((gp-0 (-> self gun))
        (v1-1 (-> self gun fire-point))
        )
    (set! (-> *last-player-pos* x) (-> *target* gun fire-point x))
    (set! (-> *last-player-pos* y) (+ 6553.6 (-> *target* control trans y)))
    (set! (-> *last-player-pos* z) (-> *target* gun fire-point z))
    (when #t
      (let ((s5-0 (new 'stack-no-clear 'gun-red-2-shockwave-init-params)))
        (set! (-> s5-0 pos quad) (-> v1-1 quad))
        (let ((v1-4 (process-spawn
                      gun-red-2-shockwave
                      s5-0
                      :name "gun-red-2-shockwave"
                      :to (ppointer->process (-> gp-0 gun))
                      :stack *kernel-dram-stack*
                      )
                    )
              )
          (set! (-> gp-0 gun 0 extra) (ppointer->handle v1-4))
          (let ((v0-0 (ppointer->handle v1-4)))
            (set! (-> self gun charge-active?) (the-as handle v0-0))
            v0-0
            )
          )
        )
      )
    )
  )

;; definition of type red-3-sphere
(deftype red-3-sphere (process-drawable)
  ((current-alpha  float)
   (pad            uint8  12)
   )
  (:state-methods
    active
    )
  (:methods
    (red-3-sphere-method-21 (_type_) none)
    (red-3-sphere-method-22 (_type_) none)
    )
  )

;; definition for method 3 of type red-3-sphere
(defmethod inspect ((this red-3-sphere))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tcurrent-alpha: ~f~%" (-> this current-alpha))
  (format #t "~2Tstate-time: ~D~%" (-> this state-time))
  (label cfg-4)
  this
  )

;; definition of type red-3-sphere-init-params
(deftype red-3-sphere-init-params (structure)
  ((pos  vector  :inline)
   )
  )

;; definition for method 3 of type red-3-sphere-init-params
(defmethod inspect ((this red-3-sphere-init-params))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'red-3-sphere-init-params)
  (format #t "~1Tpos: #<vector @ #x~X>~%" (-> this pos))
  (label cfg-4)
  this
  )

;; definition for function red-3-sphere-init-by-other
;; INFO: Used lq/sq
(defbehavior red-3-sphere-init-by-other red-3-sphere ((arg0 red-3-sphere-init-params))
  (set! (-> self root) (new 'process 'trsqv))
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-gun-red-sphere" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> self root trans quad) (-> arg0 pos quad))
  (quaternion-identity! (-> self root quat))
  (go-virtual active)
  )

;; failed to figure out what this is:
(defstate active (red-3-sphere)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set-vector! (-> self root scale) 1.0 1.0 1.0 1.0)
    )
  :trans (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'matrix)))
      (let* ((a2-0 (math-camera-matrix))
             (v1-0 (-> a2-0 rvec quad))
             (a0-0 (-> a2-0 uvec quad))
             (a1-0 (-> a2-0 fvec quad))
             (a2-1 (-> a2-0 trans quad))
             )
        (set! (-> gp-0 rvec quad) v1-0)
        (set! (-> gp-0 uvec quad) a0-0)
        (set! (-> gp-0 fvec quad) a1-0)
        (set! (-> gp-0 trans quad) a2-1)
        )
      (-> gp-0 fvec)
      (-> gp-0 rvec)
      (matrix->quat gp-0 (-> self root quat))
      )
    (set! (-> self current-alpha) (* 0.008333334 (the float (- (current-time) (-> self state-time)))))
    (let ((f0-3 (+ (-> self root scale x) (* 24.0 (seconds-per-frame)))))
      (set-vector! (-> self root scale) f0-3 f0-3 f0-3 1.0)
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 0)
    (ja-no-eval :group! gun-red-sphere-burst-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (ja-no-eval :group! gun-red-sphere-fade-ja :num! (seek! max 5.0) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max 5.0))
      )
    (deactivate self)
    )
  :post (behavior ()
    (ja-post)
    )
  )

;; definition for function gun-fire-red-3
;; INFO: Used lq/sq
;; WARN: Return type mismatch (pointer process) vs gun-red-3-grenade.
;; ERROR: Unsupported inline assembly instruction kind - [mula.s f1, f4]
;; ERROR: Unsupported inline assembly instruction kind - [madda.s f2, f5]
;; ERROR: Unsupported inline assembly instruction kind - [madd.s f1, f3, f6]
(defbehavior gun-fire-red-3 target ()
  (local-vars
    (f1-2 float)
    (sv-16 gun-info)
    (sv-20 vector)
    (sv-24 vector)
    (sv-28 float)
    (sv-144 vector)
    (sv-148 vector)
    (sv-1952 vector)
    (sv-1968 vector)
    )
  (set! sv-16 (-> self gun))
  (set! sv-20 (-> self gun fire-dir-out))
  (set! sv-24 (-> self gun fire-point))
  (set! sv-28 (the-as float 266240.0))
  (draw-beam (-> *part-id-table* 217) sv-24 sv-20 #f)
  (set! (-> sv-20 y) (fmax 0.3 (-> sv-20 y)))
  (vector-normalize! sv-20 1.0)
  (let ((v1-17 (cond
                 ((logtest? (-> *part-group-id-table* 86 flags) (sp-group-flag sp13))
                  (set! (-> *launch-matrix* trans quad) (-> sv-16 fire-point quad))
                  (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 86))
                  )
                 (else
                   (set! (-> *launch-matrix* trans quad) (-> sv-16 fire-point quad))
                   (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 86))
                   )
                 )
               )
        )
    (send-event (ppointer->process v1-17) 'clock self)
    )
  (set! sv-144 (new 'stack-no-clear 'vector))
  (let ((v1-42 (new 'stack-no-clear 'vector)))
    (set! (-> v1-42 quad) (-> sv-20 quad))
    (set! sv-148 v1-42)
    )
  (set! (-> sv-148 y) 0.0)
  (vector-normalize! sv-148 1.0)
  (vector+float*! sv-144 sv-24 sv-148 143360.0)
  (set! (-> sv-144 w) 143360.0)
  (let ((f30-0 4096000.0)
        (s5-0 #f)
        (gp-2 (the-as process-focusable #f))
        )
    (let ((a1-11 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-11 from) (process->ppointer self))
      (set! (-> a1-11 num-params) 0)
      (set! (-> a1-11 message) 'get-vehicle)
      (let ((s4-0 (send-event-function *target* a1-11)))
        (let ((s3-0 (new 'stack-no-clear 'array 'collide-shape 384)))
          (countdown (s2-0 (fill-actor-list-for-box *actor-hash* sv-144 s3-0 384))
            (let* ((s1-0 (-> s3-0 s2-0))
                   (v1-54 (if (type? s1-0 collide-shape)
                              s1-0
                              )
                          )
                   )
              (when v1-54
                (let* ((s0-0 (-> v1-54 process))
                       (s1-1 (if (type? s0-0 process-focusable)
                                 s0-0
                                 )
                             )
                       )
                  (when s1-1
                    (when (and (!= *target* s1-1)
                               (not (focus-test? (the-as process-focusable s1-1) disable dead inactive gun-no-target))
                               (or (logtest? (process-mask crate enemy vehicle civilian) (-> s1-1 mask))
                                   (and (logtest? (process-mask guard) (-> s1-1 mask)) (-> *setting-control* user-current gun-target-guards?))
                                   )
                               (!= s4-0 s1-1)
                               )
                      (when (or (not s5-0) (logtest? (process-mask enemy guard) (-> s1-1 mask)))
                        (set! sv-1952 (new 'stack-no-clear 'vector))
                        (let ((v1-71 (-> (get-trans (the-as process-focusable s1-1) 0) quad)))
                          (set! (-> sv-1952 quad) v1-71)
                          )
                        (set! sv-1968 (vector-normalize-copy! (new 'stack-no-clear 'vector) sv-148 1.0))
                        (let ((s0-1 (new 'stack-no-clear 'vector)))
                          (let ((a1-18 s0-1)
                                (v1-72 sv-24)
                                )
                            (vector-! a1-18 sv-1952 v1-72)
                            )
                          (let ((f0-7 (vector-normalize-ret-len! s0-1 1.0)))
                            (let* ((v1-73 s0-1)
                                   (f1-1 (-> sv-1968 x))
                                   (f2-0 (-> sv-1968 y))
                                   (f3-0 (-> sv-1968 z))
                                   (f4-0 (-> v1-73 x))
                                   (f5-0 (-> v1-73 y))
                                   (f6-0 (-> v1-73 z))
                                   )
                              (.mula.s f1-1 f4-0)
                              (.madda.s f2-0 f5-0)
                              (.madd.s f1-2 f3-0 f6-0)
                              )
                            (let ((f1-3 f1-2)
                                  (v1-75 (and (not s5-0) (logtest? (process-mask enemy guard) (-> s1-1 mask))))
                                  )
                              (when (and (< 0.707 f1-3) (< (fabs (-> s0-1 y)) 28672.0) (or v1-75 (< f0-7 f30-0)))
                                (set! s5-0 v1-75)
                                (set! f30-0 f0-7)
                                (set! gp-2 (the-as process-focusable s1-1))
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        (let* ((s2-1 *target*)
               (s3-1 (if (type? s2-1 process-focusable)
                         s2-1
                         )
                     )
               )
          (when (and s3-1 (< (vector-vector-distance (get-trans s3-1 0) sv-144) (-> sv-144 w)))
            (when (and (!= *target* s3-1)
                       (not (focus-test? s3-1 disable dead inactive gun-no-target))
                       (or (logtest? (process-mask crate enemy vehicle civilian) (-> s3-1 mask))
                           (and (logtest? (process-mask guard) (-> s3-1 mask)) (-> *setting-control* user-current gun-target-guards?))
                           )
                       (!= s4-0 s3-1)
                       )
              (when (or (not s5-0) (logtest? (process-mask enemy guard) (-> s3-1 mask)))
                (let ((s1-2 (new 'stack-no-clear 'vector)))
                  (set! (-> s1-2 quad) (-> (get-trans s3-1 0) quad))
                  (let ((s2-3 (vector-normalize-copy! (new 'stack-no-clear 'vector) sv-148 1.0))
                        (s4-1 (new 'stack-no-clear 'vector))
                        )
                    (vector-! s4-1 s1-2 sv-24)
                    (let ((f0-9 (vector-normalize-ret-len! s4-1 1.0))
                          (f1-8 (vector-dot s2-3 s4-1))
                          (v1-101 (and (not s5-0) (logtest? (process-mask enemy guard) (-> s3-1 mask))))
                          )
                      (if (and (< 0.707 f1-8) (< (fabs (-> s4-1 y)) 28672.0) (or v1-101 (< f0-9 f0-9)))
                          (set! gp-2 s3-1)
                          )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    (when gp-2
      (let ((s5-1 (new 'stack-no-clear 'vector)))
        (set! (-> s5-1 quad) (-> (get-trans gp-2 3) quad))
        (let ((f0-10 (vector-vector-xz-distance s5-1 (-> sv-16 fire-point)))
              (f1-13 (fabs (- (-> s5-1 y) (-> sv-16 fire-point y))))
              )
          0.0
          (when (< f1-13 24576.0)
            (let ((f0-14 (* 0.5 (asin (/ (* 184320.0 f0-10) (* sv-28 sv-28))))))
              (set! (-> sv-20 y) (sin f0-14))
              )
            (vector-normalize! sv-20 1.0)
            )
          )
        )
      )
    )
  (let ((a1-33 (new 'stack-no-clear 'projectile-init-by-other-params)))
    (set! (-> a1-33 ent) (-> self entity))
    (set! (-> a1-33 charge) 1.0)
    (set! (-> a1-33 options) (projectile-options))
    (logclear! (-> a1-33 options) (projectile-options po14 po15 po16))
    (set! (-> a1-33 pos quad) (-> sv-24 quad))
    (set! (-> a1-33 vel quad) (-> (vector-float*! (new 'stack-no-clear 'vector) sv-20 sv-28) quad))
    (set! (-> a1-33 notify-handle) (the-as handle #f))
    (set! (-> a1-33 owner-handle) (process->handle self))
    (set! (-> a1-33 target-handle) (the-as handle #f))
    (set! (-> a1-33 target-pos quad) (the-as uint128 0))
    (set! (-> a1-33 ignore-handle) (process->handle self))
    (let* ((v1-127 *game-info*)
           (a0-100 (+ (-> v1-127 attack-id) 1))
           )
      (set! (-> v1-127 attack-id) a0-100)
      (set! (-> a1-33 attack-id) a0-100)
      )
    (set! (-> a1-33 timeout) (seconds 4))
    (the-as gun-red-3-grenade (spawn-projectile gun-red-3-grenade a1-33 self *default-dead-pool*))
    )
  )

;; definition for method 39 of type gun-red-3-grenade
;; WARN: Return type mismatch sound-id vs none.
(defmethod projectile-method-39 ((this gun-red-3-grenade))
  (let* ((a2-0 (-> this root))
         (v1-0 (-> a2-0 status))
         )
    (if (logtest? v1-0 (collide-status touch-surface))
        (vector-float*! (-> a2-0 transv) (-> a2-0 transv) 0.6)
        )
    (when (and (logtest? v1-0 (collide-status impact-surface))
               (time-elapsed? (-> this played-bounce-time) (seconds 0.3))
               )
      (set-time! (-> this played-bounce-time))
      (sound-play "grenade-bounce")
      )
    )
  (none)
  )

;; failed to figure out what this is:
(defstate moving (gun-red-3-grenade)
  :virtual #t
  :trans (behavior ()
    (go-impact self)
    (call-parent-state-handler trans)
    )
  )

;; failed to figure out what this is:
(defstate sitting (gun-red-3-grenade)
  :virtual #t
  :trans (behavior ()
    (go-impact self)
    (call-parent-state-handler trans)
    )
  )

;; failed to figure out what this is:
(defstate impact-tiny (gun-red-3-grenade)
  :virtual #t
  :event projectile-event-handler
  :enter (behavior ()
    '()
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'explosion-init-params)))
      (set! (-> gp-0 spawn-point quad) (-> self root trans quad))
      (quaternion-identity! (-> gp-0 spawn-quat))
      (set! (-> gp-0 radius) 0.0)
      (set! (-> gp-0 scale) 1.0)
      (set! (-> gp-0 group) (-> *part-group-id-table* 104))
      (set! (-> gp-0 collide-with) (collide-spec))
      (set! (-> gp-0 damage) 2.0)
      (set! (-> gp-0 damage-scale) 1.0)
      (set! (-> gp-0 vehicle-damage-factor) 1.0)
      (set! (-> gp-0 vehicle-impulse-factor) 1.0)
      (set! (-> gp-0 ignore-proc) (process->handle #f))
      (explosion-spawn gp-0 self)
      )
    (logior! (-> self draw status) (draw-control-status no-draw))
    (while (-> self child)
      (suspend)
      )
    (deactivate self)
    )
  )

;; definition for method 10 of type gun-red-3-grenade
(defmethod deactivate ((this gun-red-3-grenade))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (setup-zoom-blur-2d *blit-displays-work* *zero-vector* 0 1.0 #f)
  (call-parent-method this)
  (none)
  )

;; failed to figure out what this is:
(defstate impact (gun-red-3-grenade)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touched)
       (when (send-event
               proc
               'attack
               (-> block param 0)
               (static-attack-info :mask (vehicle-impulse-factor) ((id (-> self attack-id))
                                                                   (damage 2.0)
                                                                   (vehicle-damage-factor 1.0)
                                                                   (vehicle-impulse-factor 1.0)
                                                                   (mode 'explode)
                                                                   )
                                   )
               )
         (+! (-> *game-info* shots-hit 1) 1.0)
         #t
         )
       )
      )
    )
  :code (behavior ()
    (sound-play "red3-blast")
    (find-and-damage-targets self)
    (set-time! (-> self state-time))
    (when (not (-> self immediate-detonation?))
      (let ((gp-1 (new 'stack-no-clear 'red-3-sphere-init-params)))
        (set! (-> gp-1 pos quad) (-> self root trans quad))
        (process-spawn red-3-sphere gp-1 :name "red-3-sphere" :to self)
        )
      )
    (cond
      ((logtest? (-> *part-group-id-table* 88 flags) (sp-group-flag sp13))
       (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
       (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 88))
       )
      (else
        (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
        (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 88))
        )
      )
    (logior! (-> self draw status) (draw-control-status no-draw))
    (let ((v1-49 (-> self root root-prim)))
      (set! (-> v1-49 prim-core collide-as) (collide-spec))
      (set! (-> v1-49 prim-core collide-with) (collide-spec))
      )
    0
    (let ((gp-4 (-> self child)))
      (while gp-4
        (send-event (ppointer->process gp-4) 'notice 'die)
        (set! gp-4 (-> gp-4 0 brother))
        )
      )
    (let ((gp-6 (vector-! (new 'stack-no-clear 'vector) (-> self root trans) (math-camera-pos))))
      0.0
      (let* ((f0-2 (vector-length gp-6))
             (f30-0 (/ f0-2 (meters 150)))
             )
        (cpad-set-buzz!
          (-> *cpad-list* cpads 0)
          1
          (the int (* 255.0 (lerp-scale-clamp 1.0 0.3 f30-0 0.1 0.8)))
          (the-as time-frame (the int (* 300.0 (lerp 0.3 0.1 f30-0))))
          )
        (let ((f30-1 (fmin 1.0 f30-0)))
          (while (-> self child)
            (let ((f0-11 (* 0.0044444446 (the float (- (current-time) (-> self state-time))))))
              0.0
              (let* ((f0-13 (- 1.0 (evaluate *impact-blur* f0-11 (loop-behavior clamp))))
                     (f0-14 (lerp f0-13 1.0 f30-1))
                     )
                (set! (-> *display* force-sync) (the-as uint 2))
                (setup-zoom-blur-2d *blit-displays-work* (-> self root trans) 2 (fmin 1.0 f0-14) #f)
                )
              )
            (let ((gp-8 (-> self child)))
              (while gp-8
                (send-event (ppointer->process gp-8) 'notice 'die)
                (set! gp-8 (-> gp-8 0 brother))
                )
              )
            (suspend)
            )
          )
        )
      )
    (setup-zoom-blur-2d *blit-displays-work* (-> self root trans) 15 1.0 #f)
    (deactivate self)
    )
  )

;; definition for function gun-fire-red-1
;; INFO: Used lq/sq
;; WARN: Return type mismatch (pointer process) vs object.
(defbehavior gun-fire-red-1 target ()
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 (-> self gun)))
      (let ((s5-0 (-> *part-id-table* 216)))
        (get-field-spec-by-id s5-0 (sp-field-id spt-omega))
        (let ((s5-1 (get-field-spec-by-id s5-0 (sp-field-id spt-rotate-y))))
          (if s5-1
              (set! (-> s5-1 initial-valuef) (y-angle (-> self control)))
              )
          )
        )
      (launch-particles (-> *part-id-table* 216) (-> gp-0 fire-point))
      (let ((s5-2 (new 'stack-no-clear 'vector)))
        (let ((v1-10 (-> gp-0 fire-point)))
          (let ((a0-4 (-> gp-0 fire-dir-out)))
            (let ((a1-4 24576.0))
              (.mov vf7 a1-4)
              )
            (.lvf vf5 (&-> a0-4 quad))
            )
          (.lvf vf4 (&-> v1-10 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> s5-2 quad) vf6)
        (set! (-> s5-2 w) 24576.0)
        (when (and (sphere-in-view-frustum? (the-as sphere s5-2))
                   (< 24576.0 (vector-vector-distance s5-2 (math-camera-pos)))
                   )
          (let ((s5-3
                  (process-spawn
                    manipy
                    :init manipy-init
                    (-> gp-0 fire-point)
                    (-> self entity)
                    (art-group-get-by-name *level* "skel-gun-red-cone" (the-as (pointer level) #f))
                    #f
                    0
                    :name "manipy"
                    :to self
                    :stack-size #x20000
                    )
                  )
                )
            (when s5-3
              (send-event (ppointer->process s5-3) 'anim-mode 'play1)
              (send-event (ppointer->process s5-3) 'anim "idle")
              (forward-up->quaternion (-> (the-as manipy (-> s5-3 0)) root quat) (-> gp-0 fire-dir-out) *up-vector*)
              (let ((f30-1
                      (vector-dot
                        (-> gp-0 fire-dir-out)
                        (vector-! (new 'stack-no-clear 'vector) (-> gp-0 fire-point) (math-camera-pos))
                        )
                      )
                    (f0-5 (vector-vector-xz-distance (-> gp-0 fire-point) (math-camera-pos)))
                    )
                (when (and (< f30-1 0.0) (< f0-5 32768.0))
                  (set! (-> (the-as manipy (-> s5-3 0)) root scale z) (lerp-scale 0.2 1.0 (fabs f0-5) 20480.0 32768.0))
                  (set! (-> (the-as manipy (-> s5-3 0)) root scale x) (-> (the-as manipy (-> s5-3 0)) root scale z))
                  )
                )
              )
            )
          )
        )
      (process-spawn
        gun-red-shot
        (-> gp-0 fire-point)
        (-> gp-0 fire-dir-out)
        :name "gun-red-shot"
        :to (ppointer->process (-> gp-0 gun))
        )
      )
    )
  )

;; definition for function target-gun-can-fire-red?
(defbehavior target-gun-can-fire-red? target ((arg0 pickup-type))
  #t
  )

;; definition for function target-gun-fire-red
;; WARN: Return type mismatch object vs (pointer process).
(defbehavior target-gun-fire-red target ((arg0 pickup-type))
  (+! (-> *game-info* shots-fired 1) 1.0)
  (the-as (pointer process) (case arg0
                              (((pickup-type gun-red-1))
                               (gun-fire-red-1)
                               )
                              (((pickup-type gun-red-2))
                               (gun-fire-red-2)
                               )
                              (((pickup-type gun-red-3))
                               (gun-fire-red-3)
                               )
                              )
          )
  )

;; definition for function gun-red-shot-event-handler
;; WARN: Return type mismatch none vs object.
(defbehavior gun-red-shot-event-handler gun-red-shot ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('touched)
     (send-attack! self (the-as process-drawable arg0) (the-as touching-shapes-entry (-> arg3 param 0)))
     )
    )
  )

;; definition for method 29 of type gun-red-shot
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defmethod send-attack! ((this gun-red-shot) (arg0 process-drawable) (arg1 touching-shapes-entry))
  (let* ((s5-0 arg0)
         (v1-0 (if (type? s5-0 process-drawable)
                   s5-0
                   )
               )
         )
    (when v1-0
      (let* ((s5-2 (vector-! (new 'stack-no-clear 'vector) (-> v1-0 root trans) (-> this start-pos)))
             (f30-0 (* (if (< (vector-length s5-2) 24576.0)
                           3.0
                           2.0
                           )
                       (if (logtest? (game-feature feature22) (-> *game-info* features))
                           2.0
                           1.0
                           )
                       )
                    )
             )
        (if (and (logtest? (process-mask guard) (-> arg0 mask))
                 (not (-> *setting-control* user-current gun-target-guards?))
                 )
            (set! f30-0 0.0)
            )
        (let ((s2-0 (new 'stack-no-clear 'vector)))
          (rot-zxy-from-vector! s2-0 s5-2)
          (let ((f28-0 (deg- (-> s2-0 x) (-> this start-rot x)))
                (f0-6 (deg- (-> s2-0 y) (-> this start-rot y)))
                )
            (when (or (< 2730.6667 (fabs f28-0)) (< 8192.0 (fabs f0-6)))
              (let ((f1-5 (fmax -2730.6667 (fmin 2730.6667 f28-0)))
                    (f0-8 (fmax -8192.0 (fmin 8192.0 f0-6)))
                    )
                (set! (-> s2-0 x) (+ (-> this start-rot x) f1-5))
                (set! (-> s2-0 y) (+ (-> this start-rot y) f0-8))
                )
              (set-vector! s5-2 0.0 0.0 1.0 1.0)
              (vector-rotate-around-x! s5-2 s5-2 (-> s2-0 x))
              (vector-rotate-around-y! s5-2 s5-2 (-> s2-0 y))
              )
            )
          )
        (+! (-> *game-info* shots-hit 1) 1.0)
        (send-event
          arg0
          'attack
          arg1
          (static-attack-info :mask (vehicle-impulse-factor) ((id (-> this attack-id))
                                                              (damage f30-0)
                                                              (vehicle-damage-factor 1.0)
                                                              (vehicle-impulse-factor 1.0)
                                                              (mode 'eco-red)
                                                              (attacker-velocity s5-2)
                                                              (attacker (process->handle *target*))
                                                              )
                              )
          )
        )
      )
    )
  (none)
  )

;; definition for method 25 of type gun-red-shot
;; WARN: Return type mismatch int vs none.
(defmethod stub ((this gun-red-shot))
  0
  (none)
  )

;; definition for method 23 of type gun-red-shot
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod init-probes! ((this gun-red-shot) (arg0 collide-shape))
  (let ((s5-0 (-> this probe-count)))
    (when (< s5-0 19)
      (let* ((s4-0 (-> arg0 process))
             (a0-2 (if (type? s4-0 process-focusable)
                       (the-as process-focusable s4-0)
                       )
                   )
             (s4-1 (new 'stack-no-clear 'vector))
             )
        (if a0-2
            (set! (-> s4-1 quad) (-> (get-trans a0-2 3) quad))
            (set! (-> s4-1 quad) (-> arg0 root-prim prim-core world-sphere quad))
            )
        (vector-! s4-1 s4-1 (-> this start-pos))
        (vector-normalize! s4-1 1.0)
        (let ((s3-2 (new 'stack-no-clear 'vector)))
          (rot-zxy-from-vector! s3-2 s4-1)
          (let ((f30-0 (deg- (-> s3-2 x) (-> this start-rot x)))
                (f0-4 (deg- (-> s3-2 y) (-> this start-rot y)))
                )
            (when (or (< 2730.6667 (fabs f30-0)) (< 8192.0 (fabs f0-4)))
              (let ((f1-3 (fmax -2730.6667 (fmin 2730.6667 f30-0)))
                    (f0-6 (fmax -8192.0 (fmin 8192.0 f0-4)))
                    )
                (set! (-> s3-2 x) (+ (-> this start-rot x) f1-3))
                (set! (-> s3-2 y) (+ (-> this start-rot y) f0-6))
                )
              (set-vector! s4-1 0.0 0.0 1.0 1.0)
              (vector-rotate-around-x! s4-1 s4-1 (-> s3-2 x))
              (vector-rotate-around-y! s4-1 s4-1 (-> s3-2 y))
              )
            )
          )
        (set! (-> this probe-dir s5-0 quad) (-> s4-1 quad))
        )
      (set! (-> this probe-count) (+ s5-0 1))
      )
    )
  (none)
  )

;; definition for method 26 of type gun-red-shot
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod find-targets ((this gun-red-shot))
  (local-vars (a2-5 float) (a2-12 float))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (set! (-> s5-0 quad) (-> this start-dir quad))
      (vector-float*! s5-0 s5-0 43417.6)
      (vector+! s5-0 s5-0 (-> this start-pos))
      (set! (-> s5-0 w) 43827.2)
      (let ((s4-0 (-> this root root-prim prim-core collide-with)))
        (set! *actor-list-length* 0)
        (if (logtest? s4-0 (collide-spec hit-by-others-list))
            (set! *actor-list-length* (fill-actor-list-for-box *actor-hash* s5-0 *actor-list* 256))
            )
        (when (logtest? s4-0 (collide-spec player-list))
          (let ((a0-6 (-> *collide-player-list* alive-list next0)))
            *collide-player-list*
            (let ((v1-18 (-> a0-6 next0)))
              (while (!= a0-6 (-> *collide-player-list* alive-list-end))
                (let* ((a0-7 (-> (the-as connection a0-6) param1))
                       (a1-4 (-> (the-as collide-shape a0-7) root-prim))
                       )
                  (when (logtest? s4-0 (-> a1-4 prim-core collide-as))
                    (let ((a1-5 (-> a1-4 prim-core)))
                      (let ((a2-4 a1-5)
                            (a3-1 s5-0)
                            )
                        (.lvf vf2 (&-> a2-4 world-sphere quad))
                        (.lvf vf3 (&-> a3-1 quad))
                        )
                      (.sub.vf vf1 vf3 vf2)
                      (.mul.vf vf1 vf1 vf1)
                      (.add.y.vf vf1 vf1 vf1 :mask #b1)
                      (.add.z.vf vf1 vf1 vf1 :mask #b1)
                      (.mov a2-5 vf1)
                      (let ((f0-2 a2-5)
                            (f1-1 (+ (-> a1-5 world-sphere w) (-> s5-0 w)))
                            )
                        (when (< f0-2 (* f1-1 f1-1))
                          (when (< *actor-list-length* 256)
                            (set! (-> *actor-list* *actor-list-length*) (the-as collide-shape a0-7))
                            (set! *actor-list-length* (+ *actor-list-length* 1))
                            )
                          )
                        )
                      )
                    )
                  )
                (set! a0-6 v1-18)
                *collide-player-list*
                (set! v1-18 (-> v1-18 next0))
                )
              )
            )
          )
        (when (logtest? s4-0 (collide-spec hit-by-player-list))
          (let ((a0-9 (-> *collide-hit-by-player-list* alive-list next0)))
            *collide-hit-by-player-list*
            (let ((v1-26 (-> a0-9 next0)))
              (while (!= a0-9 (-> *collide-hit-by-player-list* alive-list-end))
                (let* ((a0-10 (-> (the-as connection a0-9) param1))
                       (a1-16 (-> (the-as collide-shape a0-10) root-prim))
                       )
                  (when (logtest? s4-0 (-> a1-16 prim-core collide-as))
                    (let ((a1-17 (-> a1-16 prim-core)))
                      (let ((a2-11 a1-17)
                            (a3-2 s5-0)
                            )
                        (.lvf vf2 (&-> a2-11 world-sphere quad))
                        (.lvf vf3 (&-> a3-2 quad))
                        )
                      (.sub.vf vf1 vf3 vf2)
                      (.mul.vf vf1 vf1 vf1)
                      (.add.y.vf vf1 vf1 vf1 :mask #b1)
                      (.add.z.vf vf1 vf1 vf1 :mask #b1)
                      (.mov a2-12 vf1)
                      (let ((f0-3 a2-12)
                            (f1-5 (+ (-> a1-17 world-sphere w) (-> s5-0 w)))
                            )
                        (when (< f0-3 (* f1-5 f1-5))
                          (when (< *actor-list-length* 256)
                            (set! (-> *actor-list* *actor-list-length*) (the-as collide-shape a0-10))
                            (set! *actor-list-length* (+ *actor-list-length* 1))
                            )
                          )
                        )
                      )
                    )
                  )
                (set! a0-9 v1-26)
                *collide-hit-by-player-list*
                (set! v1-26 (-> v1-26 next0))
                )
              )
            )
          )
        (dotimes (s5-1 *actor-list-length*)
          (let ((a1-28 (-> *actor-list* s5-1)))
            (if (logtest? s4-0 (-> a1-28 root-prim prim-core collide-as))
                (init-probes! this a1-28)
                )
            )
          )
        )
      )
    (set! (-> this actor-count) (-> this probe-count))
    0
    (none)
    )
  )

;; definition for method 27 of type gun-red-shot
;; WARN: Return type mismatch int vs none.
(defmethod setup-probes ((this gun-red-shot))
  (find-targets this)
  (let ((s5-0 (-> this probe-count)))
    (while (< s5-0 19)
      (let ((f28-0 (rand-vu-float-range -2730.6667 2730.6667))
            (f30-0 (rand-vu-float-range -8192.0 8192.0))
            (s4-0 (-> this probe-dir s5-0))
            )
        (set-vector! s4-0 0.0 0.0 1.0 1.0)
        (vector-rotate-around-x! s4-0 s4-0 (+ (-> this start-rot x) f28-0))
        (vector-rotate-around-y! s4-0 s4-0 (+ (-> this start-rot y) f30-0))
        )
      (+! s5-0 1)
      )
    (set! (-> this probe-count) s5-0)
    )
  0
  (none)
  )

;; definition for method 28 of type gun-red-shot
;; INFO: Used lq/sq
;; WARN: Return type mismatch sound-id vs none.
(defmethod do-collision ((this gun-red-shot) (arg0 vector))
  (local-vars (at-0 int))
  (with-pp
    (rlet ((vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (let ((gp-0 (-> this root)))
        (let ((v1-0 (new 'stack-no-clear 'collide-query)))
          (set! (-> gp-0 trans quad) (-> this start-pos quad))
          (vector-float*! (-> gp-0 transv) arg0 61440.0)
          (let ((a1-1 v1-0))
            (set! (-> a1-1 radius) (-> gp-0 root-prim local-sphere w))
            (set! (-> a1-1 collide-with) (-> gp-0 root-prim prim-core collide-with))
            (set! (-> a1-1 ignore-process0) this)
            (set! (-> a1-1 ignore-process1) (ppointer->process (-> this parent)))
            (set! (-> a1-1 ignore-pat)
                  (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                  )
            (set! (-> a1-1 action-mask) (collide-action solid))
            )
          (set! (-> v1-0 start-pos quad) (-> gp-0 trans quad))
          (set! (-> v1-0 move-dist quad) (-> gp-0 transv quad))
          (fill-using-line-sphere *collide-cache* v1-0)
          )
        (let ((v1-2 (-> gp-0 transv)))
          (.lvf vf1 (&-> (-> gp-0 transv) quad))
          (let ((f0-2 (-> pp clock frames-per-second)))
            (.mov at-0 f0-2)
            )
          (.mov vf2 at-0)
          (.mov.vf vf1 vf0 :mask #b1000)
          (.mul.x.vf vf1 vf1 vf2 :mask #b111)
          (.svf (&-> v1-2 quad) vf1)
          )
        (integrate-and-collide! gp-0 (-> gp-0 transv))
        (if (logtest? (-> gp-0 status) (collide-status touch-surface touch-wall))
            (sound-play "red-shot-hit")
            )
        )
      (none)
      )
    )
  )

;; definition for method 24 of type gun-red-shot
(defmethod check-blocked? ((this gun-red-shot))
  (let ((v1-0 (-> this root))
        (t1-0 (new 'stack-no-clear 'collide-query))
        )
    (let ((a1-0 t1-0))
      (set! (-> a1-0 radius) (-> v1-0 root-prim prim-core world-sphere w))
      (set! (-> a1-0 collide-with) (-> v1-0 root-prim prim-core collide-with))
      (set! (-> a1-0 ignore-process0) this)
      (set! (-> a1-0 ignore-process1) (ppointer->process (-> this parent)))
      (set! (-> a1-0 ignore-pat)
            (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
            )
      (set! (-> a1-0 action-mask) (collide-action solid))
      )
    (if (fill-and-try-snap-to-surface v1-0 (-> v1-0 transv) -6144.0 0.0 -2048.0 t1-0)
        #t
        )
    )
  )

;; failed to figure out what this is:
(defstate debug-idle (gun-red-shot)
  :virtual #t
  :code (behavior ()
    (set-time! (-> self state-time))
    (until (time-elapsed? (-> self state-time) (seconds 3))
      (let ((gp-0 (new 'stack-no-clear 'vector)))
        (dotimes (s5-0 (-> self probe-count))
          (vector-float*! gp-0 (-> self probe-dir s5-0) 61440.0)
          (vector+! gp-0 gp-0 (-> self start-pos))
          (add-debug-sphere
            #t
            (bucket-id debug-no-zbuf1)
            gp-0
            (meters 0.5)
            (if (< s5-0 (-> self actor-count))
                (new 'static 'rgba :r #xff :a #x80)
                (new 'static 'rgba :r #xff :g #xff :a #x60)
                )
            )
          )
        )
      (add-debug-vector
        #t
        (bucket-id debug)
        (-> self start-pos)
        (-> self start-dir)
        (meters 6)
        (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
        )
      (suspend)
      )
    )
  )

;; failed to figure out what this is:
(defstate blocked (gun-red-shot)
  :virtual #t
  :event gun-red-shot-event-handler
  :code (behavior ()
    (suspend)
    0
    )
  )

;; failed to figure out what this is:
(defstate idle (gun-red-shot)
  :virtual #t
  :event gun-red-shot-event-handler
  :code (behavior ()
    (let ((gp-0 0))
      (countdown (s5-0 3)
        (countdown (s4-0 7)
          (when (< gp-0 19)
            (do-collision self (-> self probe-dir gp-0))
            (+! gp-0 1)
            )
          )
        (suspend)
        )
      )
    )
  )

;; definition for function gun-red-shot-init-by-other
;; INFO: Used lq/sq
(defbehavior gun-red-shot-init-by-other gun-red-shot ((arg0 vector) (arg1 vector))
  (set! (-> self start-pos quad) (-> arg0 quad))
  (set! (-> self start-dir quad) (-> arg1 quad))
  (rot-zxy-from-vector! (-> self start-rot) arg1)
  (let* ((v1-2 *game-info*)
         (a0-7 (+ (-> v1-2 attack-id) 1))
         )
    (set! (-> v1-2 attack-id) a0-7)
    (set! (-> self attack-id) a0-7)
    )
  (let ((s5-0 (new 'process 'collide-shape-moving self (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction)
          (the-as (function control-info collide-query vector vector collide-status) cshape-reaction-just-move)
          )
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrate-using) (penetrate jak-red-shot))
    (let ((v1-10 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec projectile))
      (set! (-> v1-10 prim-core collide-with)
            (collide-spec backgnd bot crate civilian enemy obstacle vehicle-sphere hit-by-others-list pusher shield)
            )
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set-vector! (-> v1-10 local-sphere) 0.0 0.0 0.0 819.2)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-10)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> s5-0 max-iteration-count) (the-as uint 1))
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> self root) s5-0)
    )
  (let ((s5-1 (-> self root)))
    (set! (-> s5-1 trans quad) (-> arg0 quad))
    (quaternion-copy! (-> s5-1 quat) (-> self parent 0 root quat))
    (vector-identity! (-> s5-1 scale))
    )
  (update-transforms (-> self root))
  (set! (-> self event-hook) gun-red-shot-event-handler)
  (logior! (-> self mask) (process-mask projectile))
  (logclear! (-> self mask) (process-mask enemy))
  (setup-probes self)
  (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 204 (seconds 0.1))
  (let ((v1-39 (cond
                 ((logtest? (-> *part-group-id-table* 84 flags) (sp-group-flag sp13))
                  (set! (-> *launch-matrix* trans quad) (-> self start-pos quad))
                  (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 84))
                  )
                 (else
                   (set! (-> *launch-matrix* trans quad) (-> self start-pos quad))
                   (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 84))
                   )
                 )
               )
        )
    (send-event (ppointer->process v1-39) 'clock self)
    )
  (draw-beam (-> *part-id-table* 213) (-> self start-pos) (-> self start-dir) #f)
  (sound-play "red-shot-fire")
  (vector-float*! (-> self root transv) (-> self start-dir) 61440.0)
  (if (check-blocked? self)
      (go-virtual blocked)
      (go-virtual idle)
      )
  )
