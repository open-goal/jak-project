;;-*-Lisp-*-
(in-package goal)

;; definition for symbol *auto-continue*, type symbol
(define *auto-continue* #f)

;; definition for function next-continue
;; WARN: Return type mismatch object vs continue-point.
(defun next-continue ((arg0 continue-point))
  (let* ((v1-0 #f)
         (a1-0 *level-load-list*)
         (a2-0 (car a1-0))
         )
    (while (not (null? a1-0))
      (let* ((a2-2 (-> (the-as level-load-info (-> (the-as symbol a2-0) value)) continues))
             (a3-0 (car a2-2))
             )
        (while (not (null? a2-2))
          (if (and v1-0 (logtest? (continue-flags test) (-> (the-as continue-point a3-0) flags)))
              (return (the-as continue-point a3-0))
              )
          (if (= a3-0 arg0)
              (set! v1-0 #t)
              )
          (set! a2-2 (cdr a2-2))
          (set! a3-0 (car a2-2))
          )
        )
      (set! a1-0 (cdr a1-0))
      (set! a2-0 (car a1-0))
      )
    )
  (the-as continue-point #f)
  )

;; definition for function arrive-at-continue
;; WARN: Found some very strange gotos. Check result carefully, this is not well tested.
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defbehavior arrive-at-continue target ((arg0 continue-point))
  (cond
    ((logtest? (-> arg0 flags) (continue-flags title))
     (go target-title #t)
     )
    ((logtest? (-> arg0 flags) (continue-flags title-movie))
     (go target-title #f)
     )
    ((logtest? (-> arg0 flags) (continue-flags intro))
     (pre-intro-play)
     )
    ((logtest? (-> arg0 flags) (continue-flags hero-mode))
     (when (string= (-> arg0 name) "intro-start-hero")
       (logior! (-> self game secrets) (game-secrets hero-mode))
       (logior! (-> self game purchase-secrets) (game-secrets hero-mode))
       )
     (intro-play)
     )
    ((logtest? (-> arg0 flags) (continue-flags warp-gate))
     (suspend-for (seconds 0.05)
       )
     (let ((s5-1 (new 'static 'vector))
           (a2-0 (find-nearest-entity (-> arg0 trans) warp-gate))
           )
       (when a2-0
         (set! (-> s5-1 quad) (-> a2-0 extra trans quad))
         (+! (-> s5-1 y) 9011.2)
         (go target-warp-in s5-1 (-> arg0 trans) a2-0)
         )
       )
     )
    ((logtest? (continue-flags indax) (-> arg0 flags))
     (go target-indax-start (the-as handle #f) (if (logtest? (continue-flags indax-hang) (-> arg0 flags))
                                                   'hang
                                                   #t
                                                   )
         )
     )
    ((logtest? (continue-flags flut) (-> arg0 flags))
     (go target-flut-start (the-as handle #f) 'normal -1)
     )
    ((logtest? (continue-flags flut-racer) (-> arg0 flags))
     (go target-flut-start (the-as handle #f) 'racer -1)
     )
    ((logtest? (continue-flags flut-fight) (-> arg0 flags))
     (go target-flut-start (the-as handle #f) 'fight -1)
     )
    ((logtest? (continue-flags lightjak) (-> arg0 flags))
     (send-event self 'get-pickup (pickup-type eco-pill-light) 100.0)
     (case (-> arg0 vehicle-type)
       ((38)
        (go target-lightjak-get-on (lightjak-stage ls0 ls2 swoop ls7))
        )
       (else
         (go target-lightjak-get-on (lightjak-stage ls0 ls2 ls7))
         )
       )
     )
    ((logtest? (-> arg0 flags) (continue-flags darkjak))
     (send-event self 'get-pickup (pickup-type eco-pill-dark) 100.0)
     (go target-darkjak-get-on (darkjak-stage force-on active no-anim))
     )
    ((logtest? (continue-flags vehicle) (-> arg0 flags))
     (label cfg-39)
     (let* ((v1-77 (-> arg0 vehicle-type))
            (s5-2
              (cond
                ((= v1-77 7)
                 (process->handle (search-process-tree *active-pool* (lambda ((arg0 process)) (type? arg0 bt-gun-manager))))
                 )
                ((= v1-77 14)
                 (process->handle
                   (search-process-tree *active-pool* (lambda ((arg0 process)) (type? arg0 scorpion-gun-manager)))
                   )
                 )
                (else
                  (process->handle (search-process-tree *active-pool* (lambda ((arg0 process)) (type? arg0 target-turret))))
                  )
                )
              )
            )
       (when (not (handle->process s5-2))
         (suspend)
         (goto cfg-39)
         )
       (suspend)
       (case (-> arg0 vehicle-type)
         ((14)
          (send-event (handle->process s5-2) 'restart)
          )
         )
       (send-event (handle->process s5-2) 'pickup)
       )
     )
    ((logtest? (continue-flags vehicle-scorpion) (-> arg0 flags))
     (label cfg-84)
     (let ((gp-1 (process->handle
                   (search-process-tree *active-pool* (lambda ((arg0 process)) (type? arg0 scorpion-gun-manager)))
                   )
                 )
           )
       (when (not (handle->process gp-1))
         (suspend)
         (goto cfg-84)
         )
       (suspend)
       (send-event (handle->process gp-1) 'restart)
       (when (not (send-event (handle->process gp-1) 'pickup))
         (suspend)
         0
         )
       )
     )
    ((logtest? (continue-flags htorpedo) (-> arg0 flags))
     (label cfg-114)
     (let ((gp-2 (process->handle (search-process-tree *active-pool* (lambda ((arg0 process)) (type? arg0 htorpedo))))))
       (when (not (handle->process gp-2))
         (suspend)
         (goto cfg-114)
         )
       (suspend)
       (set-blackout-frames (seconds 10))
       (send-event self 'change-mode 'pilot-daxter (handle->process gp-2))
       )
     )
    ((logtest? (continue-flags mech) (-> arg0 flags))
     (go target-mech-start (the-as handle #f) 100.0 #t)
     )
    ((logtest? (continue-flags nothing-apparently) (-> arg0 flags))
     )
    ((logtest? (continue-flags credits) (-> arg0 flags))
     (case (-> arg0 vehicle-type)
       ((41)
        (go target-credits 1)
        )
       ((42)
        (go target-credits 2)
        )
       ((43)
        (go target-credits 3)
        )
       (else
         (go target-credits 0)
         )
       )
     )
    ((and (logtest? (continue-flags race) (-> arg0 flags)) (!= (-> arg0 vehicle-type) 27))
     (set! (-> self mode-cache) 'pilot)
     (set! (-> self mode-param1) (the-as handle #f))
     (set! (-> self mode-param2) (-> arg0 vehicle-type))
     (when (= (-> arg0 vehicle-type) 28)
       (let ((v1-172 (cond
                       ((have-vehicle-v-type? (the-as vehicle-type (-> self game current-vehicle)))
                        (the-as int (-> self game current-vehicle))
                        )
                       ((have-vehicle-v-type? (vehicle-type v-snake))
                        13
                        )
                       ((have-vehicle-v-type? (vehicle-type v-turtle))
                        12
                        )
                       ((have-vehicle-v-type? (vehicle-type v-scorpion))
                        14
                        )
                       ((have-vehicle-v-type? (vehicle-type v-toad))
                        15
                        )
                       )
                     )
             )
         (set! (-> self mode-param2) (the-as uint v1-172))
         )
       )
     (set! (-> self mode-param3) (the-as uint #t))
     )
    ((logtest? (-> arg0 flags) (continue-flags grab))
     (go target-grab 'stance)
     )
    (else
      (suspend-for (seconds 0.05)
        )
      )
    )
  0
  (none)
  )

;; definition for function apply-pos-from-entity
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defbehavior apply-pos-from-entity target ((arg0 continue-point))
  (local-vars (sv-1328 collide-query))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s1-0 (entity-by-name (the-as string (-> arg0 on-goto)))))
      (cond
        (s1-0
          (entity-birth-no-kill s1-0)
          (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-0 from) (process->ppointer self))
            (set! (-> a1-0 num-params) 0)
            (set! (-> a1-0 message) 'apply-pos-from-entity)
            (let ((t9-2 send-event-function)
                  (v1-2 s1-0)
                  )
              (t9-2
                (if v1-2
                    (-> v1-2 extra process)
                    )
                a1-0
                )
              )
            )
          (let ((s0-0 (-> s1-0 extra perm)))
            (logior! (-> s0-0 status) (entity-perm-status bit-5))
            (let ((s2-0 (new 'stack-no-clear 'vector))
                  (s3-0 (new 'stack-no-clear 'vector))
                  (s4-0 (new 'stack-no-clear 'vector))
                  (s5-0 (new 'stack-no-clear 'matrix))
                  )
              (set! (-> s2-0 x) (* 4096.0 (the float (-> s0-0 user-int16 0))))
              (set! (-> s2-0 y) (-> s1-0 extra trans y))
              (set! (-> s2-0 z) (* 4096.0 (the float (-> s0-0 user-int16 1))))
              (set! sv-1328 (new 'stack-no-clear 'collide-query))
              (set-vector! (-> sv-1328 move-dist) 0.0 -204800.0 0.0 1.0)
              (set! (-> sv-1328 start-pos quad) (-> s2-0 quad))
              (+! (-> sv-1328 start-pos y) 102400.0)
              (let ((v1-20 sv-1328))
                (set! (-> v1-20 radius) 409.6)
                (set! (-> v1-20 collide-with) (collide-spec backgnd))
                (set! (-> v1-20 ignore-process0) #f)
                (set! (-> v1-20 ignore-process1) #f)
                (set! (-> v1-20 ignore-pat)
                      (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                      )
                (set! (-> v1-20 action-mask) (collide-action solid))
                )
              (let ((f0-12 (fill-and-probe-using-line-sphere *collide-cache* sv-1328)))
                (cond
                  ((>= f0-12 0.0)
                   (let ((v1-22 s2-0))
                     (let ((a0-15 (-> sv-1328 start-pos)))
                       (let ((a1-3 (-> sv-1328 move-dist)))
                         (let ((a2-0 f0-12))
                           (.mov vf7 a2-0)
                           )
                         (.lvf vf5 (&-> a1-3 quad))
                         )
                       (.lvf vf4 (&-> a0-15 quad))
                       )
                     (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                     (.mul.x.vf acc vf5 vf7 :mask #b111)
                     (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                     (.svf (&-> v1-22 quad) vf6)
                     )
                   (set! (-> s2-0 y) (+ 4096.0 (-> s2-0 y)))
                   )
                  (else
                    (format 0 "failed to find gem ground on pos-from-entity~%")
                    )
                  )
                )
              (set! (-> s3-0 x) (* 4096.0 (the float (-> s0-0 user-int16 2))))
              (set! (-> s3-0 y) (-> s1-0 extra trans y))
              (set! (-> s3-0 z) (* 4096.0 (the float (-> s0-0 user-int16 3))))
              (let ((s1-1 (new 'stack-no-clear 'collide-query)))
                (set-vector! (-> s1-1 move-dist) 0.0 -204800.0 0.0 1.0)
                (set! (-> s1-1 start-pos quad) (-> s3-0 quad))
                (+! (-> s1-1 start-pos y) 102400.0)
                (let ((v1-33 s1-1))
                  (set! (-> v1-33 radius) 409.6)
                  (set! (-> v1-33 collide-with) (collide-spec backgnd))
                  (set! (-> v1-33 ignore-process0) #f)
                  (set! (-> v1-33 ignore-process1) #f)
                  (set! (-> v1-33 ignore-pat)
                        (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                        )
                  (set! (-> v1-33 action-mask) (collide-action solid))
                  )
                (let ((f0-27 (fill-and-probe-using-line-sphere *collide-cache* s1-1)))
                  (cond
                    ((>= f0-27 0.0)
                     (let ((a0-26 s3-0))
                       (let ((v1-35 (-> s1-1 start-pos)))
                         (let ((a1-6 (-> s1-1 move-dist)))
                           (let ((a2-1 f0-27))
                             (.mov vf7 a2-1)
                             )
                           (.lvf vf5 (&-> a1-6 quad))
                           )
                         (.lvf vf4 (&-> v1-35 quad))
                         )
                       (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                       (.mul.x.vf acc vf5 vf7 :mask #b111)
                       (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                       (.svf (&-> a0-26 quad) vf6)
                       )
                     (set! (-> s3-0 y) (+ 4096.0 (-> s3-0 y)))
                     )
                    (else
                      (format 0 "failed to find jak ground on pos-from-entity~%")
                      )
                    )
                  )
                )
              (set! (-> arg0 trans quad) (-> s3-0 quad))
              (vector-! s4-0 s3-0 s2-0)
              (set! (-> s4-0 y) 16384.0)
              (vector+! (-> arg0 camera-trans) s4-0 s3-0)
              (vector-negate! s4-0 s4-0)
              (set! (-> s4-0 y) 0.0)
              (vector-normalize! s4-0 1.0)
              (let ((s3-1 (new 'stack-no-clear 'quaternion)))
                (quaternion-from-two-vectors! s3-1 (new 'static 'vector :z 1.0) s4-0)
                (quaternion->matrix s5-0 s3-1)
                (set-vector!
                  (-> arg0 quat)
                  (the int (* 32767.0 (-> s3-1 x)))
                  (the int (* 32767.0 (-> s3-1 y)))
                  (the int (* 32767.0 (-> s3-1 z)))
                  (the int (* 32767.0 (-> s3-1 w)))
                  )
                )
              (set! (-> arg0 camera-rot 0) (the int (* 32767.0 (-> s5-0 rvec x))))
              (set! (-> arg0 camera-rot 1) (the int (* 32767.0 (-> s5-0 rvec y))))
              (set! (-> arg0 camera-rot 2) (the int (* 32767.0 (-> s5-0 rvec z))))
              (set! (-> arg0 camera-rot 3) (the int (* 32767.0 (-> s5-0 uvec x))))
              (set! (-> arg0 camera-rot 4) (the int (* 32767.0 (-> s5-0 uvec y))))
              (set! (-> arg0 camera-rot 5) (the int (* 32767.0 (-> s5-0 uvec z))))
              (set! (-> arg0 camera-rot 6) (the int (* 32767.0 (-> s5-0 fvec x))))
              (set! (-> arg0 camera-rot 7) (the int (* 32767.0 (-> s5-0 fvec y))))
              (set! (-> arg0 camera-rot 8) (the int (* 32767.0 (-> s5-0 fvec z))))
              )
            )
          (let ((t9-11 quaternion-copy!)
                (a0-46 (-> self control quat-for-control))
                (a1-12 (new 'stack-no-clear 'quaternion))
                )
            (set! (-> a1-12 x) (* 0.00003051851 (the float (-> arg0 quat x))))
            (set! (-> a1-12 y) (* 0.00003051851 (the float (-> arg0 quat y))))
            (set! (-> a1-12 z) (* 0.00003051851 (the float (-> arg0 quat z))))
            (set! (-> a1-12 w) (* 0.00003051851 (the float (-> arg0 quat w))))
            (t9-11 a0-46 a1-12)
            )
          (move-to-point! (-> self control) (-> arg0 trans))
          (rot->dir-targ! (-> self control))
          (set! (-> self control camera-pos quad) (-> self control trans quad))
          )
        (else
          (format 0 "ERROR: failed to find '~S' for pos-from-entity~%" (-> arg0 on-goto))
          )
        )
      )
    (none)
    )
  )

;; definition for function target-continue-init-art
;; WARN: Return type mismatch int vs none.
(defbehavior target-continue-init-art target ()
  (let ((a1-0 (target-skel-group))
        (gp-0 (new 'stack-no-clear 'lod-set))
        )
    (setup-lods! gp-0 a1-0 (-> self draw art-group) (-> self entity))
    (lods-assign! (-> self draw) gp-0)
    )
  (let ((gp-1 (target-skel-group)))
    (when (-> gp-1 clothing)
      (when (not (-> self draw cloth-instances))
        (set! (-> self draw cloth-instances) (new 'process 'boxed-array cloth-on-skeleton (-> gp-1 clothing length)))
        (set! (-> self draw cloth-instances length) (-> self draw cloth-instances allocated-length))
        (dotimes (s5-0 (-> gp-1 clothing length))
          (set! (-> self draw cloth-instances s5-0) (new 'process 'cloth-on-skeleton))
          )
        )
      (case (-> self ext-geo)
        (((target-geo jakc))
         (dotimes (s5-1 (-> gp-1 clothing length))
           (setup-from-params! (-> self draw cloth-instances s5-1) (-> gp-1 clothing s5-1) (process->handle self))
           (logior! (-> self draw cloth-instances s5-1 flags) (cloth-flag need-reset active))
           )
         )
        (else
          (dotimes (v1-41 (-> gp-1 clothing length))
            (logclear! (-> self draw cloth-instances v1-41 flags) (cloth-flag active))
            )
          )
        )
      )
    )
  (case (-> self ext-geo)
    (((target-geo jakc))
     (set! (-> self draw shadow)
           (the-as
             shadow-geo
             (-> self
                 draw
                 art-group
                 data
                 (-> (the-as skeleton-group (art-group-get-by-name *level* "skel-jchar-c" (the-as (pointer level) #f))) shadow)
                 )
             )
           )
     )
    (((target-geo jakb))
     (set! (-> self draw shadow)
           (the-as
             shadow-geo
             (-> self
                 draw
                 art-group
                 data
                 (-> (the-as skeleton-group (art-group-get-by-name *level* "skel-jchar-normal" (the-as (pointer level) #f)))
                     shadow
                     )
                 )
             )
           )
     )
    (else
      (set! (-> self draw shadow) #f)
      )
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate target-continue (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (v0-0 object))
    (case message
      (('change-mode)
       (case (-> block param 0)
         (('grab 'look-around)
          #f
          )
         (else
           (set! (-> self mode-cache) (the-as symbol (-> block param 0)))
           (set! (-> self mode-param1) (if (>= argc 2)
                                           (process->handle (the-as process (-> block param 1)))
                                           (the-as handle #f)
                                           )
                 )
           (set! (-> self mode-param2) (-> block param 2))
           (set! v0-0 (-> block param 3))
           (set! (-> self mode-param3) (the-as uint v0-0))
           v0-0
           )
         )
       )
      (('want-continue)
       (set! v0-0 (-> block param 0))
       (set! (-> self control unknown-word04) (the-as uint v0-0))
       v0-0
       )
      (else
        (target-generic-event-handler proc argc message block)
        )
      )
    )
  :exit (behavior ()
    (set! (-> *level* camera-pos 0 quad) (-> (camera-pos) quad))
    (set! (-> *level* camera-pos 1 quad) (-> *level* camera-pos 0 quad))
    (set! (-> *level* target-pos 0 quad) (-> (target-pos 0) quad))
    (set! (-> *level* target-pos 1 quad) (-> *level* target-pos 0 quad))
    (set! (-> *setting-control* user-default border-mode) (-> *level* play?))
    (set! (-> *setting-control* user-default region-mode) #t)
    (kill-persister *setting-control* (the-as engine-pers 'title-control) 'render)
    (let ((v1-16 (-> self control root-prim)))
      (set! (-> v1-16 prim-core collide-as) (-> self control backup-collide-as))
      (set! (-> v1-16 prim-core collide-with) (-> self control backup-collide-with))
      )
    (remove-setting! 'allow-pause)
    (remove-setting! 'allow-progress)
    (remove-setting! 'allow-timeout)
    (remove-setting! 'bg-a)
    (remove-setting! 'music-volume)
    (remove-setting! 'sfx-volume)
    (remove-setting! 'dialog-volume)
    (remove-setting! 'ambient-volume)
    (remove-setting! 'music)
    (remove-setting! 'region-mode)
    (remove-setting! 'border-mode)
    (remove-setting! 'allow-continue)
    (remove-setting! 'level-trans-time)
    (remove-setting! 'speech-control)
    (apply-settings *setting-control*)
    (logclear! (-> self focus-status) (focus-status teleporting))
    (set! (-> self mode-cache) #f)
    (set-time! (-> self teleport-time))
    (set! (-> self control last-trans-any-surf quad) (-> self control trans quad))
    (set! (-> self game kiosk-timeout) (-> *display* game-clock frame-counter))
    0
    )
  :code (behavior ((arg0 continue-point))
    (local-vars (v1-126 symbol))
    (set! (-> self control mod-surface) *empty-mods-allow-gun*)
    (let ((v1-2 (-> self control root-prim)))
      (set! (-> v1-2 prim-core collide-as) (collide-spec))
      (set! (-> v1-2 prim-core collide-with) (collide-spec))
      )
    0
    (set! *spawn-actors* #f)
    (set! (-> self control unknown-word04) (the-as uint #f))
    (set! (-> self mode-cache) #f)
    (set-time! (-> self state-time))
    (logior! (-> self focus-status) (focus-status teleporting))
    (let ((a0-4 (get-continue-by-name (-> self game) (-> arg0 name))))
      (cond
        (a0-4
          (set! (-> self game last-continue) a0-4)
          )
        ((string= (-> arg0 name) "default")
         )
        (else
          (format 0 "ERROR: TARGET: attempting to goto continue ~A which is not in level-info~%" (-> arg0 name))
          )
        )
      )
    (if (-> *art-control* reserve-buffer)
        (reserve-free *art-control* (-> *art-control* reserve-buffer heap))
        )
    (kill-persister *setting-control* (the-as engine-pers 'fail) 'bg-a)
    (kill-persister *setting-control* (the-as engine-pers 'fail-sfx-volume) 'sfx-volume)
    (kill-persister *setting-control* (the-as engine-pers 'fail-dialog-volume) 'dialog-volume)
    (kill-persister *setting-control* (the-as engine-pers 'fail-music-volume) 'music-volume)
    (when (-> *setting-control* user-current render)
      (when (not (logtest? (continue-flags no-blackout vehicle-movie) (-> arg0 flags)))
        (add-setting! 'bg-a 'abs 1.0 0)
        (set! (-> *setting-control* user-current bg-a) 1.0)
        )
      )
    (set-setting! 'sfx-volume 'abs 0.0 0)
    (set-setting! 'ambient-volume 'abs 0.0 0)
    (set-setting! 'dialog-volume 'abs 0.0 0)
    (set-setting! 'music-volume 'abs 0.0 0)
    (set-setting! 'region-mode #f 0.0 0)
    (set-setting! 'border-mode #f 0.0 0)
    (set-setting! 'allow-continue #f 0.0 0)
    (set-setting! 'allow-timeout #f 0.0 0)
    (set-setting! 'speech-control #f 0.0 0)
    (set-setting! 'allow-pause #f 0.0 0)
    (set-setting! 'allow-progress #f 0.0 0)
    (set-setting! 'level-trans-time #f 0.0 0)
    (kill-persister *setting-control* (the-as engine-pers 'speech-control) 'speech-control)
    (when (logtest? (continue-flags indax-hang) (-> arg0 flags))
      (set-setting! 'head-offset 'abs (meters 1) 0)
      (set-setting! 'foot-offset 'abs (meters -1) 0)
      (set-setting! 'target-height 'abs (meters 1.5) 0)
      (logior! (-> self target-flags) (target-flags tf26))
      )
    (set! (-> *setting-control* user-default border-mode) #f)
    (apply-settings *setting-control*)
    (reset-target-state #t)
    (target-exit)
    (logior! (-> self focus-status) (focus-status teleporting))
    (ja-channel-set! 0)
    (set! (-> self control mod-surface) *empty-mods-allow-gun*)
    (let ((t9-29 quaternion-copy!)
          (a0-39 (-> self control quat-for-control))
          (a1-25 (new 'stack-no-clear 'quaternion))
          )
      (set! (-> a1-25 x) (* 0.00003051851 (the float (-> arg0 quat x))))
      (set! (-> a1-25 y) (* 0.00003051851 (the float (-> arg0 quat y))))
      (set! (-> a1-25 z) (* 0.00003051851 (the float (-> arg0 quat z))))
      (set! (-> a1-25 w) (* 0.00003051851 (the float (-> arg0 quat w))))
      (t9-29 a0-39 a1-25)
      )
    (move-to-point! (-> self control) (-> arg0 trans))
    (rot->dir-targ! (-> self control))
    (set! (-> self control camera-pos quad) (-> self control trans quad))
    (vector-reset! (-> self control transv))
    (if (not (string= (-> arg0 name) "default"))
        (set! *external-cam-mode* #f)
        )
    (if (not (logtest? (-> arg0 flags) (continue-flags no-blackout)))
        (cam-stop)
        )
    (suspend)
    (let ((a0-47 (lookup-level-info (-> arg0 vis-nick))))
      (set! (-> *load-state* vis-nick) (if a0-47
                                           (-> a0-47 name)
                                           )
            )
      )
    (dotimes (v1-104 10)
      (cond
        ((< v1-104 (-> arg0 want-count))
         (set! (-> *load-state* want v1-104 name) (-> arg0 want v1-104 name))
         (set! (-> *load-state* want v1-104 display?) (-> arg0 want v1-104 display?))
         )
        (else
          (set! (-> *load-state* want v1-104 name) #f)
          (set! (-> *load-state* want v1-104 display?) #f)
          )
        )
      (set! (-> *load-state* want v1-104 force-vis?) #f)
      (set! (-> *load-state* want v1-104 force-inside?) #f)
      )
    (dotimes (v1-107 3)
      (set! (-> *load-state* want-sound v1-107 name) (-> arg0 want-sound v1-107))
      (set! (-> *load-state* want-sound v1-107 mode) (sound-bank-mode unknown))
      )
    (add-borrow-levels *load-state*)
    (when (not (string= (-> arg0 name) "default"))
      (while (begin
               (dotimes (s5-0 (-> arg0 want-count))
                 (when (not (or (not (-> arg0 want s5-0 name))
                                (not (-> arg0 want s5-0 display?))
                                (= (status-of-level-and-borrows *level* (-> arg0 want s5-0 name) #f) 'active)
                                )
                            )
                   (set! v1-126 #t)
                   (goto cfg-53)
                   )
                 )
               (let ((s5-1 *load-state*))
                 (dotimes (s4-0 10)
                   (when (not (or (not (-> s5-1 want s4-0 name))
                                  (not (-> s5-1 want s4-0 display?))
                                  (= (status-of-level-and-borrows *level* (-> s5-1 want s4-0 name) #f) 'active)
                                  )
                              )
                     (set! v1-126 #t)
                     (goto cfg-53)
                     )
                   )
                 )
               (set! v1-126 #f)
               (label cfg-53)
               v1-126
               )
        (suspend)
        )
      )
    (if (logtest? (-> arg0 flags) (continue-flags copy-entity-pos))
        (apply-pos-from-entity arg0)
        )
    (while (!= (-> self ext-geo) (-> self pending-ext-geo))
      (let ((s5-2 (-> self ext-geo-control)))
        (when (not (or (= (-> s5-2 status) 'initialize) (= (-> self ext-geo) (target-geo none))))
          (unload-from-heap *anim-manager* (-> s5-2 heap))
          (unlink-shaders-in-heap *texture-page-dir* (-> s5-2 heap))
          )
        (case (-> self pending-ext-geo)
          (((target-geo jakb) (target-geo jakb-old) (target-geo jakc))
           (set-pending-file s5-2 "jak-external" (the-as int (-> self pending-ext-geo)) (process->handle self) 0.0)
           )
          (else
            (set-pending-file s5-2 (the-as string #f) 0 (process->handle self) 0.0)
            )
          )
        (if (= (-> s5-2 status) 'active)
            (set! (-> self ext-geo) (the-as target-geo (-> s5-2 load-file-part)))
            (set! (-> self ext-geo) (target-geo none))
            )
        (update s5-2)
        )
      (suspend)
      0
      )
    (when (logtest? (continue-flags indax) (-> arg0 flags))
      (while (!= (-> self ext-anim) (-> self pending-ext-anim))
        (suspend)
        )
      )
    (target-continue-init-art)
    (remove-setting! 'music)
    (remove-setting! 'music-volume)
    (let ((s5-3 (-> *level* border?)))
      (set! (-> *level* border?) (-> *level* play?))
      (set-setting! 'allow-continue #t 0.0 0)
      (set-setting! 'border-mode #t 0.0 0)
      (apply-settings *setting-control*)
      (script-eval '(teleport))
      (script-eval (the-as pair (-> arg0 on-goto)))
      (set-setting! 'allow-continue #f 0.0 0)
      (set-setting! 'border-mode #f 0.0 0)
      (apply-settings *setting-control*)
      (set! (-> *level* border?) s5-3)
      )
    (set! (-> *ACTOR-bank* birth-max) 1000)
    (when (not (logtest? (-> arg0 flags) (continue-flags no-blackout)))
      (new 'stack 'transformq)
      (cam-start #t)
      (suspend)
      (when (not (string= (-> arg0 name) "default"))
        (set! (-> *camera-combiner* trans quad) (-> arg0 camera-trans quad))
        (let ((s5-4 (-> *camera-combiner* inv-camera-rot))
              (s4-1 (-> arg0 camera-rot))
              )
          (matrix-identity! s5-4)
          (set! (-> s5-4 rvec x) (* 0.00003051851 (the float (-> s4-1 0))))
          (set! (-> s5-4 rvec y) (* 0.00003051851 (the float (-> s4-1 1))))
          (set! (-> s5-4 rvec z) (* 0.00003051851 (the float (-> s4-1 2))))
          (set! (-> s5-4 uvec x) (* 0.00003051851 (the float (-> s4-1 3))))
          (set! (-> s5-4 uvec y) (* 0.00003051851 (the float (-> s4-1 4))))
          (set! (-> s5-4 uvec z) (* 0.00003051851 (the float (-> s4-1 5))))
          (set! (-> s5-4 fvec x) (* 0.00003051851 (the float (-> s4-1 6))))
          (set! (-> s5-4 fvec y) (* 0.00003051851 (the float (-> s4-1 7))))
          (set! (-> s5-4 fvec z) (* 0.00003051851 (the float (-> s4-1 8))))
          )
        )
      (cam-master-activate-slave #t)
      )
    (send-event self 'level-enter (-> arg0 level))
    (dotimes (v1-242 (-> *level* length))
      (let ((a0-120 (-> *level* level v1-242)))
        (if (= (-> a0-120 status) 'active)
            (set! (-> a0-120 all-visible?) 'loading)
            )
        )
      )
    (let ((s5-5 (level-get *level* (-> arg0 level))))
      (when s5-5
        (while (and (-> *level* vis?) (-> s5-5 vis-info 0) (= (-> s5-5 all-visible?) 'loading))
          (suspend)
          )
        )
      )
    (set! *spawn-actors* #t)
    (set! *teleport* #t)
    (set! (-> *ACTOR-bank* birth-max) 1000)
    (if (not (logtest? (continue-flags no-blackout vehicle-movie) (-> arg0 flags)))
        (set-blackout-frames (seconds 0.1))
        )
    (let* ((a0-128 *game-info*)
           (t9-66 (method-of-object a0-128 set-continue!))
           (a1-70 (the-as basic (-> self control unknown-spool-anim00)))
           )
      (set! a1-70 (cond
                    ((the-as spool-anim a1-70)
                     (empty)
                     a1-70
                     )
                    (else
                      arg0
                      )
                    )
            )
      (t9-66 a0-128 a1-70 #f)
      )
    (arrive-at-continue arg0)
    (let* ((a0-130 *game-info*)
           (t9-68 (method-of-object a0-130 set-continue!))
           (a1-71 (the-as basic (-> self control unknown-spool-anim00)))
           )
      (set! a1-71 (cond
                    ((the-as spool-anim a1-71)
                     (empty)
                     a1-71
                     )
                    (else
                      arg0
                      )
                    )
            )
      (t9-68 a0-130 a1-71 #f)
      )
    (when *auto-continue*
      (let ((gp-1 (next-continue arg0)))
        (when gp-1
          (format 0 "~A ~A ~A~%" (-> gp-1 level) (-> gp-1 name) gp-1)
          (inspect global)
          (process-spawn-function process (lambda ((arg0 continue-point)) (start 'play arg0)) gp-1)
          )
        )
      )
    (when (not (-> *setting-control* user-current render))
      (set-setting! 'bg-a 'abs 1.0 0)
      (apply-settings *setting-control*)
      (while (!= (-> *setting-control* user-current bg-a) 1.0)
        (suspend)
        )
      (set-blackout-frames (seconds 0.1))
      (kill-persister *setting-control* (the-as engine-pers 'title-control-scene) 'render)
      )
    (ja-channel-set! 1)
    (ja :group! jakb-stance-loop-ja)
    (suspend)
    (logior! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (when (-> self mode-cache)
      (set! (-> self event-hook) target-standard-event-handler)
      (send-event
        self
        'change-mode
        (-> self mode-cache)
        (handle->process (-> self mode-param1))
        (-> self mode-param2)
        (-> self mode-param3)
        )
      (set! (-> self mode-cache) #f)
      )
    (go target-stance)
    )
  :post target-no-move-post
  )

;; definition for symbol *smack-mods*, type surface
(define *smack-mods* (new 'static 'surface
                       :name 'jump
                       :tiltv 32768.0
                       :tiltvf 150.0
                       :tiltvv 131072.0
                       :tiltvvf 15.0
                       :transv-max 40960.0
                       :target-speed 40960.0
                       :seek0 0.3
                       :seek90 0.3
                       :seek180 0.3
                       :fric 0.05
                       :nonlin-fric-dist 1.0
                       :slip-factor 1.0
                       :slide-factor 1.0
                       :slope-up-factor 1.0
                       :slope-down-factor 1.0
                       :slope-slip-angle 1.0
                       :impact-fric 1.0
                       :bend-factor 1.0
                       :bend-speed 1.0
                       :alignv 1.0
                       :slope-up-traction 1.0
                       :align-speed 1.0
                       :mult-hook (lambda :behavior target
                         ((arg0 surface) (arg1 surface) (arg2 surface) (arg3 int))
                         (when (= arg3 1)
                           (let ((f30-0 (-> self control unknown-floatiujh1bnb2n3i1))
                                 (f28-0 (-> self control force-turn-to-strength))
                                 )
                             (set! (-> arg0 seek0) (lerp (-> arg0 seek0) 409600.0 f28-0))
                             (set! (-> arg0 seek90) (lerp (-> arg0 seek90) 409600.0 f28-0))
                             (set! (-> arg0 seek180) (lerp (-> arg0 seek180) 409600.0 f28-0))
                             (set! (-> arg0 target-speed) (lerp (-> arg0 target-speed) f30-0 f28-0))
                             (set! (-> arg0 transv-max) (lerp (-> arg0 transv-max) f30-0 f28-0))
                             )
                           )
                         )
                       :mode 'air
                       :flags (surface-flag air gun-inactive gun-no-twist)
                       )
        )

;; definition for symbol *smack-up-mods*, type surface
(define *smack-up-mods* (new 'static 'surface
                          :name 'jump
                          :turnv 131072.0
                          :turnvf 30.0
                          :turnvv 32768.0
                          :turnvvf 30.0
                          :tiltv 32768.0
                          :tiltvf 150.0
                          :tiltvv 131072.0
                          :tiltvvf 15.0
                          :transv-max 40960.0
                          :target-speed 40960.0
                          :seek0 0.3
                          :seek90 0.3
                          :seek180 0.3
                          :fric 0.05
                          :nonlin-fric-dist 1.0
                          :slip-factor 1.0
                          :slide-factor 1.0
                          :slope-up-factor 1.0
                          :slope-down-factor 1.0
                          :slope-slip-angle 1.0
                          :impact-fric 1.0
                          :bend-factor 1.0
                          :bend-speed 1.0
                          :alignv 1.0
                          :slope-up-traction 1.0
                          :align-speed 1.0
                          :mult-hook (lambda :behavior target
                            ((arg0 surface) (arg1 surface) (arg2 surface) (arg3 int))
                            (when (= arg3 1)
                              (let ((f30-0 (-> self control unknown-floatiujh1bnb2n3i1))
                                    (f28-0 (-> self control force-turn-to-strength))
                                    )
                                (set! (-> arg0 seek0) (lerp (-> arg0 seek0) 409600.0 f28-0))
                                (set! (-> arg0 seek90) (lerp (-> arg0 seek90) 409600.0 f28-0))
                                (set! (-> arg0 seek180) (lerp (-> arg0 seek180) 409600.0 f28-0))
                                (set! (-> arg0 target-speed) (lerp (-> arg0 target-speed) f30-0 f28-0))
                                (set! (-> arg0 transv-max) (lerp (-> arg0 transv-max) f30-0 f28-0))
                                )
                              )
                            )
                          :mode 'air
                          :flags (surface-flag no-turn-around turn-to-pad air gun-inactive gun-no-twist)
                          )
        )

;; definition for function velocity-set-to-target!
;; INFO: Used lq/sq
(defbehavior velocity-set-to-target! target ((arg0 vector) (arg1 float) (arg2 attack-info))
  (let* ((v1-1 (-> self control trans))
         (gp-1 (vector-! (new 'stack-no-clear 'vector) arg0 v1-1))
         )
    (set! (-> gp-1 y) 0.0)
    (set! (-> self control force-turn-to-direction quad) (-> gp-1 quad))
    (vector-xz-normalize! (-> self control force-turn-to-direction) 1.0)
    (set! (-> self control force-turn-to-speed) 1.0)
    (set! (-> self control unknown-floatiujh1bnb2n3i1) arg1)
    (set! (-> self control force-turn-to-strength) (- 1.0 (-> arg2 control)))
    gp-1
    )
  )

;; definition for function target-hit-effect
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defbehavior target-hit-effect target ((arg0 attack-info))
  (cond
    ((logtest? (-> *part-group-id-table* 10 flags) (sp-group-flag sp13))
     (set! (-> *launch-matrix* trans quad)
           (-> (the-as vector (if (logtest? (-> arg0 mask) (attack-mask intersection))
                                  (-> arg0 intersection)
                                  (the-as vector (-> self control root-prim prim-core))
                                  )
                       )
               quad
               )
           )
     (part-tracker-spawn part-tracker-subsampler :to self :group (-> *part-group-id-table* 10))
     )
    (else
      (set! (-> *launch-matrix* trans quad)
            (-> (the-as vector (if (logtest? (-> arg0 mask) (attack-mask intersection))
                                   (-> arg0 intersection)
                                   (the-as vector (-> self control root-prim prim-core))
                                   )
                        )
                quad
                )
            )
      (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 10))
      )
    )
  (let ((v1-32 (-> arg0 mode)))
    (cond
      ((or (= v1-32 'endlessfall) (= v1-32 'instant-death) (= v1-32 'crush) (= v1-32 'tentacle))
       )
      ((begin
         (target-timed-invulnerable (-> arg0 invinc-time) self 1)
         (cpad-set-buzz! (-> *cpad-list* cpads 0) 0 255 (seconds 0.5))
         (focus-test? self indax)
         )
       (let* ((v1-38 (rand-vu-int-count 4))
              (t0-0 (cond
                      ((zero? v1-38)
                       "ds176"
                       )
                      ((= v1-38 1)
                       "ds177"
                       )
                      ((= v1-38 2)
                       "ds178"
                       )
                      (else
                        "ds179"
                        )
                      )
                    )
              )
         (set! (-> self control unknown-sound-id00)
               (add-process *gui-control* *target* (gui-channel daxter) (gui-action play) t0-0 -99.0 0)
               )
         )
       (sound-params-set! *gui-control* (-> self control unknown-sound-id00) #t -1 100 2 -1.0)
       )
      (else
        (case (-> arg0 angle)
          (('up)
           (sound-play "hit-up")
           )
          (else
            (sound-play "oof")
            )
          )
        )
      )
    )
  (let ((v1-50 (-> arg0 mode)))
    (cond
      ((or (= v1-50 'burn) (or (= v1-50 'burnup) (= v1-50 'lava) (= v1-50 'melt) (= v1-50 'fry) (= v1-50 'slime)))
       (if (not (handle->process (-> self burn-proc)))
           (set! (-> self burn-proc) (ppointer->handle (process-spawn-function
                                                         process
                                                         process-drawable-burn-effect
                                                         1200
                                                         :to (if (focus-test? self indax)
                                                             (ppointer->process (-> self sidekick))
                                                             self
                                                             )
                                                         )
                                                       )
                 )
           )
       )
      ((= v1-50 'tar)
       (sound-play "get-burned")
       )
      )
    )
  0
  (none)
  )

;; definition for function target-hit-push
;; INFO: Used lq/sq
(defbehavior target-hit-push target ((arg0 vector) (arg1 matrix) (arg2 float) (arg3 float) (arg4 attack-info))
  (case (-> arg4 mode)
    (('shock 'shockup 'shock-red 'shock-green)
     (when (>= (- (-> *display* game-clock frame-counter) (-> self shock-effect-time)) (seconds 0.03))
       (set! (-> self shock-effect-time) (-> *display* game-clock frame-counter))
       (send-event self 'color-effect 'shock (seconds 0.2))
       (case (-> arg4 mode)
         (('shock-red)
          (process-drawable-shock-effect
            self
            (-> *lightning-spec-id-table* 3)
            lightning-probe-callback
            (the-as sparticle-launcher #f)
            0
            0
            40960.0
            )
          )
         (('shock-green)
          (process-drawable-shock-effect
            self
            (-> *lightning-spec-id-table* 4)
            lightning-probe-callback
            (the-as sparticle-launcher #f)
            0
            0
            40960.0
            )
          )
         (else
           (process-drawable-shock-effect
             self
             (-> *lightning-spec-id-table* 1)
             lightning-probe-callback
             (-> *part-id-table* 160)
             0
             0
             40960.0
             )
           )
         )
       )
     )
    )
  (case (-> arg4 angle)
    (('jump 'up 'up-forward)
     (when (and (not (focus-test? self flut pilot mech indax))
                (not (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact health))))
                )
       (if (and (cpad-pressed? (-> self control cpad number) circle) (can-feet? #f))
           (go target-attack-air #f)
           )
       (if (and (cpad-pressed? (-> self control cpad number) square)
                (and (< (vector-dot (-> self control dynam gravity-normal) (-> self control transv)) 26624.0)
                     (< -61440.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                     (and (time-elapsed? (-> self control last-time-of-stuck) (the-as time-frame (-> *TARGET-bank* stuck-timeout)))
                          (not (logtest? (-> self target-flags) (target-flags prevent-attack)))
                          (not (logtest? (-> self control current-surface flags) (surface-flag no-attack no-hands)))
                          (not (and (not (using-gun? self)) (!= (-> self skel top-anim interp) 0.0)))
                          )
                     )
                )
           (go
             target-flop
             65502.96
             -163840.0
             (the-as float (if (= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
                               0
                               #x47866666
                               )
                     )
             'flop
             )
           )
       )
     )
    )
  (when (if (and (< (target-move-dist (-> *TARGET-bank* stuck-time)) (-> *TARGET-bank* stuck-distance))
                 (and (time-elapsed? (-> self state-time) (the-as time-frame (-> *TARGET-bank* stuck-time)))
                      (not (and *cheat-mode* (cpad-hold? (-> self control cpad number) r2)))
                      )
                 )
            #t
            )
    (logior! (-> self control status) (collide-status on-surface))
    (return 'stuck)
    )
  (let ((s1-0 (new-stack-vector0)))
    (set! (-> s1-0 z) arg2)
    (vector-matrix*! s1-0 s1-0 arg1)
    (vector+! s1-0 s1-0 arg0)
    (cond
      ((< (vector-vector-distance arg0 s1-0) (fabs (-> arg4 dist)))
       (velocity-set-to-target! s1-0 (fabs arg3) arg4)
       #t
       )
      (else
        (set! (-> self control unknown-floatiujh1bnb2n3i1) 0.0)
        (set! (-> self control force-turn-to-strength) (- 1.0 (-> arg4 control)))
        #f
        )
      )
    )
  )

;; definition for function target-hit-orient
(defbehavior target-hit-orient target ((arg0 attack-info) (arg1 vector))
  (let ((s5-0 #f))
    (if (and (!= (-> arg0 angle) 'front)
             (!= (-> arg0 angle) 'shove)
             (logtest? (-> arg0 mask) (attack-mask vector))
             (!= (-> arg0 shove-back) 0.0)
             )
        (forward-up-nopitch->quaternion (-> self control dir-targ) arg1 (-> self control dynam gravity-normal))
        )
    (case (-> arg0 angle)
      (('back 'air)
       (set! s5-0 #t)
       )
      (('up-forward)
       (set! (-> self control mod-surface) *smack-up-mods*)
       )
      (('front)
       (if (and (logtest? (-> arg0 mask) (attack-mask vector)) (!= (-> arg0 shove-back) 0.0))
           (forward-up-nopitch->quaternion
             (-> self control dir-targ)
             (vector-negate! (new 'stack-no-clear 'vector) arg1)
             (-> self control dynam gravity-normal)
             )
           )
       (set! s5-0 #t)
       )
      (('jump)
       (set! s5-0 #t)
       (set! (-> self control mod-surface) *forward-high-jump-mods*)
       )
      )
    s5-0
    )
  )

;; definition for function target-hit-setup-anim
;; WARN: Return type mismatch object vs none.
(defbehavior target-hit-setup-anim target ((arg0 attack-info))
  (let ((v1-0 (-> arg0 angle)))
    (cond
      ((= v1-0 'back)
       (let ((v1-3 (ja-group)))
         (when (not (and v1-3 (= v1-3 jakb-hit-from-back-ja)))
           (when (using-gun? self)
             (set! (-> self gun top-anim-low-high) 0.0)
             (push-anim-to-targ
               (-> self skel top-anim)
               (the-as art-joint-anim jakb-gun-hit-from-back-ja)
               0.0
               0
               30
               1.0
               0.0
               #f
               )
             )
           (ja-channel-push! 1 (seconds 0.075))
           (ja :group! jakb-hit-from-back-ja :num! min)
           )
         )
       )
      ((= v1-0 'lava)
       (let ((v1-19 (ja-group)))
         (when (not (and v1-19 (= v1-19 jakb-hit-elec-ja)))
           (ja-channel-push! 1 (seconds 0.075))
           (ja :group! jakb-hit-elec-ja :num! min)
           )
         )
       )
      ((or (= v1-0 'up) (= v1-0 'up-forward) (= v1-0 'lava))
       (let ((v1-28 (ja-group)))
         (when (not (and v1-28 (= v1-28 jakb-hit-up-ja)))
           (ja-channel-push! 1 (seconds 0.075))
           (ja :group! jakb-hit-up-ja :num! min)
           )
         )
       )
      ((or (= v1-0 'air) (= v1-0 'jump))
       (ja-channel-push! 1 (seconds 0.05))
       (ja-no-eval :group! jakb-jump-ja :num! (seek!) :frame-num 0.0)
       (when (= (-> arg0 angle) 'air)
         (sound-play "smack-surface")
         (do-effect (-> self skel effect) "group-smack-surface" 0.0 6)
         (do-effect (-> self skel effect) "group-smack-surface-dizzy" 0.0 9)
         )
       )
      ((= v1-0 'shove)
       (ja-channel-push! 1 (seconds 0.05))
       (ja-no-eval :group! jakb-smack-surface-ja :num! (seek!) :frame-num 0.0)
       (sound-play "smack-surface")
       )
      ((rand-vu-percent? 0.5)
       (let ((v1-77 (ja-group)))
         (when (not (and v1-77 (= v1-77 jakb-hit-from-front-alt1-ja)))
           (when (using-gun? self)
             (set! (-> self gun top-anim-low-high) 0.0)
             (push-anim-to-targ
               (-> self skel top-anim)
               (the-as art-joint-anim jakb-gun-hit-from-front-ja)
               0.0
               0
               30
               1.0
               0.0
               #f
               )
             )
           (ja-channel-push! 1 (seconds 0.075))
           (ja :group! jakb-hit-from-front-alt1-ja :num! min)
           )
         )
       )
      (else
        (let ((v1-93 (ja-group)))
          (when (not (and v1-93 (= v1-93 jakb-hit-from-front-ja)))
            (when (using-gun? self)
              (set! (-> self gun top-anim-low-high) 0.0)
              (push-anim-to-targ
                (-> self skel top-anim)
                (the-as art-joint-anim jakb-gun-hit-from-front-ja)
                0.0
                0
                30
                1.0
                0.0
                #f
                )
              )
            (ja-channel-push! 1 (seconds 0.075))
            (ja :group! jakb-hit-from-front-ja :num! min)
            )
          )
        )
      )
    )
  (none)
  )

;; definition for function target-hit-move
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defbehavior target-hit-move target ((arg0 attack-info) (arg1 symbol) (arg2 (function none :behavior target)) (arg3 float))
  (local-vars (v1-29 symbol) (s1-1 symbol))
  (vector-identity! (-> self control transv))
  (let ((v1-1 (new-stack-vector0)))
    (let ((f0-1 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
      0.0
      (vector-! v1-1 (-> self control transv) (vector-float*! v1-1 (-> self control dynam gravity-normal) f0-1))
      )
    (let* ((f0-2 (vector-length v1-1))
           (f1-1 f0-2)
           (f2-1 (+ 2048.0 (sqrtf (* 491520.0 (-> arg0 shove-up)))))
           )
      (vector+!
        (-> self control transv)
        (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-1)
        (vector-float*! v1-1 v1-1 (/ f0-2 f1-1))
        )
      )
    )
  (let ((s3-0 (new 'stack-no-clear 'vector)))
    (set! (-> s3-0 quad) (-> self control trans quad))
    (let ((s2-1 (matrix-rotate-y! (new 'stack-no-clear 'matrix) (+ 32768.0 (vector-y-angle (-> arg0 vector)))))
          (f30-1 0.0)
          )
      (set-quaternion! (-> self control) (-> self control dir-targ))
      #t
      (let ((f28-1 (* 1.05 (/ (* -60.0 arg3) (* (the float (+ (-> (ja-group) frames num-frames) -1)) (ja-step 0))))))
        (until v1-29
          (+! f30-1 (* (-> arg0 shove-back) f28-1 (seconds-per-frame)))
          (set! s1-1 (target-hit-push s3-0 s2-1 f30-1 (* (-> arg0 shove-back) f28-1) arg0))
          (suspend)
          (ja :num! (seek!))
          (set! v1-29 (or (ja-done? 0) (and arg1 (logtest? (-> self control status) (collide-status on-surface)))))
          )
        (while (and (or (not (logtest? (-> self control status) (collide-status on-surface))) s1-1) (!= s1-1 'stuck))
          (arg2)
          (+! f30-1 (* (-> arg0 shove-back) f28-1 (seconds-per-frame)))
          (set! s1-1 (target-hit-push s3-0 s2-1 f30-1 (* (-> arg0 shove-back) f28-1) arg0))
          (if (not s1-1)
              (logclear! (-> self focus-status) (focus-status hit))
              )
          (suspend)
          )
        )
      )
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate target-hit (target)
  :event target-standard-event-handler
  :exit (behavior ()
    (let ((v1-0 (new-stack-vector0))
          (f0-1 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
          )
      0.0
      (vector-! v1-0 (-> self control transv) (vector-float*! v1-0 (-> self control dynam gravity-normal) f0-1))
      (let* ((f2-0 (vector-length v1-0))
             (f1-2 f2-0)
             )
        (if (< 40960.0 f2-0)
            (set! f2-0 40960.0)
            )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-1)
          (vector-float*! v1-0 v1-0 (/ f2-0 f1-2))
          )
        )
      )
    (when (not (and (-> self next-state) (let ((v1-4 (-> self next-state name)))
                                           (or (= v1-4 'target-death) (= v1-4 'target-hit))
                                           )
                    )
               )
      (logclear! (-> self focus-status) (focus-status dead hit))
      (logclear! (-> self target-flags) (target-flags disable-attacks))
      )
    ((method-of-type focus clear-focused) (the-as focus (-> self gun track-target)))
    (target-exit)
    )
  :trans (behavior ()
    (when (= *cheat-mode* 'debug)
      (when (and (not *pause-lock*) (cpad-hold? (-> self control cpad number) r2))
        (set-time! (-> self control time-of-last-debug-heal))
        (pickup-collectable! (-> self fact) (pickup-type health) 100.0 (the-as handle #f))
        (go target-stance)
        )
      )
    )
  :code (behavior ((arg0 symbol) (arg1 attack-info))
    (local-vars (sv-32 attack-info) (sv-36 vector))
    (logclear! (-> self water flags) (water-flag jump-out))
    (set-time! (-> self state-time))
    (set! (-> self neck flex-blend) 0.0)
    (set! sv-32 (-> self attack-info))
    (set! sv-36 (new 'stack-no-clear 'vector))
    (let ((v1-7 sv-32))
      (set! (-> v1-7 attacker) (the-as handle #f))
      (set! (-> v1-7 mode) 'generic)
      (set! (-> v1-7 shove-back) 6144.0)
      (set! (-> v1-7 shove-up) 4915.2)
      (set! (-> v1-7 angle) #f)
      (set! (-> v1-7 trans quad) (-> self control trans quad))
      (set! (-> v1-7 control) 0.0)
      (set! (-> v1-7 invinc-time) (-> *TARGET-bank* hit-invulnerable-timeout))
      (set! (-> v1-7 damage) (-> *FACT-bank* health-default-inc))
      )
    (case arg0
      (('shove)
       (let ((v1-10 sv-32))
         (set! (-> v1-10 shove-back) (-> *TARGET-bank* smack-surface-dist))
         (set! (-> v1-10 shove-up) (-> *TARGET-bank* smack-surface-height))
         (set! (-> v1-10 angle) 'shove)
         )
       )
      )
    (let ((v1-13 (if (logtest? (-> arg1 mask) (attack-mask mode))
                     (-> arg1 mode)
                     'generic
                     )
                 )
          )
      (when (or (= v1-13 'lava) (or (= v1-13 'melt) (= v1-13 'fry) (= v1-13 'slime)))
        (let ((v1-16 sv-32))
          (set! (-> v1-16 shove-up) 32768.0)
          (set! (-> v1-16 angle) 'lava)
          (set! (-> v1-16 control) 1.0)
          (set! (-> v1-16 damage) 4.0)
          )
        )
      )
    (combine! sv-32 arg1 self)
    (when (not (logtest? (-> sv-32 mask) (attack-mask vector)))
      (vector-z-quaternion! (-> sv-32 vector) (-> self control quat-for-control))
      (vector-xz-normalize! (-> sv-32 vector) (- (fabs (-> sv-32 shove-back))))
      (set! (-> sv-32 vector y) (-> sv-32 shove-up))
      )
    (when (and (focus-test? self dark) (nonzero? (-> self darkjak)))
      (set! (-> sv-32 damage) (fmax 1.0 (ceil (/ (-> sv-32 damage) 2))))
      0
      )
    (set! (-> sv-36 quad) (-> sv-32 vector quad))
    (let ((f0-19 (vector-dot
                   (vector-normalize-copy! (new 'stack-no-clear 'vector) sv-36 1.0)
                   (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control quat-for-control))
                   )
                 )
          )
      (if (not (-> self attack-info angle))
          (set! (-> self attack-info angle) (if (>= 0.0 f0-19)
                                                'front
                                                'back
                                                )
                )
          )
      )
    (cond
      ((= arg0 'attack)
       (send-event (handle->process (-> self notify)) 'notify 'hit (-> sv-32 mode))
       (logior! (-> self focus-status) (focus-status hit))
       (set-time! (-> self game hit-time))
       (case (-> sv-32 mode)
         (('endlessfall)
          (cond
            ((= (-> self game mode) 'debug)
             (let ((gp-1 (new-stack-vector0)))
               (set! (-> gp-1 quad) (-> self control last-trans-on-ground quad))
               (ja-channel-set! 0)
               (suspend-for (seconds 1)
                 )
               (move-to-point! (-> self control) gp-1)
               )
             (set! (-> self control camera-pos quad) (-> self control trans quad))
             (send-event *camera* 'teleport)
             (go target-stance)
             )
            (else
              (pickup-collectable! (-> self fact) (pickup-type health) -1000.0 (the-as handle #f))
              (go target-death (-> sv-32 mode))
              )
            )
          )
         (('fry)
          (pickup-collectable! (-> self fact) (pickup-type health) (- (-> sv-32 damage)) (the-as handle #f))
          (cond
            ((and (= (-> self game mode) 'play) (>= 0.0 (-> self fact health)))
             (go target-death (-> sv-32 mode))
             )
            (else
              (sound-play "death-melt")
              (cond
                ((logtest? (-> *part-group-id-table* 64 flags) (sp-group-flag sp13))
                 (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
                 (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 64))
                 )
                (else
                  (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
                  (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 64))
                  )
                )
              )
            )
          )
         (('lava 'melt 'slime)
          (pickup-collectable! (-> self fact) (pickup-type health) -1000.0 (the-as handle #f))
          (cond
            ((and (= (-> self game mode) 'play) (>= 0.0 (-> self fact health)))
             (go target-death (-> sv-32 mode))
             )
            (else
              (sound-play "death-melt")
              (cond
                ((logtest? (-> *part-group-id-table* 64 flags) (sp-group-flag sp13))
                 (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
                 (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 64))
                 )
                (else
                  (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
                  (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 64))
                  )
                )
              )
            )
          )
         (('drown-death
            'sharkey
            'dark-eco-pool
            'instant-death
            'crush
            'death
            'grenade
            'bot
            'turret
            'centipede
            'big-explosion
            'tentacle
            )
          (pickup-collectable! (-> self fact) (pickup-type health) -1000.0 (the-as handle #f))
          (if (= (-> self game mode) 'play)
              (go target-death (-> sv-32 mode))
              )
          )
         (('explode)
          (pickup-collectable! (-> self fact) (pickup-type health) (- (-> sv-32 damage)) (the-as handle #f))
          (if (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact health)))
              (go target-death (-> sv-32 mode))
              )
          )
         (('smush)
          (case (-> sv-32 angle)
            (('front)
             (forward-up-nopitch->quaternion
               (-> self control dir-targ)
               (vector-negate! (new 'stack-no-clear 'vector) sv-36)
               (-> self control dynam gravity-normal)
               )
             )
            (else
              (forward-up-nopitch->quaternion (-> self control dir-targ) sv-36 (-> self control dynam gravity-normal))
              )
            )
          (pickup-collectable! (-> self fact) (pickup-type health) (- (-> sv-32 damage)) (the-as handle #f))
          (go target-hit-ground-hard (-> *TARGET-bank* fall-far))
          )
         (('shock 'shock-red 'shock-green)
          (pickup-collectable! (-> self fact) (pickup-type health) (- (-> sv-32 damage)) (the-as handle #f))
          (let* ((v1-211 (-> sv-32 mode))
                 (gp-9 (cond
                         ((= v1-211 'shock-red)
                          (-> *part-group-id-table* 69)
                          )
                         ((= v1-211 'shock-green)
                          (-> *part-group-id-table* 68)
                          )
                         (else
                           (-> *part-group-id-table* 67)
                           )
                         )
                       )
                 )
            (if (logtest? (-> gp-9 flags) (sp-group-flag sp13))
                (part-tracker-spawn
                  part-tracker-subsampler
                  :to self
                  :group gp-9
                  :duration (seconds 1)
                  :target self
                  :mat-joint 6
                  )
                (part-tracker-spawn part-tracker :to self :group gp-9 :duration (seconds 1) :target self :mat-joint 6)
                )
            )
          (let ((gp-10 (-> self post-hook)))
            (set! (-> self control mod-surface) *turn-around-mods*)
            (set! (-> self post-hook) target-no-stick-post)
            (if (using-gun? self)
                (push-anim-to-targ (-> self skel top-anim) (the-as art-joint-anim jakb-gun-hit-elec-ja) 0.0 30 0 1.0 0.0 #f)
                )
            (let ((v1-247 (new-stack-vector0)))
              (let ((f0-36 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
                0.0
                (vector-!
                  v1-247
                  (-> self control transv)
                  (vector-float*! v1-247 (-> self control dynam gravity-normal) f0-36)
                  )
                )
              (let* ((f0-37 (vector-length v1-247))
                     (f1-6 f0-37)
                     (f2-0 0.0)
                     )
                (vector+!
                  (-> self control transv)
                  (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-0)
                  (vector-float*! v1-247 v1-247 (/ f0-37 f1-6))
                  )
                )
              )
            (ja-channel-push! 1 (seconds 0.1))
            (ja-no-eval :group! jakb-hit-elec-ja :num! (seek!) :frame-num 0.0)
            (until (ja-done? 0)
              (let ((v1-263 (new-stack-vector0))
                    (f0-44 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                    )
                0.0
                (vector-!
                  v1-263
                  (-> self control transv)
                  (vector-float*! v1-263 (-> self control dynam gravity-normal) f0-44)
                  )
                (let* ((f1-9 (vector-length v1-263))
                       (f2-1 f1-9)
                       (f0-45 (+ f0-44 (* 286720.0 (seconds-per-frame))))
                       )
                  (vector+!
                    (-> self control transv)
                    (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-45)
                    (vector-float*! v1-263 v1-263 (/ f1-9 f2-1))
                    )
                  )
                )
              (when (>= (- (-> *display* game-clock frame-counter) (-> self shock-effect-time)) (seconds 0.03))
                (set! (-> self shock-effect-time) (-> *display* game-clock frame-counter))
                (send-event self 'color-effect 'shock (seconds 0.2))
                (case (-> sv-32 mode)
                  (('shock-red)
                   (process-drawable-shock-effect
                     self
                     (-> *lightning-spec-id-table* 3)
                     lightning-probe-callback
                     (the-as sparticle-launcher #f)
                     0
                     0
                     40960.0
                     )
                   )
                  (('shock-green)
                   (process-drawable-shock-effect
                     self
                     (-> *lightning-spec-id-table* 4)
                     lightning-probe-callback
                     (the-as sparticle-launcher #f)
                     0
                     0
                     40960.0
                     )
                   )
                  (else
                    (process-drawable-shock-effect
                      self
                      (-> *lightning-spec-id-table* 1)
                      lightning-probe-callback
                      (-> *part-id-table* 160)
                      0
                      0
                      40960.0
                      )
                    )
                  )
                )
              (suspend)
              (ja :num! (seek!))
              )
            (set! (-> sv-32 angle) 'back)
            (set! (-> self post-hook) gp-10)
            )
          )
         (else
           (pickup-collectable! (-> self fact) (pickup-type health) (- (-> sv-32 damage)) (the-as handle #f))
           )
         )
       (target-hit-effect sv-32)
       )
      (else
        (case (-> sv-32 mode)
          (('burn 'burnup)
           (sound-play "get-burned")
           )
          )
        )
      )
    (when (and (= (-> self game mode) 'play) (and (>= 0.0 (-> self fact health)) (using-gun? self)))
      (send-event (ppointer->process (-> self gun gun)) 'notice 'die)
      (target-gun-end-mode #f)
      )
    (set! (-> self control mod-surface) *smack-mods*)
    (target-hit-setup-anim sv-32)
    (target-hit-move sv-32 (target-hit-orient sv-32 sv-36) target-falling-anim-trans 1.0)
    (cond
      ((and (= (-> self game mode) 'play) (>= 0.0 (-> self fact health)))
       (go target-death (-> sv-32 mode))
       )
      ((and (and (focus-test? self dark) (nonzero? (-> self darkjak))) (>= 1.0 (-> self fact health)))
       (go target-darkjak-get-off)
       )
      ((and (and (focus-test? self light) (nonzero? (-> self lightjak))) (>= 1.0 (-> self fact health)))
       (go target-lightjak-get-off)
       )
      (else
        (go target-hit-ground #f)
        )
      )
    )
  :post target-post
  )

;; definition for symbol *death-spool-array*, type (array spool-anim)
(define *death-spool-array*
  (new 'static 'boxed-array :type spool-anim
    (new 'static 'spool-anim :name "jak-death-1" :anim-name "jak-death-1" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "daxter-death-06" :anim-name "daxter-death-06" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-2" :anim-name "jak-death-2" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-3" :anim-name "jak-death-3" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "daxter-death-13" :anim-name "daxter-death-13" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-4" :anim-name "jak-death-4" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-5" :anim-name "jak-death-5" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-1" :anim-name "jak-death-1" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "daxter-death-14" :anim-name "daxter-death-14" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-2" :anim-name "jak-death-2" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-3" :anim-name "jak-death-3" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "daxter-death-16" :anim-name "daxter-death-16" :parts 2 :command-list '())
    (new 'static 'spool-anim :name "jak-death-4" :anim-name "jak-death-4" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-5" :anim-name "jak-death-5" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-1" :anim-name "jak-death-1" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "daxter-death-17" :anim-name "daxter-death-17" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-2" :anim-name "jak-death-2" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-3" :anim-name "jak-death-3" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "daxter-death-20" :anim-name "daxter-death-20" :parts 2 :command-list '())
    (new 'static 'spool-anim :name "jak-death-4" :anim-name "jak-death-4" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-5" :anim-name "jak-death-5" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "daxter-death-21" :anim-name "daxter-death-21" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-1" :anim-name "jak-death-1" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-2" :anim-name "jak-death-2" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "daxter-death-24" :anim-name "daxter-death-24" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-3" :anim-name "jak-death-3" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-4" :anim-name "jak-death-4" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "daxter-death-31" :anim-name "daxter-death-31" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-5" :anim-name "jak-death-5" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-1" :anim-name "jak-death-1" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "daxter-death-35" :anim-name "daxter-death-35" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-2" :anim-name "jak-death-2" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-3" :anim-name "jak-death-3" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-4" :anim-name "jak-death-4" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "daxter-death-38" :anim-name "daxter-death-38" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-5" :anim-name "jak-death-5" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-1" :anim-name "jak-death-1" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "daxter-death-57" :anim-name "daxter-death-57" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-2" :anim-name "jak-death-2" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-3" :anim-name "jak-death-3" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "daxter-death-58" :anim-name "daxter-death-58" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-4" :anim-name "jak-death-4" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-5" :anim-name "jak-death-5" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "daxter-death-61" :anim-name "daxter-death-61" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-2" :anim-name "jak-death-2" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-3" :anim-name "jak-death-3" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "daxter-death-07" :anim-name "daxter-death-07" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-5" :anim-name "jak-death-5" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-4" :anim-name "jak-death-4" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "daxter-death-10" :anim-name "daxter-death-10" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-1" :anim-name "jak-death-1" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-3" :anim-name "jak-death-3" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "daxter-death-12" :anim-name "daxter-death-12" :parts 2 :command-list '())
    (new 'static 'spool-anim :name "jak-death-5" :anim-name "jak-death-5" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-2" :anim-name "jak-death-2" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "daxter-death-18" :anim-name "daxter-death-18" :parts 1 :command-list '())
    )
  )

;; definition for function death-movie-remap
(defun death-movie-remap ((arg0 int) (arg1 int))
  (let ((v1-0 (/ arg0 arg1)))
    (mod
      (if (not (logtest? v1-0 1))
          (logxor v1-0 arg0)
          (logand #xfffffff (- (logxor v1-0 arg0)))
          )
      arg1
      )
    )
  )

;; definition of type kill-nearby-enemies-info
(deftype kill-nearby-enemies-info (basic)
  ((dist  float)
   (pos   vector  :inline)
   )
  )

;; definition for method 3 of type kill-nearby-enemies-info
(defmethod inspect ((this kill-nearby-enemies-info))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this (-> this type))
  (format #t "~1Tdist: ~f~%" (-> this dist))
  (format #t "~1Tpos: #<vector @ #x~X>~%" (-> this pos))
  (label cfg-4)
  this
  )

;; definition for symbol *kill-nearby-enemies-info*, type kill-nearby-enemies-info
(define *kill-nearby-enemies-info* (new 'static 'kill-nearby-enemies-info))

;; definition for function kill-nearby-enemies
;; INFO: Used lq/sq
(defun kill-nearby-enemies ((arg0 vector) (arg1 float))
  (let ((v1-0 *kill-nearby-enemies-info*))
    (set! (-> v1-0 dist) arg1)
    (set! (-> v1-0 pos quad) (-> arg0 quad))
    )
  (iterate-process-tree
    *entity-pool*
    (lambda ((arg0 process-drawable))
      (if (and (logtest? (process-mask enemy) (-> arg0 mask))
               (type? arg0 process-drawable)
               (nonzero? (-> arg0 root))
               (>= (-> *kill-nearby-enemies-info* dist)
                   (vector-vector-distance (-> arg0 root trans) (-> *kill-nearby-enemies-info* pos))
                   )
               )
          (process-entity-status! arg0 (entity-perm-status bit-9) #t)
          )
      )
    *null-kernel-context*
    )
  )

;; definition for function target-death-anim-trans
;; WARN: Return type mismatch int vs none.
(defbehavior target-death-anim-trans target ()
  (send-event *camera* 'joystick 0.0 -1.0)
  (compute-alignment! (-> self align))
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    (when (not (logtest? (-> self align flags) (align-flags disabled)))
      (vector-matrix*! gp-0 (the-as vector (-> self align delta)) (-> self control c-R-w))
      (vector-float*! (-> self control transv) gp-0 (-> self clock frames-per-second))
      )
    )
  0
  (none)
  )

;; definition for function target-death-anim
;; WARN: Return type mismatch int vs none.
(defbehavior target-death-anim target ((arg0 spool-anim))
  (set! (-> self control mod-surface) *neutral-mods*)
  (logior! (-> self target-flags) (target-flags lleg-no-ik rleg-no-ik))
  (ja-channel-push! 1 (seconds 0.1))
  (ja-no-eval :group! jakb-deatha-ja :num! (seek! (ja-aframe 30.0 0)) :frame-num 0.0)
  (until (ja-done? 0)
    (if arg0
        (gui-control-method-12
          *gui-control*
          self
          (gui-channel art-load)
          (gui-action queue)
          (-> arg0 name)
          0
          -99.0
          (new 'static 'sound-id)
          )
        )
    (target-death-anim-trans)
    (suspend)
    (ja :num! (seek! (ja-aframe 30.0 0)))
    )
  0
  (none)
  )

;; definition for function target-death-main
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defbehavior target-death-main target ((arg0 symbol))
  (local-vars (sv-96 level) (sv-112 vector))
  (let ((v1-0 arg0))
    (if (= v1-0 'tar)
        (sound-play "death-drown")
        )
    )
  (+! (-> *game-info* death-movie-tick) 1)
  (if (= (death-movie-remap (+ (-> *game-info* death-movie-tick) -1) (-> *death-spool-array* length))
         (death-movie-remap (-> *game-info* death-movie-tick) (-> *death-spool-array* length))
         )
      (+! (-> *game-info* death-movie-tick) 1)
      )
  (let ((gp-2
          (-> *death-spool-array* (death-movie-remap (-> *game-info* death-movie-tick) (-> *death-spool-array* length)))
          )
        )
    (if (= arg0 'bot)
        (set! gp-2 (the-as spool-anim #f))
        )
    (set-setting! 'allow-progress #f 0.0 0)
    (target-death-anim gp-2)
    (cond
      ((or (not gp-2)
           (or (or (logtest? (water-flag touch-water) (-> self water flags))
                   (logtest? (-> self control status) (collide-status on-water))
                   )
               (or (-> *setting-control* user-current spooling)
                   (let ((v1-31 (file-status *art-control* (-> gp-2 name) 0)))
                     (or (not (or (= v1-31 'locked) (= v1-31 'active)))
                         (and (string-prefix= "daxter" (-> gp-2 name))
                              (or (not (art-group-get-by-name *level* "daxter-highres" (the-as (pointer level) #f)))
                                  (not (logtest? (logand (game-feature sidekick) (-> *setting-control* user-current features))
                                                 (-> self game features)
                                                 )
                                       )
                                  (= (-> self control ground-pat material) (pat-material snow))
                                  (= (-> self control ground-pat material) (pat-material deepsnow))
                                  )
                              )
                         )
                     )
                   )
               )
           )
       (ja-no-eval :num! (seek!))
       (while (not (ja-done? 0))
         (target-death-anim-trans)
         (suspend)
         (ja-eval)
         )
       )
      ((string-prefix= "jak" (-> gp-2 name))
       (set! (-> self spool-anim) gp-2)
       (set! (-> self post-hook) (lambda :behavior target () (target-death-anim-trans) (target-no-stick-post)))
       (ja-play-spooled-anim
         gp-2
         (the-as art-joint-anim jakb-stance-loop-ja)
         (the-as art-joint-anim #f)
         (the-as (function process-drawable symbol) false-func)
         (spooler-flags)
         )
       (set-blackout-frames (seconds 0.1))
       (set! (-> self spool-anim) #f)
       )
      (else
        (ja-no-eval :num! (seek!))
        (while (not (ja-done? 0))
          (gui-control-method-12
            *gui-control*
            self
            (gui-channel art-load)
            (gui-action queue)
            (-> gp-2 name)
            0
            -99.0
            (new 'static 'sound-id)
            )
          (target-death-anim-trans)
          (suspend)
          (ja-eval)
          )
        (kill-nearby-enemies (-> *target* control trans) 61440.0)
        (set! (-> *ACTOR-bank* birth-max) 1000)
        (set! (-> self trans-hook) #f)
        (let ((t1-3 #x100000))
          (set-setting! 'features 'clear (shr t1-3 32) t1-3)
          )
        (send-event self 'blend-shape #t)
        (apply-settings *setting-control*)
        (flag-setup)
        (set! sv-96 (the-as level #f))
        (art-group-get-by-name *level* "daxter-highres" (new 'stack-no-clear 'array 'level 1))
        (let ((s4-1 (if (and sv-96 (nonzero? (-> sv-96 entity)) (> (-> sv-96 entity length) 0))
                        (-> sv-96 entity data 0 entity)
                        )
                    )
              )
          (when s4-1
            (let ((s5-2 (ppointer->handle (process-spawn
                                            pov-camera
                                            (-> self control trans)
                                            (art-group-get-by-name *level* "skel-scenecamera" (the-as (pointer level) #f))
                                            gp-2
                                            12
                                            self
                                            '()
                                            :name "pov-camera"
                                            :to *target-pool*
                                            )
                                          )
                        )
                  )
              (when (handle->process s5-2)
                (let* ((s2-1 (get-process *default-dead-pool* manipy #x20000 1))
                       (s3-1
                         (when s2-1
                           (let ((t9-33 (method-of-type manipy activate)))
                             (t9-33 (the-as manipy s2-1) (handle->process s5-2) "sidekick-highres" (the-as pointer #x70004000))
                             )
                           (let ((s3-2 run-function-in-process)
                                 (s1-1 s2-1)
                                 (s0-1 manipy-init)
                                 )
                             (set! sv-112 (-> self control trans))
                             (let ((t0-6 (art-group-get-by-name *level* "skel-sidekick-highres" (the-as (pointer level) #f)))
                                   (t1-5 #f)
                                   (t2-3 0)
                                   )
                               ((the-as (function object object object object object object object none) s3-2)
                                s1-1
                                s0-1
                                sv-112
                                s4-1
                                t0-6
                                t1-5
                                t2-3
                                )
                               )
                             )
                           (-> s2-1 ppointer)
                           )
                         )
                       )
                  (process-spawn-function
                    process
                    (lambda :behavior target ((arg0 handle)) (suspend) (send-event (handle->process arg0) 'light-index 240))
                    (ppointer->handle s3-1)
                    :to self
                    )
                  (send-event (ppointer->process s3-1) 'anim-mode 'clone-anim)
                  (send-event (ppointer->process s3-1) 'blend-shape #t)
                  )
                (send-event (handle->process s5-2) 'music-movie-volume 0.0)
                (send-event (handle->process s5-2) 'sfx-movie-volume 0.5)
                (send-event (handle->process s5-2) 'ambient-movie-volume 0.5)
                (set! (-> self post-hook) target-no-ja-move-post)
                (ja-channel-set! 0)
                (while (handle->process s5-2)
                  (gui-control-method-12
                    *gui-control*
                    self
                    (gui-channel art-load)
                    (gui-action queue)
                    (-> gp-2 name)
                    0
                    -99.0
                    (new 'static 'sound-id)
                    )
                  (suspend)
                  )
                (set-blackout-frames (seconds 0.2))
                (let ((a0-83 (handle->process s5-2)))
                  (if a0-83
                      (deactivate a0-83)
                      )
                  )
                )
              )
            )
          )
        (suspend)
        (remove-setting! 'features)
        )
      )
    )
  0
  (none)
  )

;; definition for function target-death-reset
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defbehavior target-death-reset target ((arg0 symbol) (arg1 symbol))
  (let ((v1-1 (-> *task-manager-engine* alive-list next0)))
    *task-manager-engine*
    (let ((s4-0 (-> v1-1 next0)))
      (while (!= v1-1 (-> *task-manager-engine* alive-list-end))
        (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-1 from) (process->ppointer self))
          (set! (-> a1-1 num-params) 2)
          (set! (-> a1-1 message) 'target)
          (set! (-> a1-1 param 0) (the-as uint 'die))
          (set! (-> a1-1 param 1) (the-as uint arg0))
          (let ((v1-2 (send-event-function (the-as process-tree (-> (the-as connection v1-1) param1)) a1-1)))
            (case v1-2
              (('wait)
               (set! arg1 (the-as symbol v1-2))
               )
              )
            )
          )
        (set! v1-1 s4-0)
        *task-manager-engine*
        (set! s4-0 (-> s4-0 next0))
        )
      )
    )
  (cond
    ((= (the-as object arg1) 'wait)
     (set! (-> self trans-hook) #f)
     (set! (-> self control unknown-word04) (the-as uint #f))
     (when (not (focus-test? self pilot))
       (set! (-> self post-hook) target-no-ja-move-post)
       (ja-post)
       )
     (while (not (-> self control unknown-spool-anim00))
       (send-event *camera* 'joystick 0.0 -1.0)
       (suspend)
       )
     )
    (else
      (suspend)
      0
      )
    )
  (set! (-> self control transv quad) (the-as uint128 0))
  (initialize! (-> self game) 'life (the-as game-save #f) (the-as string #f) (-> self death-resetter))
  (set-time! (-> self state-time))
  (sleep-code)
  0
  (none)
  )

;; failed to figure out what this is:
(defstate target-death (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('end-mode)
       (case (-> block param 0)
         (('bot 'grab)
          (set! (-> self control unknown-word04) (the-as uint #t))
          (if (>= argc 2)
              (mem-copy! (the-as pointer (-> self death-resetter)) (the-as pointer (-> block param 1)) 16)
              )
          )
         )
       )
      (('change-mode)
       (case (-> block param 0)
         (('grab)
          (case (-> block param 1)
            (('dead)
             #t
             )
            (else
              #f
              )
            )
          )
         )
       )
      (('notify)
       (when (type? proc pov-camera)
         (case (-> block param 0)
           (('die 'abort-request)
            (set! (-> self control unknown-word04) (the-as uint #t))
            (set-blackout-frames (seconds 0.2))
            )
           )
         )
       )
      (('get-pickup)
       #f
       )
      (('touched)
       #f
       )
      (else
        (target-generic-event-handler proc argc message block)
        )
      )
    )
  :exit (behavior ()
    (let ((a0-0 (-> self spool-anim)))
      (when (and a0-0 (= (-> *setting-control* user-current spooling) (process->ppointer self)))
        (ja-abort-spooled-anim a0-0 (the-as art-joint-anim #f) -1)
        (ja-channel-set! 1)
        (ja :group! jakb-stance-loop-ja :num! min)
        )
      )
    (logclear! (-> self focus-status) (focus-status dead hit))
    (logclear! (-> self target-flags) (target-flags disable-attacks))
    (target-exit)
    (remove-setting! 'process-mask)
    (remove-setting! 'allow-progress)
    (remove-setting! 'mode-name)
    (let ((v1-20 (-> self control root-prim)))
      (set! (-> v1-20 prim-core collide-as) (-> self control backup-collide-as))
      (set! (-> v1-20 prim-core collide-with) (-> self control backup-collide-with))
      )
    (set! (-> self control pat-ignore-mask)
          (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :board #x1)
          )
    (set! (-> self control dynam gravity-max) (-> self control standard-dynamics gravity-max))
    (set! (-> self control dynam gravity-length) (-> self control standard-dynamics gravity-length))
    (send-event (ppointer->process (-> self gun gun)) 'reset)
    (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
    )
  :trans (-> target-hit trans)
  :code (behavior ((arg0 symbol))
    (set! (-> self control unknown-word04) (the-as uint #f))
    (set! (-> self control did-move-to-pole-or-max-jump-height)
          (the-as float (send-event (handle->process (-> self attack-info attacker)) 'target 'die arg0))
          )
    (set! (-> self neck flex-blend) 0.0)
    (logior! (-> self control pat-ignore-mask) (new 'static 'pat-surface :noendlessfall #x1))
    (target-timed-invulnerable-off self 0)
    (let ((s5-0 (-> self child)))
      (while s5-0
        (send-event (ppointer->process s5-0) 'notice 'die)
        (set! s5-0 (-> s5-0 0 brother))
        )
      )
    (cond
      ((-> *setting-control* user-current death-info)
       (mem-copy!
         (the-as pointer (-> self death-resetter))
         (&-> (-> *setting-control* user-current death-info) node)
         16
         )
       )
      (else
        (set! (-> self death-resetter continue) #f)
        (set! (-> self death-resetter node) (game-task-node none))
        (set! (-> self death-resetter reset-mode) 'life)
        (set! (-> self death-resetter execute) #f)
        )
      )
    (let ((v1-29 arg0))
      (cond
        ((or (= v1-29 'bot) (or (= v1-29 'centipede) (= v1-29 'tentacle)))
         (set-setting! 'process-mask 'set 0.0 (process-mask platform projectile death))
         )
        ((= v1-29 'endlessfall)
         (set-setting! 'process-mask 'set 0.0 (process-mask enemy projectile death guard))
         )
        ((or (= v1-29 'instant-death)
             (= v1-29 'lava)
             (= v1-29 'fry)
             (= v1-29 'slime)
             (= v1-29 'dark-eco-pool)
             (= v1-29 'melt)
             (= v1-29 'explode)
             (= v1-29 'grenade)
             (= v1-29 'big-explosion)
             (= v1-29 'turret)
             )
         (set-setting! 'process-mask 'set 0.0 (process-mask enemy platform projectile death))
         )
        (else
          (let ((v1-38 (-> self water flags)))
            (if (or (and (logtest? (water-flag touch-water) v1-38)
                         (logtest? (water-flag under-water swimming) v1-38)
                         (not (logtest? (focus-status mech) (-> self focus-status)))
                         )
                    (= (-> self control cur-pat material) (pat-material waterbottom))
                    )
                (set! arg0 'drown)
                )
            )
          (set-setting! 'process-mask 'set 0.0 (process-mask enemy platform projectile death guard))
          (if (using-gun? self)
              (target-gun-end-mode #f)
              )
          )
        )
      )
    (apply-settings *setting-control*)
    (set! (-> self control transv quad) (the-as uint128 0))
    (logior! (-> self focus-status) (focus-status dead))
    (logior! (-> self target-flags) (target-flags disable-attacks))
    (let ((v1-61 arg0))
      (cond
        ((or (= v1-61 'none) (= v1-61 'instant-death))
         )
        (else
          (b!
            (not (or (= v1-61 'dark-eco-pool) (= v1-61 'explode) (= v1-61 'grenade) (= v1-61 'big-explosion)))
            cfg-138
            :delay (nop!)
            )
          (let ((s5-1 (handle->process (-> self attack-info attacker))))
            (when (if (type? s5-1 water-vol)
                      s5-1
                      )
              (logior! (-> self target-flags) (target-flags tf14))
              (set! (-> self alt-cam-pos y) (+ 4096.0 (-> self water height)))
              )
            )
          (set! (-> self control mod-surface) *neutral-mods*)
          (case arg0
            (('dark-eco-pool)
             (sound-play "death-darkeco")
             (cond
               ((logtest? (-> *part-group-id-table* 62 flags) (sp-group-flag sp13))
                (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
                (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 62))
                )
               (else
                 (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
                 (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 62))
                 )
               )
             (let ((v1-110 (-> self control root-prim)))
               (set! (-> v1-110 prim-core collide-as) (collide-spec))
               (set! (-> v1-110 prim-core collide-with) (collide-spec))
               )
             0
             (set! (-> self post-hook) target-no-ja-move-post)
             (ja-channel-set! 0)
             (ja-post)
             (suspend-for (seconds 2)
               )
             )
            (('grenade 'big-explosion 'explode)
             (set! (-> self post-hook) target-no-stick-post)
             (set! (-> self control dynam gravity-max) 294912.0)
             (set! (-> self control dynam gravity-length) 294912.0)
             (vector-float*!
               (-> self control dynam gravity)
               (-> self control dynam gravity-normal)
               (the-as float (-> self control dynam gravity-length))
               )
             (case arg0
               (('big-explosion)
                (sound-play "jak-explode")
                )
               (else
                 (sound-play "explosion")
                 )
               )
             (cond
               ((logtest? (-> *part-group-id-table* 65 flags) (sp-group-flag sp13))
                (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
                (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 65))
                )
               (else
                 (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
                 (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 65))
                 )
               )
             (set-vector! (-> self control transv) 0.0 65502.96 0.0 1.0)
             (ja-channel-push! 1 (seconds 0.1))
             (ja-no-eval :group! jakb-hit-from-front-ja :num! (seek!) :frame-num 0.0)
             (until (ja-done? 0)
               (if (and (logtest? (-> self control status) (collide-status on-surface))
                        (>= 409.6 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                        )
                   (goto cfg-122)
                   )
               (suspend)
               (ja :num! (seek!))
               )
             (while (not (or (logtest? (-> self control status) (collide-status on-surface))
                             (time-elapsed? (-> self state-time) (seconds 2))
                             )
                         )
               (suspend)
               )
             (label cfg-122)
             (when (logtest? (-> self control status) (collide-status on-surface))
               (let ((v1-220 (-> self water flags)))
                 (b!
                   (or (and (logtest? (water-flag touch-water) v1-220)
                            (logtest? (water-flag under-water swimming) v1-220)
                            (not (logtest? (focus-status mech) (-> self focus-status)))
                            )
                       (= (-> self control cur-pat material) (pat-material waterbottom))
                       )
                   cfg-168
                   :delay (nop!)
                   )
                 )
               (set! (-> self post-hook) target-no-move-post)
               (let ((v1-232 (-> self control root-prim)))
                 (set! (-> v1-232 prim-core collide-as) (collide-spec))
                 (set! (-> v1-232 prim-core collide-with) (collide-spec))
                 )
               0
               (ja-channel-push! 1 (seconds 0.1))
               (ja-no-eval :group! jakb-death-painful-land-ja :num! (seek!) :frame-num 0.0)
               (until (ja-done? 0)
                 (set! (-> self control transv quad) (the-as uint128 0))
                 (vector-seek!
                   (-> self draw color-mult)
                   (new 'static 'vector :x 0.5 :y 0.5 :z 0.5 :w 1.0)
                   (* 5.0 (seconds-per-frame))
                   )
                 (suspend)
                 (ja :num! (seek!))
                 )
               (suspend-for (seconds 2)
                 )
               )
             )
            )
          (b! #t cfg-206 :delay (nop!))
          (label cfg-138)
          (cond
            ((= v1-61 'turret)
             (let ((v1-269 (-> self control root-prim)))
               (set! (-> v1-269 prim-core collide-as) (collide-spec))
               (set! (-> v1-269 prim-core collide-with) (collide-spec))
               )
             0
             (set! (-> self post-hook) target-no-ja-move-post)
             (ja-channel-set! 0)
             (ja-post)
             (suspend-for (seconds 1.2)
               )
             )
            ((= v1-61 'endlessfall)
             ((lambda :behavior target
                ()
                (local-vars (v1-24 symbol))
                (sound-play "death-fall")
                (set! (-> self control unknown-sound-id00)
                      (add-process *gui-control* *target* (gui-channel daxter) (gui-action play) "jakfall" -99.0 0)
                      )
                (sound-params-set! *gui-control* (-> self control unknown-sound-id00) #t -1 100 2 -1.0)
                (set-setting! 'mode-name 'cam-endlessfall 0.0 0)
                (logclear! (-> self water flags) (water-flag swim-ground))
                (let ((f0-1 (fmin -4096.0 (- (-> self control ground-impact-vel)))))
                  (set! (-> self control unknown-word04) (the-as uint f0-1))
                  (let ((v1-13 (new-stack-vector0)))
                    (let ((f1-3 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
                      0.0
                      (vector-! v1-13 (-> self control transv) (vector-float*! v1-13 (-> self control dynam gravity-normal) f1-3))
                      )
                    (let* ((f1-4 (vector-length v1-13))
                           (f2-1 f1-4)
                           )
                      (vector+!
                        (-> self control transv)
                        (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-1)
                        (vector-float*! v1-13 v1-13 (/ f1-4 f2-1))
                        )
                      )
                    )
                  )
                (when (and (logtest? (-> self control status) (collide-status on-surface)) (!= (-> self control cur-pat event) 2))
                  (set! v1-24 'target-hit-ground-hard)
                  (goto cfg-17)
                  )
                (target-falling-anim 30 (seconds 0.33))
                (ja-channel-push! 1 (seconds 0.3))
                (ja-no-eval :group! jakb-launch-jump-loop-ja :num! (loop! 0.5) :frame-num 0.0)
                (suspend-for (seconds 0.8)
                  (when (and (logtest? (-> self control status) (collide-status on-surface)) (!= (-> self control cur-pat event) 2))
                    (set! v1-24 'target-hit-ground-hard)
                    (goto cfg-17)
                    )
                  (vector-seek! (-> self draw color-mult) *zero-vector* (seconds-per-frame))
                  (let ((v1-49 (new-stack-vector0))
                        (f0-7 (the-as number (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
                        )
                    0.0
                    (vector-!
                      v1-49
                      (-> self control transv)
                      (vector-float*! v1-49 (-> self control dynam gravity-normal) (the-as float f0-7))
                      )
                    (let* ((f1-7 (vector-length v1-49))
                           (f2-2 f1-7)
                           )
                      (if (< (the-as float (-> self control unknown-word04)) (the-as float f0-7))
                          (set! f0-7 (-> self control unknown-word04))
                          )
                      (vector+!
                        (-> self control transv)
                        (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) (the-as float f0-7))
                        (vector-float*! v1-49 v1-49 (/ f1-7 f2-2))
                        )
                      )
                    )
                  (ja :group! jakb-launch-jump-loop-ja :num! (loop! 0.5))
                  )
                (set! v1-24 #f)
                (label cfg-17)
                (when (= v1-24 'target-hit-ground-hard)
                  (set-action!
                    *gui-control*
                    (gui-action fade)
                    (-> self control unknown-sound-id00)
                    (gui-channel none)
                    (gui-action none)
                    (the-as string #f)
                    (the-as (function gui-connection symbol) #f)
                    (the-as process #f)
                    )
                  (set! (-> self control mod-surface) *neutral-mods*)
                  (set! (-> self post-hook) target-no-move-post)
                  (set! (-> self control transv quad) (the-as uint128 0))
                  (ja-channel-push! 1 (seconds 0.05))
                  (ja-no-eval :group! jakb-death-painful-land-ja :num! (seek!) :frame-num 0.0)
                  (until (ja-done? 0)
                    (vector-seek! (-> self draw color-mult) *identity-vector* (seconds-per-frame))
                    (suspend)
                    (ja :num! (seek!))
                    )
                  (suspend-for (seconds 2)
                    )
                  )
                (remove-setting! 'mode-name)
                )
              )
             )
            ((or (= v1-61 'burn) (= v1-61 'burnup))
             (cond
               ((logtest? (-> *part-group-id-table* 66 flags) (sp-group-flag sp13))
                (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
                (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 66))
                )
               (else
                 (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
                 (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 66))
                 )
               )
             (target-death-anim (the-as spool-anim #f))
             )
            ((or (= v1-61 'lava) (= v1-61 'melt) (= v1-61 'fry) (= v1-61 'slime))
             ((lambda :behavior target
                ((arg0 symbol))
                (local-vars (gp-2 vector))
                (sound-play "death-melt")
                (let ((gp-1 (if (= arg0 'slime)
                                (-> *part-group-id-table* 63)
                                (-> *part-group-id-table* 64)
                                )
                            )
                      )
                  (cond
                    ((logtest? (-> gp-1 flags) (sp-group-flag sp13))
                     (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
                     (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group gp-1)
                     )
                    (else
                      (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
                      (part-tracker-spawn part-tracker :to *entity-pool* :group gp-1)
                      )
                    )
                  )
                (let ((f30-0 (-> self control trans y)))
                  (logior! (-> self target-flags) (target-flags tf6))
                  (set! (-> self alt-cam-pos quad) (-> self control camera-pos quad))
                  (logclear! (-> self water flags) (water-flag swim-ground))
                  (let ((v1-38 (new-stack-vector0)))
                    (let ((f0-2 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
                      0.0
                      (vector-! v1-38 (-> self control transv) (vector-float*! v1-38 (-> self control dynam gravity-normal) f0-2))
                      )
                    (let* ((f0-3 (vector-length v1-38))
                           (f1-1 f0-3)
                           (f2-0 0.0)
                           )
                      (vector+!
                        (-> self control transv)
                        (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-0)
                        (vector-float*! v1-38 v1-38 (/ f0-3 f1-1))
                        )
                      )
                    )
                  (logior! (-> self target-flags) (target-flags lleg-no-ik rleg-no-ik))
                  (set! (-> self control mod-surface) *dive-mods*)
                  (set! (-> self control dynam gravity-max) 409.6)
                  (set! (-> self control dynam gravity-length) 409.6)
                  (cond
                    ((and (logtest? (-> self control status) (collide-status on-surface))
                          (and (= (-> self ext-anim) (target-anim default))
                               (begin
                                 (set! gp-2 (new 'stack-no-clear 'vector))
                                 (find-collision-below
                                   gp-2
                                   (vector+! (new 'stack-no-clear 'vector) (-> self control trans) (new 'static 'vector :y -409.6 :w 1.0))
                                   40960.0
                                   )
                                 )
                               (< (+ -8192.0 (-> self control trans y)) (-> gp-2 y))
                               )
                          )
                     (ja-channel-push! 1 (seconds 0.1))
                     (ja-no-eval :group! jakb-death-lava-ja :num! (seek!) :frame-num 0.0)
                     (until (ja-done? 0)
                       (target-death-anim-trans)
                       (if (< (+ -409.6 f30-0) (-> self control trans y))
                           (seek! (-> self control trans y) (+ -409.6 f30-0) (* 81920.0 (seconds-per-frame)))
                           )
                       (suspend)
                       (ja :num! (seek!))
                       )
                     #f
                     )
                    (else
                      (ja-channel-push! 1 (seconds 0.1))
                      (ja-no-eval :group! jakb-death-swim-ja :num! (seek!) :frame-num 0.0)
                      (until (ja-done? 0)
                        (if (< (+ -10240.0 f30-0) (-> self control trans y))
                            (seek! (-> self control trans y) (+ -10240.0 f30-0) (* 81920.0 (seconds-per-frame)))
                            )
                        (suspend)
                        (ja :num! (seek!))
                        )
                      (dotimes (gp-3 1)
                        (ja-no-eval :group! jakb-death-swim-loop-ja :num! (seek! max 0.75) :frame-num 0.0)
                        (until (ja-done? 0)
                          (suspend)
                          (ja :num! (seek! max 0.75))
                          )
                        )
                      (ja-no-eval :group! jakb-death-swim-end-ja :num! (seek! max 0.5) :frame-num 0.0)
                      (until (ja-done? 0)
                        (suspend)
                        (ja :num! (seek! max 0.5))
                        )
                      #f
                      )
                    )
                  )
                )
              arg0
              )
             )
            ((or (= v1-61 'drown) (= v1-61 'drown-death))
             (label cfg-168)
             ((lambda :behavior target
                ()
                (logior! (-> self target-flags) (target-flags tf14))
                (set! (-> self alt-cam-pos y) (+ -8192.0 (-> self water height)))
                (sound-play "death-drown")
                (logclear! (-> self water flags) (water-flag swim-ground))
                (set! (-> self control mod-surface) *dive-mods*)
                (set! (-> self control dynam gravity-max) 6144.0)
                (set! (-> self control dynam gravity-length) 6144.0)
                (ja-channel-push! 1 (seconds 0.1))
                (ja-no-eval :group! jakb-death-swim-ja :num! (seek!) :frame-num 0.0)
                (until (ja-done? 0)
                  (if (< (+ -10240.0 (-> self water height)) (-> self control trans y))
                      (seek! (-> self control trans y) (+ -10240.0 (-> self water height)) (* 81920.0 (seconds-per-frame)))
                      )
                  (suspend)
                  (ja :num! (seek!))
                  )
                (dotimes (gp-1 1)
                  (ja-no-eval :group! jakb-death-swim-loop-ja :num! (seek! max 0.75) :frame-num 0.0)
                  (until (ja-done? 0)
                    (suspend)
                    (ja :num! (seek! max 0.75))
                    )
                  )
                (ja-no-eval :group! jakb-death-swim-end-ja :num! (seek! max 0.5) :frame-num 0.0)
                (until (ja-done? 0)
                  (suspend)
                  (ja :num! (seek! max 0.5))
                  )
                #f
                )
              )
             )
            ((or (= v1-61 'target-hit-ground-hard) (= v1-61 'smush))
             (set! (-> self control mod-surface) *neutral-mods*)
             (ja-channel-push! 1 (seconds 0.1))
             (ja-no-eval :group! jakb-death-painful-land-ja :num! (seek!) :frame-num 0.0)
             (until (ja-done? 0)
               (suspend)
               (ja :num! (seek!))
               )
             (suspend-for (seconds 2)
               )
             )
            ((= v1-61 'centipede)
             (set! (-> self trans-hook) #f)
             (set! (-> self control mod-surface) *neutral-mods*)
             (set! (-> self post-hook) target-no-move-post)
             (ja-channel-push! 1 (seconds 0.075))
             (ja :group! jakb-hit-from-back-ja :num! min)
             (while (not (-> self control unknown-spool-anim00))
               (suspend)
               (ja :num! (loop!))
               )
             )
            ((= v1-61 'tentacle)
             (set! (-> self trans-hook) #f)
             (let ((s5-16 (-> self attack-info attacker)))
               (target-darkjak-end-mode #f)
               (set! (-> self post-hook) target-no-ja-move-post)
               (while (and (handle->process s5-16)
                           (not (-> self control unknown-spool-anim00))
                           (-> self control did-move-to-pole-or-max-jump-height)
                           )
                 (handle->process s5-16)
                 (clone-anim-once s5-16 #t "")
                 (suspend)
                 0
                 )
               )
             )
            ((= v1-61 'bot)
             ((lambda :behavior target
                ()
                (set! (-> self trans-hook) #f)
                (let ((gp-0 0))
                  (while (not (logtest? (-> self control status) (collide-status on-surface)))
                    (target-falling-anim-trans)
                    (+! gp-0 (- (current-time) (-> self clock old-frame-counter)))
                    (if (-> self control unknown-spool-anim00)
                        (return (the-as object #f))
                        )
                    (suspend)
                    )
                  (if (or (> gp-0 0)
                          (let ((v1-14 (ja-group)))
                            (and v1-14 (or (= v1-14 jakb-jump-ja) (= v1-14 jakb-jump-loop-ja) (= v1-14 jakb-duck-high-jump-ja)))
                            )
                          )
                      (target-hit-ground-anim #f (are-still?))
                      )
                  )
                (target-stance-push 1)
                (until #f
                  (ja-no-eval :group! jakb-stance-loop-ja :num! (seek!) :frame-num 0.0)
                  (until (ja-done? 0)
                    (if (-> self control unknown-spool-anim00)
                        (return (the-as object #f))
                        )
                    (suspend)
                    (ja :num! (seek!))
                    )
                  )
                #f
                )
              )
             )
            (else
              (target-death-main arg0)
              )
            )
          )
        )
      )
    (label cfg-206)
    (target-death-reset arg0 #f)
    )
  :post target-no-stick-post
  )
