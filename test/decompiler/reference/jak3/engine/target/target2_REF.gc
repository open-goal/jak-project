;;-*-Lisp-*-
(in-package goal)

;; failed to figure out what this is:
(let ((a0-1 (copy *walk-no-turn-mods* 'global)))
  (set! (-> a0-1 flags) (surface-flag gun-off gun-fast-exit))
  (set! *trip-mods* a0-1)
  )

;; failed to figure out what this is:
(defstate target-load-wait (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('loading)
       (set-time! (-> self state-time))
       #f
       )
      (else
        (target-standard-event-handler proc argc message block)
        )
      )
    )
  :exit target-exit
  :code (behavior ()
    (set! (-> self control mod-surface) *trip-mods*)
    (set-time! (-> self state-time))
    (while (not (time-elapsed? (-> self state-time) (seconds 0.05)))
      (ja-channel-push! 1 (seconds 0.1))
      (ja-no-eval :group! jakb-trip-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (compute-alignment! (-> self align))
        (align! (-> self align) (align-opts adjust-xz-vel) 1.0 1.0 1.0)
        (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
          (let ((v1-22 (process->ppointer self)))
            (set! (-> a1-3 from) v1-22)
            )
          (set! (-> a1-3 num-params) 2)
          (set! (-> a1-3 message) 'joystick)
          (set! (-> a1-3 param 0) (the-as uint 0))
          (set! (-> a1-3 param 1) (the-as uint 0))
          (send-event-function *camera* a1-3)
          )
        (suspend)
        (ja :num! (seek!))
        )
      (suspend-for (seconds 0.3)
        (suspend)
        (ja :num! (seek! (ja-aframe 19.0 0) 0.05))
        )
      (ja-channel-push! 1 (seconds 0.3))
      (ja-no-eval :group! jakb-painful-land-ja :num! (seek!) :frame-num (ja-aframe 40.0 0))
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      (ja-no-eval :group! jakb-painful-land-end-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (go target-stance)
    )
  :post target-no-stick-post
  )

;; failed to figure out what this is:
(defstate target-stance-ambient (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('movie)
       (go target-stance)
       )
      (else
        (target-standard-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self neck flex-blend) 0.0)
    ((-> target-stance enter))
    (let ((v1-2 (rand-vu-int-count 7)))
      (cond
        ((zero? v1-2)
         (set! (-> self spool-anim)
               (new 'static 'spool-anim :name "jak-ambient-1" :anim-name "jak-ambient-1" :parts 1 :command-list '())
               )
         )
        ((= v1-2 1)
         (set! (-> self spool-anim)
               (new 'static 'spool-anim :name "jak-ambient-2" :anim-name "jak-ambient-2" :parts 1 :command-list '())
               )
         )
        ((= v1-2 2)
         (set! (-> self spool-anim)
               (new 'static 'spool-anim :name "jak-ambient-3" :anim-name "jak-ambient-3" :parts 1 :command-list '())
               )
         )
        ((= v1-2 3)
         (set! (-> self spool-anim)
               (new 'static 'spool-anim :name "jak-ambient-4" :anim-name "jak-ambient-4" :parts 1 :command-list '())
               )
         )
        ((= v1-2 4)
         (set! (-> self spool-anim)
               (new 'static 'spool-anim :name "jak-ambient-5" :anim-name "jak-ambient-5" :parts 1 :command-list '())
               )
         )
        ((= v1-2 5)
         (set! (-> self spool-anim)
               (new 'static 'spool-anim :name "jak-ambient-6" :anim-name "jak-ambient-6" :parts 1 :command-list '())
               )
         )
        (else
          (set! (-> self spool-anim)
                (new 'static 'spool-anim :name "jak-ambient-7" :anim-name "jak-ambient-7" :parts 1 :command-list '())
                )
          )
        )
      )
    (set-time! (-> self state-time))
    )
  :exit (behavior ()
    (set-time! (-> self ambient-time))
    (let ((a0-0 (-> self spool-anim)))
      (when (and a0-0 (= (-> *setting-control* user-current spooling) (process->ppointer self)))
        (ja-abort-spooled-anim a0-0 (the-as art-joint-anim #f) -1)
        (ja-channel-set! 1)
        (ja :group! jakb-stance-loop-ja :num! min)
        )
      )
    (set! (-> self spool-anim) #f)
    ((-> target-stance exit))
    (target-exit)
    )
  :trans (behavior ()
    (gui-control-method-12
      *gui-control*
      self
      (gui-channel art-load)
      (gui-action queue)
      (-> self spool-anim name)
      0
      -99.0
      (new 'static 'sound-id)
      )
    (if (or (cpad-hold? (-> self control cpad number) start l1 r1 triangle circle x square)
            *progress-process*
            (want-to-powerjak?)
            )
        (go target-stance)
        )
    )
  :code (behavior ()
    (while (let ((v1-15 (file-status *art-control* (-> self spool-anim name) 0)))
             (not (or (= v1-15 'locked) (= v1-15 'active)))
             )
      (if (!= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
          (go target-stance)
          )
      (suspend)
      (ja :num! (loop!))
      )
    (ja-play-spooled-anim
      (-> self spool-anim)
      (the-as art-joint-anim jakb-stance-loop-ja)
      (the-as art-joint-anim jakb-stance-loop-ja)
      (the-as
        (function process-drawable symbol)
        (lambda :behavior target () (!= (-> *cpad-list* cpads 0 stick0-speed) 0.0))
        )
      (spooler-flags)
      )
    (go target-stance)
    )
  :post target-post
  )

;; failed to figure out what this is:
(defstate target-stance-look-around (target)
  :event target-standard-event-handler
  :enter (-> target-stance enter)
  :exit (-> target-stance exit)
  :trans (-> target-stance trans)
  :code (behavior ()
    (while (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
             (set! (-> a1-0 from) (process->ppointer self))
             (set! (-> a1-0 num-params) 0)
             (set! (-> a1-0 message) 'dist-from-interp-src)
             (and (or (< (the-as float (send-event-function *camera* a1-0)) 4915.2)
                      (not (time-elapsed? (-> self state-time) (seconds 0.05)))
                      )
                  (and (not (time-elapsed? (-> self state-time) (seconds 0.07))) (zero? (ja-group-size)))
                  )
             )
      (suspend)
      )
    (go target-stance)
    )
  :post target-post
  )

;; failed to figure out what this is:
(let ((a0-22 (copy *duck-mods* 'global)))
  (set! (-> a0-22 flags) (surface-flag gun-inactive))
  (set! *look-around-mods* a0-22)
  )

;; failed to figure out what this is:
(defstate target-look-around (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (cond
      ((and (= message 'query) (= (-> block param 0) 'mode))
       (-> self state name)
       )
      (else
        (let ((v1-4 message))
          (cond
            ((= v1-4 'end-mode)
             (case (-> block param 0)
               (('in-head)
                (if (not (focus-test? self dead))
                    (go target-stance-look-around)
                    )
                )
               )
             )
            ((= v1-4 'gun)
             (target-gun-fire (the-as pickup-type (-> block param 0)))
             )
            ((or (= v1-4 'push-trans) (= v1-4 'push-transv))
             (set! (-> self cam-user-mode) 'normal)
             (target-standard-event-handler proc argc message block)
             )
            ((-> self control danger-mode)
             (target-dangerous-event-handler proc argc message block)
             )
            (else
              (target-standard-event-handler proc argc message block)
              )
            )
          )
        )
      )
    )
  :enter (behavior ()
    (set! (-> self cam-user-mode) 'look-around)
    (set! (-> self control mod-surface) *look-around-mods*)
    (logior! (-> self focus-status) (focus-status in-head))
    (set-setting! 'mode-name 'cam-eye 0.0 0)
    )
  :exit (behavior ()
    (set! (-> self cam-user-mode) 'normal)
    (target-exit)
    (remove-setting! 'mode-name)
    )
  :trans (behavior ()
    (when (or (cpad-pressed? (-> self control cpad number) r3)
              (< 2048.0 (target-height-above-ground))
              (not (-> *setting-control* user-current allow-look-around))
              )
      (logclear! (-> *cpad-list* cpads (-> self control cpad number) button0-abs 0) (pad-buttons r3))
      (logclear! (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0) (pad-buttons r3))
      (set! (-> self cam-user-mode) 'normal)
      )
    )
  :code (behavior ()
    (local-vars (a1-0 event-message-block) (f30-0 float))
    (until (>= f30-0 (the-as float (send-event-function *camera* a1-0)))
      (if (!= (-> self cam-user-mode) 'look-around)
          (go target-stance)
          )
      (suspend)
      (set! f30-0 8192.0)
      (set! a1-0 (new 'stack-no-clear 'event-message-block))
      (let ((v1-5 (process->ppointer self)))
        (set! (-> a1-0 from) v1-5)
        )
      (set! (-> a1-0 num-params) 0)
      (set! (-> a1-0 message) 'dist-from-interp-dest)
      )
    (ja-channel-set! 0)
    (set! (-> self control transv quad) (the-as uint128 0))
    (until #f
      (if (!= (-> self cam-user-mode) 'look-around)
          (go target-stance-look-around)
          )
      (can-play-stance-amibent?)
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (target-no-move-post)
    (when (using-gun? self)
      (let ((gp-0 (camera-matrix)))
        (let ((s5-1 (vector-float*! (new-stack-vector0) (-> gp-0 fvec) 8192.0)))
          (vector+float*! s5-1 s5-1 (-> gp-0 uvec) -4096.0)
          (vector+! (-> self gun fire-point) (camera-pos) s5-1)
          )
        (set! (-> self gun fire-dir-out quad) (-> gp-0 fvec quad))
        )
      (set! (-> self gun track?) (gun-track-flags gutflags-1 gutflags-2))
      (target-gun-check)
      )
    )
  )

;; failed to figure out what this is:
(defstate target-grab (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (v0-0 object))
    (cond
      ((and (= message 'query) (= (-> block param 0) 'mode))
       (-> self state name)
       )
      (else
        (case message
          (('end-mode)
           (case (-> block param 0)
             (('grab)
              (go target-stance)
              )
             (('gun)
              (target-gun-end-mode #t)
              )
             (('darkjak)
              (when (and (focus-test? self dark) (nonzero? (-> self darkjak)))
                (target-darkjak-end-mode #t)
                (set! v0-0 'target-darkjak-get-off)
                (set! (-> self control unknown-word04) (the-as uint v0-0))
                v0-0
                )
              )
             (('lightjak)
              (if (and (focus-test? self light) (nonzero? (-> self lightjak)))
                  (target-lightjak-end-mode #t)
                  )
              )
             )
           )
          (('play-anim)
           (go target-grab (the-as symbol (-> block param 0)))
           )
          (('clone-anim)
           (go target-clone-anim (process->handle (the-as process (-> block param 0))))
           )
          (('change-mode)
           (case (-> block param 0)
             (('normal)
              (cond
                ((and (focus-test? self dark) (nonzero? (-> self darkjak)))
                 (target-darkjak-end-mode #t)
                 )
                ((and (focus-test? self light) (nonzero? (-> self lightjak)))
                 (target-lightjak-end-mode #t)
                 )
                ((using-gun? self)
                 (target-gun-end-mode #t)
                 )
                )
              )
             (('gun)
              (cond
                ((using-gun? self)
                 (send-event self 'gun-type (-> block param 2))
                 )
                ((want-to-gun? self #t)
                 (if (logtest? (-> self game features) (game-feature gun))
                     (target-gun-init (the-as pickup-type (-> block param 2)))
                     )
                 )
                )
              )
             (('demo)
              enter-state
              (go target-demo)
              )
             (('title)
              (go target-title #f)
              )
             (('grab)
              (if (and (and (-> self next-state) (= (-> self next-state name) 'target-grab-ride)) (-> block param 1))
                  (go target-grab 'stance)
                  )
              )
             (('grab-ride)
              (if (and (and (-> self next-state) (= (-> self next-state name) 'target-grab)) (-> block param 1))
                  (go target-grab-ride (process->handle proc))
                  )
              )
             )
           )
          (('anim)
           (set! v0-0 (-> block param 0))
           (set! (-> self control unknown-word04) (the-as uint v0-0))
           v0-0
           )
          (else
            (target-generic-event-handler proc argc message block)
            )
          )
        )
      )
    )
  :enter (behavior ((arg0 symbol))
    (set! (-> self board latch?) #f)
    (set! (-> self control mod-surface) *grab-mods*)
    (set! (-> self neck flex-blend) 0.0)
    (logior! (-> self target-flags) (target-flags tf2))
    (logior! (-> self focus-status) (focus-status grabbed))
    (set! (-> self control unknown-word04) (the-as uint arg0))
    (logior! (-> self skel effect flags) (effect-control-flag ecf2))
    (let ((v1-12 (new-stack-vector0))
          (f0-2 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
          )
      0.0
      (vector-! v1-12 (-> self control transv) (vector-float*! v1-12 (-> self control dynam gravity-normal) f0-2))
      (let* ((f1-2 (vector-length v1-12))
             (f2-0 f1-2)
             )
        (if (< 0.0 f0-2)
            (set! f0-2 0.0)
            )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-2)
          (vector-float*! v1-12 v1-12 (/ f1-2 f2-0))
          )
        )
      )
    )
  :exit (behavior ()
    (let ((v1-1 (-> self control root-prim)))
      (set! (-> v1-1 prim-core collide-as) (-> self control backup-collide-as))
      (set! (-> v1-1 prim-core collide-with) (-> self control backup-collide-with))
      )
    (set-time! (-> self ambient-time))
    (logclear! (-> self target-flags) (target-flags tf2))
    (logclear! (-> self skel effect flags) (effect-control-flag ecf2))
    (target-exit)
    )
  :code (behavior ((arg0 symbol))
    (set-forward-vel 0.0)
    (let ((gp-0 0))
      (while (not (logtest? (-> self control status) (collide-status on-surface)))
        (target-falling-anim-trans)
        (+! gp-0 (- (current-time) (-> self clock old-frame-counter)))
        (suspend)
        )
      (if (or (> gp-0 0)
              (let ((v1-10 (ja-group)))
                (and v1-10 (or (= v1-10 jakb-jump-ja) (= v1-10 jakb-jump-loop-ja) (= v1-10 jakb-duck-high-jump-ja)))
                )
              )
          (target-hit-ground-anim #f (are-still?))
          )
      )
    (-> self control unknown-spool-anim00)
    (until #f
      (let ((gp-2 (-> self control unknown-spool-anim00)))
        (case gp-2
          (('stance)
           (cond
             ((logtest? (water-flag swimming) (-> self water flags))
              (ja-channel-push! 1 (seconds 0.15))
              (until #f
                (ja :group! jakb-swim-stance-ja :num! min)
                (until (and (ja-done? 0) (= (-> self skel root-channel 0) (-> self skel channel)))
                  (if (!= gp-2 (-> self control unknown-spool-anim00))
                      (goto cfg-131)
                      )
                  (suspend)
                  (if (= (-> self skel root-channel 0) (-> self skel channel))
                      (ja :num! (seek!))
                      )
                  )
                )
              #f
              )
             ((and (focus-test? self dark) (nonzero? (-> self darkjak)))
              (ja-channel-push! 1 (seconds 0.15))
              (until #f
                (ja-no-eval :group! (-> self draw art-group data 446) :num! (seek!) :frame-num 0.0)
                (until (ja-done? 0)
                  (if (!= gp-2 (-> self control unknown-spool-anim00))
                      (goto cfg-131)
                      )
                  (when (not (and (focus-test? self dark) (nonzero? (-> self darkjak))))
                    (set! (-> self control unknown-word04) (the-as uint 'stance))
                    (goto cfg-131)
                    )
                  (suspend)
                  (ja :num! (seek!))
                  )
                )
              #f
              )
             ((and (focus-test? self light) (nonzero? (-> self lightjak)))
              (ja-channel-push! 1 (seconds 0.15))
              (until #f
                (ja-no-eval :group! jakb-lightjak-stance-ja :num! (seek!) :frame-num 0.0)
                (until (ja-done? 0)
                  (if (!= gp-2 (-> self control unknown-spool-anim00))
                      (goto cfg-131)
                      )
                  (when (not (and (focus-test? self light) (nonzero? (-> self lightjak))))
                    (set! (-> self control unknown-word04) (the-as uint 'stance))
                    (goto cfg-131)
                    )
                  (suspend)
                  (ja :num! (seek!))
                  )
                )
              #f
              )
             ((using-gun? self)
              (let* ((v1-133 (gun->eco (-> self gun gun-type)))
                     (s5-2 (cond
                             ((= v1-133 (pickup-type eco-blue))
                              jakb-gun-stance-blue-ja
                              )
                             ((= v1-133 (pickup-type eco-yellow))
                              jakb-gun-stance-yellow-ja
                              )
                             ((= v1-133 (pickup-type eco-dark))
                              jakb-gun-stance-dark-ja
                              )
                             (else
                               jakb-gun-stance-ja
                               )
                             )
                           )
                     )
                (ja-channel-push! 1 (seconds 0.15))
                (until #f
                  (ja :group! s5-2 :num! min)
                  (until (and (ja-done? 0) (= (-> self skel root-channel 0) (-> self skel channel)))
                    (if (or (!= gp-2 (-> self control unknown-spool-anim00)) (not (using-gun? self)))
                        (goto cfg-131)
                        )
                    (suspend)
                    (if (= (-> self skel root-channel 0) (-> self skel channel))
                        (ja :num! (seek!))
                        )
                    )
                  )
                )
              #f
              )
             (else
               (target-stance-push 1)
               (until #f
                 (ja-no-eval :group! jakb-stance-loop-ja :num! (seek!) :frame-num 0.0)
                 (until (ja-done? 0)
                   (if (or (!= gp-2 (-> self control unknown-spool-anim00)) (using-gun? self))
                       (goto cfg-131)
                       )
                   (suspend)
                   (ja :num! (seek!))
                   )
                 )
               #f
               )
             )
           )
          (('shock-in)
           (ja-channel-push! 1 (seconds 0.2))
           (ja-no-eval :group! jakb-shocked-ja :num! (seek! (ja-aframe 15.0 0)) :frame-num 0.0)
           (until (ja-done? 0)
             (if (!= gp-2 (-> self control unknown-spool-anim00))
                 (goto cfg-131)
                 )
             (suspend)
             (ja :num! (seek! (ja-aframe 15.0 0)))
             )
           (until #f
             (ja-no-eval :group! jakb-shocked-ja :num! (seek! (ja-aframe 26.0 0)) :frame-num (ja-aframe 16.0 0))
             (until (ja-done? 0)
               (if (!= gp-2 (-> self control unknown-spool-anim00))
                   (goto cfg-131)
                   )
               (suspend)
               (ja :num! (seek! (ja-aframe 26.0 0)))
               )
             )
           #f
           )
          (('shock-out)
           (ja-channel-push! 1 (seconds 0.2))
           (ja-no-eval :group! jakb-shocked-ja :num! (seek!) :frame-num (ja-aframe 17.0 0))
           (until (ja-done? 0)
             (if (!= gp-2 (-> self control unknown-spool-anim00))
                 (goto cfg-131)
                 )
             (suspend)
             (ja :num! (seek!))
             )
           (set! (-> self control unknown-word04) (the-as uint 'stance))
           )
          (('target-darkjak-get-off)
           (ja-channel-push! 1 (seconds 0.05))
           (ja-no-eval :group! jakb-darkjak-get-off-ja :num! (seek!) :frame-num 0.0)
           (until (ja-done? 0)
             (set! (-> self darkjak-interp) (lerp-scale 1.0 0.0 (ja-aframe-num 0) 10.0 60.0))
             (suspend)
             (ja :num! (seek!))
             )
           (ja-no-eval :group! jakb-darkjak-get-off-end-ja :num! (seek!) :frame-num 0.0)
           (until (ja-done? 0)
             (set! (-> self darkjak-interp) (lerp-scale 1.0 0.0 (ja-aframe-num 0) 10.0 60.0))
             (suspend)
             (ja :num! (seek!))
             )
           (set! (-> self control unknown-word04) (the-as uint 'stance))
           )
          )
        )
      (label cfg-131)
      )
    #f
    )
  :post (behavior ()
    (if (logtest? (-> self control status) (collide-status on-surface))
        (set! (-> self control transv quad) (the-as uint128 0))
        )
    (set! (-> self game kiosk-timeout) (-> *display* game-clock frame-counter))
    (target-no-stick-post)
    )
  )

;; failed to figure out what this is:
(defstate target-grab-ride (target)
  :event (-> target-grab event)
  :enter (behavior ((arg0 handle))
    ((-> target-grab enter) 'stance)
    )
  :exit (behavior ()
    ((-> target-grab exit))
    (let ((v1-2 (-> self control root-prim)))
      (set! (-> v1-2 prim-core collide-as) (-> self control backup-collide-as))
      (set! (-> v1-2 prim-core collide-with) (-> self control backup-collide-with))
      )
    )
  :code (behavior ((arg0 handle))
    (let ((v1-1 (-> self control root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    (ja-channel-set! 0)
    (until #f
      (let* ((s5-0 (handle->process arg0))
             (a0-6 (if (type? s5-0 process-focusable)
                       s5-0
                       )
                   )
             )
        (if a0-6
            (move-to-point! (-> self control) (get-trans (the-as process-focusable a0-6) 0))
            )
        )
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (set! (-> self game kiosk-timeout) (-> *display* game-clock frame-counter))
    (target-no-move-post)
    )
  )

;; failed to figure out what this is:
(defstate target-pole-cycle (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (if (and (= message 'query) (= (-> block param 0) 'mode))
        (-> self state name)
        (target-standard-event-handler proc argc message block)
        )
    )
  :enter (behavior ((arg0 handle))
    (set! (-> self control anim-handle) arg0)
    (set-time! (-> self state-time))
    (set! (-> self control mod-surface) *pole-mods*)
    (logior! (-> self focus-status) (focus-status pole))
    (target-collide-set! 'pole 0.0)
    (set! (-> self control unknown-vector37 quad) (-> self control transv quad))
    (set! (-> self control transv quad) (the-as uint128 0))
    (send-event *camera* 'ease-in)
    (set! (-> self control did-move-to-pole-or-max-jump-height) (the-as float #f))
    (set! (-> self control hand-to-edge-dist) 0.5)
    )
  :exit (behavior ()
    (target-collide-set! 'normal 0.0)
    (logclear! (-> self focus-status) (focus-status pole))
    (set! (-> self control anim-handle) (the-as handle #f))
    )
  :trans (behavior ()
    (when (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                         (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                         )
                                 (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                                 )
                         (pad-buttons x)
                         )
               (not (logtest? (-> self target-flags) (target-flags prevent-jump)))
               (time-elapsed? (-> self state-time) (seconds 0.4))
               )
      (set! (-> self control transv quad) (the-as uint128 0))
      (cond
        ((< 44.0 (ja-aframe-num 0))
         (set-forward-vel -49152.0)
         (let ((v1-19 (new-stack-vector0)))
           (let ((f0-2 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
             0.0
             (vector-! v1-19 (-> self control transv) (vector-float*! v1-19 (-> self control dynam gravity-normal) f0-2))
             )
           (let* ((f0-3 (vector-length v1-19))
                  (f1-1 f0-3)
                  (f2-0 -81920.0)
                  )
             (vector+!
               (-> self control transv)
               (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-0)
               (vector-float*! v1-19 v1-19 (/ f0-3 f1-1))
               )
             )
           )
         (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
         (go target-falling 'target-pole-cycle)
         )
        ((>= (ja-aframe-num 0) 14.0)
         (remove-exit)
         (go target-pole-flip-up 28672.0 28672.0 (* 1024.0 (- 26.0 (ja-aframe-num 0))))
         )
        (else
          (remove-exit)
          (go target-pole-flip-forward 14336.0 14336.0 57344.0)
          )
        )
      )
    )
  :code (behavior ((arg0 handle))
    (sound-play "edge-grab")
    (target-compute-pole)
    (set! (-> self control unknown-word04)
          (the-as
            uint
            (vector-dot (-> self control edge-grab-edge-dir) (vector-normalize! (-> self control unknown-vector37) 1.0))
            )
          )
    (let ((v1-8 (ja-group)))
      (cond
        ((and v1-8 (= v1-8 jakb-pole-jump-loop-ja))
         (while (not (-> self control did-move-to-pole-or-max-jump-height))
           (ja :num! (seek!))
           (suspend)
           )
         (ja :num-func num-func-identity :frame-num (ja-aframe 37.0 0))
         )
        (else
          (while (not (-> self control did-move-to-pole-or-max-jump-height))
            (suspend)
            )
          (suspend)
          (ja-channel-push! 1 (seconds 0.15))
          )
        )
      )
    (ja-no-eval :group! jakb-pole-cycle-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (until #f
      (set! (-> self anim-seed) (the-as uint (if (rand-vu-percent? 0.1)
                                                 0
                                                 1
                                                 )
                                        )
            )
      (ja-no-eval :group! jakb-pole-cycle-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (can-play-stance-amibent?)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post target-no-move-post
  )

;; failed to figure out what this is:
(defstate target-pole-flip-up (target)
  :event target-standard-event-handler
  :exit (-> target-pole-cycle exit)
  :code (behavior ((arg0 float) (arg1 float) (arg2 float))
    (local-vars (a2-2 (function joint-control-channel float float float float :behavior process)))
    (let ((f0-2 (+ 1.0 (fmin 17.0 (ja-aframe-num 0)))))
      (ja-no-eval :group! jakb-pole-flip-up-ja :num! (seek!) :frame-num (ja-aframe f0-2 0))
      )
    (until (ja-done? 0)
      (suspend)
      (let ((a0-4 (-> self skel root-channel 0)))
        (set! (-> a0-4 param 0) (the float (+ (-> a0-4 frame-group frames num-frames) -1)))
        (set! (-> a0-4 param 1) 1.0)
        (let ((t9-3 joint-control-channel-group-eval!)
              (a1-3 #f)
              )
          (set! a2-2 num-func-seek!)
          (t9-3 a0-4 (the-as art-joint-anim a1-3) a2-2)
          )
        )
      )
    (set-forward-vel arg2)
    (go target-pole-flip-up-jump arg0 arg1 (the-as symbol a2-2))
    )
  :post target-no-move-post
  )

;; failed to figure out what this is:
(defstate target-pole-flip-up-jump (target)
  :event target-standard-event-handler
  :enter (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    ((-> target-jump-forward enter) arg0 arg1 arg2)
    (set! (-> self control mod-surface) *forward-pole-jump-mods*)
    )
  :exit target-exit
  :trans (behavior ()
    ((-> target-jump-forward trans))
    (vector-flatten! (-> self control transv) (-> self control transv) (-> self control edge-grab-edge-dir))
    )
  :code (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    (send-event *camera* 'damp-up)
    (ja :group! jakb-pole-jump-loop-ja :num! min)
    (let ((f0-1 (target-height-above-ground))
          (f1-1 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
          )
      (while (not (and (< (fabs (/ f0-1 (/ f1-1 300))) 40.0) (and (< f1-1 0.0) (ja-min? 0))))
        (suspend)
        (ja :num! (loop!))
        (set! f0-1 (target-height-above-ground))
        (set! f1-1 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
        )
      )
    (ja-channel-push! 1 (seconds 0.25))
    (ja-no-eval :group! jakb-jump-loop-ja :num! (loop!) :frame-num 0.0)
    (until #f
      (suspend)
      (ja :group! jakb-jump-loop-ja :num! (loop!))
      )
    #f
    )
  :post target-post
  )

;; failed to figure out what this is:
(defstate target-pole-flip-forward (target)
  :event target-standard-event-handler
  :exit (-> target-pole-cycle exit)
  :code (behavior ((arg0 float) (arg1 float) (arg2 float))
    (let ((f30-1 (+ 4.0 (ja-aframe-num 0))))
      (ja-no-eval :group! jakb-pole-flip-forward-ja :num! (seek! (ja-aframe 16.0 0)) :frame-num (ja-aframe f30-1 0))
      )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! (ja-aframe 16.0 0)))
      )
    (set-forward-vel arg2)
    (go target-pole-flip-forward-jump arg0 arg1)
    )
  :post target-no-move-post
  )

;; failed to figure out what this is:
(defstate target-pole-flip-forward-jump (target)
  :event target-standard-event-handler
  :enter (behavior ((arg0 float) (arg1 float))
    ((-> target-jump enter) arg0 arg1 (the-as surface #f))
    (set! (-> self control mod-surface) *forward-pole-jump-mods*)
    )
  :exit target-exit
  :trans (behavior ()
    ((-> target-jump-forward trans))
    (vector-flatten! (-> self control transv) (-> self control transv) (-> self control edge-grab-edge-dir))
    )
  :code (behavior ((arg0 float) (arg1 float))
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    ((the-as (function none) (-> target-pole-flip-up-jump code)))
    )
  :post target-post
  )

;; failed to figure out what this is:
(defstate target-edge-grab (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('end-mode)
       (case (-> block param 0)
         (('edge-grab)
          (go target-falling 'target-edge-grab)
          )
         )
       )
      (else
        (target-standard-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> *edge-grab-info* pilot-edge-grab?) #f)
    (set! (-> self control unknown-handle000) (the-as handle #f))
    (set! (-> self control mod-surface) *edge-grab-mods*)
    (set-time! (-> self control edge-grab-start-time))
    (logior! (-> self control root-prim prim-core action) (collide-action dont-push-away))
    (logior! (-> self focus-status) (focus-status edge-grab))
    (set! (-> self control unknown-vector37 quad) (-> self control transv quad))
    (set! (-> self control transv quad) (the-as uint128 0))
    (send-event *camera* 'ease-in)
    (if (!= (-> self skel top-anim interp) 0.0)
        (set! (-> self skel top-anim interp) 0.000000000000000000000000000000001)
        )
    )
  :exit (behavior ()
    (let ((v1-2 (handle->process (-> self control unknown-handle000))))
      (when v1-2
        (if (not (-> self control unknown-symbol000))
            (logclear! (-> (the-as process-focusable v1-2) root root-prim prim-core action) (collide-action edge-grabbed))
            )
        )
      )
    (set! (-> self control unknown-handle000) (the-as handle #f))
    (when (focus-test? self edge-grab)
      (logclear! (-> self focus-status) (focus-status edge-grab))
      (logclear! (-> self control root-prim prim-core action) (collide-action dont-push-away))
      (send-event *camera* 'damp-up)
      )
    (if (!= (-> self skel top-anim interp) 0.0)
        (set! (-> self skel top-anim interp) 1.0)
        )
    (set! (-> self control draw-offset y) 0.0)
    )
  :trans (behavior ()
    (when (and (time-elapsed? (-> self state-time) (seconds 0.2))
               (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                         (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                         )
                                 (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                                 )
                         (pad-buttons x)
                         )
               (not (logtest? (-> self target-flags) (target-flags prevent-jump)))
               )
      (cond
        ((or (< -0.2 (local-pad-angle)) (= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0))
         (let ((a1-2 (new 'stack-no-clear 'collide-query)))
           (let ((v1-25 a1-2))
             (set! (-> v1-25 best-dist) (the-as float (-> *collide-edge-work* world-player-leap-up-spheres)))
             (set! (-> v1-25 best-other-prim) (the-as collide-shape-prim 6))
             (set! (-> v1-25 collide-with) (-> self control root-prim prim-core collide-with))
             (set! (-> v1-25 ignore-process0) #f)
             (set! (-> v1-25 ignore-process1) #f)
             (set! (-> v1-25 ignore-pat)
                   (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                   )
             (set! (-> v1-25 best-my-prim) (the-as collide-shape-prim #t))
             (set! (-> v1-25 action-mask) (collide-action solid))
             )
           (when (not (fill-and-probe-using-spheres *collide-cache* a1-2))
             (if (!= (-> self skel top-anim interp) 0.0)
                 (set! (-> self skel top-anim interp) 1.0)
                 )
             (remove-exit)
             (go
               target-edge-grab-jump
               (-> *TARGET-bank* edge-grab-jump-height-min)
               (-> *TARGET-bank* edge-grab-jump-height-max)
               #f
               )
             )
           )
         )
        (else
          (when (!= (-> self skel top-anim interp) 0.0)
            (set! (-> self skel top-anim interp) 1.0)
            (let* ((v1-47 (-> self skel float-channels))
                   (v1-52 (cond
                            ((= v1-47 1)
                             (-> self skel channel (-> self skel active-channels))
                             )
                            ((= v1-47 2)
                             (-> self skel channel (+ (-> self skel active-channels) 1))
                             )
                            (else
                              (the-as joint-control-channel #f)
                              )
                            )
                          )
                   )
              (if v1-52
                  (set! (-> v1-52 frame-interp 1) 1.0)
                  )
              )
            )
          (remove-exit)
          (go target-edge-grab-off)
          )
        )
      )
    (if (using-gun? self)
        (seek! (-> self control draw-offset y) 778.24 (* 4096.0 (seconds-per-frame)))
        )
    )
  :code (behavior ()
    (target-compute-edge)
    (let ((gp-0 *edge-grab-info*))
      (set! (-> self control unknown-handle000) (-> gp-0 actor-handle))
      (set! (-> self control unknown-symbol000) #f)
      (let ((v1-4 (handle->process (-> self control unknown-handle000))))
        (if v1-4
            (logior! (-> (the-as process-focusable v1-4) root root-prim prim-core action) (collide-action edge-grabbed))
            )
        )
      (set! (-> self control unknown-word04)
            (the-as
              uint
              (vector-dot (-> self control edge-grab-edge-dir) (vector-normalize! (-> self control unknown-vector37) 1.0))
              )
            )
      (cond
        ((= (-> gp-0 pilot-edge-grab?) 'target-double-jump)
         (ja-channel-push! 1 (seconds 0.05))
         (ja-no-eval :group! jakb-jump-ja :num! (seek! (ja-aframe 14.0 0) 0.75) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek! (ja-aframe 14.0 0) 0.75))
           )
         (sound-play "jump-double")
         (ja-channel-push! 1 (seconds 0.05))
         (ja-no-eval :group! jakb-jump-ja :num! (seek! (ja-aframe 14.0 0)) :frame-num (ja-aframe 5.0 0))
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek! (ja-aframe 14.0 0)))
           )
         )
        ((-> gp-0 pilot-edge-grab?)
         (ja-channel-push! 1 (seconds 0.05))
         (ja-no-eval :group! jakb-jump-ja :num! (seek! (ja-aframe 14.0 0)) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek! (ja-aframe 14.0 0)))
           )
         )
        (else
          (while (< 0.0 (-> self control hand-to-edge-dist))
            (let ((v1-60 (ja-group)))
              (when (not (and v1-60 (= v1-60 jakb-jump-loop-ja)))
                (ja-channel-push! 1 (the-as time-frame (if (using-gun? self)
                                                           15
                                                           45
                                                           )
                                            )
                                  )
                (ja :group! jakb-jump-loop-ja :num! min)
                )
              )
            (suspend)
            )
          )
        )
      )
    (target-edge-grab-anim (the-as float (-> self control unknown-word04)))
    )
  :post target-no-move-post
  )

;; failed to figure out what this is:
(defstate target-edge-grab-jump (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('end-mode)
       (case (-> block param 0)
         (('edge-grab)
          (go target-falling 'target-edge-grab)
          )
         )
       )
      (('ladder)
       #f
       )
      (else
        (target-standard-event-handler proc argc message block)
        )
      )
    )
  :exit (-> target-edge-grab exit)
  :code (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    (local-vars (a2-4 (function joint-control-channel float float float float :behavior process)))
    (case arg2
      (('ladder)
       (ja-channel-push! 1 (seconds 0.1))
       )
      (else
        (when (-> *edge-grab-info* pilot-edge-grab?)
          (set! arg0 (+ 8192.0 arg0))
          (set! arg1 (+ 8192.0 arg1))
          )
        (ja-channel-set! 1)
        )
      )
    (set-quaternion! (-> self control) (-> self control dir-targ))
    (logclear! (-> self focus-status) (focus-status edge-grab))
    (logclear! (-> self control root-prim prim-core action) (collide-action dont-push-away))
    (set! (-> self control transv quad) (the-as uint128 0))
    (let ((s3-0 (new 'stack-no-clear 'vector)))
      (let ((a1-4 (cond
                    ((using-gun? self)
                     (push-anim-to-targ
                       (-> self skel top-anim)
                       (the-as art-joint-anim jakb-gun-edge-grab-to-jump-ja)
                       0.0
                       0
                       30
                       1.0
                       0.0
                       #f
                       )
                     jakb-gun-edge-grab-to-jump-ja
                     )
                    (else
                      jakb-edge-grab-to-jump-ja
                      )
                    )
                  )
            )
        (ja-no-eval :group! a1-4 :num! (seek!) :frame-num 0.0)
        )
      (until (ja-done? 0)
        (set! (-> self control transv quad) (the-as uint128 0))
        (case arg2
          (('ladder)
           )
          (else
            (target-compute-edge-rider)
            )
          )
        (compute-alignment! (-> self align))
        (when (not (logtest? (-> self align flags) (align-flags disabled)))
          (vector-matrix*! s3-0 (the-as vector (-> self align delta)) (-> self control c-R-w))
          (move-by-vector! (-> self control) s3-0)
          )
        (suspend)
        (let ((a0-18 (-> self skel root-channel 0)))
          (set! (-> a0-18 param 0) (the float (+ (-> a0-18 frame-group frames num-frames) -1)))
          (set! (-> a0-18 param 1) 1.0)
          (let ((t9-10 joint-control-channel-group-eval!)
                (a1-7 #f)
                )
            (set! a2-4 num-func-seek!)
            (t9-10 a0-18 (the-as art-joint-anim a1-7) a2-4)
            )
          )
        )
      )
    (set! (-> self control transv quad) (the-as uint128 0))
    (set! (-> self control time-of-last-clear-wall-in-jump) 0)
    (set-forward-vel 16384.0)
    (set! (-> self gun surpress-time) (+ (current-time) (seconds 0.2)))
    (send-event *camera* 'damp-up)
    (go target-jump-forward arg0 arg1 (the-as symbol a2-4))
    )
  :post target-no-move-post
  )

;; failed to figure out what this is:
(defstate target-edge-grab-off (target)
  :event target-standard-event-handler
  :exit (-> target-edge-grab exit)
  :code (behavior ()
    (ja-channel-set! 1)
    (set-quaternion! (-> self control) (-> self control dir-targ))
    (send-event *camera* 'damp-up)
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (if (using-gun? self)
          (push-anim-to-targ
            (-> self skel top-anim)
            (the-as art-joint-anim jakb-gun-edge-grab-off-ja)
            0.0
            0
            30
            1.0
            0.0
            #f
            )
          )
      (ja-no-eval :group! jakb-edge-grab-off-ja :num! (seek! (ja-aframe 191.0 0)) :frame-num 0.0)
      (until (ja-done? 0)
        (compute-alignment! (-> self align))
        (when (not (logtest? (-> self align flags) (align-flags disabled)))
          (vector-matrix*! gp-0 (the-as vector (-> self align delta)) (-> self control c-R-w))
          (move-by-vector! (-> self control) gp-0)
          )
        (suspend)
        (ja :num! (seek! (ja-aframe 191.0 0)))
        )
      )
    (set! (-> self control transv quad) (the-as uint128 0))
    (logclear! (-> self focus-status) (focus-status edge-grab))
    (logclear! (-> self control root-prim prim-core action) (collide-action dont-push-away))
    (set! (-> self gun surpress-time) (+ (current-time) (seconds 0.2)))
    (vector-float*! (-> self control transv) (-> self control edge-grab-across-edge-dir) -40960.0)
    (if (not (time-elapsed? (-> self control rider-time) (seconds 0.2)))
        (send-event self 'push-transv (-> self control rider-last-move) (seconds 100))
        )
    (go target-falling 'target-edge-grab)
    )
  :post target-no-move-post
  )

;; failed to figure out what this is:
(defstate target-eco-powerup (target)
  :event target-standard-event-handler
  :exit (behavior ()
    (logclear! (-> self target-effect) (target-effect te2 te5 te6))
    (target-exit)
    )
  :trans (behavior ()
    (slide-down-test)
    )
  :code (behavior ((arg0 int) (arg1 float))
    (case arg0
      ((8)
       (logior! (-> self target-effect) (target-effect te2 te5))
       )
      ((7)
       (logior! (-> self target-effect) (target-effect te6))
       )
      )
    (set! (-> self neck flex-blend) 0.0)
    (set-time! (-> self state-time))
    (if (= arg1 (-> *FACT-bank* eco-full-inc))
        (set! (-> self control mod-surface) *double-jump-mods*)
        (set! (-> self control mod-surface) *walk-mods*)
        )
    (let ((gp-0 (lambda :behavior target
                  ()
                  (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                                     (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                                     )
                                             (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                                             )
                                     (pad-buttons x)
                                     )
                           (not (logtest? (water-flag touch-water) (-> self water flags)))
                           (not (logtest? (-> self target-flags) (target-flags prevent-jump)))
                           )
                      (target-jump-go)
                      )
                  (if (and (cpad-pressed? (-> self control cpad number) circle) (can-feet? #t))
                      (go target-attack-air #f)
                      )
                  (if (and (cpad-pressed? (-> self control cpad number) square) (can-hands? #f))
                      (go target-running-attack)
                      )
                  )
                )
          )
      (case arg0
        ((7)
         (let ((s5-1 0))
           (while (not (logtest? (-> self control status) (collide-status on-surface)))
             (target-falling-anim-trans)
             (+! s5-1 (- (current-time) (-> self clock old-frame-counter)))
             (if (>= s5-1 300)
                 (goto cfg-15)
                 )
             (gp-0)
             (suspend)
             )
           )
         (label cfg-15)
         (set! (-> self post-hook) target-no-stick-post)
         (ja-channel-push! 1 (seconds 0.1))
         (ja-no-eval :group! jakb-powerjak-get-on-ja :num! (seek! max 1.2) :frame-num 0.0)
         (until (ja-done? 0)
           (gp-0)
           (suspend)
           (ja :num! (seek! max 1.2))
           )
         (ja-no-eval :group! jakb-powerjak-get-on-loop-ja :num! (seek! max 1.5) :frame-num 0.0)
         (until (ja-done? 0)
           (gp-0)
           (suspend)
           (ja :num! (seek! max 1.5))
           )
         (ja-no-eval :group! jakb-powerjak-get-on-ja :num! (seek! (ja-aframe 6.0 0) 1.2) :frame-num max)
         (until (ja-done? 0)
           (gp-0)
           (suspend)
           (ja :num! (seek! (ja-aframe 6.0 0) 1.2))
           )
         (go target-stance)
         )
        (else
          (ja-channel-push! 1 (seconds 0.05))
          (ja-no-eval :group! jakb-powerup-ja
                      :num! (seek! max (if (= arg1 (-> *FACT-bank* eco-full-inc))
                                     2.0
                                     3.0
                                     )
                             )
                      :frame-num (ja-aframe
                        (if (= arg1 (-> *FACT-bank* eco-full-inc))
                            0.0
                            6.0
                            )
                        0
                        )
                      )
          (until (ja-done? 0)
            (gp-0)
            (compute-alignment! (-> self align))
            (align!
              (-> self align)
              (align-opts adjust-y-vel)
              1.0
              (if (= arg1 (-> *FACT-bank* eco-full-inc))
                  2.0
                  1.0
                  )
              1.0
              )
            (suspend)
            (let ((a0-21 (-> self skel root-channel 0)))
              (set! (-> a0-21 param 0) (the float (+ (-> a0-21 frame-group frames num-frames) -1)))
              (let ((v1-124 (if (= arg1 (-> *FACT-bank* eco-full-inc))
                                2.0
                                3.0
                                )
                            )
                    )
                (set! (-> a0-21 param 1) v1-124)
                )
              (joint-control-channel-group-eval! a0-21 (the-as art-joint-anim #f) num-func-seek!)
              )
            )
          (go target-falling 'target-eco-powerup)
          )
        )
      )
    )
  :post target-post
  )

;; failed to figure out what this is:
(let ((a0-90 (copy *walk-mods* 'global)))
  (set! (-> a0-90 flags) (surface-flag gun-off gun-fast-exit))
  (set! *hit-ground-hard-mods* a0-90)
  )

;; failed to figure out what this is:
(defstate target-hit-ground-hard (target)
  :event target-standard-event-handler
  :enter (behavior ((arg0 float))
    (set! (-> self control last-running-attack-end-time) 0)
    (set! (-> self control last-attack-end-time) 0)
    (set-forward-vel 0.0)
    (set! (-> self control mod-surface) *hit-ground-hard-mods*)
    (logior! (-> self focus-status) (focus-status hit))
    )
  :exit (behavior ()
    (if (not (and (-> self next-state) (= (-> self next-state name) 'target-death)))
        (logclear! (-> self focus-status) (focus-status dead hit))
        )
    (target-exit)
    )
  :code (behavior ((arg0 float))
    (when (!= arg0 0.0)
      (let ((f0-5 (the float (the int (+ 1.0 (/ (- arg0 (-> *TARGET-bank* fall-far)) (-> *TARGET-bank* fall-far-inc))))))
            )
        (pickup-collectable!
          (-> self fact)
          (pickup-type health)
          (* (-> *FACT-bank* health-single-inc) (- (fmax 0.0 f0-5)))
          (the-as handle #f)
          )
        )
      (target-timed-invulnerable (-> *TARGET-bank* hit-invulnerable-timeout) self 1)
      )
    (cond
      ((and (= (-> self game mode) 'play) (>= 0.0 (-> self fact health)))
       (set! (-> self attack-info attacker) (the-as handle #f))
       (go target-death 'target-hit-ground-hard)
       )
      (else
        (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.1))
        (ja-channel-push! 1 1)
        (ja :group! jakb-painful-land-ja :num! min)
        (until (and (ja-done? 0) (= (-> self skel root-channel 0) (-> self skel channel)))
          (suspend)
          (if (= (-> self skel root-channel 0) (-> self skel channel))
              (ja :num! (seek!))
              )
          )
        (ja :group! jakb-painful-land-end-ja :num! min)
        (until (and (ja-done? 0) (= (-> self skel root-channel 0) (-> self skel channel)))
          (suspend)
          (if (= (-> self skel root-channel 0) (-> self skel channel))
              (ja :num! (seek!))
              )
          )
        (go target-stance)
        )
      )
    )
  :post target-no-stick-post
  )

;; definition for symbol *hide-mods*, type surface
(define *hide-mods* (new 'static 'surface
                      :name 'run
                      :turnv 262144.0
                      :turnvf 15.0
                      :tiltv 65536.0
                      :tiltvf 150.0
                      :tiltvv 262144.0
                      :tiltvvf 15.0
                      :transv-max 40960.0
                      :seek0 0.5
                      :seek90 0.5
                      :seek180 0.5
                      :fric 1.0
                      :nonlin-fric-dist 1.0
                      :slip-factor 1.0
                      :slide-factor 1.0
                      :slope-up-factor 1.0
                      :slope-down-factor 1.0
                      :slope-slip-angle 1.0
                      :impact-fric 1.0
                      :bend-factor 1.0
                      :bend-speed 1.0
                      :alignv 1.0
                      :slope-up-traction 1.0
                      :align-speed 1.0
                      :flags (surface-flag look-around gun-off)
                      )
        )

;; failed to figure out what this is:
(defstate target-hide (target)
  :event target-standard-event-handler
  :enter (behavior ()
    (set! (-> self control mod-surface) *hide-mods*)
    (forward-up-nopitch->quaternion
      (-> self control dir-targ)
      (-> self control wall-contact-normal)
      (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> self control quat))
      )
    (set-time! (-> self state-time))
    )
  :exit (behavior ()
    (if (using-gun? self)
        (target-top-anim-base-mode 37)
        )
    (logclear! (-> self target-flags) (target-flags lleg-still rleg-still))
    (set! (-> self control bend-target) 0.0)
    )
  :trans (behavior ()
    (if (and (logtest? (water-flag wading) (-> self water flags)) (not (using-gun? self)))
        (go target-wade-stance)
        )
    (if (= (-> self control ground-pat material) (pat-material ice))
        (go target-ice-stance)
        )
    (if (and (move-legs?)
             (and (time-elapsed? (-> self state-time) (seconds 1))
                  (let ((f0-1 (vector-dot (-> self control to-target-pt-xz) (-> self control wall-contact-normal))))
                    (< 0.1 f0-1)
                    )
                  )
             )
        (go target-walk)
        )
    (if (want-to-powerjak?)
        (go target-powerjak-get-on)
        )
    (if (and (cpad-hold? (-> self control cpad number) l1) (can-duck?))
        (go target-duck-stance #f)
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons x)
                       )
             (can-jump? #f)
             )
        (target-jump-go)
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons circle)
                       )
             (can-feet? #t)
             )
        (go target-attack)
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons square)
                       )
             (can-hands? #t)
             )
        (go target-running-attack)
        )
    (if (and (using-gun? self)
             (and (-> self next-state) (= (-> self next-state name) 'target-stance))
             (let ((v1-85 (ja-group)))
               (and v1-85 (= v1-85 jakb-stance-loop-ja))
               )
             )
        (go target-gun-stance)
        )
    (if (and (logtest? (game-feature feature19) (-> self game features))
             (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons r1)
                       )
             )
        (go target-carry-pickup)
        )
    (slide-down-test)
    (fall-test target-falling (-> *TARGET-bank* fall-height))
    (set-forward-vel (* 0.7 (-> self control ctrl-xz-vel)))
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! jakb-wall-hide-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (ja-channel-push! 2 (seconds 0.05))
    (let ((a0-5 (-> self skel root-channel 1)))
      (let ((f0-7 0.2))
        (set! (-> a0-5 frame-interp 1) f0-7)
        (set! (-> a0-5 frame-interp 0) f0-7)
        )
      (set! (-> a0-5 frame-group) (the-as art-joint-anim jakb-wall-hide-body-ja))
      (set! (-> a0-5 param 0) 1.0)
      (joint-control-channel-group-eval! a0-5 (the-as art-joint-anim jakb-wall-hide-body-ja) num-func-loop!)
      )
    (set! (-> self control unknown-word04) (the-as uint 0.5))
    (set! (-> self control did-move-to-pole-or-max-jump-height) 0.5)
    (set! (-> self control unknown-float35) (the-as float #f))
    (let ((gp-0
            (lambda :behavior target
              ()
              (ja :chan 1 :num! (loop! (the-as float (-> self control unknown-word04))))
              (if (rand-vu-percent? 0.05)
                  (set! (-> self control did-move-to-pole-or-max-jump-height) (rand-vu-float-range 0.5 1.5))
                  )
              (set! (-> self control unknown-word04) (the-as uint (seek
                                                                    (the-as float (-> self control unknown-word04))
                                                                    (-> self control did-move-to-pole-or-max-jump-height)
                                                                    (* 2.0 (seconds-per-frame))
                                                                    )
                                                             )
                    )
              (let ((v0-4 (> (-> self neck look-at-count) 0)))
                (set! (-> self control unknown-float35) (the-as float v0-4))
                v0-4
                )
              )
            )
          )
      (until #f
        (let ((s5-0 (rand-vu-int-range 30 600)))
          (ja :group! jakb-wall-hide-head-ja)
          (suspend-for s5-0
            (gp-0)
            )
          )
        (let ((f30-0 (rand-vu-float-range 0.5 1.5)))
          (cond
            ((or (cpad-hold? 1 r3) (-> self control unknown-float35))
             (let ((f30-1 (rand-vu-float-range 0.25 0.75)))
               (ja-no-eval :group! jakb-wall-hide-scared-ja :num! (seek!) :frame-num 0.0)
               (until (ja-done? 0)
                 (gp-0)
                 (suspend)
                 (ja :num! (seek!))
                 )
               (let ((s5-1 (rand-vu-int-range 1 10)))
                 (dotimes (s4-1 s5-1)
                   (ja-no-eval :group! jakb-wall-hide-scared-loop-ja :num! (seek! max f30-1) :frame-num 0.0)
                   (until (ja-done? 0)
                     (gp-0)
                     (suspend)
                     (ja :num! (seek! max f30-1))
                     )
                   )
                 )
               )
             (ja-no-eval :group! jakb-wall-hide-scared-return-ja :num! (seek!) :frame-num 0.0)
             (until (ja-done? 0)
               (gp-0)
               (suspend)
               (ja :num! (seek!))
               )
             )
            ((rand-vu-percent? 0.5)
             (ja-no-eval :group! jakb-wall-hide-head-left-ja :num! (seek! max f30-0) :frame-num 0.0)
             (until (ja-done? 0)
               (gp-0)
               (suspend)
               (ja :num! (seek! max f30-0))
               )
             (let ((s5-2 (rand-vu-int-range 60 300)))
               (suspend-for s5-2
                 (gp-0)
                 )
               )
             (ja-no-eval :group! jakb-wall-hide-head-left-ja :num! (seek! 0.0 f30-0) :frame-num max)
             (until (ja-done? 0)
               (gp-0)
               (suspend)
               (ja :num! (seek! 0.0 f30-0))
               )
             )
            (else
              (ja-no-eval :group! jakb-wall-hide-head-right-ja :num! (seek! 0.0 f30-0) :frame-num max)
              (until (ja-done? 0)
                (gp-0)
                (suspend)
                (ja :num! (seek! 0.0 f30-0))
                )
              (let ((s5-3 (rand-vu-int-range 60 300)))
                (suspend-for s5-3
                  (gp-0)
                  )
                )
              (ja-no-eval :group! jakb-wall-hide-head-right-ja :num! (seek! max f30-0) :frame-num 0.0)
              (until (ja-done? 0)
                (gp-0)
                (suspend)
                (ja :num! (seek! max f30-0))
                )
              )
            )
          )
        )
      )
    #f
    )
  :post target-post
  )

;; failed to figure out what this is:
(defstate target-launch (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (if (and (= message 'query) (= (-> block param 0) 'mode))
        'target-launch
        (target-standard-event-handler proc argc message block)
        )
    )
  :code (behavior ((arg0 float) (arg1 symbol) (arg2 vector) (arg3 int))
    (set-time! (-> self state-time))
    (set! (-> self control mod-surface) *turn-around-mods*)
    (ja-channel-push! 1 (seconds 0.15))
    (set-forward-vel 0.0)
    (ja-no-eval :group! jakb-duck-stance-ja :num! (seek! (ja-aframe 15.0 0) 3.0) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! (ja-aframe 15.0 0) 3.0))
      )
    (if arg1
        (send-event *camera* 'change-state arg1 (seconds 0.6))
        )
    (if (nonzero? arg3)
        (process-spawn-function
          process
          (lambda :behavior process
            ((arg0 vector) (arg1 time-frame) (arg2 float))
            (local-vars (sv-32 time-frame) (sv-40 vector) (sv-44 symbol))
            (set! sv-32 (current-time))
            (let ((v1-2 (new-stack-vector0)))
              (set! (-> v1-2 quad) (-> arg0 quad))
              (set! sv-40 v1-2)
              )
            (set! sv-44 #t)
            (until (time-elapsed? sv-32 arg1)
              (let ((s4-0 (ppointer->process (-> self parent))))
                (cond
                  ((and sv-44
                        (< (- (-> (the-as target s4-0) control trans y) (-> (the-as target s4-0) control last-trans-any-surf y)) arg2)
                        )
                   (vector-xz-normalize! (-> (the-as target s4-0) control transv) 0.0)
                   (when (< (vector-vector-xz-distance (-> (the-as target s4-0) control trans) sv-40) 20480.0)
                     (let ((v1-15 (vector-! (new-stack-vector0) (-> (the-as target s4-0) control trans) sv-40)))
                       (set! (-> (the-as target s4-0) control trans x) (+ (-> sv-40 x) (fmax -2867.2 (fmin 2867.2 (-> v1-15 x)))))
                       (set! (-> (the-as target s4-0) control trans z) (+ (-> sv-40 z) (fmax -2867.2 (fmin 2867.2 (-> v1-15 z)))))
                       )
                     )
                   )
                  (else
                    (if sv-44
                        (set! sv-32 (current-time))
                        )
                    (set! sv-44 (the-as symbol #f))
                    (when (and (-> (the-as target s4-0) next-state)
                               (let ((v1-25 (-> (the-as target s4-0) next-state name)))
                                 (or (= v1-25 'target-duck-high-jump-jump) (= v1-25 'target-falling))
                                 )
                               )
                      (let ((v1-28 (-> (the-as target s4-0) control trans))
                            (s3-0 (-> (the-as target s4-0) control transv))
                            )
                        (set! (-> s3-0 x) (- (-> sv-40 x) (-> v1-28 x)))
                        (set! (-> s3-0 z) (- (-> sv-40 z) (-> v1-28 z)))
                        (let* ((v1-29 s3-0)
                               (f30-0 (sqrtf (+ (* (-> v1-29 x) (-> v1-29 x)) (* (-> v1-29 z) (-> v1-29 z)))))
                               )
                          (if (< 122880.0 f30-0)
                              (vector-xz-normalize! s3-0 122880.0)
                              )
                          (if (< 4096.0 f30-0)
                              (forward-up-nopitch->quaternion
                                (-> (the-as target s4-0) control dir-targ)
                                (vector-normalize-copy! (new 'stack-no-clear 'vector) s3-0 1.0)
                                (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> (the-as target s4-0) control quat))
                                )
                              )
                          )
                        )
                      )
                    )
                  )
                )
              (suspend)
              0
              )
            #f
            )
          arg2
          arg3
          #x480c0000
          :to self
          )
        )
    (go target-high-jump arg0 arg0 'launch)
    )
  :post target-no-stick-post
  )

;; failed to figure out what this is:
(defstate target-play-anim (target)
  :event target-generic-event-handler
  :enter (behavior ((arg0 string) (arg1 handle))
    (set! (-> self control anim-handle) arg1)
    (move-to-ground (-> self control) 40960.0 40960.0 #f (-> self control root-prim prim-core collide-with))
    (logior! (-> self focus-status) (focus-status grabbed))
    (set! (-> self neck flex-blend) 0.0)
    )
  :exit (behavior ()
    (send-event (handle->process (-> self control anim-handle)) 'end-mode)
    (target-exit)
    )
  :code (behavior ((arg0 string) (arg1 handle))
    (let ((gp-0 (get-art-by-name (-> self draw art-group) arg0 art-joint-anim)))
      (when gp-0
        (send-event (ppointer->process (-> self sidekick)) 'matrix 'play-anim)
        (ja-channel-set! 1)
        (ja-no-eval :group! gp-0 :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!))
          )
        (send-event (ppointer->process (-> self sidekick)) 'matrix 'normal)
        )
      )
    (go target-stance)
    )
  :post target-no-stick-post
  )

;; failed to figure out what this is:
(defstate target-clone-anim (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (if (and (= message 'trans) (= (-> block param 0) 'restore))
        (set! (-> self control unknown-word04) (the-as uint #f))
        )
    ((-> target-grab event) proc argc message block)
    )
  :enter (behavior ((arg0 handle))
    (set! (-> self control anim-handle) arg0)
    (set! (-> self control unknown-vector37 quad) (-> self control trans quad))
    (set! (-> self control unknown-word04) (the-as uint #t))
    (quaternion-copy! (the-as quaternion (-> self control unknown-vector38)) (-> self control quat))
    (logior! (-> self focus-status) (focus-status grabbed))
    (vector-reset! (-> self control transv))
    (set! (-> self neck flex-blend) 0.0)
    (send-event (ppointer->process (-> self sidekick)) 'shadow #t)
    )
  :exit (behavior ()
    (send-event (ppointer->process (-> self sidekick)) 'matrix 'normal)
    (send-event (ppointer->process (-> self sidekick)) 'shadow #t)
    (let ((gp-0 (joint-node jakb-lod0-jg main))
          (a1-2 (-> self control camera-pos))
          )
      (cond
        ((not (-> self control unknown-spool-anim00))
         )
        ((not (logtest? (-> self draw status) (draw-control-status no-draw)))
         (move-to-point! (-> self control) a1-2)
         (matrix->quaternion (-> self control quat-for-control) (-> gp-0 bone transform))
         (quaternion-copy! (-> self control quat) (-> self control quat-for-control))
         (move-to-ground (-> self control) 4096.0 40960.0 #t (-> self control root-prim prim-core collide-with))
         (when (logtest? (-> self control status) (collide-status on-water))
           (let ((a1-6 (new-stack-vector0)))
             (set! (-> a1-6 x) (-> self control trans x))
             (set! (-> a1-6 y) (-> self water height))
             (set! (-> a1-6 z) (-> self control trans z))
             (set! (-> a1-6 w) 1.0)
             (move-to-point! (-> self control) a1-6)
             )
           )
         )
        (else
          (format 0 "ERROR: <ASG>: camera used backup position~%")
          (move-to-point! (-> self control) (-> self control unknown-vector37))
          (quaternion-copy! (-> self control quat) (the-as quaternion (-> self control unknown-vector38)))
          )
        )
      )
    (rot->dir-targ! (-> self control))
    (logior! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (set-time! (-> self control last-time-on-surface))
    (ja-channel-set! 0)
    (ja-post)
    (target-exit)
    )
  :code (behavior ((arg0 handle))
    (clone-anim arg0 #t "")
    (go target-stance)
    )
  :post target-no-ja-move-post
  )

;; failed to figure out what this is:
(let ((v1-28 (copy *walk-mods* 'global)))
  (set! (-> v1-28 name) 'float)
  (set! (-> v1-28 target-speed) 81920.0)
  (set! (-> v1-28 transv-max) 81920.0)
  (set! (-> v1-28 flags) (surface-flag gun-off))
  (set! *float-mods* v1-28)
  )

;; failed to figure out what this is:
(defstate target-float (target)
  :event target-generic-event-handler
  :enter (behavior ()
    (sound-play-by-spec (static-sound-spec "menu-pick" :group 0 :fo-curve 1) (new-sound-id) (the-as vector #t))
    (set! (-> self control additional-decaying-velocity-end-time) 0)
    (vector-reset! (-> self control additional-decaying-velocity))
    (let ((v1-3 (new-stack-vector0)))
      (let ((f0-1 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
        0.0
        (vector-! v1-3 (-> self control transv) (vector-float*! v1-3 (-> self control dynam gravity-normal) f0-1))
        )
      (let* ((f0-2 (vector-length v1-3))
             (f1-1 f0-2)
             (f2-0 0.0)
             )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-0)
          (vector-float*! v1-3 v1-3 (/ f0-2 f1-1))
          )
        )
      )
    (set! (-> self control dynam gravity-max) 0.0)
    (set! (-> self control dynam gravity-length) 0.0)
    (set! (-> self control mod-surface) *float-mods*)
    (target-darkjak-end-mode #t)
    (target-lightjak-end-mode #t)
    )
  :exit (behavior ()
    (sound-play-by-spec (static-sound-spec "menu-back" :group 0 :fo-curve 1) (new-sound-id) (the-as vector #t))
    (set! (-> self control dynam gravity-max) (-> self control standard-dynamics gravity-max))
    (set! (-> self control dynam gravity-length) (-> self control standard-dynamics gravity-length))
    (target-exit)
    (logclear! (-> *cpad-list* cpads (-> self control cpad number) button0-abs 0) (pad-buttons l2 r2 l1 r1 x))
    (logclear! (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0) (pad-buttons l2 r2 l1 r1 x))
    (when (nonzero? (-> self gun))
      (set! (-> self gun using-gun-type) (pickup-type none))
      (set! (-> self gun latch?) #f)
      )
    (if (nonzero? (-> self board))
        (set! (-> self board latch?) #f)
        )
    )
  :trans (behavior ()
    (set-time! (-> self control time-of-last-debug-float))
    (cond
      ((cpad-hold? (-> self control cpad number) r2)
       (let ((a1-0 (new 'stack-no-clear 'vector)))
         (set! (-> a1-0 quad) (-> self control trans quad))
         (let ((v1-14 (new-stack-vector0))
               (f0-1 (vector-dot (-> self control dynam gravity-normal) a1-0))
               )
           0.0
           (vector-! v1-14 a1-0 (vector-float*! v1-14 (-> self control dynam gravity-normal) f0-1))
           (let* ((f1-2 (vector-length v1-14))
                  (f2-0 f1-2)
                  (f0-2 (+ 512.0 f0-1))
                  )
             (vector+!
               a1-0
               (vector-float*! a1-0 (-> self control dynam gravity-normal) f0-2)
               (vector-float*! v1-14 v1-14 (/ f1-2 f2-0))
               )
             )
           )
         (move-to-point! (-> self control) a1-0)
         )
       )
      ((cpad-hold? (-> self control cpad number) l2)
       (let ((a1-1 (new 'stack-no-clear 'vector)))
         (set! (-> a1-1 quad) (-> self control trans quad))
         (let ((v1-29 (new-stack-vector0))
               (f0-5 (vector-dot (-> self control dynam gravity-normal) a1-1))
               )
           0.0
           (vector-! v1-29 a1-1 (vector-float*! v1-29 (-> self control dynam gravity-normal) f0-5))
           (let* ((f1-5 (vector-length v1-29))
                  (f2-1 f1-5)
                  (f0-6 (+ -512.0 f0-5))
                  )
             (vector+!
               a1-1
               (vector-float*! a1-1 (-> self control dynam gravity-normal) f0-6)
               (vector-float*! v1-29 v1-29 (/ f1-5 f2-1))
               )
             )
           )
         (move-to-point! (-> self control) a1-1)
         )
       )
      ((cpad-pressed? (-> self control cpad number) l1 x)
       (go (the-as (state target) target-falling))
       )
      )
    (let ((v1-43 (new-stack-vector0)))
      (let ((f0-9 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
        0.0
        (vector-! v1-43 (-> self control transv) (vector-float*! v1-43 (-> self control dynam gravity-normal) f0-9))
        )
      (let* ((f0-10 (vector-length v1-43))
             (f1-7 f0-10)
             (f2-2 0.0)
             )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-2)
          (vector-float*! v1-43 v1-43 (/ f0-10 f1-7))
          )
        )
      )
    )
  :code target-stance-anim
  :post target-post
  )

;; failed to figure out what this is:
(let ((v1-31 (copy *walk-mods* 'global)))
  (set! (-> v1-31 name) 'blast-recover)
  (set! (-> v1-31 flags) (surface-flag gun-off gun-fast-exit))
  (set! *blast-recover-mods* v1-31)
  )

;; failed to figure out what this is:
(defstate target-blast-recover (target)
  :event target-standard-event-handler
  :code (behavior ((arg0 rigid-body-impact))
    (when (= (-> self ext-anim) (target-anim default))
      (set-forward-vel 0.0)
      (set! (-> self control mod-surface) *blast-recover-mods*)
      (ja-channel-push! 1 (seconds 0.1))
      (ja-no-eval :group! jakb-blast-recover-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      (suspend-for (the-as time-frame arg0)
        (ja-no-eval :group! jakb-blast-recover-loop-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!))
          )
        (empty-form)
        )
      (ja-no-eval :group! jakb-blast-recover-end-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (if (!= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
            (go target-walk)
            )
        (suspend)
        (ja :num! (seek!))
        )
      )
    (go target-stance)
    )
  :post target-no-stick-post
  )
