;;-*-Lisp-*-
(in-package goal)

;; failed to figure out what this is:
(defskelgroup skel-jchar jakb jakb-lod0-jg -1
              ((jakb-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3.2)
              :longest-edge (meters 1)
              :texture-level 10
              :origin-joint-index 3
              :shadow-joint-index 3
              :light-index 1
              )

;; failed to figure out what this is:
(defskelgroup skel-jchar-normal jakb jakb-lod0-jg -1
              ((jak-ext-geo-c+0-jakclod0-skirt-cg (meters 999999)))
              :bounds (static-spherem 0 0 0 3.2)
              :longest-edge (meters 1)
              :shadow jak-ext-geo-c+0-jakclod0-sash-cg
              :texture-level 10
              :origin-joint-index 3
              :shadow-joint-index 3
              :light-index 1
              )

;; failed to figure out what this is:
(defskelgroup skel-jchar-old jakb jakb-lod0-jg -1
              ((jakb-old-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3.2)
              :longest-edge (meters 1)
              :texture-level 10
              :origin-joint-index 3
              :shadow-joint-index 3
              :light-index 1
              )

;; failed to figure out what this is:
(defskelgroup skel-jchar-c jakb jakb-lod0-jg -1
              ((jakb-c-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3.2)
              :longest-edge (meters 1)
              :shadow jakb-c-shadow-mg
              :texture-level 10
              :origin-joint-index 3
              :shadow-joint-index 3
              :light-index 1
              :clothing (((mesh 10)
                (gravity-constant (meters 16))
                (wind-constant 0.5)
                (cloth-width 13)
                (flags (cloth-flag use-wind double-sided))
                (tex-name "jakc-skirt")
                (tex-name2 "jakc-skirt")
                (tex-name3 "jakc-skirt")
                (alt-tex-name "jakc-jacketbody")
                (alt-tex-name2 "jakc-jacketbody")
                (alt-tex-name3 "jakc-jacketbody")
                (cloth-thickness 1.0)
                (initial-xform 3)
                (drag 0.151)
                (ball-collision-radius (meters 0.05))
                (num-iterations 1)
                )
               ((mesh 11)
                (gravity-constant (meters 32))
                (wind-constant 0.75)
                (cloth-width 6)
                (flags (cloth-flag use-wind double-sided))
                (tex-name "jakc-skirt")
                (tex-name2 "jakc-skirt")
                (tex-name3 "jakc-skirt")
                (alt-tex-name "jakc-jacketbody")
                (alt-tex-name2 "jakc-jacketbody")
                (alt-tex-name3 "jakc-jacketbody")
                (cloth-thickness 1.0)
                (initial-xform 3)
                (drag 0.251)
                (ball-collision-radius (meters 0.05))
                (num-iterations 1)
                )
               ((mesh 12)
                (gravity-constant (meters 16))
                (wind-constant 1.25)
                (cloth-width 6)
                (flags (cloth-flag use-wind double-sided))
                (tex-name "jakc-scarfhanging")
                (tex-name2 "jakc-scarfhanging")
                (tex-name3 "jakc-scarfhanging")
                (alt-tex-name "jakc-eyebrow-norm")
                (alt-tex-name2 "jakc-eyebrow-norm")
                (alt-tex-name3 "jakc-eyebrow-norm")
                (cloth-thickness 2.0)
                (initial-xform 5)
                (drag 0.151)
                (ball-collision-radius (meters 0.05))
                (num-iterations 1)
                )
               )
              )

;; failed to figure out what this is:
(defskelgroup skel-jchar-wings jakb jakb-wings-wings-lod0-jg -1
              ((jakb-wings-wings-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3.2)
              :longest-edge (meters 1)
              :shadow jakb-walk-down-ja
              :texture-level 10
              :sort 2
              :origin-joint-index 3
              :shadow-joint-index 3
              :light-index 4
              )

;; failed to figure out what this is:
(defskelgroup skel-jchar-shield jakb jakb-shield-shield-lod0-jg -1
              ((jakb-shield-shield-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3.2)
              :longest-edge (meters 1)
              :texture-level 10
              :shadow-joint-index 3
              :light-index 5
              )

;; definition for symbol *target-shadow-control*, type shadow-control
(define *target-shadow-control*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :center (new 'static 'vector :w (the-as float #x2))
                                           :shadow-dir (new 'static 'vector :x -0.4226 :y -0.9063 :w 409600.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 37683.2)
                                           :top-plane (new 'static 'plane :y 1.0 :w 4096.0)
                                           )
                               )
  )

;; failed to figure out what this is:
(defskelgroup skel-jak-highres jak-highres jak-highres-lod0-jg jak-highres-idle-ja
              ((jak-highres-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3.2)
              :longest-edge (meters 1)
              :shadow jak-highres-shadow-mg
              :origin-joint-index 3
              :shadow-joint-index 3
              :light-index 1
              )

;; failed to figure out what this is:
(defskelgroup skel-jakc-highres jakc-highres jakc-highres-lod0-jg jakc-highres-idle-ja
              ((jakc-highres-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3.2)
              :longest-edge (meters 1)
              :shadow jakc-highres-shadow-mg
              :origin-joint-index 3
              :shadow-joint-index 3
              :clothing (((mesh jakc-highres-jakcfma0-skirt-cg)
                (gravity-constant (meters 16))
                (wind-constant 0.5)
                (cloth-width 13)
                (flags (cloth-flag use-wind double-sided))
                (tex-name "jakc-skirt")
                (tex-name2 "jakc-skirt")
                (tex-name3 "jakc-skirt")
                (cloth-thickness 1.0)
                (initial-xform 3)
                (drag 0.151)
                (ball-collision-radius (meters 0.05))
                (num-iterations 1)
                (timestep-frequency 7)
                )
               ((mesh jakc-highres-jakcfma0-sash-cg)
                (gravity-constant (meters 32))
                (wind-constant 0.75)
                (cloth-width 6)
                (flags (cloth-flag use-wind double-sided))
                (tex-name "jakc-skirt")
                (tex-name2 "jakc-skirt")
                (tex-name3 "jakc-skirt")
                (cloth-thickness 1.0)
                (initial-xform 3)
                (drag 0.251)
                (ball-collision-radius (meters 0.05))
                (num-iterations 1)
                (timestep-frequency 7)
                )
               ((mesh jakc-highres-jakcfma0-scarf-cg)
                (gravity-constant (meters 16))
                (wind-constant 1.25)
                (cloth-width 6)
                (flags (cloth-flag use-wind double-sided))
                (tex-name "jakc-scarfhanging")
                (tex-name2 "jakc-scarfhanging")
                (tex-name3 "jakc-scarfhanging")
                (cloth-thickness 2.0)
                (initial-xform 4)
                (drag 0.151)
                (ball-collision-radius (meters 0.05))
                (num-iterations 1)
                (timestep-frequency 7)
                )
               )
              )

;; failed to figure out what this is:
(defskelgroup skel-generic-blast collectables collectables-generic-blast-lod0-jg collectables-generic-blast-idle-ja
              ((collectables-generic-blast-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 50)
              :texture-level 10
              :light-index 4
              )

;; failed to figure out what this is:
(defskelgroup skel-generic-ripples collectables collectables-generic-ripples-lod0-jg collectables-generic-ripples-idle-ja
              ((collectables-generic-ripples-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 6)
              :texture-level 10
              :light-index 4
              )

;; failed to figure out what this is:
(defskelgroup skel-bomb-blast collectables collectables-bomb-blast-lod0-jg collectables-bomb-blast-idle-ja
              ((collectables-bomb-blast-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 50)
              :texture-level 10
              :light-index 4
              )

;; definition of type target-bank
(deftype target-bank (basic)
  ((jump-collide-offset               meters)
   (jump-height-min                   meters)
   (jump-height-max                   meters)
   (double-jump-height-min            meters)
   (double-jump-height-max            meters)
   (flip-jump-height-min              meters)
   (flip-jump-height-max              meters)
   (duck-jump-height-min              meters)
   (duck-jump-height-max              meters)
   (flop-jump-height-min              meters)
   (flop-jump-height-max              meters)
   (attack-jump-height-min            meters)
   (attack-jump-height-max            meters)
   (edge-grab-jump-height-min         meters)
   (edge-grab-jump-height-max         meters)
   (swim-jump-height-min              meters)
   (swim-jump-height-max              meters)
   (tube-jump-height-min              meters)
   (tube-jump-height-max              meters)
   (carry-jump-height-min             meters)
   (carry-jump-height-max             meters)
   (mech-jump-height-min              meters)
   (mech-jump-height-max              meters)
   (mech-carry-jump-height-min        meters)
   (mech-carry-jump-height-max        meters)
   (indax-jump-height-min             meters)
   (indax-jump-height-max             meters)
   (indax-double-jump-height-min      meters)
   (indax-double-jump-height-max      meters)
   (roll-duration                     time-frame)
   (roll-jump-pre-window              time-frame)
   (roll-jump-post-window             time-frame)
   (roll-timeout                      time-frame)
   (roll-speed-min                    meters)
   (roll-speed-inc                    meters)
   (roll-flip-duration                time-frame)
   (roll-flip-height                  meters)
   (roll-flip-dist                    meters)
   (roll-flip-art-height              meters)
   (roll-flip-art-dist                meters)
   (duck-slide-distance               meters)
   (fall-far                          meters)
   (fall-far-inc                      meters)
   (attack-timeout                    time-frame)
   (ground-timeout                    time-frame)
   (slide-down-timeout                time-frame)
   (fall-timeout                      time-frame)
   (fall-stumble-threshold            meters)
   (yellow-projectile-speed           meters)
   (hit-invulnerable-timeout          time-frame)
   (same-attack-invulnerable-timeout  time-frame)
   (run-cycle-length                  float)
   (walk-cycle-dist                   meters)
   (walk-up-cycle-dist                meters)
   (walk-down-cycle-dist              meters)
   (walk-side-cycle-dist              meters)
   (run-cycle-dist                    meters)
   (run-up-cycle-dist                 meters)
   (run-down-cycle-dist               meters)
   (run-side-cycle-dist               meters)
   (run-wall-cycle-dist               meters)
   (duck-walk-cycle-dist              meters)
   (wade-shallow-walk-cycle-dist      meters)
   (wade-deep-walk-cycle-dist         meters)
   (mech-walk-cycle-dist              meters)
   (mech-run-cycle-dist               meters)
   (smack-surface-dist                meters)
   (smack-surface-height              meters)
   (min-dive-depth                    meters)
   (root-radius                       meters)
   (root-offset                       vector  :inline)
   (body-radius                       meters)
   (edge-radius                       meters)
   (edge-offset                       vector  :inline)
   (edge-grab-height-off-ground       meters)
   (head-radius                       meters)
   (head-height                       meters)
   (head-offset                       vector  :inline)
   (spin-radius                       meters)
   (spin-offset                       vector  :inline)
   (duck-spin-radius                  meters)
   (duck-spin-offset                  vector  :inline)
   (punch-radius                      meters)
   (punch-offset                      vector  :inline)
   (uppercut-radius                   meters)
   (uppercut0-offset                  vector  :inline)
   (uppercut1-offset                  vector  :inline)
   (flop-radius                       meters)
   (flop0-offset                      vector  :inline)
   (flop1-offset                      vector  :inline)
   (stuck-time                        seconds)
   (stuck-timeout                     seconds)
   (stuck-distance                    meters)
   (tongue-pull-speed-min             float)
   (tongue-pull-speed-max             float)
   (yellow-attack-timeout             time-frame)
   (fall-height                       meters)
   (mech-jump-thrust-fuel             float)
   (strafe-jump-pre-window            time-frame)
   (strafe-jump                       basic)
   (strafe-duck-jump                  basic)
   (dark-jump-height-min              meters)
   (dark-jump-height-max              meters)
   (ladder-walk-up-speed              meters)
   (ladder-walk-down-speed            meters)
   (ladder-slide-speed                meters)
   (invisible-duration                time-frame)
   (mech-walk-carry-cycle-dist        meters)
   )
  )

;; definition for method 3 of type target-bank
(defmethod inspect ((this target-bank))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this (-> this type))
  (format #t "~1Tjump-collide-offset: (meters ~m)~%" (-> this jump-collide-offset))
  (format #t "~1Tjump-height-min: (meters ~m)~%" (-> this jump-height-min))
  (format #t "~1Tjump-height-max: (meters ~m)~%" (-> this jump-height-max))
  (format #t "~1Tdouble-jump-height-min: (meters ~m)~%" (-> this double-jump-height-min))
  (format #t "~1Tdouble-jump-height-max: (meters ~m)~%" (-> this double-jump-height-max))
  (format #t "~1Tflip-jump-height-min: (meters ~m)~%" (-> this flip-jump-height-min))
  (format #t "~1Tflip-jump-height-max: (meters ~m)~%" (-> this flip-jump-height-max))
  (format #t "~1Tduck-jump-height-min: (meters ~m)~%" (-> this duck-jump-height-min))
  (format #t "~1Tduck-jump-height-max: (meters ~m)~%" (-> this duck-jump-height-max))
  (format #t "~1Tflop-jump-height-min: (meters ~m)~%" (-> this flop-jump-height-min))
  (format #t "~1Tflop-jump-height-max: (meters ~m)~%" (-> this flop-jump-height-max))
  (format #t "~1Tattack-jump-height-min: (meters ~m)~%" (-> this attack-jump-height-min))
  (format #t "~1Tattack-jump-height-max: (meters ~m)~%" (-> this attack-jump-height-max))
  (format #t "~1Tedge-grab-jump-height-min: (meters ~m)~%" (-> this edge-grab-jump-height-min))
  (format #t "~1Tedge-grab-jump-height-max: (meters ~m)~%" (-> this edge-grab-jump-height-max))
  (format #t "~1Tswim-jump-height-min: (meters ~m)~%" (-> this swim-jump-height-min))
  (format #t "~1Tswim-jump-height-max: (meters ~m)~%" (-> this swim-jump-height-max))
  (format #t "~1Ttube-jump-height-min: (meters ~m)~%" (-> this tube-jump-height-min))
  (format #t "~1Ttube-jump-height-max: (meters ~m)~%" (-> this tube-jump-height-max))
  (format #t "~1Tcarry-jump-height-min: (meters ~m)~%" (-> this carry-jump-height-min))
  (format #t "~1Tcarry-jump-height-max: (meters ~m)~%" (-> this carry-jump-height-max))
  (format #t "~1Tmech-jump-height-min: (meters ~m)~%" (-> this mech-jump-height-min))
  (format #t "~1Tmech-jump-height-max: (meters ~m)~%" (-> this mech-jump-height-max))
  (format #t "~1Tmech-carry-jump-height-min: (meters ~m)~%" (-> this mech-carry-jump-height-min))
  (format #t "~1Tmech-carry-jump-height-max: (meters ~m)~%" (-> this mech-carry-jump-height-max))
  (format #t "~1Tindax-jump-height-min: (meters ~m)~%" (-> this indax-jump-height-min))
  (format #t "~1Tindax-jump-height-max: (meters ~m)~%" (-> this indax-jump-height-max))
  (format #t "~1Tindax-double-jump-height-min: (meters ~m)~%" (-> this indax-double-jump-height-min))
  (format #t "~1Tindax-double-jump-height-max: (meters ~m)~%" (-> this indax-double-jump-height-max))
  (format #t "~1Troll-duration: ~D~%" (-> this roll-duration))
  (format #t "~1Troll-jump-pre-window: ~D~%" (-> this roll-jump-pre-window))
  (format #t "~1Troll-jump-post-window: ~D~%" (-> this roll-jump-post-window))
  (format #t "~1Troll-timeout: ~D~%" (-> this roll-timeout))
  (format #t "~1Troll-speed-min: (meters ~m)~%" (-> this roll-speed-min))
  (format #t "~1Troll-speed-inc: (meters ~m)~%" (-> this roll-speed-inc))
  (format #t "~1Troll-flip-duration: ~D~%" (-> this roll-flip-duration))
  (format #t "~1Troll-flip-height: (meters ~m)~%" (-> this roll-flip-height))
  (format #t "~1Troll-flip-dist: (meters ~m)~%" (-> this roll-flip-dist))
  (format #t "~1Troll-flip-art-height: (meters ~m)~%" (-> this roll-flip-art-height))
  (format #t "~1Troll-flip-art-dist: (meters ~m)~%" (-> this roll-flip-art-dist))
  (format #t "~1Tduck-slide-distance: (meters ~m)~%" (-> this duck-slide-distance))
  (format #t "~1Tfall-far: (meters ~m)~%" (-> this fall-far))
  (format #t "~1Tfall-far-inc: (meters ~m)~%" (-> this fall-far-inc))
  (format #t "~1Tattack-timeout: ~D~%" (-> this attack-timeout))
  (format #t "~1Tground-timeout: ~D~%" (-> this ground-timeout))
  (format #t "~1Tslide-down-timeout: ~D~%" (-> this slide-down-timeout))
  (format #t "~1Tfall-timeout: ~D~%" (-> this fall-timeout))
  (format #t "~1Tfall-stumble-threshold: (meters ~m)~%" (-> this fall-stumble-threshold))
  (format #t "~1Tyellow-projectile-speed: (meters ~m)~%" (-> this yellow-projectile-speed))
  (format #t "~1Thit-invulnerable-timeout: ~D~%" (-> this hit-invulnerable-timeout))
  (format #t "~1Tsame-attack-invulnerable-timeout: ~D~%" (-> this same-attack-invulnerable-timeout))
  (format #t "~1Trun-cycle-length: ~f~%" (-> this run-cycle-length))
  (format #t "~1Twalk-cycle-dist: (meters ~m)~%" (-> this walk-cycle-dist))
  (format #t "~1Twalk-up-cycle-dist: (meters ~m)~%" (-> this walk-up-cycle-dist))
  (format #t "~1Twalk-down-cycle-dist: (meters ~m)~%" (-> this walk-down-cycle-dist))
  (format #t "~1Twalk-side-cycle-dist: (meters ~m)~%" (-> this walk-side-cycle-dist))
  (format #t "~1Trun-cycle-dist: (meters ~m)~%" (-> this run-cycle-dist))
  (format #t "~1Trun-up-cycle-dist: (meters ~m)~%" (-> this run-up-cycle-dist))
  (format #t "~1Trun-down-cycle-dist: (meters ~m)~%" (-> this run-down-cycle-dist))
  (format #t "~1Trun-side-cycle-dist: (meters ~m)~%" (-> this run-side-cycle-dist))
  (format #t "~1Trun-wall-cycle-dist: (meters ~m)~%" (-> this run-wall-cycle-dist))
  (format #t "~1Tduck-walk-cycle-dist: (meters ~m)~%" (-> this duck-walk-cycle-dist))
  (format #t "~1Twade-shallow-walk-cycle-dist: (meters ~m)~%" (-> this wade-shallow-walk-cycle-dist))
  (format #t "~1Twade-deep-walk-cycle-dist: (meters ~m)~%" (-> this wade-deep-walk-cycle-dist))
  (format #t "~1Tmech-walk-cycle-dist: (meters ~m)~%" (-> this mech-walk-cycle-dist))
  (format #t "~1Tmech-run-cycle-dist: (meters ~m)~%" (-> this mech-run-cycle-dist))
  (format #t "~1Tsmack-surface-dist: (meters ~m)~%" (-> this smack-surface-dist))
  (format #t "~1Tsmack-surface-height: (meters ~m)~%" (-> this smack-surface-height))
  (format #t "~1Tmin-dive-depth: (meters ~m)~%" (-> this min-dive-depth))
  (format #t "~1Troot-radius: (meters ~m)~%" (-> this root-radius))
  (format #t "~1Troot-offset: ~`vector`P~%" (-> this root-offset))
  (format #t "~1Tbody-radius: (meters ~m)~%" (-> this body-radius))
  (format #t "~1Tedge-radius: (meters ~m)~%" (-> this edge-radius))
  (format #t "~1Tedge-offset: ~`vector`P~%" (-> this edge-offset))
  (format #t "~1Tedge-grab-height-off-ground: (meters ~m)~%" (-> this edge-grab-height-off-ground))
  (format #t "~1Thead-radius: (meters ~m)~%" (-> this head-radius))
  (format #t "~1Thead-height: (meters ~m)~%" (-> this head-height))
  (format #t "~1Thead-offset: ~`vector`P~%" (-> this head-offset))
  (format #t "~1Tspin-radius: (meters ~m)~%" (-> this spin-radius))
  (format #t "~1Tspin-offset: ~`vector`P~%" (-> this spin-offset))
  (format #t "~1Tduck-spin-radius: (meters ~m)~%" (-> this duck-spin-radius))
  (format #t "~1Tduck-spin-offset: ~`vector`P~%" (-> this duck-spin-offset))
  (format #t "~1Tpunch-radius: (meters ~m)~%" (-> this punch-radius))
  (format #t "~1Tpunch-offset: ~`vector`P~%" (-> this punch-offset))
  (format #t "~1Tuppercut-radius: (meters ~m)~%" (-> this uppercut-radius))
  (format #t "~1Tuppercut0-offset: ~`vector`P~%" (-> this uppercut0-offset))
  (format #t "~1Tuppercut1-offset: ~`vector`P~%" (-> this uppercut1-offset))
  (format #t "~1Tflop-radius: (meters ~m)~%" (-> this flop-radius))
  (format #t "~1Tflop0-offset: ~`vector`P~%" (-> this flop0-offset))
  (format #t "~1Tflop1-offset: ~`vector`P~%" (-> this flop1-offset))
  (format #t "~1Tstuck-time: (seconds ~e)~%" (-> this stuck-time))
  (format #t "~1Tstuck-timeout: (seconds ~e)~%" (-> this stuck-timeout))
  (format #t "~1Tstuck-distance: (meters ~m)~%" (-> this stuck-distance))
  (format #t "~1Ttongue-pull-speed-min: ~f~%" (-> this tongue-pull-speed-min))
  (format #t "~1Ttongue-pull-speed-max: ~f~%" (-> this tongue-pull-speed-max))
  (format #t "~1Tyellow-attack-timeout: ~D~%" (-> this yellow-attack-timeout))
  (format #t "~1Tfall-height: (meters ~m)~%" (-> this fall-height))
  (format #t "~1Tmech-jump-thrust-fuel: ~f~%" (-> this mech-jump-thrust-fuel))
  (format #t "~1Tstrafe-jump-pre-window: ~D~%" (-> this strafe-jump-pre-window))
  (format #t "~1Tstrafe-jump: ~A~%" (-> this strafe-jump))
  (format #t "~1Tstrafe-duck-jump: ~A~%" (-> this strafe-duck-jump))
  (format #t "~1Tdark-jump-height-min: (meters ~m)~%" (-> this dark-jump-height-min))
  (format #t "~1Tdark-jump-height-max: (meters ~m)~%" (-> this dark-jump-height-max))
  (format #t "~1Tladder-walk-up-speed: (meters ~m)~%" (-> this ladder-walk-up-speed))
  (format #t "~1Tladder-walk-down-speed: (meters ~m)~%" (-> this ladder-walk-down-speed))
  (format #t "~1Tladder-slide-speed: (meters ~m)~%" (-> this ladder-slide-speed))
  (format #t "~1Tinvisible-duration: ~D~%" (-> this invisible-duration))
  (format #t "~1Tmech-walk-carry-cycle-dist: (meters ~m)~%" (-> this mech-walk-carry-cycle-dist))
  (label cfg-4)
  this
  )

;; definition for symbol *TARGET-bank*, type target-bank
(define *TARGET-bank* (new 'static 'target-bank
                        :jump-collide-offset (meters 0.7)
                        :jump-height-min (meters 1.01)
                        :jump-height-max (meters 3.5)
                        :double-jump-height-min (meters 1)
                        :double-jump-height-max (meters 2.5)
                        :flip-jump-height-min (meters 5)
                        :flip-jump-height-max (meters 7)
                        :duck-jump-height-min (meters 7)
                        :duck-jump-height-max (meters 7)
                        :flop-jump-height-min (meters 5)
                        :flop-jump-height-max (meters 7)
                        :attack-jump-height-min (meters 5)
                        :attack-jump-height-max (meters 6.5)
                        :edge-grab-jump-height-min (meters 1.7)
                        :edge-grab-jump-height-max (meters 1.7)
                        :swim-jump-height-min (meters 5)
                        :swim-jump-height-max (meters 5)
                        :tube-jump-height-min (meters 1.75)
                        :tube-jump-height-max (meters 2.5)
                        :carry-jump-height-min (meters 1.75)
                        :carry-jump-height-max (meters 2)
                        :mech-jump-height-min (meters 1.5)
                        :mech-jump-height-max (meters 1.5)
                        :mech-carry-jump-height-min (meters 5)
                        :mech-carry-jump-height-max (meters 3)
                        :indax-jump-height-min (meters 1.01)
                        :indax-jump-height-max (meters 3.5)
                        :indax-double-jump-height-min (meters 1)
                        :indax-double-jump-height-max (meters 2.5)
                        :roll-duration (seconds 0.5)
                        :roll-jump-pre-window (seconds 1)
                        :roll-jump-post-window (seconds 0.1)
                        :roll-speed-min (meters 11.5)
                        :roll-speed-inc (meters 1.5)
                        :roll-flip-duration (seconds 0.7)
                        :roll-flip-height (meters 3.52)
                        :roll-flip-dist (meters 17.3)
                        :roll-flip-art-height (meters 3.2969)
                        :roll-flip-art-dist (meters 12.5)
                        :duck-slide-distance (meters 5.75)
                        :fall-far (meters 30)
                        :fall-far-inc (meters 20)
                        :attack-timeout (seconds 0.3)
                        :ground-timeout (seconds 0.2)
                        :slide-down-timeout (seconds 0.2)
                        :fall-timeout (seconds 1)
                        :fall-stumble-threshold (meters 39.9)
                        :yellow-projectile-speed (meters 60)
                        :hit-invulnerable-timeout (seconds 1)
                        :same-attack-invulnerable-timeout (seconds 2)
                        :run-cycle-length 60.0
                        :walk-cycle-dist (meters 2.8)
                        :walk-up-cycle-dist (meters 2.8)
                        :walk-down-cycle-dist (meters 2.8)
                        :walk-side-cycle-dist (meters 2.8)
                        :run-cycle-dist (meters 6.25)
                        :run-up-cycle-dist (meters 5)
                        :run-down-cycle-dist (meters 5)
                        :run-side-cycle-dist (meters 6.25)
                        :run-wall-cycle-dist (meters 2.8)
                        :duck-walk-cycle-dist (meters 3.25)
                        :wade-shallow-walk-cycle-dist (meters 6)
                        :wade-deep-walk-cycle-dist (meters 6)
                        :mech-walk-cycle-dist (meters 4)
                        :mech-run-cycle-dist (meters 8)
                        :smack-surface-dist (meters 1.25)
                        :min-dive-depth (meters 2)
                        :root-radius (meters 2.2)
                        :root-offset (new 'static 'vector :y 4915.2 :w 1.0)
                        :body-radius (meters 0.7)
                        :edge-radius (meters 0.35)
                        :edge-offset (new 'static 'vector :y 4915.2 :z 4096.0 :w 1.0)
                        :edge-grab-height-off-ground (meters 2.3)
                        :head-radius (meters 0.7)
                        :head-height (meters 1.4)
                        :head-offset (new 'static 'vector :y 4915.2 :w 1.0)
                        :spin-radius (meters 2.2)
                        :spin-offset (new 'static 'vector :y 6553.6 :w 1.0)
                        :duck-spin-radius (meters 1.2)
                        :duck-spin-offset (new 'static 'vector :y 4096.0 :w 1.0)
                        :punch-radius (meters 1.3)
                        :punch-offset (new 'static 'vector :y 5324.8 :w 1.0)
                        :uppercut-radius (meters 1)
                        :uppercut0-offset (new 'static 'vector :y 3276.8 :w 1.0)
                        :uppercut1-offset (new 'static 'vector :y 9011.2 :w 1.0)
                        :flop-radius (meters 1.4)
                        :flop0-offset (new 'static 'vector :y 3276.8 :w 1.0)
                        :flop1-offset (new 'static 'vector :y 9011.2 :w 1.0)
                        :stuck-time (seconds 0.3)
                        :stuck-timeout (seconds 2)
                        :stuck-distance (meters 0.05)
                        :tongue-pull-speed-min 0.15
                        :tongue-pull-speed-max 0.22
                        :yellow-attack-timeout (seconds 0.2)
                        :fall-height (meters 1)
                        :mech-jump-thrust-fuel 900.0
                        :strafe-jump-pre-window (seconds 0.5)
                        :strafe-jump #f
                        :strafe-duck-jump #f
                        :dark-jump-height-min (meters 20.5)
                        :dark-jump-height-max (meters 20.5)
                        :ladder-walk-up-speed (meters 2.5)
                        :ladder-walk-down-speed (meters 3)
                        :ladder-slide-speed (meters 20)
                        :invisible-duration (seconds 30)
                        :mech-walk-carry-cycle-dist (meters 8)
                        )
        )

;; definition for function target-start-attack
;; WARN: Return type mismatch int vs none.
(defbehavior target-start-attack target ()
  (let* ((v1-0 *game-info*)
         (a0-1 (+ (-> v1-0 attack-id) 1))
         )
    (set! (-> v1-0 attack-id) a0-1)
    (set! (-> self control target-attack-id) a0-1)
    )
  (set! (-> self control attack-count) (the-as uint 0))
  (set! (-> self control bomb-scale) 0.0)
  (+! (-> self anim-seed) 1)
  0
  (none)
  )

;; definition for function target-danger-set!
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defbehavior target-danger-set! target ((arg0 symbol) (arg1 symbol))
  (let* ((s4-0 (-> self control collision-spheres 6))
         (s5-0 (-> self control collision-spheres 7))
         (gp-0 (-> self control collision-spheres 8))
         (s2-0 (-> self control collision-spheres 9))
         (v1-4 arg1)
         (f30-0 (if (or (= v1-4 'cone) (= v1-4 'eco-red))
                    2.0
                    1.0
                    )
                )
         )
    (set! (-> self control penetrate-using) (penetrate touch))
    (set! (-> self control penetrated-by) (penetrate lunge))
    (sphere<-vector+r!
      (the-as sphere (-> self control root-prim local-sphere))
      (-> *TARGET-bank* root-offset)
      (-> *TARGET-bank* root-radius)
      )
    (set! (-> self control danger-mode) arg0)
    (logclear! (-> self focus-status) (focus-status dangerous))
    (set! (-> s4-0 transform-index) -2)
    (set! (-> s4-0 prim-core collide-as) (collide-spec))
    (set! (-> s4-0 prim-core collide-with) (collide-spec))
    (set! (-> s4-0 local-sphere w) 0.0)
    (set! (-> s5-0 transform-index) -2)
    (set! (-> s5-0 prim-core collide-as) (collide-spec))
    (set! (-> s5-0 prim-core collide-with) (collide-spec))
    (set! (-> s5-0 local-sphere w) 0.0)
    (set! (-> gp-0 transform-index) -2)
    (set! (-> gp-0 prim-core collide-as) (collide-spec))
    (set! (-> gp-0 prim-core collide-with) (collide-spec))
    (set! (-> gp-0 local-sphere w) 0.0)
    (set! (-> s2-0 transform-index) -2)
    (set! (-> s2-0 prim-core collide-as) (collide-spec))
    (set! (-> s2-0 prim-core collide-with) (collide-spec))
    (set! (-> s2-0 local-sphere w) 0.0)
    (case arg0
      (('harmless #f)
       (set! (-> self control danger-mode) #f)
       (target-collide-set! (-> self control collide-mode) (-> self control collide-mode-transition))
       )
      (('carry?)
       (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r!
         (the-as sphere (-> s4-0 local-sphere))
         (-> *TARGET-bank* spin-offset)
         (+ 8192.0 (-> *TARGET-bank* spin-radius))
         )
       (set! (-> self control root-prim local-sphere quad) (-> s4-0 local-sphere quad))
       )
      (('spin 'spin-air 'get-on)
       (sphere<-vector+r!
         (the-as sphere (-> self control root-prim local-sphere))
         (new 'static 'vector :y 6553.6 :w 1.0)
         9830.4
         )
       (logior! (-> self focus-status) (focus-status dangerous))
       (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r!
         (the-as sphere (-> s4-0 local-sphere))
         (-> *TARGET-bank* spin-offset)
         (-> *TARGET-bank* spin-radius)
         )
       (set! (-> self control penetrate-using) (penetrate touch spin))
       )
      (('board-spin)
       (sphere<-vector+r!
         (the-as sphere (-> self control root-prim local-sphere))
         (new 'static 'vector :y 6553.6 :w 1.0)
         9830.4
         )
       (logior! (-> self focus-status) (focus-status dangerous))
       (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r! (the-as sphere (-> s4-0 local-sphere)) (-> *TARGET-bank* spin-offset) 6963.2)
       (set! (-> self control penetrate-using) (penetrate touch spin board))
       )
      (('board-zap)
       (sphere<-vector+r!
         (the-as sphere (-> self control root-prim local-sphere))
         (new 'static 'vector :y 6553.6 :w 1.0)
         13107.2
         )
       (logior! (-> self focus-status) (focus-status dangerous))
       (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r! (the-as sphere (-> s4-0 local-sphere)) (-> *TARGET-bank* spin-offset) 12288.0)
       (set! (-> self control penetrate-using) (penetrate touch spin board))
       )
      (('duck-spin)
       (sphere<-vector+r!
         (the-as sphere (-> self control root-prim local-sphere))
         (new 'static 'vector :y 6553.6 :w 1.0)
         10649.6
         )
       (logior! (-> self focus-status) (focus-status dangerous))
       (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r!
         (the-as sphere (-> s4-0 local-sphere))
         (-> *TARGET-bank* duck-spin-offset)
         (-> *TARGET-bank* duck-spin-radius)
         )
       (set! (-> s5-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> s5-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r! (the-as sphere (-> s5-0 local-sphere)) *null-vector* (-> *TARGET-bank* duck-spin-radius))
       (set! (-> s5-0 transform-index) 46)
       (set! (-> self control penetrate-using) (penetrate touch spin))
       )
      (('duck-slide)
       (logior! (-> self focus-status) (focus-status dangerous))
       (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r!
         (the-as sphere (-> s4-0 local-sphere))
         (-> *TARGET-bank* duck-spin-offset)
         (-> *TARGET-bank* duck-spin-radius)
         )
       (set! (-> s5-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> s5-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r! (the-as sphere (-> s5-0 local-sphere)) *null-vector* (-> *TARGET-bank* duck-spin-radius))
       (set! (-> s5-0 transform-index) 40)
       (set! (-> self control penetrate-using) (penetrate touch punch))
       )
      (('roll-solid)
       (logior! (-> self focus-status) (focus-status dangerous))
       (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r!
         (the-as sphere (-> s4-0 local-sphere))
         (-> *TARGET-bank* duck-spin-offset)
         (+ 819.2 (-> *TARGET-bank* duck-spin-radius))
         )
       (set! (-> s5-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> s5-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r! (the-as sphere (-> s5-0 local-sphere)) *null-vector* (-> *TARGET-bank* duck-spin-radius))
       (set! (-> s5-0 transform-index) 8)
       (set! (-> self control danger-mode) 'roll)
       (set! (-> self control penetrate-using) (penetrate touch roll))
       )
      (('flip)
       (logior! (-> self focus-status) (focus-status dangerous))
       (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r!
         (the-as sphere (-> s4-0 local-sphere))
         (-> *TARGET-bank* duck-spin-offset)
         (+ 819.2 (-> *TARGET-bank* duck-spin-radius))
         )
       (set! (-> s5-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> s5-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r! (the-as sphere (-> s5-0 local-sphere)) *null-vector* (-> *TARGET-bank* duck-spin-radius))
       (set! (-> s5-0 transform-index) 8)
       (set! (-> self control danger-mode) 'flip)
       (set! (-> self control penetrate-using) (penetrate touch roll))
       )
      (('punch 'dark-smack)
       (sphere<-vector+r!
         (the-as sphere (-> self control root-prim local-sphere))
         (new 'static 'vector :y 6553.6 :w 1.0)
         11878.4
         )
       (logior! (-> self focus-status) (focus-status dangerous))
       (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r!
         (the-as sphere (-> s4-0 local-sphere))
         (-> *TARGET-bank* punch-offset)
         (-> *TARGET-bank* punch-radius)
         )
       (when (not (focus-test? self indax))
         (set! (-> s5-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s5-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r! (the-as sphere (-> s5-0 local-sphere)) *null-vector* (-> *TARGET-bank* punch-radius))
         (set! (-> s5-0 transform-index) 27)
         )
       (set! (-> self control penetrate-using) (penetrate touch punch))
       (if (and (focus-test? self dark)
                (nonzero? (-> self darkjak))
                (logtest? (-> self darkjak stage) (darkjak-stage bomb0))
                )
           (logior! (-> self control penetrate-using) (penetrate dark-punch))
           )
       (if (= arg0 'dark-smack)
           (logior! (-> self control penetrate-using) (penetrate dark-smack))
           )
       )
      (('uppercut)
       (sphere<-vector+r!
         (the-as sphere (-> self control root-prim local-sphere))
         (new 'static 'vector :y 6553.6 :w 1.0)
         11878.4
         )
       (logior! (-> self focus-status) (focus-status dangerous))
       (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r!
         (the-as sphere (-> s4-0 local-sphere))
         (-> *TARGET-bank* uppercut0-offset)
         (-> *TARGET-bank* uppercut-radius)
         )
       (set! (-> s5-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> s5-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r! (the-as sphere (-> s5-0 local-sphere)) *null-vector* (-> *TARGET-bank* uppercut-radius))
       (set! (-> s5-0 transform-index) 27)
       (set! (-> gp-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> gp-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r!
         (the-as sphere (-> gp-0 local-sphere))
         (-> *TARGET-bank* uppercut1-offset)
         (-> *TARGET-bank* uppercut-radius)
         )
       (set! (-> self control penetrate-using) (penetrate touch uppercut))
       )
      (('flop)
       (logior! (-> self focus-status) (focus-status dangerous))
       (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r!
         (the-as sphere (-> s4-0 local-sphere))
         (-> *TARGET-bank* flop0-offset)
         (-> *TARGET-bank* flop-radius)
         )
       (set! f30-0 1.0)
       (set! (-> self control danger-mode) 'flop)
       (set! (-> self control penetrate-using) (penetrate touch flop))
       )
      (('flop-down)
       (logior! (-> self focus-status) (focus-status dangerous))
       (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r!
         (the-as sphere (-> s4-0 local-sphere))
         (-> *TARGET-bank* flop0-offset)
         (-> *TARGET-bank* flop-radius)
         )
       (set! (-> s5-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> s5-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r!
         (the-as sphere (-> s5-0 local-sphere))
         (-> *TARGET-bank* flop1-offset)
         (-> *TARGET-bank* flop-radius)
         )
       (if (!= f30-0 1.0)
           (set! f30-0 2.1)
           )
       (set! (-> self control danger-mode) 'flop)
       (set! (-> self control penetrate-using) (penetrate touch flop))
       )
      (('flut-attack)
       (sphere<-vector+r!
         (the-as sphere (-> self control root-prim local-sphere))
         (new 'static 'vector :y 6553.6 :w 1.0)
         12288.0
         )
       (logior! (-> self focus-status) (focus-status dangerous))
       (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r!
         (the-as sphere (-> s4-0 local-sphere))
         (-> *TARGET-bank* spin-offset)
         (+ 2048.0 (-> *TARGET-bank* punch-radius))
         )
       (set! (-> s5-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
       (set! (-> s5-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
       (sphere<-vector+r!
         (the-as sphere (-> s5-0 local-sphere))
         *null-vector*
         (+ 1228.8 (-> *TARGET-bank* punch-radius))
         )
       (set! (-> s5-0 transform-index) 8)
       (set! (-> self control penetrate-using) (penetrate touch flut-attack))
       )
      (('mech-punch)
       (logior! (-> self focus-status) (focus-status dangerous))
       (set! (-> self control penetrate-using) (penetrate touch mech))
       )
      (('bomb)
       (let* ((f0-32 (-> self control bomb-scale))
              (f28-0 (lerp-scale (-> *TARGET-bank* root-radius) 122880.0 f0-32 0.0 1.0))
              )
         (sphere<-vector+r!
           (the-as sphere (-> self control root-prim local-sphere))
           (-> *TARGET-bank* root-offset)
           f28-0
           )
         (logior! (-> self focus-status) (focus-status dangerous))
         (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s4-0 prim-core collide-with)
               (logclear (-> self control default-collide-with-fgnd) (collide-spec collectable))
               )
         (sphere<-vector+r! (the-as sphere (-> s4-0 local-sphere)) (-> *TARGET-bank* root-offset) f28-0)
         )
       (set! (-> self control penetrate-using) (penetrate touch dark-bomb))
       )
      (else
        (format 0 "ERROR: ~A unknown danger mode ~A" self arg0)
        )
      )
    (when (= arg1 'cone)
      (let ((f28-1 16384.0))
        (sphere<-vector+r!
          (the-as sphere (-> self control root-prim local-sphere))
          (-> *TARGET-bank* root-offset)
          (+ (-> *TARGET-bank* root-radius) (* 2.0 f28-1))
          )
        (logior! (-> self focus-status) (focus-status dangerous))
        (set! (-> s2-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
        (set! (-> s2-0 prim-core collide-with)
              (logclear (-> self control default-collide-with-fgnd) (collide-spec collectable))
              )
        (set! (-> s2-0 transform-index) 0)
        (sphere<-vector+r!
          (the-as sphere (-> s2-0 local-sphere))
          (new 'static 'vector :y 12288.0 :z 16384.0 :w 1.0)
          f28-1
          )
        )
      (set! (-> self control penetrate-using) (penetrate touch dark-bomb))
      )
    (when (and (!= f30-0 1.0) (not (or (= arg0 'harmless) (= arg0 #f))))
      (set! (-> self control root-prim local-sphere w) (* (-> self control root-prim local-sphere w) f30-0))
      (set! (-> s4-0 local-sphere w) (* (-> s4-0 local-sphere w) f30-0))
      (set! (-> s5-0 local-sphere w) (* (-> s5-0 local-sphere w) f30-0))
      (set! (-> gp-0 local-sphere w) (* (-> gp-0 local-sphere w) f30-0))
      )
    )
  (case (-> self fact eco-type)
    ((1)
     (logior! (-> self control penetrate-using) (penetrate eco-yellow))
     )
    ((2)
     (logior! (-> self control penetrate-using) (penetrate eco-red))
     )
    ((3)
     (set! (-> self control penetrate-using)
           (the-as penetrate (logior (penetrate eco-blue) (-> self control penetrate-using)))
           )
     )
    ((5)
     (set! (-> self control penetrate-using)
           (the-as penetrate (logior (penetrate eco-green) (-> self control penetrate-using)))
           )
     )
    )
  (none)
  )

;; definition for function target-collide-set!
(defbehavior target-collide-set! target ((arg0 symbol) (arg1 float))
  (let ((gp-0 (-> self control)))
    (if (and (= arg0 'normal)
             (enabled-gun? self)
             (not (logtest? (-> self control current-surface flags) (surface-flag duck)))
             )
        (set! arg0 'gun)
        )
    (set! (-> self control collide-mode) arg0)
    (set! (-> self control collide-mode-transition) arg1)
    (logclear! (-> self control penetrate-using) (penetrate tube vehicle board mech))
    (set! (-> self control penetrated-by) (penetrate lunge))
    (dotimes (v1-10 4)
      (set! (-> gp-0 collision-spheres v1-10 transform-index) -2)
      )
    (set! (-> gp-0 collision-spheres 3 prim-core collide-as) (collide-spec))
    (set! (-> gp-0 collision-spheres 3 prim-core collide-with) (collide-spec))
    (set! (-> gp-0 collision-spheres 4 prim-core collide-as) (collide-spec jak))
    (set! (-> gp-0 collision-spheres 4 prim-core collide-with) (collide-spec
                                                                 backgnd
                                                                 bot
                                                                 crate
                                                                 civilian
                                                                 enemy
                                                                 obstacle
                                                                 hit-by-player-list
                                                                 hit-by-others-list
                                                                 player-list
                                                                 water
                                                                 collectable
                                                                 blocking-plane
                                                                 tobot
                                                                 pusher
                                                                 vehicle-mesh
                                                                 obstacle-for-jak
                                                                 shield
                                                                 vehicle-mesh-no-block-use
                                                                 )
          )
    (cond
      ((= arg0 'pole)
       (set-vector! (-> gp-0 collision-spheres 0 local-sphere) 0.0 0.0 0.0 (-> *TARGET-bank* body-radius))
       (set-vector! (-> gp-0 collision-spheres 1 local-sphere) 0.0 0.0 0.0 (-> *TARGET-bank* body-radius))
       (set-vector! (-> gp-0 collision-spheres 2 local-sphere) 0.0 0.0 0.0 (-> *TARGET-bank* body-radius))
       (set! (-> gp-0 collision-spheres 0 transform-index) 40)
       (set! (-> gp-0 collision-spheres 1 transform-index) 38)
       (set! (-> gp-0 collision-spheres 2 transform-index) 8)
       )
      ((= arg0 'board)
       (logior! (-> self control penetrate-using) (penetrate touch board))
       )
      ((= arg0 'racer)
       (set! (-> gp-0 draw-offset y) 4096.0)
       (sphere<-vector+r!
         (the-as sphere (-> gp-0 root-prim local-sphere))
         (new 'static 'vector :y 8192.0 :w 1.0)
         16384.0
         )
       (set-vector! (-> gp-0 collision-spheres 0 local-sphere) 0.0 6553.6 0.0 6553.6)
       (set-vector! (-> gp-0 collision-spheres 1 local-sphere) 0.0 9420.8 0.0 6553.6)
       (set-vector! (-> gp-0 collision-spheres 2 local-sphere) 0.0 12288.0 0.0 6553.6)
       (logior! (-> self control penetrate-using) (penetrate touch vehicle))
       )
      ((= arg0 'flut)
       (sphere<-vector+r!
         (the-as sphere (-> gp-0 root-prim local-sphere))
         (new 'static 'vector :y 8192.0 :w 1.0)
         12288.0
         )
       (set-vector! (-> gp-0 collision-spheres 0 local-sphere) 0.0 4915.2 0.0 4915.2)
       (set-vector! (-> gp-0 collision-spheres 1 local-sphere) 0.0 7782.4004 0.0 4915.2)
       (set-vector! (-> gp-0 collision-spheres 2 local-sphere) 0.0 10649.6 0.0 4915.2)
       (if (= (-> self flut mode) 'racer)
           (logior! (-> self control penetrate-using) (penetrate flut))
           )
       )
      ((= arg0 'mech)
       (sphere<-vector+r!
         (the-as sphere (-> gp-0 root-prim local-sphere))
         (new 'static 'vector :y 8192.0 :w 1.0)
         16384.0
         )
       (set-vector! (-> gp-0 collision-spheres 0 local-sphere) 0.0 4096.0 0.0 4096.0)
       (set-vector! (-> gp-0 collision-spheres 1 local-sphere) 0.0 8601.6 0.0 6553.6)
       (set-vector! (-> gp-0 collision-spheres 2 local-sphere) 0.0 14745.6 0.0 6963.2)
       (logior! (-> self control penetrate-using) (penetrate touch mech))
       )
      ((= arg0 'mech-carry)
       (set! (-> gp-0 draw-offset y) 0.0)
       (sphere<-vector+r!
         (the-as sphere (-> gp-0 root-prim local-sphere))
         (new 'static 'vector :y 12288.0 :w 1.0)
         20480.0
         )
       (set-vector! (-> gp-0 collision-spheres 0 local-sphere) 0.0 4096.0 0.0 4096.0)
       (set-vector! (-> gp-0 collision-spheres 1 local-sphere) 0.0 8601.6 0.0 6553.6)
       (set-vector!
         (-> gp-0 collision-spheres 2 local-sphere)
         0.0
         (+ 5734.4 (lerp-scale 9011.2 12288.0 arg1 0.0 1.0))
         0.0
         (lerp-scale 9420.8 12697.6 arg1 0.0 1.0)
         )
       )
      ((= arg0 'duck)
       (set! (-> self control duck-gun-tube-transision) arg1)
       (let ((f30-1 (- 1.0 arg1)))
         (set! (-> gp-0 draw-offset y) 0.0)
         (sphere<-vector+r!
           (the-as sphere (-> gp-0 root-prim local-sphere))
           (-> *TARGET-bank* root-offset)
           (-> *TARGET-bank* root-radius)
           )
         (set-vector!
           (-> gp-0 collision-spheres 0 local-sphere)
           0.0
           (-> *TARGET-bank* body-radius)
           (* 0.0 f30-1)
           (-> *TARGET-bank* body-radius)
           )
         (if (using-gun? self)
             (set-vector!
               (-> gp-0 collision-spheres 1 local-sphere)
               0.0
               (+ 2867.2 (-> *TARGET-bank* body-radius))
               0.0
               (-> *TARGET-bank* body-radius)
               )
             (set-vector!
               (-> gp-0 collision-spheres 1 local-sphere)
               0.0
               (+ (-> *TARGET-bank* body-radius) (* 2867.2 f30-1))
               0.0
               (-> *TARGET-bank* body-radius)
               )
             )
         (set-vector!
           (-> gp-0 collision-spheres 2 local-sphere)
           0.0
           (+ (-> *TARGET-bank* body-radius) (* 5734.4 f30-1))
           0.0
           (-> *TARGET-bank* body-radius)
           )
         )
       )
      ((= arg0 'indax)
       (let ((f30-2 0.2))
         (set! (-> gp-0 draw-offset y) 0.0)
         (sphere<-vector+r!
           (the-as sphere (-> gp-0 root-prim local-sphere))
           (-> *TARGET-bank* root-offset)
           (-> *TARGET-bank* root-radius)
           )
         (set-vector!
           (-> gp-0 collision-spheres 0 local-sphere)
           0.0
           (-> *TARGET-bank* body-radius)
           (* 0.0 f30-2)
           (-> *TARGET-bank* body-radius)
           )
         (set-vector!
           (-> gp-0 collision-spheres 1 local-sphere)
           0.0
           (+ (-> *TARGET-bank* body-radius) (* 2867.2 f30-2))
           0.0
           (-> *TARGET-bank* body-radius)
           )
         (set-vector!
           (-> gp-0 collision-spheres 2 local-sphere)
           0.0
           (+ (-> *TARGET-bank* body-radius) (* 5734.4 f30-2))
           0.0
           (-> *TARGET-bank* body-radius)
           )
         )
       (set! (-> gp-0 collision-spheres 4 prim-core collide-as) (collide-spec))
       (set! (-> gp-0 collision-spheres 4 prim-core collide-with) (collide-spec))
       0
       )
      ((= arg0 'tube)
       (set! (-> self control duck-gun-tube-transision) arg1)
       (let ((f30-3 (- 1.0 arg1)))
         (set! (-> gp-0 draw-offset y) 0.0)
         (sphere<-vector+r!
           (the-as sphere (-> gp-0 root-prim local-sphere))
           (-> *TARGET-bank* root-offset)
           (-> *TARGET-bank* root-radius)
           )
         (set-vector!
           (-> gp-0 collision-spheres 0 local-sphere)
           0.0
           (-> *TARGET-bank* body-radius)
           (* 0.0 f30-3)
           (-> *TARGET-bank* body-radius)
           )
         (set-vector!
           (-> gp-0 collision-spheres 1 local-sphere)
           0.0
           (+ (-> *TARGET-bank* body-radius) (* 2867.2 f30-3))
           0.0
           (-> *TARGET-bank* body-radius)
           )
         (set-vector!
           (-> gp-0 collision-spheres 2 local-sphere)
           0.0
           (+ (-> *TARGET-bank* body-radius) (* 5734.4 f30-3))
           0.0
           (-> *TARGET-bank* body-radius)
           )
         )
       (logior! (-> self control penetrate-using) (penetrate touch tube))
       )
      ((= arg0 'carry)
       (set! (-> gp-0 draw-offset y) 0.0)
       (sphere<-vector+r!
         (the-as sphere (-> gp-0 root-prim local-sphere))
         (-> *TARGET-bank* root-offset)
         (-> *TARGET-bank* root-radius)
         )
       (set-vector!
         (-> gp-0 collision-spheres 0 local-sphere)
         0.0
         (-> *TARGET-bank* body-radius)
         0.0
         (-> *TARGET-bank* body-radius)
         )
       (set-vector!
         (-> gp-0 collision-spheres 1 local-sphere)
         0.0
         (+ 2867.2 (-> *TARGET-bank* body-radius))
         0.0
         (-> *TARGET-bank* body-radius)
         )
       (set-vector!
         (-> gp-0 collision-spheres 2 local-sphere)
         0.0
         (+ 5734.4 (-> *TARGET-bank* body-radius))
         0.0
         (lerp-scale (-> *TARGET-bank* body-radius) 7372.8 arg1 0.0 1.0)
         )
       )
      ((= arg0 'gun)
       (set! (-> self control duck-gun-tube-transision) arg1)
       (set! (-> gp-0 draw-offset y) 0.0)
       (sphere<-vector+r!
         (the-as sphere (-> gp-0 root-prim local-sphere))
         (-> *TARGET-bank* root-offset)
         (-> *TARGET-bank* root-radius)
         )
       (set-vector!
         (-> gp-0 collision-spheres 0 local-sphere)
         0.0
         (-> *TARGET-bank* body-radius)
         0.0
         (-> *TARGET-bank* body-radius)
         )
       (set-vector!
         (-> gp-0 collision-spheres 1 local-sphere)
         0.0
         (+ 2867.2 (-> *TARGET-bank* body-radius))
         0.0
         (-> *TARGET-bank* body-radius)
         )
       (set-vector!
         (-> gp-0 collision-spheres 2 local-sphere)
         0.0
         (+ 5734.4 (-> *TARGET-bank* body-radius))
         0.0
         (-> *TARGET-bank* body-radius)
         )
       (set-vector!
         (-> gp-0 collision-spheres 3 local-sphere)
         0.0
         (+ 5734.4 (-> *TARGET-bank* body-radius))
         0.0
         (lerp-scale (-> *TARGET-bank* body-radius) 4915.2 arg1 0.0 1.0)
         )
       (set! (-> gp-0 collision-spheres 3 prim-core collide-with) (collide-spec
                                                                    backgnd
                                                                    bot
                                                                    crate
                                                                    obstacle
                                                                    hit-by-player-list
                                                                    hit-by-others-list
                                                                    player-list
                                                                    water
                                                                    collectable
                                                                    blocking-plane
                                                                    tobot
                                                                    pusher
                                                                    vehicle-mesh
                                                                    obstacle-for-jak
                                                                    shield
                                                                    vehicle-mesh-no-block-use
                                                                    )
             )
       )
      (else
        (set! (-> self control duck-gun-tube-transision) 0.0)
        (set! (-> gp-0 draw-offset y) 0.0)
        (sphere<-vector+r!
          (the-as sphere (-> gp-0 root-prim local-sphere))
          (-> *TARGET-bank* root-offset)
          (-> *TARGET-bank* root-radius)
          )
        (set-vector!
          (-> gp-0 collision-spheres 0 local-sphere)
          0.0
          (-> *TARGET-bank* body-radius)
          0.0
          (-> *TARGET-bank* body-radius)
          )
        (set-vector!
          (-> gp-0 collision-spheres 1 local-sphere)
          0.0
          (+ 2867.2 (-> *TARGET-bank* body-radius))
          0.0
          (-> *TARGET-bank* body-radius)
          )
        (set-vector!
          (-> gp-0 collision-spheres 2 local-sphere)
          0.0
          (+ 5734.4 (-> *TARGET-bank* body-radius))
          0.0
          (-> *TARGET-bank* body-radius)
          )
        )
      )
    (set! (-> gp-0 nav-radius) (-> gp-0 collision-spheres 2 local-sphere w))
    )
  0
  )

;; definition for method 27 of type control-info
(defmethod get-quaternion ((this control-info))
  "Get the quat for this [[trsqv]]."
  (-> this quat-for-control)
  )

;; definition for function target-skel-group
;; WARN: Return type mismatch art-group vs skeleton-group.
(defun target-skel-group ()
  (the-as skeleton-group (cond
                           (*target*
                             (case (-> *target* ext-geo)
                               (((target-geo jakb))
                                (art-group-get-by-name *level* "skel-jchar-normal" (the-as (pointer level) #f))
                                )
                               (((target-geo jakb-old))
                                (art-group-get-by-name *level* "skel-jchar-old" (the-as (pointer level) #f))
                                )
                               (((target-geo jakc))
                                (art-group-get-by-name *level* "skel-jchar-c" (the-as (pointer level) #f))
                                )
                               (else
                                 (art-group-get-by-name *level* "skel-jchar" (the-as (pointer level) #f))
                                 )
                               )
                             )
                           (else
                             (art-group-get-by-name *level* "skel-jchar" (the-as (pointer level) #f))
                             )
                           )
          )
  )

;; definition for function debounce-speed
(defbehavior debounce-speed target ((arg0 float) (arg1 float) (arg2 vector) (arg3 vector))
  (if (and (< 0.3 arg0) (< arg0 0.7) (< 0.0 arg1) (< (vector-dot arg2 arg3) 0.2))
      (set! arg0 0.0)
      )
  arg0
  )

;; definition for function target-align-vel-z-adjust
(defbehavior target-align-vel-z-adjust target ((arg0 float))
  (let ((f1-0 (-> self control local-slope-z)))
    (* arg0 (if (< 0.0 f1-0)
                (* (- 1.0 f1-0) (-> self control current-surface alignv))
                (-> self control current-surface alignv)
                )
       )
    )
  )

;; definition for method 27 of type target
(defmethod get-inv-mass ((this target))
  (if (focus-test? this mech)
      0.1
      1.0
      )
  )

;; definition for method 16 of type target
;; INFO: Used lq/sq
;; WARN: Return type mismatch control-info vs trsqv.
(defmethod apply-alignment ((this target) (arg0 align-opts) (arg1 transformq) (arg2 vector))
  (with-pp
    (let ((s2-0 (new 'stack-no-clear 'vector)))
      (set! (-> s2-0 quad) (-> arg2 quad))
      (set! (-> s2-0 z) (target-align-vel-z-adjust (-> s2-0 z)))
      (when (logtest? arg0 (align-opts adjust-x-vel adjust-y-vel adjust-xz-vel))
        (let* ((s3-0 (-> this control c-R-w))
               (s0-0 (-> this control w-R-c))
               (s1-0 (vector-matrix*! (new 'stack-no-clear 'vector) (-> this control dynam gravity) s0-0))
               (a1-3 (vector-matrix*! (new 'stack-no-clear 'vector) (-> this control transv) s0-0))
               )
          (if (logtest? arg0 (align-opts no-gravity))
              (set-vector! s1-0 0.0 0.0 0.0 1.0)
              )
          (when (logtest? arg0 (align-opts adjust-x-vel))
            (set! (-> a1-3 x)
                  (+ (* (-> arg1 trans x) (-> s2-0 x) (-> pp clock frames-per-second)) (* (-> s1-0 x) (seconds-per-frame)))
                  )
            (if (not (logtest? arg0 (align-opts adjust-xz-vel keep-other-velocities)))
                (set! (-> a1-3 z) 0.0)
                )
            )
          (if (and (logtest? arg0 (align-opts adjust-y-vel))
                   (not (and (logtest? arg0 (align-opts ignore-y-if-zero)) (= (-> arg1 trans y) 0.0)))
                   )
              (set! (-> a1-3 y)
                    (+ (* (-> arg1 trans y) (-> s2-0 y) (-> pp clock frames-per-second)) (* (-> s1-0 y) (seconds-per-frame)))
                    )
              )
          (when (logtest? arg0 (align-opts adjust-xz-vel))
            (set! (-> a1-3 z)
                  (+ (* (-> arg1 trans z) (-> s2-0 z) (-> pp clock frames-per-second)) (* (-> s1-0 z) (seconds-per-frame)))
                  )
            (if (not (logtest? arg0 (align-opts adjust-x-vel keep-other-velocities)))
                (set! (-> a1-3 x) 0.0)
                )
            )
          (vector-matrix*! (-> this control transv) a1-3 s3-0)
          )
        )
      )
    (if (logtest? arg0 (align-opts adjust-quat))
        (quaternion-normalize!
          (quaternion*! (-> this control quat-for-control) (-> this control quat-for-control) (-> arg1 quat))
          )
        )
    (the-as trsqv (-> this control))
    )
  )

;; definition for function average-turn-angle
(defun average-turn-angle ((arg0 target))
  (let ((f30-0 0.0))
    (dotimes (s5-0 8)
      (+! f30-0
          (fabs
            (deg-diff (atan (-> arg0 control turn-history-ctrl s5-0 x) (-> arg0 control turn-history-ctrl s5-0 z)) 0.0)
            )
          )
      )
    (* 0.125 f30-0)
    )
  )

;; definition for function can-play-stance-amibent?
(defbehavior can-play-stance-amibent? target ()
  (and (or (and (kiosk?)
                (>= (+ -300000 (-> *display* real-clock frame-counter)) (seconds 60))
                (>= (- (-> *display* base-clock frame-counter) (-> self control cpad change-time)) (seconds 60))
                (>= (- (-> *display* game-clock frame-counter) (-> self game kiosk-timeout)) (seconds 60))
                )
           (and (time-elapsed? (-> self ambient-time) (seconds 30))
                (not (logtest? (-> self control status) (collide-status touch-actor)))
                (logtest? (-> self control status) (collide-status on-surface))
                (not (or (logtest? (water-flag touch-water) (-> self water flags))
                         (logtest? (-> self control status) (collide-status on-water))
                         )
                     )
                (not (logtest? (focus-status dead hit grabbed in-head edge-grab pole flut tube light board mech dark indax teleporting)
                               (-> self focus-status)
                               )
                     )
                )
           )
       (not (paused?))
       (not (movie?))
       (>= (- (-> *display* base-clock frame-counter) (-> self control cpad change-time)) (seconds 30))
       (!= (-> self tobot?) 'tobot)
       (not (-> *setting-control* user-current talking))
       (not (-> *setting-control* user-current spooling))
       (not (-> *setting-control* user-current movie))
       (not (-> *setting-control* user-current hint))
       (not (focus-test? self dead hit grabbed))
       (logtest? (game-feature sidekick) (-> self game features))
       (= (-> self ext-anim) (target-anim default))
       (case *kernel-boot-message*
         (('kiosk)
          (set! (-> self control cpad change-time) (-> *display* base-clock frame-counter))
          (initialize! *game-info* 'game (the-as game-save #f) (the-as string #f) (the-as resetter-spec #f))
          #f
          )
         (else
           #t
           )
         )
       )
  )

;; definition for function target-height-above-ground
(defbehavior target-height-above-ground target ()
  (- (-> self control trans y) (-> self control gspot-pos y))
  )

;; definition for function find-collision-below
;; INFO: Used lq/sq
(defun find-collision-below ((arg0 vector) (arg1 vector) (arg2 float))
  (let ((s5-0 (new 'stack-no-clear 'collide-query)))
    (set! (-> s5-0 start-pos quad) (-> arg1 quad))
    (set-vector! (-> s5-0 move-dist) 0.0 (- arg2) 0.0 1.0)
    (let ((v1-2 s5-0))
      (set! (-> v1-2 radius) 40.96)
      (set! (-> v1-2 collide-with) (collide-spec backgnd hit-by-others-list pusher))
      (set! (-> v1-2 ignore-process0) #f)
      (set! (-> v1-2 ignore-process1) #f)
      (set! (-> v1-2 ignore-pat)
            (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
            )
      (set! (-> v1-2 action-mask) (collide-action solid))
      )
    (when (>= (fill-and-probe-using-line-sphere *collide-cache* s5-0) 0.0)
      (set! (-> arg0 quad) (-> s5-0 best-other-tri intersect quad))
      #t
      )
    )
  )

;; definition for function can-jump?
(defbehavior can-jump? target ((mode symbol))
  (and (or (logtest? (-> self control status) (collide-status on-surface))
           (not (time-elapsed? (-> self control last-time-on-surface) (-> *TARGET-bank* ground-timeout)))
           (and (= mode 'board)
                (or (not (time-elapsed? (-> self board last-jump-time) (seconds 0.05)))
                    (and (not (time-elapsed? (-> self control last-time-of-stuck) (seconds 0.5)))
                         (< (target-height-above-ground) 2048.0)
                         )
                    )
                )
           (and (= mode 'flut)
                (not (time-elapsed? (-> self control last-time-on-surface) (seconds 0.5)))
                (< (target-height-above-ground) 6144.0)
                )
           )
       (and (not (logtest? (-> self control current-surface flags) (surface-flag no-jump)))
            (not (logtest? (-> self target-flags) (target-flags prevent-jump)))
            (or (= mode 'board) (!= (-> self control poly-pat event) 13))
            (if (= mode 'target-roll-flip)
                (>= 0.5 (-> self control local-slope-z))
                #t
                )
            )
       )
  )

;; definition for function target-jump-go
;; WARN: Return type mismatch object vs none.
(defbehavior target-jump-go target ()
  (go target-jump (-> *TARGET-bank* jump-height-min) (-> *TARGET-bank* jump-height-max) (the-as surface #f))
  (none)
  )

;; definition for function move-legs?
(defbehavior move-legs? target ()
  (!= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
  )

;; definition for function jump-hit-ground-stuck?
(defbehavior jump-hit-ground-stuck? target ()
  (or (logtest? (-> self control status) (collide-status on-surface))
      (when (and (< (target-move-dist (-> *TARGET-bank* stuck-time)) (-> *TARGET-bank* stuck-distance))
                 (not (and *cheat-mode* (cpad-hold? (-> self control cpad number) r2)))
                 )
        (set-time! (-> self control last-time-of-stuck))
        #t
        )
      )
  )

;; definition for function target-time-to-ground
;; WARN: Return type mismatch int vs time-frame.
(defbehavior target-time-to-ground target ()
  (let ((f0-0 (target-height-above-ground))
        (f2-0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
        (f1-1 0.0)
        )
    (while (< 0.0 f0-0)
      (set! f1-1 (+ 5.0 f1-1))
      (+! f0-0 (* f2-0 (seconds-per-frame)))
      (set! f2-0 (- f2-0 (* (-> self control dynam gravity-length) (seconds-per-frame))))
      )
    (the time-frame f1-1)
    )
  )

;; definition for function fall-test
;; WARN: Return type mismatch object vs none.
(defbehavior fall-test target ((arg0 (state symbol target)) (arg1 float))
  (when (and (not (logtest? (-> self control status) (collide-status on-surface)))
             (time-elapsed? (-> self control last-time-on-surface) (-> *TARGET-bank* ground-timeout))
             (>= 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
             (>= (target-height-above-ground) arg1)
             )
    (if (not (time-elapsed? (-> self control rider-time) (-> *TARGET-bank* ground-timeout)))
        (send-event self 'push-transv (-> self control rider-last-move) (seconds 100))
        )
    (go arg0 #f)
    )
  (none)
  )

;; definition for function slide-down-test
;; WARN: Return type mismatch object vs none.
(defbehavior slide-down-test target ()
  (if (and (not (logtest? (-> self control status) (collide-status on-surface touch-edge)))
           (time-elapsed? (-> self control last-time-on-surface) (-> *TARGET-bank* ground-timeout))
           (logtest? (-> self control status) (collide-status touch-surface))
           (< (cos (-> self control current-surface slope-slip-angle)) (-> self control surface-angle))
           )
      (go target-slide-down)
      )
  (none)
  )

;; definition for function smack-surface?
(defbehavior smack-surface? target ((arg0 symbol))
  (and (< 0.7 (-> self control touch-angle))
       (and (< (-> self control surface-angle) 0.3)
            (logtest? (-> self control status) (collide-status touch-wall))
            (or arg0 (not (logtest? (-> self control status) (collide-status touch-actor))))
            )
       )
  )

;; definition for function can-roll?
(defbehavior can-roll? target ()
  (and (or (not (time-elapsed? (-> self control last-time-on-surface) (seconds 0.1)))
           (logtest? (-> self control status) (collide-status on-surface))
           )
       (or (not (logtest? (-> self control status) (collide-status touch-wall)))
           (>= 0.7 (-> self control touch-angle))
           )
       (< (-> self control local-slope-z) 0.7)
       (and (not (logtest? (-> self target-flags) (target-flags prevent-attack prevent-duck)))
            (not (and (focus-test? self dark) (nonzero? (-> self darkjak))))
            (not (and (focus-test? self light) (nonzero? (-> self lightjak))))
            (time-elapsed? (-> *TARGET-bank* roll-timeout) (-> self control last-roll-end-time))
            (or (not (enabled-gun? self))
                (not (-> *TARGET-bank* strafe-duck-jump))
                (and (< 0.3 (vector-dot (-> self control to-target-pt-xz) (-> self control c-R-w fvec)))
                     (time-elapsed? (-> self control time-of-last-zero-input) (seconds 0.3))
                     )
                )
            (not (and (not (using-gun? self)) (!= (-> self skel top-anim interp) 0.0)))
            )
       )
  )

;; definition for function can-duck?
(defbehavior can-duck? target ()
  (and (logtest? (-> self control status) (collide-status on-surface))
       (>= (-> self control ground-local-norm-dot-grav) 0.7)
       (not (logtest? (water-flag under-water swimming) (-> self water flags)))
       (not (logtest? (-> self target-flags) (target-flags prevent-duck)))
       (or (not (logtest? (water-flag wading) (-> self water flags)))
           (< (- (- (-> self control trans y) (- (-> self water base-height) (-> self water wade-height)))) 2457.6)
           )
       (not (and (focus-test? self light) (nonzero? (-> self lightjak))))
       (let ((v1-23 (ja-group)))
         (and (not (and v1-23 (or (= v1-23 (-> self draw art-group data 476)) (= v1-23 (-> self draw art-group data 477)))))
              (or (= (-> self ext-anim) (target-anim default))
                  (and (= (-> self ext-anim) (target-anim dark)) (focus-test? self dark) (nonzero? (-> self darkjak)))
                  )
              )
         )
       )
  )

;; definition for function can-exit-duck?
;; INFO: Used lq/sq
(defun can-exit-duck? ((arg0 target))
  (let ((gp-0 (new 'stack-no-clear 'collide-query)))
    (let ((s4-0 (new 'stack-no-clear 'inline-array 'sphere 2)))
      (dotimes (s3-0 2)
        ((method-of-type sphere new) (the-as symbol (-> s4-0 s3-0)) sphere)
        )
      (set! (-> s4-0 0 quad) (-> arg0 control trans quad))
      (set! (-> s4-0 0 y) (+ 5734.4 (-> *TARGET-bank* body-radius) (-> s4-0 0 y)))
      (set! (-> s4-0 0 r) (-> *TARGET-bank* body-radius))
      (set! (-> s4-0 1 quad) (-> arg0 control trans quad))
      (set! (-> s4-0 1 y) (+ 2867.2 (-> *TARGET-bank* body-radius) (-> s4-0 1 y)))
      (set! (-> s4-0 1 r) (-> *TARGET-bank* body-radius))
      (let ((v1-12 gp-0))
        (set! (-> v1-12 spheres) s4-0)
        (set! (-> v1-12 best-other-prim) (the-as collide-shape-prim 2))
        (set! (-> v1-12 collide-with)
              (logclear
                (-> arg0 control root-prim prim-core collide-with)
                (collide-spec civilian enemy vehicle-sphere projectile)
                )
              )
        (set! (-> v1-12 ignore-process0) #f)
        (set! (-> v1-12 ignore-process1) #f)
        (set! (-> v1-12 ignore-pat)
              (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
              )
        (set! (-> v1-12 best-my-prim) (the-as collide-shape-prim #t))
        (set! (-> v1-12 action-mask) (collide-action solid))
        )
      )
    (if (fill-and-probe-using-spheres *collide-cache* gp-0)
        #f
        #t
        )
    )
  )

;; definition for function can-hands?
(defbehavior can-hands? target ((arg0 symbol))
  (cond
    ((or (logtest? (-> self target-flags) (target-flags prevent-attack))
         (logtest? (-> self control current-surface flags) (surface-flag no-attack no-hands))
         )
     #f
     )
    ((and (or (not arg0)
              (and (not (time-elapsed? (-> self control last-time-on-surface) (-> *TARGET-bank* ground-timeout)))
                   (< (-> self control local-slope-z) 0.7)
                   )
              )
          (time-elapsed?
            (-> self control last-running-attack-end-time)
            (if (and (= (-> self fact eco-type) 1) (>= (-> self fact eco-level) 1.0))
                (-> *TARGET-bank* yellow-attack-timeout)
                (-> *TARGET-bank* attack-timeout)
                )
            )
          )
     #t
     )
    (else
      (set-time! (-> self control last-hands-attempt-time))
      #f
      )
    )
  )

;; definition for function can-feet?
(defbehavior can-feet? target ((arg0 symbol))
  (cond
    ((or (logtest? (-> self target-flags) (target-flags prevent-attack))
         (logtest? (-> self control current-surface flags) (surface-flag no-attack no-feet))
         (and (and (focus-test? self light) (nonzero? (-> self lightjak)))
              (logtest? (game-feature lightjak-shield) (-> self game features))
              (not (handle->process (-> self lightjak freeze-control)))
              )
         )
     #f
     )
    ((time-elapsed? (-> self control last-attack-end-time) (-> *TARGET-bank* attack-timeout))
     #t
     )
    (else
      (set-time! (-> self control last-feet-attempt-time))
      #f
      )
    )
  )

;; definition for function are-still?
(defbehavior are-still? target ()
  (or (= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
      (< (-> self control ctrl-xz-vel) 61440.0)
      )
  )

;; definition for function vector-local+!
;; INFO: Used lq/sq
(defbehavior vector-local+! target ((arg0 vector) (arg1 vector))
  (let ((s5-0 (new-stack-vector0)))
    (vector-matrix*! s5-0 arg1 (-> self control c-R-w))
    (vector+! arg0 arg0 s5-0)
    )
  )

;; definition for function move-forward
;; INFO: Used lq/sq
(defbehavior move-forward target ((arg0 float))
  (let ((a1-0 (new-stack-vector0))
        (gp-0 (new-stack-vector0))
        )
    (set-vector! a1-0 0.0 0.0 arg0 1.0)
    (vector-matrix*! gp-0 a1-0 (-> self control c-R-w))
    (vector+! (-> self control transv) (-> self control transv) gp-0)
    )
  )

;; definition for function set-forward-vel
;; INFO: Used lq/sq
(defbehavior set-forward-vel target ((arg0 float))
  (let ((gp-0 (new-stack-vector0)))
    (vector-matrix*! gp-0 (-> self control transv) (-> self control w-R-c))
    (set! (-> gp-0 z) arg0)
    (set! (-> gp-0 x) 0.0)
    (vector-matrix*! (-> self control transv) gp-0 (-> self control c-R-w))
    )
  )

;; definition for function delete-back-vel
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defbehavior delete-back-vel target ()
  (let ((gp-0 (new-stack-vector0)))
    (vector-z-quaternion! gp-0 (-> self control dir-targ))
    (let ((v1-1 (new-stack-vector0))
          (f0-1 (vector-dot gp-0 (-> self control transv)))
          )
      0.0
      (vector-! v1-1 (-> self control transv) (vector-float*! v1-1 gp-0 f0-1))
      (let* ((f1-2 (vector-length v1-1))
             (f2-0 f1-2)
             )
        (if (< f0-1 0.0)
            (set! f0-1 0.0)
            )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) gp-0 f0-1)
          (vector-float*! v1-1 v1-1 (/ f1-2 f2-0))
          )
        )
      )
    )
  0
  (none)
  )

;; definition for function set-side-vel
;; INFO: Used lq/sq
(defbehavior set-side-vel target ((arg0 float))
  (let ((gp-0 (new-stack-vector0)))
    (vector-matrix*! gp-0 (-> self control transv) (-> self control w-R-c))
    (set! (-> gp-0 x) arg0)
    (set! (-> gp-0 z) 0.0)
    (vector-matrix*! (-> self control transv) gp-0 (-> self control c-R-w))
    )
  )

;; definition for function target-timed-invulnerable
;; WARN: Return type mismatch int vs none.
(defun target-timed-invulnerable ((arg0 time-frame) (arg1 target) (arg2 int))
  (case arg2
    ((1)
     (logior! (-> arg1 target-flags) (target-flags tinvuln1))
     (set-time! (-> arg1 control invul1-on-time))
     (set! (-> arg1 control invul1-off-time) arg0)
     )
    ((2)
     (logior! (-> arg1 target-flags) (target-flags tinvuln2))
     (set-time! (-> arg1 control invul2-on-time))
     (set! (-> arg1 control invul2-off-time) arg0)
     )
    )
  (let ((t9-0 (method-of-object (-> arg1 control) collide-shape-method-49)))
    2
    #x8000
    0
    (t9-0)
    )
  (logior! (-> arg1 focus-status) (focus-status ignore))
  0
  (none)
  )

;; definition for function target-timed-invulnerable-off
;; WARN: Return type mismatch int vs none.
(defun target-timed-invulnerable-off ((arg0 target) (arg1 int))
  (let ((v1-0 arg1))
    (cond
      ((zero? v1-0)
       (logclear! (-> arg0 target-flags) (target-flags tinvuln1 tinvuln2))
       )
      ((= v1-0 1)
       (logclear! (-> arg0 target-flags) (target-flags tinvuln1))
       )
      ((= v1-0 2)
       (logclear! (-> arg0 target-flags) (target-flags tinvuln2))
       )
      )
    )
  (when (not (logtest? (target-flags tinvuln1 tinvuln2) (-> arg0 target-flags)))
    (logclear! (-> arg0 draw status) (draw-control-status no-draw-bounds))
    (let ((t9-0 (method-of-object (-> arg0 control) collide-shape-method-49)))
      2
      0
      #x8000
      (t9-0)
      )
    )
  0
  (none)
  )

;; definition for function target-log-attack
(defbehavior target-log-attack target ((arg0 attack-info) (arg1 symbol))
  (if (and (= arg1 'background) (= (-> arg0 id) 2))
      (return #t)
      )
  (let ((a3-0 (the-as object (-> self attack-info-old))))
    (dotimes (a2-2 8)
      (let ((v1-9 (-> self attack-info-old a2-2)))
        (when (= (-> arg0 id) (-> v1-9 id))
          (if (not (time-elapsed? (-> v1-9 attack-time) (-> *TARGET-bank* same-attack-invulnerable-timeout)))
              (return #f)
              )
          (cond
            ((= arg1 'test)
             )
            (else
              (mem-copy! (the-as pointer v1-9) (the-as pointer arg0) 168)
              )
            )
          (return #t)
          )
        (if (< (-> v1-9 attack-time) (-> (the-as attack-info a3-0) attack-time))
            (set! a3-0 v1-9)
            )
        )
      )
    (case arg1
      (('test)
       )
      (else
        (mem-copy! (the-as pointer a3-0) (the-as pointer arg0) 168)
        )
      )
    )
  #t
  )

;; definition for method 9 of type attack-info
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod attack-info-method-9 ((this attack-info) (arg0 attack-info) (arg1 process-drawable) (arg2 process-drawable))
  (local-vars (v1-14 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (if (type? arg1 process-drawable)
                    arg1
                    )
                )
          )
      (let ((v1-0 (if (type? arg2 process-drawable)
                      arg2
                      )
                  )
            )
        (cond
          ((logtest? (attack-mask attacker-velocity) (-> this mask))
           (set! (-> arg0 attacker-velocity quad) (-> this attacker-velocity quad))
           (vector-normalize-copy! (-> arg0 trans) (-> arg0 attacker-velocity) 1.0)
           )
          (v1-0
            (cond
              (s5-0
                (vector-! (-> arg0 trans) (-> v1-0 root trans) (-> s5-0 root trans))
                (vector-normalize! (-> arg0 trans) 1.0)
                (set! (-> arg0 attacker-velocity quad) (-> arg0 trans quad))
                )
              (else
                (vector-z-quaternion! (-> arg0 trans) (-> v1-0 root quat))
                (vector-negate-in-place! (-> arg0 trans))
                (vector-normalize! (-> arg0 trans) 1.0)
                (set! (-> arg0 attacker-velocity quad) (-> arg0 trans quad))
                )
              )
            )
          (else
            (set! (-> arg0 trans quad) (the-as uint128 0))
            (set! (-> arg0 attacker-velocity quad) (the-as uint128 0))
            )
          )
        )
      (if s5-0
          (set! (-> arg0 intersection quad) (-> s5-0 root trans quad))
          (set! (-> arg0 intersection quad) (-> (target-pos 0) quad))
          )
      )
    (.lvf vf1 (&-> (-> arg0 trans) quad))
    (.add.w.vf vf2 vf0 vf0 :mask #b1)
    (.mul.vf vf1 vf1 vf1)
    (.mul.x.vf acc vf2 vf1 :mask #b1)
    (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
    (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
    (.mov v1-14 vf1)
    (cond
      ((!= v1-14 0.0)
       (set! (-> arg0 vector quad) (-> arg0 trans quad))
       (set! (-> arg0 vector y) 0.0)
       (vector-xz-normalize! (-> arg0 vector) 1.0)
       )
      (else
        (set! (-> arg0 vector quad) (the-as uint128 0))
        )
      )
    0
    (none)
    )
  )

;; definition for method 10 of type attack-info
(defmethod compute-intersect-info ((this attack-info) (arg0 object) (arg1 process-drawable) (arg2 process) (arg3 touching-shapes-entry))
  (when (and arg3 arg1)
    (let ((a1-2 (prims-touching? arg3 (the-as collide-shape (-> arg1 root)) (the-as uint -1))))
      (when a1-2
        (get-intersect-point (-> this intersection) a1-2 (the-as collide-shape (-> arg1 root)) arg3)
        (logior! (-> this mask) (attack-mask intersection))
        )
      )
    )
  (when arg1
    (set! (-> this prev-state) (-> arg1 state))
    (logior! (-> this mask) (attack-mask prev-state))
    )
  (when (not (logtest? (-> this mask) (attack-mask attacker)))
    (set! (-> this attacker) (process->handle arg2))
    (logior! (-> this mask) (attack-mask attacker))
    )
  (when (not (logtest? (-> this mask) (attack-mask attack-time)))
    (set! (-> this attack-time) (-> *display* base-clock frame-counter))
    (logior! (-> this mask) (attack-mask attack-time))
    )
  (if (not (logtest? (attack-mask damage) (-> this mask)))
      (set! (-> this damage) (-> *FACT-bank* health-default-inc))
      )
  this
  )

;; definition for method 11 of type attack-info
;; INFO: Used lq/sq
(defmethod combine! ((this attack-info) (arg0 attack-info) (arg1 process-drawable))
  (let ((s4-0 (-> arg0 mask)))
    (set! (-> this mask) (-> arg0 mask))
    (if (logtest? s4-0 (attack-mask attacker))
        (set! (-> this attacker) (-> arg0 attacker))
        )
    (if (logtest? s4-0 (attack-mask mode))
        (set! (-> this mode) (-> arg0 mode))
        )
    (if (logtest? s4-0 (attack-mask angle))
        (set! (-> this angle) (-> arg0 angle))
        )
    (if (logtest? s4-0 (attack-mask dist))
        (set! (-> this dist) (-> arg0 dist))
        )
    (if (logtest? s4-0 (attack-mask control))
        (set! (-> this control) (-> arg0 control))
        )
    (if (logtest? s4-0 (attack-mask speed))
        (set! (-> this speed) (-> arg0 speed))
        )
    (if (logtest? (attack-mask penetrate-using) s4-0)
        (set! (-> this penetrate-using) (-> arg0 penetrate-using))
        )
    (if (logtest? (attack-mask damage) s4-0)
        (set! (-> this damage) (-> arg0 damage))
        )
    (if (logtest? (attack-mask shield-damage) s4-0)
        (set! (-> this shield-damage) (-> arg0 shield-damage))
        )
    (if (logtest? (attack-mask knock) s4-0)
        (set! (-> this knock) (-> arg0 knock))
        )
    (if (logtest? (attack-mask count) s4-0)
        (set! (-> this count) (-> arg0 count))
        )
    (if (logtest? s4-0 (attack-mask id))
        (set! (-> this id) (-> arg0 id))
        )
    (if (logtest? s4-0 (attack-mask shove-back))
        (set! (-> this shove-back) (-> arg0 shove-back))
        )
    (if (logtest? s4-0 (attack-mask shove-up))
        (set! (-> this shove-up) (-> arg0 shove-up))
        )
    (if (logtest? s4-0 (attack-mask invinc-time))
        (set! (-> this invinc-time) (-> arg0 invinc-time))
        )
    (if (logtest? s4-0 (attack-mask rotate-to))
        (set! (-> this rotate-to) (-> arg0 rotate-to))
        )
    (if (logtest? s4-0 (attack-mask intersection))
        (set! (-> this intersection quad) (-> arg0 intersection quad))
        )
    (if (logtest? (attack-mask attacker-velocity) s4-0)
        (set! (-> this attacker-velocity quad) (-> arg0 attacker-velocity quad))
        )
    (cond
      ((not (logtest? s4-0 (attack-mask vector)))
       (let* ((s2-0 (handle->process (-> this attacker)))
              (v1-65 (if (type? s2-0 process-drawable)
                         (the-as process-drawable s2-0)
                         )
                     )
              )
         (when (and v1-65 (nonzero? (-> v1-65 root)))
           (set! (-> this trans quad) (-> v1-65 root trans quad))
           (vector-! (-> this vector) (-> arg1 root trans) (-> v1-65 root trans))
           (logior! (-> this mask) (attack-mask vector))
           )
         )
       )
      (else
        (let* ((s3-1 (handle->process (-> this attacker)))
               (v1-72 (if (type? s3-1 process-drawable)
                          (the-as process-drawable s3-1)
                          )
                      )
               )
          (if (and v1-72 (nonzero? (-> v1-72 root)))
              (set! (-> this trans quad) (-> v1-72 root trans quad))
              )
          )
        (set! (-> this vector quad) (-> arg0 vector quad))
        (when (not (logtest? s4-0 (attack-mask shove-back)))
          (let ((v1-79 (-> this vector)))
            (set! (-> this shove-back) (sqrtf (+ (* (-> v1-79 x) (-> v1-79 x)) (* (-> v1-79 z) (-> v1-79 z)))))
            )
          )
        (if (not (logtest? s4-0 (attack-mask shove-up)))
            (set! (-> this shove-up) (-> this vector y))
            )
        )
      )
    (if (not (logtest? (-> this mask) (attack-mask dist)))
        (set! (-> this dist) (fabs (-> this shove-back)))
        )
    (if (logtest? s4-0 (attack-mask trans))
        (set! (-> this trans quad) (-> arg0 trans quad))
        )
    )
  this
  )

;; definition for function ground-tween-initialize
(defbehavior ground-tween-initialize target ((arg0 ground-tween-info)
                                   (arg1 uint)
                                   (arg2 uint)
                                   (arg3 uint)
                                   (arg4 uint)
                                   (arg5 uint)
                                   (arg6 uint)
                                   (arg7 float)
                                   )
  (set! (-> arg0 group 0) arg2)
  (set! (-> arg0 group 1) arg3)
  (set! (-> arg0 group 2) arg4)
  (set! (-> arg0 group 3) arg5)
  (set! (-> arg0 group 4) arg6)
  (dotimes (s2-0 3)
    (set! (-> arg0 chan s2-0) (+ arg1 s2-0))
    (let ((s1-0 (-> self skel root-channel (-> arg0 chan s2-0))))
      (let ((f0-1 (fabs (-> arg0 blend s2-0))))
        (set! (-> s1-0 frame-interp 1) f0-1)
        (set! (-> s1-0 frame-interp 0) f0-1)
        )
      (joint-control-channel-group-eval! s1-0 (the-as art-joint-anim arg2) num-func-identity)
      (set! (-> s1-0 frame-num) arg7)
      )
    )
  arg0
  )

;; definition for function ground-tween-update
;; WARN: Return type mismatch int vs none.
(defbehavior ground-tween-update target ((arg0 ground-tween-info) (arg1 float) (arg2 float) (arg3 float))
  (let ((f0-1 (fmax -1.0 (fmin 1.0 arg1)))
        (f30-0 (fmax -1.0 (fmin 1.0 arg2)))
        )
    (let ((f1-5 (fabs (- f0-1 (-> arg0 blend 1)))))
      (seek! (-> arg0 blend 1) f0-1 (fmax (fmin (* f1-5 arg3) (* 0.8 arg3)) (* 0.2 arg3)))
      )
    (let ((f0-9 (fabs (- f30-0 (-> arg0 blend 2)))))
      (seek! (-> arg0 blend 2) f30-0 (fmax (fmin (* f0-9 arg3) (* 0.8 arg3)) (* 0.2 arg3)))
      )
    )
  (cond
    ((>= (-> arg0 blend 1) 0.0)
     (let ((v1-12 (-> self skel root-channel (-> arg0 chan 1))))
       (let ((f0-16 (fabs (-> arg0 blend 1))))
         (set! (-> v1-12 frame-interp 1) f0-16)
         (set! (-> v1-12 frame-interp 0) f0-16)
         )
       (set! (-> v1-12 frame-group) (the-as art-joint-anim (-> arg0 group 1)))
       )
     )
    (else
      (let ((v1-15 (-> self skel root-channel (-> arg0 chan 1))))
        (let ((f0-18 (fabs (-> arg0 blend 1))))
          (set! (-> v1-15 frame-interp 1) f0-18)
          (set! (-> v1-15 frame-interp 0) f0-18)
          )
        (set! (-> v1-15 frame-group) (the-as art-joint-anim (-> arg0 group 2)))
        )
      )
    )
  (cond
    ((>= (-> arg0 blend 2) 0.0)
     (let ((v1-18 (-> self skel root-channel (-> arg0 chan 2))))
       (let ((f0-21 (fabs (-> arg0 blend 2))))
         (set! (-> v1-18 frame-interp 1) f0-21)
         (set! (-> v1-18 frame-interp 0) f0-21)
         )
       (set! (-> v1-18 frame-group) (the-as art-joint-anim (-> arg0 group 4)))
       )
     )
    (else
      (let ((v1-21 (-> self skel root-channel (-> arg0 chan 2))))
        (let ((f0-23 (fabs (-> arg0 blend 2))))
          (set! (-> v1-21 frame-interp 1) f0-23)
          (set! (-> v1-21 frame-interp 0) f0-23)
          )
        (set! (-> v1-21 frame-group) (the-as art-joint-anim (-> arg0 group 3)))
        )
      )
    )
  0
  (none)
  )

;; definition for function target-pos
(defun target-pos ((arg0 int))
  (let ((a1-0 *target*))
    (cond
      (a1-0
        (if (zero? arg0)
            (-> a1-0 control trans)
            (vector<-cspace! (new 'static 'vector) (-> a1-0 node-list data arg0))
            )
        )
      (else
        (camera-pos)
        )
      )
    )
  )

;; definition for function target-cam-pos
;; INFO: Used lq/sq
(defun target-cam-pos ()
  (let ((gp-0 *target*))
    (cond
      ((not gp-0)
       (camera-pos)
       )
      ((logtest? (-> gp-0 target-flags) (target-flags tf6))
       (add-debug-sphere
         *display-camera-marks*
         (bucket-id debug-no-zbuf1)
         (-> gp-0 alt-cam-pos)
         (meters 0.2)
         (new 'static 'rgba :r #xff :a #x80)
         )
       (-> gp-0 alt-cam-pos)
       )
      ((logtest? (-> gp-0 target-flags) (target-flags tf12))
       (add-debug-sphere
         *display-camera-marks*
         (bucket-id debug-no-zbuf1)
         (-> gp-0 alt-cam-pos)
         (meters 0.2)
         (new 'static 'rgba :r #xff :a #x80)
         )
       (-> gp-0 alt-cam-pos)
       )
      ((logtest? (-> gp-0 target-flags) (target-flags tf14))
       (let ((s5-0 (new 'static 'vector)))
         (set! (-> s5-0 quad) (-> gp-0 control camera-pos quad))
         (set! (-> s5-0 y) (fmax (-> s5-0 y) (-> gp-0 alt-cam-pos y)))
         (add-debug-sphere
           *display-camera-marks*
           (bucket-id debug-no-zbuf1)
           s5-0
           (meters 0.2)
           (new 'static 'rgba :r #xff :a #x80)
           )
         s5-0
         )
       )
      (else
        (add-debug-sphere
          *display-camera-marks*
          (bucket-id debug-no-zbuf1)
          (-> gp-0 control camera-pos)
          (meters 0.2)
          (new 'static 'rgba :r #xff :b #xff :a #x80)
          )
        (-> gp-0 control camera-pos)
        )
      )
    )
  )

;; definition for function target-rot
(defun target-rot ()
  (let ((v1-0 *target*))
    (if v1-0
        (-> v1-0 control quat-for-control)
        *unity-quaternion*
        )
    )
  )

;; definition for method 21 of type target
;; INFO: Used lq/sq
(defmethod get-trans ((this target) (arg0 int))
  "Get the `trans` for this process."
  (local-vars (v0-0 vector))
  (let ((v1-0 (-> this control)))
    (cond
      ((zero? arg0)
       (-> v1-0 trans)
       )
      ((= arg0 1)
       (let ((a1-2 (-> this water flags)))
         (cond
           ((and (logtest? (water-flag touch-water) a1-2)
                 (logtest? (water-flag under-water swimming) a1-2)
                 (not (logtest? (focus-status mech) (-> this focus-status)))
                 )
            (set! v0-0 (new 'static 'vector :w 1.0))
            (set! (-> v0-0 quad) (-> this control trans quad))
            (set! (-> v0-0 y) (-> this water height))
            v0-0
            )
           (else
             (-> v1-0 gspot-pos)
             )
           )
         )
       )
      ((= arg0 2)
       (if (logtest? (-> this draw status) (draw-control-status no-draw no-draw-temp))
           (-> v1-0 trans)
           (vector<-cspace! (new 'static 'vector) (-> this node-list data 8))
           )
       )
      ((= arg0 3)
       (cond
         ((logtest? (-> this draw status) (draw-control-status no-draw no-draw-temp))
          (set! v0-0 (new 'static 'vector))
          (set! (-> v0-0 quad) (-> v1-0 trans quad))
          (vector+float*! v0-0 v0-0 (-> this control local-normal) 8192.0)
          )
         (else
           (set! v0-0 (vector<-cspace! (new 'static 'vector) (-> this node-list data 6)))
           (set! (-> v0-0 w) 4096.0)
           )
         )
       v0-0
       )
      ((= arg0 4)
       (target-cam-pos)
       )
      ((= arg0 5)
       (if (= (-> this draw origin w) 0.0)
           (-> v1-0 trans)
           (-> this draw origin)
           )
       )
      ((= arg0 6)
       (let ((f0-5 (vector-dot (-> v1-0 dynam gravity-normal) (-> v1-0 transv))))
         (cond
           ((and (< 0.0 f0-5) (focus-test? this in-air))
            (let* ((v0-1 (new 'static 'vector))
                   (f0-6 (+ (* 0.0016666667 (-> v1-0 dynam gravity-length)) f0-5))
                   (f0-9 (/ (* 0.5 f0-6 f0-6) (-> v1-0 dynam gravity-length)))
                   )
              (vector+float*! v0-1 (-> v1-0 trans) (-> v1-0 dynam gravity-normal) f0-9)
              )
            )
           (else
             (-> v1-0 trans)
             )
           )
         )
       )
      ((= arg0 7)
       (-> v1-0 last-trans-on-ground)
       )
      ((= arg0 8)
       (-> v1-0 last-trans-leaving-surf)
       )
      (else
        (-> v1-0 trans)
        )
      )
    )
  )

;; definition for method 24 of type target
(defmethod time-to-apex-or-ground ((this target) (arg0 int))
  (let ((v1-0 (-> this control)))
    (cond
      ((zero? arg0)
       (let ((f0-1 (vector-dot (-> v1-0 dynam gravity-normal) (-> v1-0 transv))))
         (if (and (< 0.0 f0-1) (focus-test? this in-air))
             (time-to-apex f0-1 (- (-> v1-0 dynam gravity-length)))
             0
             )
         )
       )
      ((= arg0 1)
       (if (focus-test? this in-air)
           (the-as int (target-time-to-ground))
           0
           )
       )
      (else
        0
        )
      )
    )
  )

;; definition for method 22 of type target
(defmethod get-quat ((this target) (arg0 int))
  "Get the quaternion for this process."
  (let ((v1-0 arg0))
    (cond
      ((zero? v1-0)
       (-> this control quat)
       )
      ((= v1-0 1)
       (-> this control quat-for-control)
       )
      ((= v1-0 2)
       (-> this control dir-targ)
       )
      ((= v1-0 3)
       (if (using-gun? this)
           (forward-up->quaternion
             (new 'static 'quaternion)
             (-> this gun fire-dir-out)
             (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> this control quat-for-control))
             )
           (-> this control quat)
           )
       )
      (else
        (-> this control quat)
        )
      )
    )
  )

;; definition for method 25 of type target
;; WARN: Return type mismatch float vs meters.
(defmethod get-water-height ((this target))
  (the-as meters (if (logtest? (-> this water flags) (water-flag active))
                     (-> this water surface-height)
                     (-> this control trans y)
                     )
          )
  )

;; definition for method 26 of type target
(defmethod get-notice-time ((this target))
  (-> this neck notice-time)
  )

;; definition for function external-target-spawn
;; INFO: Used lq/sq
(defun external-target-spawn ((arg0 vector) (arg1 quaternion) (arg2 process) (arg3 symbol) (arg4 manipy-options))
  (local-vars
    (v1-5 symbol)
    (sv-96 process)
    (sv-112 (function vector entity-actor skeleton-group vector manipy-options none :behavior manipy))
    (sv-128 entity-actor)
    )
  (let* ((s1-0 (get-process *default-dead-pool* manipy #x20000 1))
         (s5-0 (when s1-0
                 (let ((t9-1 (method-of-type manipy activate)))
                   (t9-1 (the-as manipy s1-0) arg2 "manipy" (the-as pointer #x70004000))
                   )
                 (let ((s5-1 run-function-in-process))
                   (set! sv-96 s1-0)
                   (set! sv-112 manipy-init)
                   (set! v1-5 (when (not (logtest? (-> arg2 mask) (process-mask process-tree)))
                                (set! sv-128 (the-as entity-actor v1-5))
                                (set! sv-128 (-> arg2 entity))
                                v1-5
                                )
                         )
                   (let ((t0-1 (target-skel-group))
                         (t1-0 (if (logtest? arg4 (manipy-options mo3))
                                   (the-as vector #f)
                                   (new 'static 'vector :y 2867.2 :w 3276.8)
                                   )
                               )
                         (t2-0 2)
                         )
                     ((the-as (function object object object object object object object none) s5-1)
                      sv-96
                      sv-112
                      arg0
                      sv-128
                      t0-1
                      t1-0
                      t2-0
                      )
                     )
                   )
                 (-> s1-0 ppointer)
                 )
               )
         )
    (when s5-0
      (cond
        ((logtest? arg4 (manipy-options mo2))
         (send-event (ppointer->process s5-0) 'anim-mode 'still)
         (send-event (ppointer->process s5-0) 'art-joint-anim "pilot-wcar-turn-back" 0 #x40a00000)
         )
        (else
          (send-event (ppointer->process s5-0) 'anim-mode 'loop)
          (send-event (ppointer->process s5-0) 'art-joint-anim "duck-stance")
          )
        )
      (send-event
        (ppointer->process s5-0)
        'eval
        (lambda :behavior target
          ()
          (logior! (-> self control root-prim prim-core action) (collide-action solid))
          (none)
          )
        )
      (send-event (ppointer->process s5-0) 'user-data arg3)
      (cond
        ((logtest? arg4 (manipy-options mo1))
         (send-event
           (ppointer->process s5-0)
           'trans-hook
           (lambda :behavior manipy
             ()
             (target-update-segs self)
             (if (and (and *target*
                           (and (>= 40960.0 (vector-vector-distance (-> self root trans) (-> *target* control trans)))
                                (not (logtest? (focus-status teleporting) (-> *target* focus-status)))
                                )
                           )
                      (and (focus-test? *target* indax)
                           (not (focus-test? *target* in-head pole light board mech dark teleporting))
                           (>= (-> *display* base-clock frame-counter) (-> *game-info* blackout-time))
                           (= (-> *setting-control* user-current bg-a) 0.0)
                           (send-event *target* 'end-mode 'indax)
                           )
                      )
                 (script-eval (the-as pair (-> self userdata)))
                 )
             (none)
             )
           )
         )
        ((logtest? arg4 (manipy-options mo0))
         (send-event
           (ppointer->process s5-0)
           'trans-hook
           (lambda :behavior manipy
             ()
             (target-update-segs self)
             (when (and (and *target* (and (>= 20480.0 (vector-vector-distance (-> self root trans) (-> *target* control trans)))
                                           (not (logtest? (focus-status teleporting) (-> *target* focus-status)))
                                           )
                             )
                        (focus-test? *target* indax)
                        (not (focus-test? *target* in-head pole light board mech dark teleporting))
                        (can-display-query? self "indax" -99.0)
                        )
               (let ((gp-0
                       (new 'stack 'font-context *font-default-matrix* 32 320 0.0 (font-color default) (font-flags shadow kerning))
                       )
                     )
                 (let ((v1-14 gp-0))
                   (set! (-> v1-14 width) (the float 340))
                   )
                 (let ((v1-15 gp-0))
                   (set! (-> v1-15 height) (the float 80))
                   )
                 (let ((v1-16 gp-0)
                       (a0-13 (-> *setting-control* user-default language))
                       )
                   (set! (-> v1-16 scale) (if (or (= a0-13 (language-enum korean)) (= a0-13 (language-enum russian)))
                                              0.9
                                              0.7
                                              )
                         )
                   )
                 (set! (-> gp-0 flags) (font-flags shadow kerning large))
                 (print-game-text
                   (lookup-text! *common-text* (text-id text-0083) #f)
                   gp-0
                   #f
                   44
                   (bucket-id hud-draw-hud-alpha)
                   )
                 )
               (if (and (cpad-pressed? 0 triangle) (send-event *target* 'end-mode 'indax))
                   (script-eval (the-as pair (-> self userdata)))
                   )
               )
             (none)
             )
           )
         )
        ((logtest? arg4 (manipy-options mo2))
         (send-event
           (ppointer->process s5-0)
           'trans-hook
           (lambda :behavior target
             ()
             (target-update-segs self)
             (set! (-> self control trans quad) (-> (the-as process-drawable (-> self parent 0)) root trans quad))
             (quaternion-copy! (-> self control quat) (-> (the-as process-drawable (-> self parent 0)) root quat))
             (none)
             )
           )
         )
        (else
          (send-event
            (ppointer->process s5-0)
            'trans-hook
            (lambda :behavior target () (target-update-segs self) (none))
            )
          )
        )
      (quaternion-copy! (-> (the-as process-drawable (-> s5-0 0)) root quat) arg1)
      )
    s5-0
    )
  )

;; definition for function target-reset-on-task-finish
;; WARN: Return type mismatch int vs none.
(defun target-reset-on-task-finish ()
  (when *target*
    (set! (-> *target* fact health) (-> *target* fact health-max))
    (if (using-gun? *target*)
        (send-event *target* 'end-mode 'gun)
        )
    )
  (hide-hud 'hud-health)
  (hide-hud 'hud-gun)
  (set! (-> *game-info* gun-ammo 0) (fmax (-> *game-info* gun-ammo 0) (-> *FACT-bank* ammo-yellow-start)))
  (set! (-> *game-info* gun-ammo 1) (fmax (-> *game-info* gun-ammo 1) (-> *FACT-bank* ammo-red-start)))
  (set! (-> *game-info* gun-ammo 2) (fmax (-> *game-info* gun-ammo 2) (-> *FACT-bank* ammo-blue-start)))
  (set! (-> *game-info* gun-ammo 3) (fmax (-> *game-info* gun-ammo 3) (-> *FACT-bank* ammo-dark-start)))
  0
  (none)
  )
