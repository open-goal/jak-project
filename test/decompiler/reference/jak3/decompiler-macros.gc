;; This file should contain an implementation for all macros that the decompiler uses in its output.

(defmacro init-vf0-vector ()
  "Initializes the VF0 vector which is a constant vector in the VU set to <0,0,0,1>"
  `(.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
  )

(defmacro new-stack-vector0 ()
  "Get a stack vector that's set to 0.
   This is more efficient than (new 'stack 'vector) because
   this doesn't call the constructor."
  `(let ((vec (new 'stack-no-clear 'vector)))
     (set! (-> vec quad) (the-as uint128 0))
     vec
     )
  )

(defmacro set-vector! (v xv yv zv wv)
  "Set all fields in a vector"
  (with-gensyms (vec)
     `(let ((,vec ,v))
       (set! (-> ,vec x) ,xv)
       (set! (-> ,vec y) ,yv)
       (set! (-> ,vec z) ,zv)
       (set! (-> ,vec w) ,wv)
       ,vec
       ))
     )

(defmacro new-stack-quaternion0 ()
  "Get a stack quaternion that's set to 0.
   This is more efficient than (new 'stack 'quaternion) because
   this doesn't call the constructor."
  `(let ((q (new 'stack-no-clear 'quaternion)))
     (set! (-> q quad) (the-as uint128 0))
     q
     )
  )

(defmacro with-pp (&rest body)
  "execute the body with pp bound to the current process register."
  `(rlet ((pp :reg r13 :reset-here #t :type process))
         ,@body)
  )

(defconstant PP (with-pp pp))

(defmacro current-time ()
  `(-> PP clock frame-counter)
  )

(defmacro seconds-per-frame ()
  `(-> PP clock seconds-per-frame)
  )

(defmacro make-u128 (upper lower)
  `(rlet ((result :class i128)
          (upper-xmm :class i128)
          (lower-xmm :class i128))
     (.mov upper-xmm ,upper)
     (.mov lower-xmm ,lower)
     (.pcpyld result upper-xmm lower-xmm)
     (the uint result)
     )
  )

(defmacro handle->process (handle)
  "Convert a handle to a process. If the process no longer exists, returns #f."
  `(let ((the-handle (the-as handle ,handle)))
     (if (-> the-handle process) ;; if we don't point to a process, kernel sets this to #f
         (let ((proc (-> (-> the-handle process))))
           (if (= (-> the-handle pid) (-> proc pid)) ;; make sure it's the same process
               proc
               )
           )
         )
     )
  )

(defmacro ppointer->process (ppointer)
  "convert a (pointer process) to a process."
  ;; this uses the self field, which seems to always just get set to the object.
  ;; confirmed in Jak 1 that using self here is useless, not sure...
  `(let ((the-pp ,ppointer))
     (if the-pp (-> the-pp 0 self))
     )
  )

(defmacro defbehavior (name process-type bindings &rest body)
  "define a new behavior. This is simply a function where self is bound to the process register,
   which is assumed to have type process-type."
  (if (and
       (> (length body) 1)     ;; more than one thing in function
       (string? (first body))  ;; first thing is a string
       )
      ;; then it's a docstring and we ignore it.
      `(define ,name (lambda :name ,name :behavior ,process-type ,bindings ,@(cdr body)))
      ;; otherwise don't ignore it.
      `(define ,name (lambda :name ,name :behavior ,process-type ,bindings ,@body))
      )
  )

(defmacro process->ppointer (proc)
  "safely get a (pointer process) from a process, returning #f if invalid."
  `(let ((the-proc ,proc))
     (if the-proc (-> the-proc ppointer))
     )
  )

(defmacro ppointer->handle (pproc)
  `(let ((the-process (the-as (pointer process) ,pproc)))
      (new 'static 'handle :process the-process :pid (-> the-process 0 pid))
      )
  )

(defmacro process->handle (proc)
  "convert a process to a handle. if proc is #f, returns a #f handle."
  `(ppointer->handle (process->ppointer (the-as process ,proc)))
  )

;; use a compile-time list to keep track of the type of an anonymous behavior.
(seval (define *defstate-type-stack* '()))
(desfun def-state-check-behavior (beh-form beh-type)
  "check if code block is an anonymous behavior. needed for anonymous behaviors on defstate."

  (when (and (pair? beh-form) (eq? (first beh-form) 'behavior))
    (push! *defstate-type-stack* beh-type)
    )
  )
(defmacro clear-def-state-stack ()
  (set! *defstate-type-stack* '())
  `(none)
  )

;; set when inside a defstate.
(seval (define *defstate-current-type* #f))
(seval (define *defstate-current-state-name* #f))

;; *no-state* is just used for the compiler to know whether a handler was actually set or not
(defmacro defstate (state-name parents
                               &key (virtual #f)
                               &key (event *no-state*)
                               &key (enter *no-state*)
                               &key (trans *no-state*)
                               &key (exit *no-state*)
                               &key (code *no-state*)
                               &key (post *no-state*)
                               )
  "Define a new state!"

  (with-gensyms (new-state)
    (let ((defstate-type (first parents)))
      (when (not (null? *defstate-type-stack*))
        (fmt #t "*defstate-type-stack* leaked! An error probably happened in a previous defstate. stack is: {}"
                 *defstate-type-stack*)
        )
      (set! *defstate-type-stack* '())
      (when virtual
        (set! *defstate-current-type* defstate-type)
        (set! *defstate-current-state-name* state-name)
        )
      ;; check for default handlers
      (let ((default-handlers (assoc defstate-type *default-state-handlers*)))
          (when default-handlers
              ;;(fmt #t "found default-handlers for {}: {}\n" defstate-type default-handlers)
              ;; event
              (set! default-handlers (cadr default-handlers))
              (when (and (eq? event '*no-state*) (car default-handlers))
                  (set! event (car default-handlers)))
              ;; enter
              (set! default-handlers (cdr default-handlers))
              (when (and (eq? enter '*no-state*) (car default-handlers))
                  (set! enter (car default-handlers)))
              ;; trans
              (set! default-handlers (cdr default-handlers))
              (when (and (eq? trans '*no-state*) (car default-handlers))
                  (set! trans (car default-handlers)))
              ;; exit
              (set! default-handlers (cdr default-handlers))
              (when (and (eq? exit '*no-state*) (car default-handlers))
                  (set! exit (car default-handlers)))
              ;; code
              (set! default-handlers (cdr default-handlers))
              (when (and (eq? code '*no-state*) (car default-handlers))
                  (set! code (car default-handlers)))
              ;; post
              (set! default-handlers (cdr default-handlers))
              (when (and (eq? post '*no-state*) (car default-handlers))
                  (set! post (car default-handlers)))

              (set! default-handlers (cdr default-handlers))
              )
          )
      (def-state-check-behavior event defstate-type)
      (def-state-check-behavior enter defstate-type)
      (def-state-check-behavior trans defstate-type)
      (def-state-check-behavior exit defstate-type)
      (def-state-check-behavior code defstate-type)
      (def-state-check-behavior post defstate-type)
      `(let ((,new-state (new 'static 'state
                              :name (quote ,state-name)
                              :next #f
                              :exit #f
                              :code #f
                              :trans #f
                              :post #f
                              :enter #f
                              :event #f
                              )
                         ))
         ;; the compiler will set the fields of the given state and define the symbol.
         ;; This way it can check the individual function types, make sure they make sense, and create
         ;; a state with the appropriate type.
         ,(if virtual
              `(define-virtual-state-hook ,state-name ,defstate-type ,new-state ,(eq? virtual 'override) :event ,event :enter ,enter :trans ,trans :exit ,exit :code ,code :post ,post)
              `(define-state-hook ,state-name ,defstate-type ,new-state :event ,event :enter ,enter :trans ,trans :exit ,exit :code ,code :post ,post)
              )

         )
      )
    )
  )


(defmacro find-parent-state ()
  "Find the first different implementation of the current virtual state above this one."
  (when (or (not *defstate-current-type*)
            (not *defstate-current-state-name*))
    (error "use of find-parent-state outside of a defstate.")
    )
  `(cast-to-method-type
     ,*defstate-current-type*
     ,*defstate-current-state-name*
     (find-parent-method ,*defstate-current-type* (method-id-of-type ,*defstate-current-type* ,*defstate-current-state-name*))
    )
  )

(defmacro call-parent-method (&rest args)
  "Find the first different implementation of the current method in a parent type and call it with these arguments."
  `((the (current-method-function-type) (find-parent-method (current-method-type) (current-method-id)))
    ,@args)
  )


(defmacro behavior (bindings &rest body)
  "Define an anonymous behavior for a process state. This may only be used inside a defstate!"

  (let ((behavior-type (first *defstate-type-stack*)))
    (pop! *defstate-type-stack*)
    `(lambda :behavior ,behavior-type ,bindings ,@body)
    )
  )

;; set the default handler functions for a process's state handlers
(seval (define *default-state-handlers* '()))
(defmacro defstatehandler (proc
                           &key (event #f)
                           &key (enter #f)
                           &key (trans #f)
                           &key (exit #f)
                           &key (code #f)
                           &key (post #f))
  (let ((old (assoc proc *default-state-handlers*))
        (new (list proc (list event enter trans exit code post))))
      (if (not old)
          (append!! *default-state-handlers* new) ;; add new set of default handlers
          (dolist (hnd *default-state-handlers*)  ;; replace old handlers with new ones
            (when (eq? (car hnd) old)
              (set-car! hnd new)
              )
            )
          )
      )
  `(none)
  )

(defmacro b! (pred destination &key (delay '()) &key (likely-delay '()))
  "Branch!"
  ;; evaluate the predicate
  `(let ((should-branch ,pred))
     ;; normal delay slot:
     ,delay
     (when should-branch
       ,likely-delay
       (goto ,destination)
       )
     )
  )

;; meters are stored as (usually) a float, scaled by 4096.
;; this gives you reasonable accuracy as an integer.
(defglobalconstant METER_LENGTH 4096.0)

(defmacro meters (x)
  "Convert number to meters.
   If the input is a constant float or integer, the result will be a
   compile time constant float. Otherwise, it will not be constant.
   Returns float."

  ;; we don't have enough constant propagation for the compiler to figure this out.
  (cond
    ((float? x)
     (* METER_LENGTH x)
     )
    ((integer? x)
     (* METER_LENGTH x)
     )
    (#t
     `(* METER_LENGTH ,x)
     )
    )
  )

;; rotations are stored in 65,536ths of a full rotation.
;; like with meters, you get a reasonable accuracy as an integer.
;; additionally, it is a power-of-two, so wrapping rotations can be done
;; quickly by converting to an int, masking, and back to float
(defglobalconstant DEGREES_PER_ROT 65536.0)

;; this was deg in GOAL
(defmacro degrees (x)
  "Convert number to degrees unit.
   Will keep a constant float/int constant."
  (cond
    ((or (float? x) (integer? x))
     (* DEGREES_PER_ROT (/ (+ 0.0 x) 360.0))
     )
    (#t
     `(* (/ (the float ,x) 360.0)
         DEGREES_PER_ROT
         )
     )
    )
  )

;; times are stored in 300ths of a second.
;; this divides evenly into frames at both 50 and 60 fps.
;; typically these are stored as integers as more precision is not useful.
;; an unsigned 32-bit integer can store about 150 days
(defglobalconstant TICKS_PER_SECOND 300) ;; 5 t/frame @ 60fps, 6 t/frame @ 50fps

;; this was usec in GOAL
(defmacro seconds (x)
  "Convert number to seconds unit.
   Returns uint."
  (cond
    ((integer? x)
     (* TICKS_PER_SECOND x)
     )
    ((float? x)
     (* 1 (* 1.0 x TICKS_PER_SECOND))
     )
    (#t
     `(the uint (* TICKS_PER_SECOND ,x))
     )
    )
  )

(defmacro fsec (x)
  "Convert number to seconds unit.
   Returns float."
  (cond
    ((or (integer? x) (float? x))
     (* 1.0 TICKS_PER_SECOND x)
     )
    (#t
     `(* 1.0 TICKS_PER_SECOND ,x)
     )
    )
  )

(fake-asm .sync.l)
(fake-asm .sync.p)
(fake-asm .mfc0 dest src)
(fake-asm .mtc0 dest src)
(fake-asm .mtpc dest src)
(fake-asm .mfpc dest src)
(fake-asm .mtdab src)
(fake-asm .mtdabm src)

(defmacro suspend ()
  '(none)
  )

(defmacro empty-form ()
  '(none)
  )

(defmacro .sync.l ()
  `(none))

(defmacro seek! (place target rate)
  "Macro to use seek in-place. place is the base, and where the result is stored."
  `(set! ,place (seek ,place ,target ,rate))
  )

(defmacro seekl! (place target rate)
  "Macro to use seekl in-place. place is the base, and where the result is stored."
  `(set! ,place (seekl ,place ,target ,rate))
  )

;; pad
(defmacro cpad-pressed (pad-idx)
  `(-> *cpad-list* cpads ,pad-idx button0-rel 0)
  )

(defmacro cpad-hold (pad-idx)
  `(-> *cpad-list* cpads ,pad-idx button0-abs 0)
  )

(defmacro cpad-pressed? (pad-idx &rest buttons)
  `(logtest? (cpad-pressed ,pad-idx) (pad-buttons ,@buttons))
  )

(defmacro cpad-hold? (pad-idx &rest buttons)
  `(logtest? (cpad-hold ,pad-idx) (pad-buttons ,@buttons))
  )

(defmacro mouse-pressed ()
  `(-> *mouse* button0-rel 0)
  )

(defmacro mouse-hold ()
  `(-> *mouse* button0-abs 0)
  )

(defmacro mouse-pressed? (&rest buttons)
  `(logtest? (mouse-pressed) (mouse-buttons ,@buttons))
  )

(defmacro mouse-hold? (&rest buttons)
  `(logtest? (mouse-hold) (mouse-buttons ,@buttons))
  )

(defmacro gs-reg-list (&rest reg-ids)
  "Generate a giftag register descriptor list from reg-ids."

  (let ((reg-count (length reg-ids)))
    (when (> (length reg-ids) 16)
      (ferror "too many regs passed to gs-reg-list")
      )
    (let ((list-to-splice '())
          (cur-lst reg-ids)
          (i -1))

        ;; this is questionable.
        (while (and (not (null? cur-lst)) (< i 15))
          (push! list-to-splice (cons 'gif-reg-id (cons (car cur-lst) '())))
          (push! list-to-splice (string->symbol-format ":regs{}" (inc! i)))
          (pop! cur-lst)
          )

        `(new 'static 'gif-tag-regs
            ,@list-to-splice
            )
        )
  #| ;; the opengoal compiler does not have enough constant propagation for this for now
    (let ((i -1))

      `(the-as gif-tag-regs (logior ,@(apply (lambda (x)
          `(shl (the-as uint (gif-reg-id ,x)) ,(* 4 (inc! i)))
                ) reg-ids)
              ))

      )|#
    )
  )

(defmacro dma-buffer-add-base-type (buf pkt dma-type &rest body)
  "Base macro for adding stuff to a dma-buffer. Don't use this directly!"

  (with-gensyms (dma-buf)
    `(let* ((,dma-buf ,buf)
            (,pkt (the-as ,dma-type (-> ,dma-buf base))))

          ,@body

          (set! (-> ,dma-buf base) (&+ (the-as pointer ,pkt) (size-of ,dma-type)))

        )
    )
  )

(defmacro dma-buffer-add-base-data (buf data-type forms)
  "Base macro for adding data words to a dma-buffer.
   Each form in forms is converted into data-type and added to the buffer. NO TYPE CHECKING is performed, so be careful!"

  (with-gensyms (dma-buf ptr)
    `(let* ((,dma-buf ,buf)
            (,ptr (the-as (pointer ,data-type) (-> ,dma-buf base))))

          ,@(apply-i (lambda (x i) `(set! (-> ,ptr ,i) (the-as ,data-type ,x))) forms)

          (set! (-> ,dma-buf base) (&+ (the-as pointer ,ptr) (* ,(length forms) (size-of ,data-type))))

        )
    )
  )


(defmacro dma-buffer-add-cnt-vif2 (buf qwc vif0 vif1)
  "Add a dma-packet to a dma-buffer.
   The packet is made up of a 'cnt' DMAtag (transfer qwc qwords of data after the tag and continue from after that point)
    and includes two vif-tags for vifcode, or something else if needed."

  (with-gensyms (pkt)
    `(dma-buffer-add-base-type ,buf ,pkt dma-packet

        (set! (-> ,pkt dma) (new 'static 'dma-tag :id (dma-tag-id cnt) :qwc ,qwc))

        (set! (-> ,pkt vif0) ,vif0)
        (set! (-> ,pkt vif1) ,vif1)

        )
    )
  )

(defmacro dma-buffer-add-ref-vif2 (buf qwc addr vif0 vif1)
  "Add a dma-packet to a dma-buffer.
   The packet is made up of a 'cnt' DMAtag (transfer qwc qwords of data at addr and continue from after the tag)
    and includes two vif-tags for vifcode, or something else if needed."

  (with-gensyms (pkt)
    `(dma-buffer-add-base-type ,buf ,pkt dma-packet

        (set! (-> ,pkt dma) (new 'static 'dma-tag :id (dma-tag-id ref) :qwc ,qwc :addr (the-as int ,addr)))

        (set! (-> ,pkt vif0) ,vif0)
        (set! (-> ,pkt vif1) ,vif1)

        )
    )
  )

(defmacro dma-buffer-add-ret (buf)
  "Add a dma-packet to a dma-buffer. This packet simply does a DMA 'return' "

  (with-gensyms (pkt)
    `(dma-buffer-add-base-type ,buf ,pkt dma-packet

        (set! (-> ,pkt dma) (new 'static 'dma-tag :id (dma-tag-id ret) :qwc 0))

        (set! (-> ,pkt vif0) (new 'static 'vif-tag :cmd (vif-cmd nop)))
        (set! (-> ,pkt vif1) (new 'static 'vif-tag :cmd (vif-cmd nop)))

        )
    )
  )

(defmacro dma-buffer-add-gif-tag (buf giftag gifregs)
  "Add a giftag to a dma-buffer."

  (with-gensyms (pkt)
    `(dma-buffer-add-base-type ,buf ,pkt gs-gif-tag

        (set! (-> ,pkt tag) ,giftag)

        (set! (-> ,pkt regs) ,gifregs)

        )
    )
  )

(defmacro dma-buffer-add-uint64 (buf &rest body)
  "Add 64-bit words to a dma-buffer. See dma-buffer-add-base-data"

  `(dma-buffer-add-base-data ,buf uint64 ,body)
  )

(defmacro dma-buffer-add-uint128 (buf &rest body)
  "Add 128-bit words to a dma-buffer. See dma-buffer-add-base-data"

  `(dma-buffer-add-base-data ,buf uint128 ,body)
  )

(defmacro dma-buffer-add-gs-set-flusha (buf &rest reg-list)
  "Add a gif cnt dma packet to a dma-buffer for setting GS registers. Up to 16 can be set at once.
   The packet runs the flusha command which waits for GIF transfer to end and VU1 microprogram to stop.
   reg-list is a list of pairs where the car is the register name and the cadr is the value to be set for that register."

  (let ((reg-count (length reg-list))
        (qwc (+ (length reg-list) 1))
        (reg-names (apply first reg-list))
        (reg-datas (apply second reg-list))
        )
    `(begin
      ;; dma tag
      (dma-buffer-add-cnt-vif2 ,buf ,qwc
                              (new 'static 'vif-tag :cmd (vif-cmd flusha))
                              (new 'static 'vif-tag :cmd (vif-cmd direct) :imm ,qwc)
                              )

      ;; gif tag for editing gs regs
      (dma-buffer-add-gif-tag ,buf (new 'static 'gif-tag64 :nloop 1 :eop 1 :nreg ,reg-count)
                                   (gs-reg-list a+d a+d a+d a+d a+d a+d a+d a+d a+d a+d a+d a+d a+d a+d a+d a+d)
                                   )

      ;; gs regs
      (dma-buffer-add-uint64 ,buf
          ,@(apply2 (lambda (x) x) (lambda (x) `(gs-reg64 ,x)) reg-datas reg-names)
          )
      )
    )
  )

(defmacro dma-buffer-add-gs-set (buf &rest reg-list)
  "Add a gif cnt dma packet to a dma-buffer for setting GS registers. Up to 16 can be set at once.
   reg-list is a list of pairs where the car is the register name and the cadr is the value to be set for that register."

  (let ((reg-count (length reg-list))
        (qwc (+ (length reg-list) 1))
        (reg-names (apply first reg-list))
        (reg-datas (apply second reg-list))
        )
    `(begin
      ;; dma tag
      (dma-buffer-add-cnt-vif2 ,buf ,qwc
                              (new 'static 'vif-tag :cmd (vif-cmd nop))
                              (new 'static 'vif-tag :cmd (vif-cmd direct) :imm ,qwc)
                              )

      ;; gif tag for editing gs regs
      (dma-buffer-add-gif-tag ,buf (new 'static 'gif-tag64 :nloop 1 :eop 1 :nreg ,reg-count)
                                   (gs-reg-list a+d a+d a+d a+d a+d a+d a+d a+d a+d a+d a+d a+d a+d a+d a+d a+d)
                                   )

      ;; gs regs
      (dma-buffer-add-uint64 ,buf
          ,@(apply2 (lambda (x) x) (lambda (x) `(gs-reg64 ,x)) reg-datas reg-names)
          )
      )
    )
  )

(defmacro with-dma-bucket (bindings &rest body)
  "Start a new dma-bucket in body that will be finished at the end.
   The bindings are the dma-buffer, dma-bucket and bucket-id respectively."

  (let ((buf (first bindings))
        (bucket (second bindings))
        (bucket-id (third bindings))
        )

      (with-gensyms (buf-start bucket-edge pkt)
        `(let ((,buf-start (-> ,buf base)))

            ,@body

            ;; we end the chain with a next.  The bucket system will patch the next chain to this,
            ;; and then patch all the buckets togehter before sending the DMA.
            (let ((,bucket-edge (the (pointer dma-tag) (-> ,buf base))))
                (let ((,pkt (the-as dma-packet (-> ,buf base))))

                  (set! (-> ,pkt dma) (new 'static 'dma-tag :id (dma-tag-id next)))
                  (set! (-> ,pkt vif0) (new 'static 'vif-tag :cmd (vif-cmd nop)))
                  (set! (-> ,pkt vif1) (new 'static 'vif-tag :cmd (vif-cmd nop)))

                  (set! (-> ,buf base) (&+ (the-as pointer ,pkt) (size-of dma-packet)))

                  )
                (dma-bucket-insert-tag ,bucket ,bucket-id
                      ,buf-start ;; the first thing in this chain, bucket will patch previous to this
                      ,bucket-edge ;; end of this chain (ptr to next tag)
                      )
                )
            )
        )

      )
  )

(defmacro with-dma-buffer-add-bucket (bindings &key (bucket-group (-> (current-frame) bucket-group)) &rest body)
  "Bind a dma-buffer to a variable and use it on a block to allow adding things to a new bucket.
   usage: (with-dma-buffer-add-bucket ((buffer-name buffer) bucket-id) &rest body)
   example: (with-dma-buffer-add-bucket ((buf (-> (current-frame) debug-buf)) (bucket-id debug-no-zbuf)) ...)"

  `(let ((,(caar bindings) ,(cadar bindings)))
    (with-dma-bucket (,(caar bindings) ,bucket-group ,(cadr bindings))
      ,@body
      )
    )
  )

(defmacro def-mips2c (name type)
  "Define a mips2c object (typically a function)."
  `(begin
     (define-extern ,name ,type)
     (set! ,name (the-as ,type (__pc-get-mips2c ,(symbol->string name))))
     )
  )

(defmacro copy-and-set-field (original field-name field-value)
  `(let ((temp-copy ,original))
     (set! (-> temp-copy ,field-name) ,field-value)
     temp-copy
     )
  )

(defmacro res-lump-data (lump name type &key (tag-ptr (the-as (pointer res-tag) #f)) &key (time -1000000000.0))
  "Helper macro to get data from a res-lump without interpolation."
  `(the-as ,type ((method-of-type res-lump get-property-data)
                  ,lump
                  ,name
                  'interp
                  ,time
                  (the-as pointer #f)
                  ,tag-ptr
                  *res-static-buf*
                  )
           )
  )

(defmacro res-lump-data-exact (lump name type &key (tag-ptr (the-as (pointer res-tag) #f)) &key (time 0.0))
  "Helper macro to get start of data from a res-lump."
  `(the-as ,type ((method-of-type res-lump get-property-data)
                  ,lump
                  ,name
                  'exact
                  ,time
                  (the-as pointer #f)
                  ,tag-ptr
                  *res-static-buf*
                  )
           )
  )

(defmacro res-lump-struct (lump name type &key (tag-ptr (the-as (pointer res-tag) #f)) &key (time -1000000000.0))
  `(the-as ,type ((method-of-type res-lump get-property-struct)
                  ,lump
                  ,name
                  'interp
                  ,time
                  (the-as structure #f)
                  ,tag-ptr
                  *res-static-buf*
                  )
           )
  )

(defmacro res-lump-struct-exact (lump name type &key (tag-ptr (the-as (pointer res-tag) #f)) &key (time 0.0))
  `(the-as ,type ((method-of-type res-lump get-property-struct)
                  ,lump
                  ,name
                  'exact
                  ,time
                  (the-as structure #f)
                  ,tag-ptr
                  *res-static-buf*
                  )
           )
  )

(defmacro res-lump-value (lump name type &key (tag-ptr (the-as (pointer res-tag) #f)) &key (default (the-as uint128 0)) &key (time -1000000000.0))
  "Helper macro to get a value from a res-lump with no interpolation."
  `(the-as ,type ((method-of-type res-lump get-property-value)
                  ,lump
                  ,name
                  'interp
                  ,time
                  ,default
                  ,tag-ptr
                  *res-static-buf*
                  )
           )
  )

(defmacro res-lump-float (lump name &key (tag-ptr (the-as (pointer res-tag) #f)) &key (default 0.0) &key (time -1000000000.0))
  "Helper macro to get a float from a res-lump with no interpolation."
  `((method-of-type res-lump get-property-value-float)
                  ,lump
                  ,name
                  'interp
                  ,time
                  ,default
                  ,tag-ptr
                  *res-static-buf*
                  )
  )

;; cause the current process to change state
(defmacro go (next-state &rest args)
  `(with-pp
     (go-hook pp ,next-state ,@args)
     )
  )

(defmacro go-virtual (state-name &key (proc self) &rest args)
  "Change the current process to the virtual state of the given process."
  `(go (method-of-object ,proc ,state-name) ,@args)
  )

;; run the given function in a process right now.
;; will return to here when:
;;  - you return
;;  - you deactivate
;;  - you go
;;  - you throw to 'initialize
(defmacro run-now-in-process (proc func &rest args)
  `((the (function _varargs_ object) run-function-in-process)
    ,proc ,func ,@args
    )
  )

;; sets the main thread of the given process to run the given thing.
;; this resets the main thread stack back to the top
(defmacro run-next-time-in-process (proc func &rest args)
  `((the (function _varargs_ object) set-to-run)
    (-> ,proc main-thread) ,func ,@args
    )
  )

(defmacro send-event (proc msg &key (from (with-pp pp)) &rest params)
  "Send an event to a process. This should be used over send-event-function"

  `(let ((event-data (new 'stack-no-clear 'event-message-block)))
        (set! (-> event-data from) (process->ppointer ,from))
        (set! (-> event-data num-params) ,(length params))
        (set! (-> event-data message) ,msg)
        ,@(apply-i (lambda (x i) `(set! (-> event-data param ,i) (the-as uint ,x))) params)
        (send-event-function ,proc event-data)
        )
  )

(defmacro setting-control-func! (func s &rest args)
  (let ((argb #f)
        (argi 0)
        (argf 0.0)
        (setting (cadr s)))
    (cond
      (#t
        (set! argb (car args))
        (set! argf (cadr args))
        (set! argi (caddr args))
        )
      )
    `(,func *setting-control* (with-pp pp) ,s ,argb ,argf ,argi)
    )
  )

(defmacro add-setting! (s &rest args)
  `(setting-control-func! add-setting ,s ,@args)
  )
(defmacro set-setting! (s &rest args)
  `(setting-control-func! set-setting ,s ,@args)
  )
(defmacro remove-setting! (s)
  `(remove-setting *setting-control* (with-pp pp) ,s)
  )

(defmacro static-sound-name (str)
  "Convert a string constant to a static sound-name."

  ;; all this is done at compile-time so we can come up with 2
  ;; 64-bit constants to use
  (when (> (string-length str) 16)
    (error "static-sound-name got a string that is too long")
    )
  (let ((lo-val 0)
        (hi-val 0)
        )
    (dotimes (i (string-length str))
      (if (>= i 8)
          (+! hi-val (ash (string-ref str i) (* 8 (- i 8))))
          (+! lo-val (ash (string-ref str i) (* 8 i)))
          )
      )
    `(new 'static 'sound-name :lo ,lo-val :hi ,hi-val)
    )
  )

(defmacro time-elapsed? (time duration)
  `(>= (- (current-time) ,time) ,duration)
  )

(defconstant *scratch-memory-top* (the pointer #x70004000))
(defconstant DPROCESS_STACK_SIZE #x8000)

(defmacro process-spawn-function (proc-type func &key (from *default-dead-pool*) &key (to *default-pool*) &key (name #f) &key (stack-size #x4000) &key (stack *scratch-memory-top*) &rest args)
  "Start a new process that runs a function on its main thread.
   Returns a pointer to the new process (or #f? on error)."

  (with-gensyms (new-proc)
    `(let ((,new-proc (the-as ,proc-type (get-process ,from ,proc-type ,stack-size 1))))
        (when ,new-proc
          ((method-of-type ,proc-type activate) ,new-proc ,to ,(if name name `(symbol->string (-> ,proc-type symbol))) ,stack)
          (run-next-time-in-process ,new-proc ,func ,@args)
          (the (pointer ,proc-type) (-> ,new-proc ppointer))
          )
        )
    )
  )