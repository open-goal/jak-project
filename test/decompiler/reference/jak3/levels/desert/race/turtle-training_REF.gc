;;-*-Lisp-*-
(in-package goal)

;; definition of type des-train-bollard
(deftype des-train-bollard (process-drawable)
  ((root  collide-shape :override)
   )
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type des-train-bollard
(defmethod inspect ((this des-train-bollard))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-des-train-bollard des-train-bollard des-train-bollard-lod0-jg des-train-bollard-idle-ja
              ((des-train-bollard-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 5 0 5.2)
              )

;; failed to figure out what this is:
(defstate idle (des-train-bollard)
  :virtual #t
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post ja-post
  )

;; definition for method 11 of type des-train-bollard
(defmethod init-from-entity! ((this des-train-bollard) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) 0.0 20480.0 0.0 21299.2)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-des-train-bollard" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (update-transforms (-> this root))
  (go (method-of-object this idle))
  )

;; definition of type des-train-barrier
(deftype des-train-barrier (process-drawable)
  ()
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type des-train-barrier
(defmethod inspect ((this des-train-barrier))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-des-train-barrier des-train-barrier des-train-barrier-lod0-jg des-train-barrier-idle-ja
              ((des-train-barrier-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 1 0 4)
              )

;; failed to figure out what this is:
(defstate idle (des-train-barrier)
  :virtual #t
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post ja-post
  )

;; definition for method 11 of type des-train-barrier
(defmethod init-from-entity! ((this des-train-barrier) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) 0.0 4096.0 0.0 16384.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-des-train-barrier" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (go (method-of-object this idle))
  )

;; definition of type des-train-stones
(deftype des-train-stones (process-drawable)
  ()
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type des-train-stones
(defmethod inspect ((this des-train-stones))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-des-train-stones des-train-stones des-train-stones-lod0-jg des-train-stones-idle-ja
              ((des-train-stones-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 12)
              )

;; failed to figure out what this is:
(defstate idle (des-train-stones)
  :virtual #t
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post ja-post
  )

;; definition for method 11 of type des-train-stones
(defmethod init-from-entity! ((this des-train-stones) (arg0 entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-des-train-stones" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (go (method-of-object this idle))
  )

;; definition of type turtle-training-goal
(deftype turtle-training-goal (structure)
  ((pos  vector  :inline)
   )
  )

;; definition for method 3 of type turtle-training-goal
(defmethod inspect ((this turtle-training-goal))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'turtle-training-goal)
  (format #t "~1Tpos: #<vector @ #x~X>~%" (-> this pos))
  (label cfg-4)
  this
  )

;; definition of type task-manager-desert-turtle-training
(deftype task-manager-desert-turtle-training (task-manager)
  ((goal-array       turtle-training-goal  7 :inline)
   (door-plane       vector                :inline)
   (start-pos        vector                :inline)
   (goal-pos         vector                :inline)
   (player-pos       vector                :inline)
   (player-vel       vector                :inline)
   (player-controls  vehicle-controls      :inline)
   (test-time        time-frame)
   (max-count        int16)
   (show-message?    symbol)
   )
  (:methods
    (print-training-text (_type_ text-id) none)
    )
  )

;; definition for method 3 of type task-manager-desert-turtle-training
(defmethod inspect ((this task-manager-desert-turtle-training))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type task-manager inspect)))
    (t9-0 this)
    )
  (format #t "~2Tgoal-array[7] @ #x~X~%" (-> this goal-array))
  (format #t "~2Tdoor-plane: #<vector @ #x~X>~%" (-> this door-plane))
  (format #t "~2Tstart-pos: #<vector @ #x~X>~%" (-> this start-pos))
  (format #t "~2Tgoal-pos: #<vector @ #x~X>~%" (-> this goal-pos))
  (format #t "~2Tplayer-pos: #<vector @ #x~X>~%" (-> this player-pos))
  (format #t "~2Tplayer-vel: #<vector @ #x~X>~%" (-> this player-vel))
  (format #t "~2Tplayer-controls: #<vehicle-controls @ #x~X>~%" (-> this player-controls))
  (format #t "~2Ttest-time: ~D~%" (-> this test-time))
  (format #t "~2Tmax-count: ~D~%" (-> this max-count))
  (format #t "~2Tshow-message?: ~A~%" (-> this show-message?))
  (label cfg-4)
  this
  )

;; definition for method 21 of type task-manager-desert-turtle-training
;; INFO: Used lq/sq
(defmethod set-time-limit ((this task-manager-desert-turtle-training))
  (local-vars (sv-16 res-tag))
  (let ((t9-0 (method-of-type task-manager set-time-limit)))
    (t9-0 this)
    )
  (set! (-> this start-pos quad) (-> (new 'static 'vector :x 11540444.0 :y 91835.19 :z 956374.6 :w 1.0) quad))
  (set! (-> this door-plane quad) (-> (new 'static 'vector :z 1.0 :w 1.0) quad))
  (set! (-> this door-plane w)
        (- (vector-dot (-> this door-plane) (new 'static 'vector :x 9277440.0 :y 125747.2 :z 957235.2 :w 1.0)))
        )
  (set! (-> this max-count) 0)
  (let ((a0-8 (entity-by-name "training-1")))
    (when a0-8
      (set! sv-16 (new 'static 'res-tag))
      (let ((v1-7 (res-lump-data a0-8 'actor-groups (pointer actor-group) :tag-ptr (& sv-16))))
        (cond
          ((and v1-7 (nonzero? (-> sv-16 elt-count)))
           (set! (-> this max-count) (-> v1-7 0 length))
           (dotimes (a0-13 (-> this max-count))
             (let ((a1-7 (-> v1-7 0 data a0-13 actor)))
               (set! (-> this goal-array a0-13 pos quad) (-> a1-7 extra trans quad))
               )
             )
           )
          (else
            (format 0 "ERROR: task-manager-desert-turtle-training: missing actor-group!~%")
            )
          )
        )
      )
    )
  (spawn-dust-storm-randomizer this)
  (none)
  )

;; definition for method 32 of type task-manager-desert-turtle-training
;; WARN: Return type mismatch int vs none.
(defmethod print-training-text ((this task-manager-desert-turtle-training) (arg0 text-id))
  (let ((s5-0
          (new 'stack 'font-context *font-default-matrix* 70 20 0.0 (font-color orange) (font-flags shadow kerning))
          )
        )
    (let ((v1-1 s5-0))
      (set! (-> v1-1 scale) 0.7)
      )
    (let ((v1-2 s5-0))
      (set! (-> v1-2 width) (the float 370))
      )
    (let ((v1-3 s5-0))
      (set! (-> v1-3 height) (the float 70))
      )
    (set! (-> s5-0 origin x) (the float (- 201 (the int (/ (-> s5-0 width) 2)))))
    (set! (-> s5-0 origin y) 290.0)
    (set! (-> s5-0 flags) (font-flags shadow kerning middle-vert large))
    (let ((s4-0 print-game-text))
      (format (clear *temp-string*) (lookup-text! *common-text* arg0 #f) 1)
      (s4-0 *temp-string* s5-0 #f 44 (bucket-id hud-draw-hud-alpha))
      )
    )
  0
  (none)
  )

;; definition for method 26 of type task-manager-desert-turtle-training
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod task-manager-method-26 ((this task-manager-desert-turtle-training))
  (let ((t9-0 (method-of-type task-manager task-manager-method-26)))
    (t9-0 this)
    )
  (let ((a0-3 (handle->process (-> this player-vehicle))))
    (when (not a0-3)
      (let ((v1-5 *target*))
        (if (and v1-5 (focus-test? v1-5 pilot-riding))
            (set! (-> this player-vehicle) (-> v1-5 pilot vehicle))
            )
        )
      )
    (when a0-3
      (set! (-> this player-pos quad) (-> (the-as process-drawable a0-3) root trans quad))
      (set! (-> this player-vel quad) (-> (the-as process-drawable a0-3) root transv quad))
      (copy-vehicle-controls! (the-as wvehicle a0-3) (-> this player-controls))
      0
      )
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate active (task-manager-desert-turtle-training)
  :virtual #t
  :code (behavior ()
    (set-setting! 'pilot-exit #f 0.0 0)
    (set-setting! 'pilot-death #t 0.0 0)
    (set-setting! 'scarf 'abs 1.0 0)
    (set-setting! 'goggles 'abs 1.0 0)
    (let ((t1-4 1))
      (set-setting! 'vehicles 'set (shr t1-4 32) t1-4)
      )
    (add-process *gui-control* self (gui-channel query) (gui-action play) (-> self name) -99.0 0)
    (while (not (handle->process (-> self player-vehicle)))
      (suspend)
      )
    (suspend)
    (send-event (handle->process (-> self player-vehicle)) 'ignore-damage #t)
    (set-time! (-> self test-time))
    (set! (-> self goal-pos quad) (-> self goal-array 0 pos quad))
    (let ((gp-0 (new 'stack-no-clear 'task-arrow-params)))
      (set! (-> gp-0 pos quad) (-> self goal-pos quad))
      (quaternion-identity! (-> gp-0 quat))
      (set! (-> gp-0 flags) (task-arrow-flags))
      (set! (-> gp-0 map-icon) (the-as uint 12))
      (set! (-> self arrow) (process->handle (task-arrow-spawn gp-0 self)))
      )
    (suspend-for (seconds 4)
      (print-training-text self (text-id text-05e6))
      )
    (suspend-for (seconds 0.25)
      )
    (set! (-> self time-limit) (seconds 30))
    (set-time! (-> self start-time))
    (until #f
      (print-training-text self (text-id text-0583))
      (if (< 102400.0 (vector-length (-> self player-vel)))
          (goto cfg-29)
          )
      (suspend)
      )
    #f
    (until #f
      (label cfg-29)
      (if (< (vector-vector-xz-distance (-> self player-pos) (-> self goal-pos)) 40960.0)
          (goto cfg-33)
          )
      (suspend)
      )
    #f
    (label cfg-33)
    (sound-play "special-pickup")
    (send-event (handle->process (-> self arrow)) 'leave)
    (set! (-> self arrow) (the-as handle #f))
    (send-event (handle->process (-> self hud-timer)) 'hide-and-die)
    (set! (-> self start-time) 0)
    (suspend-for (seconds 0.25)
      )
    (set! (-> self show-message?) #f)
    (set! (-> self goal-pos quad) (-> self goal-array 1 pos quad))
    (let ((gp-5 (new 'stack-no-clear 'task-arrow-params)))
      (set! (-> gp-5 pos quad) (-> self goal-pos quad))
      (quaternion-identity! (-> gp-5 quat))
      (set! (-> gp-5 flags) (task-arrow-flags))
      (set! (-> gp-5 map-icon) (the-as uint 12))
      (set! (-> self arrow) (process->handle (task-arrow-spawn gp-5 self)))
      )
    (set! (-> self time-limit) (seconds 30))
    (set-time! (-> self start-time))
    (until #f
      (if (< (vector-vector-xz-distance (-> self player-pos) (-> self goal-pos)) 245760.0)
          (set! (-> self show-message?) #t)
          )
      (when (-> self show-message?)
        (print-training-text self (text-id text-0584))
        (if (and (< 0.1 (-> self player-controls brake)) (< (vector-length (-> self player-vel)) 8192.0))
            (goto cfg-68)
            )
        )
      (suspend)
      )
    #f
    (label cfg-68)
    (sound-play "special-pickup")
    (send-event (handle->process (-> self arrow)) 'leave)
    (set! (-> self arrow) (the-as handle #f))
    (send-event (handle->process (-> self hud-timer)) 'hide-and-die)
    (set! (-> self start-time) 0)
    (suspend-for (seconds 0.25)
      )
    (set! (-> self time-limit) (seconds 28))
    (set-time! (-> self start-time))
    (set-time! (-> self test-time))
    (until #f
      (print-training-text self (text-id text-0587))
      (if (not (cpad-hold? 0 l2))
          (set-time! (-> self test-time))
          )
      (if (time-elapsed? (-> self test-time) (seconds 0.665))
          (goto cfg-91)
          )
      (suspend)
      )
    #f
    (label cfg-91)
    (sound-play "special-pickup")
    (send-event (handle->process (-> self hud-timer)) 'hide-and-die)
    (set! (-> self start-time) 0)
    (suspend-for (seconds 0.25)
      )
    (set! (-> self show-message?) #f)
    (set! (-> self goal-pos quad) (-> self goal-array 2 pos quad))
    (let ((gp-10 (new 'stack-no-clear 'task-arrow-params)))
      (set! (-> gp-10 pos quad) (-> self goal-pos quad))
      (quaternion-identity! (-> gp-10 quat))
      (set! (-> gp-10 flags) (task-arrow-flags))
      (set! (-> gp-10 map-icon) (the-as uint 12))
      (set! (-> self arrow) (process->handle (task-arrow-spawn gp-10 self)))
      )
    (set! (-> self time-limit) (seconds 30))
    (set-time! (-> self start-time))
    (until #f
      (let ((f0-5 (vector-vector-xz-distance (-> self player-pos) (-> self goal-pos))))
        (cond
          ((-> self show-message?)
           (if (< 163840.0 f0-5)
               (set! (-> self show-message?) #f)
               )
           )
          (else
            (if (< f0-5 40960.0)
                (set! (-> self show-message?) #t)
                )
            )
          )
        )
      (when (-> self show-message?)
        (print-training-text self (text-id text-0588))
        (let ((v1-176 (handle->process (-> self player-vehicle))))
          (when v1-176
            (if (and (logtest? (vehicle-flag reverse-gear) (-> (the-as wvehicle v1-176) v-flags))
                     (< 36864.0 (vector-length (-> self player-vel)))
                     )
                (goto cfg-127)
                )
            )
          )
        )
      (suspend)
      )
    #f
    (label cfg-127)
    (sound-play "special-pickup")
    (send-event (handle->process (-> self arrow)) 'leave)
    (set! (-> self arrow) (the-as handle #f))
    (send-event (handle->process (-> self hud-timer)) 'hide-and-die)
    (set! (-> self start-time) 0)
    (suspend-for (seconds 0.25)
      )
    (set! (-> self goal-pos quad) (-> self goal-array 3 pos quad))
    (let ((gp-13 (new 'stack-no-clear 'task-arrow-params)))
      (set! (-> gp-13 pos quad) (-> self goal-pos quad))
      (quaternion-identity! (-> gp-13 quat))
      (set! (-> gp-13 flags) (task-arrow-flags))
      (set! (-> gp-13 map-icon) (the-as uint 12))
      (set! (-> self arrow) (process->handle (task-arrow-spawn gp-13 self)))
      )
    (set! (-> self time-limit) (seconds 35))
    (set-time! (-> self start-time))
    (until #f
      (let ((f30-0 (vector-vector-xz-distance (-> self player-pos) (-> self goal-pos))))
        (when (< f30-0 696320.0)
          (print-training-text self (text-id text-0589))
          (if (< f30-0 40960.0)
              (goto cfg-154)
              )
          )
        )
      (suspend)
      )
    #f
    (label cfg-154)
    (sound-play "special-pickup")
    (send-event (handle->process (-> self arrow)) 'leave)
    (set! (-> self arrow) (the-as handle #f))
    (send-event (handle->process (-> self hud-timer)) 'hide-and-die)
    (set! (-> self start-time) 0)
    (suspend-for (seconds 0.25)
      )
    (set! (-> self goal-pos quad) (-> self goal-array 4 pos quad))
    (let ((gp-16 (new 'stack-no-clear 'task-arrow-params)))
      (set! (-> gp-16 pos quad) (-> self goal-pos quad))
      (quaternion-identity! (-> gp-16 quat))
      (set! (-> gp-16 flags) (task-arrow-flags))
      (set! (-> gp-16 map-icon) (the-as uint 12))
      (set! (-> self arrow) (process->handle (task-arrow-spawn gp-16 self)))
      )
    (set! (-> self time-limit) (seconds 45))
    (set-time! (-> self start-time))
    (until #f
      (let ((f30-1 (vector-vector-xz-distance (-> self player-pos) (-> self goal-pos))))
        (when (< f30-1 819200.0)
          (print-training-text self (text-id text-058a))
          (if (and (< f30-1 40960.0)
                   (< 61440.0 (vector-length (-> self player-vel)))
                   (< 0.5 (-> self player-controls handbrake))
                   (< 0.5 (fabs (-> self player-controls steering)))
                   )
              (goto cfg-195)
              )
          )
        )
      (suspend)
      )
    #f
    (label cfg-195)
    (sound-play "special-pickup")
    (send-event (handle->process (-> self arrow)) 'leave)
    (set! (-> self arrow) (the-as handle #f))
    (send-event (handle->process (-> self hud-timer)) 'hide-and-die)
    (set! (-> self start-time) 0)
    (suspend-for (seconds 0.25)
      )
    (set! (-> self goal-pos quad) (-> self goal-array 5 pos quad))
    (let ((gp-19 (new 'stack-no-clear 'task-arrow-params)))
      (set! (-> gp-19 pos quad) (-> self goal-pos quad))
      (quaternion-identity! (-> gp-19 quat))
      (set! (-> gp-19 flags) (task-arrow-flags))
      (set! (-> gp-19 map-icon) (the-as uint 12))
      (set! (-> self arrow) (process->handle (task-arrow-spawn gp-19 self)))
      )
    (set! (-> self time-limit) (seconds 45))
    (set-time! (-> self start-time))
    (until #f
      (when (< (vector-vector-xz-distance (-> self player-pos) (-> self goal-pos)) 40960.0)
        (print-training-text self (text-id text-058b))
        (let ((v1-299 (-> self player-vel)))
          (if (and (< (sqrtf (+ (* (-> v1-299 x) (-> v1-299 x)) (* (-> v1-299 z) (-> v1-299 z)))) 20480.0)
                   (and (logtest? (-> self player-controls flags) (vehicle-controls-flag vcf0))
                        (< 0.5 (fabs (-> self player-controls steering)))
                        )
                   )
              (goto cfg-230)
              )
          )
        )
      (suspend)
      )
    #f
    (label cfg-230)
    (sound-play "special-pickup")
    (send-event (handle->process (-> self arrow)) 'leave)
    (set! (-> self arrow) (the-as handle #f))
    (send-event (handle->process (-> self hud-timer)) 'hide-and-die)
    (set! (-> self start-time) 0)
    (task-node-close! (game-task-node desert-course-race-restrict-to-turtle) 'event)
    (let ((t9-62 (-> (the-as (state task-manager) (find-parent-state)) code)))
      (if t9-62
          ((the-as (function none) t9-62))
          )
      )
    )
  )
