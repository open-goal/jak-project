;;-*-Lisp-*-
(in-package goal)

;; definition of type cav-break-bridge
(deftype cav-break-bridge (process-drawable)
  ()
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type cav-break-bridge
(defmethod inspect ((this cav-break-bridge))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defstate idle (cav-break-bridge)
  :virtual #t
  :enter (behavior ()
    (transform-post)
    )
  :code sleep-code
  )

;; definition for method 11 of type cav-break-bridge
(defmethod init-from-entity! ((this cav-break-bridge) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec enemy))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 transform-index) 4)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 49152.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> v1-9 prim-core action) (collide-action solid))
      (set! (-> v1-9 transform-index) 3)
      (set-vector! (-> v1-9 local-sphere) 21.7088 769.2288 5129.8306 14745.19)
      )
    (let ((v1-11 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-11 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> v1-11 prim-core action) (collide-action solid))
      (set! (-> v1-11 transform-index) 4)
      (set-vector! (-> v1-11 local-sphere) -10593.075 -778.24 26691.584 37455.87)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-14 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-14 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-14 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cav-break-bridge" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (when (task-node-closed? (game-task-node mine-boss-introduction))
    (cleanup-for-death this)
    (deactivate this)
    )
  (go (method-of-object this idle))
  )

;; definition for method 20 of type cav-railblocker
;; WARN: Return type mismatch int vs search-info-flag.
(defmethod process-mask->search-info-flag ((this cav-railblocker))
  (the-as search-info-flag (if (-> this trackable)
                               24
                               1
                               )
          )
  )

;; definition for method 30 of type cav-railblocker
;; WARN: Return type mismatch connection vs none.
(defmethod cav-railblocker-method-30 ((this cav-railblocker) (arg0 symbol))
  (when (>= (- (current-time) (-> this red-tip-change-time)) 0)
    (set! (-> this alt-red-tip-on) (not (-> this alt-red-tip-on)))
    (let* ((f30-0 37.5)
           (v1-8 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
           (v1-9 (the-as number (logior #x3f800000 v1-8)))
           )
      (set! (-> this red-tip-change-time)
            (the-as time-frame (+ (the int (* f30-0 (+ -1.0 (the-as float v1-9)))) 150 (current-time)))
            )
      )
    (set! arg0 #t)
    )
  (when arg0
    (remove-from-process *part-engine* this)
    (if (-> this alt-red-tip-on)
        (add-connection *part-engine* this 5 this 4490 (new 'static 'vector :w 819200.0))
        (add-connection *part-engine* this 6 this 4490 (new 'static 'vector :w 819200.0))
        )
    (add-connection *part-engine* this 7 this 4489 (new 'static 'vector :w 819200.0))
    )
  (none)
  )

;; failed to figure out what this is:
(defstate idle (cav-railblocker)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (when (or (not (-> self notify-on-die)) (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
                                                 (set! (-> a1-1 from) (process->ppointer self))
                                                 (set! (-> a1-1 num-params) 1)
                                                 (set! (-> a1-1 message) 'railblocker-hittable?)
                                                 (set! (-> a1-1 param 0) (the-as uint #t))
                                                 (let ((t9-0 send-event-function)
                                                       (v1-7 (-> self notify-on-die))
                                                       )
                                                   (t9-0
                                                     (if v1-7
                                                         (-> v1-7 extra process)
                                                         )
                                                     a1-1
                                                     )
                                                   )
                                                 )
                 )
         (let ((f0-0 1.0)
               (v1-11 (the-as attack-info (-> block param 1)))
               )
           (when (and (or (not (logtest? (-> v1-11 mask) (attack-mask id))) (!= (-> self incoming-attack-id) (-> v1-11 id)))
                      (!= (-> self hit-points) 0.0)
                      )
             (if (logtest? (-> v1-11 mask) (attack-mask id))
                 (set! (-> self incoming-attack-id) (-> v1-11 id))
                 )
             (if (logtest? (attack-mask damage) (-> v1-11 mask))
                 (set! f0-0 (-> v1-11 damage))
                 )
             (if (logtest? (-> *game-info* secrets) (game-secrets hero-mode))
                 (set! f0-0 (* 0.6666667 f0-0))
                 )
             (set! (-> self hit-points) (fmax 0.0 (- (-> self hit-points) f0-0)))
             (cond
               ((= (-> self hit-points) 0.0)
                (go-virtual fall)
                )
               ((< (-> self hit-points) 5.0)
                (setup-masks (-> self draw) 8 22)
                )
               ((< (-> self hit-points) 10.0)
                (setup-masks (-> self draw) 6 24)
                )
               (else
                 (setup-masks (-> self draw) 0 12)
                 )
               )
             )
           )
         )
       #t
       )
      )
    )
  :enter (behavior ()
    (transform-post)
    (cav-railblocker-method-30 self #t)
    )
  :trans (behavior ()
    (set! (-> self trackable)
          (the-as symbol (or (not (-> self notify-on-die)) (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
                                                             (set! (-> a1-0 from) (process->ppointer self))
                                                             (set! (-> a1-0 num-params) 1)
                                                             (set! (-> a1-0 message) 'railblocker-hittable?)
                                                             (set! (-> a1-0 param 0) (the-as uint #f))
                                                             (let ((t9-0 send-event-function)
                                                                   (v1-5 (-> self notify-on-die))
                                                                   )
                                                               (t9-0
                                                                 (if v1-5
                                                                     (-> v1-5 extra process)
                                                                     )
                                                                 a1-0
                                                                 )
                                                               )
                                                             )
                             )
                  )
          )
    (cav-railblocker-method-30 self #f)
    )
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate fall (cav-railblocker)
  :virtual #t
  :enter (behavior ()
    (let ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-cav-railblocker-explode" (the-as (pointer level) #f))
        5
        gp-0
        *cav-railblocker-exploder-params*
        :name "joint-exploder"
        :to self
        :unk 0
        )
      )
    (let ((gp-1 (new 'stack-no-clear 'explosion-init-params)))
      (set! (-> gp-1 spawn-point quad) (-> self root trans quad))
      (quaternion-identity! (-> gp-1 spawn-quat))
      (set! (-> gp-1 radius) 8192.0)
      (set! (-> gp-1 scale) 1.0)
      (set! (-> gp-1 group) (-> *part-group-id-table* 218))
      (set! (-> gp-1 collide-with) (collide-spec))
      (set! (-> gp-1 damage) 2.0)
      (set! (-> gp-1 damage-scale) 1.0)
      (set! (-> gp-1 vehicle-damage-factor) 1.0)
      (set! (-> gp-1 vehicle-impulse-factor) 1.0)
      (set! (-> gp-1 ignore-proc) (process->handle #f))
      (explosion-spawn gp-1 (the-as process-drawable *default-pool*))
      )
    (set-time! (-> self state-time))
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (let ((v1-22 (-> self root root-prim)))
      (set! (-> v1-22 prim-core collide-as) (collide-spec))
      (set! (-> v1-22 prim-core collide-with) (collide-spec))
      )
    0
    )
  :trans (behavior ()
    (when (+ (current-time) -1)
      (ja-channel-set! 0)
      (ja-post)
      )
    (let ((gp-0 (res-lump-value (-> self entity) 'animation-select uint128 :time -1000000000.0)))
      (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-1 from) (process->ppointer self))
        (set! (-> a1-1 num-params) 1)
        (set! (-> a1-1 message) 'blocker-died)
        (set! (-> a1-1 param 0) (the-as uint gp-0))
        (let ((t9-3 send-event-function)
              (v1-9 (-> self notify-on-die))
              )
          (t9-3
            (if v1-9
                (-> v1-9 extra process)
                )
            a1-1
            )
          )
        )
      (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-2 from) (process->ppointer self))
        (set! (-> a1-2 num-params) 1)
        (set! (-> a1-2 message) 'blocker-died)
        (set! (-> a1-2 param 0) (the-as uint gp-0))
        (let ((t9-4 send-event-function)
              (v1-15 (-> self notify-on-die-2))
              )
          (t9-4
            (if v1-15
                (-> v1-15 extra process)
                )
            a1-2
            )
          )
        )
      )
    (when (time-elapsed? (-> self state-time) (seconds 1))
      (cleanup-for-death self)
      (deactivate self)
      )
    )
  :code sleep-code
  )

;; definition for method 11 of type cav-railblocker
;; INFO: Used lq/sq
(defmethod init-from-entity! ((this cav-railblocker) (arg0 entity-actor))
  (local-vars (sv-16 res-tag))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set-vector! (-> v1-2 local-sphere) 0.0 8192.0 0.0 12288.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> s4-0 event-self) 'touched)
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cav-railblocker" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this root pause-adjust-distance) 409600.0)
  (set! (-> this draw light-index) (the-as uint 10))
  (set! (-> this incoming-attack-id) (the-as uint 0))
  (set! (-> this hit-points) 10.0)
  (set! (-> this trackable) #t)
  (set! (-> this notify-on-die) #f)
  (set! (-> this notify-on-die-2) #f)
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-17 (res-lump-data arg0 'actor-groups (pointer actor-group) :tag-ptr (& sv-16))))
    (when (and v1-17 (nonzero? (-> sv-16 elt-count)))
      (let ((v1-18 (-> v1-17 0)))
        (if (> (-> v1-18 length) 0)
            (set! (-> this notify-on-die) (-> v1-18 data 0 actor))
            )
        (if (< 1 (-> v1-18 length))
            (set! (-> this notify-on-die-2) (-> v1-18 data 1 actor))
            )
        )
      )
    )
  (set! (-> this red-tip-change-time) 0)
  (set! (-> this alt-red-tip-on) #f)
  (setup-masks (-> this draw) 0 12)
  (when (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete))
    (cleanup-for-death this)
    (deactivate this)
    )
  (go (method-of-object this idle))
  )

;; failed to figure out what this is:
(defstate idle (cav-minecar)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('blocker-died)
       (cleanup-for-death self)
       (deactivate self)
       )
      )
    )
  :enter (behavior ()
    (transform-post)
    )
  :code sleep-code
  )

;; definition for method 11 of type cav-minecar
(defmethod init-from-entity! ((this cav-minecar) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set-vector! (-> v1-2 local-sphere) 0.0 8192.0 0.0 4096.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> s4-0 event-self) 'touched)
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cav-minecar" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this draw light-index) (the-as uint 10))
  (when (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete))
    (cleanup-for-death this)
    (deactivate this)
    )
  (go (method-of-object this idle))
  )

;; failed to figure out what this is:
(defstate idle (prebot-sword)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (v0-1 object))
    (case message
      (('touch 'bonk 'attack)
       (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
         (set! (-> a1-3 from) (process->ppointer self))
         (set! (-> a1-3 num-params) 2)
         (set! (-> a1-3 message) 'attack)
         (set! (-> a1-3 param 0) (the-as uint #f))
         (set! (-> a1-3 param 1)
               (the-as uint (static-attack-info :mask (vehicle-impulse-factor) ((id (new-attack-id))
                                                                                (damage 2.0)
                                                                                (vehicle-damage-factor 1.0)
                                                                                (vehicle-impulse-factor 1.0)
                                                                                (shove-up (meters 1))
                                                                                (shove-back (meters 3))
                                                                                )
                                                )
                       )
               )
         (if (and (send-event-function proc a1-3) (= proc *target*))
             (sound-play "sword-hit-jak" :position (-> (the-as process-drawable proc) root trans))
             )
         )
       )
      (('scale)
       (set! (-> self blade-scale target) (the-as float (-> block param 0)))
       )
      (('use-pos-pitch)
       (set! v0-1 (-> block param 0))
       (set! (-> self use-pos-pitch) (the-as symbol v0-1))
       v0-1
       )
      (('whoosh-lead)
       (set! (-> self whoosh-lead) (the-as float (-> block param 0)))
       (set! v0-1 #t)
       (set! (-> self allow-whoosh) (the-as symbol v0-1))
       v0-1
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (local-vars (at-0 int))
    (rlet ((vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (clone-anim-once (ppointer->handle (-> self parent)) #t (-> self prefix))
      (update! (-> self blade-scale) 0.0)
      (set-vector! (-> self blade-jm scale) 1.0 (-> self blade-scale value) 1.0 1.0)
      (let ((gp-0 (vector<-cspace! (new 'stack-no-clear 'vector) (joint-node prebot-sword-lod0-jg blade)))
            (s5-0 (new 'stack-no-clear 'vector))
            )
        0.0
        (vector-float*! gp-0 gp-0 0.5)
        (vector+float*!
          gp-0
          gp-0
          (vector<-cspace! (new 'stack-no-clear 'vector) (joint-node prebot-sword-lod0-jg tip))
          0.5
          )
        (vector-! s5-0 gp-0 (-> self prev-position))
        (set! (-> self prev-position quad) (-> gp-0 quad))
        (let ((v1-13 s5-0))
          (.lvf vf1 (&-> s5-0 quad))
          (let ((f0-7 (-> self clock frames-per-second)))
            (.mov at-0 f0-7)
            )
          (.mov vf2 at-0)
          (.mov.vf vf1 vf0 :mask #b1000)
          (.mul.x.vf vf1 vf1 vf2 :mask #b111)
          (.svf (&-> v1-13 quad) vf1)
          )
        (let ((f30-1 (fabs (- (-> gp-0 x) (-> (target-pos 0) x)))))
          (when (time-elapsed? (-> self state-time) (seconds 0.05))
            (set! (-> self sword-sound-playing) #t)
            (let* ((s2-0 (new 'stack-no-clear 'vector))
                   (v1-19 gp-0)
                   (a0-19 (-> self parent))
                   (s2-1 (vector-! s2-0 v1-19 (-> (the-as prebot (if a0-19
                                                                     (the-as prebot (-> a0-19 0 self))
                                                                     )
                                                          )
                                                  entity
                                                  extra
                                                  trans
                                                  )
                                   )
                         )
                   (s3-2 (vector-! (new 'stack-no-clear 'vector) gp-0 (target-pos 0)))
                   (f28-0 (doppler-pitch-shift gp-0 s5-0))
                   (s4-3 (if (-> self alternate-sound)
                             (static-sound-spec "boss-sword-2" :group 0 :volume 0.0 :mask (pitch reg0))
                             (static-sound-spec "boss-sword" :group 0 :volume 0.0 :mask (pitch reg0))
                             )
                         )
                   )
              1.0
              (let ((f26-0 (lerp-scale
                             0.0
                             1.0
                             f30-1
                             (if (< f30-1 (-> self old-target-dist))
                                 40960.0
                                 20480.0
                                 )
                             0.0
                             )
                           )
                    )
                (let ((f0-13 (/ f28-0 500)))
                  (fmin 0.1 f0-13)
                  )
                (let ((f28-4 (+ 0.0
                                (lerp-scale 0.0 0.1 (-> s2-1 y) 20480.0 122880.0)
                                (lerp-scale 0.0 0.1 (-> s5-0 y) 204800.0 1024000.0)
                                (lerp-scale 0.0 -0.2 (-> s5-0 y) -204800.0 -1024000.0)
                                )
                             )
                      )
                  (when (-> self use-pos-pitch)
                    (+! f28-4 (/ f26-0 5))
                    (when (and (-> self allow-whoosh) (< (fabs (-> s3-2 x)) (-> self whoosh-lead)))
                      (set! (-> self allow-whoosh) #f)
                      (sound-play "sword-whoosh-by" :position gp-0)
                      )
                    )
                  (seek! (-> self current-volume) (lerp-scale 1.0 1.5 (vector-length s5-0) 204800.0 1024000.0) 0.02)
                  (set! (-> s4-3 volume) (the int (* 1024.0 (-> self current-volume))))
                  (set! (-> s4-3 pitch-mod) (the int (* 1524.0 f28-4)))
                  )
                )
              (sound-play-by-spec s4-3 (-> self sword-sound) gp-0)
              )
            )
          (set! (-> self old-target-dist) f30-1)
          )
        )
      )
    )
  :code sleep-code
  :post (behavior ()
    (transform-post)
    )
  )

;; definition for method 7 of type prebot-sword
(defmethod relocate ((this prebot-sword) (offset int))
  (if (nonzero? (-> this blade-jm))
      (&+! (-> this blade-jm) offset)
      )
  (call-parent-method this offset)
  )

;; definition for method 10 of type prebot-sword
(defmethod deactivate ((this prebot-sword))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (-> this sword-sound-playing)
      (sound-stop (-> this sword-sound))
      )
  ((method-of-type process-focusable deactivate) (the-as process-focusable this))
  (none)
  )

;; definition of type prebot-shockwave-joint-position
(deftype prebot-shockwave-joint-position (structure)
  ((joint-index  int8)
   (position     vector  :inline)
   )
  )

;; definition for method 3 of type prebot-shockwave-joint-position
(defmethod inspect ((this prebot-shockwave-joint-position))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'prebot-shockwave-joint-position)
  (format #t "~1Tjoint-index: ~D~%" (-> this joint-index))
  (format #t "~1Tposition: #<vector @ #x~X>~%" (-> this position))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defstate idle (prebot-shockwave)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch 'bonk)
       (if (= proc *target*)
           (send-event
             *target*
             'attack
             #f
             (static-attack-info :mask (vehicle-impulse-factor) ((id (new-attack-id))
                                                                 (damage 2.0)
                                                                 (vehicle-damage-factor 1.0)
                                                                 (vehicle-impulse-factor 1.0)
                                                                 (shove-up (meters 1))
                                                                 (shove-back (meters 3))
                                                                 )
                                 )
             )
           )
       )
      )
    )
  :trans (behavior ()
    (ja :num! (seek!))
    (if (ja-done? 0)
        (deactivate self)
        )
    (let ((gp-0 (new 'stack-no-clear 'collide-query))
          (s4-0 (new 'stack-no-clear 'bounding-box))
          (s5-0
            (new 'static 'boxed-array :type prebot-shockwave-joint-position
              (new 'static 'prebot-shockwave-joint-position :joint-index 33)
              (new 'static 'prebot-shockwave-joint-position :joint-index 15)
              (new 'static 'prebot-shockwave-joint-position :joint-index 29)
              (new 'static 'prebot-shockwave-joint-position :joint-index 13)
              (new 'static 'prebot-shockwave-joint-position :joint-index 27)
              (new 'static 'prebot-shockwave-joint-position :joint-index 11)
              (new 'static 'prebot-shockwave-joint-position :joint-index 25)
              (new 'static 'prebot-shockwave-joint-position :joint-index 19)
              (new 'static 'prebot-shockwave-joint-position :joint-index 31)
              (new 'static 'prebot-shockwave-joint-position :joint-index 17)
              (new 'static 'prebot-shockwave-joint-position :joint-index 36)
              )
            )
          )
      (vector<-cspace! (-> s4-0 min) (-> self node-list data (-> s5-0 (+ (-> s5-0 length) -1) joint-index)))
      (set! (-> s4-0 max quad) (-> s4-0 min quad))
      (set! (-> s5-0 (+ (-> s5-0 length) -1) position quad) (-> s4-0 min quad))
      (dotimes (s3-0 (+ (-> s5-0 length) -1))
        (let ((s2-0 (new 'stack-no-clear 'vector)))
          (vector<-cspace! (-> s5-0 s3-0 position) (-> self node-list data (-> s5-0 s3-0 joint-index)))
          (vector+! s2-0 (-> s5-0 s3-0 position) (new 'static 'vector :x 2048.0 :y 2048.0 :z 2048.0))
          (set! (-> s4-0 max x) (fmax (-> s2-0 x) (-> s4-0 max x)))
          (set! (-> s4-0 max y) (fmax (-> s2-0 y) (-> s4-0 max y)))
          (set! (-> s4-0 max z) (fmax (-> s2-0 z) (-> s4-0 max z)))
          (vector-! s2-0 (-> s5-0 s3-0 position) (new 'static 'vector :x 2048.0 :y 2048.0 :z 2048.0))
          (set! (-> s4-0 min x) (fmin (-> s2-0 x) (-> s4-0 min x)))
          (set! (-> s4-0 min y) (fmin (-> s2-0 y) (-> s4-0 min y)))
          (set! (-> s4-0 min z) (fmin (-> s2-0 z) (-> s4-0 min z)))
          )
        )
      (set! (-> gp-0 collide-with) (collide-spec jak player-list))
      (set! (-> gp-0 ignore-process0) #f)
      (set! (-> gp-0 ignore-process1) #f)
      (set! (-> gp-0 ignore-pat)
            (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
            )
      (set! (-> gp-0 action-mask) (collide-action solid))
      (mem-copy! (the-as pointer (-> gp-0 bbox)) (the-as pointer s4-0) 32)
      (fill-using-bounding-box *collide-cache* gp-0)
      (dotimes (s4-1 (+ (-> s5-0 length) -1))
        (set! (-> gp-0 start-pos quad) (-> s5-0 s4-1 position quad))
        (vector-! (-> gp-0 move-dist) (-> s5-0 (+ s4-1 1) position) (-> gp-0 start-pos))
        (let ((v1-52 gp-0))
          (set! (-> v1-52 radius) 2048.0)
          (set! (-> v1-52 collide-with) (collide-spec jak player-list))
          (set! (-> v1-52 ignore-process0) #f)
          (set! (-> v1-52 ignore-process1) #f)
          (set! (-> v1-52 ignore-pat)
                (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                )
          (set! (-> v1-52 action-mask) (collide-action solid))
          )
        (if (>= (probe-using-line-sphere *collide-cache* gp-0) 0.0)
            (send-event
              *target*
              'attack
              #f
              (static-attack-info :mask (vehicle-impulse-factor) ((id (new-attack-id))
                                                                  (damage 2.0)
                                                                  (vehicle-damage-factor 1.0)
                                                                  (vehicle-impulse-factor 1.0)
                                                                  (shove-up (meters 1))
                                                                  (shove-back (meters 3))
                                                                  )
                                  )
              )
            )
        )
      )
    )
  :code sleep-code
  :post (behavior ()
    (transform-post)
    )
  )

;; definition of type prebot-gun-shot
(deftype prebot-gun-shot (projectile)
  ((whoosh-sound  sound-id)
   )
  )

;; definition for method 3 of type prebot-gun-shot
(defmethod inspect ((this prebot-gun-shot))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type projectile inspect)))
    (t9-0 this)
    )
  (format #t "~2Twhoosh-sound: ~D~%" (-> this whoosh-sound))
  (label cfg-4)
  this
  )

;; definition for method 40 of type prebot-gun-shot
(defmethod projectile-method-40 ((this prebot-gun-shot))
  256
  )

;; definition for method 30 of type prebot-gun-shot
;; WARN: Return type mismatch int vs none.
(defmethod setup-collision! ((this prebot-gun-shot))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-projectile)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec projectile))
      (set! (-> v1-6 prim-core collide-with)
            (collide-spec
              backgnd
              jak
              crate
              civilian
              enemy
              obstacle
              vehicle-sphere
              hit-by-others-list
              player-list
              pusher
              shield
              )
            )
      (set! (-> v1-6 prim-core action) (collide-action solid))
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 3072.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> s5-0 max-iteration-count) (the-as uint 2))
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> this root) s5-0)
    )
  (set! (-> this root pat-ignore-mask)
        (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noproj #x1 :noendlessfall #x1 :board #x1)
        )
  0
  (none)
  )

;; definition for method 31 of type prebot-gun-shot
;; WARN: Return type mismatch int vs none.
(defmethod init-proj-settings! ((this prebot-gun-shot))
  (set! (-> this attack-mode) 'eco-dark)
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 1335) this))
  (set! (-> this sound-id) (new-sound-id))
  ((method-of-type projectile init-proj-settings!) this)
  0
  (none)
  )

;; definition for method 28 of type prebot-gun-shot
;; WARN: Return type mismatch sound-id vs none.
(defmethod play-impact-sound ((this prebot-gun-shot) (arg0 projectile-options))
  (let ((v1-0 arg0))
    (cond
      ((zero? v1-0)
       (sound-play "launch-bomb" :position (-> this root trans))
       (set! (-> this whoosh-sound) (sound-play "bomb-whoosh" :position (-> this root trans)))
       )
      ((= v1-0 (projectile-options po0))
       (sound-stop (-> this whoosh-sound))
       (sound-play "bomb-explode" :position (-> this root trans))
       )
      ((= v1-0 (projectile-options po0 po1))
       (let ((f0-0 (doppler-pitch-shift (-> this root trans) (-> this root transv)))
             (a0-16 (static-sound-spec "blue-trail" :group 0 :volume 0.0 :mask (pitch reg0)))
             )
         (set! (-> a0-16 volume) 1024)
         (set! (-> a0-16 pitch-mod) (the int (* 1524.0 f0-0)))
         (sound-play-by-spec a0-16 (-> this sound-id) (-> this root trans))
         )
       )
      )
    )
  (none)
  )

;; failed to figure out what this is:
(defstate moving (prebot-gun-shot)
  :virtual #t
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type projectile moving) trans)))
      (if t9-0
          (t9-0)
          )
      )
    (if (logtest? (collide-status
                    on-surface
                    on-ground
                    touch-surface
                    touch-wall
                    touch-ceiling
                    touch-actor
                    on-special-surface
                    touch-edge
                    no-touch
                    blocked
                    on-water
                    impact-surface
                    touch-background
                    stuck
                    touch-ceiling-sticky
                    glance
                    probe-hit
                    )
                  (-> self root status)
                  )
        (go-impact! self)
        )
    )
  )

;; failed to figure out what this is:
(defstate impact (prebot-gun-shot)
  :virtual #t
  :code (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    (let ((gp-0 (new 'stack-no-clear 'explosion-init-params)))
      (set! (-> gp-0 spawn-point quad) (-> self root trans quad))
      (quaternion-identity! (-> gp-0 spawn-quat))
      (set! (-> gp-0 radius) 8192.0)
      (set! (-> gp-0 scale) 1.0)
      (set! (-> gp-0 group) (-> *part-group-id-table* 1343))
      (set! (-> gp-0 collide-with)
            (collide-spec backgnd jak crate enemy obstacle vehicle-sphere hit-by-others-list player-list pusher shield)
            )
      (set! (-> gp-0 damage) 2.0)
      (set! (-> gp-0 damage-scale) 1.0)
      (set! (-> gp-0 vehicle-damage-factor) 1.0)
      (set! (-> gp-0 vehicle-impulse-factor) 1.0)
      (set! (-> gp-0 ignore-proc) (process->handle #f))
      (explosion-spawn gp-0 (ppointer->process (-> self parent)))
      )
    (send-event (ppointer->process (-> self parent)) 'shot-hit (-> self root trans))
    (let ((gp-1 (current-time)))
      (while (or (-> self child) (not (time-elapsed? gp-1 (seconds 10))))
        (suspend)
        )
      )
    (deactivate self)
    )
  )

;; failed to figure out what this is:
(defstate idle (prebot-gun)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('fire)
       (let ((gp-0 (new 'stack-no-clear 'projectile-init-by-other-params)))
         (set! (-> gp-0 ent) (-> self entity))
         (set! (-> gp-0 charge) 1.0)
         (set! (-> gp-0 options) (projectile-options))
         (logclear! (-> gp-0 options) (projectile-options po14 po15 po16))
         (set! (-> gp-0 pos quad)
               (-> (vector<-cspace! (new 'stack-no-clear 'vector) (joint-node prebot-gun-lod0-jg gunTip)) quad)
               )
         (set! (-> gp-0 vel quad) (-> (vector-normalize-copy!
                                        (new 'stack-no-clear 'vector)
                                        (-> self node-list data 7 bone transform uvec)
                                        (* 4096.0 (-> self clock frames-per-second))
                                        )
                                      quad
                                      )
               )
         (set! (-> gp-0 notify-handle) (the-as handle #f))
         (set! (-> gp-0 owner-handle) (the-as handle #f))
         (set! (-> gp-0 target-handle) (the-as handle #f))
         (set! (-> gp-0 target-pos quad) (the-as uint128 0))
         (set! (-> gp-0 ignore-handle) (process->handle self))
         (let* ((v1-18 *game-info*)
                (a0-10 (+ (-> v1-18 attack-id) 1))
                )
           (set! (-> v1-18 attack-id) a0-10)
           (set! (-> gp-0 attack-id) a0-10)
           )
         (set! (-> gp-0 timeout) (seconds 4))
         (spawn-projectile prebot-gun-shot gp-0 (ppointer->process (-> self parent)) *default-dead-pool*)
         )
       (if (logtest? (-> *part-group-id-table* 1334 flags) (sp-group-flag sp13))
           (part-tracker-spawn
             part-tracker-subsampler
             :to *entity-pool*
             :group (-> *part-group-id-table* 1334)
             :duration (seconds 1)
             :mat-joint (-> self node-list data 7 bone transform)
             )
           (part-tracker-spawn
             part-tracker
             :to *entity-pool*
             :group (-> *part-group-id-table* 1334)
             :duration (seconds 1)
             :mat-joint (-> self node-list data 7 bone transform)
             )
           )
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (clone-anim-once (ppointer->handle (-> self parent)) #t (-> self prefix))
    )
  :code sleep-code
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root))
    )
  )

;; definition for method 7 of type prebot-tentacle
(defmethod relocate ((this prebot-tentacle) (offset int))
  (if (nonzero? (-> this aim-jm))
      (&+! (-> this aim-jm) offset)
      )
  (if (nonzero? (-> this half-aim-jm))
      (&+! (-> this half-aim-jm) offset)
      )
  (call-parent-method this offset)
  )

;; definition for method 10 of type prebot-tentacle
(defmethod deactivate ((this prebot-tentacle))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (-> this laser-sound-playing)
      (sound-stop (-> this laser-sound))
      )
  (call-parent-method this)
  (none)
  )

;; failed to figure out what this is:
(defstate idle (prebot-tentacle)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('look-at)
       (cond
         ((-> block param 0)
          (let ((s5-0 (-> block param 0)))
            (blend-on! (-> self aim-jm) (seconds 0.25) 1.0 #f)
            (set-target! (-> self aim-jm) (the-as vector s5-0))
            (blend-on! (-> self half-aim-jm) (seconds 0.25) 0.5 #f)
            (set-target! (-> self half-aim-jm) (the-as vector s5-0))
            )
          )
         (else
           (blend-to-off! (-> self aim-jm) (seconds 0.25) #f)
           (blend-to-off! (-> self half-aim-jm) (seconds 0.25) #f)
           )
         )
       (cond
         ((-> block param 1)
          (let ((t2-0 (vector<-cspace! (new 'stack-no-clear 'vector) (joint-node prebot-tentacle-lod0-jg gun))))
            (sound-play "prebot-laser" :id (-> self laser-sound) :position t2-0)
            )
          (let ((v0-0 #t))
            (set! (-> self laser-sound-playing) v0-0)
            v0-0
            )
          )
         ((-> self laser-sound-playing)
          (sound-stop (-> self laser-sound))
          (set! (-> self laser-sound-playing) #f)
          #f
          )
         )
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (clone-anim-once (ppointer->handle (-> self parent)) #t (-> self prefix))
    )
  :code sleep-code
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root))
    )
  )

;; definition for symbol *prebot-eco-pillar-debris-params*, type debris-static-params
(define *prebot-eco-pillar-debris-params*
  (new 'static 'debris-static-params
    :joints (new 'static 'boxed-array :type debris-static-joint-params
      (new 'static 'debris-static-joint-params :parent-joint-index 3 :group "skel-cav-molten-pil-debris-a")
      (new 'static 'debris-static-joint-params
        :parent-joint-index 3
        :group "skel-cav-molten-pil-debris-b"
        :offset (new 'static 'vector :y -4096.0 :w 1.0)
        )
      (new 'static 'debris-static-joint-params
        :parent-joint-index 3
        :group "skel-cav-molten-pil-debris-c"
        :offset (new 'static 'vector :y -20480.0 :w 1.0)
        )
      (new 'static 'debris-static-joint-params
        :parent-joint-index 3
        :group "skel-cav-molten-pil-debris-d"
        :offset (new 'static 'vector :y -36864.0 :w 1.0)
        )
      )
    :collide-spec (collide-spec backgnd)
    )
  )

;; definition for method 7 of type prebot-eco-pillar
(defmethod relocate ((this prebot-eco-pillar) (offset int))
  (if (nonzero? (-> this heat-part))
      (&+! (-> this heat-part) offset)
      )
  (if (nonzero? (-> this cool-part))
      (&+! (-> this cool-part) offset)
      )
  (call-parent-method this offset)
  )

;; definition for method 10 of type prebot-eco-pillar
(defmethod deactivate ((this prebot-eco-pillar))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (nonzero? (-> this heat-part))
      (kill-particles (-> this heat-part))
      )
  (if (nonzero? (-> this cool-part))
      (kill-particles (-> this cool-part))
      )
  (call-parent-method this)
  (none)
  )

;; definition for function prebot-eco-pillar-handler
;; INFO: Used lq/sq
;; WARN: Return type mismatch symbol vs object.
(defbehavior prebot-eco-pillar-handler prebot-eco-pillar ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('touch 'bonk)
     (when (and (= arg0 *target*) (-> self hot))
       (if (send-event
             *target*
             'attack-or-shove
             #f
             (static-attack-info :mask (vehicle-impulse-factor) ((id (new-attack-id))
                                                                 (damage 2.0)
                                                                 (vehicle-damage-factor 1.0)
                                                                 (vehicle-impulse-factor 1.0)
                                                                 (shove-up (meters 1))
                                                                 (shove-back (meters 3))
                                                                 )
                                 )
             )
           (send-event (ppointer->process (-> self parent)) 'touched-hot-pillar)
           )
       )
     #t
     )
    (('vulnerable)
     (let ((v0-2 #t))
       (set! (-> self vulnerable) v0-2)
       v0-2
       )
     )
    (('attack)
     (when (and (-> self vulnerable) (type? arg0 prebot-gun-shot))
       (let ((a1-12 (new 'stack 'debris-tuning (the-as uint 1))))
         (set! (-> a1-12 hit-xz-reaction) 0.95)
         (set! (-> a1-12 hit-y-reaction) 0.6)
         (set! (-> a1-12 fountain-rand-transv-lo quad) (-> self root trans quad))
         (+! (-> a1-12 fountain-rand-transv-lo z) 4096.0)
         (debris-spawn
           (the-as process-drawable (ppointer->process (-> self parent)))
           a1-12
           *prebot-eco-pillar-debris-params*
           self
           )
         )
       (sound-play "columns-break" :position (-> self root trans))
       (cond
         ((logtest? (-> *part-group-id-table* 1344 flags) (sp-group-flag sp13))
          (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
          (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 1344))
          )
         (else
           (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
           (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 1344))
           )
         )
       (go-virtual wait-to-die)
       )
     #f
     )
    )
  )

;; failed to figure out what this is:
(defstate wait-to-die (prebot-eco-pillar)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (if (+ (current-time) -1)
        (deactivate self)
        )
    )
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate idle (prebot-eco-pillar)
  :virtual #t
  :event prebot-eco-pillar-handler
  :code sleep-code
  :post (behavior ()
    (do-push-aways (-> self root))
    )
  )

;; failed to figure out what this is:
(defstate cool-down (prebot-eco-pillar)
  :virtual #t
  :event prebot-eco-pillar-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :exit (behavior ()
    (set! (-> self hot) #f)
    )
  :trans (behavior ()
    (if (time-elapsed? (-> self state-time) (seconds 1))
        (go-virtual idle)
        )
    (let ((f30-0 (lerp-scale 0.0 1.0 (the float (- (current-time) (-> self state-time))) 0.0 300.0)))
      (let ((f28-0 (lerp-scale 1.0 0.0 f30-0 0.5 1.0)))
        (set-mined-pillar-texture! f30-0)
        (set-vector! (-> self draw color-emissive) f28-0 f28-0 f28-0 1.0)
        )
      (set-vector! (-> self draw color-mult) f30-0 f30-0 f30-0 1.0)
      )
    (let ((a1-2 (new 'stack-no-clear 'vector)))
      (set! (-> a1-2 quad) (-> self root trans quad))
      (set! (-> a1-2 y) (-> self start-y))
      (spawn (-> self cool-part) a1-2)
      )
    )
  :code sleep-code
  :post (behavior ()
    (do-push-aways (-> self root))
    )
  )

;; failed to figure out what this is:
(defstate wait-to-cool (prebot-eco-pillar)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('cool-down)
       (go-virtual cool-down)
       )
      (else
        (prebot-eco-pillar-handler proc argc message block)
        )
      )
    )
  :trans (behavior ()
    (let ((a1-0 (new 'stack-no-clear 'vector)))
      (set! (-> a1-0 quad) (-> self root trans quad))
      (set! (-> a1-0 y) (-> self start-y))
      (spawn (-> self part) a1-0)
      )
    )
  :code sleep-code
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root))
    )
  )

;; failed to figure out what this is:
(defstate grow (prebot-eco-pillar)
  :virtual #t
  :event prebot-eco-pillar-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set-zero! *camera-smush-control*)
    (activate! *camera-smush-control* 819.2 37 600 1.0 1.1 (-> *display* camera-clock))
    (sound-play "columns-raise" :position (-> self root trans))
    )
  :exit (behavior ()
    (set-zero! *camera-smush-control*)
    (activate! *camera-smush-control* 819.2 37 300 1.0 1.1 (-> *display* camera-clock))
    )
  :trans (behavior ()
    (set! (-> self root trans y) (lerp-scale
                                   (+ 4300.8 (-> self start-y))
                                   (-> self end-y)
                                   (the float (- (current-time) (-> self state-time)))
                                   0.0
                                   75.0
                                   )
          )
    (if (time-elapsed? (-> self state-time) (seconds 0.25))
        (go-virtual wait-to-cool)
        )
    (let ((a1-1 (new 'stack-no-clear 'vector)))
      (set! (-> a1-1 quad) (-> self root trans quad))
      (set! (-> a1-1 y) (-> self start-y))
      (spawn (-> self part) a1-1)
      )
    )
  :code sleep-code
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root))
    )
  )

;; failed to figure out what this is:
(defstate heat-up (prebot-eco-pillar)
  :virtual #t
  :event prebot-eco-pillar-handler
  :enter (behavior ()
    (ja :num-func num-func-identity :frame-num max)
    (set-time! (-> self state-time))
    (set-vector! (-> self draw color-emissive) 1.0 1.0 1.0 1.0)
    (set-vector! (-> self draw color-mult) 0.0 0.0 0.0 1.0)
    )
  :exit (behavior ()
    (set! (-> self hot) #t)
    )
  :trans (behavior ()
    (if (time-elapsed? (-> self state-time) (seconds 0.5))
        (set! (-> self hot) #t)
        )
    (if (time-elapsed? (-> self state-time) (seconds 5))
        (go-virtual grow)
        )
    (let ((a1-0 (new 'stack-no-clear 'vector)))
      (set! (-> a1-0 quad) (-> self root trans quad))
      (set! (-> a1-0 y) (-> self start-y))
      (spawn (-> self heat-part) a1-0)
      )
    (set! (-> self root trans y) (lerp-scale
                                   (-> self start-y)
                                   (+ 4300.8 (-> self start-y))
                                   (the float (- (current-time) (-> self state-time)))
                                   0.0
                                   300.0
                                   )
          )
    )
  :code sleep-code
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root))
    )
  )

;; definition of type cav-exit-door
(deftype cav-exit-door (process-drawable)
  ((initial-y  float)
   )
  (:state-methods
    idle
    rise
    )
  )

;; definition for method 3 of type cav-exit-door
(defmethod inspect ((this cav-exit-door))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tinitial-y: ~f~%" (-> this initial-y))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defstate rise (cav-exit-door)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (sound-play "mb-door-open")
    )
  :trans (behavior ()
    (set! (-> self root trans y)
          (+ (-> self initial-y) (lerp-scale 0.0 32768.0 (the float (- (current-time) (-> self state-time))) 0.0 300.0))
          )
    (when (time-elapsed? (-> self state-time) (seconds 1))
      (sound-play "mb-door-hit")
      (cleanup-for-death self)
      (deactivate self)
      )
    )
  :code sleep-code
  :post transform-post
  )

;; failed to figure out what this is:
(defstate idle (cav-exit-door)
  :virtual #t
  :enter (behavior ()
    (transform-post)
    )
  :trans (behavior ()
    (let ((f0-0 (vector-vector-distance-squared (-> self root trans) (target-pos 0)))
          (f1-0 16384.0)
          )
      (if (< f0-0 (* f1-0 f1-0))
          (go-virtual rise)
          )
      )
    )
  :code sleep-code
  )

;; definition for method 11 of type cav-exit-door
(defmethod init-from-entity! ((this cav-exit-door) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 1) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 2))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 8192.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> v1-9 prim-core action) (collide-action solid))
      (set! (-> v1-9 transform-index) 3)
      (set-vector! (-> v1-9 local-sphere) 74.1376 13979.238 -22.528 20222.771)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cav-exit-door" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this initial-y) (-> this root trans y))
  (set! (-> this draw light-index) (the-as uint 10))
  (go (method-of-object this idle))
  )
