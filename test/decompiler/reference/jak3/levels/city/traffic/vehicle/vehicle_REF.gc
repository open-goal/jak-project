;;-*-Lisp-*-
(in-package goal)

;; definition for symbol *debug-vehicle-work*, type debug-vehicle-work
(define *debug-vehicle-work* (new 'static 'debug-vehicle-work))

;; failed to figure out what this is:
(defskelgroup skel-vehicle-explosion vehicle-explosion vehicle-explosion-lod0-jg vehicle-explosion-idle-ja
              ((vehicle-explosion-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 50)
              )

;; definition for symbol *vehicle-shadow-control*, type shadow-control
(define *vehicle-shadow-control*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :center (new 'static 'vector :w (the-as float #xa))
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 163840.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 40960.0)
                                           :top-plane (new 'static 'plane :y 1.0 :w 2048.0)
                                           )
                               )
  )

;; definition for symbol *vehicle-shadow-control-disabled*, type shadow-control
(define *vehicle-shadow-control-disabled*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :center (new 'static 'vector :w (the-as float #x2a))
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 163840.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 40960.0)
                                           :top-plane (new 'static 'plane :y 1.0 :w 2048.0)
                                           )
                               )
  )

;; definition for function vehicle-event-handler
(defbehavior vehicle-event-handler vehicle ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (rbody-event-handler self arg0 arg1 arg2 arg3)
  )

;; definition for method 48 of type vehicle
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod on-impact ((this vehicle) (arg0 rigid-body-impact))
  (local-vars (v1-79 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (logior! (-> this v-flags) (vehicle-flag impact))
    (set! (-> this impact-pos quad) (-> arg0 point quad))
    (let ((s4-0 (new 'stack-no-clear 'matrix)))
      (matrix-inverse-of-rot-trans! (the-as matrix (-> s4-0 rvec)) (-> this rbody matrix))
      (vector-matrix*! (-> this impact-local-pos) (-> this impact-pos) (the-as matrix (-> s4-0 rvec)))
      )
    (set! (-> this prev-impact-time) (-> this impact-time))
    (set! (-> this impact-time) (the-as uint (current-time)))
    (set! (-> this impact-pat) (the-as uint (-> arg0 pat)))
    (set! (-> this impact-proc) (the-as handle #f))
    (let ((a0-5 (-> arg0 process)))
      (if a0-5
          (set! (-> this impact-proc) (process->handle a0-5))
          )
      )
    (let ((s4-1 (-> this info))
          (f0-0 1.0)
          )
      (let ((v1-14 (-> arg0 prim-id)))
        (if (logtest? v1-14 512)
            (set! f0-0 (* 1.5 f0-0))
            )
        (if (logtest? v1-14 1024)
            (set! f0-0 (* 2.0 f0-0))
            )
        (if (logtest? v1-14 2048)
            (set! f0-0 (* 4.0 f0-0))
            )
        (if (logtest? v1-14 256)
            (set! f0-0 (/ 1.0 f0-0))
            )
        )
      (let ((f30-0 (* (-> arg0 impulse) f0-0 (-> s4-1 info inv-mass) (-> s4-1 damage inv-toughness-factor))))
        (set! (-> this crash-impulse) (-> arg0 impulse))
        (cond
          ((< f30-0 (-> s4-1 damage hit-threshold))
           )
          ((>= f30-0 (-> s4-1 damage hit-deadly))
           (when (logtest? (vehicle-flag player-driving) (-> this v-flags))
             (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 1))
             0
             )
           (apply-damage this (* 2.0 (-> s4-1 damage hit-points)) arg0)
           (vehicle-method-74 this 2 (seconds 1))
           )
          ((>= f30-0 (-> s4-1 damage hit-big))
           (when (logtest? (vehicle-flag player-driving) (-> this v-flags))
             (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.5))
             0
             )
           (apply-damage this (* 10.0 (-> s4-1 damage impact-damage-factor)) arg0)
           (vehicle-method-74 this 1 (seconds 0.25))
           )
          ((>= f30-0 (-> s4-1 damage hit-small))
           (when (logtest? (vehicle-flag player-driving) (-> this v-flags))
             (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.25))
             0
             )
           (apply-damage this (* 5.0 (-> s4-1 damage impact-damage-factor)) arg0)
           (vehicle-method-74 this 1 (seconds 0.25))
           )
          (else
            (let* ((f0-14 0.0)
                   (f1-10 40.0)
                   (f2-0 16384000.0)
                   (f0-15 (fmax f0-14 (* f1-10 (/ 1.0 f2-0) (- f30-0 (-> s4-1 damage hit-threshold)))))
                   )
              (apply-damage this (* f0-15 (-> s4-1 damage impact-damage-factor)) arg0)
              )
            (when (< 32768.0 f30-0)
              (if (logtest? (vehicle-flag player-driving) (-> this v-flags))
                  (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.1))
                  )
              )
            )
          )
        (let* ((f0-18 1.0)
               (f1-14 61440.0)
               (f28-0 (fmin f0-18 (* f30-0 (/ 1.0 f1-14))))
               )
          (cond
            ((>= f30-0 (-> s4-1 damage hit-small))
             (sound-play-by-name
               (-> this info sound impact-sound)
               (new-sound-id)
               (the int (* 1024.0 f28-0))
               0
               0
               (sound-group)
               #t
               )
             (logclear! (-> this v-flags) (vehicle-flag turbo-boost))
             )
            ((< 0.1 f28-0)
             (sound-play-by-name
               (-> this info sound glance-sound)
               (new-sound-id)
               (the int (* 1024.0 f28-0))
               0
               0
               (sound-group)
               #t
               )
             )
            )
          )
        )
      )
    (let ((a0-39 (new 'stack-no-clear 'vector)))
      (vector+float*!
        a0-39
        (-> arg0 velocity)
        (-> arg0 normal)
        (- (vector-dot (-> arg0 velocity) (-> arg0 normal)))
        )
      (.lvf vf1 (&-> a0-39 quad))
      )
    (.add.w.vf vf2 vf0 vf0 :mask #b1)
    (.mul.vf vf1 vf1 vf1)
    (.mul.x.vf acc vf2 vf1 :mask #b1)
    (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
    (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
    (.mov v1-79 vf1)
    (let ((f0-30 v1-79)
          (f1-18 12288.0)
          )
      (when (< (* f1-18 f1-18) f0-30)
        (set! (-> this scrape-sound-envelope) 1.0)
        (if (logtest? (vehicle-flag player-driving) (-> this v-flags))
            (cpad-set-buzz! (-> *cpad-list* cpads 0) 0 255 (seconds 0.05))
            )
        )
      )
    (if (>= 0.0 (-> this hit-points))
        (vehicle-method-74 this 2 (seconds 1))
        )
    0
    (none)
    )
  )

;; definition for method 92 of type vehicle
;; WARN: Return type mismatch int vs none.
(defmethod vehicle-method-92 ((this vehicle) (arg0 vehicle-controls))
  (seek! (-> this controls steering) (-> arg0 steering) (* 8.0 (seconds-per-frame)))
  (seek! (-> this controls lean-z) (-> arg0 lean-z) (* 8.0 (seconds-per-frame)))
  (let ((f0-10 (-> arg0 throttle))
        (f30-0 (-> arg0 brake))
        )
    (seek! (-> this controls throttle) f0-10 (* 4.0 (seconds-per-frame)))
    (+! (-> this controls brake) (* (- f30-0 (-> this controls brake)) (fmin 1.0 (* 8.0 (seconds-per-frame)))))
    )
  (set! (-> this controls prev-flags) (-> this controls flags))
  (set! (-> this controls flags) (-> arg0 flags))
  0
  (none)
  )

;; definition for method 88 of type vehicle
;; WARN: Return type mismatch int vs none.
(defmethod vehicle-method-88 ((this vehicle) (arg0 vehicle-controls))
  0
  (none)
  )

;; definition for method 91 of type vehicle
;; WARN: Return type mismatch int vs none.
(defmethod control-hook-player ((this vehicle))
  (let ((gp-0 (new 'stack-no-clear 'vehicle-controls)))
    (mem-set32! (&-> gp-0 steering) 6 0)
    (cond
      ((or (logtest? (-> this v-flags) (vehicle-flag player-grabbed))
           (and *target* (focus-test? *target* dead grabbed))
           (-> *setting-control* user-current stop-vehicle?)
           )
       (set! (-> gp-0 steering) 0.0)
       (set! (-> gp-0 lean-z) 0.0)
       (set! (-> gp-0 throttle) 0.0)
       (set! (-> gp-0 brake) 1.0)
       (set! (-> gp-0 handbrake) 0.0)
       (set! (-> this v-flags)
             (the-as vehicle-flag (logclear (-> this v-flags) (vehicle-flag reverse-gear camera-look-mode)))
             )
       )
      (else
        (vehicle-method-88 this (the-as vehicle-controls (&-> gp-0 steering)))
        )
      )
    (vehicle-method-92 this (the-as vehicle-controls (&-> gp-0 steering)))
    )
  0
  (none)
  )

;; definition for method 93 of type vehicle
;; WARN: Return type mismatch int vs none.
(defmethod vehicle-method-93 ((this vehicle))
  (let ((s5-0 (new 'stack-no-clear 'mystery-vehicle-type2)))
    (set! (-> s5-0 time) (the-as uint (current-time)))
    (when (and *target* (logtest? (vehicle-flag ignition) (-> this v-flags)))
      (when (and (logtest? (vehicle-flag player-driving) (-> this v-flags))
                 (zero? (-> this root num-riders))
                 (or (not *target*) (or (< 32768.0 (vector-vector-distance (-> this root trans) (-> *target* control trans)))
                                        (focus-test? *target* teleporting)
                                        )
                     )
                 )
        (set! (-> this controls throttle) 0.0)
        (set! (-> this controls steering) 0.0)
        (set! (-> this controls lean-z) 0.0)
        (mem-copy! (the-as pointer (-> this prev-controls)) (the-as pointer (-> this controls)) 24)
        )
      )
    (cond
      ((zero? (-> this crash-level))
       (seek! (-> this force-scale) 1.0 (seconds-per-frame))
       )
      ((< (-> this crash-level) 3)
       (set! (-> s5-0 word01) (- (-> s5-0 time) (-> this crash-time)))
       (when (>= (-> s5-0 word01) (-> this crash-duration))
         (if (or (>= (-> this rbody matrix uvec y) (cos 18204.445)) (>= (-> s5-0 word01) (the-as uint 900)))
             (vehicle-method-75 this)
             )
         )
       )
      )
    (set! (-> this force-level) (-> this crash-level))
    (cond
      ((>= (-> this hit-points) 0.9)
       (set! (-> this power-fluctuation-factor) 0.01)
       )
      ((>= (-> this hit-points) 0.75)
       (set! (-> this power-fluctuation-factor) 0.02)
       )
      ((>= (-> this hit-points) 0.5)
       (set! (-> this power-fluctuation-factor) 0.04)
       )
      ((>= (-> this hit-points) 0.3)
       (set! (-> this power-fluctuation-factor) 0.08)
       )
      ((>= (-> this hit-points) 0.15)
       (set! (-> this power-fluctuation-factor) 0.16)
       )
      ((>= (-> this hit-points) 0.05)
       (set! (-> this power-fluctuation-factor) 0.32)
       )
      (else
        (set! (-> this power-fluctuation-factor) 0.5)
        )
      )
    (let ((f1-6 0.0))
      (when (logtest? (vehicle-flag ignition) (-> this v-flags))
        (let ((f0-23 (- 1.0 (* (rand-vu) (-> this power-fluctuation-factor)))))
          (set! f1-6 (* f0-23 f0-23))
          )
        (if (not (logtest? (-> this v-flags) (vehicle-flag riding)))
            (set! f1-6 (* 0.5 f1-6))
            )
        )
      (+! (-> this power-level)
          (* (- f1-6 (-> this power-level))
             (fmin 1.0 (* (+ 1.0 (* 50.0 (-> this power-fluctuation-factor))) (seconds-per-frame)))
             )
          )
      )
    (when (logtest? (vehicle-flag turbo-boost) (-> this v-flags))
      (set! (-> s5-0 word00) (- (-> s5-0 time) (-> this turbo-boost-time)))
      (if (or (>= (-> s5-0 word00) (-> this turbo-boost-duration))
              (and (>= (-> s5-0 word00) (the-as uint 30)) (>= (-> this controls brake) 0.75))
              )
          (logclear! (-> this v-flags) (vehicle-flag turbo-boost))
          )
      )
    )
  (if (logtest? (-> this v-flags) (vehicle-flag on-ground on-flight-level))
      (set! (-> this air-time) (the-as uint (current-time)))
      )
  0
  (none)
  )

;; definition for method 94 of type vehicle
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod vehicle-method-94 ((this vehicle))
  (let ((s5-0 (new 'stack-no-clear 'mystery-vehicle-type1)))
    (set! (-> s5-0 word02) (the-as uint (current-time)))
    (cond
      ((logtest? (-> this v-flags) (vehicle-flag in-air))
       (when (or (< 55296.0 (-> this rbody lin-velocity y)) (>= (- (-> s5-0 word02) (-> this air-time)) (the-as uint 225)))
         (set-setting! 'extra-follow-height 'abs (meters -4) 0)
         (send-event *camera* 'set-max-angle-offset (-> this info camera air-max-angle-offset))
         )
       )
      (else
        (remove-setting! 'extra-follow-height)
        (send-event *camera* 'set-max-angle-offset (-> this info camera normal-max-angle-offset))
        )
      )
    (let ((f0-4 (vector-dot (-> this rbody lin-velocity) (-> this rbody matrix fvec))))
      (cond
        ((= (-> this crash-level) 2)
         (vehicle-method-85 this)
         )
        ((< f0-4 (-> this info camera max-lookaround-speed))
         (vehicle-method-85 this)
         )
        ((< (+ 4096.0 (-> this info camera max-lookaround-speed)) f0-4)
         (vehicle-method-84 this)
         )
        )
      )
    (when (not (logtest? (vehicle-flag flight-level-transition) (-> this v-flags)))
      (let* ((f0-5 1.0)
             (v1-49 (-> this rbody lin-velocity))
             (f0-6 (fmin f0-5 (/ (sqrtf (+ (* (-> v1-49 x) (-> v1-49 x)) (* (-> v1-49 z) (-> v1-49 z))))
                                 (-> this info handling max-xz-speed)
                                 )
                         )
                   )
             )
        (seek! (-> this cam-speed-interp) f0-6 (* 0.1 (seconds-per-frame)))
        )
      )
    (let ((f30-0 (-> this cam-speed-interp)))
      (if #f
          (set! f30-0
                (fmax 0.0 (fmin 1.0 (analog-input (the-as int (-> *cpad-list* cpads 1 righty)) 128.0 48.0 110.0 -1.0)))
                )
          )
      (set! (-> s5-0 float00)
            (lerp-scale (-> this info camera min-fov) (-> this info camera max-fov) f30-0 0.0 1.0)
            )
      (set-setting! 'fov 'abs (-> s5-0 float00) 0)
      (let ((f30-2 (lerp-scale 1.0 0.6 f30-0 0.0 1.0)))
        (set-setting! 'string-min-length 'abs (* f30-2 (-> this info camera string-min-length)) 0)
        (set-setting! 'string-max-length 'abs (* f30-2 (-> this info camera string-max-length)) 0)
        )
      )
    (when *target*
      (set! (-> s5-0 vec0 quad) (-> *target* draw shadow-ctrl settings shadow-dir quad))
      (let ((v1-75 (-> this draw shadow-ctrl settings shadow-dir)))
        (set! (-> s5-0 vec0 w) (-> v1-75 w))
        (set! (-> v1-75 quad) (-> s5-0 vec0 quad))
        )
      )
    (let ((s4-0 (new 'stack-no-clear 'inline-array 'collide-query 2)))
      (let* ((v1-76 (-> s4-0 1))
             (a3-7 (-> this rbody matrix))
             (a0-29 (-> a3-7 rvec quad))
             (a1-11 (-> a3-7 uvec quad))
             (a2-9 (-> a3-7 fvec quad))
             (a3-8 (-> a3-7 trans quad))
             )
        (set! (-> v1-76 best-other-tri vertex 0 quad) a0-29)
        (set! (-> v1-76 best-other-tri vertex 1 quad) a1-11)
        (set! (-> v1-76 best-other-tri vertex 2 quad) a2-9)
        (set! (-> v1-76 best-other-tri intersect quad) a3-8)
        )
      (cond
        ((logtest? (vehicle-flag camera-look-mode) (-> this v-flags))
         (let ((a0-31 *camera*))
           (when a0-31
             (let ((s3-0 (-> a0-31 slave)))
               (when s3-0
                 (set! (-> s3-0 0 fov) (-> s5-0 float00))
                 (let ((v1-83 (-> this cam-view)))
                   (cond
                     ((zero? v1-83)
                      (vector-matrix*!
                        (the-as vector (-> s4-0 1 bbox))
                        (the-as vector (-> this info camera look-pos-array))
                        (the-as matrix (-> s4-0 1))
                        )
                      )
                     ((= v1-83 1)
                      (vector-matrix*! (the-as vector (-> s4-0 1 bbox)) (-> this info camera look-rear) (the-as matrix (-> s4-0 1)))
                      (matrix-rotate-yx! (the-as matrix (-> s4-0 1 best-other-tri normal)) 32768.0 3640.889)
                      (matrix*!
                        (the-as matrix (-> s4-0 1))
                        (the-as matrix (-> s4-0 1 best-other-tri normal))
                        (the-as matrix (-> s4-0 1))
                        )
                      )
                     ((= v1-83 2)
                      (vector-matrix*! (the-as vector (-> s4-0 1 bbox)) (-> this info camera look-left) (the-as matrix (-> s4-0 1)))
                      (matrix-rotate-yx! (the-as matrix (-> s4-0 1 best-other-tri normal)) 16384.0 3640.889)
                      (matrix*!
                        (the-as matrix (-> s4-0 1))
                        (the-as matrix (-> s4-0 1 best-other-tri normal))
                        (the-as matrix (-> s4-0 1))
                        )
                      )
                     ((= v1-83 3)
                      (vector-matrix*!
                        (the-as vector (-> s4-0 1 bbox))
                        (-> this info camera look-right)
                        (the-as matrix (-> s4-0 1))
                        )
                      (matrix-rotate-yx! (the-as matrix (-> s4-0 1 best-other-tri normal)) -16384.0 3640.889)
                      (matrix*!
                        (the-as matrix (-> s4-0 1))
                        (the-as matrix (-> s4-0 1 best-other-tri normal))
                        (the-as matrix (-> s4-0 1))
                        )
                      )
                     (else
                       (vector-matrix*!
                         (the-as vector (-> s4-0 1 bbox))
                         (the-as vector (-> this info camera look-pos-array))
                         (the-as matrix (-> s4-0 1))
                         )
                       )
                     )
                   )
                 (when (nonzero? (-> this cam-view))
                   (let ((v1-96 (-> s4-0 0)))
                     (set! (-> v1-96 radius) 2048.0)
                     (set! (-> v1-96 collide-with)
                           (collide-spec
                             backgnd
                             bot
                             crate
                             civilian
                             enemy
                             obstacle
                             vehicle-sphere
                             hit-by-player-list
                             hit-by-others-list
                             collectable
                             pusher
                             shield
                             vehicle-sphere-no-probe
                             )
                           )
                     (set! (-> v1-96 ignore-process0) this)
                     (set! (-> v1-96 ignore-process1) #f)
                     (set! (-> v1-96 ignore-pat)
                           (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                           )
                     (set! (-> v1-96 action-mask) (collide-action solid))
                     )
                   (set! (-> s4-0 0 start-pos quad) (-> this rbody position quad))
                   (vector-! (-> s4-0 0 move-dist) (the-as vector (-> s4-0 1 bbox)) (-> s4-0 0 start-pos))
                   (let ((f0-23 (fill-and-probe-using-line-sphere *collide-cache* (-> s4-0 0))))
                     (if (>= f0-23 0.0)
                         (vector+float*! (the-as vector (-> s4-0 1 bbox)) (-> s4-0 0 start-pos) (-> s4-0 0 move-dist) f0-23)
                         )
                     )
                   )
                 (set! (-> s3-0 0 saved-pt quad) (-> s4-0 1 bbox min quad))
                 (let ((v1-107 (-> s3-0 0 tracking)))
                   (set! (-> v1-107 inv-mat rvec quad) (-> s4-0 1 best-other-tri vertex 0 quad))
                   (set! (-> v1-107 inv-mat uvec quad) (-> s4-0 1 best-other-tri vertex 1 quad))
                   (set! (-> v1-107 inv-mat fvec quad) (-> s4-0 1 best-other-tri vertex 2 quad))
                   )
                 )
               )
             )
           )
         (if (zero? (-> this cam-view))
             (vehicle-method-147 this)
             (vehicle-method-148 this)
             )
         (when (not (logtest? (vehicle-flag camera-look-mode) (-> this unknown-flags)))
           (set-setting! 'interp-time 'abs 3.0 0)
           (set-setting! 'mode-name 'cam-fixed 0.0 0)
           (set-setting! 'lock-sound-camera-to-target #t 0.0 0)
           )
         )
        (else
          (when (logtest? (vehicle-flag camera-look-mode) (-> this unknown-flags))
            (vehicle-method-148 this)
            (let ((v1-130 *camera*))
              (when v1-130
                (when (-> v1-130 slave)
                  (let ((s5-1 (new 'static 'vector)))
                    (let ((v1-132 (new 'stack-no-clear 'inline-array 'matrix 2)))
                      (let ((a0-72 (-> v1-132 1)))
                        (set! (-> a0-72 rvec x) 0.0)
                        (set! (-> a0-72 rvec y) 0.0)
                        (set! (-> a0-72 rvec z) -1.0)
                        (set! (-> a0-72 rvec w) 1.0)
                        )
                      (let* ((a0-73 (-> v1-132 0))
                             (t0-10 (-> this rbody matrix))
                             (a1-37 (-> t0-10 rvec quad))
                             (a2-24 (-> t0-10 uvec quad))
                             (a3-12 (-> t0-10 fvec quad))
                             (t0-11 (-> t0-10 trans quad))
                             )
                        (set! (-> a0-73 rvec quad) a1-37)
                        (set! (-> a0-73 uvec quad) a2-24)
                        (set! (-> a0-73 fvec quad) a3-12)
                        (set! (-> a0-73 trans quad) t0-11)
                        )
                      (vector-rotate*! s5-1 (the-as vector (-> v1-132 1)) (-> v1-132 0))
                      )
                    (persist-with-delay
                      *setting-control*
                      'string-startup-vector
                      (seconds 0.05)
                      'string-startup-vector
                      'abs
                      (the-as float s5-1)
                      0
                      )
                    )
                  )
                )
              )
            (set-setting! 'interp-time 'abs 0.0 0)
            (remove-setting! 'mode-name)
            (remove-setting! 'lock-sound-camera-to-target)
            )
          )
        )
      )
    )
  0
  (none)
  )

;; definition for method 101 of type vehicle
;; WARN: Return type mismatch int vs none.
(defmethod vehicle-method-101 ((this vehicle))
  0
  (none)
  )

;; definition for method 30 of type vehicle
;; WARN: Return type mismatch int vs object.
(defmethod rigid-body-object-method-30 ((this vehicle))
  (cond
    ((logtest? (vehicle-flag sounds) (-> this v-flags))
     (rigid-body-object-method-38 this)
     )
    (else
      (if (logtest? (vehicle-flag sounds) (-> this unknown-flags))
          (vehicle-method-106 this)
          )
      )
    )
  (if (logtest? (vehicle-flag particles) (-> this v-flags))
      (vehicle-method-78 this)
      )
  (if (logtest? (vehicle-flag joints) (-> this v-flags))
      (vehicle-method-79 this)
      )
  (when (logtest? (vehicle-flag player-dismounting) (-> this v-flags))
    (let ((a0-10 (new 'stack-no-clear 'array 'uint32 1)))
      (set! (-> a0-10 0) (the-as uint (current-time)))
      (when (< (the-as uint 150) (- (-> a0-10 0) (-> this player-dismount-time)))
        (logclear! (-> this v-flags) (vehicle-flag player-dismounting))
        (let ((v1-32 (find-prim-by-id-logtest (-> this root) (the-as uint 64))))
          (if v1-32
              (set! (-> v1-32 prim-core collide-as) (collide-spec vehicle-sphere vehicle-mesh))
              )
          )
        )
      )
    )
  (set! (-> this unknown-flags) (-> this v-flags))
  (ja-post)
  0
  )

;; definition for method 54 of type vehicle
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-54 ((this vehicle))
  (logclear! (-> this v-flags) (vehicle-flag impact))
  (let ((s5-0 (new 'stack-no-clear 'rigid-body-move-work)))
    (set! (-> s5-0 mat trans w) -4096000.0)
    (water-info-init! (-> this root) (the-as water-info (-> s5-0 mat)) (collide-action solid semi-solid))
    (set! (-> this water-flags) (the-as uint (-> s5-0 mat trans x)))
    (if (and (logtest? (the-as int (-> s5-0 mat trans x)) 1) (logtest? #x20000000 (the-as int (-> s5-0 mat trans x))))
        (set! (-> s5-0 mat trans w) (-> s5-0 mat fvec x))
        )
    (set! (-> this water-height) (-> s5-0 mat trans w))
    (set! (-> s5-0 cquery start-pos quad) (-> this rbody position quad))
    (vector-float*! (-> s5-0 cquery move-dist) (-> this rbody lin-velocity) (seconds-per-frame))
    (let ((v1-15 (-> s5-0 cquery)))
      (set! (-> v1-15 radius) (+ 4096.0 (-> this root root-prim local-sphere w)))
      (set! (-> v1-15 collide-with) (collide-spec
                                      backgnd
                                      jak
                                      bot
                                      crate
                                      civilian
                                      enemy
                                      obstacle
                                      vehicle-sphere
                                      hit-by-player-list
                                      hit-by-others-list
                                      player-list
                                      collectable
                                      blocking-plane
                                      pusher
                                      vehicle-mesh-probeable
                                      shield
                                      vehicle-sphere-no-probe
                                      )
            )
      (set! (-> v1-15 ignore-process0) this)
      (set! (-> v1-15 ignore-process1) #f)
      (set! (-> v1-15 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nopilot #x1))
      (set! (-> v1-15 action-mask) (collide-action solid))
      )
    (if (focus-test? this dead)
        (set! (-> s5-0 cquery ignore-pat) (new 'static 'pat-surface :noentity #x1 :nopilot #x1 :probe #x1))
        )
    (fill-using-line-sphere *collide-cache* (-> s5-0 cquery))
    )
  (rigid-body-control-method-10 (-> this rbody) this (-> this rbody time-remaining) (-> this max-time-step))
  0
  (none)
  )

;; definition for method 77 of type vehicle
;; WARN: Return type mismatch int vs none.
(defmethod vehicle-method-77 ((this vehicle))
  (vehicle-method-115 this)
  (if (logtest? (vehicle-flag camera) (-> this v-flags))
      (vehicle-method-94 this)
      )
  (if (logtest? (vehicle-flag nav-spheres) (-> this v-flags))
      (vehicle-method-140 this)
      )
  (when (< (-> this hit-points) 0.0)
    (logior! (-> this v-flags) (vehicle-flag dead))
    (set! (-> this crash-level) 3)
    )
  (if (and (logtest? (-> this v-flags) (vehicle-flag dead))
           (not (logtest? (-> this focus-status) (focus-status dead)))
           )
      (go (method-of-object this crash))
      )
  0
  (none)
  )

;; definition for method 55 of type vehicle
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod clear-impulse-force-flag! ((this vehicle))
  (with-pp
    (let ((v1-0 (new 'stack-no-clear 'matrix)))
      (set! (-> v1-0 rvec quad) (-> this root transv quad))
      (vector-! (-> v1-0 uvec) (-> this rbody lin-velocity) (-> v1-0 rvec))
      (vector-float*! (-> this lin-acceleration) (-> v1-0 uvec) (-> pp clock frames-per-second))
      )
    (set! (-> this root transv quad) (-> this rbody lin-velocity quad))
    (quaternion-copy! (-> this root quat) (the-as quaternion (-> this rbody rot)))
    (rigid-body-control-method-25 (-> this rbody) (-> this root trans))
    (let* ((v1-11 (-> this node-list data 0 bone transform))
           (a3-0 (-> this rbody matrix))
           (a0-12 (-> a3-0 rvec quad))
           (a1-8 (-> a3-0 uvec quad))
           (a2-1 (-> a3-0 fvec quad))
           (a3-1 (-> a3-0 trans quad))
           )
      (set! (-> v1-11 rvec quad) a0-12)
      (set! (-> v1-11 uvec quad) a1-8)
      (set! (-> v1-11 fvec quad) a2-1)
      (set! (-> v1-11 trans quad) a3-1)
      )
    (set! (-> this node-list data 0 bone transform trans quad) (-> this root trans quad))
    (vehicle-method-77 this)
    (rigid-body-object-method-30 this)
    (update-transforms (-> this root))
    (seek! (-> this scrape-sound-envelope) 0.0 (* 2.0 (seconds-per-frame)))
    (mem-copy! (the-as pointer (-> this prev-controls)) (the-as pointer (-> this controls)) 24)
    (logclear! (-> this v-flags) (vehicle-flag player-impulse-force player-contact-force))
    0
    (none)
    )
  )

;; definition for method 117 of type vehicle
;; WARN: Return type mismatch int vs none.
(defmethod vehicle-method-117 ((this vehicle))
  (if (time-elapsed? (-> this player-touch-time) (seconds 0.1))
      (logclear! (-> this v-flags) (vehicle-flag player-touching player-edge-grabbing player-standing-on))
      )
  (when (logtest? (-> this v-flags) (vehicle-flag player-touching))
    (detect-riders! (-> this root))
    0
    )
  (if (logtest? (vehicle-flag player-touching player-driving) (-> this v-flags))
      (logior! (-> this skel status) (joint-control-status sync-math))
      (logclear! (-> this skel status) (joint-control-status sync-math))
      )
  (vehicle-method-93 this)
  0
  (none)
  )

;; definition for method 39 of type vehicle
;; WARN: Return type mismatch int vs none.
(defmethod rbody-post ((this vehicle))
  (local-vars (a0-14 int) (a0-16 int) (a0-19 int) (a0-21 int))
  (let* ((v1-1 (-> *perf-stats* data 37))
         (a0-1 (-> v1-1 ctrl))
         )
    (+! (-> v1-1 count) 1)
    (b! (zero? a0-1) cfg-2 :delay (nop!))
    (.mtc0 Perf 0)
    (.sync.l)
    (.sync.p)
    (.mtpc pcr0 0)
    (.mtpc pcr1 0)
    (.sync.l)
    (.sync.p)
    (.mtc0 Perf a0-1)
    )
  (.sync.l)
  (.sync.p)
  (label cfg-2)
  0
  (set! (-> this camera-dist2) (vector-vector-distance-squared (-> this root trans) (camera-pos)))
  (set! (-> this player-dist2) (vector-vector-distance-squared (-> this root trans) (target-pos 0)))
  (cond
    ((logtest? (-> this rbody flags) (rigid-body-flag enable-physics))
     (if (not (vehicle-method-102 this))
         (disable-physics! this)
         )
     )
    (else
      (if (vehicle-method-102 this)
          (apply-momentum! this)
          )
      )
    )
  (cond
    ((logtest? (-> this rbody flags) (rigid-body-flag enable-physics))
     (vehicle-method-117 this)
     (vehicle-method-103 this)
     )
    (else
      (let* ((v1-26 (-> *perf-stats* data 20))
             (a0-11 (-> v1-26 ctrl))
             )
        (+! (-> v1-26 count) 1)
        (b! (zero? a0-11) cfg-12 :delay (nop!))
        (.mtc0 Perf 0)
        (.sync.l)
        (.sync.p)
        (.mtpc pcr0 0)
        (.mtpc pcr1 0)
        (.sync.l)
        (.sync.p)
        (.mtc0 Perf a0-11)
        )
      (.sync.l)
      (.sync.p)
      (label cfg-12)
      0
      (rigid-body-object-method-30 this)
      (let ((v1-31 (-> *perf-stats* data 20)))
        (b! (zero? (-> v1-31 ctrl)) cfg-14 :delay (nop!))
        (.mtc0 Perf 0)
        (.sync.l)
        (.sync.p)
        (.mfpc a0-14 pcr0)
        (+! (-> v1-31 accum0) a0-14)
        (.mfpc a0-16 pcr1)
        (+! (-> v1-31 accum1) a0-16)
        )
      (label cfg-14)
      0
      )
    )
  (let ((v1-34 (-> *perf-stats* data 37)))
    (b! (zero? (-> v1-34 ctrl)) cfg-17 :delay (nop!))
    (.mtc0 Perf 0)
    (.sync.l)
    (.sync.p)
    (.mfpc a0-19 pcr0)
    (+! (-> v1-34 accum0) a0-19)
    (.mfpc a0-21 pcr1)
    (+! (-> v1-34 accum1) a0-21)
    )
  (label cfg-17)
  0
  0
  (none)
  )

;; definition for method 89 of type vehicle
;; WARN: Return type mismatch int vs none.
(defmethod init-reverse ((this vehicle) (arg0 vehicle-controls))
  (set! (-> arg0 steering) 0.0)
  (set! (-> arg0 lean-z) 0.0)
  (set! (-> arg0 throttle) 0.0)
  (set! (-> arg0 brake) 1.0)
  (set! (-> arg0 handbrake) 1.0)
  (logclear! (-> this v-flags) (vehicle-flag reverse-gear))
  0
  (none)
  )

;; definition for method 118 of type vehicle
;; WARN: Return type mismatch int vs none.
(defmethod vehicle-method-118 ((this vehicle))
  (local-vars (a0-25 int) (a0-27 int))
  (set! (-> this camera-dist2) (vector-vector-distance-squared (-> this root trans) (camera-pos)))
  (set! (-> this player-dist2) (vector-vector-distance-squared (-> this root trans) (target-pos 0)))
  (b!
    (not (and (logtest? (vehicle-flag traffic-managed) (-> this v-flags))
              (not (logtest? (-> this v-flags) (vehicle-flag persistent)))
              )
         )
    cfg-20
    :delay (empty-form)
    )
  (let ((f0-3 (fmin (-> this player-dist2) (-> this camera-dist2))))
    (let ((f1-1 819200.0))
      (b! (>= (* f1-1 f1-1) f0-3) cfg-8)
      )
    (let ((f1-4 819200.0))
      (if (< (* f1-4 f1-4) f0-3)
          (vehicle-method-109 this)
          )
      )
    (b! #t cfg-19 :delay (nop!))
    (label cfg-8)
    (let ((f1-7 81920.0))
      (b! (>= (* f1-7 f1-7) f0-3) cfg-18)
      )
    (b! (not (logtest? (-> this draw status) (draw-control-status on-screen))) cfg-11 :delay (nop!))
    (set-time! (-> this state-time))
    (b! #t cfg-17 :delay (nop!))
    (label cfg-11)
    (if (or (time-elapsed? (-> this state-time) (seconds 10)) (let ((f1-10 409600.0))
                                                                (< (* f1-10 f1-10) f0-3)
                                                                )
            )
        (vehicle-method-109 this)
        )
    )
  (label cfg-17)
  (b! #t cfg-19 :delay (nop!))
  (label cfg-18)
  (set-time! (-> this state-time))
  (label cfg-19)
  0
  (label cfg-20)
  (vehicle-method-129 this)
  (cond
    ((logtest? (-> this rbody flags) (rigid-body-flag enable-physics))
     (when (not (vehicle-method-102 this))
       (disable-physics! this)
       (vehicle-method-142 this)
       )
     )
    (else
      (if (vehicle-method-102 this)
          (apply-momentum! this)
          )
      )
    )
  (b! (not (logtest? (-> this rbody flags) (rigid-body-flag enable-physics))) cfg-31 :delay (nop!))
  (vector-reset! (-> this target-acceleration))
  (when (logtest? (-> this v-flags) (vehicle-flag disturbed))
    (if (logtest? (-> this v-flags) (vehicle-flag in-air))
        (set-time! (-> this disturbed-time))
        )
    )
  (let ((s5-2 (new 'stack-no-clear 'vehicle-controls)))
    (mem-set32! (&-> s5-2 steering) 6 0)
    (init-reverse this (the-as vehicle-controls (&-> s5-2 steering)))
    (vehicle-method-92 this (the-as vehicle-controls (&-> s5-2 steering)))
    )
  (vehicle-method-117 this)
  (vehicle-method-103 this)
  (b! #t cfg-36 :delay (nop!))
  (label cfg-31)
  (let* ((v1-71 (-> *perf-stats* data 20))
         (a0-22 (-> v1-71 ctrl))
         )
    (+! (-> v1-71 count) 1)
    (b! (zero? a0-22) cfg-33 :delay (nop!))
    (.mtc0 Perf 0)
    (.sync.l)
    (.sync.p)
    (.mtpc pcr0 0)
    (.mtpc pcr1 0)
    (.sync.l)
    (.sync.p)
    (.mtc0 Perf a0-22)
    )
  (.sync.l)
  (.sync.p)
  (label cfg-33)
  0
  (rigid-body-object-method-30 this)
  (let ((v1-76 (-> *perf-stats* data 20)))
    (b! (zero? (-> v1-76 ctrl)) cfg-35 :delay (nop!))
    (.mtc0 Perf 0)
    (.sync.l)
    (.sync.p)
    (.mfpc a0-25 pcr0)
    (+! (-> v1-76 accum0) a0-25)
    (.mfpc a0-27 pcr1)
    (+! (-> v1-76 accum1) a0-27)
    )
  (label cfg-35)
  0
  (label cfg-36)
  0
  (none)
  )

;; definition for method 119 of type vehicle
;; WARN: Return type mismatch int vs none.
(defmethod vehicle-method-119 ((this vehicle))
  (set! (-> this player-dist2) 0.0)
  (set! (-> this camera-dist2) 0.0)
  ((-> this control-hook) this)
  (vehicle-method-117 this)
  0
  (none)
  )

;; definition for method 33 of type vehicle
;; WARN: Return type mismatch int vs none.
(defmethod alloc-rbody-control! ((this vehicle) (arg0 rigid-body-object-constants))
  (if (logtest? (-> (the-as rigid-body-vehicle-constants arg0) flags) 8)
      (iterate-prims
        (-> this root)
        (lambda ((arg0 collide-shape-prim))
          (let ((v1-0 (-> arg0 prim-core prim-type)))
            (cond
              ((= v1-0 -1)
               (set! (-> arg0 prim-core collide-with)
                     (collide-spec
                       backgnd
                       bot
                       crate
                       civilian
                       enemy
                       obstacle
                       vehicle-sphere
                       hit-by-player-list
                       hit-by-others-list
                       collectable
                       pusher
                       shield
                       vehicle-sphere-no-probe
                       )
                     )
               (set! (-> arg0 prim-core collide-as) (collide-spec vehicle-sphere))
               )
              ((= v1-0 1)
               (set! (-> arg0 prim-core collide-with) (collide-spec jak player-list))
               (set! (-> arg0 prim-core collide-as) (collide-spec vehicle-mesh))
               )
              ((zero? v1-0)
               (set! (-> arg0 prim-core collide-with)
                     (collide-spec
                       backgnd
                       jak
                       bot
                       crate
                       civilian
                       enemy
                       obstacle
                       vehicle-sphere
                       hit-by-player-list
                       hit-by-others-list
                       player-list
                       collectable
                       pusher
                       shield
                       vehicle-sphere-no-probe
                       )
                     )
               (set! (-> arg0 prim-core collide-as) (collide-spec vehicle-sphere vehicle-mesh))
               )
              )
            )
          (none)
          )
        )
      (iterate-prims
        (-> this root)
        (lambda ((arg0 collide-shape-prim))
          (set! (-> arg0 prim-core collide-with)
                (collide-spec
                  backgnd
                  jak
                  bot
                  crate
                  civilian
                  enemy
                  obstacle
                  vehicle-sphere
                  hit-by-player-list
                  hit-by-others-list
                  player-list
                  collectable
                  pusher
                  shield
                  vehicle-sphere-no-probe
                  )
                )
          (set! (-> arg0 prim-core collide-as) (collide-spec vehicle-sphere vehicle-mesh))
          (none)
          )
        )
      )
  (set! (-> this bound-radius) (-> this draw bounds w))
  (set! (-> this draw shadow-ctrl)
        (new 'process 'shadow-control -61440.0 -2048.0 69632.0 (-> this root trans) (shadow-flags shdf03) 245760.0)
        )
  (logior! (-> this root root-prim prim-core action) (collide-action pull-rider-can-collide))
  (set! (-> this root pat-ignore-mask) (new 'static 'pat-surface :noentity #x1 :nopilot #x1 :probe #x1))
  (set! (-> this root event-self) 'touched)
  (let ((t9-3 (method-of-type rigid-body-object alloc-rbody-control!)))
    (t9-3 this (the-as rigid-body-vehicle-constants arg0))
    )
  (logior! (-> this rbody flags) (rigid-body-flag enable-collision))
  (set! (-> this root max-iteration-count) (the-as uint 8))
  (set! (-> this max-time-step) 0.033333335)
  (logior! (-> this mask) (process-mask vehicle))
  (logclear! (-> this mask) (process-mask actor-pause movie))
  (logclear! (-> this skel status) (joint-control-status sync-math))
  (process-entity-status! this (entity-perm-status no-kill) #t)
  (set! (-> this nav) #f)
  (set! (-> this squad) #f)
  (let ((v1-29 (-> this root root-prim)))
    (set! (-> this root backup-collide-as) (-> v1-29 prim-core collide-as))
    (set! (-> this root backup-collide-with) (-> v1-29 prim-core collide-with))
    )
  (rigid-body-object-method-42 this)
  (vehicle-method-76 this)
  (set! (-> this power-level) 0.5)
  (set! (-> this lights-factor) 0.0)
  (set! (-> this turbo-boost-factor) 1.0)
  (dotimes (v1-37 4)
    (set! (-> this rider-array v1-37) (the-as handle #f))
    )
  (set! (-> this scrape-sound-id) (new 'static 'sound-id))
  (set! (-> this damage-zap-sound-id) (new-sound-id))
  (set! (-> this draw lod-set lod 0 dist) 122880.0)
  (set! (-> this draw lod-set lod 1 dist) 204800.0)
  (set! (-> this draw lod-set lod 2 dist) 819200.0)
  (set! (-> this event-hook) vehicle-event-handler)
  0
  (none)
  )

;; definition for method 50 of type vehicle
;; INFO: Used lq/sq
(defmethod attack-handler ((this vehicle) (arg0 process-drawable) (arg1 attack-info) (arg2 touching-shapes-entry) (arg3 penetrate))
  (let ((s5-0 (new 'stack-no-clear 'inline-array 'rigid-body-impact 2)))
    (init-rbody-impact-from-tshape! this (-> s5-0 0) arg2)
    (cond
      ((logtest? (attack-mask attacker-velocity) (-> arg1 mask))
       (set! (-> s5-0 0 velocity quad) (-> arg1 attacker-velocity quad))
       )
      (else
        (let ((s0-0 arg0))
          (cond
            ((if (type? s0-0 process-focusable)
                 s0-0
                 )
             (set! (-> s5-0 1 point quad) (-> (get-trans (the-as process-focusable arg0) 3) quad))
             (vector-! (-> s5-0 0 velocity) (the-as vector (-> s5-0 0)) (the-as vector (-> s5-0 1)))
             )
            (else
              (vector-! (-> s5-0 0 velocity) (the-as vector (-> s5-0 0)) (-> arg0 root trans))
              )
            )
          )
        )
      )
    (let ((f28-0 0.0))
      (let ((f30-0 0.0))
        (if (and (logtest? (penetrate jak-dark-nuke) arg3)
                 (not (logtest? (vehicle-flag ignore-damage) (-> this v-flags)))
                 )
            (send-event this 'traffic-off-force)
            )
        (set! f28-0
              (cond
                ((logtest? (penetrate jak-dark-blackhole) arg3)
                 (set! (-> this v-flags) (the-as vehicle-flag (logior (vehicle-flag gun-dark-2-zero-g) (-> this v-flags))))
                 f28-0
                 )
                ((or (logtest? (penetrate dark-punch dark-bomb) arg3)
                     (and (logtest? (penetrate dark-skin) arg3) (logtest? arg3 (penetrate punch spin)))
                     )
                 (set! f30-0 (* 204800.0 (-> this info info mass)))
                 (* 0.2 (-> this info damage hit-points))
                 )
                ((logtest? (penetrate jak-red-shockwave) arg3)
                 (case (-> arg1 mode)
                   (('eco-red-shove)
                    (set! f30-0 (* (lerp 4096.0 8192.0 (-> arg1 control)) (-> this info info mass)))
                    (set! f28-0 0.0)
                    )
                   (('eco-red)
                    (let ((f0-6 (* (lerp 20480.0 122880.0 (-> arg1 control)) (-> this info info mass))))
                      (set! f30-0 (* 2.0 f0-6))
                      )
                    (set! f28-0 (* 8.0 (-> arg1 control)))
                    )
                   )
                 f28-0
                 )
                (else
                  (cond
                    ((logtest? arg3 (penetrate punch))
                     (set! f30-0 40960.0)
                     (set! f28-0 4.0)
                     )
                    ((logtest? arg3 (penetrate flop spin))
                     (set! f30-0 20480.0)
                     (set! f28-0 2.0)
                     )
                    ((logtest? (attack-mask vehicle-damage-factor) (-> arg1 mask))
                     (set! f28-0 (* (-> arg1 damage) (-> arg1 vehicle-damage-factor)))
                     (set! f30-0 (* 49152.0 (-> arg1 vehicle-impulse-factor) (-> arg1 damage)))
                     0
                     )
                    (else
                      (set! f30-0 8192.0)
                      (set! f28-0 2.0)
                      )
                    )
                  f28-0
                  )
                )
              )
        (set! (-> s5-0 0 impulse) f30-0)
        )
      (apply-damage this f28-0 (-> s5-0 0))
      )
    (when (not (logtest? (vehicle-flag ignore-impulse) (-> this v-flags)))
      (impulse-handler this)
      (let ((s3-1 (new 'stack-no-clear 'vector)))
        (set! (-> s3-1 quad) (-> s5-0 0 velocity quad))
        (vector-normalize! s3-1 1.0)
        (vector-float*! s3-1 s3-1 (-> s5-0 0 impulse))
        (apply-impact! (-> this rbody) (the-as vector (-> s5-0 0)) s3-1)
        (rigid-body-control-method-12 (-> this rbody) 1.0)
        (init-velocities! (-> this rbody))
        (when #f
          (set-time! (-> *debug-vehicle-work* impact-time))
          (mem-copy! (the-as pointer (-> *debug-vehicle-work* impact)) (the-as pointer (-> s5-0 0)) 64)
          (let ((v1-84 (-> arg2 head)))
            (set! (-> *debug-vehicle-work* prim-sphere1 quad) (-> v1-84 prim1 cprim prim-core world-sphere quad))
            (set! (-> *debug-vehicle-work* prim-sphere2 quad) (-> v1-84 prim2 cprim prim-core world-sphere quad))
            )
          (add-debug-x #t (bucket-id debug-no-zbuf1) (the-as vector (-> s5-0 0)) *color-blue*)
          (add-debug-vector
            #t
            (bucket-id debug-no-zbuf1)
            (the-as vector (-> s5-0 0))
            s3-1
            (meters 0.00024414062)
            *color-blue*
            )
          )
        )
      )
    )
  (if (and (-> this next-state) (= (-> this next-state name) 'idle))
      (go (method-of-object this waiting))
      )
  #t
  )

;; definition for method 51 of type vehicle
(defmethod touch-handler ((this vehicle) (arg0 process-focusable) (arg1 touching-shapes-entry))
  #t
  )

;; definition for method 49 of type vehicle
;; WARN: disable def twice: 317. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
;; WARN: disable def twice: 331. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod rbody-event-handler ((this vehicle) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (v0-2 object))
  (when (and (= arg2 'touched) arg0 (logtest? (process-mask collectable) (-> arg0 mask)))
    (dotimes (s1-0 4)
      (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-2 from) (process->ppointer arg0))
        (set! (-> a1-2 num-params) arg1)
        (set! (-> a1-2 message) arg2)
        (set! (-> a1-2 param 0) (-> arg3 param 0))
        (set! (-> a1-2 param 1) (-> arg3 param 1))
        (set! (-> a1-2 param 2) (-> arg3 param 2))
        (set! (-> a1-2 param 3) (-> arg3 param 3))
        (set! (-> a1-2 param 4) (-> arg3 param 4))
        (set! (-> a1-2 param 5) (-> arg3 param 5))
        (send-event-function (handle->process (-> this rider-array s1-0)) a1-2)
        )
      )
    )
  (case arg2
    (('attack)
     (let ((s3-1 (the-as object (-> arg3 param 1)))
           (s2-1 (get-penetrate-using-from-attack-event (the-as process-drawable arg0) arg3))
           )
       (when (and (!= (-> (the-as attack-info s3-1) id) (-> this incoming-attack-id))
                  (not (logtest? (-> this v-flags) (vehicle-flag dead)))
                  (or (not (logtest? (vehicle-flag player-driving) (-> this v-flags)))
                      (not (logtest? (penetrate jak-yellow-shot jak-red-shot jak-blue-shot jak-dark-shot) s2-1))
                      )
                  )
         (set! (-> this incoming-attack-id) (-> (the-as attack-info s3-1) id))
         (when (and (logtest? (-> this info flags) 4) (logtest? (vehicle-flag ai-driving) (-> this v-flags)))
           (let ((a1-6 (find-offending-process-focusable arg0 (the-as attack-info s3-1))))
             (if (and a1-6 (logtest? (-> a1-6 mask) (process-mask target)))
                 (vehicle-method-130 this)
                 )
             )
           )
         (attack-handler
           this
           (the-as process-drawable arg0)
           (the-as attack-info s3-1)
           (the-as touching-shapes-entry (-> arg3 param 0))
           s2-1
           )
         )
       )
     )
    (('apply-impulse)
     (when (not (logtest? (vehicle-flag ignore-impulse) (-> this v-flags)))
       (impulse-handler this)
       (let ((a1-8 (-> arg3 param 0))
             (a2-3 (-> arg3 param 1))
             )
         (apply-impact! (-> this rbody) (the-as vector a1-8) (the-as vector a2-3))
         )
       (rigid-body-control-method-12 (-> this rbody) 1.0)
       (init-velocities! (-> this rbody))
       )
     )
    (('get-offending-focusable)
     (if (logtest? (vehicle-flag player-driving) (-> this v-flags))
         *target*
         )
     )
    (('pilot-on)
     (let* ((s3-2 (-> arg3 param 0))
            (s2-2 arg0)
            (s5-1 (if (type? s2-2 process-focusable)
                      s2-2
                      )
                  )
            )
       (when s5-1
         (format #t "vehicle::event-handler: pilot-on (pid ~d) from pid ~d~%" (-> this pid) (-> arg0 pid))
         (logior! (-> this v-flags) (vehicle-flag riding))
         (put-rider-in-seat this (the-as int s3-2) s5-1)
         (if (logtest? (-> s5-1 mask) (process-mask target))
             (logior! (-> this v-flags) (vehicle-flag player-driving))
             )
         #t
         )
       )
     )
    (('player-get-off)
     (if (and (logtest? (vehicle-flag player-driving) (-> this v-flags)) (!= (-> this crash-level) 3))
         (go (method-of-object this waiting))
         )
     )
    (('nav-mesh-kill)
     (vehicle-method-138 this)
     #t
     )
    (('go-hostile)
     (let ((a1-13 (-> arg3 param 0)))
       (vehicle-method-143 this (the-as process a1-13))
       )
     )
    (('go-die)
     (let ((v1-71 (-> this root root-prim)))
       (set! (-> v1-71 prim-core collide-as) (collide-spec))
       (set! (-> v1-71 prim-core collide-with) (collide-spec))
       )
     0
     (go (method-of-object this die))
     )
    (('scale-max-hit-points)
     (let ((f1-0 (the-as float (-> arg3 param 0))))
       (set! (-> this damage-factor) (* (-> this damage-factor) (/ 1.0 f1-0)))
       )
     0
     )
    (('push-trans)
     (let ((a1-14 (-> arg3 param 0)))
       (vehicle-method-146 this (the-as vector a1-14))
       )
     #t
     )
    (('gun-dark-2-off)
     (set! (-> this v-flags) (the-as vehicle-flag (logclear (-> this v-flags) (vehicle-flag gun-dark-2-zero-g))))
     (let* ((f1-2 (the-as float (-> arg3 param 0)))
            (f30-0 (fmin (-> this hit-points) (- 1.0 f1-2)))
            (a2-6 (new 'stack 'rigid-body-impact))
            )
       (apply-damage this (* (-> this info damage hit-points) (- (-> this hit-points) f30-0)) a2-6)
       )
     )
    (('set-control-hook-ai)
     (set! v0-2 (method-of-object this control-hook-ai))
     (set! (-> this control-hook) (the-as (function vehicle vehicle-controls) v0-2))
     v0-2
     )
    (('set-control-hook-player)
     (set! v0-2 (method-of-object this control-hook-player))
     (set! (-> this control-hook) (the-as (function vehicle vehicle-controls) v0-2))
     v0-2
     )
    (('ignore-damage)
     (set! (-> this v-flags) (the-as vehicle-flag (logclear (-> this v-flags) (vehicle-flag ignore-damage))))
     (when (-> arg3 param 0)
       (set! v0-2 (logior (vehicle-flag ignore-damage) (-> this v-flags)))
       (set! (-> this v-flags) (the-as vehicle-flag v0-2))
       v0-2
       )
     )
    (('ignore-impulse)
     (set! (-> this v-flags) (the-as vehicle-flag (logclear (-> this v-flags) (vehicle-flag ignore-impulse))))
     (when (-> arg3 param 0)
       (set! v0-2 (logior (vehicle-flag ignore-impulse) (-> this v-flags)))
       (set! (-> this v-flags) (the-as vehicle-flag v0-2))
       v0-2
       )
     )
    (else
      ((method-of-type rigid-body-object rbody-event-handler) this arg0 arg1 arg2 arg3)
      )
    )
  )

;; definition for method 131 of type vehicle
;; WARN: Return type mismatch int vs none.
(defmethod vehicle-method-131 ((this vehicle) (arg0 traffic-object-spawn-params))
  0
  (none)
  )

;; definition for method 143 of type vehicle
;; WARN: Return type mismatch int vs object.
(defmethod vehicle-method-143 ((this vehicle) (arg0 process))
  0
  )
