;;-*-Lisp-*-
(in-package goal)

;; definition of type security-wall
(deftype security-wall (process-drawable)
  ((root                collide-shape :override)
   (pass                pickup-type)
   (incoming-attack-id  uint32)
   (next-message-time   time-frame)
   (message             int32)
   (plane               plane          :inline)
   (color               vector         :inline)
   (target-pos          vector         :inline)
   (flash               float)
   (touch-count         int32)
   (breach              symbol)
   )
  (:state-methods
    idle-open
    idle-close
    )
  (:methods
    (init-wall (_type_ vector vector float) vector)
    (play-speech (_type_) none)
    (security-wall-method-24 (_type_) none)
    )
  )

;; definition for method 3 of type security-wall
(defmethod inspect ((this security-wall))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tpass: ~D~%" (-> this pass))
  (format #t "~2Tincoming-attack-id: ~D~%" (-> this incoming-attack-id))
  (format #t "~2Tnext-message-time: ~D~%" (-> this next-message-time))
  (format #t "~2Tmessage: ~D~%" (-> this message))
  (format #t "~2Tplane: #<plane @ #x~X>~%" (-> this plane))
  (format #t "~2Tcolor: #<vector @ #x~X>~%" (-> this color))
  (format #t "~2Ttarget-pos: #<vector @ #x~X>~%" (-> this target-pos))
  (format #t "~2Tflash: ~f~%" (-> this flash))
  (format #t "~2Ttouch-count: ~D~%" (-> this touch-count))
  (format #t "~2Tbreach: ~A~%" (-> this breach))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-security-wall security-wall security-wall-lod0-jg security-wall-idle-ja
              ((security-wall-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 100.1)
              )

;; definition for method 23 of type security-wall
;; WARN: Return type mismatch int vs none.
(defmethod play-speech ((this security-wall))
  (when (< (-> this next-message-time) (current-time))
    (set! (-> this next-message-time) (+ (current-time) (the int (* 300.0 (rand-vu-float-range 2.0 5.0)))))
    (let ((v1-6 (rand-vu-int-count 15)))
      (cond
        ((zero? v1-6)
         (case (-> this pass)
           (((pickup-type pass-red))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv015" -99.0 0)
            )
           (((pickup-type pass-green))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv016" -99.0 0)
            )
           (((pickup-type pass-yellow))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv017" -99.0 0)
            )
           (((pickup-type pass-blue))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv018" -99.0 0)
            )
           )
         )
        ((= v1-6 1)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv011" -99.0 0)
         )
        ((= v1-6 2)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         )
        ((= v1-6 3)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv013" -99.0 0)
         )
        ((= v1-6 4)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         )
        ((= v1-6 5)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv011" -99.0 0)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         )
        ((= v1-6 6)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv011" -99.0 0)
         )
        ((= v1-6 7)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv013" -99.0 0)
         )
        ((= v1-6 8)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         )
        ((= v1-6 9)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         )
        ((= v1-6 10)
         (let ((v1-45 (rand-vu-int-count 3)))
           (cond
             ((zero? v1-45)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv035" -99.0 0)
              )
             ((= v1-45 1)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv038" -99.0 0)
              )
             ((= v1-45 2)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv058" -99.0 0)
              )
             )
           )
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv013" -99.0 0)
         )
        ((= v1-6 11)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         (let ((v1-57 (rand-vu-int-count 3)))
           (cond
             ((zero? v1-57)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv035" -99.0 0)
              )
             ((= v1-57 1)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv038" -99.0 0)
              )
             ((= v1-57 2)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv058" -99.0 0)
              )
             )
           )
         )
        ((= v1-6 12)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         (case (-> this pass)
           (((pickup-type pass-red))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv015" -99.0 0)
            )
           (((pickup-type pass-green))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv016" -99.0 0)
            )
           (((pickup-type pass-yellow))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv017" -99.0 0)
            )
           (((pickup-type pass-blue))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv018" -99.0 0)
            )
           )
         )
        ((= v1-6 13)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv011" -99.0 0)
         (case (-> this pass)
           (((pickup-type pass-red))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv015" -99.0 0)
            )
           (((pickup-type pass-green))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv016" -99.0 0)
            )
           (((pickup-type pass-yellow))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv017" -99.0 0)
            )
           (((pickup-type pass-blue))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv018" -99.0 0)
            )
           )
         )
        ((= v1-6 14)
         (case (-> this pass)
           (((pickup-type pass-red))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv015" -99.0 0)
            )
           (((pickup-type pass-green))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv016" -99.0 0)
            )
           (((pickup-type pass-yellow))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv017" -99.0 0)
            )
           (((pickup-type pass-blue))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv018" -99.0 0)
            )
           )
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv013" -99.0 0)
         )
        )
      )
    (+! (-> this message) 1)
    (when (>= (-> this message) 5)
      (set! (-> this message) 0)
      0
      )
    )
  0
  (none)
  )

;; definition for method 24 of type security-wall
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod security-wall-method-24 ((this security-wall))
  (let ((s4-0 *target*))
    (when s4-0
      (let* ((f0-0 (vector-vector-distance-squared (-> this root trans) (-> s4-0 control trans)))
             (f30-0 (+ 40960.0 (-> this root root-prim local-sphere w)))
             (f1-1 f30-0)
             )
        (when (< f0-0 (* f1-1 f1-1))
          (let ((s5-0 (new 'stack-no-clear 'inline-array 'vector 1)))
            (set! (-> s5-0 0 quad) (-> s4-0 control trans quad))
            (when (< (vector-vector-distance-squared (-> this root trans) (-> this target-pos)) (* f30-0 f30-0))
              (let ((f0-3 (vector4-dot (-> this target-pos) (the-as vector (-> this plane))))
                    (f1-7 (vector4-dot (-> s5-0 0) (the-as vector (-> this plane))))
                    )
                (if (and (< (fabs f1-7) 16384.0)
                         (< (fabs f0-3) 16384.0)
                         (or (and (< f0-3 0.0) (>= f1-7 0.0)) (and (< f1-7 0.0) (>= f0-3 0.0)))
                         )
                    (set! (-> this breach) #t)
                    )
                )
              )
            (set! (-> this target-pos quad) (-> s5-0 0 quad))
            )
          (when (-> this breach)
            (if (send-event
                  *target*
                  'attack-invinc
                  #f
                  (static-attack-info
                    :mask (vehicle-impulse-factor)
                    ((id (new-attack-id)) (damage 2.0) (vehicle-damage-factor 1.0) (vehicle-impulse-factor 1.0) (mode 'grenade))
                    )
                  )
                (set! (-> this breach) #f)
                )
            )
          )
        )
      )
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate idle-close (security-wall)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (case message
        (('on)
         (let ((v1-2 (-> self root root-prim)))
           (set! (-> v1-2 prim-core collide-as) (-> self root backup-collide-as))
           (let ((v0-0 (the-as object (-> self root backup-collide-with))))
             (set! (-> v1-2 prim-core collide-with) (the-as collide-spec v0-0))
             v0-0
             )
           )
         )
        (('off)
         (let ((v1-4 (-> self root root-prim)))
           (set! (-> v1-4 prim-core collide-as) (collide-spec))
           (set! (-> v1-4 prim-core collide-with) (collide-spec))
           )
         0
         )
        (('attack)
         (let ((v1-5 (the-as attack-info (-> block param 1))))
           (when (!= (-> v1-5 id) (-> self incoming-attack-id))
             (set! (-> self incoming-attack-id) (-> v1-5 id))
             (let* ((s5-0 proc)
                    (s3-0 (if (type? s5-0 process-drawable)
                              s5-0
                              )
                          )
                    )
               (when s3-0
                 (let ((s5-1 (process-spawn
                               manipy
                               :init manipy-init
                               (-> (the-as process-drawable s3-0) root trans)
                               (-> self entity)
                               (art-group-get-by-name *level* "skel-generic-ripples" (the-as (pointer level) #f))
                               #f
                               0
                               :name "manipy"
                               :to self
                               :stack-size #x20000
                               )
                             )
                       )
                   (when s5-1
                     (send-event (ppointer->process s5-1) 'anim-mode 'play1)
                     (send-event (ppointer->process s5-1) 'speed 1.5)
                     (send-event (ppointer->process s5-1) 'art-joint-anim "generic-ripples-idle" 0)
                     (set-vector! (-> (the-as process-drawable (-> s5-1 0)) root scale) 1.0 1.0 1.0 1.0)
                     (quaternion-rotate-local-x! (-> (the-as process-drawable (-> s5-1 0)) root quat) (-> self root quat) -16384.0)
                     (let ((v1-43 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                       (let ((a0-29 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                         (let ((a1-11 *up-vector*))
                           (let ((a2-7 8192.0))
                             (.mov vf7 a2-7)
                             )
                           (.lvf vf5 (&-> a1-11 quad))
                           )
                         (.lvf vf4 (&-> a0-29 quad))
                         )
                       (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                       (.mul.x.vf acc vf5 vf7 :mask #b111)
                       (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                       (.svf (&-> v1-43 quad) vf6)
                       )
                     (let ((f0-6 (vector4-dot (-> (the-as process-drawable (-> s5-1 0)) root trans) (the-as vector (-> self plane)))))
                       (let ((v1-50 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                         (let ((a0-33 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                           (let ((a1-12 (-> self plane)))
                             (let ((a2-8 (- f0-6)))
                               (.mov vf7 a2-8)
                               )
                             (.lvf vf5 (&-> a1-12 quad))
                             )
                           (.lvf vf4 (&-> a0-33 quad))
                           )
                         (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                         (.mul.x.vf acc vf5 vf7 :mask #b111)
                         (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                         (.svf (&-> v1-50 quad) vf6)
                         )
                       (let ((v1-53 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                         (let ((a0-36 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                           (let ((a1-13 (-> self plane)))
                             (let ((a2-10 (the-as float (if (< 0.0 f0-6)
                                                            -2048.0
                                                            2048.0
                                                            )
                                                  )
                                          )
                                   )
                               (.mov vf7 a2-10)
                               )
                             (.lvf vf5 (&-> a1-13 quad))
                             )
                           (.lvf vf4 (&-> a0-36 quad))
                           )
                         (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                         (.mul.x.vf acc vf5 vf7 :mask #b111)
                         (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                         (.svf (&-> v1-53 quad) vf6)
                         )
                       )
                     (send-event (ppointer->process s5-1) 'trans-hook (lambda () #f))
                     )
                   )
                 )
               )
             (when (zero? (-> self touch-count))
               (+! (-> self touch-count) 1)
               (set! (-> self flash) 0.375)
               )
             (+! (-> self touch-count) 1)
             (if (and (logtest? (-> proc mask) (process-mask target))
                      (not (logtest? (process-mask projectile) (-> proc mask)))
                      )
                 (play-speech self)
                 )
             )
           )
         )
        (('touched)
         (when (zero? (-> self touch-count))
           (+! (-> self touch-count) 1)
           (set! (-> self flash) 0.375)
           )
         (+! (-> self touch-count) 1)
         (let ((v1-81 (if (type? proc process-focusable)
                          proc
                          )
                      )
               )
           (when v1-81
             (let* ((gp-1 (-> (the-as process-drawable v1-81) root))
                    (a0-45 (if (type? gp-1 collide-shape)
                               gp-1
                               )
                           )
                    )
               (if (and a0-45 (logtest? (-> (the-as collide-shape a0-45) root-prim prim-core collide-as) (collide-spec jak)))
                   (play-speech self)
                   )
               )
             )
           )
         )
        )
      )
    )
  :trans (behavior ()
    (security-wall-method-24 self)
    )
  :code (behavior ()
    (until #f
      (when (and (logtest? (game-feature feature35) (-> *game-info* features))
                 (= (pickup-type pass-slumb-genb) (-> self pass))
                 )
        (go-virtual idle-open)
        #t
        (b! #t cfg-9 :delay (nop!))
        (the-as none 0)
        )
      (let ((f30-0 (calc-fade-from-fog (-> self root trans)))
            (a0-4 (new 'stack-no-clear 'vector))
            (gp-0 (new 'stack-no-clear 'vector))
            )
        (vector-float*! a0-4 (-> self color) f30-0)
        (set-security-color! a0-4)
        (vector-float*! gp-0 (-> self color) (* f30-0 (-> self flash)))
        (seek! (-> self flash) 0.0 (seconds-per-frame))
        (if (nonzero? (-> self touch-count))
            (+! (-> self touch-count) -1)
            )
        (set-security-flash! gp-0)
        )
      (suspend)
      )
    #f
    (label cfg-9)
    )
  )

;; failed to figure out what this is:
(defstate idle-open (security-wall)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('on)
       (let ((v1-2 (-> self root root-prim)))
         (set! (-> v1-2 prim-core collide-as) (-> self root backup-collide-as))
         (let ((v0-0 (the-as int (-> self root backup-collide-with))))
           (set! (-> v1-2 prim-core collide-with) (the-as collide-spec v0-0))
           v0-0
           )
         )
       )
      (('off)
       (let ((v1-4 (-> self root root-prim)))
         (set! (-> v1-4 prim-core collide-as) (collide-spec))
         (set! (-> v1-4 prim-core collide-with) (collide-spec))
         )
       0
       )
      )
    )
  :enter (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    )
  :trans (behavior ()
    (let* ((f28-0 (vector4-dot (the-as vector (-> self plane)) (target-pos 0)))
           (f30-0 (calc-fade-from-fog (-> self root trans)))
           (f28-1 (lerp-scale 0.0 1.0 (fabs f28-0) 163840.0 327680.0))
           (gp-1 (new 'stack-no-clear 'vector))
           )
      (when (= f28-1 0.0)
        (cleanup-for-death self)
        (deactivate self)
        )
      (let ((f0-3 (* f30-0 f28-1)))
        (vector-float*! gp-1 (-> self color) f0-3)
        )
      (set! (-> gp-1 w) 1.0)
      (set-security-color! gp-1)
      )
    )
  :code (behavior ()
    (until #f
      (suspend)
      )
    #f
    )
  )

;; definition for method 22 of type security-wall
;; INFO: Used lq/sq
(defmethod init-wall ((this security-wall) (arg0 vector) (arg1 vector) (arg2 float))
  0.0
  (* 0.5 (vector-vector-distance arg0 arg1))
  (let ((s2-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((v1-3 (new 'process 'collide-shape-prim-mesh s2-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-3 prim-core collide-as) (collide-spec obstacle blocking-plane camera-blocker))
      (set! (-> v1-3 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-3 prim-core action) (collide-action solid))
      (set! (-> v1-3 transform-index) 3)
      (set! (-> s2-0 total-prims) (the-as uint 1))
      (set! (-> s2-0 root-prim) v1-3)
      )
    (set! (-> s2-0 nav-radius) (* 0.75 (-> s2-0 root-prim local-sphere w)))
    (let ((v1-6 (-> s2-0 root-prim)))
      (set! (-> s2-0 backup-collide-as) (-> v1-6 prim-core collide-as))
      (set! (-> s2-0 backup-collide-with) (-> v1-6 prim-core collide-with))
      )
    (set! (-> this root) s2-0)
    )
  (let ((s2-1 (new 'stack-no-clear 'matrix))
        (s1-0 (-> this root))
        )
    (vector+! (-> s1-0 trans) arg0 arg1)
    (vector-float*! (-> s1-0 trans) (-> s1-0 trans) 0.5)
    (+! (-> s1-0 trans y) (/ arg2 2))
    (vector-! (-> s2-1 rvec) arg1 arg0)
    (let ((f30-1 (vector-normalize-ret-len! (-> s2-1 rvec) 1.0)))
      (set! (-> s1-0 scale x) (/ f30-1 METER_LENGTH))
      (set! (-> s1-0 scale y) (/ arg2 METER_LENGTH))
      (set! (-> s1-0 scale z) 1.0)
      (set! (-> s2-1 uvec quad) (-> (new 'static 'vector :y 1.0 :w 1.0) quad))
      (vector-cross! (-> s2-1 fvec) (-> s2-1 rvec) (-> s2-1 uvec))
      (vector-normalize! (-> s2-1 fvec) 1.0)
      (matrix->quaternion (-> s1-0 quat) s2-1)
      (set! (-> this plane quad) (-> s2-1 fvec quad))
      (set! (-> this plane w) (- (vector-dot (-> s2-1 fvec) (-> this root trans))))
      (let ((v0-6 (-> this root root-prim local-sphere)))
        (set! (-> v0-6 x) 0.0)
        (set! (-> v0-6 y) (* 0.00024414062 (/ arg2 2)))
        (set! (-> v0-6 z) 0.0)
        (let ((f0-20 0.5)
              (f1-7 (* f30-1 f30-1))
              (f2-2 arg2)
              )
          (set! (-> v0-6 w) (* f0-20 (sqrtf (+ f1-7 (* f2-2 f2-2)))))
          )
        v0-6
        )
      )
    )
  )

;; definition for method 11 of type security-wall
(defmethod init-from-entity! ((this security-wall) (arg0 entity-actor))
  (ctywide-entity-hack)
  (set! (-> this breach) #f)
  (set! (-> this pass) (res-lump-value arg0 'pickup-type pickup-type :time -1000000000.0))
  (let ((v1-3 (new 'process 'path-control this 'path 0.0 (the-as entity #f) #f)))
    (set! (-> this path) v1-3)
    (if (or (not v1-3) (!= (-> v1-3 curve num-cverts) 2))
        (go process-drawable-art-error "bad path")
        )
    )
  (let ((s5-1 (new 'stack-no-clear 'vector))
        (s4-0 (new 'stack-no-clear 'vector))
        )
    (get-point-in-path! (-> this path) s5-1 0.0 'exact)
    (get-point-in-path! (-> this path) s4-0 1.0 'exact)
    (init-wall this s5-1 s4-0 122880.0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-security-wall" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this root event-self) 'touched)
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (logior! (-> this draw status) (draw-control-status disable-fog))
  (set-security-texture-masks! (the-as vector (-> this draw mgeo header texture-usage-group data 4)))
  (set-vector! (-> this color) 1.0 1.0 1.0 1.0)
  (cond
    ((= (-> this pass) (pickup-type pass-red))
     (set-vector! (-> this color) 1.0 0.0 0.0 1.0)
     )
    ((= (-> this pass) (pickup-type pass-yellow))
     (set-vector! (-> this color) 1.0 1.0 0.0 1.0)
     )
    ((= (-> this pass) (pickup-type pass-green))
     (set-vector! (-> this color) 0.0 1.0 0.0 1.0)
     )
    ((= (-> this pass) (pickup-type pass-blue))
     (set-vector! (-> this color) 0.0 0.0 1.0 1.0)
     )
    )
  (set-security-color! (-> this color))
  (set-vector! (-> this draw color-mult) 0.0 0.0 0.0 0.0)
  (set-vector! (-> this draw color-emissive) 1.0 1.0 1.0 1.0)
  (transform-post)
  (cond
    ((logtest? (game-feature feature35) (-> *game-info* features))
     (= (pickup-type pass-slumb-genb) (-> this pass))
     (go (method-of-object this idle-open))
     )
    (else
      (go (method-of-object this idle-close))
      )
    )
  )

;; definition of type security-wall-child
(deftype security-wall-child (security-wall)
  ((hidden?  symbol)
   )
  (:state-methods
    hide-wall
    )
  )

;; definition for method 3 of type security-wall-child
(defmethod inspect ((this security-wall-child))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type security-wall inspect)))
    (t9-0 this)
    )
  (format #t "~2Thidden?: ~A~%" (-> this hidden?))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defstate idle-close (security-wall-child)
  :virtual #t
  :code (behavior ()
    (until #f
      (let ((f30-0 (calc-fade-from-fog (-> self root trans)))
            (a0-1 (new 'stack-no-clear 'vector))
            (gp-0 (new 'stack-no-clear 'vector))
            )
        (vector-float*! a0-1 (-> self color) f30-0)
        (set-security-color! a0-1)
        (vector-float*! gp-0 (-> self color) (* f30-0 (-> self flash)))
        (seek! (-> self flash) 0.0 (seconds-per-frame))
        (if (nonzero? (-> self touch-count))
            (+! (-> self touch-count) -1)
            )
        (set-security-flash! gp-0)
        )
      (suspend)
      )
    #f
    )
  )

;; failed to figure out what this is:
(defstate hide-wall (security-wall-child)
  :virtual #t
  :parent (security-wall-child idle-close)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       #f
       )
      (else
        ((-> (method-of-type security-wall-child idle-close) event) proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (logior! (-> self draw status) (draw-control-status no-draw))
    (ja-post)
    )
  :code sleep-code
  )

;; definition for function security-wall-child-init-by-other
(defbehavior security-wall-child-init-by-other security-wall-child ((arg0 vector) (arg1 vector) (arg2 float) (arg3 symbol))
  (ctywide-entity-hack)
  (set! (-> self breach) #f)
  (set! (-> self hidden?) arg3)
  (init-wall self arg0 arg1 arg2)
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-security-wall" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> self root event-self) 'touched)
  (logior! (-> self draw status) (draw-control-status disable-fog))
  (set-security-texture-masks! (the-as vector (-> self draw mgeo header texture-usage-group data 4)))
  (set-vector! (-> self color) 1.0 1.0 1.0 1.0)
  (set-vector! (-> self color) 1.0 0.0 0.0 1.0)
  (set-security-color! (-> self color))
  (set-vector! (-> self draw color-mult) 0.0 0.0 0.0 0.0)
  (set-vector! (-> self draw color-emissive) 1.0 1.0 1.0 1.0)
  (transform-post)
  (if (-> self hidden?)
      (go-virtual hide-wall)
      (go-virtual idle-close)
      )
  )

;; definition for function spawn-security-wall
;; WARN: Return type mismatch int vs handle.
(defun spawn-security-wall ((arg0 process) (arg1 vector) (arg2 vector) (arg3 float) (arg4 symbol))
  (the-as handle (ppointer->handle
                   (process-spawn security-wall-child arg1 arg2 arg3 arg4 :name "security-wall-child" :to arg0)
                   )
          )
  )

;; definition of type parking-spot
(deftype parking-spot (process-drawable)
  ((vehicle           handle)
   (spawned           symbol)
   (minimap           connection-minimap)
   (test-sphere       sphere  :inline)
   (expire-time       time-frame)
   (last-update-time  time-frame)
   )
  (:state-methods
    idle
    )
  (:methods
    (parking-spot-method-21 (_type_) none)
    (parking-spot-method-22 (_type_) none)
    (parking-spot-method-23 (_type_ traffic-type) none)
    (parking-spot-method-24 (_type_) none)
    (parking-spot-method-25 (_type_ symbol) symbol)
    (parking-spot-method-26 (_type_) symbol)
    )
  )

;; definition for method 3 of type parking-spot
(defmethod inspect ((this parking-spot))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tvehicle: ~D~%" (-> this vehicle))
  (format #t "~2Tspawned: ~A~%" (-> this spawned))
  (format #t "~2Tminimap: #<connection-minimap @ #x~X>~%" (-> this minimap))
  (format #t "~2Ttest-sphere: #<sphere @ #x~X>~%" (-> this test-sphere))
  (format #t "~2Texpire-time: ~D~%" (-> this expire-time))
  (format #t "~2Tlast-update-time: ~D~%" (-> this last-update-time))
  (label cfg-4)
  this
  )

;; definition for method 25 of type parking-spot
;; WARN: disable def twice: 36. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod parking-spot-method-25 ((this parking-spot) (arg0 symbol))
  (local-vars (f30-0 float))
  (and (not (-> *setting-control* user-current disable-parking-spots?))
       (begin
         (set! f30-0 (vector-vector-distance (-> this root trans) (math-camera-pos)))
         (or (< 163840.0 f30-0) arg0)
         )
       (if (sphere-in-view-frustum? (-> this test-sphere))
           (and (or arg0 (< 614400.0 f30-0)) (< f30-0 1024000.0))
           (< f30-0 614400.0)
           )
       )
  )

;; definition for method 26 of type parking-spot
(defmethod parking-spot-method-26 ((this parking-spot))
  (let ((f30-0 (vector-vector-distance (-> this root trans) (math-camera-pos))))
    (or (< f30-0 163840.0) (and (sphere-in-view-frustum? (-> this test-sphere)) (< f30-0 614400.0)))
    )
  )

;; definition for method 24 of type parking-spot
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod parking-spot-method-24 ((this parking-spot))
  (let ((gp-0 (new 'stack-no-clear 'cquery-with-vec)))
    (set! (-> gp-0 vec0 quad) (-> this root trans quad))
    (set! (-> gp-0 cquery start-pos quad) (-> gp-0 vec0 quad))
    (vector-reset! (-> gp-0 vec1))
    (set! (-> gp-0 vec1 y) 1.0)
    (set-vector! (-> gp-0 cquery move-dist) 0.0 -40960.0 0.0 1.0)
    (let ((v1-5 (-> gp-0 cquery)))
      (set! (-> v1-5 radius) 1024.0)
      (set! (-> v1-5 collide-with) (collide-spec backgnd))
      (set! (-> v1-5 ignore-process0) #f)
      (set! (-> v1-5 ignore-process1) #f)
      (set! (-> v1-5 ignore-pat)
            (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
            )
      (set! (-> v1-5 action-mask) (collide-action solid))
      )
    (let ((f30-0 (fill-and-probe-using-line-sphere *collide-cache* (-> gp-0 cquery))))
      (when (>= f30-0 0.0)
        (vector+float*! (-> gp-0 vec0) (-> gp-0 cquery start-pos) (-> gp-0 cquery move-dist) f30-0)
        (set! (-> gp-0 vec1 quad) (-> gp-0 cquery best-other-tri normal quad))
        (set! (-> this root trans quad) (-> gp-0 vec0 quad))
        (format #t "parking-spot::find-ground: ground y ~M~%" (-> gp-0 vec0 y))
        )
      (if (< f30-0 0.0)
          (format #t "parking-spot::find-ground: could not find ground~%")
          )
      )
    (set! (-> this root trans quad) (-> gp-0 vec0 quad))
    (forward-up-nopitch->quaternion (-> this root quat) (new 'static 'vector :z 1.0 :w 1.0) (-> gp-0 vec1))
    )
  0
  (none)
  )

;; definition for method 21 of type parking-spot
;; WARN: Return type mismatch int vs none.
(defmethod parking-spot-method-21 ((this parking-spot))
  (with-pp
    (let ((s5-0 (the-as vehicle (handle->process (-> this vehicle)))))
      (cond
        (s5-0
          (cond
            ((or (-> *setting-control* user-current disable-parking-spots?)
                 (focus-test? s5-0 dead inactive)
                 (not (logtest? (vehicle-flag waiting-for-player) (-> s5-0 v-flags)))
                 (let ((f0-0 (-> this test-sphere r)))
                   (< (* f0-0 f0-0) (vector-vector-distance-squared (-> s5-0 root trans) (-> this test-sphere)))
                   )
                 )
             (logclear! (-> s5-0 v-flags) (vehicle-flag persistent))
             (cond
               ((-> *setting-control* user-current disable-parking-spots?)
                (when (or (< (-> *display* base-clock frame-counter) (-> *game-info* blackout-time))
                          (>= (-> *setting-control* user-current bg-a) 1.0)
                          (>= (-> *setting-control* user-current bg-a-force) 1.0)
                          (let ((f0-5 (-> this test-sphere r)))
                            (and (>= (* f0-5 f0-5) (vector-vector-distance-squared (-> s5-0 root trans) (-> this test-sphere)))
                                 (not (sphere-in-view-frustum? (-> this test-sphere)))
                                 )
                            )
                          )
                  (send-event (handle->process (-> this vehicle)) 'traffic-off-force)
                  (set! (-> this vehicle) (the-as handle #f))
                  )
                )
               (else
                 (set! (-> this vehicle) (the-as handle #f))
                 )
               )
             )
            (else
              (if (not (-> this minimap))
                  (set! (-> this minimap) (add-icon! *minimap* this (the-as uint 11) (the-as int #f) (the-as vector #t) 0))
                  )
              (cond
                ((parking-spot-method-26 this)
                 (logior! (-> s5-0 v-flags) (vehicle-flag persistent))
                 (+! (-> this expire-time) (- (current-time) (-> pp clock old-frame-counter)))
                 )
                (else
                  )
                )
              (when (< (-> this expire-time) (current-time))
                (logclear! (-> s5-0 v-flags) (vehicle-flag persistent))
                (set! (-> this vehicle) (the-as handle #f))
                )
              )
            )
          )
        (else
          (set! (-> this vehicle) (the-as handle #f))
          (set! (-> this spawned) #f)
          (when (-> this minimap)
            (logior! (-> this minimap flags) (minimap-flag fade-out))
            (set! (-> this minimap) #f)
            )
          )
        )
      )
    0
    (none)
    )
  )

;; definition for function parking-spot-spawn
;; WARN: Return type mismatch object vs vehicle.
(defun parking-spot-spawn ((arg0 traffic-object-spawn-params))
  (set! (-> arg0 proc) #f)
  (the-as vehicle (cond
                    ((= (-> arg0 object-type) (traffic-type bike-d))
                     (let ((v0-0 (the-as object (vehicle-spawn (vehicle-type h-bike-d) arg0))))
                       (if (the-as process-drawable v0-0)
                           (logior! (-> (the-as vehicle v0-0) v-flags) (vehicle-flag traffic-managed))
                           )
                       (set! (-> arg0 proc) (the-as vehicle v0-0))
                       v0-0
                       )
                     )
                    (else
                      (send-event *traffic-manager* 'activate-object arg0)
                      )
                    )
          )
  )

;; definition for method 23 of type parking-spot
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod parking-spot-method-23 ((this parking-spot) (arg0 traffic-type))
  (let ((v1-0 (new 'stack-no-clear 'cquery-with-vec)))
    (let* ((a0-1 (new 'stack-no-clear 'inline-array 'vector 1))
           (a1-2 (the-as uint #xa01013fd))
           (a2-1 (logand -2 a1-2))
           )
      (set! (-> a0-1 0 quad) (-> this test-sphere quad))
      (let ((a1-4 (-> v1-0 cquery)))
        (set! (-> a1-4 best-dist) (the-as float a0-1))
        (set! (-> a1-4 best-other-prim) (the-as collide-shape-prim 1))
        (set! (-> a1-4 collide-with) (the-as collide-spec a2-1))
        (set! (-> a1-4 ignore-process0) #f)
        (set! (-> a1-4 ignore-process1) #f)
        (set! (-> a1-4 ignore-pat)
              (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
              )
        (set! (-> a1-4 best-my-prim) (the-as collide-shape-prim #t))
        (set! (-> a1-4 action-mask) (collide-action solid))
        )
      )
    0
    (when (not (fill-and-probe-using-spheres *collide-cache* (-> v1-0 cquery)))
      (let ((s4-0 (new 'stack 'traffic-object-spawn-params)))
        (set! (-> s4-0 position quad) (-> this root trans quad))
        (mem-copy! (the-as pointer (-> s4-0 rotation)) (the-as pointer (-> this root quat)) 16)
        (+! (-> s4-0 position y) 14336.0)
        (set! (-> s4-0 behavior) (the-as uint 0))
        (set! (-> s4-0 object-type) arg0)
        (set! (-> s4-0 id) (the-as uint 0))
        (set! (-> s4-0 proc) #f)
        (parking-spot-spawn s4-0)
        (when (-> s4-0 proc)
          (let ((v1-9 (-> s4-0 proc)))
            (if v1-9
                (logior! (-> (the-as vehicle v1-9) v-flags) (vehicle-flag persistent))
                )
            )
          (set! (-> this expire-time) (+ (current-time) (seconds 10)))
          (set! (-> this vehicle) (process->handle (-> s4-0 proc)))
          (set! (-> this spawned) #t)
          )
        )
      )
    )
  0
  (none)
  )

;; definition for method 11 of type parking-spot
;; INFO: Used lq/sq
(defmethod init-from-entity! ((this parking-spot) (arg0 entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (set! (-> this minimap) #f)
  (set! (-> this vehicle) (the-as handle #f))
  (set! (-> this spawned) #f)
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause movie))
  (let ((f0-0 (res-lump-float (-> this entity) 'rotoffset)))
    (if (!= f0-0 0.0)
        (quaternion-rotate-y! (-> this root quat) (-> this root quat) f0-0)
        )
    )
  (parking-spot-method-24 this)
  (set! (-> this test-sphere quad) (-> this root trans quad))
  (set! (-> this test-sphere r) 24576.0)
  (set-time! (-> this state-time))
  (when (parking-spot-method-25 this #t)
    (let ((s4-0 29))
      (if (nonzero? (res-lump-value arg0 'use-special-bike uint128 :time -1000000000.0))
          (set! s4-0 28)
          )
      (if (= s4-0 29)
          (set! s4-0 (the-as int (get-random-parking-spot-type *traffic-engine*)))
          )
      (if (!= s4-0 29)
          (parking-spot-method-23 this (the-as traffic-type s4-0))
          )
      )
    )
  (go (method-of-object this idle))
  )

;; failed to figure out what this is:
(defstate idle (parking-spot)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :exit (behavior ()
    (parking-spot-method-21 self)
    (send-event (handle->process (-> self vehicle)) 'traffic-off-force)
    )
  :code sleep-code
  :post (behavior ()
    (when (time-elapsed? (-> self state-time) (seconds 0.25))
      (parking-spot-method-21 self)
      (when (time-elapsed? (-> self last-update-time) (seconds 0.2))
        (set-time! (-> self last-update-time))
        (when (and (not (-> self spawned)) (parking-spot-method-25 self #f))
          (let ((a1-1 (get-random-parking-spot-type *traffic-engine*)))
            (if (!= a1-1 (traffic-type max))
                (parking-spot-method-23 self a1-1)
                )
            )
          )
        )
      0
      )
    )
  )

;; definition of type propa
(deftype propa (process-focusable)
  ((sound-id            sound-id)
   (sound-index         uint32)
   (handle              handle)
   (y-rot               float)
   (hit-points          int32)
   (incoming-attack-id  uint32)
   )
  (:state-methods
    idle
    broken
    )
  (:methods
    (propa-method-30 (_type_) none)
    (propa-method-31 (_type_) none)
    (propa-method-32 (_type_ vector) none)
    )
  )

;; definition for method 3 of type propa
(defmethod inspect ((this propa))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-focusable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tsound-id: ~D~%" (-> this sound-id))
  (format #t "~2Tsound-index: ~D~%" (-> this sound-index))
  (format #t "~2Thandle: ~D~%" (-> this handle))
  (format #t "~2Ty-rot: ~f~%" (-> this y-rot))
  (format #t "~2Thit-points: ~D~%" (-> this hit-points))
  (format #t "~2Tincoming-attack-id: ~D~%" (-> this incoming-attack-id))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-propa propa 0 2 ((1 (meters 999999))) :bounds (static-spherem 0 0 0 3))

;; definition for symbol *propa-sounds*, type (array string)
(define *propa-sounds* (new 'static 'boxed-array :type string
                         "prop009"
                         "prop010"
                         "prop011"
                         "prop012"
                         "prop013"
                         "prop014"
                         "prop015"
                         "prop016"
                         "prop017"
                         "prop018"
                         "prop019"
                         "prop020"
                         "prop021"
                         "prop022"
                         "prop023"
                         "prop024"
                         "prop025"
                         "prop026"
                         "prop028"
                         "prop027"
                         "prop029"
                         "prop030"
                         "prop031"
                         "prop032"
                         "prop033"
                         "prop034"
                         "prop035"
                         "prop036"
                         "prop037"
                         "prop038"
                         "prop039"
                         "prop040"
                         "prop041"
                         "prop042"
                         "prop043"
                         "prop008"
                         "prop006"
                         "prop005"
                         "prop004"
                         "prop002"
                         "prop003"
                         "bar001"
                         "prop044"
                         "prop045"
                         "prop046"
                         "prop047"
                         "prop048"
                         "prop049"
                         "prop051"
                         "prop052"
                         "prop053"
                         "prop054"
                         "prop055"
                         "prop056"
                         )
        )

;; definition for symbol *propa-sounds-class-3*, type (array string)
(define *propa-sounds-class-3* (new 'static 'boxed-array :type string "cityv177"))

;; definition for symbol *propa-sounds-class-2*, type (array string)
(define *propa-sounds-class-2* (new 'static 'boxed-array :type string "cityv176"))

;; definition for symbol *propa-sounds-class-1*, type (array string)
(define *propa-sounds-class-1* (new 'static 'boxed-array :type string "prop050" "spot004" "cityv175"))

;; definition for symbol *propa-sounds-metalheads*, type (array string)
(define *propa-sounds-metalheads* (new 'static 'boxed-array :type string
                                    "prop007"
                                    "prop057"
                                    "cityv096"
                                    "cityv097"
                                    "cityv098"
                                    "cityv099"
                                    "cityv142"
                                    "cityv143"
                                    )
        )

;; definition for symbol *propa-sounds-baron-construction*, type (array string)
(define *propa-sounds-baron-construction* (new 'static 'boxed-array :type string "prop058"))

;; definition for function propa-pu->knocked-type
;; WARN: Return type mismatch int vs knocked-type.
(defun propa-pu->knocked-type ((arg0 penetrate))
  (the-as knocked-type (cond
                         ((logtest? arg0 (penetrate vehicle))
                          7
                          )
                         ((logtest? (penetrate jak-blue-shot) arg0)
                          6
                          )
                         ((logtest? (penetrate jak-yellow-shot enemy-yellow-shot) arg0)
                          4
                          )
                         ((logtest? (penetrate jak-red-shot) arg0)
                          5
                          )
                         ((logtest? (penetrate explode jak-dark-shot enemy-dark-shot) arg0)
                          2
                          )
                         ((logtest? (penetrate dark-bomb dark-smack) arg0)
                          3
                          )
                         ((logtest? arg0 (penetrate mech-punch))
                          1
                          )
                         (else
                           0
                           )
                         )
          )
  )

;; failed to figure out what this is:
(defstate broken (propa)
  :virtual #t
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate idle (propa)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (case message
        (('attack)
         (get-penetrate-using-from-attack-event (the-as process-drawable proc) block)
         (let ((v1-2 (the-as object (-> block param 1))))
           (when (!= (-> (the-as attack-info v1-2) id) (-> self incoming-attack-id))
             (set! (-> self incoming-attack-id) (-> (the-as attack-info v1-2) id))
             (let ((s5-1 (get-penetrate-using-from-attack-event (the-as process-drawable proc) block)))
               (if (and (not (logtest? (penetrate dark-skin) s5-1)) (zero? (propa-pu->knocked-type s5-1)))
                   (set! (-> self hit-points) (- (-> self hit-points) (the int (penetrate-using->damage s5-1))))
                   (+! (-> self hit-points) -10)
                   )
               )
             (cond
               ((< (-> self hit-points) 3)
                (setup-masks (-> self draw) 0 -1)
                (setup-masks (-> self draw) 1 0)
                (let* ((a0-9 (the-as collide-shape-prim-group (-> self root root-prim)))
                       (v1-18 (-> a0-9 child 0))
                       )
                  (let ((a0-11 (-> a0-9 child 1)))
                    (set! (-> a0-11 prim-core collide-as) (-> v1-18 prim-core collide-as))
                    (set! (-> a0-11 prim-core collide-with) (-> v1-18 prim-core collide-with))
                    )
                  (set! (-> v1-18 prim-core collide-as) (collide-spec))
                  (set! (-> v1-18 prim-core collide-with) (collide-spec))
                  )
                0
                (cond
                  ((logtest? (-> *part-group-id-table* 224 flags) (sp-group-flag sp13))
                   (let ((v1-25 (-> *launch-matrix* trans))
                         (a0-12 (new 'stack-no-clear 'vector))
                         )
                     (let ((a1-9 (-> self root trans)))
                       (let ((a2-3 *up-vector*))
                         (let ((a3-2 8192.0))
                           (.mov vf7 a3-2)
                           )
                         (.lvf vf5 (&-> a2-3 quad))
                         )
                       (.lvf vf4 (&-> a1-9 quad))
                       )
                     (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                     (.mul.x.vf acc vf5 vf7 :mask #b111)
                     (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                     (.svf (&-> a0-12 quad) vf6)
                     (set! (-> v1-25 quad) (-> a0-12 quad))
                     )
                   (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 224))
                   )
                  (else
                    (let ((v1-40 (-> *launch-matrix* trans))
                          (a0-17 (new 'stack-no-clear 'vector))
                          )
                      (let ((a1-14 (-> self root trans)))
                        (let ((a2-9 *up-vector*))
                          (let ((a3-6 8192.0))
                            (.mov vf7 a3-6)
                            )
                          (.lvf vf5 (&-> a2-9 quad))
                          )
                        (.lvf vf4 (&-> a1-14 quad))
                        )
                      (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                      (.mul.x.vf acc vf5 vf7 :mask #b111)
                      (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                      (.svf (&-> a0-17 quad) vf6)
                      (set! (-> v1-40 quad) (-> a0-17 quad))
                      )
                    (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 224))
                    )
                  )
                (go-virtual broken)
                )
               ((< (-> self hit-points) 6)
                (setup-masks (-> self draw) 0 -1)
                (setup-masks (-> self draw) 2 0)
                )
               )
             )
           )
         )
        )
      )
    )
  :exit (behavior ()
    (when (nonzero? (-> self sound-id))
      (sound-stop (-> self sound-id))
      (set! (-> self sound-id) (new 'static 'sound-id))
      0
      )
    )
  :code sleep-code
  :post (behavior ()
    (cond
      ((or (not (-> *setting-control* user-current speech-control))
           (< 245760.0 (vector-vector-distance (camera-pos) (-> self root trans)))
           )
       (when (nonzero? (-> self sound-id))
         (set-action!
           *gui-control*
           (gui-action stop)
           (-> self sound-id)
           (gui-channel none)
           (gui-action none)
           (the-as string #f)
           (the-as (function gui-connection symbol) #f)
           (the-as process #f)
           )
         (set! (-> self sound-id) (new 'static 'sound-id))
         (+! (-> self sound-index) 1)
         (when (>= (-> self sound-index) (the-as uint (-> *propa-sounds* length)))
           (set! (-> self sound-index) (the-as uint 0))
           0
           )
         )
       )
      ((< (vector-vector-distance (camera-pos) (-> self root trans)) 225280.0)
       (cond
         ((zero? (-> self sound-id))
          (set! (-> self sound-id) (add-process
                                     *gui-control*
                                     self
                                     (gui-channel alert)
                                     (gui-action play)
                                     (-> *propa-sounds* (-> self sound-index))
                                     -99.0
                                     0
                                     )
                )
          (let ((a1-4 (new 'stack-no-clear 'vector)))
            (set! (-> a1-4 quad) (-> self root trans quad))
            (set! (-> a1-4 w) 40960.0)
            (propa-method-32 self a1-4)
            )
          )
         (else
           (when *sound-player-enable*
             (let ((gp-2 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
               (set! (-> gp-2 command) (sound-command set-param))
               (set! (-> gp-2 id) (-> self sound-id))
               (set! (-> gp-2 params fo-min) 40)
               (set! (-> gp-2 params fo-max) 55)
               (set! (-> gp-2 params fo-curve) 2)
               (let ((a1-5 (-> self root trans)))
                 (let ((s5-0 self))
                   (when (= a1-5 #t)
                     (if (and s5-0 (type? s5-0 process-drawable) (nonzero? (-> s5-0 root)))
                         (set! a1-5 (-> s5-0 root trans))
                         (set! a1-5 (the-as vector #f))
                         )
                     )
                   )
                 (sound-trans-convert (-> gp-2 params trans) a1-5)
                 )
               (set! (-> gp-2 params mask) (the-as uint 480))
               (-> gp-2 id)
               )
             )
           (when (= (get-status *gui-control* (-> self sound-id)) (gui-status unknown))
             (set! (-> self sound-id) (new 'static 'sound-id))
             (+! (-> self sound-index) 1)
             (when (>= (-> self sound-index) (the-as uint (-> *propa-sounds* length)))
               (set! (-> self sound-index) (the-as uint 0))
               0
               )
             )
           )
         )
       )
      )
    (let ((s5-1 (matrix->trans (-> self node-list data 3 bone transform) (new 'stack-no-clear 'vector)))
          (s4-0 (new 'stack-no-clear 'vector))
          (gp-3 (new 'stack-no-clear 'matrix))
          )
      (when (and (nonzero? (-> self handle)) (handle->process (-> self handle)))
        (let* ((s3-0 (handle->process (-> self handle)))
               (a0-25 (if (type? s3-0 process-focusable)
                          s3-0
                          )
                      )
               )
          (when a0-25
            (vector-! s4-0 (-> (the-as process-focusable a0-25) root trans) (-> self root trans))
            (set! (-> self y-rot) (deg-seek
                                    (-> self y-rot)
                                    (deg- (vector-y-angle s4-0) (quaternion-y-angle (-> self root quat)))
                                    (* 36408.89 (seconds-per-frame))
                                    )
                  )
            )
          )
        )
      (matrix-rotate-y! gp-3 (-> self y-rot))
      (matrix<-trans gp-3 s5-1)
      (spawn-from-mat (-> self part) gp-3)
      )
    )
  )

;; definition for method 32 of type propa
;; WARN: Return type mismatch int vs none.
(defmethod propa-method-32 ((this propa) (arg0 vector))
  (let ((s5-0 (the-as process-drawable #f)))
    (let ((f30-0 (the-as float #x7f800000))
          (s3-0 (new 'stack-no-clear 'array 'collide-shape 64))
          )
      (countdown (s2-0 (fill-actor-list-for-box *actor-hash* arg0 s3-0 64))
        (let* ((s1-0 (-> s3-0 s2-0))
               (a0-3 (if (type? s1-0 collide-shape)
                         s1-0
                         )
                     )
               )
          (when a0-3
            (let* ((s0-0 (-> a0-3 process))
                   (s1-1 (if (type? s0-0 process-focusable)
                             s0-0
                             )
                         )
                   )
              (when (and s1-1
                         (!= this s1-1)
                         (not (focus-test? (the-as process-focusable s1-1) inactive))
                         (not (focus-test? (the-as process-focusable s1-1) disable))
                         (not (focus-test? (the-as process-focusable s1-1) dead))
                         (not (logtest? (process-mask guard) (-> s1-1 mask)))
                         (not (logtest? (process-mask crate) (-> s1-1 mask)))
                         (not (logtest? (process-mask vehicle) (-> s1-1 mask)))
                         )
                (let ((f0-0 (vector-vector-xz-distance (-> this root trans) (-> s1-1 root trans))))
                  (when (or (not s5-0) (< f0-0 f30-0))
                    (set! s5-0 s1-1)
                    (set! f30-0 f0-0)
                    )
                  )
                )
              )
            )
          )
        )
      )
    (if (and *target* (< (vector-vector-distance (target-pos 0) arg0) (-> arg0 w)))
        (set! s5-0 *target*)
        )
    (if s5-0
        (set! (-> this handle) (process->handle s5-0))
        (set! (-> this handle) (the-as handle #f))
        )
    )
  0
  (none)
  )

;; definition for method 30 of type propa
;; WARN: Return type mismatch int vs none.
(defmethod propa-method-30 ((this propa))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec crate))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-12 prim-core action) (collide-action solid rideable))
      (set! (-> v1-12 transform-index) 3)
      (set-vector! (-> v1-12 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-14 prim-core action) (collide-action solid rideable))
      (set! (-> v1-14 transform-index) 3)
      (set-vector! (-> v1-14 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-17 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-17 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-17 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; definition for method 31 of type propa
;; WARN: Return type mismatch int vs none.
(defmethod propa-method-31 ((this propa))
  (logior! (-> this mask) (process-mask crate))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 259) this))
  0
  (none)
  )

;; definition for method 11 of type propa
(defmethod init-from-entity! ((this propa) (arg0 entity-actor))
  (propa-method-30 this)
  (process-drawable-from-entity! this arg0)
  (ctywide-entity-hack)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-propa" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (propa-method-31 this)
  (set! (-> this sound-index) (the-as uint (rand-vu-int-count (-> *propa-sounds* length))))
  (setup-masks (-> this draw) 0 -1)
  (setup-masks (-> this draw) 4 0)
  (set! (-> this hit-points) 10)
  (transform-post)
  (go (method-of-object this idle))
  )

;; definition of type burning-bush
(deftype burning-bush (process-focusable)
  ((task        game-task-control)
   (part-off    sparticle-launch-control)
   (part-alert  sparticle-launch-control)
   (angle       float)
   (time        float)
   (rotmin      float)
   (rotmax      float)
   (bb-perm     entity-perm)
   )
  (:state-methods
    idle
    talking
    menu
    collect-gems
    )
  (:methods
    (burning-bush-method-32 (_type_) none)
    (burning-bush-method-33 (_type_) none)
    (burning-bush-method-34 (_type_) object)
    )
  )

;; definition for method 3 of type burning-bush
(defmethod inspect ((this burning-bush))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-focusable inspect)))
    (t9-0 this)
    )
  (format #t "~2Ttask: ~A~%" (-> this task))
  (format #t "~2Tpart-off: ~A~%" (-> this part-off))
  (format #t "~2Tpart-alert: ~A~%" (-> this part-alert))
  (format #t "~2Tangle: ~f~%" (-> this angle))
  (format #t "~2Ttime: ~f~%" (-> this time))
  (format #t "~2Trotmin: ~f~%" (-> this rotmin))
  (format #t "~2Trotmax: ~f~%" (-> this rotmax))
  (format #t "~2Tbb-perm: #<entity-perm @ #x~X>~%" (-> this bb-perm))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defstate collect-gems (burning-bush)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :exit (behavior ()
    (process-release? *target*)
    )
  :code (behavior ()
    (until (process-grab? *target* #f)
      (suspend)
      )
    (suspend)
    (let ((gp-0 (-> (get-current-task-event (-> self task)) tex)))
      (format 0 "skull-cost: ~d~%" gp-0)
      (set! (-> *target* game gem) (- (-> *target* game gem) (the float gp-0)))
      (until (time-elapsed? (-> self state-time) (* 45 (the-as int gp-0)))
        (suspend)
        )
      )
    (go-virtual talking)
    )
  )

;; failed to figure out what this is:
(defskelgroup skel-burning-bush burning-bush burning-bush-lod0-jg burning-bush-idle-ja
              ((burning-bush-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 1.5 0 3.5)
              )

;; failed to figure out what this is:
(defstate idle (burning-bush)
  :virtual #t
  :exit (behavior ()
    '()
    )
  :trans (behavior ()
    (let ((gp-0 (get-current-task-event (-> self task))))
      (let ((s5-0 (new 'stack-no-clear 'matrix)))
        (let* ((a2-0 (-> self node-list data 3 bone transform))
               (v1-4 (-> a2-0 rvec quad))
               (a0-1 (-> a2-0 uvec quad))
               (a1-0 (-> a2-0 fvec quad))
               (a2-1 (-> a2-0 trans quad))
               )
          (set! (-> s5-0 rvec quad) v1-4)
          (set! (-> s5-0 uvec quad) a0-1)
          (set! (-> s5-0 fvec quad) a1-0)
          (set! (-> s5-0 trans quad) a2-1)
          )
        (when (< (vector-dot
                   (-> s5-0 fvec)
                   (vector-! (new 'stack-no-clear 'vector) (camera-pos) (matrix->trans s5-0 (new 'stack-no-clear 'vector)))
                   )
                 0.0
                 )
          )
        (let ((v1-11 (-> self entity extra perm)))
          (logior! (-> v1-11 status) (entity-perm-status bit-5))
          (set! (-> self bb-perm) v1-11)
          (logior! (-> v1-11 status) (entity-perm-status bit-14))
          )
        (cond
          ((= (-> self bb-perm user-object 0) 1)
           (if (nonzero? (-> gp-0 action))
               (spawn-from-mat (-> self part) s5-0)
               )
           )
          ((= (-> gp-0 action) (game-task-action show))
           (spawn-from-mat (-> self part-off) s5-0)
           )
          ((= (-> gp-0 action) (game-task-action play))
           (spawn-from-mat (-> self part-off) s5-0)
           )
          ((= (-> gp-0 action) (game-task-action menu))
           (spawn-from-mat (-> self part) s5-0)
           )
          (else
            )
          )
        )
      (cond
        ((and (or (= (-> gp-0 action) (game-task-action show)) (= (-> gp-0 action) (game-task-action menu)))
              (and (burning-bush-method-34 self) (can-display-query? self (the-as string #f) -99.0))
              )
         (let ((s4-2
                 (new 'stack 'font-context *font-default-matrix* 32 300 0.0 (font-color default) (font-flags shadow kerning))
                 )
               (s5-1 (-> gp-0 tex))
               )
           (set! (-> s4-2 flags) (font-flags shadow kerning large))
           (let ((v1-36 s4-2))
             (set! (-> v1-36 width) (the float 340))
             )
           (let ((v1-37 s4-2))
             (set! (-> v1-37 height) (the float 80))
             )
           (let ((v1-38 s4-2))
             (set! (-> v1-38 scale) 0.6)
             )
           (let ((v1-41 (-> self entity extra perm)))
             (logior! (-> v1-41 status) (entity-perm-status bit-5))
             (set! (-> self bb-perm) v1-41)
             (logior! (-> v1-41 status) (entity-perm-status bit-14))
             )
           (cond
             ((zero? (-> self bb-perm user-object 0))
              (let ((s3-1 print-game-text))
                (format (clear *temp-string*) (lookup-text! *common-text* (text-id text-061d) #f) s5-1)
                (s3-1 *temp-string* s4-2 #f 44 (bucket-id hud-draw-hud-alpha))
                )
              (logior! (-> *hud-skullgem* 0 flags) (hud-flags show))
              )
             (else
               (let ((s3-2 print-game-text))
                 (format (clear *temp-string*) (lookup-text! *common-text* (text-id press-triangle-to-talk) #f))
                 (s3-2 *temp-string* s4-2 #f 44 (bucket-id hud-draw-hud-alpha))
                 )
               )
             )
           (when (cpad-pressed? 0 triangle)
             (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
             (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
             (cond
               ((= (-> gp-0 action) (game-task-action menu))
                (go-virtual menu)
                )
               ((and (zero? (-> self bb-perm user-object 0))
                     (or (= s5-1 (the int (-> *target* game gem)))
                         (< (the-as uint s5-1) (the-as uint (the int (-> *target* game gem))))
                         )
                     )
                (set! (-> self bb-perm user-object 0) 1)
                (go-virtual collect-gems)
                )
               ((= (-> self bb-perm user-object 0) 1)
                (go-virtual talking)
                )
               (else
                 (sound-play "skull-negative")
                 )
               )
             )
           )
         )
        (else
          (if *hud-skullgem*
              (logclear! (-> *hud-skullgem* 0 flags) (hud-flags show))
              )
          )
        )
      )
    )
  :code sleep-code
  :post (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when *target*
        (let* ((a0-0 (-> *target* neck))
               (t9-0 (method-of-object a0-0 look-at!))
               (a1-0 (new 'stack-no-clear 'vector))
               )
          (let ((v1-4 (-> self root trans)))
            (let ((a2-0 *up-vector*))
              (let ((a3-1 20480.0))
                (.mov vf7 a3-1)
                )
              (.lvf vf5 (&-> a2-0 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-0 quad) vf6)
          (t9-0 a0-0 a1-0 #f self)
          )
        )
      )
    )
  )

;; failed to figure out what this is:
(defstate talking (burning-bush)
  :virtual #t
  :enter (behavior ()
    (set-setting! 'minimap 'clear 0.0 (minimap-flag minimap))
    (set! (-> self time) -1.0)
    (process-entity-status! self (entity-perm-status no-kill) #t)
    )
  :exit (behavior ()
    (remove-setting! 'music-volume)
    (remove-setting! 'sfx-volume)
    (remove-setting! 'dialog-volume)
    (remove-setting! 'minimap)
    (set! (-> *part-id-table* 1180 init-specs 4 initial-valuef) 14336.0)
    (set! (-> *part-id-table* 1181 init-specs 4 initial-valuef) 16384.0)
    (send-event *camera* 'change-target *target*)
    (remove-setting! 'interp-time)
    (remove-setting! 'mode-name)
    )
  :trans (behavior ()
    (local-vars
      (sv-272 vector)
      (sv-288 quaternion)
      (sv-304 (function float float float float float float))
      (sv-320 float)
      (sv-336 float)
      )
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when (!= (-> self time) -1.0)
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (new 'stack-no-clear 'vector)
          (let ((s5-0 gp-0)
                (s4-0 (-> self root trans))
                (s3-0 vector-orient-by-quat!)
                (s2-0 (new 'stack-no-clear 'vector))
                (s1-0 (new 'static 'vector :y 16384.0 :z 40960.0 :w 1.0))
                (s0-0 quaternion-rotate-local-y!)
                )
            (set! sv-272 (new 'stack-no-clear 'vector))
            (set! sv-288 (-> self root quat))
            (set! sv-304 lerp-scale)
            (set! sv-320 (-> self rotmin))
            (set! sv-336 (-> self rotmax))
            (let* ((a2-0 (sin (* 7281.778 (-> self time))))
                   (a3-0 -1.0)
                   (t0-0 1.0)
                   (a2-1 (sv-304 sv-320 sv-336 a2-0 a3-0 t0-0))
                   )
              (vector+! s5-0 s4-0 (s3-0 s2-0 s1-0 (s0-0 (the-as quaternion sv-272) sv-288 a2-1)))
              )
            )
          (set! (-> *camera* slave 0 trans quad) (-> gp-0 quad))
          (let ((t9-4 forward-down->inv-matrix)
                (a0-6 (-> *camera* slave 0 tracking))
                (a1-3 (new 'stack-no-clear 'vector))
                (v1-18 (new 'stack-no-clear 'vector))
                )
            (let ((a2-4 (-> self root trans)))
              (let ((a3-1 *up-vector*))
                (let ((t0-2 20480.0))
                  (.mov vf7 t0-2)
                  )
                (.lvf vf5 (&-> a3-1 quad))
                )
              (.lvf vf4 (&-> a2-4 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> v1-18 quad) vf6)
            (t9-4 (the-as matrix a0-6) (vector-! a1-3 v1-18 gp-0) (-> *camera* local-down))
            )
          )
        )
      (let ((gp-1 (new 'stack-no-clear 'matrix)))
        (let* ((a2-6 (-> self node-list data 3 bone transform))
               (v1-23 (-> a2-6 rvec quad))
               (a0-7 (-> a2-6 uvec quad))
               (a1-5 (-> a2-6 fvec quad))
               (a2-7 (-> a2-6 trans quad))
               )
          (set! (-> gp-1 rvec quad) v1-23)
          (set! (-> gp-1 uvec quad) a0-7)
          (set! (-> gp-1 fvec quad) a1-5)
          (set! (-> gp-1 trans quad) a2-7)
          )
        (if (< (vector-dot
                 (-> gp-1 fvec)
                 (vector-! (new 'stack-no-clear 'vector) (camera-pos) (matrix->trans gp-1 (new 'stack-no-clear 'vector)))
                 )
               0.0
               )
            (matrix*! gp-1 (matrix-rotate-y! (new 'stack-no-clear 'matrix) 32768.0) gp-1)
            )
        (+! (-> self angle) (* 100.0 (rand-vu)))
        (set! (-> *part-id-table* 1180 init-specs 4 initial-valuef)
              (+ 14336.0 (* 1228.8 (cos (* 182.04445 (-> self angle)))))
              )
        (set! (-> *part-id-table* 1181 init-specs 4 initial-valuef)
              (+ 2048.0 (-> *part-id-table* 1180 init-specs 4 initial-valuef))
              )
        (spawn-from-mat (-> self part) gp-1)
        )
      )
    )
  :code (behavior ()
    (set-setting! 'mode-name 'cam-really-fixed 0.0 0)
    (suspend)
    (until (process-grab? *target* #f)
      (suspend)
      )
    (suspend)
    (if *target*
        (set! (-> *target* neck flex-blend) 1.0)
        )
    (add-setting! 'music-volume 'rel (-> *setting-control* user-current music-volume-movie) 0)
    (add-setting! 'sfx-volume 'rel (-> *setting-control* user-current sfx-volume-movie) 0)
    (add-setting! 'dialog-volume 'rel (-> *setting-control* user-current dialog-volume-talker) 0)
    (set-time! (-> self state-time))
    (let* ((v1-21 (get-current-task-event (-> self task)))
           (gp-0 (add-process *gui-control* self (gui-channel bbush) (gui-action play) (-> v1-21 scene) -99.0 0))
           )
      (let ((s5-0 (current-time)))
        (while (and (nonzero? (get-status *gui-control* gp-0)) (not (time-elapsed? s5-0 (seconds 60))))
          (set! (-> self time) (* 0.0033333334 (the float (- (current-time) (-> self state-time)))))
          (suspend)
          (when (cpad-pressed? 0 triangle)
            (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
            (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
            (sound-play "inter-burn-bush")
            (goto cfg-13)
            )
          )
        )
      (label cfg-13)
      (set-action!
        *gui-control*
        (gui-action stop)
        gp-0
        (gui-channel none)
        (gui-action none)
        (the-as string #f)
        (the-as (function gui-connection symbol) #f)
        (the-as process #f)
        )
      )
    (until (process-release? *target*)
      (suspend)
      )
    (task-node-close! (-> self task current-node) 'event)
    (go-virtual idle)
    )
  :post (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when *target*
        (let* ((a0-0 (-> *target* neck))
               (t9-0 (method-of-object a0-0 look-at!))
               (a1-0 (new 'stack-no-clear 'vector))
               )
          (let ((v1-4 (-> self root trans)))
            (let ((a2-0 *up-vector*))
              (let ((a3-1 20480.0))
                (.mov vf7 a3-1)
                )
              (.lvf vf5 (&-> a2-0 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-0 quad) vf6)
          (t9-0 a0-0 a1-0 #f self)
          )
        )
      )
    )
  )

;; failed to figure out what this is:
(defstate menu (burning-bush)
  :virtual #t
  :enter (behavior ()
    (set-setting! 'minimap 'clear 0.0 (minimap-flag minimap))
    (set! (-> self time) -1.0)
    (set-time! (-> self state-time))
    )
  :exit (behavior ()
    (remove-setting! 'minimap)
    (send-event *camera* 'change-target *target*)
    (remove-setting! 'interp-time)
    (remove-setting! 'mode-name)
    )
  :trans (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when (time-elapsed? (-> self state-time) (seconds 1.5))
        (let ((gp-0 0)
              (s5-0 0)
              )
          (when (cpad-pressed? 0 down l-analog-down)
            (+! s5-0 1)
            (if (< (+ gp-0 -1) s5-0)
                (set! s5-0 (+ gp-0 -1))
                (sound-play "menu-up-down")
                )
            )
          (when (cpad-pressed? 0 up l-analog-up)
            (+! s5-0 -1)
            (if (< s5-0 0)
                (set! s5-0 0)
                (sound-play "menu-up-down")
                )
            )
          (let* ((s4-2 40)
                 (s3-2 36)
                 (s2-0 (- 228 (* gp-0 (/ s4-2 2))))
                 (v1-19 (new
                          'stack
                          'font-context
                          *font-default-matrix*
                          s3-2
                          s2-0
                          0.0
                          (font-color default)
                          (font-flags shadow kerning)
                          )
                        )
                 )
            (set! (-> v1-19 flags) (font-flags shadow kerning middle middle-vert large))
            (let ((a0-17 v1-19))
              (set! (-> a0-17 width) (the float 440))
              )
            (let ((a0-18 v1-19))
              (set! (-> a0-18 height) (the float 50))
              )
            (let ((a0-19 v1-19))
              (set! (-> a0-19 scale) 1.0)
              )
            (let ((a0-20 v1-19)
                  (a2-3 s3-2)
                  (a1-6 40)
                  )
              (set! (-> a0-20 origin x) (the float a2-3))
              (set! (-> a0-20 origin y) (the float a1-6))
              )
            (let ((a1-7 v1-19))
              (set! (-> a1-7 color) (font-color progress-old-yellow))
              )
            (let ((a0-22 v1-19))
              (set! (-> a0-22 height) (the float s4-2))
              )
            (dotimes (a0-23 gp-0)
              (let ((a1-9 v1-19)
                    (a3-3 s3-2)
                    (a2-4 s2-0)
                    )
                (set! (-> a1-9 origin x) (the float a3-3))
                (set! (-> a1-9 origin y) (the float a2-4))
                )
              (let ((a1-10 v1-19))
                (set! (-> a1-10 scale) (if (= a0-23 s5-0)
                                           0.8
                                           0.6
                                           )
                      )
                )
              (let ((a2-6 v1-19))
                (set! (-> a2-6 color) (if (= a0-23 s5-0)
                                          (font-color progress-old-selected)
                                          (font-color default)
                                          )
                      )
                )
              (+! s2-0 s4-2)
              )
            )
          )
        )
      (when (!= (-> self time) -1.0)
        (let ((gp-1 (new 'stack-no-clear 'vector)))
          (new 'stack-no-clear 'vector)
          (vector+! gp-1 (-> self root trans) (vector-orient-by-quat!
                                                (new 'stack-no-clear 'vector)
                                                (new 'static 'vector :y 24166.4 :z 32768.0 :w 1.0)
                                                (-> self root quat)
                                                )
                    )
          (set! (-> *camera* slave 0 trans quad) (-> gp-1 quad))
          (let ((t9-6 forward-down->inv-matrix)
                (a0-27 (-> *camera* slave 0 tracking))
                (a1-13 (new 'stack-no-clear 'vector))
                (v1-35 (new 'stack-no-clear 'vector))
                )
            (let ((a2-9 (-> self root trans)))
              (let ((a3-4 *up-vector*))
                (let ((t0-4 24166.4))
                  (.mov vf7 t0-4)
                  )
                (.lvf vf5 (&-> a3-4 quad))
                )
              (.lvf vf4 (&-> a2-9 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> v1-35 quad) vf6)
            (t9-6 (the-as matrix a0-27) (vector-! a1-13 v1-35 gp-1) (-> *camera* local-down))
            )
          )
        )
      (let ((gp-2 (new 'stack-no-clear 'matrix)))
        (let* ((a2-11 (-> self node-list data 3 bone transform))
               (v1-40 (-> a2-11 rvec quad))
               (a0-28 (-> a2-11 uvec quad))
               (a1-15 (-> a2-11 fvec quad))
               (a2-12 (-> a2-11 trans quad))
               )
          (set! (-> gp-2 rvec quad) v1-40)
          (set! (-> gp-2 uvec quad) a0-28)
          (set! (-> gp-2 fvec quad) a1-15)
          (set! (-> gp-2 trans quad) a2-12)
          )
        (if (< (vector-dot
                 (-> gp-2 fvec)
                 (vector-! (new 'stack-no-clear 'vector) (camera-pos) (matrix->trans gp-2 (new 'stack-no-clear 'vector)))
                 )
               0.0
               )
            (matrix*! gp-2 (matrix-rotate-y! (new 'stack-no-clear 'matrix) 32768.0) gp-2)
            )
        (spawn-from-mat (-> self part-off) gp-2)
        )
      )
    )
  :code (behavior ()
    (set-setting! 'mode-name 'cam-really-fixed 0.0 0)
    (suspend)
    (until (process-grab? *target* #f)
      (suspend)
      )
    (set! (-> self time) 0.0)
    (let ((s4-0 #f))
      (let ((gp-0 (add-process *gui-control* self (gui-channel bbush) (gui-action play) "cityv174" -99.0 0)))
        (let ((s5-0 (current-time)))
          (while (and (nonzero? (get-status *gui-control* gp-0)) (not (time-elapsed? s5-0 (seconds 60))) (not s4-0))
            (suspend)
            (when (or (cpad-pressed? 0 triangle) (cpad-pressed? 0 confirm))
              (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle circle x confirm))
              (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle circle x confirm))
              (sound-play "inter-burn-bush")
              (set! s4-0 #t)
              )
            )
          )
        (set-action!
          *gui-control*
          (gui-action stop)
          gp-0
          (gui-channel none)
          (gui-action none)
          (the-as string #f)
          (the-as (function gui-connection symbol) #f)
          (the-as process #f)
          )
        )
      (when (not s4-0)
        (until #f
          (when (or (cpad-pressed? 0 confirm) (cpad-pressed? 0 triangle))
            (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle circle x confirm))
            (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle circle x confirm))
            (sound-play "menu-pick")
            #t
            (goto cfg-23)
            )
          (suspend)
          )
        #f
        )
      )
    (until (process-release? *target*)
      (label cfg-23)
      (suspend)
      )
    (go-virtual idle)
    )
  :post (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when *target*
        (let* ((a0-0 (-> *target* neck))
               (t9-0 (method-of-object a0-0 look-at!))
               (a1-0 (new 'stack-no-clear 'vector))
               )
          (let ((v1-4 (-> self root trans)))
            (let ((a2-0 *up-vector*))
              (let ((a3-1 20480.0))
                (.mov vf7 a3-1)
                )
              (.lvf vf5 (&-> a2-0 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-0 quad) vf6)
          (t9-0 a0-0 a1-0 #f self)
          )
        )
      )
    )
  )

;; definition for method 34 of type burning-bush
(defmethod burning-bush-method-34 ((this burning-bush))
  (let* ((gp-1 (vector-! (new 'stack-no-clear 'vector) (target-pos 0) (-> this root trans)))
         (f30-0 (vector-dot (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)) gp-1))
         (f0-2 (vector-dot (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)) gp-1))
         )
    (and *target*
         (not (focus-test? *target* pilot))
         (< (fabs f30-0) 10240.0)
         (< 0.0 f0-2)
         (< (fabs f0-2) 20480.0)
         )
    )
  )

;; definition for method 32 of type burning-bush
;; WARN: Return type mismatch int vs none.
(defmethod burning-bush-method-32 ((this burning-bush))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-6 prim-core action) (collide-action solid rideable))
      (set! (-> v1-6 transform-index) 3)
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; definition for method 33 of type burning-bush
;; WARN: Return type mismatch int vs none.
(defmethod burning-bush-method-33 ((this burning-bush))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 260) this))
  (set! (-> this part-off) (create-launch-control (-> *part-group-id-table* 261) this))
  (set! (-> this part-alert) (create-launch-control (-> *part-group-id-table* 262) this))
  0
  (none)
  )

;; definition for method 7 of type burning-bush
;; WARN: Return type mismatch process-focusable vs burning-bush.
(defmethod relocate ((this burning-bush) (offset int))
  (if (nonzero? (-> this task))
      (&+! (-> this task) offset)
      )
  (if (nonzero? (-> this part-off))
      (&+! (-> this part-off) offset)
      )
  (if (nonzero? (-> this part-alert))
      (&+! (-> this part-alert) offset)
      )
  (the-as burning-bush ((method-of-type process-focusable relocate) this offset))
  )

;; definition for method 10 of type burning-bush
(defmethod deactivate ((this burning-bush))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (nonzero? (-> this part-off))
      (kill-particles (-> this part-off))
      )
  (if (nonzero? (-> this part-alert))
      (kill-particles (-> this part-alert))
      )
  ((method-of-type process-focusable deactivate) this)
  (none)
  )

;; definition for method 12 of type burning-bush
(defmethod run-logic? ((this burning-bush))
  "Should this process be run? Checked by execute-process-tree."
  (or (not (logtest? (-> this mask) (process-mask actor-pause)))
      (or (and (nonzero? (-> this draw))
               (logtest? (-> this draw status) (draw-control-status on-screen))
               (>= (+ (-> *ACTOR-bank* pause-dist) (-> this root pause-adjust-distance))
                   (vector-vector-distance (-> this root trans) (math-camera-pos))
                   )
               )
          (and (nonzero? (-> this skel)) (!= (-> this skel root-channel 0) (-> this skel channel)))
          (and (nonzero? (-> this draw)) (logtest? (-> this draw status) (draw-control-status uninited)))
          )
      )
  )

;; definition for method 11 of type burning-bush
(defmethod init-from-entity! ((this burning-bush) (arg0 entity-actor))
  (burning-bush-method-32 this)
  (process-drawable-from-entity! this arg0)
  (ctywide-entity-hack)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-burning-bush" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (burning-bush-method-33 this)
  (set! (-> this rotmin) (res-lump-float arg0 'rotmin :default -5461.3335))
  (set! (-> this rotmax) (res-lump-float arg0 'rotmax :default 5461.3335))
  (let ((f0-2 (res-lump-float (-> this entity) 'rotoffset)))
    (if (!= f0-2 0.0)
        (quaternion-rotate-local-y! (-> this root quat) (-> this root quat) f0-2)
        )
    )
  (set! (-> this task)
        (new 'process 'game-task-control (res-lump-value arg0 'task-actor game-task-actor :time -1000000000.0))
        )
  (set! (-> this angle) 0.0)
  (set! (-> this root pause-adjust-distance) 819200.0)
  (transform-post)
  (go (method-of-object this idle))
  )

;; definition of type city-burning-bush-get-on-info
(deftype city-burning-bush-get-on-info (structure)
  ((trans         vector      :inline)
   (quat          quaternion  :inline)
   (camera-trans  vector      :inline)
   (camera-rot    float       9)
   (time          float)
   (fov           float)
   )
  )

;; definition for method 3 of type city-burning-bush-get-on-info
(defmethod inspect ((this city-burning-bush-get-on-info))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'city-burning-bush-get-on-info)
  (format #t "~1Ttrans: #<vector @ #x~X>~%" (-> this trans))
  (format #t "~1Tquat: #<quaternion @ #x~X>~%" (-> this quat))
  (format #t "~1Tcamera-trans: #<vector @ #x~X>~%" (-> this camera-trans))
  (format #t "~1Tcamera-rot[9] @ #x~X~%" (-> this camera-rot))
  (format #t "~1Ttime: ~f~%" (-> this time))
  (format #t "~1Tfov: ~f~%" (-> this fov))
  (label cfg-4)
  this
  )

;; definition for symbol *city-burning-bush-get-on-info*, type (array city-burning-bush-get-on-info)
(define *city-burning-bush-get-on-info*
  (new 'static 'boxed-array :type city-burning-bush-get-on-info
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 1442120.5 :y 32765.543 :z -412846.9 :w 1.0)
      :quat (new 'static 'quaternion :x 0.0006 :y 0.8826 :z -0.0012 :w -0.4699)
      :camera-trans (new 'static 'vector :x 1458548.4 :y 46188.543 :z -449677.72 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.8889 0.0 0.458 -0.0229 0.9987 0.0444 -0.4574 -0.05 0.8878)
      :time 7500.0
      :fov 12743.111
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 2247272.5 :y 67314.484 :z -1134648.9 :w 1.0)
      :quat (new 'static 'quaternion :x -0.1469 :y 0.0545 :z 0.0068 :w 0.9876)
      :camera-trans (new 'static 'vector :x 2279621.8 :y 74105.24 :z -1128908.0 :w 1.0)
      :camera-rot (new 'static 'array float 9 -0.6307 0.0 0.776 -0.2236 0.9575 -0.1817 -0.743 -0.2881 -0.6039)
      :time 5400.0
      :fov 16384.0
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 1438305.1 :y 71998.26 :z -1084914.5 :w 1.0)
      :quat (new 'static 'quaternion :x 0.001 :y -0.9202 :z 0.0002 :w -0.3912)
      :camera-trans (new 'static 'vector :x 1479435.0 :y 85435.59 :z -1095610.4 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.151 0.0 0.9885 0.0056 0.9999 -0.0008 -0.9885 0.0057 0.151)
      :time 5400.0
      :fov 16384.0
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 1466428.2 :y 125903.26 :z -1495985.0 :w 1.0)
      :quat (new 'static 'quaternion :y 0.2215 :w 0.9751)
      :camera-trans (new 'static 'vector :x 1465902.8 :y 102859.57 :z -1401041.8 :w 1.0)
      :camera-rot (new 'static 'array float 9 -0.9864 0.0 0.1639 0.0493 0.9536 0.2967 -0.1563 0.3008 -0.9407)
      :time 6600.0
      :fov 10922.667
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 634022.3 :y 122880.0 :z -697692.56 :w 1.0)
      :quat (new 'static 'quaternion :x -0.0012 :y 0.6246 :z 0.0009 :w -0.7808)
      :camera-trans (new 'static 'vector :x 684180.7 :y 160337.52 :z -642709.1 :w 1.0)
      :camera-rot (new 'static 'array float 9 -0.6785 0.0 0.7345 -0.3495 0.8795 -0.3229 -0.646 -0.4758 -0.5967)
      :time 5100.0
      :fov 10922.667
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 1966872.6 :y 47686.86 :z -206054.19 :w 1.0)
      :quat (new 'static 'quaternion :y 0.9988 :w 0.0482)
      :camera-trans (new 'static 'vector :x 1971155.4 :y 38171.44 :z -273855.7 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.9641 0.0 -0.2652 0.0043 0.9998 0.0158 0.2652 -0.0164 0.964)
      :time 6900.0
      :fov 16384.0
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 2645027.2 :y 7752.499 :z -2422284.8 :w 1.0)
      :quat (new 'static 'quaternion :y -0.9993 :w -0.0352)
      :camera-trans (new 'static 'vector :x 2643901.8 :y 20940.8 :z -2451367.5 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.818 0.0 0.5751 -0.061 0.9943 0.0869 -0.5718 -0.1062 0.8134)
      :time 5400.0
      :fov 16384.0
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 2339761.0 :y 92694.12 :z -3021732.8 :w 1.0)
      :quat (new 'static 'quaternion :y 0.3606 :w -0.9326)
      :camera-trans (new 'static 'vector :x 2329062.2 :y 105224.6 :z -2983756.5 :w 1.0)
      :camera-rot (new 'static 'array float 9 -0.7717 0.0 -0.6359 0.3292 0.8555 -0.3995 0.544 -0.5177 -0.6602)
      :time 6000.0
      :fov 16384.0
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 3210766.0 :y 32764.314 :z 787847.2 :w 1.0)
      :quat (new 'static 'quaternion :x 0.0008 :y 0.5021 :z 0.0011 :w -0.8647)
      :camera-trans (new 'static 'vector :x 3185149.2 :y 40500.84 :z 778470.6 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.1119 0.0 -0.9937 0.0693 0.9975 0.0078 0.9912 -0.0697 0.1116)
      :time 6000.0
      :fov 16384.0
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 4139099.2 :y 37910.527 :z 1484301.5 :w 1.0)
      :quat (new 'static 'quaternion :x -0.0002 :y -0.1337 :z 0.0015 :w 0.991)
      :camera-trans (new 'static 'vector :x 4120032.5 :y 53998.387 :z 1506306.0 :w 1.0)
      :camera-rot (new 'static 'array float 9 -0.6088 0.0 -0.7932 0.1409 0.984 -0.1082 0.7806 -0.1777 -0.5991)
      :time 3300.0
      :fov 16384.0
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 3936017.2 :y 94799.46 :z 2196627.0 :w 1.0)
      :quat (new 'static 'quaternion :x -0.0015 :y -0.483 :z -0.0002 :w -0.8755)
      :camera-trans (new 'static 'vector :x 3910655.2 :y 104816.23 :z 2183312.2 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.6539 0.0 -0.7564 0.0916 0.9926 0.0792 0.7509 -0.1211 0.6491)
      :time 4200.0
      :fov 16384.0
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 4434624.0 :y 100512.56 :z 2489095.0 :w 1.0)
      :quat (new 'static 'quaternion :x -0.0005 :y 0.1411 :w 0.9899)
      :camera-trans (new 'static 'vector :x 4484939.5 :y 121671.27 :z 2430261.2 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.6538 0.0 0.7566 -0.4974 0.7535 0.4298 -0.5701 -0.6573 0.4926)
      :time 3000.0
      :fov 18204.445
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 3858326.8 :y 99340.695 :z 3912547.5 :w 1.0)
      :quat (new 'static 'quaternion :y 0.0271 :w 0.9996)
      :camera-trans (new 'static 'vector :x 3848977.5 :y 111943.68 :z 3934181.0 :w 1.0)
      :camera-rot (new 'static 'array float 9 -0.8843 0.0 -0.4667 0.1047 0.9744 -0.1984 0.4548 -0.2243 -0.8618)
      :time 3900.0
      :fov 16384.0
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 3764324.2 :y 98499.79 :z 4562610.0 :w 1.0)
      :quat (new 'static 'quaternion :x -0.0012 :y 0.0062 :w 0.9999)
      :camera-trans (new 'static 'vector :x 3691300.0 :y 123541.914 :z 4541654.0 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.2135 0.0 -0.9769 0.2535 0.9657 0.0554 0.9434 -0.2594 0.2062)
      :time 3900.0
      :fov 7281.778
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 4427024.5 :y 74095.414 :z 3948627.5 :w 1.0)
      :quat (new 'static 'quaternion :y -0.972 :w 0.2349)
      :camera-trans (new 'static 'vector :x 4436096.0 :y 88536.266 :z 3978709.8 :w 1.0)
      :camera-rot (new 'static 'array float 9 -0.9909 0.0 0.1338 -0.0287 0.9767 -0.2124 -0.1307 -0.2143 -0.9679)
      :time 3900.0
      :fov 18204.445
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 1377852.2 :y 76197.89 :z 7083083.0 :w 1.0)
      :quat (new 'static 'quaternion :x -0.0004 :y 0.3829 :z -0.001 :w 0.9237)
      :camera-trans (new 'static 'vector :x 1263103.6 :y 188428.28 :z 6971105.5 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.5705 0.0 -0.8212 0.5598 0.7316 0.3889 0.6008 -0.6817 0.4174)
      :time 1800.0
      :fov 5461.3335
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x -942875.9 :y 96113.46 :z 6424137.0 :w 1.0)
      :quat (new 'static 'quaternion :x 0.0002 :y 0.9944 :w 0.1048)
      :camera-trans (new 'static 'vector :x -755284.4 :y 180505.81 :z 6304042.0 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.6079 0.0 0.7939 -0.329 0.9101 0.2519 -0.7225 -0.4143 0.5533)
      :time 2100.0
      :fov 3640.889
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x -1205959.5 :y 114149.375 :z 5692970.5 :w 1.0)
      :quat (new 'static 'quaternion :x -0.0005 :y 0.8807 :z -0.001 :w -0.4736)
      :camera-trans (new 'static 'vector :x -1230954.9 :y 126642.586 :z 5698481.5 :w 1.0)
      :camera-rot (new 'static 'array float 9 -0.1203 0.0 -0.9927 0.4576 0.8874 -0.0554 0.8809 -0.4609 -0.1068)
      :time 6900.0
      :fov 16384.0
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 1641758.8 :y 97295.98 :z 5436796.0 :w 1.0)
      :quat (new 'static 'quaternion :x 0.0001 :y 0.4706 :z 0.0001 :w 0.8823)
      :camera-trans (new 'static 'vector :x 1620224.0 :y 105643.625 :z 5418739.0 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.8069 0.0 -0.5906 0.1079 0.9831 0.1474 0.5807 -0.1826 0.7933)
      :time 4500.0
      :fov 14563.556
      )
    )
  )

;; definition of type task-manager-ctywide-bbush-get-to
(deftype task-manager-ctywide-bbush-get-to (task-manager)
  ((skill  handle)
   )
  (:methods
    (task-manager-ctywide-bbush-get-to-method-32 (_type_) none)
    )
  )

;; definition for method 3 of type task-manager-ctywide-bbush-get-to
(defmethod inspect ((this task-manager-ctywide-bbush-get-to))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type task-manager inspect)))
    (t9-0 this)
    )
  (format #t "~2Tskill: ~D~%" (-> this skill))
  (label cfg-4)
  this
  )

;; definition for method 32 of type task-manager-ctywide-bbush-get-to
;; WARN: Return type mismatch int vs none.
(defmethod task-manager-ctywide-bbush-get-to-method-32 ((this task-manager-ctywide-bbush-get-to))
  (set-setting! 'city-sound '(citybb1) 0.0 2)
  0
  (none)
  )

;; definition for method 21 of type task-manager-ctywide-bbush-get-to
(defmethod set-time-limit ((this task-manager-ctywide-bbush-get-to))
  (let ((t9-0 (method-of-type task-manager set-time-limit)))
    (t9-0 this)
    )
  (set-setting! 'airlock #f 0.0 0)
  (task-manager-ctywide-bbush-get-to-method-32 this)
  (when (nonzero? (-> this skill))
    (let ((a0-5 (handle->process (-> this skill))))
      (if a0-5
          (deactivate a0-5)
          )
      )
    )
  (none)
  )

;; failed to figure out what this is:
(defstate active (task-manager-ctywide-bbush-get-to)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('notify)
       (case (-> block param 0)
         (('pickup)
          (send-event self 'complete)
          )
         (('die)
          (send-event self 'fail)
          )
         )
       )
      (else
        (task-manager-event-handler proc argc message block)
        )
      )
    )
  :code (behavior ()
    (set-setting! 'minimap 'clear 0.0 (minimap-flag minimap))
    (while (not (process-grab? *target* #f))
      (suspend)
      )
    (let ((t1-1 (new 'stack 'fact-info self (pickup-type eco-pill-random) (-> *FACT-bank* default-eco-pill-green-inc)))
          (a0-3 (new 'stack-no-clear 'vector))
          )
      (logior! (-> t1-1 options) (actor-option fade-out))
      (set! (-> t1-1 fade-time)
            (the-as time-frame (the int (-> *city-burning-bush-get-on-info* (-> self info index) time)))
            )
      (set! (-> a0-3 quad) (-> *city-burning-bush-get-on-info* (-> self info index) trans quad))
      (+! (-> a0-3 y) 4096.0)
      (set! (-> self skill)
            (ppointer->handle
              (birth-pickup-at-point a0-3 (pickup-type skill) (-> *FACT-bank* super-skill-inc) #t self t1-1)
              )
            )
      )
    (set-time! (-> self start-time))
    (set! (-> self time-limit)
          (the-as time-frame (the int (+ 300.0 (-> *city-burning-bush-get-on-info* (-> self info index) time))))
          )
    (suspend)
    (send-event (handle->process (-> self skill)) 'get-notify self)
    (set-setting! 'interp-time 'abs 0.0 0)
    (set-setting! 'mode-name 'cam-fixed 0.0 0)
    (set! (-> *ACTOR-bank* birth-max) 1000)
    (suspend)
    (let ((f30-0 (-> *camera* settings fov)))
      (let ((s5-0 (new 'stack-no-clear 'vector)))
        (set! (-> s5-0 quad) (-> *camera-combiner* trans quad))
        (let ((gp-0 (new 'stack-no-clear 'matrix)))
          (let* ((a2-7 (-> *camera-combiner* inv-camera-rot))
                 (v1-46 (-> a2-7 rvec quad))
                 (a0-15 (-> a2-7 uvec quad))
                 (a1-15 (-> a2-7 fvec quad))
                 (a2-8 (-> a2-7 trans quad))
                 )
            (set! (-> gp-0 rvec quad) v1-46)
            (set! (-> gp-0 uvec quad) a0-15)
            (set! (-> gp-0 fvec quad) a1-15)
            (set! (-> gp-0 trans quad) a2-8)
            )
          (let ((s4-0 (new 'stack 'transformq)))
            (let ((v1-52 (-> *city-burning-bush-get-on-info* (-> self info index)))
                  (a1-17 (new 'stack-no-clear 'matrix))
                  )
              (set! (-> s4-0 trans quad) (-> v1-52 camera-trans quad))
              (set-vector! (-> s4-0 scale) 1.0 1.0 1.0 1.0)
              (set! (-> a1-17 rvec x) (-> v1-52 camera-rot 0))
              (set! (-> a1-17 rvec y) (-> v1-52 camera-rot 1))
              (set! (-> a1-17 rvec z) (-> v1-52 camera-rot 2))
              (set! (-> a1-17 rvec w) 0.0)
              (set! (-> a1-17 uvec x) (-> v1-52 camera-rot 3))
              (set! (-> a1-17 uvec y) (-> v1-52 camera-rot 4))
              (set! (-> a1-17 uvec z) (-> v1-52 camera-rot 5))
              (set! (-> a1-17 uvec w) 0.0)
              (set! (-> a1-17 fvec x) (-> v1-52 camera-rot 6))
              (set! (-> a1-17 fvec y) (-> v1-52 camera-rot 7))
              (set! (-> a1-17 fvec z) (-> v1-52 camera-rot 8))
              (set! (-> a1-17 fvec w) 0.0)
              (set! (-> a1-17 trans x) 0.0)
              (set! (-> a1-17 trans y) 0.0)
              (set! (-> a1-17 trans z) 0.0)
              (set! (-> a1-17 trans w) 1.0)
              (matrix->quaternion (-> s4-0 quat) a1-17)
              )
            (send-event *camera* 'teleport-to-transformq s4-0)
            )
          (suspend-for (seconds 3)
            (set! (-> *camera* slave 0 fov) (-> *city-burning-bush-get-on-info* (-> self info index) fov))
            )
          (set! (-> *camera-combiner* trans quad) (-> s5-0 quad))
          (let ((a2-15 (-> *camera-combiner* inv-camera-rot))
                (v1-74 (-> gp-0 rvec quad))
                (a0-24 (-> gp-0 uvec quad))
                (a1-19 (-> gp-0 fvec quad))
                (a3-5 (-> gp-0 trans quad))
                )
            (set! (-> a2-15 rvec quad) v1-74)
            (set! (-> a2-15 uvec quad) a0-24)
            (set! (-> a2-15 fvec quad) a1-19)
            (set! (-> a2-15 trans quad) a3-5)
            )
          )
        )
      (set! (-> *camera* settings fov) f30-0)
      )
    (remove-setting! 'minimap)
    (set! (-> *ACTOR-bank* birth-max) 1000)
    (let ((a0-28 (get-continue-by-name *game-info* (-> self node-info reset fail-info retry continue)))
          (gp-1 (new 'static 'vector :z 1.0))
          )
      (when a0-28
        (move-camera! a0-28)
        (set-vector!
          gp-1
          (-> *camera-combiner* inv-camera-rot uvec x)
          (-> *camera-combiner* inv-camera-rot uvec y)
          (-> *camera-combiner* inv-camera-rot uvec z)
          1.0
          )
        (vector-negate-in-place! gp-1)
        (set-setting! 'string-startup-vector 'abs gp-1 0)
        )
      )
    (persist-with-delay *setting-control* 'interp-time (seconds 0.5) 'interp-time 'abs 0.0 0)
    (remove-setting! 'fov)
    (remove-setting! 'interp-time)
    (remove-setting! 'mode-name)
    (while (not (process-release? *target*))
      (suspend)
      )
    (until #f
      (hud-timer-handler self)
      (suspend)
      )
    #f
    )
  )

;; definition for method 9 of type city-race-ring-info
;; WARN: Return type mismatch int vs none.
(defmethod gen-static-macro ((this city-race-ring-info) (arg0 object))
  (format arg0 "(static-race-ring-info~%")
  (format arg0 "     :pos (~4,,2M ~4,,2M ~4,,2M)~%" (-> this pos x) (-> this pos y) (-> this pos z))
  (let ((f0-3 (-> this pos w)))
    (format arg0 "     :angle (deg ~f)~%" (* 0.005493164 f0-3))
    )
  (if (!= (-> this boost) 1.0)
      (format arg0 "     :boost ~4,,2f~%" (-> this boost))
      )
  (format arg0 "     :dist (meters ~4,,2M)~%" (-> this dist))
  (format arg0 "     ~%)~%")
  0
  (none)
  )

;; definition for method 9 of type city-ambush-info
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod init ((this city-ambush-info) (arg0 traffic-object-spawn-params))
  (set! (-> arg0 position quad) (-> this array 0 pos quad))
  (set! (-> arg0 nav-mesh) (find-nearest-nav-mesh (-> arg0 position) (the-as float #x7f800000)))
  (vector-reset! (-> arg0 velocity))
  (dotimes (s4-0 (-> this count))
    (let ((v1-3 (-> this array s4-0)))
      (set! (-> arg0 position quad) (-> v1-3 pos quad))
      (set! (-> arg0 object-type) (-> v1-3 obj-type))
      )
    (send-event *traffic-manager* 'activate-object arg0)
    0
    )
  0
  (none)
  )

;; definition of type ctyn-lamp
(deftype ctyn-lamp (process-focusable)
  ()
  (:state-methods
    idle
    die
    )
  (:methods
    (ctyn-lamp-method-30 (_type_) none)
    (ctyn-lamp-method-31 (_type_) none)
    )
  )

;; definition for method 3 of type ctyn-lamp
(defmethod inspect ((this ctyn-lamp))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-focusable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-ctyn-lamp ctyn-lamp 0 2 ((1 (meters 999999))) :bounds (static-spherem 0 0 0 5))

;; failed to figure out what this is:
(defskelgroup skel-ctyn-lamp-explode ctyn-lamp 3 5 ((4 (meters 999999))) :bounds (static-spherem 0 0 0 80))

;; definition for symbol *ctyn-lamp-exploder-params*, type joint-exploder-static-params
(define *ctyn-lamp-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      )
    :collide-spec (collide-spec backgnd)
    )
  )

;; failed to figure out what this is:
(defstate idle (ctyn-lamp)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (-> block param 1)
       (let ((s5-0 proc)
             (gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 1)))
             )
         (set! (-> gp-0 fountain-rand-transv-lo quad) (-> (the-as joint-exploder s5-0) root trans quad))
         (set! (-> gp-0 fountain-rand-transv-hi x) 16384.0)
         (set! (-> gp-0 fountain-rand-transv-hi y) 40960.0)
         (process-spawn
           joint-exploder
           (art-group-get-by-name *level* "skel-ctyn-lamp-explode" (the-as (pointer level) #f))
           5
           gp-0
           *ctyn-lamp-exploder-params*
           :name "joint-exploder"
           :to self
           :unk 0
           )
         )
       (go-virtual die)
       )
      )
    )
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate die (ctyn-lamp)
  :virtual #t
  :enter #f
  :exit #f
  :trans #f
  :code (behavior ()
    (sound-play "lamp-hit")
    (let ((v1-3 (-> self root root-prim)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self draw status) (draw-control-status no-draw))
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    )
  :post #f
  )

;; definition for method 30 of type ctyn-lamp
;; WARN: Return type mismatch int vs none.
(defmethod ctyn-lamp-method-30 ((this ctyn-lamp))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate
                                    generic-attack
                                    lunge
                                    flop
                                    punch
                                    spin
                                    roll
                                    uppercut
                                    bonk
                                    tube
                                    flut-attack
                                    board
                                    mech-punch
                                    dark-punch
                                    dark-smack
                                    flut
                                    )
          )
    (let ((v1-7 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-7 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-7 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-7 prim-core action) (collide-action solid))
      (set! (-> v1-7 transform-index) 0)
      (set-vector! (-> v1-7 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-7)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-10 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-10 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-10 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; definition for method 31 of type ctyn-lamp
;; WARN: Return type mismatch int vs none.
(defmethod ctyn-lamp-method-31 ((this ctyn-lamp))
  (logior! (-> this mask) (process-mask crate))
  0
  (none)
  )

;; definition for method 11 of type ctyn-lamp
(defmethod init-from-entity! ((this ctyn-lamp) (arg0 entity-actor))
  (ctyn-lamp-method-30 this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-ctyn-lamp" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (ctyn-lamp-method-31 this)
  (transform-post)
  (go (method-of-object this idle))
  )

;; definition of type fac-lowrez-move
(deftype fac-lowrez-move (structure)
  ((light    light-state  :inline)
   (roty     float)
   (rotz     float)
   (rot-bob  float)
   (wobble   float)
   (bob      float)
   )
  :pack-me
  )

;; definition for method 3 of type fac-lowrez-move
(defmethod inspect ((this fac-lowrez-move))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'fac-lowrez-move)
  (format #t "~1Tlight: #<light-state @ #x~X>~%" (-> this light))
  (format #t "~1Troty: ~f~%" (-> this roty))
  (format #t "~1Trotz: ~f~%" (-> this rotz))
  (format #t "~1Trot-bob: ~f~%" (-> this rot-bob))
  (format #t "~1Twobble: ~f~%" (-> this wobble))
  (format #t "~1Tbob: ~f~%" (-> this bob))
  (label cfg-4)
  this
  )

;; definition of type fac-lorez
(deftype fac-lorez (process-drawable)
  ((move-info  fac-lowrez-move  :inline)
   )
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type fac-lorez
(defmethod inspect ((this fac-lorez))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tmove-info: #<fac-lowrez-move @ #x~X>~%" (-> this move-info))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-fac-lorez fac-lorez fac-lorez-lod0-jg fac-lorez-idle-ja
              ((fac-lorez-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 400)
              )

;; definition for method 11 of type fac-lorez
(defmethod init-from-entity! ((this fac-lorez) (arg0 entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-fac-lorez" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (go (method-of-object this idle))
  )

;; definition for method 12 of type fac-lorez
(defmethod run-logic? ((this fac-lorez))
  "Should this process be run? Checked by execute-process-tree."
  #t
  )

;; failed to figure out what this is:
(defstate idle (fac-lorez)
  :virtual #t
  :trans (behavior ()
    (let ((s5-0 (new 'stack-no-clear 'quaternion))
          (gp-0 (new 'stack-no-clear 'quaternion))
          )
      (quaternion-vector-angle! s5-0 *y-vector* (- (-> self move-info roty)))
      (quaternion-vector-angle! gp-0 *z-vector* (-> self move-info wobble))
      (quaternion*! (-> self root quat) gp-0 s5-0)
      )
    (quaternion-normalize! (-> self root quat))
    (let ((f0-4 (+ (-> self move-info roty) (* 910.2222 (seconds-per-frame)))))
      (set! (-> self move-info roty) (- f0-4 (* (the float (the int (/ f0-4 65536.0))) 65536.0)))
      )
    (let ((f0-7 (+ (-> self move-info rotz) (* 8192.0 (seconds-per-frame)))))
      (set! (-> self move-info rotz) (- f0-7 (* (the float (the int (/ f0-7 65536.0))) 65536.0)))
      )
    (set! (-> self move-info wobble) (* 910.2222 (sin (-> self move-info rotz))))
    (let ((f0-13 (+ (-> self move-info rot-bob) (* 16384.0 (seconds-per-frame)))))
      (set! (-> self move-info rot-bob) (- f0-13 (* (the float (the int (/ f0-13 65536.0))) 65536.0)))
      )
    (set! (-> self move-info bob) (+ -40960.0 (* 40960.0 (sin (-> self move-info rot-bob)))))
    )
  :code sleep-code
  :post ja-post
  )

;; definition of type flitter-spawner
(deftype flitter-spawner (process-drawable)
  ((actor-group          (pointer actor-group)  :offset 204)
   (actor-group-count    int32)
   (spawner              proc-focusable-spawner)
   (desired-spawn-count  int32)
   (spawn-times          (array time-frame))
   (last-seen-times      (array time-frame))
   )
  (:state-methods
    active
    )
  (:methods
    (spawn-flitter (_type_ entity-actor) object)
    )
  )

;; definition for method 3 of type flitter-spawner
(defmethod inspect ((this flitter-spawner))
  (when (not this)
    (set! this this)
    (goto cfg-7)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Troot: ~A~%" (-> this root))
  (format #t "~2Tactor-group: #x~X~%" (-> this actor-group))
  (dotimes (s5-0 (-> this actor-group-count))
    (format #t "~T  [~D]~2Tactor-group: ~`actor-group`P~%" s5-0 (-> this actor-group s5-0))
    )
  (format #t "~2Tactor-group-count: ~D~%" (-> this actor-group-count))
  (format #t "~2Tspawner: ~A~%" (-> this spawner))
  (format #t "~2Tdesired-spawn-count: ~D~%" (-> this desired-spawn-count))
  (format #t "~2Tspawn-times: ~A~%" (-> this spawn-times))
  (format #t "~2Tlast-seen-times: ~A~%" (-> this last-seen-times))
  (label cfg-7)
  this
  )

;; definition for method 7 of type flitter-spawner
(defmethod relocate ((this flitter-spawner) (offset int))
  (if (nonzero? (-> this spawner))
      (&+! (-> this spawner) offset)
      )
  (if (nonzero? (-> this spawn-times))
      (&+! (-> this spawn-times) offset)
      )
  (if (nonzero? (-> this last-seen-times))
      (&+! (-> this last-seen-times) offset)
      )
  (call-parent-method this offset)
  )

;; definition for method 12 of type flitter-spawner
(defmethod run-logic? ((this flitter-spawner))
  "Should this process be run? Checked by execute-process-tree."
  #t
  )

;; definition for method 11 of type flitter-spawner
;; INFO: Used lq/sq
(defmethod init-from-entity! ((this flitter-spawner) (arg0 entity-actor))
  (local-vars (sv-16 res-tag))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (set! (-> this entity) arg0)
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-2 (res-lump-data (-> this entity) 'actor-groups (pointer actor-group) :tag-ptr (& sv-16))))
    (cond
      ((and v1-2 (nonzero? (-> sv-16 elt-count)))
       (set! (-> this actor-group) v1-2)
       (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> this actor-group) (the-as (pointer actor-group) #f))
        (set! (-> this actor-group-count) 0)
        0
        )
      )
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-scenecamera" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (set! (-> this desired-spawn-count) 8)
  (when (> (-> this actor-group-count) 0)
    (set! (-> this spawner) (new 'process 'proc-focusable-spawner))
    (set! (-> this spawn-times) (new 'process 'boxed-array time-frame (-> this actor-group-count)))
    (alloc-records! (-> this spawner) (+ (-> this desired-spawn-count) 2) 'process)
    (set! (-> this last-seen-times) (new 'process 'boxed-array time-frame (+ (-> this desired-spawn-count) 2)))
    (dotimes (s5-2 (-> this spawner records length))
      (let ((s4-1 (new 'stack-no-clear 'traffic-object-spawn-params)))
        (set! (-> s4-1 velocity quad) (the-as uint128 0))
        (set! (-> s4-1 behavior) (the-as uint 1))
        (set! (-> s4-1 object-type) (traffic-type metalhead-flitter))
        (set! (-> s4-1 flags) (traffic-spawn-flags tsf0))
        (set! (-> s4-1 nav-branch) #f)
        (set! (-> this spawner records data s5-2 proc)
              (ppointer->handle
                (process-spawn metalhead-flitter :init citizen-init-by-other s4-1 :name "metalhead-flitter" :to this)
                )
              )
        )
      )
    )
  (go (method-of-object this active))
  )

;; definition for method 21 of type flitter-spawner
;; INFO: Used lq/sq
(defmethod spawn-flitter ((this flitter-spawner) (arg0 entity-actor))
  (let ((gp-0 (new 'stack-no-clear 'traffic-object-spawn-params)))
    (set! (-> gp-0 velocity quad) (the-as uint128 0))
    (set! (-> gp-0 position quad) (-> arg0 extra trans quad))
    (quaternion-copy! (-> gp-0 rotation) (-> arg0 quat))
    (set! (-> gp-0 behavior) (the-as uint 2))
    (set! (-> gp-0 object-type) (traffic-type metalhead-flitter))
    (set! (-> gp-0 flags) (traffic-spawn-flags))
    (set! (-> gp-0 user-data) (the-as uint 0))
    (set! (-> gp-0 proc) #f)
    (set! (-> gp-0 nav-branch) #f)
    (let ((s4-0 (-> gp-0 position)))
      (let ((s3-0 (new 'stack-no-clear 'collide-query)))
        (vector+float*! (-> s3-0 start-pos) s4-0 *up-vector* 24576.0)
        (set! (-> s3-0 move-dist quad) (the-as uint128 0))
        (set! (-> s3-0 move-dist y) -81920.0)
        (let ((v1-8 s3-0))
          (set! (-> v1-8 radius) 40.96)
          (set! (-> v1-8 collide-with) (collide-spec backgnd))
          (set! (-> v1-8 ignore-process0) #f)
          (set! (-> v1-8 ignore-process1) #f)
          (set! (-> v1-8 ignore-pat)
                (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                )
          (set! (-> v1-8 action-mask) (collide-action solid))
          )
        (if (>= (fill-and-probe-using-line-sphere *collide-cache* s3-0) 0.0)
            (set! (-> s4-0 quad) (-> s3-0 best-other-tri intersect quad))
            )
        )
      (set! (-> gp-0 nav-mesh) (find-nearest-nav-mesh s4-0 (the-as float #x7f800000)))
      )
    (let ((a0-15 (get-last-unused-val! (-> this spawner))))
      (when (>= a0-15 0)
        (let ((v1-18 (-> this spawner records data a0-15 proc)))
          (set-time! (-> this last-seen-times a0-15))
          (send-event (handle->process v1-18) 'traffic-activate gp-0 *traffic-engine*)
          )
        )
      )
    )
  )

;; failed to figure out what this is:
(defstate active (flitter-spawner)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (when (time-elapsed? (-> self state-time) (seconds 1))
      (set-time! (-> self state-time))
      (let ((gp-0 0))
        (dotimes (s5-0 (-> self spawner records length))
          (let* ((s4-0 (handle->process (-> self spawner records data s5-0 proc)))
                 (v1-11 (if (type? s4-0 process-focusable)
                            s4-0
                            )
                        )
                 )
            (when v1-11
              (if (not (focus-test? (the-as process-focusable v1-11) disable dead inactive))
                  (+! gp-0 1)
                  )
              )
            )
          )
        (when (< gp-0 (-> self desired-spawn-count))
          (let ((gp-1 0))
            (dotimes (s5-1 (length (-> self actor-group 0)))
              (let ((s4-1 (-> self actor-group 0 data s5-1 actor)))
                (when s4-1
                  (if (and (is-object-visible? (-> s4-1 extra level) (-> s4-1 vis-id))
                           (let ((s3-0 sphere-in-view-frustum?)
                                 (a0-13 (new 'stack 'sphere))
                                 )
                             (set! (-> a0-13 quad) (-> s4-1 extra trans quad))
                             (set! (-> a0-13 r) 8192.0)
                             (or (not (s3-0 a0-13)) (< 409600.0 (vector-vector-distance (-> s4-1 extra trans) (camera-pos))))
                             )
                           (time-elapsed? (-> self spawn-times s5-1) (seconds 3))
                           (< 61440.0 (vector-vector-distance (-> s4-1 extra trans) (target-pos 0)))
                           )
                      (set! gp-1 (logior gp-1 (ash 1 s5-1)))
                      )
                  )
                )
              )
            (when (nonzero? gp-1)
              (let* ((a1-10 (lognot gp-1))
                     (v1-52 (rand-vu-int-count-excluding (-> self actor-group 0 length) a1-10))
                     )
                (set-time! (-> self spawn-times v1-52))
                (spawn-flitter self (-> self actor-group 0 data v1-52 actor))
                )
              )
            )
          )
        )
      (check-inactive (-> self spawner))
      (dotimes (gp-2 (-> self last-seen-times length))
        (let* ((s4-3 (handle->process (-> self spawner records data gp-2 proc)))
               (s5-2 (if (type? s4-3 process-focusable)
                         s4-3
                         )
                     )
               (s4-4 (new 'stack 'sphere))
               )
          0.0
          (when (the-as process-focusable s5-2)
            (let ((f30-2 (vector-vector-distance (-> (the-as process-focusable s5-2) root trans) (target-pos 0))))
              (set! (-> s4-4 quad) (-> (the-as process-focusable s5-2) root trans quad))
              (set! (-> s4-4 r) 8192.0)
              (if (or (and (sphere-in-view-frustum? s4-4) (< f30-2 307200.0)) (< f30-2 61440.0))
                  (set-time! (-> self last-seen-times gp-2))
                  )
              (if (and (time-elapsed? (-> self last-seen-times gp-2) (seconds 10))
                       (or (not (sphere-in-view-frustum? s4-4)) (< 409600.0 f30-2))
                       )
                  (send-event s5-2 'traffic-off-force)
                  )
              )
            )
          )
        )
      )
    )
  :code sleep-code
  )

;; definition of type flitter-point
(deftype flitter-point (process-hidden)
  ()
  )

;; definition for method 3 of type flitter-point
(defmethod inspect ((this flitter-point))
  (when (not this)
    (set! this this)
    (goto cfg-68)
    )
  (format #t "[~8x] ~A~%" this (-> this type))
  (format #t "~1Tname: ~A~%" (-> this name))
  (format #t "~1Tmask: #x~X : (process-mask " (-> this mask))
  (let ((s5-0 (-> this mask)))
    (if (= (logand s5-0 (process-mask process-tree)) (process-mask process-tree))
        (format #t "process-tree ")
        )
    (if (= (logand s5-0 (process-mask target)) (process-mask target))
        (format #t "target ")
        )
    (if (= (logand (process-mask collectable) s5-0) (process-mask collectable))
        (format #t "collectable ")
        )
    (if (= (logand (process-mask projectile) s5-0) (process-mask projectile))
        (format #t "projectile ")
        )
    (if (= (logand s5-0 (process-mask sleep-code)) (process-mask sleep-code))
        (format #t "sleep-code ")
        )
    (if (= (logand s5-0 (process-mask actor-pause)) (process-mask actor-pause))
        (format #t "actor-pause ")
        )
    (if (= (logand (process-mask metalhead) s5-0) (shl #x8000 16))
        (format #t "metalhead ")
        )
    (if (= (logand (process-mask bot) s5-0) (process-mask bot))
        (format #t "bot ")
        )
    (if (= (logand (process-mask vehicle) s5-0) (process-mask vehicle))
        (format #t "vehicle ")
        )
    (if (= (logand (process-mask enemy) s5-0) (process-mask enemy))
        (format #t "enemy ")
        )
    (if (= (logand (process-mask entity) s5-0) (process-mask entity))
        (format #t "entity ")
        )
    (if (= (logand s5-0 (process-mask heap-shrunk)) (process-mask heap-shrunk))
        (format #t "heap-shrunk ")
        )
    (if (= (logand (process-mask sidekick) s5-0) (process-mask sidekick))
        (format #t "sidekick ")
        )
    (if (= (logand s5-0 (process-mask going)) (process-mask going))
        (format #t "going ")
        )
    (if (= (logand s5-0 (process-mask execute)) (process-mask execute))
        (format #t "execute ")
        )
    (if (= (logand (process-mask civilian) s5-0) (process-mask civilian))
        (format #t "civilian ")
        )
    (if (= (logand (process-mask death) s5-0) (process-mask death))
        (format #t "death ")
        )
    (if (= (logand (process-mask guard) s5-0) (process-mask guard))
        (format #t "guard ")
        )
    (if (= (logand s5-0 (process-mask no-kill)) (process-mask no-kill))
        (format #t "no-kill ")
        )
    (if (= (logand (process-mask kg-robot) s5-0) (process-mask kg-robot))
        (format #t "kg-robot ")
        )
    (if (= (logand (process-mask platform) s5-0) (process-mask platform))
        (format #t "platform ")
        )
    (if (= (logand s5-0 (process-mask freeze)) (process-mask freeze))
        (format #t "freeze ")
        )
    (if (= (logand s5-0 (process-mask sleep)) (process-mask sleep))
        (format #t "sleep ")
        )
    (if (= (logand s5-0 (process-mask progress)) (process-mask progress))
        (format #t "progress ")
        )
    (if (= (logand s5-0 (process-mask menu)) (process-mask menu))
        (format #t "menu ")
        )
    (if (= (logand (process-mask camera) s5-0) (process-mask camera))
        (format #t "camera ")
        )
    (if (= (logand (process-mask ambient) s5-0) (process-mask ambient))
        (format #t "ambient ")
        )
    (if (= (logand s5-0 (process-mask dark-effect)) (process-mask dark-effect))
        (format #t "dark-effect ")
        )
    (if (= (logand (process-mask crate) s5-0) (process-mask crate))
        (format #t "crate ")
        )
    (if (= (logand s5-0 (process-mask kernel-run)) (process-mask kernel-run))
        (format #t "kernel-run ")
        )
    (if (= (logand s5-0 (process-mask movie)) (process-mask movie))
        (format #t "movie ")
        )
    (if (= (logand s5-0 (process-mask pause)) (process-mask pause))
        (format #t "pause ")
        )
    )
  (format #t ")~%")
  (format #t "~1Tclock: ~A~%" (-> this clock))
  (format #t "~1Tparent: #x~X~%" (-> this parent))
  (format #t "~1Tbrother: #x~X~%" (-> this brother))
  (format #t "~1Tchild: #x~X~%" (-> this child))
  (format #t "~1Tppointer: #x~X~%" (-> this ppointer))
  (format #t "~1Tself: ~A~%" (-> this self))
  (format #t "~1Tpool: ~A~%" (-> this pool))
  (format #t "~1Tstatus: ~A~%" (-> this status))
  (format #t "~1Tpid: ~D~%" (-> this pid))
  (format #t "~1Tmain-thread: ~A~%" (-> this main-thread))
  (format #t "~1Ttop-thread: ~A~%" (-> this top-thread))
  (format #t "~1Tentity: ~A~%" (-> this entity))
  (format #t "~1Tlevel: ~A~%" (-> this level))
  (format #t "~1Tstate: ~A~%" (-> this state))
  (format #t "~1Tprev-state: ~A~%" (-> this prev-state))
  (format #t "~1Tnext-state: ~A~%" (-> this next-state))
  (format #t "~1Tstate-stack: ~A~%" (-> this state-stack))
  (format #t "~1Ttrans-hook: ~A~%" (-> this trans-hook))
  (format #t "~1Tpost-hook: ~A~%" (-> this post-hook))
  (format #t "~1Tevent-hook: ~A~%" (-> this event-hook))
  (format #t "~1Tallocated-length: ~D~%" (-> this allocated-length))
  (format #t "~1Theap-base: #x~X~%" (-> this heap-base))
  (format #t "~1Theap-top: #x~X~%" (-> this heap-top))
  (format #t "~1Theap-cur: #x~X~%" (-> this heap-cur))
  (format #t "~1Tstack-frame-top: ~A~%" (-> this stack-frame-top))
  (format #t "~1Theap: #<kheap @ #x~X>~%" (&-> this heap-base))
  (format #t "~1Tconnection-list: ~`connectable`P~%" (-> this connection-list))
  (format #t "~1Tstack[0] @ #x~X~%" (-> this stack))
  (label cfg-68)
  this
  )

;; definition of type board-score-hud
(deftype board-score-hud (hud-goal)
  ()
  )

;; definition for method 3 of type board-score-hud
(defmethod inspect ((this board-score-hud))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type hud-goal inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 15 of type board-score-hud
;; WARN: Return type mismatch int vs none.
(defmethod draw ((this board-score-hud))
  (set-hud-piece-position! (the-as hud-sprite (-> this sprites)) 447 70)
  (format (clear (-> this strings 0 text)) "~D" (-> this values 0 current))
  (set-as-offset-from! (the-as hud-sprite (-> this strings 0 pos)) (the-as vector4w (-> this sprites)) 0 -8)
  (set-as-offset-from! (the-as hud-sprite (-> this strings 1 pos)) (the-as vector4w (-> this sprites)) 0 -40)
  ((method-of-type hud draw) this)
  0
  (none)
  )

;; definition for method 16 of type board-score-hud
;; WARN: Return type mismatch int vs none.
(defmethod update-values! ((this board-score-hud))
  (set! (-> this values 0 target) (the int (-> *game-info* score)))
  ((method-of-type hud update-values!) this)
  0
  (none)
  )

;; definition for method 17 of type board-score-hud
;; WARN: Return type mismatch int vs none.
(defmethod init-callback ((this board-score-hud))
  (set! (-> this gui-id)
        (add-process *gui-control* this (gui-channel hud-upper-right) (gui-action hidden) (-> this name) 81920.0 0)
        )
  (logior! (-> this flags) (hud-flags show))
  (set! (-> this sprites 0 tid) (the-as texture-id (get-texture hud-scoreboard-01 level-default-minimap)))
  (set! (-> this sprites 0 scale-x) 1.2)
  (set! (-> this sprites 0 flags) (hud-sprite-flags hsf3))
  (alloc-string-if-needed this 0)
  (set! (-> this strings 0 scale) 0.5)
  (set! (-> this strings 0 flags) (font-flags kerning middle large))
  (set! (-> this strings 0 color) (font-color red))
  (alloc-string-if-needed this 1)
  (set! (-> this strings 1 scale) 0.75)
  (set! (-> this strings 1 flags) (font-flags kerning middle large))
  (set! (-> this strings 1 color) (font-color red))
  (let ((s5-0 format)
        (gp-1 (clear (-> this strings 1 text)))
        (s4-0 "~S")
        )
    (format (clear *temp-string*) (lookup-text! *common-text* (text-id score) #f))
    (s5-0 gp-1 s4-0 *temp-string*)
    )
  0
  (none)
  )

;; definition of type task-manager-bbush-board
(deftype task-manager-bbush-board (task-manager)
  ((score            float)
   (challenge-done   symbol)
   (hud-score        handle)
   (hud-goal         handle)
   (game-score       uint8)
   (new-high-score   symbol)
   (goal-cup         uint8)
   (last-cup         uint8)
   (roll-back-task?  symbol)
   )
  (:methods
    (task-manager-bbush-board-method-32 (_type_) none)
    (task-manager-bbush-board-method-33 (_type_) none)
    (task-manager-bbush-board-method-34 (_type_ float) none)
    )
  )

;; definition for method 3 of type task-manager-bbush-board
(defmethod inspect ((this task-manager-bbush-board))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type task-manager inspect)))
    (t9-0 this)
    )
  (format #t "~2Tscore: ~f~%" (-> this score))
  (format #t "~2Tchallenge-done: ~A~%" (-> this challenge-done))
  (format #t "~2Thud-score: ~D~%" (-> this hud-score))
  (format #t "~2Thud-goal: ~D~%" (-> this hud-goal))
  (format #t "~2Tgame-score: ~D~%" (-> this game-score))
  (format #t "~2Tnew-high-score: ~A~%" (-> this new-high-score))
  (format #t "~2Tgoal-cup: ~D~%" (-> this goal-cup))
  (format #t "~2Tlast-cup: ~D~%" (-> this last-cup))
  (format #t "~2Troll-back-task?: ~A~%" (-> this roll-back-task?))
  (label cfg-4)
  this
  )

;; definition for method 32 of type task-manager-bbush-board
;; WARN: Return type mismatch int vs none.
(defmethod task-manager-bbush-board-method-32 ((this task-manager-bbush-board))
  (set-setting! 'music 'cityjetb 0.0 0)
  (set-setting! 'city-sound '(citybb1) 0.0 2)
  0
  (none)
  )

;; definition for method 21 of type task-manager-bbush-board
(defmethod set-time-limit ((this task-manager-bbush-board))
  (let ((t9-0 (method-of-type task-manager set-time-limit)))
    (t9-0 this)
    )
  (set-setting! 'airlock #f 0.0 0)
  (set! (-> this game-score) (the-as uint 10))
  (set! (-> this hud-score) (the-as handle #f))
  (set! (-> this hud-goal) (the-as handle #f))
  (if (= (-> this hud-score) #f)
      (set! (-> this hud-score)
            (ppointer->handle (process-spawn board-score-hud :init hud-init-by-other :name "board-score-hud" :to this))
            )
      )
  (if (= (-> this hud-goal) #f)
      (set! (-> this hud-goal)
            (ppointer->handle (process-spawn hud-goal :init hud-init-by-other :name "hud-goal" :to this))
            )
      )
  (set! (-> this roll-back-task?) #f)
  (task-manager-bbush-board-method-32 this)
  (none)
  )

;; definition for method 33 of type task-manager-bbush-board
;; WARN: Return type mismatch int vs none.
(defmethod task-manager-bbush-board-method-33 ((this task-manager-bbush-board))
  (when (< (-> *game-info* goal) (-> this score))
    (set! (-> this new-high-score) #t)
    (when (>= (the-as uint 3) (-> this goal-cup))
      (sound-play "special-pickup")
      (+! (-> this goal-cup) 1)
      )
    )
  (set! (-> *game-info* goal)
        (game-info-method-31 *game-info* (the-as int (-> this game-score)) (the-as int (-> this goal-cup)))
        )
  (let ((v1-14 (handle->process (-> this hud-goal))))
    (when v1-14
      (let ((s5-1 format)
            (s4-1 (clear (-> (the-as hud v1-14) strings 1 text)))
            (s3-0 "~S")
            )
        (let* ((s2-0 format)
               (s1-0 (clear *temp-string*))
               (a0-13 *common-text*)
               (t9-5 (method-of-object a0-13 lookup-text!))
               (v1-17 (-> this goal-cup))
               )
          (s2-0 s1-0 (t9-5
                       a0-13
                       (cond
                         ((= v1-17 1)
                          (text-id text-0139)
                          )
                         ((= v1-17 2)
                          (text-id text-0138)
                          )
                         ((= v1-17 3)
                          (text-id text-0137)
                          )
                         (else
                           (text-id text-0136)
                           )
                         )
                       #f
                       )
                )
          )
        (s5-1 s4-1 s3-0 *temp-string*)
        )
      )
    )
  0
  (none)
  )

;; definition for method 34 of type task-manager-bbush-board
;; WARN: Return type mismatch int vs none.
(defmethod task-manager-bbush-board-method-34 ((this task-manager-bbush-board) (arg0 float))
  (set! (-> this roll-back-task?) #t)
  (let* ((s2-0 (-> this game-score))
         (s4-0 (game-info-method-29 *game-info* (the-as int s2-0)))
         (t0-0 (get-highscore-rank *game-info* (the-as int s2-0) arg0))
         (s3-1 (max 0 (- t0-0 s4-0)))
         )
    (let ((t9-2 format)
          (a0-3 #t)
          (a1-3 "report-score ~s ~f my-cup ~d prev-cup ~d eggs ~d~%")
          (v1-4 s2-0)
          )
      (t9-2
        a0-3
        a1-3
        (cond
          ((= v1-4 7)
           "snake-total-jump-distance"
           )
          ((= v1-4 5)
           "snake-total-air-time"
           )
          ((= v1-4 10)
           "hoverboard"
           )
          ((= v1-4 12)
           "gungame-2"
           )
          ((= v1-4 17)
           "arena-training"
           )
          ((= v1-4 8)
           "snake-roll-count"
           )
          ((= v1-4 14)
           "gungame-4"
           )
          ((= v1-4 6)
           "snake-jump-distance"
           )
          ((= v1-4 13)
           "gungame-3"
           )
          ((= v1-4 4)
           "snake-air-time"
           )
          ((= v1-4 9)
           "wascity-gungame-1"
           )
          ((zero? v1-4)
           "none"
           )
          ((= v1-4 15)
           "power-game"
           )
          ((= v1-4 3)
           "snake-race"
           )
          ((= v1-4 1)
           "neo-sat-game"
           )
          ((= v1-4 16)
           "destroy-interceptors"
           )
          ((= v1-4 11)
           "gungame-1"
           )
          ((= v1-4 2)
           "turtle-race"
           )
          (else
            "*unknown*"
            )
          )
        arg0
        t0-0
        s4-0
        s3-1
        )
      )
    (game-info-method-27 *game-info* (the-as game-score s2-0) arg0)
    (let ((v1-7 (new 'static 'fact-info))
          (f30-0 (* (the float s3-1) (the float (-> this info user-count))))
          )
      (set! (-> v1-7 options) (actor-option))
      (logior! (-> v1-7 options) (actor-option suck-in))
      (cond
        ((< (the-as uint s4-0) (the-as uint 3))
         (cond
           ((zero? s3-1)
            (send-event this 'fail)
            )
           (else
             (give *game-info* 'skill f30-0 (the-as handle #f))
             (until (time-elapsed? (-> this state-time) (the int (* 45.0 f30-0)))
               (suspend)
               )
             )
           )
         )
        (else
          (let ((f0-5 (game-info-method-31 *game-info* (the-as int (-> this game-score)) (the-as int (-> this goal-cup)))))
            (if (< arg0 f0-5)
                (send-event this 'fail)
                )
            )
          )
        )
      )
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate active (task-manager-bbush-board)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trick-judge)
       (set! (-> self score) (the-as float (-> block param 1)))
       (let ((v0-0 (the-as object #t)))
         (set! (-> self challenge-done) (the-as symbol v0-0))
         v0-0
         )
       )
      (else
        (task-manager-event-handler proc argc message block)
        )
      )
    )
  :code (behavior ()
    (until #f
      (set! (-> self score) 0.0)
      (set! (-> self challenge-done) #f)
      (send-event *target* 'get-notify self)
      (let ((gp-1 (ppointer->handle (judge-spawn self (target-pos 0) (the-as uint 0) #t))))
        (suspend)
        (while (send-event (handle->process (the-as handle gp-1)) 'waiting)
          (suspend)
          )
        (set! (-> self last-cup) (the-as uint (game-info-method-29 *game-info* (the-as int (-> self game-score)))))
        (format #t "last-cup: ~d~%" (-> self last-cup))
        (set! (-> self goal-cup) (+ (-> self last-cup) 1))
        (suspend)
        (while (send-event (handle->process (the-as handle gp-1)) 'judging)
          (set! (-> self score) (-> *game-info* score))
          (task-manager-bbush-board-method-33 self)
          (suspend)
          )
        )
      (send-event (handle->process (-> self hud-score)) 'hide-and-die)
      (send-event (handle->process (-> self hud-goal)) 'hide-and-die)
      (task-manager-bbush-board-method-34 self (-> self score))
      (let ((a1-9 (new 'stack-no-clear 'event-message-block)))
        (let ((v1-41 (process->ppointer self)))
          (set! (-> a1-9 from) v1-41)
          )
        (set! (-> a1-9 num-params) 0)
        (set! (-> a1-9 message) 'complete)
        (send-event-function self a1-9)
        )
      )
    #f
    )
  )

;; failed to figure out what this is:
(defstate resolution (task-manager-bbush-board)
  :virtual #t
  :event task-manager-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :code (behavior ()
    (local-vars (v1-31 object))
    (when (logtest? (-> self info mask) (task-manager-mask resolution-scene))
      (let ((gp-1 (ppointer->handle (process-spawn
                                      scene-player
                                      :init scene-player-init
                                      (-> self info resolution-scene)
                                      #t
                                      (-> self info resolution-scene-continue)
                                      :name "scene-player"
                                      )
                                    )
                  )
            )
        (while (handle->process (the-as handle gp-1))
          (suspend)
          )
        )
      )
    (task-manager-method-27 self)
    (let ((gp-2 (-> self info on-complete)))
      (if gp-2
          (script-eval gp-2)
          )
      )
    (cond
      ((-> self roll-back-task?)
       (let ((a0-13 (-> self node-info parent-node 0)))
         (task-node-open! a0-13 'event)
         )
       )
      (else
        (task-node-close! (-> self info final-node) 'event)
        )
      )
    (remove-setting! 'allow-progress)
    (while (begin
             (set! v1-31 (or (handle->process (-> self arrow)) (begin
                                                                 (countdown (v1-32 4)
                                                                   (when (handle->process (-> self hud v1-32))
                                                                     (set! v1-31 #t)
                                                                     (goto cfg-42)
                                                                     )
                                                                   )
                                                                 #f
                                                                 )
                             )
                   )
             (label cfg-42)
             v1-31
             )
      (suspend)
      )
    )
  )

;; failed to figure out what this is:
(defpartgroup group-mh-tower-smoke-cty
  :id 297
  :flags (sp0 sp4 sp11)
  :bounds (static-bspherem 0 0 0 1000)
  :parts ((sp-item 1286 :fade-after (meters 10000) :falloff-to (meters 10000) :flags (sp7)))
  )

;; failed to figure out what this is:
(defpart 1286
  :init-specs ((:texture (topglow level-default-sprite))
    (:num 0.001 0.05)
    (:x (meters -10) (meters 20))
    (:y (meters -30))
    (:z (meters -10) (meters 20))
    (:scale-x (meters 40) (meters 10))
    (:rot-z (degrees 160) (degrees 40))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 100.0)
    (:b 10.0)
    (:a 0.0)
    (:vel-y (meters 0.1))
    (:scalevel-x (meters 0.006666667) (meters 0.033333335))
    (:rotvel-z (degrees -0.033333335) (degrees 0.06666667))
    (:scalevel-y :copy scalevel-x)
    (:fade-a 0.13333334 0.26666668)
    (:accel-x (meters 0.00016666666))
    (:friction 0.997)
    (:timer (seconds 166.67))
    (:flags (sp-cpuinfo-flag-2 launch-along-z))
    (:next-time (seconds 1))
    (:next-launcher 1287)
    (:rotate-y (degrees 0))
    )
  )

;; failed to figure out what this is:
(defpart 1287
  :init-specs ((:scalevel-x (meters 0.026666667) (meters 0.013333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-a 0.0)
    (:next-time (seconds 2))
    (:next-launcher 1288)
    )
  )

;; failed to figure out what this is:
(defpart 1288
  :init-specs ((:scalevel-x (meters 0.016666668) (meters 0.01))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.14222223)
    (:fade-g 0.031111112)
    (:fade-b 0.13111112)
    (:next-time (seconds 2))
    (:next-launcher 1289)
    )
  )

;; failed to figure out what this is:
(defpart 1289
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0) (:fade-a -0.006 -0.0024))
  )

;; definition of type mh-tower-smoke-cty
(deftype mh-tower-smoke-cty (process-drawable)
  ()
  (:state-methods
    idle
    die
    )
  )

;; definition for method 3 of type mh-tower-smoke-cty
(defmethod inspect ((this mh-tower-smoke-cty))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 10 of type mh-tower-smoke-cty
(defmethod deactivate ((this mh-tower-smoke-cty))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (nonzero? (-> this part))
      (kill-particles (-> this part))
      )
  ((method-of-type process-drawable deactivate) this)
  (none)
  )

;; failed to figure out what this is:
(defstate idle (mh-tower-smoke-cty)
  :virtual #t
  :code sleep-code
  :post (behavior ()
    (spawn (-> self part) (-> self root trans))
    )
  )

;; failed to figure out what this is:
(defstate die (mh-tower-smoke-cty)
  :virtual #t
  :code (behavior ()
    '()
    )
  )

;; definition for method 12 of type mh-tower-smoke-cty
(defmethod run-logic? ((this mh-tower-smoke-cty))
  "Should this process be run? Checked by execute-process-tree."
  #t
  )

;; definition for method 11 of type mh-tower-smoke-cty
(defmethod init-from-entity! ((this mh-tower-smoke-cty) (arg0 entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 297) this))
  (cond
    ((not (task-node-closed? (game-task-node tower-destroy-resolution)))
     (cleanup-for-death this)
     (go (method-of-object this die))
     )
    (else
      (go (method-of-object this idle))
      )
    )
  )
