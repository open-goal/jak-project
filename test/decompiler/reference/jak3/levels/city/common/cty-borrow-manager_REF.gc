;;-*-Lisp-*-
(in-package goal)

;; definition for function cty-borrow-manager-borrow-update
;; WARN: Return type mismatch load-state vs object.
(defun cty-borrow-manager-borrow-update ((arg0 load-state))
  (if (and *city-borrow-manager* (nonzero? *city-borrow-manager*))
      (cty-borrow-manager-method-12 *city-borrow-manager* arg0)
      )
  arg0
  )

;; definition for symbol *cty-borrow-manager-list*, type pair
(define *cty-borrow-manager-list* '(#f #f #f #f #f #f #f #f #f #f #f))

;; definition for method 10 of type cty-borrow-manager
;; WARN: Return type mismatch int vs none.
(defmethod clear-borrow-holds! ((this cty-borrow-manager))
  (set! (-> this borrow-holds length) 0)
  0
  (none)
  )

;; definition for method 9 of type cty-borrow-manager
;; WARN: Return type mismatch borrow-level-array vs none.
(defmethod init! ((this cty-borrow-manager))
  (set! (-> *load-state* update-callback) cty-borrow-manager-borrow-update)
  (set! (-> this borrow-holds) (new 'loading-level 'borrow-level-array 80))
  (none)
  )

;; definition for method 18 of type cty-borrow-manager
(defmethod cty-borrow-manager-method-18 ((this cty-borrow-manager) (arg0 level-load-info))
  (cond
    ((logtest? (-> arg0 level-flags) (level-flags ctycar))
     1.0
     )
    ((logtest? (-> arg0 level-flags) (level-flags ctypes))
     3.0
     )
    ((logtest? (level-flags city-borrow-high-priority) (-> arg0 level-flags))
     1000.0
     )
    (else
      2.0
      )
    )
  )

;; definition for function get-borrow-slot
(defun get-borrow-slot ((arg0 level-memory-mode))
  (case arg0
    (((level-memory-mode borrow3))
     3
     )
    (((level-memory-mode borrow4))
     4
     )
    (((level-memory-mode borrow-city-small))
     0
     )
    (((level-memory-mode borrow0) (level-memory-mode borrow1) (level-memory-mode borrow2))
     (break!)
     0
     )
    (else
      5
      )
    )
  )

;; definition for function parent-also-loaded?
(defun parent-also-loaded? ((arg0 load-state) (arg1 symbol))
  (let ((v1-0 #f))
    (dotimes (a2-0 10)
      (let ((a3-3 (-> *level* level a2-0)))
        (when (= (-> a3-3 name) arg1)
          (set! v1-0 (-> a3-3 info master-level))
          0
          (goto cfg-7)
          )
        )
      )
    (label cfg-7)
    (if (not v1-0)
        (return #f)
        )
    (dotimes (a1-5 10)
      (if (= (-> arg0 want-exp a1-5 name) v1-0)
          (return #t)
          )
      )
    )
  #f
  )

;; definition for method 12 of type cty-borrow-manager
;; WARN: new jak 2 until loop case, check carefully
(defmethod cty-borrow-manager-method-12 ((this cty-borrow-manager) (arg0 load-state))
  (local-vars
    (sv-16 int)
    (sv-24 int)
    (sv-32 int)
    (sv-40 int)
    (sv-48 (array uint16))
    (sv-52 (array uint16))
    (sv-56 (array uint16))
    (sv-60 (array uint16))
    )
  (set! sv-16 0)
  (set! sv-24 0)
  (set! sv-32 0)
  (set! sv-40 0)
  (when (zero? (-> *setting-control* user-current level-trans-time))
    (dotimes (v1-3 10)
      (set! (-> arg0 target v1-3 name) (-> arg0 want-exp v1-3 name))
      (set! (-> arg0 target v1-3 display?) (-> arg0 want-exp v1-3 display?))
      (set! (-> arg0 target v1-3 force-vis?) (-> arg0 want-exp v1-3 force-vis?))
      (set! (-> arg0 target v1-3 force-inside?) (-> arg0 want-exp v1-3 force-inside?))
      )
    (return 0)
    )
  (dotimes (v1-7 10)
    (let ((a1-9 (-> arg0 target v1-7 name))
          (a0-15 #f)
          )
      (when a1-9
        (dotimes (a2-1 10)
          (when (= a1-9 (-> arg0 want-exp a2-1 name))
            (set! a0-15 #t)
            0
            (goto cfg-15)
            )
          )
        (label cfg-15)
        (if (not a0-15)
            (set! sv-16 (logior sv-16 (ash 1 v1-7)))
            )
        )
      )
    )
  (dotimes (v1-10 10)
    (let ((a1-15 (-> arg0 want-exp v1-10 name))
          (a0-19 #f)
          )
      (when a1-15
        (dotimes (a2-6 10)
          (when (= a1-15 (-> arg0 target a2-6 name))
            (set! a0-19 #t)
            0
            (goto cfg-31)
            )
          )
        (label cfg-31)
        (if (not a0-19)
            (set! sv-24 (logior sv-24 (ash 1 v1-10)))
            )
        )
      )
    )
  (set! sv-48 (new 'static 'boxed-array :type uint16 :length 0 :allocated-length 6))
  (set! sv-52 (new 'static 'boxed-array :type uint16 :length 0 :allocated-length 6))
  (set! sv-56 (new 'static 'boxed-array :type uint16 :length 0 :allocated-length 6))
  (set! sv-60 (new 'static 'boxed-array :type uint16 :length 0 :allocated-length 6))
  (dotimes (v1-17 5)
    (set! (-> sv-48 v1-17) (the-as uint 0))
    (set! (-> sv-52 v1-17) (the-as uint 0))
    (set! (-> sv-60 v1-17) (the-as uint 0))
    )
  (set! (-> sv-56 0) (the-as uint 3))
  (set! (-> sv-56 1) (the-as uint 0))
  (set! (-> sv-56 2) (the-as uint 0))
  (set! (-> sv-56 3) (the-as uint 1))
  (set! (-> sv-56 4) (the-as uint 1))
  (set! (-> sv-56 5) (the-as uint 10))
  (dotimes (s4-0 10)
    (when (logtest? sv-16 (ash 1 s4-0))
      (let ((v1-29 #f)
            (s3-0 (-> arg0 target s4-0 name))
            )
        (dotimes (a0-35 (-> this borrow-holds length))
          (when (= (-> this borrow-holds data a0-35 name) s3-0)
            (set! v1-29 (parent-also-loaded? arg0 s3-0))
            0
            (goto cfg-53)
            )
          )
        (label cfg-53)
        (when v1-29
          (set! sv-16 (logclear sv-16 (ash 1 s4-0)))
          (set! sv-32 (logior sv-32 (ash 1 s4-0)))
          (let ((v1-34 (-> (lookup-level-info s3-0) memory-mode)))
            -1
            (let ((v1-35
                    (cond
                      ((= v1-34 (level-memory-mode borrow3))
                       3
                       )
                      ((= v1-34 (level-memory-mode borrow4))
                       4
                       )
                      ((= v1-34 (level-memory-mode borrow-city-small))
                       0
                       )
                      ((or (= v1-34 (level-memory-mode borrow0))
                           (= v1-34 (level-memory-mode borrow1))
                           (= v1-34 (level-memory-mode borrow2))
                           )
                       (break!)
                       0
                       )
                      (else
                        5
                        )
                      )
                    )
                  )
              (+! (-> sv-48 v1-35) 1)
              )
            )
          )
        )
      )
    )
  (dotimes (s4-1 10)
    (let* ((a0-58 (-> arg0 want-exp s4-1 name))
           (v1-44 (-> (lookup-level-info a0-58) memory-mode))
           (v1-45
             (cond
               ((= v1-44 (level-memory-mode borrow3))
                3
                )
               ((= v1-44 (level-memory-mode borrow4))
                4
                )
               ((= v1-44 (level-memory-mode borrow-city-small))
                0
                )
               ((or (= v1-44 (level-memory-mode borrow0))
                    (= v1-44 (level-memory-mode borrow1))
                    (= v1-44 (level-memory-mode borrow2))
                    )
                (break!)
                0
                )
               (else
                 5
                 )
               )
             )
           )
      (when (not (logtest? (-> sv-60 v1-45) (ash 1 s4-1)))
        (+! (-> sv-52 v1-45) 1)
        (logior! (-> sv-60 v1-45) (ash 1 s4-1))
        )
      )
    )
  (until #f
    (let ((s4-2 0))
      (dotimes (s3-1 5)
        (cond
          ((< (-> sv-56 s3-1) (+ (-> sv-48 s3-1) (-> sv-52 s3-1)))
           (let ((f30-0 1000.0)
                 (s2-0 -1)
                 )
             (dotimes (s1-0 10)
               (when (logtest? (-> sv-60 s3-1) (ash 1 s1-0))
                 (let* ((a0-86 (-> arg0 want-exp s1-0 name))
                        (a1-55 (lookup-level-info a0-86))
                        (f0-0 (cty-borrow-manager-method-18 this a1-55))
                        )
                   (if (not (logtest? sv-24 (ash 1 s1-0)))
                       (set! f0-0 (* 10.0 f0-0))
                       )
                   (when (< f0-0 f30-0)
                     (set! f30-0 f0-0)
                     (set! s2-0 s1-0)
                     )
                   )
                 )
               )
             (cond
               ((>= s2-0 0)
                (set! sv-24 (logclear sv-24 (ash 1 s2-0)))
                (set! sv-40 (logior sv-40 (ash 1 s2-0)))
                (logclear! (-> sv-60 s3-1) (ash 1 s2-0))
                (+! (-> sv-52 s3-1) -1)
                )
               (else
                 (return 0)
                 )
               )
             )
           )
          (else
            (+! s4-2 1)
            )
          )
        )
      (when (= s4-2 5)
        0
        (goto cfg-140)
        )
      )
    )
  #f
  (label cfg-140)
  (set! sv-16 (lognot sv-32))
  (set! sv-24 (lognot sv-40))
  (set! sv-40 (logior -1024 sv-40))
  (let ((s4-3 0)
        (s3-2 0)
        )
    (while (and (< s4-3 10) (< s3-2 10))
      (cond
        ((not (logtest? sv-40 (ash 1 s4-3)))
         (cond
           ((not (logtest? sv-32 (ash 1 s3-2)))
            (set! (-> arg0 target s3-2 name) (-> arg0 want-exp s4-3 name))
            (set! (-> arg0 target s3-2 display?) (-> arg0 want-exp s4-3 display?))
            (set! (-> arg0 target s3-2 force-vis?) (-> arg0 want-exp s4-3 force-vis?))
            (set! (-> arg0 target s3-2 force-inside?) (-> arg0 want-exp s4-3 force-inside?))
            (send-event *traffic-manager* 'borrow-notify-shutdown-end (-> arg0 target s3-2 name))
            (+! s4-3 1)
            (+! s3-2 1)
            )
           (else
             (+! s3-2 1)
             )
           )
         )
        (else
          (+! s4-3 1)
          )
        )
      )
    )
  (let ((s4-4 0))
    (dotimes (s3-3 10)
      (set! (car (ref& *cty-borrow-manager-list* s4-4)) #f)
      (when (not (logtest? sv-32 (ash 1 s3-3)))
        (let ((s2-1 (-> arg0 target s3-3 name)))
          (case (-> (lookup-level-info s2-1) memory-mode)
            (((level-memory-mode borrow0)
              (level-memory-mode borrow1)
              (level-memory-mode borrow2)
              (level-memory-mode borrow3)
              (level-memory-mode borrow4)
              (level-memory-mode borrow-city-small)
              )
             (set! (car (ref& *cty-borrow-manager-list* s4-4)) s2-1)
             (+! s4-4 1)
             )
            )
          )
        )
      )
    )
  (persist-with-delay
    *setting-control*
    (the-as symbol *city-borrow-manager*)
    (seconds 1000)
    'borrow-hold
    (the-as symbol *cty-borrow-manager-list*)
    0.0
    0
    )
  (cty-borrow-manager-method-16 this)
  (cty-borrow-manager-method-17 this arg0 sv-32)
  (update-sound-info arg0)
  )

;; definition for symbol *faction-sound-list*, type pair
(define *faction-sound-list* '(#f #f #f #f #f #f #f #f #f #f))

;; definition for function level->sound-bank-name
(defun level->sound-bank-name ((arg0 symbol))
  (case arg0
    (('ctypesc)
     'citykgf
     )
    (('ctypesb 'ctypepb 'ctygenb)
     'citymhf
     )
    (('ctypesa)
     'cityffh
     )
    (('ctypepa)
     'citypedh
     )
    (('ctycara 'ctycarb 'ctywide 'lctyhijk)
     'citycarh
     )
    (else
      #f
      )
    )
  )

;; definition for function insert-into-sound-list
(defun insert-into-sound-list ((arg0 symbol) (arg1 pair))
  (local-vars (a0-3 symbol))
  (if (not arg0)
      (return 0)
      )
  (let ((v1-2 -1))
    (let* ((a0-1 0)
           (a2-0 arg1)
           (a3-0 (car a2-0))
           )
      (while (not (null? a2-0))
        (if (and (not a3-0) (< v1-2 0))
            (set! v1-2 a0-1)
            )
        (when (= a3-0 arg0)
          (set! a0-3 #t)
          (goto cfg-15)
          )
        (+! a0-1 1)
        (set! a2-0 (cdr a2-0))
        (set! a3-0 (car a2-0))
        )
      )
    (set! a0-3 #f)
    (label cfg-15)
    (when (not a0-3)
      (set! (car (ref& arg1 v1-2)) arg0)
      arg0
      )
    )
  )

;; definition for function update-sound-info
;; WARN: Return type mismatch int vs none.
(defun update-sound-info ((arg0 load-state))
  (let ((s5-0 0))
    (while (let ((a0-2 *faction-sound-list*))
             (< s5-0 ((method-of-type (rtype-of a0-2) length) a0-2))
             )
      (set! (car (ref& *faction-sound-list* s5-0)) #f)
      (+! s5-0 1)
      )
    )
  (dotimes (s5-1 10)
    (let ((a0-3 (-> arg0 target s5-1 name)))
      (when (!= a0-3 'ctywide)
        (let ((a0-4 (level->sound-bank-name a0-3)))
          (insert-into-sound-list a0-4 *faction-sound-list*)
          )
        )
      )
    )
  (persist-with-delay
    *setting-control*
    'cty-borrow-manager-city-sound
    (seconds 1000)
    'city-sound
    (the-as symbol *faction-sound-list*)
    0.0
    0
    )
  0
  (none)
  )

;; definition for method 11 of type cty-borrow-manager
;; WARN: Return type mismatch symbol vs none.
(defmethod clear-callback! ((this cty-borrow-manager))
  (set! (-> *load-state* update-callback) #f)
  (none)
  )

;; definition for method 13 of type cty-borrow-manager
(defmethod cty-borrow-manager-method-13 ((this cty-borrow-manager) (arg0 symbol) (arg1 borrow-hold-info-mode) (arg2 time-frame))
  (if (not arg0)
      (return 0)
      )
  (let ((v1-3 (-> this borrow-holds length)))
    (dotimes (t0-0 (-> this borrow-holds length))
      (when (= (-> this borrow-holds data t0-0 name) arg0)
        (set! v1-3 t0-0)
        0
        (goto cfg-10)
        )
      )
    (label cfg-10)
    (cond
      ((>= v1-3 (-> this borrow-holds length))
       (set! (-> this borrow-holds data v1-3 name) arg0)
       (set! (-> this borrow-holds data v1-3 mode) arg1)
       (set! (-> this borrow-holds data v1-3 expiring?) #f)
       (set! (-> this borrow-holds data v1-3 expire-wait-time) arg2)
       (let ((v0-0 (the-as object (+ (-> this borrow-holds length) 1))))
         (set! (-> this borrow-holds length) (the-as int v0-0))
         v0-0
         )
       )
      ((= arg1 (borrow-hold-info-mode zero))
       (set! (-> this borrow-holds data v1-3 mode) (borrow-hold-info-mode zero))
       (set! (-> this borrow-holds data v1-3 expiring?) #f)
       (send-event *traffic-manager* 'borrow-notify-shutdown-end (-> this borrow-holds data v1-3 name))
       )
      ((= (-> this borrow-holds data v1-3 mode) (borrow-hold-info-mode zero))
       (set! (-> this borrow-holds data v1-3 mode) arg1)
       (set! (-> this borrow-holds data v1-3 expiring?) #f)
       #f
       )
      (else
        (set! (-> this borrow-holds data v1-3 expire-wait-time) arg2)
        arg2
        )
      )
    )
  )

;; definition for method 14 of type cty-borrow-manager
;; WARN: Return type mismatch int vs object.
(defmethod remove-by-name ((this cty-borrow-manager) (arg0 symbol))
  (dotimes (v1-0 (-> this borrow-holds length))
    (when (= (-> this borrow-holds data v1-0 name) arg0)
      (pop-front (-> this borrow-holds) v1-0)
      (return (the-as object 0))
      )
    )
  (the-as int #f)
  )

;; definition for method 15 of type cty-borrow-manager
;; WARN: Return type mismatch int vs none.
(defmethod reset-borrow-list ((this cty-borrow-manager))
  (set! (-> this borrow-holds length) 0)
  0
  (none)
  )

;; definition for method 17 of type cty-borrow-manager
(defmethod cty-borrow-manager-method-17 ((this cty-borrow-manager) (arg0 load-state) (arg1 int))
  (dotimes (s3-0 (-> this borrow-holds length))
    (let ((s2-0 (-> this borrow-holds data s3-0))
          (v1-3 #f)
          )
      (dotimes (a0-2 10)
        (when (and (logtest? arg1 (ash 1 a0-2)) (= (-> s2-0 name) (-> arg0 target a0-2 name)))
          (set! v1-3 #t)
          0
          (goto cfg-14)
          )
        )
      (label cfg-14)
      (cond
        (v1-3
          (case (-> s2-0 mode)
            (((borrow-hold-info-mode one) (borrow-hold-info-mode two))
             (when (not (-> s2-0 expiring?))
               (set! (-> s2-0 expiring?) #t)
               (set! (-> s2-0 expire-start-time) (-> *display* game-clock frame-counter))
               )
             (send-event *traffic-manager* 'borrow-notify-shutdown-begin (-> s2-0 name))
             )
            )
          (if (= (-> s2-0 mode) (borrow-hold-info-mode two))
              (set! (-> s2-0 num-remaining-objects)
                    (the-as uint (send-event *traffic-manager* 'borrow-query-remaining (-> s2-0 name)))
                    )
              )
          )
        (else
          (set! (-> s2-0 expiring?) #f)
          (send-event *traffic-manager* 'borrow-notify-shutdown-end (-> s2-0 name))
          )
        )
      )
    )
  (let ((s5-1 0))
    (while (< s5-1 (-> this borrow-holds length))
      (let ((v1-37 (-> this borrow-holds data s5-1)))
        (if (and (-> v1-37 expiring?)
                 (or (< (-> *display* base-clock frame-counter) (-> *game-info* blackout-time))
                     (>= (-> *setting-control* user-current bg-a) 1.0)
                     (or (>= (-> *setting-control* user-current bg-a-force) 1.0)
                         (and (>= (- (-> *display* game-clock frame-counter) (-> v1-37 expire-start-time)) (-> v1-37 expire-wait-time))
                              (or (= (-> v1-37 mode) (borrow-hold-info-mode one))
                                  (and (= (-> v1-37 mode) (borrow-hold-info-mode two)) (<= (-> v1-37 num-remaining-objects) 0))
                                  )
                              )
                         )
                     )
                 )
            (pop-front (-> this borrow-holds) s5-1)
            (+! s5-1 1)
            )
        )
      )
    )
  #f
  )

;; definition for function mark-permanent-holds
;; WARN: Return type mismatch int vs object.
(defun mark-permanent-holds ((arg0 pair))
  (when *city-borrow-manager*
    (let* ((a0-1 arg0)
           (s5-0 ((method-of-type (rtype-of a0-1) length) a0-1))
           )
      (dotimes (s4-0 (/ s5-0 2))
        (let ((s3-0 (ref arg0 (* s4-0 2))))
          (dotimes (s2-0 (-> *city-borrow-manager* borrow-holds length))
            (let ((v1-6 (ref arg0 (+ (* s4-0 2) 1))))
              (if (and (= (-> *city-borrow-manager* borrow-holds data s2-0 name) s3-0)
                       (= (-> *city-borrow-manager* borrow-holds data s2-0 mode) (borrow-hold-info-mode zero))
                       (or (= v1-6 'auto) (= v1-6 'faction))
                       )
                  (set! (car (ref& arg0 (+ (* s4-0 2) 1))) 'special)
                  )
              )
            )
          )
        )
      )
    )
  0
  )

;; definition for method 16 of type cty-borrow-manager
(defmethod cty-borrow-manager-method-16 ((this cty-borrow-manager))
  (local-vars (v1-25 symbol))
  (let ((s5-0 0))
    (while (< s5-0 (-> this borrow-holds length))
      (if (= (-> this borrow-holds data s5-0 mode) (borrow-hold-info-mode zero))
          (pop-front (-> this borrow-holds) s5-0)
          (+! s5-0 1)
          )
      )
    )
  (dotimes (s5-1 3)
    (let ((s4-0 (-> *setting-control* user-current borrow-hold-perm s5-1)))
      (when (nonzero? s4-0)
        (let ((a1-1 (car s4-0)))
          (while (not (null? s4-0))
            (cty-borrow-manager-method-13 this (the-as symbol a1-1) (borrow-hold-info-mode zero) (seconds 5))
            (set! s4-0 (cdr s4-0))
            (set! a1-1 (car s4-0))
            )
          )
        )
      )
    )
  (dotimes (s5-2 3)
    (let ((s4-1 (-> *setting-control* user-current borrow-hold s5-2)))
      (when (nonzero? s4-1)
        (let ((a1-2 (car s4-1)))
          (while (not (null? s4-1))
            (let ((v1-23 a1-2))
              (dotimes (a0-7 (-> this borrow-holds length))
                (when (= (-> this borrow-holds data a0-7 name) v1-23)
                  (set! v1-25 #t)
                  (goto cfg-23)
                  )
                )
              )
            (set! v1-25 #f)
            (label cfg-23)
            (if (not v1-25)
                (cty-borrow-manager-method-13 this (the-as symbol a1-2) (borrow-hold-info-mode two) (seconds 5))
                )
            (set! s4-1 (cdr s4-1))
            (set! a1-2 (car s4-1))
            )
          )
        )
      )
    )
  #f
  )

;; definition for function city-sound-exists?
(defun city-sound-exists? ((arg0 symbol) (arg1 (array symbol)))
  (dotimes (v1-0 (-> arg1 allocated-length))
    (if (= (-> arg1 v1-0) arg0)
        (return #t)
        )
    )
  #f
  )

;; definition for function sound-bank-mode->use-count
(defun sound-bank-mode->use-count ((arg0 sound-bank-mode))
  (case arg0
    (((sound-bank-mode half) (sound-bank-mode halfa) (sound-bank-mode halfb))
     1
     )
    (else
      2
      )
    )
  )

;; definition for function add-city-sound-bank-if-possible
(defun add-city-sound-bank-if-possible ((arg0 symbol) (arg1 (array symbol)) (arg2 int))
  (when (and arg0 (not (city-sound-exists? arg0 arg1)))
    (let ((a0-3 (sound-bank-name->mode arg0)))
      0
      (let ((v1-3 (sound-bank-mode->use-count a0-3)))
        (when (>= 6 (+ arg2 v1-3))
          (set! (-> arg1 arg2) arg0)
          (+! arg2 v1-3)
          )
        )
      )
    )
  arg2
  )

;; definition for function city-sound-expand-want-list
;; WARN: Return type mismatch int vs none.
(defun city-sound-expand-want-list ()
  (let ((gp-0 (new 'static 'boxed-array :type symbol :length 0 :allocated-length 6))
        (s4-0 0)
        (s5-0 *load-state*)
        )
    (dotimes (v1-0 6)
      (set! (-> gp-0 v1-0) #f)
      )
    (let* ((s3-0 (-> *setting-control* user-current city-sound 2))
           (a0-2 (car s3-0))
           )
      (while (not (null? s3-0))
        (set! s4-0 (add-city-sound-bank-if-possible (the-as symbol a0-2) gp-0 s4-0))
        (set! s3-0 (cdr s3-0))
        (set! a0-2 (car s3-0))
        )
      )
    (dotimes (s3-1 6)
      (when (-> s5-0 want-exp-sound s3-1 name)
        (let ((a0-4 (sound-bank-name->mode (-> s5-0 want-exp-sound s3-1 name))))
          (when (not (or (= a0-4 (sound-bank-mode half))
                         (= a0-4 (sound-bank-mode halfa))
                         (= a0-4 (sound-bank-mode halfb))
                         (= a0-4 (sound-bank-mode halfc))
                         )
                     )
            (set! (-> gp-0 s4-0) (-> s5-0 want-exp-sound s3-1 name))
            (set! s4-0 (+ s4-0 (sound-bank-mode->use-count a0-4)))
            )
          )
        )
      )
    (countdown (s3-2 3)
      (let* ((s2-0 (-> *setting-control* user-current city-sound s3-2))
             (a0-6 (car s2-0))
             )
        (while (not (null? s2-0))
          (set! s4-0 (add-city-sound-bank-if-possible (the-as symbol a0-6) gp-0 s4-0))
          (set! s2-0 (cdr s2-0))
          (set! a0-6 (car s2-0))
          )
        )
      )
    (dotimes (s3-3 6)
      (case (sound-bank-name->mode (-> s5-0 want-exp-sound s3-3 name))
        (((sound-bank-mode half) (sound-bank-mode halfa) (sound-bank-mode halfb) (sound-bank-mode halfc))
         (set! s4-0 (add-city-sound-bank-if-possible (-> s5-0 want-exp-sound s3-3 name) gp-0 s4-0))
         )
        )
      )
    (dotimes (v1-44 6)
      (set! (-> s5-0 want-exp-sound v1-44 name) #f)
      (set! (-> s5-0 want-exp-sound v1-44 mode) (sound-bank-mode none))
      )
    (let ((s4-1 0))
      (dotimes (s3-4 6)
        (let ((a0-17 (-> gp-0 s3-4)))
          (when a0-17
            (set! (-> s5-0 want-exp-sound s4-1 name) a0-17)
            (set! (-> s5-0 want-exp-sound s4-1 mode) (sound-bank-name->mode a0-17))
            (+! s4-1 1)
            )
          )
        )
      )
    )
  0
  (none)
  )
