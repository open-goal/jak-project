;;-*-Lisp-*-
(in-package goal)

;; failed to figure out what this is:
(defpartgroup group-fac-fire-torch
  :id 807
  :flags (sp0 sp4)
  :bounds (static-bspherem 0 0 0 20)
  :parts ((sp-item 2960 :flags (sp7)))
  )

;; failed to figure out what this is:
(defpart 2960
  :init-specs ((:texture (explosion-nebula level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 0.3))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 0.0)
    (:b 0.0)
    (:a 128.0)
    (:vel-y (meters 0.03))
    (:timer (seconds 0.667))
    (:flags ())
    (:conerot-x (degrees -30) (degrees 60))
    (:rotate-x (degrees 180))
    (:rotate-y (degrees 0) (degrees 3600))
    )
  )

;; definition for function factoryc-activate
;; WARN: Return type mismatch int vs none.
(defun factoryc-activate ((arg0 level))
  (if (and (nonzero? *nav-network*) *nav-network*)
      (init-by-other! *nav-network* arg0 *factoryc-adjacency*)
      )
  0
  (none)
  )

;; definition for function factoryc-login
;; WARN: Return type mismatch int vs none.
(defun factoryc-login ((arg0 level))
  (set! *nav-network* (new 'loading-level 'nav-network))
  (alloc-nav-network-for-level! *nav-network* 64 10)
  0
  (none)
  )

;; definition for function factoryc-logout
;; WARN: Return type mismatch int vs none.
(defun factoryc-logout ((arg0 level))
  (set! *nav-network* (the-as nav-network 0))
  0
  (none)
  )

;; failed to figure out what this is:
(defskelgroup skel-generic-spot-ring gun gun-dark-2-ring-lod0-jg gun-dark-2-ring-idle-ja
              ((gun-dark-2-ring-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0.5 84)
              :longest-edge (meters 80)
              :shadow gun-dark-2-ring-shadow-mg
              )

;; definition of type generic-spot-shadow-effect
(deftype generic-spot-shadow-effect (process-drawable)
  ((focal-length     float)
   (near-clip        float)
   (far-clip         float)
   (color            rgba)
   (pre-flicker-pos  vector               :inline)
   (jmod-outer       joint-mod-add-local  :inline)
   (jmod-inner       joint-mod-add-local  :inline)
   )
  (:state-methods
    idle
    inactive
    )
  (:methods
    (set-jmod-inner-scale! (_type_ vector) none)
    (set-jmod-outer-scale! (_type_ vector) none)
    )
  )

;; definition for method 3 of type generic-spot-shadow-effect
(defmethod inspect ((this generic-spot-shadow-effect))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tfocal-length: ~f~%" (-> this focal-length))
  (format #t "~2Tnear-clip: ~f~%" (-> this near-clip))
  (format #t "~2Tfar-clip: ~f~%" (-> this far-clip))
  (format #t "~2Tcolor: ~D~%" (-> this color))
  (format #t "~2Tpre-flicker-pos: #<vector @ #x~X>~%" (-> this pre-flicker-pos))
  (format #t "~2Tjmod-outer: #<joint-mod-add-local @ #x~X>~%" (-> this jmod-outer))
  (format #t "~2Tjmod-inner: #<joint-mod-add-local @ #x~X>~%" (-> this jmod-inner))
  (label cfg-4)
  this
  )

;; definition for method 22 of type generic-spot-shadow-effect
;; INFO: Used lq/sq
;; WARN: Return type mismatch vector vs none.
(defmethod set-jmod-inner-scale! ((this generic-spot-shadow-effect) (arg0 vector))
  (set! (-> this jmod-inner transform scale quad) (-> arg0 quad))
  (none)
  )

;; definition for method 23 of type generic-spot-shadow-effect
;; INFO: Used lq/sq
;; WARN: Return type mismatch vector vs none.
(defmethod set-jmod-outer-scale! ((this generic-spot-shadow-effect) (arg0 vector))
  (set! (-> this jmod-outer transform scale quad) (-> arg0 quad))
  (none)
  )

;; definition for function generic-spot-shadow-effect-init-by-other
;; INFO: Used lq/sq
(defbehavior generic-spot-shadow-effect-init-by-other generic-spot-shadow-effect ((arg0 vector) (arg1 quaternion))
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> arg0 quad))
  (quaternion-copy! (-> self root quat) arg1)
  (set! (-> self pre-flicker-pos quad) (-> self root trans quad))
  (set! (-> self level) (-> *level* level-default))
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-generic-spot-ring" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (init (-> self jmod-inner) self (the-as uint 4) (joint-mod-base-flags attached scale))
  (init (-> self jmod-outer) self (the-as uint 3) (joint-mod-base-flags attached scale))
  (set! (-> self focal-length) 409600.0)
  (set! (-> self near-clip) 0.0)
  (set! (-> self far-clip) 122880.0)
  (set! (-> self color) (new 'static 'rgba :r #xf0 :g #xf0 :a #x80))
  (cond
    ((-> self draw shadow)
     (set! (-> self draw shadow-ctrl) (new
                                        'process
                                        'shadow-control
                                        0.0
                                        0.0
                                        614400.0
                                        (the-as vector #f)
                                        (shadow-flags shdf02 shdf03 shdf04 disable-draw)
                                        245760.0
                                        )
           )
     (set! (-> self draw shadow-ctrl settings shadow-type) 1)
     (set! (-> self draw shadow-ctrl settings flags) (shadow-flags disable-fade shdf03 shdf04 shdf07))
     (logclear! (-> self draw status) (draw-control-status no-draw))
     )
    (else
      (go process-drawable-art-error "Shadow error (no self draw shadow)")
      )
    )
  (go-virtual idle)
  )

;; definition for function generic-spot-shadow-effect-handler
(defbehavior generic-spot-shadow-effect-handler generic-spot-shadow-effect ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('on)
     (go-virtual idle)
     )
    (('off)
     (go-virtual inactive)
     )
    )
  )

;; failed to figure out what this is:
(defstate idle (generic-spot-shadow-effect)
  :virtual #t
  :event generic-spot-shadow-effect-handler
  :enter (behavior ()
    (setup-masks (-> self draw) 0 1)
    (let ((v1-3 (-> self draw shadow-ctrl)))
      (logclear! (-> v1-3 settings flags) (shadow-flags disable-draw))
      )
    0
    )
  :trans (behavior ()
    (shadow-control-method-14
      (-> self draw shadow-ctrl)
      (-> self root trans)
      (vector-negate! (new 'stack-no-clear 'vector) (-> self node-list data 3 bone transform uvec))
      (-> self focal-length)
      (-> self near-clip)
      (-> self far-clip)
      )
    (persist-with-delay
      *setting-control*
      'spotlight-color
      (seconds 0.1)
      'spotlight-color
      #f
      0.0
      (the-as int (-> self color))
      )
    )
  :code sleep-code
  :post (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (set! (-> gp-0 x) (+ -1024.0 (* 4096.0 (* 0.5 (rand-vu)))))
      (set! (-> gp-0 y) 0.0)
      (set! (-> gp-0 z) (+ -1024.0 (* 4096.0 (* 0.5 (rand-vu)))))
      (set! (-> gp-0 w) 1.0)
      (vector+! (-> self root trans) (-> self pre-flicker-pos) gp-0)
      )
    (ja-post)
    )
  )

;; failed to figure out what this is:
(defstate inactive (generic-spot-shadow-effect)
  :virtual #t
  :event generic-spot-shadow-effect-handler
  :enter (behavior ()
    (setup-masks (-> self draw) 0 1)
    (let ((v1-3 (-> self draw shadow-ctrl)))
      (logior! (-> v1-3 settings flags) (shadow-flags disable-draw))
      )
    0
    )
  :trans (behavior ()
    '()
    )
  :code sleep-code
  )

;; definition of type fac-zapper
(deftype fac-zapper (process)
  ((on-duration   time-frame)
   (off-duration  time-frame)
   (phase-offset  time-frame)
   (beam-is-on    symbol)
   (bzzt-sound    sound-id)
   (path          path-control)
   (lightning     lightning-control)
   (hilite        handle)
   )
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type fac-zapper
(defmethod inspect ((this fac-zapper))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process inspect)))
    (t9-0 this)
    )
  (format #t "~2Ton-duration: ~D~%" (-> this on-duration))
  (format #t "~2Toff-duration: ~D~%" (-> this off-duration))
  (format #t "~2Tphase-offset: ~D~%" (-> this phase-offset))
  (format #t "~2Tbeam-is-on: ~A~%" (-> this beam-is-on))
  (format #t "~2Tbzzt-sound: ~D~%" (-> this bzzt-sound))
  (format #t "~2Tpath: ~A~%" (-> this path))
  (format #t "~2Tlightning: ~A~%" (-> this lightning))
  (format #t "~2Thilite: ~D~%" (-> this hilite))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(set! (-> *lightning-spec-id-table* 33) (new 'static 'lightning-spec
                                          :name "fac-zapper-zap"
                                          :flags (lightning-spec-flags lsf0)
                                          :start-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :end-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :fade-to-color (new 'static 'rgba :r #xbf :b #x8f :a #x5)
                                          :fade-start-factor 0.2
                                          :fade-time 60.0
                                          :texture (new 'static 'texture-id :index #x40 :page #x4)
                                          :reduction 0.62
                                          :num-points 32
                                          :box-size 16384.0
                                          :merge-factor 0.25
                                          :merge-count 2
                                          :radius 2252.8
                                          :duration 99.9
                                          :sound #f
                                          )
      )

;; failed to figure out what this is:
(set! (-> *lightning-spec-id-table* 34) (new 'static 'lightning-spec
                                          :name "fac-elec-gate-zap"
                                          :flags (lightning-spec-flags lsf0)
                                          :start-color (new 'static 'rgba :r #x80 :g #x80 :b #x80 :a #x80)
                                          :end-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :fade-to-color (new 'static 'rgba :r #xbf :b #x8f :a #x5)
                                          :fade-start-factor 0.2
                                          :fade-time 30.0
                                          :texture (new 'static 'texture-id :index #x40 :page #x4)
                                          :reduction 0.42
                                          :num-points 16
                                          :box-size 12288.0
                                          :merge-factor 0.125
                                          :merge-count 2
                                          :radius 3072.0
                                          :duration 99.9
                                          :sound #f
                                          )
      )

;; failed to figure out what this is:
(defstate idle (fac-zapper)
  :virtual #t
  :trans (behavior ()
    (if (-> self beam-is-on)
        (sound-play
          "laser-loop"
          :id (-> self bzzt-sound)
          :position (get-point-in-path! (-> self path) (new 'stack-no-clear 'vector) 0.5 'interp)
          )
        (sound-stop (-> self bzzt-sound))
        )
    )
  :code (behavior ()
    (let ((gp-0 (get-point-in-path! (-> self path) (new 'stack-no-clear 'vector) 0.0 'interp))
          (s5-0 (get-point-in-path! (-> self path) (new 'stack-no-clear 'vector) 1.0 'interp))
          )
      (let ((a0-2 (-> self lightning))
            (v1-2 gp-0)
            )
        (set! (-> a0-2 state meet data 0 quad) (-> v1-2 quad))
        )
      (let ((a0-5 (-> self lightning))
            (v1-4 s5-0)
            )
        (set! (-> a0-5 state meet data (+ (-> a0-5 state points-to-draw) -1) quad) (-> v1-4 quad))
        )
      (until #f
        (let ((v1-9 (mod (+ (current-time) (-> self phase-offset)) (+ (-> self on-duration) (-> self off-duration)))))
          (cond
            ((and (< v1-9 (-> self on-duration))
                  (< (- (the-as time-frame v1-9) (- (current-time) (-> self clock old-frame-counter))) 0)
                  )
             (let ((v1-10 (-> self lightning))
                   (a0-18 1)
                   )
               (let ((a1-11 (!= a0-18 (-> v1-10 state mode))))
                 (case a0-18
                   ((3)
                    (if a1-11
                        (set! (-> v1-10 state counter) 0.0)
                        )
                    )
                   ((1)
                    (set! (-> v1-10 state start-color) (-> v1-10 spec start-color))
                    (set! (-> v1-10 state end-color) (-> v1-10 spec end-color))
                    )
                   )
                 )
               (set! (-> v1-10 state mode) (the-as uint a0-18))
               )
             (set! (-> self beam-is-on) #t)
             (send-event (handle->process (-> self hilite)) 'on)
             (set-factoryc-light! 1.0 0)
             )
            ((and (>= v1-9 (-> self on-duration))
                  (< (- (the-as time-frame v1-9) (- (current-time) (-> self clock old-frame-counter))) (-> self on-duration))
                  )
             (let ((v1-22 (-> self lightning))
                   (a0-29 3)
                   )
               (let ((a1-26 (!= a0-29 (-> v1-22 state mode))))
                 (case a0-29
                   ((3)
                    (if a1-26
                        (set! (-> v1-22 state counter) 0.0)
                        )
                    )
                   ((1)
                    (set! (-> v1-22 state start-color) (-> v1-22 spec start-color))
                    (set! (-> v1-22 state end-color) (-> v1-22 spec end-color))
                    )
                   )
                 )
               (set! (-> v1-22 state mode) (the-as uint a0-29))
               )
             (set! (-> self beam-is-on) #f)
             (send-event (handle->process (-> self hilite)) 'off)
             (set-factoryc-light! 0.0 0)
             )
            )
          )
        (when (and *target* (-> self beam-is-on))
          (let ((s3-0 (new 'stack-no-clear 'vector)))
            (when (< (vector-segment-distance-point! (target-pos 0) gp-0 s5-0 s3-0) 4915.2)
              (sound-play "laser-zap-dax")
              (send-event
                *target*
                'attack
                #f
                (static-attack-info
                  :mask (vehicle-impulse-factor)
                  ((id (new-attack-id)) (damage 2.0) (vehicle-damage-factor 1.0) (vehicle-impulse-factor 1.0) (mode 'shock))
                  )
                )
              )
            )
          )
        (suspend)
        )
      )
    #f
    (sleep-code)
    )
  )

;; definition for method 11 of type fac-zapper
(defmethod init-from-entity! ((this fac-zapper) (arg0 entity-actor))
  (set! (-> this entity) arg0)
  (set! (-> this path) (new 'process 'path-control this 'path 0.0 arg0 #f))
  (set! (-> this lightning) (new 'process 'lightning-control (-> *lightning-spec-id-table* 33) this 0.0))
  (let ((v1-4 (-> this lightning))
        (a0-3 0)
        )
    (let ((a1-4 (!= a0-3 (-> v1-4 state mode))))
      (case a0-3
        ((3)
         (if a1-4
             (set! (-> v1-4 state counter) 0.0)
             )
         )
        ((1)
         (set! (-> v1-4 state start-color) (-> v1-4 spec start-color))
         (set! (-> v1-4 state end-color) (-> v1-4 spec end-color))
         )
        )
      )
    (set! (-> v1-4 state mode) (the-as uint a0-3))
    )
  (set! (-> this on-duration)
        (the-as time-frame (the int (* 300.0 (res-lump-float (-> this entity) 'on-duration :default 1.15))))
        )
  (set! (-> this off-duration)
        (the-as time-frame (the int (* 300.0 (res-lump-float (-> this entity) 'off-duration :default 1.85))))
        )
  (set! (-> this phase-offset)
        (the-as time-frame (the int (* 300.0 (res-lump-float (-> this entity) 'zapper-phase))))
        )
  (set! (-> this beam-is-on) #f)
  (set-factoryc-light! 0.0 0)
  (set! (-> this bzzt-sound) (new-sound-id))
  (let ((s3-0 (new 'stack-no-clear 'vector))
        (s2-0 (new 'stack-no-clear 'quaternion))
        (s5-0 (new 'stack-no-clear 'vector))
        )
    0.0
    (get-point-in-path! (-> this path) s3-0 0.5 'interp)
    (+! (-> s3-0 y) 4096.0)
    (vector-! s5-0 (-> this path curve cverts 0) (-> this path curve cverts 1))
    (let ((f30-3 (vector-length s5-0)))
      (vector-float/! s5-0 s5-0 f30-3)
      (quaternion-look-at! s2-0 s5-0 *up-vector*)
      (quaternion*! s2-0 s2-0 (new 'static 'quaternion :x 1.0))
      (let ((s4-0 (process-spawn generic-spot-shadow-effect s3-0 s2-0 :name "generic-spot-shadow-effect" :to this)))
        (when s4-0
          (set! (-> this hilite) (ppointer->handle s4-0))
          (set! (-> (the-as (pointer generic-spot-shadow-effect) s4-0) 0 far-clip) 2867.2)
          (set! (-> (the-as (pointer generic-spot-shadow-effect) s4-0) 0 near-clip) 0.4096)
          (set! (-> (the-as (pointer generic-spot-shadow-effect) s4-0) 0 color)
                (new 'static 'rgba :r #xff :g #x60 :b #x60 :a #x80)
                )
          (set-jmod-inner-scale!
            (-> (the-as (pointer generic-spot-shadow-effect) s4-0) 0)
            (new 'static 'vector :x 0.0001 :y 0.0001 :z 0.0001 :w 1.0)
            )
          (set-vector! s5-0 1.2 1.2 (* 0.0001319679 f30-3) 1.0)
          (set-jmod-outer-scale! (-> (the-as (pointer generic-spot-shadow-effect) s4-0) 0) s5-0)
          )
        )
      )
    )
  (go (method-of-object this idle))
  )

;; definition for method 10 of type fac-zapper
(defmethod deactivate ((this fac-zapper))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (sound-stop (-> this bzzt-sound))
  (call-parent-method this)
  (none)
  )

;; definition for method 7 of type fac-zapper
(defmethod relocate ((this fac-zapper) (offset int))
  (if (nonzero? (-> this path))
      (&+! (-> this path) offset)
      )
  (if (nonzero? (-> this lightning))
      (&+! (-> this lightning) offset)
      )
  (call-parent-method this offset)
  )

;; definition of type fac-fire-torch
(deftype fac-fire-torch (process-drawable)
  ((on-duration    time-frame)
   (off-duration   time-frame)
   (phase-offset   time-frame)
   (fire-is-on     symbol)
   (sync           sync-eased  :inline)
   (path-pos       float)
   (looping-sound  sound-id)
   (particle-hack  matrix      :inline)
   )
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type fac-fire-torch
(defmethod inspect ((this fac-fire-torch))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Ton-duration: ~D~%" (-> this on-duration))
  (format #t "~2Toff-duration: ~D~%" (-> this off-duration))
  (format #t "~2Tphase-offset: ~D~%" (-> this phase-offset))
  (format #t "~2Tfire-is-on: ~A~%" (-> this fire-is-on))
  (format #t "~2Tsync: #<sync-eased @ #x~X>~%" (-> this sync))
  (format #t "~2Tpath-pos: ~f~%" (-> this path-pos))
  (format #t "~2Tlooping-sound: ~D~%" (-> this looping-sound))
  (format #t "~2Tparticle-hack: #<matrix @ #x~X>~%" (-> this particle-hack))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-fac-fire-torch fac-fire-torch fac-fire-torch-lod0-jg fac-fire-torch-idle-ja
              ((fac-fire-torch-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 1 0 1.75)
              )

;; failed to figure out what this is:
(defstate idle (fac-fire-torch)
  :virtual #t
  :trans (behavior ()
    (set! (-> self path-pos) (get-norm! (-> self sync) 0))
    (get-point-at-percent-along-path! (-> self path) (-> self root trans) (-> self path-pos) 'interp)
    (sound-play "fire-loop" :id (-> self looping-sound) :position (-> self root trans))
    )
  :code (behavior ()
    (set! (-> self fire-is-on) #t)
    (sleep-code)
    )
  :post (behavior ()
    (when (-> self fire-is-on)
      (let ((f30-0 (total-distance (-> self path)))
            (gp-0 (current-time))
            )
        (- (get-scaled-val! (-> self sync) f30-0 (the-as int (+ gp-0 1)))
           (get-scaled-val! (-> self sync) f30-0 (the-as int gp-0))
           )
        )
      (let ((gp-1 (new 'stack-no-clear 'matrix)))
        (let* ((v1-9 gp-1)
               (a3-0 (-> self node-list data 4 bone transform))
               (a0-5 (-> a3-0 rvec quad))
               (a1-2 (-> a3-0 uvec quad))
               (a2-2 (-> a3-0 fvec quad))
               (a3-1 (-> a3-0 trans quad))
               )
          (set! (-> v1-9 rvec quad) a0-5)
          (set! (-> v1-9 uvec quad) a1-2)
          (set! (-> v1-9 fvec quad) a2-2)
          (set! (-> v1-9 trans quad) a3-1)
          )
        (vector-negate-in-place! (-> gp-1 uvec))
        (vector-negate-in-place! (-> gp-1 fvec))
        (let ((a2-3 (-> self particle-hack))
              (v1-10 (-> gp-1 rvec quad))
              (a0-8 (-> gp-1 uvec quad))
              (a1-3 (-> gp-1 fvec quad))
              (a3-2 (-> gp-1 trans quad))
              )
          (set! (-> a2-3 rvec quad) v1-10)
          (set! (-> a2-3 uvec quad) a0-8)
          (set! (-> a2-3 fvec quad) a1-3)
          (set! (-> a2-3 trans quad) a3-2)
          )
        )
      (add-debug-rot-matrix #t (bucket-id debug-no-zbuf1) (-> self particle-hack) (-> self root trans))
      (spawn-from-mat (-> self part) (-> self particle-hack))
      (when (and *target* (< -32768.0 (- (-> (target-pos 0) y) (-> self root trans y))))
        (when (< (if *target*
                     (vector-vector-xz-distance (-> self root trans) (-> *target* control trans))
                     4096000.0
                     )
                 5939.2
                 )
          (sound-play "get-burned")
          (send-event
            *target*
            'attack
            #f
            (static-attack-info
              :mask (vehicle-impulse-factor)
              ((id (new-attack-id)) (damage 2.0) (vehicle-damage-factor 1.0) (vehicle-impulse-factor 1.0) (mode 'burn))
              )
            )
          )
        )
      )
    (ja-post)
    )
  )

;; definition for method 11 of type fac-fire-torch
(defmethod init-from-entity! ((this fac-fire-torch) (arg0 entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-fac-fire-torch" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this on-duration)
        (the-as time-frame (the int (* 300.0 (res-lump-float (-> this entity) 'on-duration :default 1.15))))
        )
  (set! (-> this off-duration)
        (the-as time-frame (the int (* 300.0 (res-lump-float (-> this entity) 'off-duration :default 1.85))))
        )
  (set! (-> this phase-offset)
        (the-as time-frame (the int (* 300.0 (res-lump-float (-> this entity) 'zapper-phase))))
        )
  (set! (-> this fire-is-on) #f)
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 806) this))
  (let* ((s4-1 (-> this part))
         (s3-1 (method-of-object s4-1 set-local-space-info))
         (s2-0 (the-as
                 particle-local-space-info
                 (add-connection *part-local-space-engine* this local-space-proc-joint 4 0 0)
                 )
               )
         )
    (let ((v1-20 (process->handle this)))
      (if (= v1-20 #f)
          (set! v1-20 (process->handle this))
          )
      (set! (-> s2-0 hand) (the-as handle v1-20))
      )
    (matrix-identity! (-> s2-0 mat-new))
    (matrix-identity! (-> s2-0 mat-prev))
    (set! (-> s2-0 flags) (part-local-space-flags))
    (s3-1 s4-1 s2-0)
    )
  (let ((a1-11 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-24 0))
      (if #t
          (set! v1-24 (logior v1-24 1))
          )
      (set! (-> a1-11 sync-type) 'sync-eased)
      (set! (-> a1-11 sync-flags) (the-as sync-flags v1-24))
      )
    (set! (-> a1-11 period) (the-as uint 1200))
    (set! (-> a1-11 entity) arg0)
    (set! (-> a1-11 percent) 0.0)
    (set! (-> a1-11 ease-in) 0.15)
    (set! (-> a1-11 ease-out) 0.15)
    (set! (-> a1-11 pause-in) 0.0)
    (set! (-> a1-11 pause-out) 0.0)
    (initialize! (-> this sync) a1-11)
    )
  (set! (-> this path) (new 'process 'curve-control this 'path -1000000000.0))
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (set! (-> this looping-sound) (new-sound-id))
  (cond
    ((logtest? (-> this path flags) (path-control-flag not-found))
     (set! (-> this path-pos) 0.0)
     )
    ((> (-> this sync period) 0)
     (set! (-> this path-pos) (get-norm! (-> this sync) 0))
     (get-point-at-percent-along-path! (-> this path) (-> this root trans) (-> this path-pos) 'interp)
     )
    (else
      (set! (-> this path-pos) 0.0)
      (get-point-at-percent-along-path! (-> this path) (-> this root trans) (-> this path-pos) 'interp)
      )
    )
  (go (method-of-object this idle))
  )

;; definition for symbol *fac-robopod-pool-count*, type int
(define *fac-robopod-pool-count* 0)

;; definition of type fac-robopod
(deftype fac-robopod (process-focusable)
  ((my-baby            handle  3)
   (num-babies         uint32)
   (subtask-countdown  int32)
   (suppressed         symbol)
   )
  (:state-methods
    idle
    generate
    die
    already-dead
    )
  )

;; definition for method 3 of type fac-robopod
(defmethod inspect ((this fac-robopod))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-focusable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tmy-baby[3] @ #x~X~%" (-> this my-baby))
  (format #t "~2Tnum-babies: ~D~%" (-> this num-babies))
  (format #t "~2Tsubtask-countdown: ~D~%" (-> this subtask-countdown))
  (format #t "~2Tsuppressed: ~A~%" (-> this suppressed))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-fac-robopod fac-robopod fac-robopod-lod0-jg fac-robopod-idle-ja
              ((fac-robopod-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              )

;; failed to figure out what this is:
(defskelgroup skel-fac-robopod-explode fac-robopod fac-robopod-explode-lod0-jg fac-robopod-explode-idle-ja
              ((fac-robopod-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 25)
              )

;; definition for symbol *fac-robopod-exploder-params*, type joint-exploder-static-params
(define *fac-robopod-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 18 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 19 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 20 :parent-joint-index -1)
      )
    :collide-spec (collide-spec backgnd)
    :art-level #f
    )
  )

;; definition for function fac-robopod-add-hoverbot
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defun fac-robopod-add-hoverbot ((arg0 fac-robopod))
  (cond
    ((and (< (-> arg0 num-babies) (the-as uint 3))
          (< *fac-robopod-pool-count* 3)
          (not (-> *setting-control* user-current nuke-active?))
          )
     (let ((v1-5 (new 'stack-no-clear 'vector))
           (s5-0 (new 'stack-no-clear 'enemy-init-by-other-params))
           )
       (vector+! v1-5 (-> arg0 root trans) (new 'static 'vector :w 1.0))
       (set! (-> s5-0 trans quad) (-> v1-5 quad))
       (quaternion-copy! (-> s5-0 quat) (-> arg0 root quat))
       (set! (-> s5-0 entity) (-> arg0 entity))
       (set! (-> s5-0 directed?) #f)
       (set! (-> s5-0 no-initial-move-to-ground?) #t)
       (set! (-> s5-0 art-level) 'lfacrm2)
       (let* ((s4-0 (get-process *default-dead-pool* robo-hover #x4000 1))
              (v0-4 (ppointer->handle (when s4-0
                                        (let ((t9-2 (method-of-type process activate)))
                                          (t9-2 s4-0 arg0 "robo-hover" (the-as pointer #x70004000))
                                          )
                                        (run-now-in-process s4-0 enemy-init-by-other arg0 s5-0)
                                        (-> s4-0 ppointer)
                                        )
                                      )
                    )
              )
         (when (!= v0-4 #f)
           (set! (-> arg0 my-baby (-> arg0 num-babies)) (the-as handle v0-4))
           (+! (-> arg0 num-babies) 1)
           (set! *fac-robopod-pool-count* (+ *fac-robopod-pool-count* 1))
           )
         )
       )
     )
    (else
      )
    )
  (none)
  )

;; definition for function fac-robopod-invalidate-hoverbot
;; WARN: Return type mismatch symbol vs none.
(defun fac-robopod-invalidate-hoverbot ((arg0 fac-robopod) (arg1 int))
  (when (> (-> arg0 num-babies) 0)
    (let ((v1-2 (+ (-> arg0 num-babies) -1)))
      (set! (-> arg0 num-babies) v1-2)
      (let ((a2-2 (-> arg0 my-baby v1-2))
            (a3-2 (-> arg0 my-baby arg1))
            )
        (set! *fac-robopod-pool-count* (+ *fac-robopod-pool-count* -1))
        (when (!= v1-2 arg1)
          (set! (-> arg0 my-baby arg1) a2-2)
          (set! (-> arg0 my-baby v1-2) a3-2)
          )
        )
      (set! (-> arg0 my-baby v1-2) (the-as handle #f))
      )
    )
  (none)
  )

;; definition for function fac-robopod-base-handler
(defbehavior fac-robopod-base-handler fac-robopod ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('impact-impulse)
     (let ((v1-1 (the-as object (-> arg3 param 0))))
       (when (< 40960.0 (-> (the-as rigid-body-impact v1-1) impulse))
         (logior! (-> self root penetrated-by) (penetrate vehicle))
         (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.15))
         (cpad-set-buzz! (-> *cpad-list* cpads 0) 0 192 (seconds 0.1))
         (go-virtual die)
         #t
         )
       )
     )
    (('child-die)
     (let ((v1-10 (+ (-> self subtask-countdown) -1)))
       (set! (-> self subtask-countdown) v1-10)
       (when (zero? v1-10)
         (let ((t9-3 format)
               (a0-9 #t)
               (a1-3 "%s dead~%")
               )
           (-> self name)
           (t9-3 a0-9 a1-3)
           )
         (process-entity-status! self (entity-perm-status subtask-complete) #t)
         )
       )
     )
    (('suppress)
     (format #t "suppress~%")
     (set! (-> self suppressed) #t)
     (dotimes (gp-0 3)
       (format #t "~d : ~I~%" gp-0 (-> self my-baby gp-0))
       (when (and (-> self my-baby gp-0) (handle->process (-> self my-baby gp-0)))
         (let ((s5-0 (handle->process (-> self my-baby gp-0))))
           (format #t "killing ~A~%" (-> s5-0 name))
           (send-event s5-0 'die-fast)
           )
         )
       )
     #f
     )
    (('unsuppress)
     (set! (-> self suppressed) #f)
     #f
     )
    )
  )

;; definition for method 27 of type fac-robopod
;; INFO: this function exists in multiple non-identical object files
(defmethod get-inv-mass ((this fac-robopod))
  2.0
  )

;; failed to figure out what this is:
(defstate idle (fac-robopod)
  :virtual #t
  :event fac-robopod-base-handler
  :enter (behavior ()
    (setup-masks (-> self draw) 2 1)
    )
  :code (behavior ()
    (until #f
      (dotimes (gp-0 (the-as int (-> self num-babies)))
        (cond
          ((and (-> self my-baby gp-0) (handle->process (-> self my-baby gp-0)))
           (let ((s5-0 (handle->process (-> self my-baby gp-0))))
             (when (and (-> s5-0 next-state) (= (-> s5-0 next-state name) 'dormant))
               (fac-robopod-invalidate-hoverbot self gp-0)
               (send-event s5-0 'die-fast)
               )
             )
           )
          (else
            (fac-robopod-invalidate-hoverbot self gp-0)
            )
          )
        )
      (if (and (< (-> self num-babies) (the-as uint 3))
               (< *fac-robopod-pool-count* 3)
               (and (< (if *target*
                           (vector-vector-distance (-> self root trans) (-> *target* control trans))
                           4096000.0
                           )
                       245760.0
                       )
                    (< (+ -24576.0 (-> self root trans y)) (-> (target-pos 0) y))
                    (not (-> self suppressed))
                    )
               )
          (go-virtual generate)
          )
      (suspend)
      )
    #f
    )
  :post ja-post
  )

;; failed to figure out what this is:
(defstate generate (fac-robopod)
  :virtual #t
  :event fac-robopod-base-handler
  :code (behavior ()
    (fac-robopod-add-hoverbot self)
    (sound-play "fac-hatch-open")
    (ja-no-eval :group! fac-robopod-open-ja :num! (seek! max 2.0) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max 2.0))
      )
    (sound-play "fac-hatch-close")
    (ja-no-eval :group! fac-robopod-close-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go-virtual idle)
    )
  :post ja-post
  )

;; failed to figure out what this is:
(defstate die (fac-robopod)
  :virtual #t
  :enter (behavior ()
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (let* ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 1)))
           (s5-0 *target*)
           (a0-3 (if (type? s5-0 process-focusable)
                     s5-0
                     )
                 )
           )
      (when a0-3
        (get-trans a0-3 0)
        (let ((s5-1 (-> *target* control transv)))
          (vector-negate! (-> gp-0 fountain-rand-transv-lo) s5-1)
          (vector+! (-> gp-0 fountain-rand-transv-lo) (-> gp-0 fountain-rand-transv-lo) (-> self root trans))
          (+! (-> gp-0 fountain-rand-transv-lo y) -40960.0)
          (let ((f0-2 (vector-length s5-1)))
            (set! (-> gp-0 fountain-rand-transv-hi x) f0-2)
            (set! (-> gp-0 fountain-rand-transv-hi y) (* 3.0 f0-2))
            )
          )
        (set! (-> gp-0 fountain-rand-transv-hi z) 24576.0)
        (set! (-> gp-0 fountain-rand-transv-hi w) 73728.0)
        (sound-play "fac-hatch-explo")
        (cond
          ((logtest? (-> *part-group-id-table* 752 flags) (sp-group-flag sp13))
           (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
           (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 752))
           )
          (else
            (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
            (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 752))
            )
          )
        (process-spawn
          joint-exploder
          (art-group-get-by-name *level* "skel-fac-robopod-explode" (the-as (pointer level) #f))
          8
          gp-0
          *fac-robopod-exploder-params*
          :name "joint-exploder"
          :to self
          )
        )
      )
    )
  :code (behavior ()
    (set! (-> self root root-prim prim-core collide-with) (collide-spec))
    (set! (-> self root root-prim prim-core collide-as) (collide-spec))
    (set! (-> self root root-prim prim-core action) (collide-action))
    (cond
      ((logtest? (-> *part-group-id-table* 218 flags) (sp-group-flag sp13))
       (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
       (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 218))
       )
      (else
        (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
        (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 218))
        )
      )
    (setup-masks (-> self draw) 1 2)
    (sleep-code)
    )
  :post ja-post
  )

;; failed to figure out what this is:
(defstate already-dead (fac-robopod)
  :virtual #t
  :enter (behavior ()
    (set! (-> self root root-prim prim-core collide-with) (collide-spec))
    (set! (-> self root root-prim prim-core collide-as) (collide-spec))
    (set! (-> self root root-prim prim-core action) (collide-action))
    (setup-masks (-> self draw) 1 2)
    )
  :code sleep-code
  :post ja-post
  )

;; definition for method 27 of type fac-robopod
;; INFO: this function exists in multiple non-identical object files
(defmethod get-inv-mass ((this fac-robopod))
  2.0
  )

;; definition for method 10 of type fac-robopod
(defmethod deactivate ((this fac-robopod))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (format #t "~s killing ~d babies~%" (-> this name) (-> this num-babies))
  (set! *fac-robopod-pool-count* (- *fac-robopod-pool-count* (the-as int (-> this num-babies))))
  (call-parent-method this)
  (none)
  )

;; definition for method 11 of type fac-robopod
(defmethod init-from-entity! ((this fac-robopod) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-6 prim-core action) (collide-action solid))
      (set! (-> v1-6 transform-index) 3)
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-6)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-fac-robopod" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (let ((v1-14 0)
        (a0-14 2)
        )
    (while (>= a0-14 v1-14)
      (set! (-> this my-baby v1-14) (the-as handle #f))
      (+! v1-14 1)
      )
    )
  (set! (-> this num-babies) (the-as uint 0))
  (set! (-> this subtask-countdown)
        (res-lump-value (-> this entity) 'gate-countdown int :default (the-as uint128 5) :time -1000000000.0)
        )
  (set! (-> this suppressed) #f)
  (if (not (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete)))
      (go (method-of-object this idle))
      (go (method-of-object this already-dead))
      )
  )

;; definition of type factory-elec-gate
(deftype factory-elec-gate (process)
  ((path-l             path-control)
   (path-r             path-control)
   (beams              lightning-control  4)
   (beams-on           symbol             4)
   (bzzt-sound         sound-id)
   (blocking-plane     handle)
   (actor-group        (pointer actor-group))
   (actor-group-count  int32)
   )
  (:state-methods
    idle
    flickering
    )
  )

;; definition for method 3 of type factory-elec-gate
(defmethod inspect ((this factory-elec-gate))
  (when (not this)
    (set! this this)
    (goto cfg-7)
    )
  (let ((t9-0 (method-of-type process inspect)))
    (t9-0 this)
    )
  (format #t "~2Tpath-l: ~A~%" (-> this path-l))
  (format #t "~2Tpath-r: ~A~%" (-> this path-r))
  (format #t "~2Tbeams[4] @ #x~X~%" (-> this beams))
  (format #t "~2Tbeams-on[4] @ #x~X~%" (-> this beams-on))
  (format #t "~2Tbzzt-sound: ~D~%" (-> this bzzt-sound))
  (format #t "~2Tblocking-plane: ~D~%" (-> this blocking-plane))
  (format #t "~2Tactor-group: #x~X~%" (-> this actor-group))
  (dotimes (s5-0 (-> this actor-group-count))
    (format #t "~T  [~D]~2Tactor-group: ~`actor-group`P~%" s5-0 (-> this actor-group s5-0))
    )
  (format #t "~2Tactor-group-count: ~D~%" (-> this actor-group-count))
  (label cfg-7)
  this
  )

;; failed to figure out what this is:
(defstate idle (factory-elec-gate)
  :virtual #t
  :enter (behavior ()
    (let ((gp-0 0)
          (s5-0 3)
          )
      (while (>= s5-0 gp-0)
        (let ((s4-0 (get-point-in-path! (-> self path-l) (new 'stack-no-clear 'vector) (the float gp-0) 'interp))
              (v1-2 (get-point-in-path! (-> self path-r) (new 'stack-no-clear 'vector) (the float gp-0) 'interp))
              )
          (set! (-> self beams gp-0 state meet data 0 quad) (-> s4-0 quad))
          (let ((a0-9 (-> self beams gp-0)))
            (set! (-> a0-9 state meet data (+ (-> a0-9 state points-to-draw) -1) quad) (-> v1-2 quad))
            )
          )
        (set! (-> self beams-on gp-0) #t)
        (set-factoryc-light! 1.0 1)
        (+! gp-0 1)
        )
      )
    (when (not (handle->process (-> self blocking-plane)))
      (let ((gp-1 (new 'static 'inline-array vector 2 (new 'static 'vector) (new 'static 'vector))))
        (get-point-in-path! (-> self path-l) (-> gp-1 0) 0.0 'interp)
        (get-point-in-path! (-> self path-r) (-> gp-1 1) 0.0 'interp)
        (+! (-> gp-1 0 y) -16384.0)
        (+! (-> gp-1 1 y) -16384.0)
        (set! (-> self blocking-plane)
              (ppointer->handle (process-spawn blocking-plane gp-1 #x47f00000 :name "blocking-plane" :to self))
              )
        )
      (send-event (handle->process (-> self blocking-plane)) 'collide-as #x4000000)
      (send-event (handle->process (-> self blocking-plane)) 'attack-mode 'shock)
      )
    )
  :code sleep-code
  :post (behavior ()
    (when (> (-> self actor-group-count) 0)
      (dotimes (gp-0 (length (-> self actor-group 0)))
        (when (logtest? (-> self actor-group 0 data gp-0 actor extra perm status) (entity-perm-status subtask-complete))
          (go-virtual flickering)
          #t
          (goto cfg-8)
          )
        )
      )
    (label cfg-8)
    (sound-play "laser-loop" :id (-> self bzzt-sound) :position (-> self entity trans))
    (debug-draw (-> self path-l))
    (debug-draw (-> self path-r))
    )
  )

;; failed to figure out what this is:
(defstate flickering (factory-elec-gate)
  :virtual #t
  :code (behavior ()
    (suspend-for (seconds 3)
      (let ((s5-0 (the-as int (rand-uint31-gen *random-generator*))))
        (let ((s4-0 0)
              (s3-0 3)
              )
          (while (>= s3-0 s4-0)
            (cond
              ((logtest? s5-0 1)
               (when (not (-> self beams-on s4-0))
                 (let ((v1-8 (-> self beams s4-0))
                       (a0-1 1)
                       )
                   (let ((a1-1 (!= a0-1 (-> v1-8 state mode))))
                     (case a0-1
                       ((3)
                        (if a1-1
                            (set! (-> v1-8 state counter) 0.0)
                            )
                        )
                       ((1)
                        (set! (-> v1-8 state start-color) (-> v1-8 spec start-color))
                        (set! (-> v1-8 state end-color) (-> v1-8 spec end-color))
                        )
                       )
                     )
                   (set! (-> v1-8 state mode) (the-as uint a0-1))
                   )
                 (set! (-> self beams-on s4-0) #t)
                 (set-factoryc-light! 1.0 1)
                 )
               )
              (else
                (when (-> self beams-on s4-0)
                  (let ((v1-17 (-> self beams s4-0))
                        (a0-5 3)
                        )
                    (let ((a1-12 (!= a0-5 (-> v1-17 state mode))))
                      (case a0-5
                        ((3)
                         (if a1-12
                             (set! (-> v1-17 state counter) 0.0)
                             )
                         )
                        ((1)
                         (set! (-> v1-17 state start-color) (-> v1-17 spec start-color))
                         (set! (-> v1-17 state end-color) (-> v1-17 spec end-color))
                         )
                        )
                      )
                    (set! (-> v1-17 state mode) (the-as uint a0-5))
                    )
                  (set! (-> self beams-on s4-0) #f)
                  (set-factoryc-light! 0.0 1)
                  )
                )
              )
            (set! s5-0 (/ s5-0 2))
            (+! s4-0 1)
            )
          )
        (suspend-for (seconds 0.1)
          (if (logand s5-0 1)
              (sound-play "laser-loop" :id (-> self bzzt-sound) :position (-> self entity trans))
              )
          )
        )
      (empty-form)
      )
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (process-entity-status! self (entity-perm-status dead) #t)
    (sound-stop (-> self bzzt-sound))
    (let ((a0-13 (handle->process (-> self blocking-plane))))
      (if a0-13
          (deactivate a0-13)
          )
      )
    )
  :post (behavior ()
    (debug-draw (-> self path-l))
    (debug-draw (-> self path-r))
    )
  )

;; definition for method 7 of type factory-elec-gate
(defmethod relocate ((this factory-elec-gate) (offset int))
  (if (nonzero? (-> this path-l))
      (&+! (-> this path-l) offset)
      )
  (if (nonzero? (-> this path-r))
      (&+! (-> this path-r) offset)
      )
  (let ((v1-8 0)
        (a0-1 3)
        )
    (while (>= a0-1 v1-8)
      (if (nonzero? (-> this beams v1-8))
          (&+! (-> this beams v1-8) offset)
          )
      (+! v1-8 1)
      )
    )
  (call-parent-method this offset)
  )

;; definition for method 10 of type factory-elec-gate
(defmethod deactivate ((this factory-elec-gate))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (sound-stop (-> this bzzt-sound))
  (call-parent-method this)
  (none)
  )

;; definition for method 11 of type factory-elec-gate
;; INFO: Used lq/sq
(defmethod init-from-entity! ((this factory-elec-gate) (arg0 entity-actor))
  (local-vars (sv-16 res-tag))
  (when (task-node-closed? (game-task-node factory-assault-get-vehicle))
    (process-entity-status! this (entity-perm-status dead) #t)
    (deactivate this)
    )
  (set! (-> this path-l) (new 'process 'path-control this 'pathl 0.0 arg0 #f))
  (set! (-> this path-r) (new 'process 'path-control this 'pathr 0.0 arg0 #f))
  (logior! (-> this path-l flags) (path-control-flag display draw-line draw-point draw-text))
  (logior! (-> this path-r flags) (path-control-flag display draw-line draw-point draw-text))
  (set! (-> this bzzt-sound) (new-sound-id))
  (let ((s4-0 0)
        (s3-0 3)
        )
    (while (>= s3-0 s4-0)
      (set! (-> this beams s4-0) (new 'process 'lightning-control (-> *lightning-spec-id-table* 34) this 0.0))
      (set! (-> this beams-on s4-0) #f)
      (set-factoryc-light! 0.0 1)
      (+! s4-0 1)
      )
    )
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-20 (res-lump-data arg0 'actor-groups (pointer actor-group) :tag-ptr (& sv-16))))
    (cond
      ((and v1-20 (nonzero? (-> sv-16 elt-count)))
       (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
       (set! (-> this actor-group) v1-20)
       )
      (else
        (set! (-> this actor-group-count) 0)
        0
        )
      )
    )
  (set! (-> this blocking-plane) (the-as handle #f))
  (if (not (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete)))
      (go (method-of-object this idle))
      (go (method-of-object this flickering))
      )
  )
