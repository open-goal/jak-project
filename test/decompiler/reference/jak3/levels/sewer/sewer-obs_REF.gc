;;-*-Lisp-*-
(in-package goal)

;; definition for function sewer-login
;; WARN: Return type mismatch int vs none.
(defun sewer-login ((arg0 level))
  (set! *nav-network* (new 'loading-level 'nav-network))
  (alloc-nav-network-for-level! *nav-network* 64 10)
  0
  (none)
  )

;; definition for function sewer-logout
;; WARN: Return type mismatch int vs none.
(defun sewer-logout ((arg0 level))
  (set! *nav-network* (the-as nav-network 0))
  0
  (none)
  )

;; definition for function sewb-activate
;; WARN: Return type mismatch int vs none.
(defun sewb-activate ((arg0 level))
  (if (and (nonzero? *nav-network*) *nav-network*)
      (init-by-other! *nav-network* arg0 *sewb-adjacency*)
      )
  0
  (none)
  )

;; definition for function sewc-activate
;; WARN: Return type mismatch int vs none.
(defun sewc-activate ((arg0 level))
  (if (and (nonzero? *nav-network*) *nav-network*)
      (init-by-other! *nav-network* arg0 *sewb-adjacency*)
      )
  0
  (none)
  )

;; definition for function sewg-activate
;; WARN: Return type mismatch int vs none.
(defun sewg-activate ((arg0 level))
  (if (and (nonzero? *nav-network*) *nav-network*)
      (init-by-other! *nav-network* arg0 *sewg-adjacency*)
      )
  0
  (none)
  )

;; definition for function sewl-activate
;; WARN: Return type mismatch int vs none.
(defun sewl-activate ((arg0 level))
  (if (and (nonzero? *nav-network*) *nav-network*)
      (init-by-other! *nav-network* arg0 *sewl-adjacency*)
      )
  0
  (none)
  )

;; definition for function sewo-activate
;; WARN: Return type mismatch int vs none.
(defun sewo-activate ((arg0 level))
  (if (and (nonzero? *nav-network*) *nav-network*)
      (init-by-other! *nav-network* arg0 *sewo-adjacency*)
      )
  0
  (none)
  )

;; definition for function sewj-activate
;; WARN: Return type mismatch int vs none.
(defun sewj-activate ((arg0 level))
  (if (and (nonzero? *nav-network*) *nav-network*)
      (init-by-other! *nav-network* arg0 *sewj-adjacency*)
      )
  0
  (none)
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-curved-door sew-curved-door sew-curved-door-lod0-jg sew-curved-door-idle-ja
              ((sew-curved-door-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 5 0 15)
              )

;; definition of type sew-curved-door
(deftype sew-curved-door (com-airlock)
  ()
  )

;; definition for method 3 of type sew-curved-door
(defmethod inspect ((this sew-curved-door))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type com-airlock inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 11 of type sew-curved-door
(defmethod init-from-entity! ((this sew-curved-door) (arg0 entity-actor))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 1) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 2))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 20480.0 0.0 61440.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 3)
      (set-vector! (-> v1-8 local-sphere) 0.0 20480.0 0.0 61440.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-11 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-11 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-11 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-curved-door" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (init-airlock! this)
  (set! (-> this sound-open-loop) (static-sound-spec "curve-door-open" :group 0))
  (set! (-> this sound-open-stop) (static-sound-spec "curve-door-hit" :group 0))
  (set! (-> this sound-close-loop) (static-sound-spec "curve-door-cls" :group 0))
  (set! (-> this sound-close-stop) (static-sound-spec "curve-door-hit" :group 0))
  (go (method-of-object this close) #t)
  )

;; definition of type sew-floating-plat
(deftype sew-floating-plat (elevator)
  ()
  )

;; definition for method 3 of type sew-floating-plat
(defmethod inspect ((this sew-floating-plat))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type elevator inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-floating-plat sew-float-plat sew-float-plat-lod0-jg sew-float-plat-idle-ja
              ((sew-float-plat-lod0-mg (meters 20)) (sew-float-plat-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              )

;; definition for method 31 of type sew-floating-plat
(defmethod get-art-group ((this sew-floating-plat))
  (art-group-get-by-name *level* "skel-sew-floating-plat" (the-as (pointer level) #f))
  )

;; definition for method 42 of type sew-floating-plat
;; WARN: Return type mismatch object vs none.
(defmethod go-arrived-or-waiting ((this sew-floating-plat))
  (go (method-of-object this dormant))
  (none)
  )

;; definition for method 32 of type sew-floating-plat
;; WARN: Return type mismatch int vs none.
(defmethod init-collision! ((this sew-floating-plat))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak hit-by-others-list player-list projectile))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable pull-rider-can-collide))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-16 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-16 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-16 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; definition for method 34 of type sew-floating-plat
;; WARN: Return type mismatch sound-spec vs none.
(defmethod base-plat-method-34 ((this sew-floating-plat))
  (set! (-> this sound-running-loop) (static-sound-spec "float-plat-loop" :group 0))
  (set! (-> this sound-arrived) (static-sound-spec "float-plat-end" :group 0))
  (none)
  )

;; definition of type sew-cam-sequencer
(deftype sew-cam-sequencer (process)
  ((activate-script  pair  :offset 132)
   (enter-script     pair)
   (exit-script      pair)
   (timeout          time-frame)
   (offset           uint64)
   )
  (:state-methods
    active
    )
  )

;; definition for method 3 of type sew-cam-sequencer
(defmethod inspect ((this sew-cam-sequencer))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process inspect)))
    (t9-0 this)
    )
  (format #t "~2Tentity: ~A~%" (-> this entity))
  (format #t "~2Tactivate-script: ~A~%" (-> this activate-script))
  (format #t "~2Tenter-script: ~A~%" (-> this enter-script))
  (format #t "~2Texit-script: ~A~%" (-> this exit-script))
  (format #t "~2Ttimeout: ~D~%" (-> this timeout))
  (format #t "~2Toffset: ~D~%" (-> this offset))
  (label cfg-4)
  this
  )

;; definition for function sew-cam-sequencer-init-by-other
(defbehavior sew-cam-sequencer-init-by-other sew-cam-sequencer ((arg0 entity-actor))
  (set! (-> self entity) arg0)
  (logclear! (-> self mask) (process-mask actor-pause))
  (stack-size-set! (-> self main-thread) 512)
  (set! (-> self enter-script) (res-lump-struct (-> self entity) 'on-enter pair))
  (set! (-> self activate-script) (res-lump-struct (-> self entity) 'on-movie pair))
  (set! (-> self exit-script) (res-lump-struct (-> self entity) 'on-exit pair))
  (set! (-> self timeout) (the-as time-frame (the int (* 300.0 (res-lump-float (-> self entity) 'timeout)))))
  (set! (-> self offset) (the-as uint (the int (* 300.0 (res-lump-float (-> self entity) 'offset-time)))))
  (go-virtual active)
  )

;; definition for function sew-cam-eval-script
(defun sew-cam-eval-script ((arg0 pair))
  (script-eval arg0)
  )

;; failed to figure out what this is:
(defstate active (sew-cam-sequencer)
  :virtual #t
  :code (behavior ()
    (let ((gp-0 (current-time)))
      (until (time-elapsed? gp-0 (seconds 0.5))
        (suspend)
        )
      )
    (until (process-grab? *target* #f)
      (suspend)
      )
    (let ((a0-1 (-> self enter-script)))
      (if a0-1
          (sew-cam-eval-script a0-1)
          )
      )
    (let ((gp-1 (current-time)))
      (until (time-elapsed? gp-1 (-> self timeout))
        (suspend)
        )
      )
    (let ((a0-3 (-> self activate-script)))
      (if a0-3
          (sew-cam-eval-script a0-3)
          )
      )
    (let ((gp-2 (current-time)))
      (until (time-elapsed? gp-2 (the-as time-frame (-> self offset)))
        (suspend)
        )
      )
    (let ((a0-5 (-> self exit-script)))
      (if a0-5
          (sew-cam-eval-script a0-5)
          )
      )
    (until (process-release? *target*)
      (suspend)
      )
    )
  )

;; definition of type sew-floor-switch
(deftype sew-floor-switch (process-drawable)
  ()
  (:state-methods
    idle-up
    going-down
    idle-down
    )
  )

;; definition for method 3 of type sew-floor-switch
(defmethod inspect ((this sew-floor-switch))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-floor-switch sew-floor-switch sew-floor-switch-lod0-jg sew-floor-switch-idle-ja
              ((sew-floor-switch-lod0-mg (meters 20)) (sew-floor-switch-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 2)
              )

;; definition for method 12 of type sew-floor-switch
(defmethod run-logic? ((this sew-floor-switch))
  "Should this process be run? Checked by execute-process-tree."
  #t
  )

;; failed to figure out what this is:
(defstate idle-up (sew-floor-switch)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (when (logtest? (-> (the-as attack-info (-> block param 1)) penetrate-using) (penetrate flop))
         (go-virtual going-down)
         #f
         )
       )
      )
    )
  :code transform-and-sleep-code
  )

;; failed to figure out what this is:
(defstate going-down (sew-floor-switch)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('subtask-msg)
       (process-spawn sew-cam-sequencer (-> self entity) :name "sew-cam-sequencer" :to self)
       )
      )
    )
  :code (behavior ()
    (sound-play "floor-switch")
    (ja-no-eval :group! sew-floor-switch-pushdown-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (let ((gp-1 (res-lump-struct (-> self entity) 'on-activate pair)))
      (if gp-1
          (script-eval gp-1)
          )
      )
    (go-virtual idle-down)
    )
  )

;; failed to figure out what this is:
(defstate idle-down (sew-floor-switch)
  :virtual #t
  :code (behavior ()
    (ja-channel-set! 1)
    (ja :group! sew-floor-switch-pushdown-ja :num! (identity (the float (ja-num-frames 0))))
    (ja-post)
    (sleep-code)
    )
  )

;; definition for method 11 of type sew-floor-switch
(defmethod init-from-entity! ((this sew-floor-switch) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 8192.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-9 prim-core action) (collide-action solid))
      (set! (-> v1-9 transform-index) 4)
      (set-vector! (-> v1-9 local-sphere) 0.0 0.0 0.0 8192.0)
      )
    (let ((v1-11 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-11 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-11 prim-core action) (collide-action solid))
      (set! (-> v1-11 transform-index) 3)
      (set-vector! (-> v1-11 local-sphere) 0.0 0.0 0.0 8192.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-14 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-14 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-14 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (set-vector! (-> this root scale) 1.5 1.0 1.5 1.0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-floor-switch" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (let ((s4-2 (the-as object #f)))
    (let ((s5-2 (res-lump-struct (-> this entity) 'open-test structure)))
      (if s5-2
          (set! s4-2 (script-eval (the-as pair s5-2)))
          )
      )
    (if s4-2
        (go (method-of-object this idle-down))
        (go (method-of-object this idle-up))
        )
    )
  )

;; definition of type sew-jump-pad
(deftype sew-jump-pad (jump-pad)
  ()
  )

;; definition for method 3 of type sew-jump-pad
(defmethod inspect ((this sew-jump-pad))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type jump-pad inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-jump-pad sew-jump-pad sew-jump-pad-lod0-jg sew-jump-pad-idle-ja
              ((sew-jump-pad-lod0-mg (meters 20)) (sew-jump-pad-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              )

;; definition for method 28 of type sew-jump-pad
(defmethod get-fan-joint-idx ((this sew-jump-pad))
  4
  )

;; definition for method 27 of type sew-jump-pad
(defmethod get-skel ((this sew-jump-pad))
  (art-group-get-by-name *level* "skel-sew-jump-pad" (the-as (pointer level) #f))
  )

;; definition for method 24 of type sew-jump-pad
;; WARN: Return type mismatch int vs none.
(defmethod init-collision! ((this sew-jump-pad))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec crate))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 2))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 0)
      (set-vector! (-> v1-8 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 8))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-10 prim-core action) (collide-action))
      (set-vector! (-> v1-10 local-sphere) 0.0 4096.0 0.0 10240.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; definition for method 29 of type sew-jump-pad
;; WARN: Return type mismatch int vs none.
(defmethod init-sounds ((this sew-jump-pad))
  (set! (-> this fan-loop-sound) (static-sound-spec "sewer-fan" :group 0))
  (set! (-> this jump-sound) (static-sound-spec "jump-pad" :group 0))
  0
  (none)
  )

;; definition of type sew-fan
(deftype sew-fan (enemy)
  ((activate-distance  float)
   (path-pos           float)
   (sweep-dir          int8)
   (travel-dir         int8)
   (float-quat         quaternion  :inline)
   (base-trans-y       float)
   (base-quat          quaternion  :inline)
   (dest-quat          quaternion  :inline)
   (fan-rot            float)
   (fan-rot-vel        float)
   (hostile-part       sparticle-launch-control)
   (gust-part          sparticle-launch-control)
   (sound-fan-loop-id  sound-id)
   )
  )

;; definition for method 3 of type sew-fan
(defmethod inspect ((this sew-fan))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type enemy inspect)))
    (t9-0 this)
    )
  (format #t "~2Tactivate-distance: ~f~%" (-> this activate-distance))
  (format #t "~2Tpath-pos: ~f~%" (-> this path-pos))
  (format #t "~2Tsweep-dir: ~D~%" (-> this sweep-dir))
  (format #t "~2Ttravel-dir: ~D~%" (-> this travel-dir))
  (format #t "~2Tfloat-quat: #<quaternion @ #x~X>~%" (-> this float-quat))
  (format #t "~2Tbase-trans-y: ~f~%" (-> this base-trans-y))
  (format #t "~2Tbase-quat: #<quaternion @ #x~X>~%" (-> this base-quat))
  (format #t "~2Tdest-quat: #<quaternion @ #x~X>~%" (-> this dest-quat))
  (format #t "~2Tfan-rot: ~f~%" (-> this fan-rot))
  (format #t "~2Tfan-rot-vel: ~f~%" (-> this fan-rot-vel))
  (format #t "~2Thostile-part: ~A~%" (-> this hostile-part))
  (format #t "~2Tgust-part: ~A~%" (-> this gust-part))
  (format #t "~2Tsound-fan-loop-id: ~D~%" (-> this sound-fan-loop-id))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-fan sew-fan sew-fan-lod0-jg sew-fan-idle-ja
              ((sew-fan-lod0-mg (meters 20)) (sew-fan-lod1-mg (meters 40)) (sew-fan-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 1 0 4)
              )

;; definition for symbol *sew-fan-enemy-info*, type enemy-info
(define *sew-fan-enemy-info* (new 'static 'enemy-info
                               :use-die-falling #f
                               :use-victory #f
                               :use-jump-blocked #f
                               :debug-draw-neck #f
                               :jump-debug-draw #f
                               :move-to-ground #f
                               :hover-if-no-ground #f
                               :idle-anim-script (new 'static 'inline-array idle-control-frame 2
                                 (new 'static 'idle-control-frame
                                   :command (idle-control-cmd play)
                                   :anim #x4
                                   :param2 '((new 'static 'bfloat :data 1.0) (new 'static 'bfloat :data 1.0))
                                   )
                                 (new 'static 'idle-control-frame)
                                 )
                               :idle-anim 4
                               :notice-anim 4
                               :hostile-anim 4
                               :hit-anim 4
                               :knocked-anim -1
                               :knocked-land-anim -1
                               :die-anim 4
                               :die-falling-anim -1
                               :victory-anim -1
                               :jump-wind-up-anim -1
                               :jump-in-air-anim -1
                               :jump-land-anim -1
                               :neck-joint -1
                               :look-at-joint 4
                               :bullseye-joint 5
                               :notice-distance (meters 30)
                               :notice-distance-delta (meters 10)
                               :default-hit-points 8.0
                               :gnd-collide-with (collide-spec backgnd)
                               :overlaps-others-collide-with-filter (collide-spec jak bot player-list)
                               :movement-gravity (meters -100)
                               :friction 0.8
                               :attack-shove-back (meters 3)
                               :attack-shove-up (meters 2)
                               :attack-mode 'generic
                               :attack-damage 2
                               :recover-gnd-collide-with (collide-spec backgnd crate obstacle hit-by-others-list pusher)
                               :knocked-can-land-timeout (seconds 0.1)
                               :knocked-recover-timeout (seconds 2)
                               :ragdoll-blend-out-time (seconds 0.25)
                               :ragdoll-rotate-velocity-mult 1.0
                               :jump-height-min (meters 3)
                               :jump-height-factor 0.5
                               :knocked-seek-ry-clamp 2730.6667
                               :knocked-soft-vxz-lo 72089.6
                               :knocked-soft-vxz-hi 108134.4
                               :knocked-soft-vy-lo 81920.0
                               :knocked-soft-vy-hi 122880.0
                               :knocked-medium-vxz-lo 147456.0
                               :knocked-medium-vxz-hi 196608.0
                               :knocked-medium-vy-lo 135168.0
                               :knocked-medium-vy-hi 151552.0
                               :knocked-hard-vxz-lo 78643.2
                               :knocked-hard-vxz-hi 117964.8
                               :knocked-hard-vy-lo 183500.8
                               :knocked-hard-vy-hi 209715.2
                               :knocked-huge-vxz-lo 164659.2
                               :knocked-huge-vxz-hi 249036.8
                               :knocked-huge-vy-lo 183500.8
                               :knocked-huge-vy-hi 217907.2
                               :knocked-yellow-vxz-lo 40960.0
                               :knocked-yellow-vxz-hi 49152.0
                               :knocked-yellow-vy-lo 57344.0
                               :knocked-yellow-vy-hi 81920.0
                               :knocked-red-vxz-lo 24576.0
                               :knocked-red-vxz-hi 196608.0
                               :knocked-red-vy-lo 94208.0
                               :knocked-red-vy-hi 151552.0
                               :knocked-blue-vxz-lo 40960.0
                               :knocked-blue-vxz-hi 49152.0
                               :knocked-blue-vy-lo 24576.0
                               :knocked-blue-vy-hi 81920.0
                               :ragdoll-info #f
                               :shadow-size (meters 1)
                               :shadow-max-y (meters 1)
                               :shadow-min-y (meters -1)
                               :shadow-locus-dist (meters 150)
                               :gem-joint -1
                               :gem-offset (new 'static 'sphere :r 163840.0)
                               :knocked-off #t
                               )
        )

;; failed to figure out what this is:
(set! (-> *sew-fan-enemy-info* fact-defaults) *fact-info-enemy-defaults*)

;; failed to figure out what this is:
(defskelgroup skel-sew-fan-explode sew-fan sew-fan-explode-lod0-jg sew-fan-explode-idle-ja
              ((sew-fan-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 1 0 100)
              )

;; definition for symbol *sew-fan-exploder-params*, type joint-exploder-static-params
(define *sew-fan-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      )
    :collide-spec (collide-spec backgnd)
    )
  )

;; definition for function update-surface-float
(defbehavior update-surface-float sew-fan ()
  (when (< 0.99999046 (fabs (-> (quaternion*!
                                  (new 'stack-no-clear 'quaternion)
                                  (quaternion-inverse! (new 'stack-no-clear 'quaternion) (-> self root quat))
                                  (-> self float-quat)
                                  )
                                w
                                )
                            )
           )
    (let ((s5-1 (new 'stack-no-clear 'vector))
          (gp-1 (new 'stack-no-clear 'quaternion))
          )
      (set-vector! s5-1 (rand-vu-float-range -1.0 1.0) 0.0 (rand-vu-float-range -1.0 1.0) 1.0)
      (vector-normalize! s5-1 1.0)
      (quaternion-vector-angle! gp-1 s5-1 1456.3556)
      (quaternion-copy! (-> self float-quat) (-> self entity quat))
      (quaternion*! (-> self float-quat) (-> self float-quat) gp-1)
      )
    )
  (set! (-> self root trans y) (+ (-> self base-trans-y) (* 614.4 (sin (the float (* 30 (current-time)))))))
  )

;; definition for function update-idle
(defbehavior update-idle sew-fan ()
  (seek! (-> self fan-rot-vel) -21845.334 (* 21845.334 (seconds-per-frame)))
  (quaternion-smooth-seek! (-> self base-quat) (-> self base-quat) (-> self dest-quat) 0.005)
  (quaternion-smooth-seek! (-> self root quat) (-> self root quat) (-> self float-quat) 0.005)
  (when (nonzero? (-> self path))
    (set! (-> self path-pos)
          (path-control-method-26
            (-> self path)
            (-> self path-pos)
            (* 2048.0 (seconds-per-frame) (the float (-> self travel-dir)))
            )
          )
    (if (or (= (-> self path-pos) 1.0) (= (-> self path-pos) 0.0))
        (set! (-> self travel-dir) (* -1 (-> self travel-dir)))
        )
    (get-point-at-percent-along-path! (-> self path) (-> self root trans) (-> self path-pos) 'interp)
    )
  (update-surface-float)
  (sound-play-by-name
    (static-sound-name "small-sewer-fan")
    (-> self sound-fan-loop-id)
    1024
    (the int (* 1524.0 (lerp-scale -0.9 0.6 (-> self fan-rot-vel) -21845.334 -174762.67)))
    0
    (sound-group)
    #t
    )
  (when (< 0.99984777 (fabs (-> (quaternion*!
                                  (new 'stack-no-clear 'quaternion)
                                  (quaternion-inverse! (new 'stack-no-clear 'quaternion) (-> self base-quat))
                                  (-> self dest-quat)
                                  )
                                w
                                )
                            )
           )
    (set! (-> self sweep-dir) (* -1 (-> self sweep-dir)))
    (quaternion-copy! (-> self dest-quat) (-> self entity quat))
    (quaternion-rotate-y! (-> self dest-quat) (-> self dest-quat) (* 8192.0 (the float (-> self sweep-dir))))
    )
  (remove-setting! 'global-wind)
  (none)
  )

;; definition for function update-hostile
;; INFO: Used lq/sq
;; WARN: Return type mismatch connection vs none.
(defbehavior update-hostile sew-fan ()
  (let ((f0-0 -174762.67))
    (seek! (-> self fan-rot-vel) f0-0 (* (fabs f0-0) (seconds-per-frame)))
    )
  (when *target*
    (quaternion<-rotate-y-vector
      (-> self dest-quat)
      (vector-! (new 'stack-no-clear 'vector) (target-pos 0) (-> self root trans))
      )
    (when (nonzero? (-> self path))
      (seek!
        (-> self path-pos)
        (path-control-method-23 (-> self path) (target-pos 0))
        (* (/ 4096.0 (total-distance (-> self path))) (seconds-per-frame))
        )
      (get-point-at-percent-along-path! (-> self path) (-> self root trans) (-> self path-pos) 'interp)
      )
    )
  (quaternion-smooth-seek! (-> self base-quat) (-> self base-quat) (-> self dest-quat) 0.05)
  (quaternion-smooth-seek! (-> self root quat) (-> self root quat) (-> self float-quat) 0.005)
  (update-surface-float)
  (sound-play-by-name
    (static-sound-name "small-sewer-fan")
    (-> self sound-fan-loop-id)
    1024
    (the int (* 1524.0 (lerp-scale -0.9 0.6 (-> self fan-rot-vel) -21845.334 -174762.67)))
    0
    (sound-group)
    #t
    )
  (when (and *target*
             (< 0.99619657 (fabs (-> (quaternion*!
                                       (new 'stack-no-clear 'quaternion)
                                       (quaternion-inverse! (new 'stack-no-clear 'quaternion) (-> self base-quat))
                                       (-> self dest-quat)
                                       )
                                     w
                                     )
                                 )
                )
             )
    (let ((gp-4 (new 'stack-no-clear 'vector))
          (f30-4
            (fmin
              163840.0
              (fmax 0.0 (* 0.0000061035157 (- 163840.0 (vector-vector-distance (target-pos 0) (-> self root trans)))))
              )
            )
          )
      (if (and *target* (focus-test? *target* board))
          (send-event
            *target*
            'push-trans
            (vector-float*! gp-4 (vector-z-quaternion! gp-4 (-> self base-quat)) (* 4915.2 f30-4))
            (seconds 10)
            )
          (send-event
            *target*
            'push-trans
            (vector-float*! gp-4 (vector-z-quaternion! gp-4 (-> self base-quat)) (* 819.2 f30-4))
            (seconds 10)
            )
          )
      (spawn-from-cspace (-> self gust-part) (joint-node sew-fan-lod0-jg fan))
      (let ((v1-46 (vector-z-quaternion! gp-4 (-> self base-quat))))
        (vector-float*! v1-46 v1-46 (* 4096.0 (* 30.0 f30-4)))
        (let ((t1-1 (new 'static 'vector)))
          (set! (-> t1-1 quad) (-> v1-46 quad))
          (set-setting! 'global-wind #f 0.0 t1-1)
          )
        )
      )
    )
  (none)
  )

;; failed to figure out what this is:
(defstate idle (sew-fan)
  :virtual #t
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type enemy idle) trans)))
      (if t9-0
          (t9-0)
          )
      )
    (seek! (-> self fan-rot-vel) -21845.334 (* 21845.334 (seconds-per-frame)))
    (spawn-from-cspace (-> self part) (joint-node sew-fan-lod0-jg lasersight))
    )
  )

;; failed to figure out what this is:
(defstate notice (sew-fan)
  :virtual #t
  :code (behavior ()
    (go-best-state self)
    )
  )

;; failed to figure out what this is:
(defstate active (sew-fan)
  :virtual #t
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type enemy active) trans)))
      (if t9-0
          (t9-0)
          )
      )
    (update-idle)
    (spawn-from-cspace (-> self part) (joint-node sew-fan-lod0-jg lasersight))
    )
  )

;; failed to figure out what this is:
(defstate hostile (sew-fan)
  :virtual #t
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type enemy hostile) trans)))
      (if t9-0
          (t9-0)
          )
      )
    (update-hostile)
    (spawn-from-cspace (-> self hostile-part) (joint-node sew-fan-lod0-jg lasersight))
    )
  )

;; failed to figure out what this is:
(defstate die (sew-fan)
  :virtual #t
  :enter (behavior ()
    (if (nonzero? (-> self sound-fan-loop-id))
        (sound-stop (-> self sound-fan-loop-id))
        )
    (logclear! (-> self mask) (process-mask actor-pause))
    (let ((t9-1 (-> (method-of-type enemy die) enter)))
      (if t9-1
          (t9-1)
          )
      )
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
      (set-vector! (-> gp-0 fountain-rand-transv-lo) -122880.0 40960.0 -122880.0 1.0)
      (set-vector! (-> gp-0 fountain-rand-transv-hi) 122880.0 81920.0 122880.0 1.0)
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-sew-fan-explode" (the-as (pointer level) #f))
        7
        gp-0
        *sew-fan-exploder-params*
        :name "joint-exploder"
        :to self
        :unk 0
        )
      )
    (activate! *camera-smush-control* 819.2 37 210 1.0 0.995 (-> self clock))
    (sound-play "sewer-fan-explo")
    (suspend)
    (cleanup-for-death self)
    (ja-channel-set! 0)
    (send-event self 'death-end)
    (let ((gp-2 (-> self child)))
      (while gp-2
        (send-event (ppointer->process gp-2) 'notice 'die)
        (set! gp-2 (-> gp-2 0 brother))
        )
      )
    (while (-> self child)
      (suspend)
      )
    )
  :post (behavior ()
    (enemy-common-post self)
    )
  )

;; definition for method 82 of type sew-fan
(defmethod event-handler ((this sew-fan) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('touched)
     (send-event arg0 'attack #f (static-attack-info :mask (vehicle-impulse-factor) ((id (new-attack-id))
                                                                                     (damage 2.0)
                                                                                     (vehicle-damage-factor 1.0)
                                                                                     (vehicle-impulse-factor 1.0)
                                                                                     (mode 'shock)
                                                                                     (shove-up (meters 2))
                                                                                     (shove-back (meters 4))
                                                                                     )
                                                     )
                 )
     )
    (('attack)
     (let ((v1-5 (the-as attack-info (-> arg3 param 1))))
       (when (not (logtest? (-> v1-5 penetrate-using) (penetrate flop punch spin roll uppercut bonk)))
         (when (!= (-> v1-5 id) (-> this incoming attack-id))
           (set! (-> this incoming attack-id) (-> v1-5 id))
           (let ((f0-6 (if (logtest? (attack-mask damage) (-> v1-5 mask))
                           (-> v1-5 damage)
                           (penetrate-using->damage (-> v1-5 penetrate-using))
                           )
                       )
                 )
             (if (= (-> arg0 type) gun-yellow-shot-3)
                 (set! f0-6 0.5)
                 )
             (let ((f0-7 (fmin 6.0 f0-6)))
               (set! (-> this hit-points) (- (-> this hit-points) f0-7))
               )
             )
           (if (>= 0.0 (-> this hit-points))
               (go (method-of-object this die))
               )
           )
         )
       )
     )
    (else
      ((method-of-type enemy event-handler) this arg0 arg1 arg2 arg3)
      )
    )
  )

;; definition for method 75 of type sew-fan
(defmethod go-stare ((this sew-fan))
  (go (method-of-object this idle))
  )

;; definition for method 76 of type sew-fan
(defmethod go-stare2 ((this sew-fan))
  (go (method-of-object this idle))
  )

;; definition for function sew-fan-joint-fan
;; WARN: Return type mismatch int vs none.
(defun sew-fan-joint-fan ((arg0 cspace) (arg1 transformq))
  (let ((v1-0 (the-as sew-fan (-> arg0 param1))))
    (set! (-> v1-0 fan-rot)
          (the float (sar (shl (the int (+ (-> v1-0 fan-rot) (* (-> v1-0 fan-rot-vel) (seconds-per-frame)))) 48) 48))
          )
    (quaternion-rotate-local-z! (-> arg1 quat) (-> arg1 quat) (-> v1-0 fan-rot))
    )
  (cspace<-parented-transformq-joint! arg0 arg1)
  0
  (none)
  )

;; definition for function sew-fan-joint-floor
;; WARN: Return type mismatch int vs none.
(defun sew-fan-joint-floor ((arg0 cspace) (arg1 transformq))
  (let ((s1-0 (-> arg0 param1)))
    (quaternion-rotate-local-y!
      (-> arg1 quat)
      (-> arg1 quat)
      (- (quaternion-y-angle (-> (the-as sew-fan s1-0) base-quat))
         (quaternion-y-angle (-> (the-as sew-fan s1-0) root quat))
         )
      )
    )
  (cspace<-parented-transformq-joint! arg0 arg1)
  0
  (none)
  )

;; definition for method 67 of type sew-fan
(defmethod coin-flip? ((this sew-fan))
  #f
  )

;; definition for method 103 of type sew-fan
;; INFO: Used lq/sq
(defmethod enemy-method-103 ((this sew-fan) (arg0 vector) (arg1 float))
  (let ((s4-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this base-quat)))
        (s5-0 (new 'stack-no-clear 'vector))
        )
    (set! (-> s5-0 quad) (-> arg0 quad))
    (set! (-> s4-0 y) 0.0)
    (vector-normalize! s4-0 1.0)
    (set! (-> s5-0 y) 0.0)
    (vector-normalize! s5-0 1.0)
    (>= (vector-dot s4-0 s5-0) (cos arg1))
    )
  )

;; definition for method 107 of type sew-fan
(defmethod is-pfoc-in-mesh? ((this sew-fan) (arg0 process-focusable) (arg1 vector))
  (local-vars (v0-0 symbol))
  (cond
    ((= (-> this activate-distance) 0.0)
     (return #t)
     v0-0
     )
    (else
      (let* ((s5-1 (vector-! (new 'stack-no-clear 'vector) (get-trans arg0 3) (-> this root trans)))
             (f0-2 (vector-dot s5-1 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this base-quat))))
             )
        (when (and (< 0.0 f0-2) (< f0-2 (-> this activate-distance)))
          (if (and *target* (focus-test? *target* edge-grab))
              (return #f)
              )
          (return (enemy-method-103 this s5-1 5461.3335))
          v0-0
          )
        )
      )
    )
  )

;; definition for method 120 of type sew-fan
;; WARN: Return type mismatch int vs none.
(defmethod init-enemy-collision! ((this sew-fan))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec enemy))
      (set! (-> s4-0 prim-core action) (collide-action solid no-standon))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 4096.0 0.0 16384.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-12 prim-core action) (collide-action solid no-standon))
      (set! (-> v1-12 transform-index) 3)
      (set-vector! (-> v1-12 local-sphere) 0.0 10240.0 0.0 9216.0)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-14 prim-core action) (collide-action solid no-standon))
      (set! (-> v1-14 transform-index) 3)
      (set-vector! (-> v1-14 local-sphere) 0.0 0.0 0.0 11673.6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-17 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-17 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-17 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; definition for method 7 of type sew-fan
;; WARN: Return type mismatch enemy vs sew-fan.
(defmethod relocate ((this sew-fan) (offset int))
  (if (nonzero? (-> this hostile-part))
      (&+! (-> this hostile-part) offset)
      )
  (if (nonzero? (-> this gust-part))
      (&+! (-> this gust-part) offset)
      )
  (the-as sew-fan ((method-of-type enemy relocate) this offset))
  )

;; definition for method 10 of type sew-fan
(defmethod deactivate ((this sew-fan))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (nonzero? (-> this sound-fan-loop-id))
      (sound-stop (-> this sound-fan-loop-id))
      )
  (if (nonzero? (-> this hostile-part))
      (kill-particles (-> this hostile-part))
      )
  (if (nonzero? (-> this gust-part))
      (kill-particles (-> this gust-part))
      )
  ((method-of-type enemy deactivate) this)
  (none)
  )

;; definition for method 121 of type sew-fan
;; WARN: Return type mismatch sound-id vs none.
(defmethod init-enemy! ((this sew-fan))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-fan" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (init-enemy-defaults! this *sew-fan-enemy-info*)
  (set! (-> this activate-distance) (res-lump-float (-> this entity) 'distance :default 122880.0))
  (set! (-> this path) (new 'process 'path-control this 'path 0.0 (-> this entity) #f))
  (when (logtest? (-> this path flags) (path-control-flag not-found))
    (set! (-> this path) (the-as path-control 0))
    0
    )
  (when (nonzero? (-> this path))
    (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
    (set! (-> this path-pos) (path-control-method-23 (-> this path) (-> this root trans)))
    (get-point-at-percent-along-path! (-> this path) (-> this root trans) (-> this path-pos) 'interp)
    )
  (set! (-> this travel-dir) 1)
  (let ((v1-26 (-> this skel root-channel 0)))
    (set! (-> v1-26 frame-group) (if (> (-> this skel active-channels) 0)
                                     (-> this skel root-channel 0 frame-group)
                                     )
          )
    )
  (ja-post)
  (quaternion-copy! (-> this float-quat) (-> this root quat))
  (matrix->quat (-> this node-list data 4 bone transform) (-> this base-quat))
  (let ((a0-16 (-> this node-list data 4)))
    (set! (-> a0-16 param0) sew-fan-joint-floor)
    (set! (-> a0-16 param1) this)
    (set! (-> a0-16 param2) (the-as basic 0))
    )
  (quaternion-rotate-local-y! (-> this dest-quat) (-> this base-quat) 8192.0)
  (set! (-> this sweep-dir) 1)
  (let ((a0-18 (-> this node-list data 5)))
    (set! (-> a0-18 param0) sew-fan-joint-fan)
    (set! (-> a0-18 param1) this)
    (set! (-> a0-18 param2) (the-as basic 0))
    )
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 1478) this))
  (set! (-> this hostile-part) (create-launch-control (-> *part-group-id-table* 1479) this))
  (set! (-> this gust-part) (create-launch-control (-> *part-group-id-table* 1501) this))
  (set! (-> this base-trans-y) (-> this root trans y))
  (set! (-> this root trans y) (+ (-> this base-trans-y) (* 614.4 (sin (the float (* 30 (current-time)))))))
  (set! (-> this sound-fan-loop-id) (new-sound-id))
  (none)
  )

;; definition for method 11 of type sew-fan
(defmethod init-from-entity! ((this sew-fan) (arg0 entity-actor))
  (stack-size-set! (-> this main-thread) 512)
  ((method-of-type enemy init-from-entity!) this arg0)
  )

;; definition for method 122 of type sew-fan
(defmethod go-idle2 ((this sew-fan))
  (go (method-of-object this idle))
  )

;; definition of type sew-elevator
(deftype sew-elevator (process-drawable)
  ()
  (:state-methods
    idle
    )
  (:methods
    (init-collision! (_type_) none)
    )
  )

;; definition for method 3 of type sew-elevator
(defmethod inspect ((this sew-elevator))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-elevator sew-elevator sew-elevator-lod0-jg sew-elevator-idle-ja
              ((sew-elevator-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 6 10)
              :origin-joint-index 3
              )

;; failed to figure out what this is:
(defstate idle (sew-elevator)
  :virtual #t
  :code (behavior ()
    (ja :group! (ja-group) :num! min)
    (transform-and-sleep)
    )
  )

;; definition for method 21 of type sew-elevator
;; WARN: Return type mismatch collide-shape-moving vs none.
(defmethod init-collision! ((this sew-elevator))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 1) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 2))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 24576.0 40960.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-15 prim-core action) (collide-action solid rideable))
      (set! (-> v1-15 transform-index) 3)
      (set-vector! (-> v1-15 local-sphere) 0.0 0.0 24576.0 40960.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-18 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-18 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-18 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (none)
  )

;; definition for method 11 of type sew-elevator
(defmethod init-from-entity! ((this sew-elevator) (arg0 entity-actor))
  (init-collision! this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-elevator" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (go (method-of-object this idle))
  )

;; definition of type sew-gate
(deftype sew-gate (process-drawable)
  ((play-time      time-frame)
   (sound-played1  symbol)
   (sound-played2  symbol)
   )
  (:state-methods
    idle
    open
    opened
    )
  )

;; definition for method 3 of type sew-gate
(defmethod inspect ((this sew-gate))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tplay-time: ~D~%" (-> this play-time))
  (format #t "~2Tsound-played1: ~A~%" (-> this sound-played1))
  (format #t "~2Tsound-played2: ~A~%" (-> this sound-played2))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-gate sew-gate sew-gate-lod0-jg sew-gate-idle-ja
              ((sew-gate-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 7 0 8)
              )

;; failed to figure out what this is:
(defstate idle (sew-gate)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('open)
       (go-virtual open)
       )
      )
    )
  :code sleep-code
  :post transform-post
  )

;; failed to figure out what this is:
(defstate open (sew-gate)
  :virtual #t
  :code (behavior ()
    (set-time! (-> self play-time))
    (set! (-> self sound-played1) #f)
    (set! (-> self sound-played2) #f)
    (ja-no-eval :group! sew-gate-open-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (when (and (not (-> self sound-played1)) (time-elapsed? (-> self play-time) (seconds 0.015)))
        (sound-play "sew-gate-open")
        (set! (-> self sound-played1) #t)
        )
      (when (and (not (-> self sound-played2)) (time-elapsed? (-> self play-time) (seconds 1.8)))
        (sound-play "sew-gate-hit")
        (set! (-> self sound-played2) #t)
        )
      (suspend)
      (ja :num! (seek!))
      )
    (go-virtual opened)
    )
  :post transform-post
  )

;; failed to figure out what this is:
(defstate opened (sew-gate)
  :virtual #t
  :enter (behavior ()
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (ja :group! sew-gate-open-ja :num! (identity (the float (ja-num-frames 0))))
    (transform-post)
    )
  :code sleep-code
  :post #f
  )

;; definition for method 11 of type sew-gate
(defmethod init-from-entity! ((this sew-gate) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 28672.0 0.0 32768.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-9 prim-core action) (collide-action solid))
      (set! (-> v1-9 transform-index) 3)
      (set-vector! (-> v1-9 local-sphere) 0.0 28672.0 0.0 32768.0)
      )
    (let ((v1-11 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-11 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-11 prim-core action) (collide-action solid))
      (set! (-> v1-11 transform-index) 4)
      (set-vector! (-> v1-11 local-sphere) 0.0 -28672.0 0.0 32768.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-14 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-14 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-14 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-gate" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (if (and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete)))
      (go (method-of-object this opened))
      (go (method-of-object this idle))
      )
  )

;; definition of type sew-wall-switch
(deftype sew-wall-switch (process-drawable)
  ((actor-group        (pointer actor-group))
   (actor-group-count  int32)
   (minimap            connection-minimap)
   )
  (:state-methods
    idle
    open
    opened
    )
  )

;; definition for method 3 of type sew-wall-switch
(defmethod inspect ((this sew-wall-switch))
  (when (not this)
    (set! this this)
    (goto cfg-7)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tactor-group: #x~X~%" (-> this actor-group))
  (dotimes (s5-0 (-> this actor-group-count))
    (format #t "~T  [~D]~2Tactor-group: ~`actor-group`P~%" s5-0 (-> this actor-group s5-0))
    )
  (format #t "~2Tactor-group-count: ~D~%" (-> this actor-group-count))
  (format #t "~2Tminimap: #<connection-minimap @ #x~X>~%" (-> this minimap))
  (label cfg-7)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-wall-switch sew-wall-switch sew-wall-switch-lod0-jg sew-wall-switch-idle-ja
              ((sew-wall-switch-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 1)
              )

;; failed to figure out what this is:
(defstate idle (sew-wall-switch)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (case (-> (the-as attack-info (-> block param 1)) mode)
         (('spin 'punch)
          (sound-play "wall-btn-switch")
          (go-virtual open)
          )
         )
       )
      )
    )
  :enter (behavior ()
    (setup-masks (-> self draw) 4 2)
    )
  :trans (behavior ()
    (launch-particles (-> *part-id-table* 4872) (-> self root trans))
    )
  :code sleep-code
  :post ja-post
  )

;; failed to figure out what this is:
(defstate open (sew-wall-switch)
  :virtual #t
  :enter (behavior ()
    (setup-masks (-> self draw) 2 4)
    (logclear! (-> self mask) (process-mask actor-pause))
    (let ((gp-0 (-> self actor-group 0)))
      (dotimes (s5-0 (-> gp-0 length))
        (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-1 from) (process->ppointer self))
          (set! (-> a1-1 num-params) 0)
          (set! (-> a1-1 message) 'open)
          (let ((t9-1 send-event-function)
                (v1-9 (-> gp-0 data s5-0 actor))
                )
            (t9-1
              (if v1-9
                  (-> v1-9 extra process)
                  )
              a1-1
              )
            )
          )
        )
      )
    )
  :trans (behavior ()
    (launch-particles (-> *part-id-table* 4873) (-> self root trans))
    )
  :code (behavior ()
    (ja-no-eval :group! sew-wall-switch-push-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (let ((v1-25 (res-lump-value (-> self entity) 'extra-id uint128 :time -1000000000.0)))
      (when (= (the-as uint v1-25) 1)
        (let ((gp-0 (current-time)))
          (until (time-elapsed? gp-0 (seconds 0.5))
            (suspend)
            )
          )
        (set-setting! 'mode-name 'cam-fixed 0.0 0)
        (set-setting! 'interp-time 'abs 0.0 0)
        (set-setting! 'entity-name "camera-300" 0.0 0)
        (process-grab? *target* #f)
        (let ((gp-1 (current-time)))
          (until (time-elapsed? gp-1 (seconds 1))
            (suspend)
            )
          )
        (let ((gp-2 (-> self actor-group 1)))
          (dotimes (s5-0 (-> gp-2 length))
            (let ((a1-7 (new 'stack-no-clear 'event-message-block)))
              (set! (-> a1-7 from) (process->ppointer self))
              (set! (-> a1-7 num-params) 0)
              (set! (-> a1-7 message) 'cue-chase)
              (let ((t9-8 send-event-function)
                    (v1-47 (-> gp-2 data s5-0 actor))
                    )
                (t9-8
                  (if v1-47
                      (-> v1-47 extra process)
                      )
                  a1-7
                  )
                )
              )
            )
          )
        (let ((gp-3 (current-time)))
          (until (time-elapsed? gp-3 (seconds 2))
            (suspend)
            )
          )
        (remove-setting! 'mode-name)
        (remove-setting! 'interp-time)
        (remove-setting! 'entity-name)
        (let ((gp-4 (current-time)))
          (until (time-elapsed? gp-4 (seconds 0.5))
            (suspend)
            )
          )
        (process-release? *target*)
        (go-virtual opened)
        )
      )
    )
  :post ja-post
  )

;; failed to figure out what this is:
(defstate opened (sew-wall-switch)
  :virtual #t
  :enter (behavior ()
    (if (nonzero? (-> self minimap))
        (kill-callback (-> *minimap* engine) (-> self minimap))
        )
    (setup-masks (-> self draw) 2 4)
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (let ((gp-0 (-> self actor-group 0)))
      (dotimes (s5-0 (-> gp-0 length))
        (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-3 from) (process->ppointer self))
          (set! (-> a1-3 num-params) 0)
          (set! (-> a1-3 message) 'open)
          (let ((t9-3 send-event-function)
                (v1-12 (-> gp-0 data s5-0 actor))
                )
            (t9-3
              (if v1-12
                  (-> v1-12 extra process)
                  )
              a1-3
              )
            )
          )
        )
      )
    )
  :code sleep-code
  :post ja-post
  )

;; definition for method 11 of type sew-wall-switch
;; INFO: Used lq/sq
(defmethod init-from-entity! ((this sew-wall-switch) (arg0 entity-actor))
  (local-vars (sv-16 res-tag))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 4)
      (set-vector! (-> v1-2 local-sphere) 0.0 0.0 0.0 3072.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-wall-switch" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! sv-16 (new 'static 'res-tag))
  (set! (-> this actor-group)
        (res-lump-data (-> this entity) 'actor-groups (pointer actor-group) :tag-ptr (& sv-16))
        )
  (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
  (cond
    ((and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete)))
     (go (method-of-object this opened))
     )
    (else
      (set! (-> this minimap) (add-icon! *minimap* this (the-as uint 13) (the-as int #f) (the-as vector #t) 0))
      (go (method-of-object this idle))
      )
    )
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-fence-gate sew-fence-gate sew-fence-gate-lod0-jg sew-fence-gate-idle-ja
              ((sew-fence-gate-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15)
              )

;; definition of type sew-fence-gate
(deftype sew-fence-gate (process-drawable)
  ()
  (:state-methods
    closed
    open
    opening
    closing
    )
  )

;; definition for method 3 of type sew-fence-gate
(defmethod inspect ((this sew-fence-gate))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 11 of type sew-fence-gate
(defmethod init-from-entity! ((this sew-fence-gate) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 61440.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot enemy hit-by-others-list player-list projectile))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 0.0 0.0 0.0 61440.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with)
            (collide-spec jak bot enemy hit-by-others-list player-list projectile)
            )
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 5)
      (set-vector! (-> v1-10 local-sphere) 0.0 0.0 0.0 61440.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-fence-gate" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (process-entity-set! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (process-drawable-from-entity! this arg0)
  (let ((s4-2 (the-as object #f)))
    (let ((s5-1 (res-lump-struct (-> this entity) 'open-test structure)))
      (if s5-1
          (set! s4-2 (script-eval (the-as pair s5-1)))
          )
      )
    (if s4-2
        (go (method-of-object this open))
        (go (method-of-object this closed))
        )
    )
  )

;; failed to figure out what this is:
(defstate closed (sew-fence-gate)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (go-virtual opening)
       )
      (('trigger-perm)
       (process-entity-status! self (entity-perm-status subtask-complete) #t)
       (go-virtual opening)
       )
      )
    )
  :code sleep-code
  :post (behavior ()
    (transform-post)
    )
  )

;; failed to figure out what this is:
(defstate open (sew-fence-gate)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (go-virtual closing)
       )
      )
    )
  :enter (behavior ()
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    )
  :code (behavior ()
    (ja :group! sew-fence-gate-close-ja
        :num! (identity (the float (+ (-> (the-as art-joint-anim sew-fence-gate-close-ja) frames num-frames) -1)))
        )
    (sleep-code)
    )
  :post (behavior ()
    (transform-post)
    )
  )

;; failed to figure out what this is:
(defstate opening (sew-fence-gate)
  :virtual #t
  :code (behavior ()
    (set-time! (-> self state-time))
    (ja-channel-push! 1 0)
    (let ((gp-0 #f))
      (ja-no-eval :group! sew-fence-gate-close-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (when (and (not gp-0) (time-elapsed? (-> self state-time) (seconds 0.5)))
          (sound-play "sew-gate-open")
          (set! gp-0 #t)
          )
        (suspend)
        (ja :num! (seek!))
        )
      )
    (go-virtual open)
    )
  :post (behavior ()
    (transform-post)
    )
  )

;; failed to figure out what this is:
(defstate closing (sew-fence-gate)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (go-virtual closing)
       )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 0)
    (ja :group! sew-fence-gate-close-ja :num! (seek! 0.0) :frame-num max)
    (until (ja-done? 0)
      (ja :num! (seek! 0.0))
      (suspend)
      )
    (go-virtual closed)
    )
  :post (behavior ()
    (transform-post)
    )
  )

;; definition of type sew-vent
(deftype sew-vent (process-drawable)
  ((sync           sync-linear  :inline)
   (attack-id      int32)
   (last-sync-val  float)
   (vent-sound     sound-id)
   )
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type sew-vent
(defmethod inspect ((this sew-vent))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tsync: #<sync-linear @ #x~X>~%" (-> this sync))
  (format #t "~2Tattack-id: ~D~%" (-> this attack-id))
  (format #t "~2Tlast-sync-val: ~f~%" (-> this last-sync-val))
  (format #t "~2Tvent-sound: ~D~%" (-> this vent-sound))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defstate idle (sew-vent)
  :virtual #t
  :enter (behavior ()
    (set! (-> self last-sync-val) 1.0)
    )
  :trans (behavior ()
    (let ((f30-0 (get-norm! (-> self sync) 0)))
      (cond
        ((< f30-0 0.5)
         (if (zero? (-> self vent-sound))
             (set! (-> self vent-sound) (new-sound-id))
             )
         (sound-play "steam-vent" :id (-> self vent-sound) :position (-> self root trans))
         (spawn (-> self part) (-> self root trans))
         (when (< 0.5 (-> self last-sync-val))
           )
         (when (< (vector-vector-distance (target-pos 0) (-> self root trans)) 14336.0)
           (let* ((gp-1 *target*)
                  (a0-8 (if (type? gp-1 process-focusable)
                            gp-1
                            )
                        )
                  )
             (if a0-8
                 (send-event
                   a0-8
                   'attack
                   #f
                   (static-attack-info :mask (vehicle-impulse-factor) ((id (the-as uint (-> self attack-id)))
                                                                       (damage 2.0)
                                                                       (vehicle-damage-factor 1.0)
                                                                       (vehicle-impulse-factor 1.0)
                                                                       (shove-back (meters 3))
                                                                       (shove-up (meters 3))
                                                                       )
                                       )
                   )
                 )
             )
           )
         )
        (else
          (when (nonzero? (-> self vent-sound))
            (sound-stop (-> self vent-sound))
            (set! (-> self vent-sound) (new 'static 'sound-id))
            0
            )
          )
        )
      (set! (-> self last-sync-val) f30-0)
      )
    )
  :code sleep-code
  :post ja-post
  )

;; definition for method 10 of type sew-vent
(defmethod deactivate ((this sew-vent))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (when (nonzero? (-> this vent-sound))
    (sound-stop (-> this vent-sound))
    (set! (-> this vent-sound) (new 'static 'sound-id))
    0
    )
  (call-parent-method this)
  (none)
  )

;; definition for method 11 of type sew-vent
(defmethod init-from-entity! ((this sew-vent) (arg0 entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (let* ((v1-1 *game-info*)
         (a0-4 (+ (-> v1-1 attack-id) 1))
         )
    (set! (-> v1-1 attack-id) a0-4)
    (set! (-> this attack-id) (the-as int a0-4))
    )
  (let ((a1-3 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-2 0))
      (if #f
          (set! v1-2 (logior v1-2 1))
          )
      (set! (-> a1-3 sync-type) 'sync-linear)
      (set! (-> a1-3 sync-flags) (the-as sync-flags v1-2))
      )
    (set! (-> a1-3 entity) arg0)
    (set! (-> a1-3 period) (the-as uint 1800))
    (set! (-> a1-3 percent) 0.0)
    (initialize! (-> this sync) a1-3)
    )
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 1473) this))
  (go (method-of-object this idle))
  )

;; definition of type sew-power-switch
(deftype sew-power-switch (process-drawable)
  ()
  (:state-methods
    idle
    turned-off
    )
  )

;; definition for method 3 of type sew-power-switch
(defmethod inspect ((this sew-power-switch))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-power-switch sew-power-switch sew-power-switch-lod0-jg sew-power-switch-idle-ja
              ((sew-power-switch-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 2 0 4)
              )

;; failed to figure out what this is:
(defstate idle (sew-power-switch)
  :virtual #t
  :trans (behavior ()
    (when (and (and (-> self entity) (logtest? (-> self entity extra perm status) (entity-perm-status subtask-complete)))
               (not (movie?))
               )
      (logclear! (-> self mask) (process-mask actor-pause))
      (go-virtual turned-off)
      )
    )
  :code (behavior ()
    (ja :group! (ja-group) :num! min)
    (ja-post)
    (sleep-code)
    )
  )

;; failed to figure out what this is:
(defstate turned-off (sew-power-switch)
  :virtual #t
  :code (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    (ja :group! sew-power-switch-off-ja :num! min)
    (ja-post)
    (when (task-node-open? (game-task-node sewer-hum-kg-switch-off))
      (set-setting! 'exclusive-load '((ignore all) (allow sewa) (allow sewe)) 0.0 0)
      (let ((a1-2 (new 'stack-no-clear 'array 'symbol 10)))
        (set! (-> a1-2 9) #f)
        (set! (-> a1-2 8) #f)
        (set! (-> a1-2 7) #f)
        (set! (-> a1-2 6) #f)
        (set! (-> a1-2 5) #f)
        (set! (-> a1-2 4) #f)
        (set! (-> a1-2 3) #f)
        (set! (-> a1-2 2) 'sewe)
        (set! (-> a1-2 1) 'ctyinda)
        (set! (-> a1-2 0) 'sewa)
        (want-levels *load-state* a1-2)
        )
      (want-display-level *load-state* 'ctyinda 'display)
      (while (!= (status-of-level-and-borrows *level* 'ctyinda #f) 'active)
        (suspend)
        )
      (let ((gp-2 (add-process *gui-control* self (gui-channel background) (gui-action queue) "pwrdown" -99.0 0)))
        (set-setting! 'interp-time 'abs 0.0 0)
        (set-setting! 'entity-name "camera-224" 0.0 0)
        (set-setting! 'allow-progress #f 0.0 0)
        (process-grab? *target* #f)
        (let ((s5-0 (current-time)))
          (until (time-elapsed? s5-0 (seconds 2))
            (suspend)
            )
          )
        (task-node-close! (game-task-node sewer-hum-kg-switch-off) 'event)
        (script-eval '(send-event "ctyinda-vingate-1" 'shutdown))
        (set-action!
          *gui-control*
          (gui-action play)
          gp-2
          (gui-channel none)
          (gui-action none)
          (the-as string #f)
          (the-as (function gui-connection symbol) #f)
          (the-as process #f)
          )
        )
      (let ((gp-3 (current-time)))
        (until (time-elapsed? gp-3 (seconds 2.4))
          (suspend)
          )
        )
      (set-setting! 'string-startup-vector 'abs (new 'static 'vector :x 1.0) 0)
      (remove-setting! 'entity-name)
      (set! (-> *ACTOR-bank* birth-max) 1000)
      (suspend)
      (remove-setting! 'exclusive-load)
      (remove-setting! 'interp-time)
      (remove-setting! 'allow-progress)
      (process-release? *target*)
      (set-continue! *game-info* "sewe-switch-off" #f)
      (talker-spawn-func (-> *talker-speech* 62) *entity-pool* (target-pos 0) (the-as region #f))
      (script-eval '(auto-save 'auto-save))
      )
    (remove-setting! 'allow-logo)
    (logior! (-> self mask) (process-mask actor-pause))
    (sleep-code)
    )
  )

;; definition for method 11 of type sew-power-switch
(defmethod init-from-entity! ((this sew-power-switch) (arg0 entity-actor))
  (stack-size-set! (-> this main-thread) 512)
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-power-switch" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set-setting! 'allow-logo #f 0.0 0)
  (if (or (task-node-closed? (game-task-node sewer-hum-kg-switch-off))
          (and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete)))
          )
      (go (method-of-object this turned-off))
      (go (method-of-object this idle))
      )
  )

;; definition of type sew-gas-step
(deftype sew-gas-step (base-plat)
  ((sound-id       sound-id)
   (sync           sync-linear  :inline)
   (last-sync-val  float)
   (gas-time       time-frame)
   (attack-id      int32)
   )
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type sew-gas-step
(defmethod inspect ((this sew-gas-step))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type base-plat inspect)))
    (t9-0 this)
    )
  (format #t "~2Tsound-id: ~D~%" (-> this sound-id))
  (format #t "~2Tsync: #<sync-linear @ #x~X>~%" (-> this sync))
  (format #t "~2Tlast-sync-val: ~f~%" (-> this last-sync-val))
  (format #t "~2Tgas-time: ~D~%" (-> this gas-time))
  (format #t "~2Tattack-id: ~D~%" (-> this attack-id))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-gas-step sew-gas-step sew-gas-step-lod0-jg sew-gas-step-idle-ja
              ((sew-gas-step-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

;; definition for method 11 of type sew-gas-step
(defmethod init-from-entity! ((this sew-gas-step) (arg0 entity-actor))
  (init-collision! this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-gas-step" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (let ((a0-5 (-> this skel root-channel 0)))
    (set! (-> a0-5 frame-group) (if (> (-> this skel active-channels) 0)
                                    (-> this skel root-channel 0 frame-group)
                                    )
          )
    (set! (-> a0-5 param 0) 1.0)
    (set! (-> a0-5 frame-num) 0.0)
    (joint-control-channel-group!
      a0-5
      (if (> (-> this skel active-channels) 0)
          (-> this skel root-channel 0 frame-group)
          )
      num-func-loop!
      )
    )
  (ja-post)
  (let* ((v1-18 *game-info*)
         (a0-7 (+ (-> v1-18 attack-id) 1))
         )
    (set! (-> v1-18 attack-id) a0-7)
    (set! (-> this attack-id) (the-as int a0-7))
    )
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 1473) this))
  (set! (-> this gas-time) (the-as time-frame (the int (* 300.0 (res-lump-float arg0 'delay :default 1.0)))))
  (let ((a1-7 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-25 0))
      (if #f
          (set! v1-25 (logior v1-25 1))
          )
      (set! (-> a1-7 sync-type) 'sync-linear)
      (set! (-> a1-7 sync-flags) (the-as sync-flags v1-25))
      )
    (set! (-> a1-7 entity) arg0)
    (set! (-> a1-7 period) (the-as uint 1800))
    (set! (-> a1-7 percent) 0.0)
    (initialize! (-> this sync) a1-7)
    )
  (go (method-of-object this idle))
  )

;; failed to figure out what this is:
(defstate idle (sew-gas-step)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object) eco-door-event-handler)
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (set! (-> self last-sync-val) (get-norm! (-> self sync) 0))
    (sound-play "steam-vent" :id (-> self sound-id) :position (-> self root trans))
    )
  :code (behavior ()
    (ja-channel-push! 1 0)
    (ja-no-eval :group! sew-gas-step-rattle-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (set-time! (-> self state-time))
    (loop
      (spawn
        (-> self part)
        (vector<-cspace! (new 'stack-no-clear 'vector) (joint-node sew-gas-step-lod0-jg poison_gas))
        )
      (let ((f0-7 (vector-vector-xz-distance-squared (target-pos 0) (-> self root trans)))
            (f1-0 14336.0)
            )
        (when (< f0-7 (* f1-0 f1-0))
          (let* ((gp-2 *target*)
                 (a0-9 (if (type? gp-2 process-focusable)
                           gp-2
                           )
                       )
                 )
            (if a0-9
                (send-event
                  a0-9
                  'attack
                  #f
                  (static-attack-info :mask (vehicle-impulse-factor) ((id (the-as uint (-> self attack-id)))
                                                                      (damage 2.0)
                                                                      (vehicle-damage-factor 1.0)
                                                                      (vehicle-impulse-factor 1.0)
                                                                      (shove-back (meters 3))
                                                                      (shove-up (meters 3))
                                                                      )
                                      )
                  )
                )
            )
          )
        )
      (suspend)
      )
    )
  :post plat-post
  )

;; definition for method 32 of type sew-gas-step
;; WARN: Return type mismatch int vs none.
(defmethod init-collision! ((this sew-gas-step))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 18432.0 0.0 24576.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid semi-solid rideable pull-rider-can-collide))
      (set! (-> v1-10 transform-index) 0)
      (set-vector! (-> v1-10 local-sphere) 0.0 18432.0 0.0 24576.0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-12 prim-core action) (collide-action solid semi-solid rideable pull-rider-can-collide))
      (set! (-> v1-12 transform-index) 0)
      (set-vector! (-> v1-12 local-sphere) 0.0 18432.0 0.0 24576.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-15 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-15 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-15 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (set! (-> this sound-id) (new-sound-id))
  0
  (none)
  )

;; definition for method 10 of type sew-gas-step
(defmethod deactivate ((this sew-gas-step))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (nonzero? (-> this sound-id))
      (sound-stop (-> this sound-id))
      )
  (call-parent-method this)
  (none)
  )
