;;-*-Lisp-*-
(in-package goal)

;; definition of type ashelin-anim-info
(deftype ashelin-anim-info (structure)
  ((anim-index  int32)
   )
  :pack-me
  )

;; definition for method 3 of type ashelin-anim-info
(defmethod inspect ((this ashelin-anim-info))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'ashelin-anim-info)
  (format #t "~1Tanim-index: ~D~%" (-> this anim-index))
  (label cfg-4)
  this
  )

;; definition of type ashelin-global-info
(deftype ashelin-global-info (basic)
  ((prev-blue-hit       int8)
   (blue-hit-anim       ashelin-anim-info  6 :inline)
   (blue-hit-land-anim  ashelin-anim-info  6 :inline)
   )
  )

;; definition for method 3 of type ashelin-global-info
(defmethod inspect ((this ashelin-global-info))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this (-> this type))
  (format #t "~1Tprev-blue-hit: ~D~%" (-> this prev-blue-hit))
  (format #t "~1Tblue-hit-anim[6] @ #x~X~%" (-> this blue-hit-anim))
  (format #t "~1Tblue-hit-land-anim[6] @ #x~X~%" (-> this blue-hit-land-anim))
  (label cfg-4)
  this
  )

;; definition for symbol *ashelin-global-info*, type ashelin-global-info
(define *ashelin-global-info* (new 'static 'ashelin-global-info
                                :blue-hit-anim (new 'static 'inline-array ashelin-anim-info 6
                                  (new 'static 'ashelin-anim-info :anim-index 13)
                                  (new 'static 'ashelin-anim-info :anim-index 14)
                                  (new 'static 'ashelin-anim-info :anim-index 15)
                                  (new 'static 'ashelin-anim-info :anim-index 19)
                                  (new 'static 'ashelin-anim-info :anim-index 20)
                                  (new 'static 'ashelin-anim-info :anim-index 21)
                                  )
                                :blue-hit-land-anim (new 'static 'inline-array ashelin-anim-info 6
                                  (new 'static 'ashelin-anim-info :anim-index 16)
                                  (new 'static 'ashelin-anim-info :anim-index 17)
                                  (new 'static 'ashelin-anim-info :anim-index 18)
                                  (new 'static 'ashelin-anim-info :anim-index 22)
                                  (new 'static 'ashelin-anim-info :anim-index 23)
                                  (new 'static 'ashelin-anim-info :anim-index 24)
                                  )
                                )
        )

;; definition for symbol *ashelin-nav-enemy-info*, type nav-enemy-info
(define *ashelin-nav-enemy-info*
  (new 'static 'nav-enemy-info
    :use-die-falling #t
    :use-victory #f
    :use-jump-blocked #t
    :debug-draw-neck #f
    :jump-debug-draw #f
    :move-to-ground #t
    :hover-if-no-ground #f
    :idle-anim-script (new 'static 'inline-array idle-control-frame 2
      (new 'static 'idle-control-frame
        :command (idle-control-cmd play)
        :anim #x3
        :param0 1
        :param1 1
        :param2 '((new 'static 'bfloat :data 1.0) (new 'static 'bfloat :data 1.0))
        )
      (new 'static 'idle-control-frame)
      )
    :idle-anim 3
    :notice-anim 3
    :hostile-anim -1
    :hit-anim 3
    :knocked-anim 10
    :knocked-land-anim 11
    :die-anim 26
    :die-falling-anim 26
    :victory-anim -1
    :jump-wind-up-anim 3
    :jump-in-air-anim 3
    :jump-land-anim 3
    :neck-joint 5
    :look-at-joint 6
    :bullseye-joint 4
    :notice-distance (meters 40)
    :notice-distance-delta (meters 10)
    :proximity-notice-distance (meters 20)
    :default-hit-points 10.0
    :gnd-collide-with (collide-spec backgnd)
    :overlaps-others-collide-with-filter (collide-spec jak civilian enemy vehicle-sphere hit-by-others-list player-list)
    :penetrate-knocked (penetrate
      touch
      generic-attack
      lunge
      flop
      punch
      spin
      roll
      uppercut
      bonk
      tube
      vehicle
      flut-attack
      board
      mech
      mech-punch
      mech-bonk
      dark-skin
      dark-punch
      dark-bomb
      dark-smack
      flut
      shield
      explode
      jak-yellow-shot
      jak-red-shot
      jak-blue-shot
      jak-dark-shot
      enemy-yellow-shot
      enemy-dark-shot
      eco-yellow
      eco-red
      eco-blue
      eco-green
      knocked
      jak-red-shockwave
      jak-dark-nuke
      jak-dark-blackhole
      emp-blast
      penetrate38
      penetrate39
      penetrate40
      penetrate41
      penetrate42
      penetrate43
      penetrate44
      penetrate45
      penetrate46
      penetrate47
      penetrate48
      penetrate49
      penetrate50
      penetrate51
      penetrate52
      penetrate53
      penetrate54
      penetrate55
      penetrate56
      penetrate57
      penetrate58
      penetrate59
      penetrate60
      penetrate61
      penetrate64
      penetrate63
      )
    :movement-gravity (meters -100)
    :friction 0.7
    :attack-shove-back (meters 3)
    :attack-shove-up (meters 2)
    :attack-mode 'generic
    :attack-damage 2
    :recover-gnd-collide-with (collide-spec backgnd crate obstacle hit-by-others-list pusher)
    :knocked-can-land-timeout (seconds 0.1)
    :knocked-recover-timeout (seconds 2)
    :ragdoll-blend-out-time (seconds 0.25)
    :ragdoll-rotate-velocity-mult 1.0
    :jump-height-min (meters 3)
    :jump-height-factor 0.5
    :knocked-seek-ry-clamp 2730.6667
    :knocked-soft-vxz-lo 57344.0
    :knocked-soft-vxz-hi 57344.0
    :knocked-soft-vy-lo 81920.0
    :knocked-soft-vy-hi 81920.0
    :knocked-medium-vxz-lo 57344.0
    :knocked-medium-vxz-hi 57344.0
    :knocked-medium-vy-lo 81920.0
    :knocked-medium-vy-hi 81920.0
    :knocked-hard-vxz-lo 57344.0
    :knocked-hard-vxz-hi 57344.0
    :knocked-hard-vy-lo 81920.0
    :knocked-hard-vy-hi 81920.0
    :knocked-huge-vxz-lo 164659.2
    :knocked-huge-vxz-hi 249036.8
    :knocked-huge-vy-lo 183500.8
    :knocked-huge-vy-hi 217907.2
    :knocked-yellow-vxz-lo 57344.0
    :knocked-yellow-vxz-hi 57344.0
    :knocked-yellow-vy-lo 81920.0
    :knocked-yellow-vy-hi 81920.0
    :knocked-red-vxz-lo 57344.0
    :knocked-red-vxz-hi 57344.0
    :knocked-red-vy-lo 81920.0
    :knocked-red-vy-hi 81920.0
    :knocked-blue-vxz-lo 40960.0
    :knocked-blue-vxz-hi 49152.0
    :knocked-blue-vy-lo 24576.0
    :knocked-blue-vy-hi 40960.0
    :ragdoll-info #f
    :shadow-size (meters 2)
    :shadow-max-y (meters 1)
    :shadow-min-y (meters -1)
    :shadow-locus-dist (meters 150)
    :gem-joint -1
    :gem-offset (new 'static 'sphere :r 163840.0)
    :knocked-off #t
    :callback-info #f
    :use-momentum #t
    :use-frustration #t
    :use-stop-chase #f
    :use-circling #f
    :use-pacing #f
    :walk-anim 4
    :turn-anim -1
    :run-anim 6
    :taunt-anim -1
    :run-travel-speed (meters 10)
    :run-acceleration (meters 25)
    :run-turning-acceleration (meters 12)
    :walk-travel-speed (meters 3)
    :walk-acceleration (meters 5)
    :walk-turning-acceleration (meters 6)
    :maximum-rotation-rate (degrees 360)
    :notice-nav-radius (meters 20)
    :frustration-distance (meters 8)
    :frustration-time (seconds 4)
    :blocked-time (seconds 0.3)
    :circle-dist-lo 20480.0
    :circle-dist-hi 61440.0
    :nav-mesh #f
    )
  )

;; failed to figure out what this is:
(set! (-> *ashelin-nav-enemy-info* fact-defaults) *fact-info-enemy-defaults*)

;; definition for method 66 of type ashelin
(defmethod get-penetrated-by ((this ashelin))
  (let* ((t9-0 (method-of-type bot get-penetrated-by))
         (v0-0 (t9-0 this))
         )
    (if (logtest? (bot-flag bf22) (-> this bot-flags))
        (set! v0-0 (logior (penetrate jak-yellow-shot) v0-0))
        )
    v0-0
    )
  )

;; definition for method 261 of type ashelin
(defmethod ashelin-method-261 ((this ashelin) (arg0 symbol))
  (if arg0
      (logior! (-> this bot-flags) (bot-flag bf22))
      (logclear! (-> this bot-flags) (bot-flag bf22))
      )
  (let ((v0-0 (get-penetrated-by this)))
    (set! (-> this root penetrated-by) v0-0)
    v0-0
    )
  )

;; definition for method 205 of type ashelin
(defmethod bot-method-205 ((this ashelin))
  (let* ((t9-0 (method-of-type bot bot-method-205))
         (v0-0 (t9-0 this))
         )
    (when (and (not v0-0) (logtest? (penetrate jak-yellow-shot) (-> this incoming penetrate-using)))
      (if (logtest? (bot-flag bf22) (-> this bot-flags))
          (set! v0-0 #t)
          )
      (logior! (-> this bot-flags) (bot-flag bf21))
      )
    v0-0
    )
  )

;; definition for method 112 of type ashelin
;; WARN: Return type mismatch int vs none.
(defmethod get-incoming-attack! ((this ashelin)
                                (arg0 process-drawable)
                                (arg1 event-message-block)
                                (arg2 penetrate)
                                (arg3 attack-info)
                                (arg4 touching-shapes-entry)
                                )
  (let ((t9-0 (method-of-type bot get-incoming-attack!)))
    (t9-0 this arg0 arg1 arg2 arg3 arg4)
    )
  (if (!= (-> this incoming knocked-type) (knocked-type blue-shot))
      (set! (-> this incoming knocked-type) (knocked-type mech-punch))
      )
  (none)
  )

;; definition for method 110 of type ashelin
(defmethod send-attack ((this ashelin) (arg0 process) (arg1 touching-shapes-entry) (arg2 uint))
  (if (and (= (-> arg0 type) target)
           (-> this next-state)
           (let ((v1-4 (-> this next-state name)))
             (or (= v1-4 'back-spring) (= v1-4 'cartwheel-left) (= v1-4 'tumble-right))
             )
           )
      #f
      ((method-of-type bot send-attack) this arg0 arg1 arg2)
      )
  )

;; definition for method 106 of type ashelin
(defmethod find-best-focus ((this ashelin))
  (let* ((s5-0 (handle->process (-> this attacker-handle)))
         (v1-3 (if (type? s5-0 process-focusable)
                   s5-0
                   )
               )
         )
    (when v1-3
      (cond
        ((= (-> v1-3 type) target)
         (when (or (not (logtest? (-> this bot-flags) (bot-flag attacked)))
                   (time-elapsed? (-> this attacker-time) (seconds 5))
                   )
           (if (logtest? (-> this bot-flags) (bot-flag attacked))
               (bot-method-199 this)
               )
           (set! v1-3 (the-as process #f))
           (set! (-> this attacker-handle) (the-as handle #f))
           )
         )
        (else
          (when (time-elapsed? (-> this attacker-time) (seconds 2.5))
            (set! v1-3 (the-as process #f))
            (set! (-> this attacker-handle) (the-as handle #f))
            )
          )
        )
      )
    (let ((a0-21 (-> this focus-mode))
          (s5-1 (the-as process #f))
          )
      (cond
        ((zero? a0-21)
         (cond
           (v1-3
             (set! s5-1 v1-3)
             )
           ((begin (set! s5-1 (bot-method-201 this)) s5-1)
            (empty)
            )
           (else
             (let ((s4-0 (handle->process (-> this poi-handle))))
               (set! s5-1 (if (type? s4-0 process-focusable)
                              s4-0
                              )
                     )
               )
             (if s5-1
                 (empty)
                 (set! s5-1 *target*)
                 )
             )
           )
         )
        ((= a0-21 1)
         (cond
           (v1-3
             (set! s5-1 v1-3)
             )
           (else
             (let ((s4-1 (handle->process (-> this poi-handle))))
               (set! s5-1 (if (type? s4-1 process-focusable)
                              s4-1
                              )
                     )
               )
             (cond
               (s5-1
                 (empty)
                 )
               ((begin (set! s5-1 (bot-method-201 this)) s5-1)
                (empty)
                )
               (else
                 (set! s5-1 *target*)
                 )
               )
             )
           )
         )
        )
      (cond
        (s5-1
          (try-update-focus (-> this focus) (the-as process-focusable s5-1) this)
          (if (and (logtest? (-> this bot-flags) (bot-flag attacked)) (!= (-> s5-1 type) target))
              (logclear! (-> this bot-flags) (bot-flag attacked))
              )
          )
        (else
          (clear-focused (-> this focus))
          (logclear! (-> this bot-flags) (bot-flag attacked))
          )
        )
      s5-1
      )
    )
  )

;; definition for method 195 of type ashelin
;; WARN: Return type mismatch object vs symbol.
(defmethod alive? ((this ashelin))
  (let ((t9-0 (method-of-type bot alive?)))
    (the-as
      symbol
      (and (t9-0 this) (-> this next-state) (let ((v1-3 (-> this next-state name)))
                                              (or (= v1-3 'waiting-idle) (= v1-3 'hidden) (= v1-3 'traveling))
                                              )
           )
      )
    )
  )

;; definition for method 120 of type ashelin
;; WARN: Return type mismatch int vs none.
(defmethod init-enemy-collision! ((this ashelin))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-others))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 3) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 4))
      (set! (-> s4-0 prim-core collide-as) (collide-spec bot bot-targetable))
      (set! (-> s4-0 prim-core collide-with)
            (collide-spec backgnd jak crate civilian enemy obstacle vehicle-sphere hit-by-others-list player-list pusher)
            )
      (set! (-> s4-0 prim-core action) (collide-action solid can-ride deadly no-standon))
      (set-vector! (-> s4-0 local-sphere) 0.0 6144.0 0.0 8192.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec bot bot-targetable))
      (set! (-> v1-12 prim-core collide-with)
            (collide-spec backgnd jak crate civilian enemy obstacle vehicle-sphere hit-by-others-list player-list pusher)
            )
      (set! (-> v1-12 prim-core action) (collide-action solid can-ride deadly))
      (set-vector! (-> v1-12 local-sphere) 0.0 3276.8 0.0 3276.8)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec bot bot-targetable))
      (set! (-> v1-14 prim-core collide-with)
            (collide-spec backgnd jak crate civilian enemy obstacle vehicle-sphere hit-by-others-list player-list pusher)
            )
      (set! (-> v1-14 prim-core action) (collide-action solid deadly))
      (set-vector! (-> v1-14 local-sphere) 0.0 5324.8 0.0 3276.8)
      )
    (let ((v1-16 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-16 prim-core collide-as) (collide-spec bot bot-targetable))
      (set! (-> v1-16 prim-core collide-with)
            (collide-spec backgnd jak crate civilian enemy obstacle vehicle-sphere hit-by-others-list player-list pusher)
            )
      (set! (-> v1-16 prim-core action) (collide-action solid deadly no-standon))
      (set-vector! (-> v1-16 local-sphere) 0.0 7372.8 0.0 3276.8)
      )
    (set! (-> s5-0 nav-radius) 5120.0)
    (let ((v1-18 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-18 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-18 prim-core collide-with))
      )
    (set! (-> s5-0 max-iteration-count) (the-as uint 3))
    (set! (-> s5-0 event-priority) (the-as uint 7))
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; definition for method 121 of type ashelin
;; WARN: Return type mismatch int vs none.
(defmethod init-enemy! ((this ashelin))
  (init-fields! this)
  (set! (-> this channel) (gui-channel ashelin))
  (set! (-> this travel-anim-interp) 0.0)
  (set! (-> this focus-info max-los-dist) 204800.0)
  (logior! (-> this bot-flags) (bot-flag bf02))
  (set! (-> this hit-invuln-ignore-me-delay) (the-as uint 0))
  (set! (-> this hit-invuln-focus-disable-delay) (the-as uint 750))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-ashelin" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (init-enemy-defaults! this *ashelin-nav-enemy-info*)
  (let ((v1-12 (-> this neck)))
    (set! (-> v1-12 up) (the-as uint 1))
    (set! (-> v1-12 nose) (the-as uint 2))
    (set! (-> v1-12 ear) (the-as uint 0))
    (set-vector! (-> v1-12 twist-max) 11832.889 11832.889 0.0 1.0)
    (set! (-> v1-12 ignore-angle) 30947.555)
    )
  (let ((t9-4 (method-of-type bot init-enemy!)))
    (t9-4 this)
    )
  (set! (-> this my-simple-focus) (process-spawn simple-focus :name "simple-focus" :to this))
  0
  (none)
  )

;; definition for method 250 of type ashelin
;; WARN: disable def twice: 25. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod ashelin-method-250 ((this ashelin) (arg0 symbol) (arg1 symbol))
  (cond
    ((and (logtest? (-> this bot-flags) (bot-flag attacked)) (= (-> this focus-info fproc type) target))
     #t
     )
    (else
      (let ((f0-0 81920.0))
        (if arg1
            (set! f0-0 (+ 6144.0 f0-0))
            )
        (when (>= f0-0 (-> this focus-info bullseye-xz-dist))
          (let ((v1-9 (-> this focus-info los)))
            (if arg0
                (or (= v1-9 1) (= v1-9 4))
                (= v1-9 1)
                )
            )
          )
        )
      )
    )
  )

;; definition for method 247 of type ashelin
(defmethod ashelin-method-247 ((this ashelin) (arg0 symbol))
  (and (time-elapsed? (-> this last-fire-time) (seconds 1))
       (and (>= 8556.089 (fabs (-> this focus-info ry-diff))) (ashelin-method-250 this arg0 #t))
       )
  )

;; definition for method 254 of type ashelin
;; WARN: Return type mismatch int vs none.
;; WARN: Function (method 254 ashelin) has a return type of none, but the expression builder found a return statement.
(defmethod ashelin-method-254 ((this ashelin) (arg0 float))
  (let ((f30-0 (deg- arg0 (-> this focus-info my-facing-ry))))
    (when (>= 16384.0 (fabs f30-0))
      (let ((s5-0 (new 'stack-no-clear 'vector)))
        (when (ashelin-method-248 this s5-0 (+ 32768.0 arg0) 8192.0 40707.93 34563.93)
          (vector+! (-> this move-dest) s5-0 (-> this root trans))
          (return 1)
          )
        (cond
          ((< 0.0 f30-0)
           (when (ashelin-method-248 this s5-0 (+ -16384.0 arg0) 8192.0 40707.93 34563.93)
             (vector+! (-> this move-dest) s5-0 (-> this root trans))
             (return 2)
             )
           )
          (else
            (when (ashelin-method-248 this s5-0 (+ 16384.0 arg0) 8192.0 40707.93 34563.93)
              (vector+! (-> this move-dest) s5-0 (-> this root trans))
              (return 3)
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

;; definition for method 257 of type ashelin
;; WARN: Return type mismatch object vs int.
(defmethod ashelin-method-257 ((this ashelin))
  (when (>= 32768.0 (-> this focus-info bullseye-xz-dist))
    (let ((f0-1 (-> this focus-info bullseye-ry)))
      (return (the-as int (ashelin-method-254 this f0-1)))
      )
    )
  (when (logtest? (bot-flag bf20) (-> this bot-flags))
    (set! (-> this root trans w) 1.0)
    (when (>= (vector4-dot (the-as vector (-> this frontline)) (-> this root trans)) 12288.0)
      (let ((f0-7 (atan (-> this frontline x) (-> this frontline z))))
        (return (the-as int (ashelin-method-254 this f0-7)))
        )
      )
    )
  (the-as int 0)
  )

;; definition for method 252 of type ashelin
(defmethod ashelin-method-252 ((this ashelin))
  (let* ((v1-0 (target-pos 0))
         (a1-0 (-> this root trans))
         (f30-0 (atan (- (-> a1-0 x) (-> v1-0 x)) (- (-> a1-0 z) (-> v1-0 z))))
         (f0-5 (deg- f30-0 (-> this focus-info my-facing-ry)))
         (s5-0 0)
         )
    (cond
      ((or (>= 8192.0 (fabs f0-5)) (>= (fabs f0-5) 24576.0))
       (let ((s3-1 (zero? (rnd-int this 2)))
             (s4-0 (new 'stack-no-clear 'vector))
             )
         (countdown (s2-0 2)
           (cond
             (s3-1
               (when (ashelin-method-248 this s4-0 (+ 16384.0 f30-0) 8192.0 40707.93 34563.93)
                 (vector+! (-> this move-dest) s4-0 (-> this root trans))
                 (set! s5-0 3)
                 (goto cfg-20)
                 )
               )
             (else
               (when (ashelin-method-248 this s4-0 (+ -16384.0 f30-0) 8192.0 40707.93 34563.93)
                 (vector+! (-> this move-dest) s4-0 (-> this root trans))
                 (set! s5-0 2)
                 (goto cfg-20)
                 )
               )
             )
           (set! s3-1 (not s3-1))
           )
         )
       (label cfg-20)
       )
      (else
        (let ((s4-1 (new 'stack-no-clear 'vector)))
          (when (ashelin-method-248 this s4-1 (+ 32768.0 f30-0) 8192.0 40707.93 34563.93)
            (vector+! (-> this move-dest) s4-1 (-> this root trans))
            (set! s5-0 1)
            )
          )
        )
      )
    s5-0
    )
  )

;; definition for method 253 of type ashelin
(defmethod ashelin-method-253 ((this ashelin))
  (let ((s5-0 0))
    (cond
      ((zero? (rnd-int this 2))
       (when (>= 16384.0 (fabs (-> this focus-info ry-diff)))
         (let ((s4-0 (new 'stack-no-clear 'vector)))
           (when (ashelin-method-248 this s4-0 (+ 16384.0 (-> this focus-info bullseye-ry)) 8192.0 40707.93 34563.93)
             (vector+! (-> this move-dest) s4-0 (-> this root trans))
             (set! s5-0 3)
             )
           )
         )
       )
      (else
        (when (>= 16384.0 (fabs (-> this focus-info ry-diff)))
          (let ((s4-1 (new 'stack-no-clear 'vector)))
            (when (ashelin-method-248 this s4-1 (+ -16384.0 (-> this focus-info bullseye-ry)) 8192.0 40707.93 34563.93)
              (vector+! (-> this move-dest) s4-1 (-> this root trans))
              (set! s5-0 2)
              )
            )
          )
        )
      )
    s5-0
    )
  )

;; definition for method 251 of type ashelin
(defmethod go-dodge-state ((this ashelin) (arg0 int))
  (case arg0
    ((3)
     (go (method-of-object this cartwheel-left))
     )
    ((2)
     (go (method-of-object this tumble-right))
     )
    (else
      (go (method-of-object this back-spring))
      )
    )
  )

;; definition for method 258 of type ashelin
;; INFO: Used lq/sq
(defmethod ashelin-method-258 ((this ashelin))
  (cond
    ((logtest? (bot-flag bf20) (-> this bot-flags))
     (set! (-> this root trans w) 1.0)
     (set! (-> this focus-info bullseye w) 1.0)
     (let ((f30-0 (vector4-dot (the-as vector (-> this frontline)) (-> this root trans))))
       (let ((f0-4 (vector4-dot (the-as vector (-> this frontline)) (-> this focus-info bullseye))))
         (if (or (>= 0.0 f0-4) (>= -8192.0 f30-0))
             (return #t)
             )
         )
       (let ((s5-0 (new 'stack-no-clear 'vector)))
         (vector-! s5-0 (-> this focus-info bullseye) (-> this root trans))
         (set! (-> s5-0 y) 0.0)
         (vector-normalize! s5-0 1.0)
         (if (>= -0.342 (vector-dot s5-0 (the-as vector (-> this frontline))))
             (return #t)
             )
         (if (>= f30-0 0.0)
             (return #f)
             )
         (let ((a2-0 (new 'stack-no-clear 'vector))
               (a0-8 (new 'stack-no-clear 'vector))
               )
           (vector-float*! a2-0 (the-as vector (-> this frontline)) (- (-> this frontline w)))
           (set! (-> a0-8 quad) (-> this root trans quad))
           (set! (-> a0-8 y) 0.0)
           (>= (intersect-ray-plane a0-8 s5-0 a2-0 (-> this frontline)) 8192.0)
           )
         )
       )
     )
    (else
      #t
      )
    )
  )

;; definition for method 259 of type ashelin
;; WARN: Return type mismatch symbol vs none.
(defmethod ashelin-method-259 ((this ashelin))
  (when (logtest? (bot-flag bf20) (-> this bot-flags))
    (set! (-> this root trans w) 1.0)
    (set! (-> this focus-info bullseye w) 1.0)
    (let ((f0-3 (vector4-dot (the-as vector (-> this frontline)) (-> this root trans)))
          (f1-1 (vector4-dot (the-as vector (-> this frontline)) (-> this focus-info bullseye)))
          )
      (when (and (< 0.0 f1-1) (< 0.0 f0-3))
        (let ((s5-0 (new 'stack-no-clear 'vector)))
          (vector-! s5-0 (-> this focus-info bullseye) (-> this root trans))
          (set! (-> s5-0 y) 0.0)
          (vector-normalize! s5-0 1.0)
          (>= (vector-dot s5-0 (the-as vector (-> this frontline))) 0.0)
          )
        )
      )
    )
  (none)
  )

;; definition for method 78 of type ashelin
(defmethod go-hostile ((this ashelin))
  (bot-method-235 this #t)
  (cond
    ((not (bot-method-226 this))
     (go-best-state this)
     )
    ((ashelin-method-250 this #t #f)
     (go (method-of-object this standing-idle))
     )
    ((ashelin-method-258 this)
     (go (method-of-object this chase))
     )
    (else
      (go (method-of-object this standing-idle))
      )
    )
  )

;; definition for method 80 of type ashelin
(defmethod go-best-state ((this ashelin))
  (if (bot-method-226 this)
      (go-hostile this)
      (go-idle this)
      )
  )

;; definition for method 73 of type ashelin
(defmethod go-idle ((this ashelin))
  (if (bot-method-226 this)
      (go (method-of-object this standing-idle))
      (go (method-of-object this waiting-idle))
      )
  )

;; definition for method 122 of type ashelin
(defmethod go-idle2 ((this ashelin))
  (go (method-of-object this hidden))
  )

;; definition for method 249 of type ashelin
;; INFO: Used lq/sq
(defmethod fire-shot ((this ashelin) (arg0 vector))
  (set-time! (-> this last-fire-time))
  (+! (-> this fired-gun-count) 1)
  (let ((s4-0 (new 'stack-no-clear 'projectile-init-by-other-params)))
    (set! (-> s4-0 ent) (-> this entity))
    (set! (-> s4-0 charge) 1.0)
    (set! (-> s4-0 options) (projectile-options po13 po17))
    (logclear! (-> s4-0 options) (projectile-options po14 po15 po16))
    (set! (-> s4-0 notify-handle) (process->handle this))
    (set! (-> s4-0 owner-handle) (the-as handle #f))
    (set! (-> s4-0 target-handle) (the-as handle #f))
    (set! (-> s4-0 target-pos quad) (the-as uint128 0))
    (set! (-> s4-0 ignore-handle) (process->handle this))
    (let* ((v1-16 *game-info*)
           (a0-11 (+ (-> v1-16 attack-id) 1))
           )
      (set! (-> v1-16 attack-id) a0-11)
      (set! (-> s4-0 attack-id) a0-11)
      )
    (set! (-> s4-0 timeout) (seconds 4))
    (vector<-cspace! (-> s4-0 pos) (-> this node-list data 22))
    (set! (-> s4-0 vel quad) (-> arg0 quad))
    (vector-! (-> s4-0 vel) (-> s4-0 vel) (-> s4-0 pos))
    (vector-normalize! (-> s4-0 vel) 307200.0)
    (spawn-projectile ashelin-shot s4-0 this *default-dead-pool*)
    )
  )

;; definition for method 260 of type ashelin
(defmethod ashelin-method-260 ((this ashelin))
  (local-vars (v0-6 int))
  (with-pp
    (let* ((f30-0 (-> this nav state speed))
           (f0-1 (lerp-scale 0.0 2.0 f30-0 12288.0 40960.0))
           (f1-0 (-> this travel-anim-interp))
           (v1-5 (if (> (-> this skel active-channels) 0)
                     (-> this skel root-channel 0 frame-group)
                     )
                 )
           )
      (cond
        ((and v1-5 (= v1-5 (-> this draw art-group data 5)))
         (let ((f28-0 f1-0)
               (f0-4 (seek f1-0 f0-1 (* 4.0 (seconds-per-frame))))
               )
           (cond
             ((logtest? (bot-flag bf19) (-> this bot-flags))
              (if (< f0-4 1.0)
                  (set! f0-4 (cond
                               ((= f28-0 1.0)
                                (let ((v1-17 (-> this skel root-channel 1)))
                                  (set! (-> v1-17 dist) 13107.2)
                                  (set! (-> v1-17 frame-group) (the-as art-joint-anim (-> this draw art-group data 4)))
                                  )
                                (logclear! (-> this bot-flags) (bot-flag bf19))
                                f0-4
                                )
                               (else
                                 1.0
                                 )
                               )
                        )
                  )
              )
             (else
               (if (< 1.0 f0-4)
                   (set! f0-4 (cond
                                ((= f28-0 1.0)
                                 (let ((v1-27 (-> this skel root-channel 1)))
                                   (set! (-> v1-27 dist) 43690.68)
                                   (set! (-> v1-27 frame-group) (the-as art-joint-anim (-> this draw art-group data 6)))
                                   )
                                 (logior! (-> this bot-flags) (bot-flag bf19))
                                 f0-4
                                 )
                                (else
                                  1.0
                                  )
                                )
                         )
                   )
               )
             )
           (set! (-> this travel-anim-interp) f0-4)
           (let ((f0-7 (if (logtest? (bot-flag bf19) (-> this bot-flags))
                           (+ -1.0 f0-4)
                           (- 1.0 f0-4)
                           )
                       )
                 (v1-39 (-> this skel root-channel 1))
                 )
             (set! (-> v1-39 frame-interp 1) f0-7)
             (set! (-> v1-39 frame-interp 0) f0-7)
             )
           )
         (let* ((f28-1 (current-cycle-distance (-> this skel)))
                (f0-8 (quaternion-y-angle (-> this root quat)))
                (f1-10 (deg- f0-8 (-> this travel-prev-ry)))
                (f0-11 (fmin 40960.0 (* 0.35342914 (-> pp clock frames-per-second) (fabs f1-10))))
                (f0-14 (/ (* 16.0 (fmax f30-0 f0-11)) (* 15.0 f28-1)))
                (a0-22 (-> this skel root-channel 0))
                )
           (set! (-> a0-22 param 0) f0-14)
           (joint-control-channel-group-eval! a0-22 (the-as art-joint-anim #f) num-func-loop!)
           )
         (let ((a0-23 (-> this skel root-channel 1)))
           (set! (-> a0-23 param 0) 0.0)
           (joint-control-channel-group-eval! a0-23 (the-as art-joint-anim #f) num-func-chan)
           )
         )
        (else
          (let ((f30-1 (seek f1-0 f0-1 (* 4.0 (seconds-per-frame)))))
            (set! (-> this travel-anim-interp) f30-1)
            (ja-channel-push! 2 (seconds 0.15))
            (let ((a0-26 (-> this skel root-channel 0)))
              (set! (-> a0-26 dist) 26214.4)
              (set! (-> a0-26 frame-group) (the-as art-joint-anim (-> this draw art-group data 5)))
              (set! (-> a0-26 param 0) 1.0)
              (joint-control-channel-group! a0-26 (the-as art-joint-anim (-> this draw art-group data 5)) num-func-loop!)
              )
            (cond
              ((< f30-1 1.0)
               (let ((f0-22 (- 1.0 f30-1))
                     (a0-27 (-> this skel root-channel 1))
                     )
                 (set! (-> a0-27 frame-interp 1) f0-22)
                 (set! (-> a0-27 frame-interp 0) f0-22)
                 (set! (-> a0-27 dist) 13107.2)
                 (set! (-> a0-27 frame-group) (the-as art-joint-anim (-> this draw art-group data 4)))
                 (set! (-> a0-27 param 0) 0.0)
                 (joint-control-channel-group! a0-27 (the-as art-joint-anim (-> this draw art-group data 4)) num-func-chan)
                 )
               (set! v0-6 (the-as int (logclear (-> this bot-flags) (bot-flag bf19))))
               (set! (-> this bot-flags) (the-as bot-flag v0-6))
               )
              (else
                (let ((f0-26 (+ -1.0 f30-1))
                      (a0-29 (-> this skel root-channel 1))
                      )
                  (set! (-> a0-29 frame-interp 1) f0-26)
                  (set! (-> a0-29 frame-interp 0) f0-26)
                  (set! (-> a0-29 dist) 43690.68)
                  (set! (-> a0-29 frame-group) (the-as art-joint-anim (-> this draw art-group data 6)))
                  (set! (-> a0-29 param 0) 0.0)
                  (joint-control-channel-group! a0-29 (the-as art-joint-anim (-> this draw art-group data 6)) num-func-chan)
                  )
                (set! v0-6 (the-as int (logior (bot-flag bf19) (-> this bot-flags))))
                (set! (-> this bot-flags) (the-as bot-flag v0-6))
                )
              )
            )
          v0-6
          )
        )
      )
    )
  )

;; definition for method 55 of type ashelin
;; INFO: Used lq/sq
;; WARN: Return type mismatch float vs degrees.
(defmethod get-knockback-angle ((this ashelin))
  (local-vars (v1-36 art-element))
  (let ((f28-0 (quaternion-y-angle (-> this root quat))))
    (case (-> this incoming knocked-type)
      (((knocked-type blue-shot))
       (let ((a0-4 (the-as process-focusable (handle->process (-> this focus handle)))))
         (when a0-4
           (get-trans a0-4 0)
           (let ((s5-0 (new 'stack-no-clear 'vector)))
             (set! (-> s5-0 quad) (-> this root transv quad))
             (if (< (vector-dot (-> this root transv) (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)))
                    0.0
                    )
                 (vector-negate-in-place! s5-0)
                 )
             (set! f28-0 (atan (-> s5-0 x) (-> s5-0 z)))
             )
           )
         )
       )
      (else
        (let ((s5-1 (new 'stack-no-clear 'vector)))
          0.0
          0.0
          (vector-z-quaternion! s5-1 (-> this root quat))
          (let ((f28-1 (atan (-> s5-1 x) (-> s5-1 z))))
            (get-knockback-dir! this s5-1)
            (let* ((f30-0 (atan (-> s5-1 x) (-> s5-1 z)))
                   (f0-10 (deg- f30-0 f28-1))
                   )
              (set! f28-0 (if (>= 16384.0 (fabs f0-10))
                              f30-0
                              (the float (sar (shl (the int (+ 32768.0 f30-0)) 48) 48))
                              )
                    )
              (cond
                ((and (>= 8192.0 f0-10) (>= f0-10 -16384.0))
                 (set! v1-36 (-> this draw art-group data 10))
                 )
                ((>= f0-10 8192.0)
                 (set! v1-36 (-> this draw art-group data 7))
                 (set! f28-0 (the float (sar (shl (the int (+ 32768.0 f30-0)) 48) 48)))
                 )
                ((zero? (rnd-int this 3))
                 (set! v1-36 (-> this draw art-group data 10))
                 )
                (else
                  (set! v1-36 (-> this draw art-group data 7))
                  (set! f28-0 (the float (sar (shl (the int (+ 32768.0 f30-0)) 48) 48)))
                  )
                )
              )
            )
          )
        (set! (-> this knocked-anim) (the-as art-joint-anim v1-36))
        )
      )
    (the-as degrees f28-0)
    )
  )

;; definition for method 85 of type ashelin
(defmethod knocked-anim ((this ashelin) (arg0 enemy-knocked-info))
  (local-vars (a2-0 int))
  (case (-> this incoming knocked-type)
    (((knocked-type blue-shot))
     (let ((s5-1 (ash 1 (-> *ashelin-global-info* prev-blue-hit)))
           (s4-0 (new 'stack-no-clear 'vector))
           )
       0.0
       0.0
       (vector-z-quaternion! s4-0 (-> this root quat))
       (let ((f30-0 (atan (-> s4-0 x) (-> s4-0 z))))
         (get-knockback-dir! this s4-0)
         (let* ((f0-6 (atan (-> s4-0 x) (-> s4-0 z)))
                (f0-8 (fabs (deg- f0-6 f30-0)))
                )
           (if (>= 16384.0 f0-8)
               (set! a2-0 (logior s5-1 7))
               (set! a2-0 (logior s5-1 56))
               )
           )
         )
       )
     (let* ((v1-9 (enemy-method-131 this 6 a2-0))
            (s5-2 (-> this draw art-group data (-> *ashelin-global-info* blue-hit-anim v1-9 anim-index)))
            )
       (set! (-> *ashelin-global-info* prev-blue-hit) v1-9)
       (let ((v1-12 (if (> (-> this skel active-channels) 0)
                        (-> this skel root-channel 0 frame-group)
                        )
                    )
             )
         (if (and v1-12 (or (= v1-12 (-> this draw art-group data 16))
                            (= v1-12 (-> this draw art-group data 17))
                            (= v1-12 (-> this draw art-group data 18))
                            (= v1-12 (-> this draw art-group data 22))
                            (= v1-12 (-> this draw art-group data 23))
                            (= v1-12 (-> this draw art-group data 24))
                            )
                  )
             (ja-channel-push! 1 (seconds 0.17))
             (ja-channel-push! 1 (seconds 0.02))
             )
         )
       (let ((a0-38 (-> this skel root-channel 0)))
         (set! (-> a0-38 frame-group) (the-as art-joint-anim s5-2))
         (set! (-> a0-38 param 0) (the float (+ (-> (the-as art-joint-anim s5-2) frames num-frames) -1)))
         (set! (-> a0-38 param 1) 1.0)
         (set! (-> a0-38 frame-num) 0.0)
         (joint-control-channel-group! a0-38 (the-as art-joint-anim s5-2) num-func-seek!)
         )
       )
     #t
     )
    (else
      (ja-channel-push! 1 (seconds 0.03))
      (let ((a0-40 (-> this skel root-channel 0)))
        (set! (-> a0-40 frame-group) (-> this knocked-anim))
        (set! (-> a0-40 param 0) (the float (+ (-> this knocked-anim frames num-frames) -1)))
        (set! (-> a0-40 param 1) (-> arg0 anim-speed))
        (set! (-> a0-40 frame-num) 0.0)
        (joint-control-channel-group! a0-40 (-> this knocked-anim) num-func-seek!)
        )
      #t
      )
    )
  )

;; definition for method 86 of type ashelin
(defmethod knocked-land-anim ((this ashelin) (arg0 enemy-knocked-info))
  (let ((v1-0 (-> this incoming knocked-type)))
    (cond
      ((= v1-0 (knocked-type blue-shot))
       (let* ((v1-1 *ashelin-global-info*)
              (s5-0 (-> this draw art-group data (-> v1-1 blue-hit-land-anim (-> v1-1 prev-blue-hit) anim-index)))
              )
         (ja-channel-push! 1 (seconds 0.17))
         (let ((a0-7 (-> this skel root-channel 0)))
           (set! (-> a0-7 frame-group) (the-as art-joint-anim s5-0))
           (set! (-> a0-7 param 0) (the float (+ (-> (the-as art-joint-anim s5-0) frames num-frames) -1)))
           (set! (-> a0-7 param 1) 1.0)
           (set! (-> a0-7 frame-num) 0.0)
           (joint-control-channel-group! a0-7 (the-as art-joint-anim s5-0) num-func-seek!)
           )
         )
       #t
       )
      ((let ((v1-15 (if (> (-> this skel active-channels) 0)
                        (-> this skel root-channel 0 frame-group)
                        )
                    )
             )
         (and v1-15 (= v1-15 (-> this draw art-group data 7)))
         )
       (cond
         ((or (= (-> this hit-points) 0.0) (nonzero? (-> this fated-time)))
          (ja-channel-push! 1 (seconds 0.17))
          (let ((a0-14 (-> this skel root-channel 0)))
            (set! (-> a0-14 frame-group) (the-as art-joint-anim (-> this draw art-group data 9)))
            (set! (-> a0-14 param 0)
                  (the float (+ (-> (the-as art-joint-anim (-> this draw art-group data 9)) frames num-frames) -1))
                  )
            (set! (-> a0-14 param 1) 1.0)
            (set! (-> a0-14 frame-num) 0.0)
            (joint-control-channel-group! a0-14 (the-as art-joint-anim (-> this draw art-group data 9)) num-func-seek!)
            )
          #f
          )
         (else
           (ja-channel-push! 1 (seconds 0.17))
           (let ((a0-16 (-> this skel root-channel 0)))
             (set! (-> a0-16 frame-group) (the-as art-joint-anim (-> this draw art-group data 8)))
             (set! (-> a0-16 param 0)
                   (the float (+ (-> (the-as art-joint-anim (-> this draw art-group data 8)) frames num-frames) -1))
                   )
             (set! (-> a0-16 param 1) 1.0)
             (set! (-> a0-16 frame-num) 0.0)
             (joint-control-channel-group! a0-16 (the-as art-joint-anim (-> this draw art-group data 8)) num-func-seek!)
             )
           #t
           )
         )
       )
      ((and (or (= (-> this hit-points) 0.0) (nonzero? (-> this fated-time))) (nonzero? (rnd-int this 3)))
       (ja-channel-push! 1 (seconds 0.17))
       (let ((a0-20 (-> this skel root-channel 0)))
         (set! (-> a0-20 frame-group) (the-as art-joint-anim (-> this draw art-group data 12)))
         (set! (-> a0-20 param 0)
               (the float (+ (-> (the-as art-joint-anim (-> this draw art-group data 12)) frames num-frames) -1))
               )
         (set! (-> a0-20 param 1) 1.0)
         (set! (-> a0-20 frame-num) 0.0)
         (joint-control-channel-group! a0-20 (the-as art-joint-anim (-> this draw art-group data 12)) num-func-seek!)
         )
       #f
       )
      (else
        (ja-channel-push! 1 (seconds 0.17))
        (let ((a0-22 (-> this skel root-channel 0)))
          (set! (-> a0-22 frame-group) (the-as art-joint-anim (-> this draw art-group data 11)))
          (set! (-> a0-22 param 0)
                (the float (+ (-> (the-as art-joint-anim (-> this draw art-group data 11)) frames num-frames) -1))
                )
          (set! (-> a0-22 param 1) 1.0)
          (set! (-> a0-22 frame-num) 0.0)
          (joint-control-channel-group! a0-22 (the-as art-joint-anim (-> this draw art-group data 11)) num-func-seek!)
          )
        #t
        )
      )
    )
  )

;; definition for method 87 of type ashelin
(defmethod knocked-anim-handler ((this ashelin) (arg0 int) (arg1 enemy-knocked-info))
  (cond
    ((= arg0 3)
     (let ((s5-0 (ja-done? 0)))
       (cond
         ((and s5-0 (let ((v1-4 (if (> (-> this skel active-channels) 0)
                                    (-> this skel root-channel 0 frame-group)
                                    )
                                )
                          )
                      (and v1-4 (or (= v1-4 (-> this draw art-group data 16))
                                    (= v1-4 (-> this draw art-group data 17))
                                    (= v1-4 (-> this draw art-group data 18))
                                    (= v1-4 (-> this draw art-group data 22))
                                    (= v1-4 (-> this draw art-group data 23))
                                    (= v1-4 (-> this draw art-group data 24))
                                    )
                           )
                      )
               )
          (ja-channel-push! 1 (seconds 0.03))
          (let ((a0-21 (-> this skel root-channel 0)))
            (set! (-> a0-21 frame-group) (the-as art-joint-anim (-> this draw art-group data 25)))
            (set! (-> a0-21 param 0)
                  (the float (+ (-> (the-as art-joint-anim (-> this draw art-group data 25)) frames num-frames) -1))
                  )
            (set! (-> a0-21 param 1) 1.0)
            (set! (-> a0-21 frame-num) 0.0)
            (joint-control-channel-group! a0-21 (the-as art-joint-anim (-> this draw art-group data 25)) num-func-seek!)
            )
          (set! s5-0 #f)
          )
         (else
           (let ((v1-25 (if (> (-> this skel active-channels) 0)
                            (-> this skel root-channel 0 frame-group)
                            )
                        )
                 )
             (cond
               ((and v1-25 (= v1-25 (-> this draw art-group data 8)))
                (let ((f0-4 (ja-aframe-num 0)))
                  (cond
                    ((>= f0-4 22.0)
                     (when (focus-test? this dangerous)
                       (if (logtest? (-> this enemy-flags) (enemy-flag dangerous-backup))
                           (logior! (-> this focus-status) (focus-status dangerous))
                           (logclear! (-> this focus-status) (focus-status dangerous))
                           )
                       )
                     )
                    ((>= f0-4 16.0)
                     (when (not (focus-test? this dangerous))
                       (logior! (-> this focus-status) (focus-status dangerous))
                       (let* ((v1-42 *game-info*)
                              (a0-34 (+ (-> v1-42 attack-id) 1))
                              )
                         (set! (-> v1-42 attack-id) a0-34)
                         (set! (-> this attack-id) a0-34)
                         )
                       )
                     )
                    )
                  )
                )
               ((let ((v1-45 (if (> (-> this skel active-channels) 0)
                                 (-> this skel root-channel 0 frame-group)
                                 )
                             )
                      )
                  (and v1-45 (= v1-45 (-> this draw art-group data 11)))
                  )
                (let ((f0-5 (ja-aframe-num 0)))
                  (cond
                    ((>= f0-5 32.0)
                     (when (focus-test? this dangerous)
                       (if (logtest? (-> this enemy-flags) (enemy-flag dangerous-backup))
                           (logior! (-> this focus-status) (focus-status dangerous))
                           (logclear! (-> this focus-status) (focus-status dangerous))
                           )
                       )
                     )
                    ((>= f0-5 25.0)
                     (when (not (focus-test? this dangerous))
                       (logior! (-> this focus-status) (focus-status dangerous))
                       (let* ((v1-62 *game-info*)
                              (a0-47 (+ (-> v1-62 attack-id) 1))
                              )
                         (set! (-> v1-62 attack-id) a0-47)
                         (set! (-> this attack-id) a0-47)
                         )
                       )
                     )
                    )
                  )
                )
               )
             )
           (let ((a0-48 (-> this skel root-channel 0)))
             (set! (-> a0-48 param 0) (the float (+ (-> a0-48 frame-group frames num-frames) -1)))
             (set! (-> a0-48 param 1) (-> arg1 anim-speed))
             (joint-control-channel-group-eval! a0-48 (the-as art-joint-anim #f) num-func-seek!)
             )
           )
         )
       s5-0
       )
     )
    (else
      ((method-of-type bot knocked-anim-handler) this arg0 arg1)
      )
    )
  )

;; definition for method 248 of type ashelin
;; INFO: Used lq/sq
(defmethod ashelin-method-248 ((this ashelin) (arg0 vector) (arg1 float) (arg2 float) (arg3 float) (arg4 float))
  (local-vars (v1-23 float) (sv-272 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let* ((v1-0 (-> this nav))
           (a0-3 (-> v1-0 state mesh sphere-hash sphere-array))
           (a1-1 (-> v1-0 sphere-id-array))
           (a2-2 (-> v1-0 state mesh bounds))
           (a3-1 (-> v1-0 root-nav-sphere))
           (t0-1 (-> v1-0 sphere-count))
           )
      (dotimes (t1-1 t0-1)
        (let ((t3-0 (-> a0-3 (-> a1-1 t1-1)))
              (t2-4 (-> v1-0 sphere-array t1-1))
              )
          (vector-! (the-as vector t2-4) (the-as vector t3-0) (the-as vector a2-2))
          (set! (-> t2-4 r) (+ (-> t3-0 r) (-> a3-1 w)))
          )
        )
      )
    0
    (let ((s0-0 (new 'stack-no-clear 'nav-avoid-spheres-params)))
      (vector-! (-> s0-0 current-pos) (-> this root trans) (the-as vector (-> this nav state mesh bounds)))
      (set! sv-272 (-> s0-0 travel))
      (set! (-> sv-272 x) (sin arg1))
      (set! (-> sv-272 y) 0.0)
      (set! (-> sv-272 z) (cos arg1))
      (set! (-> sv-272 w) 1.0)
      (vector-float*! (-> s0-0 travel) (-> s0-0 travel) arg3)
      (set! (-> s0-0 pref-dir quad) (-> s0-0 travel quad))
      (avoid-spheres-1! (-> this nav) s0-0)
      (set! (-> arg0 quad) (-> s0-0 out-travel 0 quad))
      )
    0
    (when (>= arg2 (fabs (deg- arg1 (atan (-> arg0 x) (-> arg0 z)))))
      (let ((t0-2 (new 'stack-no-clear 'clamp-travel-vector-to-mesh-return-info)))
        (clamp-vector-to-mesh-no-gaps (-> this nav) (-> this root trans) (-> this nav state current-poly) arg0 t0-2)
        )
      (.lvf vf1 (&-> arg0 quad))
      (.add.w.vf vf2 vf0 vf0 :mask #b1)
      (.mul.vf vf1 vf1 vf1)
      (.mul.x.vf acc vf2 vf1 :mask #b1)
      (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
      (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
      (.mov v1-23 vf1)
      (let ((f0-11 v1-23)
            (f1-1 arg4)
            )
        (>= f0-11 (* f1-1 f1-1))
        )
      )
    )
  )

;; definition for method 160 of type ashelin
(defmethod normalize-heading! ((this ashelin) (arg0 nav-control))
  (if (not (and (-> this next-state) (let ((v1-3 (-> this next-state name)))
                                       (or (= v1-3 'back-spring) (= v1-3 'cartwheel-left) (= v1-3 'tumble-right))
                                       )
                )
           )
      ((method-of-type bot normalize-heading!) this arg0)
      )
  (none)
  )

;; definition for method 228 of type ashelin
;; WARN: Return type mismatch int vs none.
(defmethod bot-method-228 ((this ashelin))
  (set! (-> this health-handle)
        (ppointer->handle (process-spawn hud-ashelin :init hud-init-by-other :name "hud-ashelin" :to this))
        )
  0
  (none)
  )

;; definition for method 215 of type ashelin
(defmethod play-next-speech ((this ashelin))
  (local-vars (v1-3 int) (a3-0 int))
  (when (not (channel-active? this (gui-channel none)))
    (let ((v1-2 0))
      (if (logtest? (penetrate jak-yellow-shot jak-red-shot jak-blue-shot jak-dark-shot)
                    (-> this incoming penetrate-using)
                    )
          (set! v1-3 (logior v1-2 128))
          (set! v1-3 (logior v1-2 64))
          )
      )
    (if (logtest? (-> this bot-flags) (bot-flag attacked))
        (set! a3-0 (logior v1-3 256))
        (set! a3-0 (logior v1-3 512))
        )
    (let ((a1-3 (get-next-speech-idx
                  (-> this course attack-player-speeches)
                  this
                  (-> this course speeches)
                  (the-as bot-speech-info-flag a3-0)
                  )
                )
          )
      (if (>= a1-3 0)
          (play-speech-by-id this a1-3)
          )
      )
    )
  )

;; definition for method 255 of type ashelin
;; WARN: Return type mismatch gui-connection vs none.
(defmethod ashelin-method-255 ((this ashelin))
  (when (not (channel-active? this (gui-channel none)))
    (let ((a1-2
            (get-next-speech-idx (-> this course ouch-speeches) this (-> this course speeches) (bot-speech-info-flag))
            )
          )
      (if (>= a1-2 0)
          (play-speech-by-id this a1-2)
          )
      )
    )
  (none)
  )

;; definition for method 256 of type ashelin
;; WARN: Return type mismatch gui-connection vs none.
(defmethod ashelin-method-256 ((this ashelin))
  (when (and (not (channel-active? this (gui-channel none))) (>= (current-time) (-> this victory-speech-time)))
    (let ((s5-0
            (get-next-speech-idx (-> this course victory-speeches) this (-> this course speeches) (bot-speech-info-flag))
            )
          )
      (when (>= s5-0 0)
        (set! (-> this victory-speech-time) (+ (set-reaction-time! this (seconds 4) (seconds 7)) (current-time)))
        (play-speech-by-id this s5-0)
        )
      )
    )
  (none)
  )

;; definition for method 147 of type ashelin
;; WARN: Return type mismatch enemy-flag vs none.
(defmethod check-victory ((this ashelin))
  (if (time-elapsed? (-> this hit-focus-time) (seconds 2))
      (logclear! (-> this enemy-flags) (enemy-flag victory))
      )
  (none)
  )

;; definition for method 218 of type ashelin
;; WARN: Return type mismatch enemy-flag vs gui-connection.
(defmethod play-speech-by-id ((this ashelin) (arg0 int))
  (let ((t9-0 (method-of-type bot play-speech-by-id)))
    (t9-0 this arg0)
    )
  (let ((v0-1 (logclear (-> this enemy-flags) (enemy-flag victory))))
    (set! (-> this enemy-flags) v0-1)
    (the-as gui-connection v0-1)
    )
  )

;; definition for method 15 of type hud-ashelin
;; WARN: Return type mismatch int vs none.
(defmethod draw ((this hud-ashelin))
  (set-hud-piece-position!
    (-> this sprites 2)
    (the int (+ 30.0 (* -130.0 (-> this offset))))
    (the int (+ 30.0 (* -100.0 (-> this offset))))
    )
  (set! (-> this sprites 0 angle) (* 182.04445 (the float (- 270 (/ (* 90 (-> this values 0 current)) 100)))))
  (set-as-offset-from! (the-as hud-sprite (-> this sprites)) (the-as vector4w (-> this sprites 2)) 40 16)
  (set-as-offset-from! (-> this sprites 1) (the-as vector4w (-> this sprites 2)) 1 16)
  (set-as-offset-from! (-> this sprites 3) (the-as vector4w (-> this sprites 2)) 8 2)
  ((method-of-type hud draw) this)
  0
  (none)
  )

;; definition for method 16 of type hud-ashelin
;; WARN: Return type mismatch int vs none.
(defmethod update-values! ((this hud-ashelin))
  (set! (-> this values 0 target) (the int (* 100.0 (-> *game-info* bot-health 0))))
  ((method-of-type hud update-values!) this)
  0
  (none)
  )

;; definition for method 17 of type hud-ashelin
;; WARN: Return type mismatch int vs none.
(defmethod init-callback ((this hud-ashelin))
  (set! (-> this gui-id)
        (add-process *gui-control* this (gui-channel hud-upper-left) (gui-action hidden) (-> this name) 81920.0 0)
        )
  (logior! (-> this flags) (hud-flags show))
  (set! (-> this sprites 0 tid) (the-as texture-id (get-texture hud-transparent-01 level-default-minimap)))
  (set! (-> this sprites 0 scale-x) 12.0)
  (set! (-> this sprites 0 scale-y) 11.2)
  (set! (-> this sprites 0 pos z) #xfffff2)
  (set! (-> this sprites 1 tid) (the-as texture-id (get-texture hud-npcring-bar-01 level-default-minimap)))
  (set! (-> this sprites 1 pos z) #xfffff0)
  (set! (-> this sprites 2 tid) (the-as texture-id (get-texture hud-npcring-01 level-default-minimap)))
  (set! (-> this sprites 2 pos z) #xffffff)
  (set! (-> this sprites 3 tid)
        (the-as
          texture-id
          (lookup-texture-by-name "hud-ashlyn-head" (the-as string #f) (the-as (pointer texture-page) #f))
          )
        )
  (set! (-> this sprites 3 scale-x) 1.0)
  (set! (-> this sprites 3 scale-y) 1.4)
  (set! (-> this sprites 3 pos z) #xffffff)
  0
  (none)
  )
