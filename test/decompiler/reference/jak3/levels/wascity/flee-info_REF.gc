;;-*-Lisp-*-
(in-package goal)

;; definition of type flee-info
(deftype flee-info (structure)
  ((pad  uint8  4)
   )
  :pack-me
  (:methods
    (flee-info-method-9 (_type_ citizen nav-branch int vector float) float)
    (flee-info-method-10 (_type_ citizen vector) nav-segment)
    (flee-info-method-11 (_type_ citizen) none)
    (flee-info-method-12 (_type_ citizen) none)
    (flee-info-method-13 (_type_ citizen) none)
    )
  )

;; definition for method 3 of type flee-info
(defmethod inspect ((this flee-info))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'flee-info)
  (label cfg-4)
  this
  )

;; definition for method 9 of type flee-info
;; INFO: Used lq/sq
(defmethod flee-info-method-9 ((this flee-info) (arg0 citizen) (arg1 nav-branch) (arg2 int) (arg3 vector) (arg4 float))
  (local-vars (sv-32 int))
  (when (nonzero? arg2)
    (-> arg1 src-node)
    (let* ((s2-0 (-> arg1 dest-node))
           (t9-0 vector-vector-xz-distance)
           (a0-1 arg3)
           (a2-1 s2-0)
           (a1-1 (new 'stack-no-clear 'vector))
           )
      (set! (-> a1-1 quad) (-> a2-1 position quad))
      (set! (-> a1-1 w) 1.0)
      (let ((s0-0 (t9-0 a0-1 a1-1))
            (s1-0 (-> s2-0 branch-count))
            (f30-0 0.0)
            )
        (set! sv-32 0)
        (while (< sv-32 s1-0)
          (+! f30-0 (flee-info-method-9 this arg0 (-> s2-0 branch-array sv-32) (+ arg2 -1) arg3 s0-0))
          (set! sv-32 (+ sv-32 1))
          )
        (set! arg4 (+ s0-0 (the float (/ (the int f30-0) s1-0))))
        )
      )
    )
  arg4
  )

;; definition for method 10 of type flee-info
;; INFO: Used lq/sq
(defmethod flee-info-method-10 ((this flee-info) (arg0 citizen) (arg1 vector))
  (let ((a1-1 (new 'stack-no-clear 'vector)))
    (set! (-> a1-1 quad) (-> arg0 root trans quad))
    (set! (-> a1-1 w) 81920.0)
    (let ((s5-0 (find-segment arg0 a1-1 arg1)))
      (if s5-0
          (citizen-method-199 arg0 s5-0)
          )
      s5-0
      )
    )
  )

;; definition for method 11 of type flee-info
(defmethod flee-info-method-11 ((this flee-info) (arg0 citizen))
  (citizen-method-205 arg0)
  (none)
  )

;; definition for method 12 of type flee-info
(defmethod flee-info-method-12 ((this flee-info) (arg0 citizen))
  (let ((a2-1 (vector-! (new 'stack-no-clear 'vector) (-> arg0 root trans) (the-as vector (-> arg0 danger-pos)))))
    (flee-info-method-10 this arg0 a2-1)
    )
  (if (zero? (-> arg0 controller branch))
      (citizen-method-208 arg0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> arg0 root quat)))
      )
  (none)
  )

;; definition for method 13 of type flee-info
;; INFO: Used lq/sq
(defmethod flee-info-method-13 ((this flee-info) (arg0 citizen))
  (local-vars (sv-80 nav-branch))
  (let* ((s5-0 (-> arg0 controller))
         (s2-0 (-> s5-0 branch dest-node))
         (s4-0 (the-as nav-branch #f))
         (s1-1 (vector-! (new 'stack-no-clear 'vector) (-> arg0 dest-point) (-> arg0 controller path-prev-point)))
         )
    0.0
    (let ((s0-1 (vector-! (new 'stack-no-clear 'vector) (-> arg0 root trans) (-> arg0 dest-point))))
      (set! (-> s0-1 y) 0.0)
      (set! (-> s1-1 y) 0.0)
      (vector-xz-normalize! s1-1 1.0)
      (let ((f0-4 (vector-dot s0-1 s1-1)))
        (when (< -16384.0 f0-4)
          (cond
            ((zero? (-> s2-0 branch-count))
             )
            (else
              (let ((s1-2 (-> s2-0 branch-count))
                    (f30-0 0.0)
                    )
                (dotimes (s0-2 s1-2)
                  (set! sv-80 (-> s2-0 branch-array s0-2))
                  (let ((f0-5 (flee-info-method-9 this arg0 sv-80 4 (-> arg0 danger-pos) 0.0)))
                    (when (< f30-0 f0-5)
                      (set! f30-0 f0-5)
                      (set! s4-0 sv-80)
                      )
                    )
                  )
                )
              )
            )
          (when s4-0
            (vehicle-controller-method-11 s5-0)
            (let ((s3-1 (new 'stack-no-clear 'vector)))
              (set! (-> s3-1 quad) (-> s5-0 turn-exit-point quad))
              (vehicle-controller-method-10 s5-0 s4-0)
              (set! (-> s5-0 path-prev-point quad) (-> s3-1 quad))
              )
            (set! (-> s5-0 branch) s4-0)
            (let ((a1-4 (-> s4-0 dest-node))
                  (v1-21 (-> s5-0 turn-exit-point))
                  )
              (set! (-> v1-21 quad) (-> a1-4 position quad))
              (set! (-> v1-21 w) 1.0)
              )
            )
          )
        )
      )
    )
  (when (< (-> arg0 cp-next-time) (current-time))
    (set! (-> arg0 cp-next-time) (+ (current-time) (set-reaction-time! arg0 (seconds 2) (seconds 4))))
    (citizen-method-203 arg0 (-> arg0 cp-force))
    )
  (add-offset-to-target! (-> arg0 nav state) (-> arg0 cp-force))
  (let ((a0-18 (-> arg0 nav state))
        (v1-32 (-> arg0 dest-point))
        )
    (logclear! (-> a0-18 flags) (nav-state-flag directional-mode))
    (logior! (-> a0-18 flags) (nav-state-flag target-poly-dirty))
    (set! (-> a0-18 target-pos quad) (-> v1-32 quad))
    )
  0
  (set! (-> (new 'stack-no-clear 'vector) quad) (-> arg0 nav state target-pos quad))
  (nav-enemy-method-187 arg0)
  (none)
  )




