;;-*-Lisp-*-
(in-package goal)

;; definition of type sig-rider
(deftype sig-rider (process-focusable)
  ((front-back-interp  float)
   (left-right-interp  float)
   (up-down-interp     float)
   (complain-time      time-frame)
   (complain-speech    int32)
   (last-moved-time    time-frame)
   )
  (:state-methods
    idle
    die
    )
  )

;; definition for method 3 of type sig-rider
(defmethod inspect ((this sig-rider))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-focusable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tfront-back-interp: ~f~%" (-> this front-back-interp))
  (format #t "~2Tleft-right-interp: ~f~%" (-> this left-right-interp))
  (format #t "~2Tup-down-interp: ~f~%" (-> this up-down-interp))
  (format #t "~2Tcomplain-time: ~D~%" (-> this complain-time))
  (format #t "~2Tcomplain-speech: ~D~%" (-> this complain-speech))
  (format #t "~2Tlast-moved-time: ~D~%" (-> this last-moved-time))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sig-rider sig-rider sig-rider-lod0-jg sig-rider-idle-ja
              ((sig-rider-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

;; definition for function sig-pilot-trans
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defbehavior sig-pilot-trans sig-rider ()
  (when (and *target* (focus-test? *target* pilot-riding))
    (let ((s5-0 (-> *target* pilot)))
      (when (nonzero? s5-0)
        (let ((gp-0 (new 'stack-no-clear 'matrix)))
          (set! (-> gp-0 uvec x) (* 182.04445 (* 0.5454545 (the float (current-time)))))
          (set! (-> gp-0 uvec z) (sin (-> gp-0 uvec x)))
          (set! (-> gp-0 uvec w) (cos (-> gp-0 uvec x)))
          (set! (-> gp-0 uvec y) (seconds-per-frame))
          (set! (-> gp-0 rvec quad) (-> s5-0 local-accel quad))
          (let ((f1-6 (+ (* 0.03 (-> gp-0 uvec z)) (* -1.0 (-> gp-0 rvec x) (-> s5-0 left-right-accel-factor)))))
            (+! (-> self left-right-interp) (* (- f1-6 (-> self left-right-interp)) (fmin 1.0 (* 8.0 (-> gp-0 uvec y)))))
            )
          (set! (-> self left-right-interp) (fmax -1.0 (fmin 1.0 (-> self left-right-interp))))
          (let ((f1-15 (+ (* 0.03 (-> gp-0 uvec w)) (* -1.0 (-> gp-0 rvec z) (-> s5-0 front-back-accel-factor)))))
            (+! (-> self front-back-interp) (* (- f1-15 (-> self front-back-interp)) (fmin 1.0 (* 8.0 (-> gp-0 uvec y)))))
            )
          (set! (-> self front-back-interp) (fmax -1.0 (fmin 1.0 (-> self front-back-interp))))
          (let ((f1-24 (+ (* 0.03 (-> gp-0 uvec w)) (* -1.0 (-> gp-0 rvec y) (-> s5-0 up-down-accel-factor)))))
            (+! (-> self up-down-interp) (* (- f1-24 (-> self up-down-interp)) (fmin 1.0 (* 8.0 (-> gp-0 uvec y)))))
            )
          )
        (set! (-> self up-down-interp) (fmax -1.0 (fmin 1.0 (-> self up-down-interp))))
        )
      )
    )
  0
  (none)
  )

;; definition for function sig-pilot-wcar-anim-loop
;; WARN: Return type mismatch symbol vs none.
;; WARN: new jak 2 until loop case, check carefully
(defbehavior sig-pilot-wcar-anim-loop sig-rider ()
  (ja-channel-set! 3)
  (ja :group! sig-rider-pilot-car-turn-back-ja)
  (ja :chan 1 :group! sig-rider-pilot-car-turn-front-ja)
  (ja :chan 2 :group! sig-rider-pilot-car-up-down-ja)
  (until #f
    (let ((f30-0 (* 5.0 (+ 1.0 (-> self left-right-interp)))))
      (ja :num-func num-func-identity :frame-num (ja-aframe f30-0 0))
      (let ((gp-1 (-> self skel root-channel 1)))
        (let ((f0-3 (* 0.5 (+ 1.0 (-> self front-back-interp)))))
          (set! (-> gp-1 frame-interp 1) f0-3)
          (set! (-> gp-1 frame-interp 0) f0-3)
          )
        (set! (-> gp-1 num-func) num-func-identity)
        (set! (-> gp-1 frame-num) (ja-aframe f30-0 1))
        )
      )
    (let ((f0-6 (* 5.0 (- 1.0 (-> self up-down-interp))))
          (gp-2 (-> self skel root-channel 2))
          )
      (let ((f1-7 (fabs (-> self up-down-interp))))
        (set! (-> gp-2 frame-interp 1) f1-7)
        (set! (-> gp-2 frame-interp 0) f1-7)
        )
      (set! (-> gp-2 num-func) num-func-identity)
      (set! (-> gp-2 frame-num) (ja-aframe f0-6 2))
      )
    (suspend)
    )
  #f
  (none)
  )

;; failed to figure out what this is:
(defstate idle (sig-rider)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (v0-0 object))
    (case message
      (('hide)
       (set! v0-0 (logior (-> self draw status) (draw-control-status no-draw)))
       (set! (-> self draw status) (the-as draw-control-status v0-0))
       v0-0
       )
      (('unhide)
       (set! v0-0 (logclear (-> self draw status) (draw-control-status no-draw)))
       (set! (-> self draw status) (the-as draw-control-status v0-0))
       v0-0
       )
      (('attack-invinc 'die)
       (go-virtual die)
       )
      )
    )
  :trans (behavior ()
    (local-vars (v1-48 float))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (sig-pilot-trans)
      (cond
        ((and *target*
              (focus-test? *target* pilot-riding)
              (nonzero? (-> *target* pilot))
              (-> self parent)
              (-> self parent 0)
              (= *target* (find-rider (the-as vehicle (-> self parent 0))))
              )
         (let ((v1-14 (-> *target* pilot)))
           (when (time-elapsed? (-> self complain-time) (seconds 3))
             (let* ((f0-0 1228800.0)
                    (f0-2 (* f0-0 f0-0))
                    (a0-7 (-> v1-14 accel-array))
                    )
               (when (or (< f0-2 (+ (* (-> a0-7 0 x) (-> a0-7 0 x)) (* (-> a0-7 0 z) (-> a0-7 0 z))))
                         (< 4915200.0 (fabs (-> v1-14 accel-array 0 y)))
                         )
                 (set! (-> self complain-speech) (mod (+ (-> self complain-speech) (rand-vu-int-range 2 6)) 9))
                 (let ((v1-19 (-> self complain-speech)))
                   (cond
                     ((zero? v1-19)
                      (talker-spawn-func (-> *nest-eggs-speech-list* 9) *entity-pool* (target-pos 0) (the-as region #f))
                      )
                     ((= v1-19 1)
                      (talker-spawn-func (-> *nest-eggs-speech-list* 10) *entity-pool* (target-pos 0) (the-as region #f))
                      )
                     ((= v1-19 2)
                      (talker-spawn-func (-> *nest-eggs-speech-list* 11) *entity-pool* (target-pos 0) (the-as region #f))
                      )
                     ((= v1-19 3)
                      (talker-spawn-func (-> *nest-eggs-speech-list* 12) *entity-pool* (target-pos 0) (the-as region #f))
                      )
                     ((= v1-19 4)
                      (talker-spawn-func (-> *nest-eggs-speech-list* 13) *entity-pool* (target-pos 0) (the-as region #f))
                      )
                     ((= v1-19 5)
                      (talker-spawn-func (-> *nest-eggs-speech-list* 14) *entity-pool* (target-pos 0) (the-as region #f))
                      )
                     ((= v1-19 6)
                      (talker-spawn-func (-> *nest-eggs-speech-list* 15) *entity-pool* (target-pos 0) (the-as region #f))
                      )
                     ((= v1-19 7)
                      (talker-spawn-func (-> *nest-eggs-speech-list* 16) *entity-pool* (target-pos 0) (the-as region #f))
                      )
                     ((= v1-19 8)
                      (talker-spawn-func (-> *nest-eggs-speech-list* 17) *entity-pool* (target-pos 0) (the-as region #f))
                      )
                     ((= v1-19 9)
                      (talker-spawn-func (-> *nest-eggs-speech-list* 18) *entity-pool* (target-pos 0) (the-as region #f))
                      )
                     )
                   )
                 (set-time! (-> self complain-time))
                 )
               )
             )
           )
         (let* ((f0-4 20480.0)
                (f0-6 (* f0-4 f0-4))
                )
           (.lvf vf1 (&-> (-> *target* control transv) quad))
           (.add.w.vf vf2 vf0 vf0 :mask #b1)
           (.mul.vf vf1 vf1 vf1)
           (.mul.x.vf acc vf2 vf1 :mask #b1)
           (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
           (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
           (.mov v1-48 vf1)
           (if (< f0-6 v1-48)
               (set-time! (-> self last-moved-time))
               )
           )
         (when (time-elapsed? (-> self last-moved-time) (seconds 8))
           (talker-spawn-func (-> *nest-eggs-speech-list* 20) *entity-pool* (target-pos 0) (the-as region #f))
           (set! (-> self last-moved-time) (+ (current-time) (seconds 24)))
           )
         )
        (else
          (set-time! (-> self last-moved-time))
          )
        )
      )
    )
  :code (behavior ()
    (sig-pilot-wcar-anim-loop)
    (sleep-code)
    )
  :post ja-post
  )

;; failed to figure out what this is:
(defstate die (sig-rider)
  :virtual #t
  :code (behavior ()
    (cleanup-for-death self)
    )
  )

;; definition for method 10 of type sig-rider
(defmethod deactivate ((this sig-rider))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (call-parent-method this)
  (none)
  )

;; definition for function sig-rider-init-by-other
;; INFO: Used lq/sq
(defbehavior sig-rider-init-by-other sig-rider ((arg0 vehicle) (arg1 symbol))
  (let ((s4-0 (new 'process 'collide-shape self (collide-list-enum hit-by-player))))
    (set! (-> s4-0 penetrated-by) (the-as penetrate -1))
    (let ((v1-3 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-3 transform-index) 3)
      (set-vector! (-> v1-3 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-3)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-6 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-6 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-6 prim-core collide-with))
      )
    (set! (-> self root) s4-0)
    )
  (set! (-> self root trans quad) (-> arg0 root trans quad))
  (quaternion-copy! (-> self root quat) (-> arg0 root quat))
  (set! (-> self level) (level-get *level* 'lwassig))
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sig-rider" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (logclear! (-> self mask) (process-mask actor-pause))
  (let ((a1-9 (get-best-seat arg0 (-> self root trans) (vehicle-seat-flag vsf1) 0)))
    (when (!= a1-9 -1)
      (put-rider-in-seat arg0 a1-9 self)
      (logior! (-> self focus-status) (focus-status pilot-riding))
      )
    )
  (set! (-> self complain-time) 0)
  (set-time! (-> self last-moved-time))
  (if arg1
      (send-event
        arg0
        'attack
        #f
        (static-attack-info
          :mask (vehicle-impulse-factor)
          ((id (new-attack-id)) (damage 2.0) (vehicle-damage-factor 0.0) (vehicle-impulse-factor 0.0))
          )
        )
      )
  (go-virtual idle)
  )

;; definition for function sig-rider-spawn
;; WARN: Return type mismatch process vs sig-rider.
(defun sig-rider-spawn ((arg0 vehicle) (arg1 symbol))
  (let ((s4-0 (the-as process #f)))
    (when (= (status-of-level-and-borrows *level* 'lwassig #f) 'active)
      (dotimes (s4-1 4)
        (let ((s3-1 (get-rider-in-seat arg0 s4-1)))
          (when (type? s3-1 sig-rider)
            (set! s4-0 s3-1)
            (goto cfg-8)
            )
          )
        )
      (set! s4-0 (the-as process #f))
      (label cfg-8)
      (when (not s4-0)
        (let ((v1-9 (process-spawn sig-rider arg0 arg1 :name "sig-rider" :to arg0)))
          (if v1-9
              (set! s4-0 (-> v1-9 0))
              )
          )
        )
      )
    (the-as sig-rider s4-0)
    )
  )
