;;-*-Lisp-*-
(in-package goal)

;; definition of type kernel-context
(deftype kernel-context (basic)
  ((prevent-from-run   process-mask  :offset-assert   4)
   (require-for-run    process-mask  :offset-assert   8)
   (allow-to-run       process-mask  :offset-assert  12)
   (next-pid           int32         :offset-assert  16)
   (fast-stack-top     pointer       :offset-assert  20)
   (current-process    process       :offset-assert  24)
   (relocating-process basic         :offset-assert  28)
   (relocating-min     int32         :offset-assert  32)
   (relocating-max     int32         :offset-assert  36)
   (relocating-offset  int32         :offset-assert  40)
   (relocating-level   level         :offset-assert  44)
   (low-memory-message symbol        :offset-assert  48)
   (login-object       basic         :offset-assert  52)
   )
  :method-count-assert 9
  :size-assert         #x38
  :flag-assert         #x900000038
  )

;; definition for method 3 of type kernel-context
(defmethod inspect kernel-context ((obj kernel-context))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" obj (-> obj type))
  (format #t "~1Tprevent-from-run: ~D~%" (-> obj prevent-from-run))
  (format #t "~1Trequire-for-run: ~D~%" (-> obj require-for-run))
  (format #t "~1Tallow-to-run: ~D~%" (-> obj allow-to-run))
  (format #t "~1Tnext-pid: ~D~%" (-> obj next-pid))
  (format #t "~1Tfast-stack-top: #x~X~%" (-> obj fast-stack-top))
  (format #t "~1Tcurrent-process: ~A~%" (-> obj current-process))
  (format #t "~1Trelocating-process: ~A~%" (-> obj relocating-process))
  (format #t "~1Trelocating-min: #x~X~%" (-> obj relocating-min))
  (format #t "~1Trelocating-max: #x~X~%" (-> obj relocating-max))
  (format #t "~1Trelocating-offset: ~D~%" (-> obj relocating-offset))
  (format #t "~1Trelocating-level: ~A~%" (-> obj relocating-level))
  (format #t "~1Tlow-memory-message: ~A~%" (-> obj low-memory-message))
  (format #t "~1Tlogin-object: ~A~%" (-> obj login-object))
  (label cfg-4)
  obj
  )

;; definition of type time-frame
(deftype time-frame (int64)
  ()
  :method-count-assert 9
  :size-assert         #x8
  :flag-assert         #x900000008
  )

;; definition of type clock
(deftype clock (basic)
  ((index                      int32                :offset-assert   4)
   (mask                       process-mask         :offset-assert   8)
   (clock-ratio                float                :offset-assert  12)
   (accum                      float                :offset-assert  16)
   (integral-accum             float                :offset-assert  20)
   (frame-counter              time-frame           :offset-assert  24)
   (old-frame-counter          time-frame           :offset-assert  32)
   (integral-frame-counter     uint64               :offset-assert  40)
   (old-integral-frame-counter uint64               :offset-assert  48)
   (sparticle-data             vector       :inline :offset-assert  64)
   (seconds-per-frame          float                :offset-assert  80)
   (frames-per-second          float                :offset-assert  84)
   (time-adjust-ratio          float                :offset-assert  88)
   )
  :method-count-assert 15
  :size-assert         #x5c
  :flag-assert         #xf0000005c
  (:methods
    (new (symbol type int) _type_ 0)
    (update-rates! (_type_ float) float 9)
    (advance-by! (_type_ float) clock 10)
    (tick! (_type_) clock 11)
    (save! (_type_ (pointer uint64)) int 12)
    (load! (_type_ (pointer uint64)) int 13)
    (reset! (_type_) none 14)
    )
  )

;; definition for method 3 of type clock
(defmethod inspect clock ((obj clock))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" obj (-> obj type))
  (format #t "~1Tindex: ~D~%" (-> obj index))
  (format #t "~1Tmask: ~D~%" (-> obj mask))
  (format #t "~1Tclock-ratio: ~f~%" (-> obj clock-ratio))
  (format #t "~1Taccum: ~f~%" (-> obj accum))
  (format #t "~1Tintegral-accum: ~f~%" (-> obj integral-accum))
  (format #t "~1Tframe-counter: ~D~%" (-> obj frame-counter))
  (format #t "~1Told-frame-counter: ~D~%" (-> obj old-frame-counter))
  (format #t "~1Tintegral-frame-counter: ~D~%" (-> obj integral-frame-counter))
  (format #t "~1Told-integral-frame-counter: ~D~%" (-> obj old-integral-frame-counter))
  (format #t "~1Tsparticle-data: ~`vector`P~%" (-> obj sparticle-data))
  (format #t "~1Tseconds-per-frame: ~f~%" (-> obj seconds-per-frame))
  (format #t "~1Tframes-per-second: ~f~%" (-> obj frames-per-second))
  (format #t "~1Ttime-adjust-ratio: ~f~%" (-> obj time-adjust-ratio))
  (label cfg-4)
  obj
  )

;; definition for method 0 of type clock
(defmethod new clock ((allocation symbol) (type-to-make type) (arg0 int))
  (let ((gp-0 (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> gp-0 index) arg0)
    (set! (-> gp-0 frame-counter) (seconds 1000))
    (set! (-> gp-0 integral-frame-counter) (the-as uint #x493e0))
    (set! (-> gp-0 old-frame-counter) (+ (-> gp-0 frame-counter) -1))
    (set! (-> gp-0 old-integral-frame-counter) (+ (-> gp-0 integral-frame-counter) -1))
    (update-rates! gp-0 1.0)
    gp-0
    )
  )

;; definition of type thread
(deftype thread (basic)
  ((name         symbol                      :offset-assert   4)
   (process      process                     :offset-assert   8)
   (previous     thread                      :offset-assert  12)
   (suspend-hook (function cpu-thread none)  :offset-assert  16)
   (resume-hook  (function cpu-thread none)  :offset-assert  20)
   (pc           pointer                     :offset-assert  24)
   (sp           pointer                     :offset-assert  28)
   (stack-top    pointer                     :offset-assert  32)
   (stack-size   int32                       :offset-assert  36)
   )
  :method-count-assert 12
  :size-assert         #x28
  :flag-assert         #xc00000028
  (:methods
    (stack-size-set! (_type_ int) none 9)
    (thread-suspend (_type_) none 10)
    (thread-resume (_type_) none 11)
    )
  )

;; definition for method 3 of type thread
(defmethod inspect thread ((obj thread))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" obj (-> obj type))
  (format #t "~1Tname: ~A~%" (-> obj name))
  (format #t "~1Tprocess: ~A~%" (-> obj process))
  (format #t "~1Tprevious: ~A~%" (-> obj previous))
  (format #t "~1Tsuspend-hook: ~A~%" (-> obj suspend-hook))
  (format #t "~1Tresume-hook: ~A~%" (-> obj resume-hook))
  (format #t "~1Tpc: #x~X~%" (-> obj pc))
  (format #t "~1Tsp: #x~X~%" (-> obj sp))
  (format #t "~1Tstack-top: #x~X~%" (-> obj stack-top))
  (format #t "~1Tstack-size: ~D~%" (-> obj stack-size))
  (label cfg-4)
  obj
  )

;; definition of type cpu-thread
(deftype cpu-thread (thread)
  ((rreg  uint64 7        :offset-assert  40)
   (freg  float  8        :offset-assert  96)
   (stack uint8  :dynamic :offset-assert 128)
   )
  :method-count-assert 12
  :size-assert         #x80
  :flag-assert         #xc00000080
  (:methods
    (new (symbol type process symbol int pointer) _type_ 0)
    )
  )

;; definition for method 3 of type cpu-thread
(defmethod inspect cpu-thread ((obj cpu-thread))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" obj (-> obj type))
  (format #t "~1Tname: ~A~%" (-> obj name))
  (format #t "~1Tprocess: ~A~%" (-> obj process))
  (format #t "~1Tprevious: ~A~%" (-> obj previous))
  (format #t "~1Tsuspend-hook: ~A~%" (-> obj suspend-hook))
  (format #t "~1Tresume-hook: ~A~%" (-> obj resume-hook))
  (format #t "~1Tpc: #x~X~%" (-> obj pc))
  (format #t "~1Tsp: #x~X~%" (-> obj sp))
  (format #t "~1Tstack-top: #x~X~%" (-> obj stack-top))
  (format #t "~1Tstack-size: ~D~%" (-> obj stack-size))
  (format #t "~1Trreg[8] @ #x~X~%" (-> obj rreg))
  (format #t "~1Tfreg[6] @ #x~X~%" (&-> obj freg 2))
  (format #t "~1Tstack[0] @ #x~X~%" (-> obj stack))
  (label cfg-4)
  obj
  )

;; definition of type dead-pool
(deftype dead-pool (process-tree)
  ()
  :method-count-assert 16
  :size-assert         #x24
  :flag-assert         #x1000000024
  (:methods
    (new (symbol type int int string) _type_ 0)
    (get-process (_type_ type int) process 14)
    (return-process (_type_ process) none 15)
    )
  )

;; definition for method 3 of type dead-pool
(defmethod inspect dead-pool ((obj dead-pool))
  (when (not obj)
    (set! obj obj)
    (goto cfg-68)
    )
  (format #t "[~8x] ~A~%" obj (-> obj type))
  (format #t "~1Tname: ~A~%" (-> obj name))
  (format #t "~1Tmask: #x~X : (process-mask " (-> obj mask))
  (let ((s5-0 (-> obj mask)))
    (if (= (logand s5-0 (process-mask process-tree)) (process-mask process-tree))
        (format #t "process-tree ")
        )
    (if (= (logand s5-0 (process-mask target)) (process-mask target))
        (format #t "target ")
        )
    (if (= (logand (process-mask collectable) s5-0) (process-mask collectable))
        (format #t "attackable ")
        )
    (if (= (logand (process-mask bit18) s5-0) (process-mask bit18))
        (format #t "collectable ")
        )
    (if (= (logand (process-mask projectile) s5-0) (process-mask projectile))
        (format #t "projectile ")
        )
    (if (= (logand (process-mask no-track) s5-0) (process-mask no-track))
        (format #t "no-track ")
        )
    (if (= (logand s5-0 (process-mask sleep-code)) (process-mask sleep-code))
        (format #t "sleep-code ")
        )
    (if (= (logand s5-0 (process-mask actor-pause)) (process-mask actor-pause))
        (format #t "actor-pause ")
        )
    (if (= (logand (process-mask bot) s5-0) (process-mask bot))
        (format #t "bot ")
        )
    (if (= (logand (process-mask vehicle) s5-0) (process-mask vehicle))
        (format #t "vehicle ")
        )
    (if (= (logand (process-mask enemy) s5-0) (process-mask enemy))
        (format #t "enemy ")
        )
    (if (= (logand (process-mask entity) s5-0) (process-mask entity))
        (format #t "entity ")
        )
    (if (= (logand s5-0 (process-mask heap-shrunk)) (process-mask heap-shrunk))
        (format #t "heap-shrunk ")
        )
    (if (= (logand (process-mask sidekick) s5-0) (process-mask sidekick))
        (format #t "sidekick ")
        )
    (if (= (logand s5-0 (process-mask going)) (process-mask going))
        (format #t "going ")
        )
    (if (= (logand s5-0 (process-mask execute)) (process-mask execute))
        (format #t "execute ")
        )
    (if (= (logand (process-mask civilian) s5-0) (shl #x8000 16))
        (format #t "civilian ")
        )
    (if (= (logand (process-mask death) s5-0) (process-mask death))
        (format #t "death ")
        )
    (if (= (logand (process-mask guard) s5-0) (process-mask guard))
        (format #t "guard ")
        )
    (if (= (logand s5-0 (process-mask no-kill)) (process-mask no-kill))
        (format #t "no-kill ")
        )
    (if (= (logand (process-mask platform) s5-0) (process-mask platform))
        (format #t "platform ")
        )
    (if (= (logand s5-0 (process-mask freeze)) (process-mask freeze))
        (format #t "freeze ")
        )
    (if (= (logand s5-0 (process-mask sleep)) (process-mask sleep))
        (format #t "sleep ")
        )
    (if (= (logand s5-0 (process-mask progress)) (process-mask progress))
        (format #t "progress ")
        )
    (if (= (logand s5-0 (process-mask menu)) (process-mask menu))
        (format #t "menu ")
        )
    (if (= (logand (process-mask camera) s5-0) (process-mask camera))
        (format #t "camera ")
        )
    (if (= (logand (process-mask ambient) s5-0) (process-mask ambient))
        (format #t "ambient ")
        )
    (if (= (logand s5-0 (process-mask dark-effect)) (process-mask dark-effect))
        (format #t "dark-effect ")
        )
    (if (= (logand (process-mask crate) s5-0) (process-mask crate))
        (format #t "crate ")
        )
    (if (= (logand s5-0 (process-mask kernel-run)) (process-mask kernel-run))
        (format #t "kernel-run ")
        )
    (if (= (logand s5-0 (process-mask movie)) (process-mask movie))
        (format #t "movie ")
        )
    (if (= (logand s5-0 (process-mask pause)) (process-mask pause))
        (format #t "pause ")
        )
    )
  (format #t ")~%")
  (format #t "~1Tclock: ~A~%" (-> obj clock))
  (format #t "~1Tparent: #x~X~%" (-> obj parent))
  (format #t "~1Tbrother: #x~X~%" (-> obj brother))
  (format #t "~1Tchild: #x~X~%" (-> obj child))
  (format #t "~1Tppointer: #x~X~%" (-> obj ppointer))
  (format #t "~1Tself: ~A~%" (-> obj self))
  (label cfg-68)
  obj
  )

;; definition of type dead-pool-heap-rec
(deftype dead-pool-heap-rec (structure)
  ((process process             :offset-assert   0)
   (prev    dead-pool-heap-rec  :offset-assert   4)
   (next    dead-pool-heap-rec  :offset-assert   8)
   )
  :pack-me
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )

;; definition for method 3 of type dead-pool-heap-rec
(defmethod inspect dead-pool-heap-rec ((obj dead-pool-heap-rec))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" obj 'dead-pool-heap-rec)
  (format #t "~1Tprocess: ~A~%" (-> obj process))
  (format #t "~1Tprev: #<dead-pool-heap-rec @ #x~X>~%" (-> obj prev))
  (format #t "~1Tnext: #<dead-pool-heap-rec @ #x~X>~%" (-> obj next))
  (label cfg-4)
  obj
  )

;; definition of type dead-pool-heap
(deftype dead-pool-heap (dead-pool)
  ((allocated-length   int32                               :offset-assert  36)
   (compact-time       uint32                              :offset-assert  40)
   (compact-count-targ uint32                              :offset-assert  44)
   (compact-count      uint32                              :offset-assert  48)
   (fill-percent       float                               :offset-assert  52)
   (first-gap          dead-pool-heap-rec                  :offset-assert  56)
   (first-shrink       dead-pool-heap-rec                  :offset-assert  60)
   (heap               kheap              :inline          :offset-assert  64)
   (alive-list         dead-pool-heap-rec :inline          :offset-assert  80)
   (last               dead-pool-heap-rec                  :offset         84)
   (dead-list          dead-pool-heap-rec :inline          :offset-assert  92)
   (process-list       dead-pool-heap-rec :inline :dynamic :offset-assert 104)
   )
  :method-count-assert 28
  :size-assert         #x68
  :flag-assert         #x1c00000068
  (:methods
    (new (symbol type string int int) _type_ 0)
    (init (_type_ symbol int) none 16)
    (compact (dead-pool-heap int) none 17)
    (shrink-heap (dead-pool-heap process) dead-pool-heap 18)
    (churn (dead-pool-heap int) none 19)
    (memory-used (_type_) int 20)
    (memory-total (_type_) int 21)
    (memory-free (dead-pool-heap) int 22)
    (compact-time (dead-pool-heap) uint 23)
    (gap-size (dead-pool-heap dead-pool-heap-rec) int 24)
    (gap-location (dead-pool-heap dead-pool-heap-rec) pointer 25)
    (find-gap (dead-pool-heap dead-pool-heap-rec) dead-pool-heap-rec 26)
    (find-gap-by-size (dead-pool-heap int) dead-pool-heap-rec 27)
    )
  )

;; definition for method 3 of type dead-pool-heap
;; INFO: this function exists in multiple non-identical object files
(defmethod inspect dead-pool-heap ((obj dead-pool-heap))
  (when (not obj)
    (set! obj obj)
    (goto cfg-68)
    )
  (format #t "[~8x] ~A~%" obj (-> obj type))
  (format #t "~1Tname: ~A~%" (-> obj name))
  (format #t "~1Tmask: #x~X : (process-mask " (-> obj mask))
  (let ((s5-0 (-> obj mask)))
    (if (= (logand s5-0 (process-mask process-tree)) (process-mask process-tree))
        (format #t "process-tree ")
        )
    (if (= (logand s5-0 (process-mask target)) (process-mask target))
        (format #t "target ")
        )
    (if (= (logand (process-mask collectable) s5-0) (process-mask collectable))
        (format #t "attackable ")
        )
    (if (= (logand (process-mask bit18) s5-0) (process-mask bit18))
        (format #t "collectable ")
        )
    (if (= (logand (process-mask projectile) s5-0) (process-mask projectile))
        (format #t "projectile ")
        )
    (if (= (logand (process-mask no-track) s5-0) (process-mask no-track))
        (format #t "no-track ")
        )
    (if (= (logand s5-0 (process-mask sleep-code)) (process-mask sleep-code))
        (format #t "sleep-code ")
        )
    (if (= (logand s5-0 (process-mask actor-pause)) (process-mask actor-pause))
        (format #t "actor-pause ")
        )
    (if (= (logand (process-mask bot) s5-0) (process-mask bot))
        (format #t "bot ")
        )
    (if (= (logand (process-mask vehicle) s5-0) (process-mask vehicle))
        (format #t "vehicle ")
        )
    (if (= (logand (process-mask enemy) s5-0) (process-mask enemy))
        (format #t "enemy ")
        )
    (if (= (logand (process-mask entity) s5-0) (process-mask entity))
        (format #t "entity ")
        )
    (if (= (logand s5-0 (process-mask heap-shrunk)) (process-mask heap-shrunk))
        (format #t "heap-shrunk ")
        )
    (if (= (logand (process-mask sidekick) s5-0) (process-mask sidekick))
        (format #t "sidekick ")
        )
    (if (= (logand s5-0 (process-mask going)) (process-mask going))
        (format #t "going ")
        )
    (if (= (logand s5-0 (process-mask execute)) (process-mask execute))
        (format #t "execute ")
        )
    (if (= (logand (process-mask civilian) s5-0) (shl #x8000 16))
        (format #t "civilian ")
        )
    (if (= (logand (process-mask death) s5-0) (process-mask death))
        (format #t "death ")
        )
    (if (= (logand (process-mask guard) s5-0) (process-mask guard))
        (format #t "guard ")
        )
    (if (= (logand s5-0 (process-mask no-kill)) (process-mask no-kill))
        (format #t "no-kill ")
        )
    (if (= (logand (process-mask platform) s5-0) (process-mask platform))
        (format #t "platform ")
        )
    (if (= (logand s5-0 (process-mask freeze)) (process-mask freeze))
        (format #t "freeze ")
        )
    (if (= (logand s5-0 (process-mask sleep)) (process-mask sleep))
        (format #t "sleep ")
        )
    (if (= (logand s5-0 (process-mask progress)) (process-mask progress))
        (format #t "progress ")
        )
    (if (= (logand s5-0 (process-mask menu)) (process-mask menu))
        (format #t "menu ")
        )
    (if (= (logand (process-mask camera) s5-0) (process-mask camera))
        (format #t "camera ")
        )
    (if (= (logand (process-mask ambient) s5-0) (process-mask ambient))
        (format #t "ambient ")
        )
    (if (= (logand s5-0 (process-mask dark-effect)) (process-mask dark-effect))
        (format #t "dark-effect ")
        )
    (if (= (logand (process-mask crate) s5-0) (process-mask crate))
        (format #t "crate ")
        )
    (if (= (logand s5-0 (process-mask kernel-run)) (process-mask kernel-run))
        (format #t "kernel-run ")
        )
    (if (= (logand s5-0 (process-mask movie)) (process-mask movie))
        (format #t "movie ")
        )
    (if (= (logand s5-0 (process-mask pause)) (process-mask pause))
        (format #t "pause ")
        )
    )
  (format #t ")~%")
  (format #t "~1Tclock: ~A~%" (-> obj clock))
  (format #t "~1Tparent: #x~X~%" (-> obj parent))
  (format #t "~1Tbrother: #x~X~%" (-> obj brother))
  (format #t "~1Tchild: #x~X~%" (-> obj child))
  (format #t "~1Tppointer: #x~X~%" (-> obj ppointer))
  (format #t "~1Tself: ~A~%" (-> obj self))
  (format #t "~1Tallocated-length: ~D~%" (-> obj allocated-length))
  (format #t "~1Tcompact-time: ~D~%" (-> obj compact-time))
  (format #t "~1Tcompact-count-targ: ~D~%" (-> obj compact-count-targ))
  (format #t "~1Tcompact-count: ~D~%" (-> obj compact-count))
  (format #t "~1Tfill-percent: ~f~%" (-> obj fill-percent))
  (format #t "~1Tfirst-gap: #<dead-pool-heap-rec @ #x~X>~%" (-> obj first-gap))
  (format #t "~1Tfirst-shrink: #<dead-pool-heap-rec @ #x~X>~%" (-> obj first-shrink))
  (format #t "~1Theap: #<kheap @ #x~X>~%" (-> obj heap))
  (format #t "~1Talive-list: #<dead-pool-heap-rec @ #x~X>~%" (-> obj alive-list))
  (format #t "~1Tlast: #<dead-pool-heap-rec @ #x~X>~%" (-> obj alive-list prev))
  (format #t "~1Tdead-list: #<dead-pool-heap-rec @ #x~X>~%" (-> obj dead-list))
  (format #t "~1Tprocess-list[0] @ #x~X~%" (-> obj process-list))
  (label cfg-68)
  obj
  )

;; definition of type catch-frame
(deftype catch-frame (stack-frame)
  ((sp   int32      :offset-assert  12)
   (ra   int32      :offset-assert  16)
   (freg float   10 :offset-assert  20)
   (rreg uint128 7  :offset-assert  64)
   )
  :method-count-assert 9
  :size-assert         #xb0
  :flag-assert         #x9000000b0
  (:methods
    (new (symbol type symbol function (pointer uint64)) object 0)
    )
  )

;; definition for method 3 of type catch-frame
(defmethod inspect catch-frame ((obj catch-frame))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" obj (-> obj type))
  (format #t "~1Tname: ~A~%" (-> obj name))
  (format #t "~1Tnext: ~A~%" (-> obj next))
  (format #t "~1Tsp: #x~X~%" (-> obj sp))
  (format #t "~1Tra: #x~X~%" (-> obj ra))
  (format #t "~1Tfreg[6] @ #x~X~%" (-> obj freg))
  (format #t "~1Trreg[8] @ #x~X~%" (&-> obj freg 7))
  (label cfg-4)
  obj
  )

;; definition of type protect-frame
(deftype protect-frame (stack-frame)
  ((exit (function none)  :offset-assert  12)
   )
  :method-count-assert 9
  :size-assert         #x10
  :flag-assert         #x900000010
  (:methods
    (new (symbol type (function none)) protect-frame 0)
    )
  )

;; definition for method 3 of type protect-frame
(defmethod inspect protect-frame ((obj protect-frame))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" obj (-> obj type))
  (format #t "~1Tname: ~A~%" (-> obj name))
  (format #t "~1Tnext: ~A~%" (-> obj next))
  (format #t "~1Texit: ~A~%" (-> obj exit))
  (label cfg-4)
  obj
  )

;; definition of type handle
(deftype handle (uint64)
  ((process (pointer process) :offset   0 :size  32)
   (pid     int32             :offset  32 :size  32)
   (u64     uint64            :offset   0 :size  64)
   )
  :method-count-assert 9
  :size-assert         #x8
  :flag-assert         #x900000008
  )

;; definition for method 3 of type handle
(defmethod inspect handle ((obj handle))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" obj 'handle)
  (format #t "~1Tprocess: #x~X~%" (-> obj process))
  (format #t "~1Tpid: ~D~%" (-> obj pid))
  (label cfg-4)
  obj
  )

;; definition for method 2 of type handle
(defmethod print handle ((obj handle))
  (if (nonzero? obj)
      (format #t "#<handle :process ~A :pid ~D>" (handle->process obj) (-> obj pid))
      (format #t "#<handle :process 0 :pid 0>")
      )
  obj
  )

;; definition of type state
(deftype state (protect-frame)
  ((code  function                                                  :offset-assert  16)
   (trans (function none)                                           :offset-assert  20)
   (post  function                                                  :offset-assert  24)
   (enter function                                                  :offset-assert  28)
   (event (function process int symbol event-message-block object)  :offset-assert  32)
   )
  :method-count-assert 9
  :size-assert         #x24
  :flag-assert         #x900000024
  (:methods
    (new (symbol type symbol function (function none) function (function none) (function process int symbol event-message-block object)) _type_ 0)
    )
  )

;; definition for method 3 of type state
(defmethod inspect state ((obj state))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" obj (-> obj type))
  (format #t "~1Tname: ~A~%" (-> obj name))
  (format #t "~1Tnext: ~A~%" (-> obj next))
  (format #t "~1Texit: ~A~%" (-> obj exit))
  (format #t "~1Tcode: ~A~%" (-> obj code))
  (format #t "~1Ttrans: ~A~%" (-> obj trans))
  (format #t "~1Tpost: ~A~%" (-> obj post))
  (format #t "~1Tenter: ~A~%" (-> obj enter))
  (format #t "~1Tevent: ~A~%" (-> obj event))
  (label cfg-4)
  obj
  )

;; definition of type event-message-block
(deftype event-message-block (structure)
  ((to-handle   handle              :offset-assert   0)
   (to          (pointer process)   :offset          0)
   (form-handle handle              :offset-assert   8)
   (from        (pointer process)   :offset          8)
   (param       uint64            6 :offset-assert  16)
   (message     symbol              :offset-assert  64)
   (num-params  int32               :offset-assert  68)
   )
  :method-count-assert 9
  :size-assert         #x48
  :flag-assert         #x900000048
  )

;; definition for method 3 of type event-message-block
(defmethod inspect event-message-block ((obj event-message-block))
  (when (not obj)
    (set! obj obj)
    (goto cfg-8)
    )
  (format #t "[~8x] ~A~%" obj 'event-message-block)
  (format #t "~1Tto-handle: ~D~%" (-> obj to-handle))
  (format #t "~1Tto: ~A~%" (ppointer->process (-> obj to)))
  (format #t "~1Tfrom-handle: ~D~%" (-> obj form-handle))
  (format #t "~1Tfrom: ~A~%" (ppointer->process (-> obj from)))
  (format #t "~1Tparam[6] @ #x~X~%" (-> obj param))
  (format #t "~1Tmessage: ~A~%" (-> obj message))
  (format #t "~1Tnum-params: ~D~%" (-> obj num-params))
  (label cfg-8)
  obj
  )

;; definition of type event-message-block-array
(deftype event-message-block-array (inline-array-class)
  ((data event-message-block :inline :dynamic :offset-assert  16)
   )
  :method-count-assert 10
  :size-assert         #x10
  :flag-assert         #xa00000010
  (:methods
    (send-all! (_type_) none 9)
    )
  )

;; definition for method 3 of type event-message-block-array
(defmethod inspect event-message-block-array ((obj event-message-block-array))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" obj (-> obj type))
  (format #t "~1Tlength: ~D~%" (-> obj length))
  (format #t "~1Tallocated-length: ~D~%" (-> obj allocated-length))
  (format #t "~1Tdata[0] @ #x~X~%" (-> obj data))
  (label cfg-4)
  obj
  )

;; failed to figure out what this is:
(set! (-> event-message-block-array heap-base) (the-as uint 80))

;; definition of type sql-result
(deftype sql-result (basic)
  ((len              int32           :offset-assert   4)
   (allocated-length uint32          :offset-assert   8)
   (error            symbol          :offset-assert  12)
   (data             symbol :dynamic :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x10
  :flag-assert         #x900000010
  (:methods
    (new (symbol type uint) _type_ 0)
    )
  )

;; definition for method 0 of type sql-result
(defmethod new sql-result ((allocation symbol) (type-to-make type) (arg0 uint))
  (let ((v0-0 (object-new allocation type-to-make (the-as int (+ (-> type-to-make size) (* arg0 4))))))
    (set! (-> v0-0 allocated-length) arg0)
    (set! (-> v0-0 error) 'error)
    v0-0
    )
  )

;; definition for method 2 of type sql-result
(defmethod print sql-result ((obj sql-result))
  (format #t "#(~A" (-> obj error))
  (dotimes (s5-0 (-> obj len))
    (format #t " ~A" (-> obj data s5-0))
    )
  (format #t ")")
  obj
  )

;; definition for symbol *sql-result*, type sql-result
(define *sql-result* (the-as sql-result #f))

;; failed to figure out what this is:
0
