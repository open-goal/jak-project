;;-*-Lisp-*-
(in-package goal)

;; definition of type security-wall
(deftype security-wall (process-drawable)
  ((root                collide-shape :override)
   (pass                int32)
   (incoming-attack-id  uint32)
   (next-message-time   int64)
   (message             int32)
   (plane               plane          :inline)
   (color               vector         :inline)
   (target-pos          vector         :inline)
   (flash               float)
   (touch-count         int32)
   (breach              symbol)
   )
  (:state-methods
    idle-open
    idle-close
    )
  (:methods
    (security-wall-method-22 (_type_ path-control float) vector)
    (security-wall-method-23 (_type_) none)
    (security-wall-method-24 (_type_) none)
    )
  )

;; definition for method 3 of type security-wall
(defmethod inspect ((this security-wall))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tpass: ~D~%" (-> this pass))
  (format #t "~2Tincoming-attack-id: ~D~%" (-> this incoming-attack-id))
  (format #t "~2Tnext-message-time: ~D~%" (-> this next-message-time))
  (format #t "~2Tmessage: ~D~%" (-> this message))
  (format #t "~2Tplane: #<plane @ #x~X>~%" (-> this plane))
  (format #t "~2Tcolor: #<vector @ #x~X>~%" (-> this color))
  (format #t "~2Ttarget-pos: #<vector @ #x~X>~%" (-> this target-pos))
  (format #t "~2Tflash: ~f~%" (-> this flash))
  (format #t "~2Ttouch-count: ~D~%" (-> this touch-count))
  (format #t "~2Tbreach: ~A~%" (-> this breach))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-security-wall security-wall security-wall-lod0-jg security-wall-idle-ja
              ((security-wall-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 100.1)
              )

;; definition for method 23 of type security-wall
;; WARN: Return type mismatch int vs none.
(defmethod security-wall-method-23 ((this security-wall))
  (when (< (-> this next-message-time) (current-time))
    (set! (-> this next-message-time)
          (the-as int (+ (current-time) (the int (* 300.0 (rand-vu-float-range 2.0 5.0)))))
          )
    (let ((v1-6 (rand-vu-int-count 15)))
      (cond
        ((zero? v1-6)
         (case (-> this pass)
           ((29)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv015" -99.0 0)
            )
           ((30)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv016" -99.0 0)
            )
           ((31)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv017" -99.0 0)
            )
           ((32)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv018" -99.0 0)
            )
           )
         )
        ((= v1-6 1)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv011" -99.0 0)
         )
        ((= v1-6 2)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         )
        ((= v1-6 3)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv013" -99.0 0)
         )
        ((= v1-6 4)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         )
        ((= v1-6 5)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv011" -99.0 0)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         )
        ((= v1-6 6)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv011" -99.0 0)
         )
        ((= v1-6 7)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv013" -99.0 0)
         )
        ((= v1-6 8)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         )
        ((= v1-6 9)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         )
        ((= v1-6 10)
         (let ((v1-45 (rand-vu-int-count 3)))
           (cond
             ((zero? v1-45)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv035" -99.0 0)
              )
             ((= v1-45 1)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv038" -99.0 0)
              )
             ((= v1-45 2)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv058" -99.0 0)
              )
             )
           )
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv013" -99.0 0)
         )
        ((= v1-6 11)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         (let ((v1-57 (rand-vu-int-count 3)))
           (cond
             ((zero? v1-57)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv035" -99.0 0)
              )
             ((= v1-57 1)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv038" -99.0 0)
              )
             ((= v1-57 2)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv058" -99.0 0)
              )
             )
           )
         )
        ((= v1-6 12)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         (case (-> this pass)
           ((29)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv015" -99.0 0)
            )
           ((30)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv016" -99.0 0)
            )
           ((31)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv017" -99.0 0)
            )
           ((32)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv018" -99.0 0)
            )
           )
         )
        ((= v1-6 13)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv011" -99.0 0)
         (case (-> this pass)
           ((29)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv015" -99.0 0)
            )
           ((30)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv016" -99.0 0)
            )
           ((31)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv017" -99.0 0)
            )
           ((32)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv018" -99.0 0)
            )
           )
         )
        ((= v1-6 14)
         (case (-> this pass)
           ((29)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv015" -99.0 0)
            )
           ((30)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv016" -99.0 0)
            )
           ((31)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv017" -99.0 0)
            )
           ((32)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv018" -99.0 0)
            )
           )
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv013" -99.0 0)
         )
        )
      )
    (+! (-> this message) 1)
    (when (>= (-> this message) 5)
      (set! (-> this message) 0)
      0
      )
    )
  0
  (none)
  )

;; definition for method 24 of type security-wall
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod security-wall-method-24 ((this security-wall))
  (let ((s4-0 *target*))
    (when s4-0
      (let* ((f0-0 (vector-vector-distance-squared (-> this root trans) (-> s4-0 control trans)))
             (f30-0 (+ 40960.0 (-> this root root-prim local-sphere w)))
             (f1-1 f30-0)
             )
        (when (< f0-0 (* f1-1 f1-1))
          (let ((s5-0 (new 'stack-no-clear 'inline-array 'vector 1)))
            (set! (-> s5-0 0 quad) (-> s4-0 control trans quad))
            (when (< (vector-vector-distance-squared (-> this root trans) (-> this target-pos)) (* f30-0 f30-0))
              (let ((f0-3 (vector4-dot (-> this target-pos) (the-as vector (-> this plane))))
                    (f1-7 (vector4-dot (-> s5-0 0) (the-as vector (-> this plane))))
                    )
                (if (and (< (fabs f1-7) 16384.0)
                         (< (fabs f0-3) 16384.0)
                         (or (and (< f0-3 0.0) (>= f1-7 0.0)) (and (< f1-7 0.0) (>= f0-3 0.0)))
                         )
                    (set! (-> this breach) #t)
                    )
                )
              )
            (set! (-> this target-pos quad) (-> s5-0 0 quad))
            )
          (when (-> this breach)
            (if (send-event *target* 'attack-invinc #f (static-attack-info ((id (new-attack-id)) (mode 'grenade))))
                (set! (-> this breach) #f)
                )
            )
          )
        )
      )
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate idle-close (security-wall)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (case message
        (('on)
         (let ((v1-2 (-> self root root-prim)))
           (set! (-> v1-2 prim-core collide-as) (-> self root backup-collide-as))
           (let ((v0-0 (the-as object (-> self root backup-collide-with))))
             (set! (-> v1-2 prim-core collide-with) (the-as collide-spec v0-0))
             v0-0
             )
           )
         )
        (('off)
         (let ((v1-4 (-> self root root-prim)))
           (set! (-> v1-4 prim-core collide-as) (collide-spec))
           (set! (-> v1-4 prim-core collide-with) (collide-spec))
           )
         0
         )
        (('attack)
         (let ((v1-5 (the-as object (-> block param 1))))
           (when (!= (-> (the-as attack-info v1-5) id) (-> self incoming-attack-id))
             (set! (-> self incoming-attack-id) (-> (the-as attack-info v1-5) id))
             (let* ((s5-0 proc)
                    (s3-0 (if (type? s5-0 process-drawable)
                              (the-as process-drawable s5-0)
                              )
                          )
                    )
               (when s3-0
                 (let ((s5-1 (process-spawn
                               manipy
                               :init manipy-init
                               (-> s3-0 root trans)
                               (-> self entity)
                               (art-group-get-by-name *level* "skel-generic-ripples" (the-as (pointer uint32) #f))
                               #f
                               0
                               :to self
                               )
                             )
                       )
                   (when s5-1
                     (send-event (ppointer->process s5-1) 'anim-mode 'play1)
                     (send-event (ppointer->process s5-1) 'speed 1.5)
                     (send-event (ppointer->process s5-1) 'art-joint-anim "generic-ripples-idle" 0)
                     (set-vector! (-> (the-as process-drawable (-> s5-1 0)) root scale) 1.0 1.0 1.0 1.0)
                     (quaternion-rotate-local-x! (-> (the-as process-drawable (-> s5-1 0)) root quat) (-> self root quat) -16384.0)
                     (let ((v1-45 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                       (let ((a0-29 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                         (let ((a1-11 *up-vector*))
                           (let ((a2-9 8192.0))
                             (.mov vf7 a2-9)
                             )
                           (.lvf vf5 (&-> a1-11 quad))
                           )
                         (.lvf vf4 (&-> a0-29 quad))
                         )
                       (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                       (.mul.x.vf acc vf5 vf7 :mask #b111)
                       (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                       (.svf (&-> v1-45 quad) vf6)
                       )
                     (let ((f0-6 (vector4-dot (-> (the-as process-drawable (-> s5-1 0)) root trans) (the-as vector (-> self plane)))))
                       (let ((v1-52 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                         (let ((a0-33 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                           (let ((a1-12 (-> self plane)))
                             (let ((a2-10 (- f0-6)))
                               (.mov vf7 a2-10)
                               )
                             (.lvf vf5 (&-> a1-12 quad))
                             )
                           (.lvf vf4 (&-> a0-33 quad))
                           )
                         (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                         (.mul.x.vf acc vf5 vf7 :mask #b111)
                         (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                         (.svf (&-> v1-52 quad) vf6)
                         )
                       (let ((v1-55 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                         (let ((a0-36 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                           (let ((a1-13 (-> self plane)))
                             (let ((a2-12 (the-as float (if (< 0.0 f0-6)
                                                            -989855744
                                                            #x45000000
                                                            )
                                                  )
                                          )
                                   )
                               (.mov vf7 a2-12)
                               )
                             (.lvf vf5 (&-> a1-13 quad))
                             )
                           (.lvf vf4 (&-> a0-36 quad))
                           )
                         (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                         (.mul.x.vf acc vf5 vf7 :mask #b111)
                         (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                         (.svf (&-> v1-55 quad) vf6)
                         )
                       )
                     (send-event (ppointer->process s5-1) 'trans-hook (lambda () #f))
                     )
                   )
                 )
               )
             (when (zero? (-> self touch-count))
               (+! (-> self touch-count) 1)
               (set! (-> self flash) 0.375)
               )
             (+! (-> self touch-count) 1)
             (if (and (logtest? (-> proc mask) (process-mask target))
                      (not (logtest? (process-mask projectile) (-> proc mask)))
                      )
                 (security-wall-method-23 self)
                 )
             )
           )
         )
        (('touched)
         (when (zero? (-> self touch-count))
           (+! (-> self touch-count) 1)
           (set! (-> self flash) 0.375)
           )
         (+! (-> self touch-count) 1)
         (let ((v1-83 (if (type? proc process-focusable)
                          (the-as process-focusable proc)
                          )
                      )
               )
           (when v1-83
             (let* ((gp-1 (-> v1-83 root))
                    (a0-45 (if (type? gp-1 collide-shape)
                               gp-1
                               )
                           )
                    )
               (if (and a0-45 (logtest? (-> a0-45 root-prim prim-core collide-as) (collide-spec jak)))
                   (security-wall-method-23 self)
                   )
               )
             )
           )
         )
        )
      )
    )
  :trans (behavior ()
    (security-wall-method-24 self)
    )
  )

;; failed to figure out what this is:
(defstate idle-open (security-wall)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('on)
       (let ((v1-2 (-> self root root-prim)))
         (set! (-> v1-2 prim-core collide-as) (-> self root backup-collide-as))
         (let ((v0-0 (the-as int (-> self root backup-collide-with))))
           (set! (-> v1-2 prim-core collide-with) (the-as collide-spec v0-0))
           v0-0
           )
         )
       )
      (('off)
       (let ((v1-4 (-> self root root-prim)))
         (set! (-> v1-4 prim-core collide-as) (collide-spec))
         (set! (-> v1-4 prim-core collide-with) (collide-spec))
         )
       0
       )
      )
    )
  :enter (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    )
  :trans (behavior ()
    (let* ((f28-0 (vector4-dot (the-as vector (-> self plane)) (target-pos 0)))
           (f30-0 (calc-fade-from-fog (-> self root trans)))
           (f28-1 (lerp-scale 0.0 1.0 (fabs f28-0) 163840.0 327680.0))
           (gp-1 (new 'stack-no-clear 'vector))
           )
      (when (= f28-1 0.0)
        (cleanup-for-death self)
        (deactivate self)
        )
      (let ((f0-3 (* f30-0 f28-1)))
        (vector-float*! gp-1 (-> self color) f0-3)
        )
      (set! (-> gp-1 w) 1.0)
      (set-security-color! gp-1)
      )
    )
  :code (behavior ()
    (until #f
      (suspend)
      )
    #f
    )
  )

;; definition for method 22 of type security-wall
;; INFO: Used lq/sq
(defmethod security-wall-method-22 ((this security-wall) (arg0 path-control) (arg1 float))
  (let ((s4-0 (new 'static 'vector))
        (s3-0 (new 'static 'vector))
        )
    0.0
    (get-point-in-path! arg0 s4-0 0.0 'exact)
    (get-point-in-path! arg0 s3-0 1.0 'exact)
    (* 0.5 (vector-vector-distance s4-0 s3-0))
    (let ((s2-1 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
      (let ((v1-7 (new 'process 'collide-shape-prim-mesh s2-1 (the-as uint 0) (the-as uint 0))))
        (set! (-> v1-7 prim-core collide-as) (collide-spec blocking-plane camera-blocker))
        (set! (-> v1-7 prim-core collide-with) (collide-spec jak player-list))
        (set! (-> v1-7 prim-core action) (collide-action solid))
        (set! (-> v1-7 transform-index) 3)
        (set! (-> s2-1 total-prims) (the-as uint 1))
        (set! (-> s2-1 root-prim) v1-7)
        )
      (set! (-> s2-1 nav-radius) (* 0.75 (-> s2-1 root-prim local-sphere w)))
      (let ((v1-10 (-> s2-1 root-prim)))
        (set! (-> s2-1 backup-collide-as) (-> v1-10 prim-core collide-as))
        (set! (-> s2-1 backup-collide-with) (-> v1-10 prim-core collide-with))
        )
      (set! (-> this root) s2-1)
      )
    (let ((s2-2 (new 'stack-no-clear 'matrix))
          (s1-0 (-> this root))
          )
      (vector+! (-> s1-0 trans) s4-0 s3-0)
      (vector-float*! (-> s1-0 trans) (-> s1-0 trans) 0.5)
      (+! (-> s1-0 trans y) (* 0.5 arg1))
      (vector-! (the-as vector (-> s2-2 vector)) s3-0 s4-0)
      (let ((f30-1 (vector-normalize-ret-len! (the-as vector (-> s2-2 vector)) 1.0)))
        (set! (-> s1-0 scale x) (* 0.00024414062 f30-1))
        (set! (-> s1-0 scale y) (* 0.00024414062 arg1))
        (set! (-> s1-0 scale z) 1.0)
        (set! (-> s2-2 vector 1 quad) (-> (new 'static 'vector :y 1.0 :w 1.0) quad))
        (vector-cross! (-> s2-2 vector 2) (the-as vector (-> s2-2 vector)) (-> s2-2 vector 1))
        (vector-normalize! (-> s2-2 vector 2) 1.0)
        (matrix->quaternion (-> s1-0 quat) s2-2)
        (set! (-> this plane quad) (-> s2-2 vector 2 quad))
        (set! (-> this plane w) (- (vector-dot (-> s2-2 vector 2) (-> this root trans))))
        (let ((v0-8 (-> this root root-prim local-sphere)))
          (set! (-> v0-8 x) 0.0)
          (set! (-> v0-8 y) (* 0.00024414062 (* 0.5 arg1)))
          (set! (-> v0-8 z) 0.0)
          (let ((f0-20 0.5)
                (f1-7 (* f30-1 f30-1))
                (f2-2 arg1)
                )
            (set! (-> v0-8 w) (* f0-20 (sqrtf (+ f1-7 (* f2-2 f2-2)))))
            )
          v0-8
          )
        )
      )
    )
  )

;; definition for method 11 of type security-wall
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this security-wall) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (ctywide-entity-hack)
  (set! (-> this breach) #f)
  (set! (-> this pass) (res-lump-value arg0 'pickup-type int :time -1000000000.0))
  (let ((v1-3 (new 'process 'path-control this 'path 0.0 (the-as entity #f) #f)))
    (set! (-> this path) v1-3)
    (if (or (not v1-3) (!= (-> v1-3 curve num-cverts) 2))
        (go process-drawable-art-error "bad path")
        )
    )
  (security-wall-method-22 this (-> this path) 122880.0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-security-wall" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this root event-self) 'touched)
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (logior! (-> this draw status) (draw-control-status disable-fog))
  (set-security-texture-masks! (the-as vector (-> this draw mgeo header texture-usage-group data 4)))
  (set-vector! (-> this color) 1.0 1.0 1.0 1.0)
  (cond
    ((= (-> this pass) 29)
     (set-vector! (-> this color) 1.0 0.0 0.0 1.0)
     )
    ((= (-> this pass) 31)
     (set-vector! (-> this color) 1.0 1.0 0.0 1.0)
     )
    ((= (-> this pass) 30)
     (set-vector! (-> this color) 0.0 1.0 0.0 1.0)
     )
    ((= (-> this pass) 32)
     (set-vector! (-> this color) 0.0 0.0 1.0 1.0)
     )
    )
  (set-security-color! (-> this color))
  (set-vector! (-> this draw color-mult) 0.0 0.0 0.0 0.0)
  (set-vector! (-> this draw color-emissive) 1.0 1.0 1.0 1.0)
  (transform-post)
  (if (or (and (logtest? (game-feature pass-red) (-> *game-info* features)) (= 29 (-> this pass)))
          (and (logtest? (game-feature pass-green) (-> *game-info* features)) (= 30 (-> this pass)))
          (and (logtest? (game-feature pass-yellow) (-> *game-info* features)) (= 31 (-> this pass)))
          (and (logtest? (game-feature pass-blue) (-> *game-info* features)) (= 32 (-> this pass)))
          )
      (go (method-of-object this idle-open))
      (go (method-of-object this idle-close))
      )
  (none)
  )

;; definition of type fruit-stand
(deftype fruit-stand (process-focusable)
  ((incoming-attack-id  uint32)
   (hack-counter        uint32)
   (count-sparts        uint32)
   (first-sparts        uint32)
   (num-sparts          uint32)
   (sparts-index        uint32  4)
   (sparts-pos          vector  4 :inline)
   )
  (:state-methods
    idle
    )
  (:methods
    (fruit-stand-method-28 (_type_) none)
    (fruit-stand-method-29 (_type_) none)
    )
  )

;; definition for method 3 of type fruit-stand
(defmethod inspect ((this fruit-stand))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-focusable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tincoming-attack-id: ~D~%" (-> this incoming-attack-id))
  (format #t "~2Thack-counter: ~D~%" (-> this hack-counter))
  (format #t "~2Tcount-sparts: ~D~%" (-> this count-sparts))
  (format #t "~2Tfirst-sparts: ~D~%" (-> this first-sparts))
  (format #t "~2Tnum-sparts: ~D~%" (-> this num-sparts))
  (format #t "~2Tsparts-index[4] @ #x~X~%" (-> this sparts-index))
  (format #t "~2Tsparts-pos[4] @ #x~X~%" (-> this sparts-pos))
  (label cfg-4)
  this
  )

;; definition for symbol *fruit-check-ground-counter*, type int
(define *fruit-check-ground-counter* 0)

;; definition for function fruit-check-ground-bounce
(defun fruit-check-ground-bounce ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo) (arg3 matrix))
  (let ((v1-1 (-> arg1 key proc))
        (f0-0 (-> arg1 user-float))
        )
    (when (and (>= (-> (the-as fruit-stand v1-1) count-sparts) (-> (the-as fruit-stand v1-1) first-sparts))
               (nonzero? (-> (the-as fruit-stand v1-1) hack-counter))
               )
      (set! (-> (the-as fruit-stand v1-1) sparts-index (-> (the-as fruit-stand v1-1) num-sparts))
            (the-as uint arg3)
            )
      (set-vector!
        (-> (the-as fruit-stand v1-1) sparts-pos (-> (the-as fruit-stand v1-1) num-sparts))
        (-> arg2 launchrot x)
        (-> arg2 launchrot y)
        (-> arg2 launchrot z)
        1.0
        )
      (+! (-> (the-as fruit-stand v1-1) num-sparts) 1)
      (+! (-> (the-as fruit-stand v1-1) hack-counter) -1)
      )
    (+! (-> (the-as fruit-stand v1-1) count-sparts) 1)
    (when (and (< (-> arg2 launchrot y) f0-0) (< (-> arg1 vel-sxvel y) 0.0))
      (set! (-> arg2 launchrot y) f0-0)
      (if (and (< (-> arg1 vel-sxvel y) -122.88) (< (rand-vu-int-count 10) 3))
          (set-vector!
            (new 'stack-no-clear 'vector)
            (-> arg2 launchrot x)
            (-> arg2 launchrot y)
            (-> arg2 launchrot z)
            1.0
            )
          )
      (set! (-> arg1 vel-sxvel y) (* (-> arg1 vel-sxvel y) (- (rand-vu-float-range 0.6 0.8))))
      )
    )
  )

;; definition for function fruit-sparticle-next-on-mode-1
(defun fruit-sparticle-next-on-mode-1 ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (-> arg1 key)))
      (cond
        ((zero? (-> s5-0 state-mode 0))
         (set! (-> arg1 next-time)
               (the-as uint (* (max 1 (the-as int (-> *display* clock (-> arg1 clock-index) sparticle-data x))) 2))
               )
         )
        (else
          (let ((s4-0 (new 'stack-no-clear 'vector)))
            0.0
            0.0
            0.0
            (let* ((f28-0 (/ 1.0 (* 0.00024414062 (-> arg1 omega))))
                   (f26-0 (* (rand-vu-float-range -136.53334 136.53334) f28-0))
                   (f30-0 (* (rand-vu-float-range 0.0 136.53334) f28-0))
                   (f0-8 (* (rand-vu-float-range -13.653334 54.613335) f28-0))
                   )
              (vector-float*! s4-0 (the-as vector (-> s5-0 origin)) f26-0)
              (let ((a1-5 s4-0))
                (let ((v1-8 s4-0))
                  (let ((a0-10 (-> s5-0 origin vector 1)))
                    (let ((a2-1 f30-0))
                      (.mov vf7 a2-1)
                      )
                    (.lvf vf5 (&-> a0-10 quad))
                    )
                  (.lvf vf4 (&-> v1-8 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a1-5 quad) vf6)
                )
              (let ((a1-6 s4-0))
                (let ((v1-9 s4-0))
                  (let ((a0-11 (-> s5-0 origin vector 2)))
                    (let ((a2-2 f0-8))
                      (.mov vf7 a2-2)
                      )
                    (.lvf vf5 (&-> a0-11 quad))
                    )
                  (.lvf vf4 (&-> v1-9 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a1-6 quad) vf6)
                )
              )
            (set! (-> arg1 vel-sxvel x) (-> s4-0 x))
            (set! (-> arg1 vel-sxvel y) (-> s4-0 y))
            (set! (-> arg1 vel-sxvel z) (-> s4-0 z))
            )
          (-> arg1 vel-sxvel)
          (set! (-> arg1 user-float) (+ (-> s5-0 origin trans y) (-> arg1 omega)))
          )
        )
      )
    0.0
    )
  )

;; failed to figure out what this is:
(defpartgroup group-ctywide-fruit
  :id 185
  :flags (use-local-clock unk-6)
  :bounds (static-bspherem 0 0 0 6)
  :rotate ((degrees 30) (degrees 0) (degrees 0))
  :parts ((sp-item 856 :flags (launch-asap bit7))
    (sp-item 857 :flags (launch-asap bit7))
    (sp-item 858 :flags (launch-asap bit7))
    (sp-item 859 :flags (launch-asap bit7))
    (sp-item 860 :flags (launch-asap bit7))
    )
  )

;; failed to figure out what this is:
(defpart 856
  :init-specs ((:texture (new 'static 'texture-id :index #x75 :page #x45e))
    (:num 8.0)
    (:x (meters 2.2) 2 (meters 0.75))
    (:y (meters 1.1))
    (:z (meters -1.25) 2 (meters 0.75))
    (:scale-x (meters 0.75) (meters 0.1))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g :copy r)
    (:b :copy b)
    (:a 128.0)
    (:omega (degrees 9))
    (:timer (seconds -0.005))
    (:flags (sp-cpuinfo-flag-2 aux-list sp-cpuinfo-flag-12 use-global-acc))
    (:userdata 1638.4)
    (:func 'fruit-sparticle-next-on-mode-1)
    (:next-launcher 861)
    (:rotate-y (degrees 0))
    )
  )

;; failed to figure out what this is:
(defpart 861
  :init-specs ((:accel-y (meters -0.0033333334) (meters -0.0016666667))
    (:friction 0.96 0.02)
    (:func 'fruit-check-ground-bounce)
    (:next-time (seconds 2) (seconds 3.997))
    (:next-launcher 862)
    )
  )

;; failed to figure out what this is:
(defpart 860
  :init-specs ((:texture (new 'static 'texture-id :index #x76 :page #x45e))
    (:num 40.0)
    (:x (meters -3.7) 7 (meters 0.25))
    (:y (meters 1.1))
    (:z (meters -1.1) 7 (meters 0.25))
    (:scale-x (meters 0.25) (meters 0.1))
    (:scale-y (meters 0.35) (meters 0.1))
    (:r 0.0 1 160.0)
    (:g 100.0 64.0)
    (:b 0.0 5.0)
    (:a 128.0)
    (:omega (degrees 4.5))
    (:timer (seconds -0.005))
    (:flags (sp-cpuinfo-flag-2 aux-list sp-cpuinfo-flag-12 use-global-acc))
    (:userdata 819.2)
    (:func 'fruit-sparticle-next-on-mode-1)
    (:next-launcher 863)
    (:rotate-y (degrees 0))
    )
  )

;; failed to figure out what this is:
(defpart 859
  :init-specs ((:texture (new 'static 'texture-id :index #x76 :page #x45e))
    (:num 24.0)
    (:x (meters -3.6) 7 (meters 0.25))
    (:y (meters 1.25))
    (:z (meters -1.075) 6 (meters 0.25))
    (:scale-x (meters 0.25) (meters 0.1))
    (:scale-y (meters 0.35) (meters 0.1))
    (:r 0.0 1 160.0)
    (:g 100.0 64.0)
    (:b 0.0 5.0)
    (:a 128.0)
    (:omega (degrees 4.5))
    (:timer (seconds -0.005))
    (:flags (sp-cpuinfo-flag-2 aux-list sp-cpuinfo-flag-12 use-global-acc))
    (:userdata 819.2)
    (:func 'fruit-sparticle-next-on-mode-1)
    (:next-launcher 863)
    (:rotate-y (degrees 0))
    )
  )

;; failed to figure out what this is:
(defpart 863
  :init-specs ((:rot-z (degrees 0) (degrees 360))
    (:rotvel-z (degrees -1.2) (degrees 2.4))
    (:accel-y (meters -0.0033333334) (meters -0.0016666667))
    (:friction 0.97 0.02)
    (:func 'fruit-check-ground-bounce)
    (:next-time (seconds 1.5) (seconds 2.997))
    (:next-launcher 864)
    )
  )

;; failed to figure out what this is:
(defpart 864
  :init-specs ((:rotvel-z (degrees 0)) (:fade-a -0.42666668))
  )

;; failed to figure out what this is:
(defpart 858
  :init-specs ((:texture (new 'static 'texture-id :index #x76 :page #x45e))
    (:num 32.0)
    (:x (meters -0.8) 3 (meters 0.5))
    (:y (meters 1))
    (:z (meters -1) 3 (meters 0.5))
    (:scale-x (meters 0.4) (meters 0.15))
    (:scale-y :copy scale-x)
    (:r 128.0 64.0)
    (:g 48.0 32.0)
    (:b 0.0 5.0)
    (:a 128.0)
    (:omega (degrees 6.7500005))
    (:timer (seconds -0.005))
    (:flags (sp-cpuinfo-flag-2 aux-list sp-cpuinfo-flag-12 use-global-acc))
    (:userdata 1228.8)
    (:func 'fruit-sparticle-next-on-mode-1)
    (:next-launcher 865)
    (:rotate-y (degrees 0))
    )
  )

;; failed to figure out what this is:
(defpart 857
  :init-specs ((:texture (new 'static 'texture-id :index #x76 :page #x45e))
    (:num 32.0)
    (:x (meters -0.55) 2 (meters 0.5))
    (:y (meters 1.25))
    (:z (meters -0.8) 2 (meters 0.5))
    (:scale-x (meters 0.4) (meters 0.15))
    (:scale-y :copy scale-x)
    (:r 128.0 64.0)
    (:g 48.0 32.0)
    (:b 0.0 5.0)
    (:a 128.0)
    (:omega (degrees 6.7500005))
    (:timer (seconds -0.005))
    (:flags (sp-cpuinfo-flag-2 aux-list sp-cpuinfo-flag-12 use-global-acc))
    (:userdata 1228.8)
    (:func 'fruit-sparticle-next-on-mode-1)
    (:next-launcher 865)
    (:rotate-y (degrees 0))
    )
  )

;; failed to figure out what this is:
(defpart 865
  :init-specs ((:accel-y (meters -0.0033333334) (meters -0.0016666667))
    (:friction 0.97 0.02)
    (:func 'fruit-check-ground-bounce)
    (:next-time (seconds 2) (seconds 3.997))
    (:next-launcher 862)
    )
  )

;; failed to figure out what this is:
(defpart 862
  :init-specs ((:fade-a -0.42666668))
  )

;; failed to figure out what this is:
(defskelgroup skel-fruit-stand cty-fruit-stand cty-fruit-stand-lod0-jg cty-fruit-stand-idle-ja
              ((cty-fruit-stand-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              )

;; definition for function fruit-stand-event-handler
;; WARN: Return type mismatch int vs object.
(defbehavior fruit-stand-event-handler fruit-stand ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('attack)
     (let ((v1-1 (the-as object (-> arg3 param 1))))
       (when (!= (-> (the-as attack-info v1-1) id) (-> self incoming-attack-id))
         (set! (-> self incoming-attack-id) (-> (the-as attack-info v1-1) id))
         (let ((v0-0 1))
           (set! (-> self part state-mode 0) (the-as uint v0-0))
           v0-0
           )
         )
       )
     )
    )
  )

;; failed to figure out what this is:
(defstate idle (fruit-stand)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (fruit-stand-event-handler proc argc message block)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post (behavior ()
    (dotimes (gp-0 (the-as int (-> self num-sparts)))
      (let ((s5-0 (new 'stack-no-clear 'collide-query))
            (s4-0 (-> *sp-particle-system-2d* cpuinfo-table (-> self sparts-index gp-0)))
            )
        (set! (-> s5-0 start-pos quad) (-> self sparts-pos gp-0 quad))
        (+! (-> s5-0 start-pos y) 4096.0)
        (set-vector! (-> s5-0 move-dist) 0.0 -40960.0 0.0 1.0)
        (let ((v1-5 s5-0))
          (set! (-> v1-5 radius) (-> s4-0 omega))
          (set! (-> v1-5 collide-with) (collide-spec backgnd))
          (set! (-> v1-5 ignore-process0) #f)
          (set! (-> v1-5 ignore-process1) #f)
          (set! (-> v1-5 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
          (set! (-> v1-5 action-mask) (collide-action solid))
          )
        (let ((f0-7 (fill-and-probe-using-line-sphere *collide-cache* s5-0)))
          (if (>= f0-7 0.0)
              (set! (-> s4-0 user-float) (+ (-> s5-0 start-pos y) (* (-> s5-0 move-dist y) f0-7)))
              )
          (when (< f0-7 0.0)
            )
          )
        )
      )
    (+! (-> self first-sparts) (-> self num-sparts))
    (when (>= (-> self first-sparts) (-> self count-sparts))
      (set! (-> self first-sparts) (the-as uint 0))
      0
      )
    (set! (-> self num-sparts) (the-as uint 0))
    (set! (-> self hack-counter) (the-as uint 4))
    (set! (-> self count-sparts) (the-as uint 0))
    (spawn-with-cspace (-> self part) (the-as cspace (-> self node-list data)))
    (ja-post)
    )
  )

;; definition for method 28 of type fruit-stand
;; WARN: Return type mismatch int vs none.
(defmethod fruit-stand-method-28 ((this fruit-stand))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-6 prim-core action) (collide-action solid rideable))
      (set! (-> v1-6 transform-index) 0)
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; definition for method 29 of type fruit-stand
;; WARN: Return type mismatch int vs none.
(defmethod fruit-stand-method-29 ((this fruit-stand))
  (logior! (-> this mask) (process-mask crate))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 185) this))
  0
  (none)
  )

;; definition for method 11 of type fruit-stand
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this fruit-stand) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (fruit-stand-method-28 this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-fruit-stand" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (fruit-stand-method-29 this)
  (go (method-of-object this idle))
  (none)
  )

;; definition of type cty-fruit-stand
(deftype cty-fruit-stand (fruit-stand)
  ()
  )

;; definition for method 3 of type cty-fruit-stand
(defmethod inspect ((this cty-fruit-stand))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type fruit-stand inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defpartgroup group-cty-guard-turret-hit
  :id 186
  :duration (seconds 3)
  :linger-duration (seconds 1)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 15)
  :parts ((sp-item 866 :period (seconds 5) :length (seconds 0.085) :offset -10)
    (sp-item 867 :fade-after (meters 60) :period (seconds 5) :length (seconds 0.1))
    (sp-item 868 :fade-after (meters 60) :falloff-to (meters 60) :period (seconds 5) :length (seconds 0.335))
    (sp-item 869 :fade-after (meters 200) :falloff-to (meters 200) :period (seconds 5) :length (seconds 0.167))
    (sp-item 870 :period (seconds 5) :length (seconds 0.017) :offset -10)
    (sp-item 871 :fade-after (meters 150) :falloff-to (meters 150) :period (seconds 5) :length (seconds 0.167))
    )
  )

;; failed to figure out what this is:
(defpart 869
  :init-specs ((:texture (new 'static 'texture-id :index #x34 :page #xc))
    (:num 1.0 1.0)
    (:scale-x (meters 1) (meters 1))
    (:rot-z (degrees 0) (degrees 360) :store)
    (:scale-y (meters 0.8) (meters 0.2))
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 32.0 32.0)
    (:vel-y (meters 0.02) (meters 0.01))
    (:scalevel-x (meters 0.01) (meters 0.13333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -0.36)
    (:fade-b -4.24)
    (:fade-a -0.22068965)
    (:friction 0.95)
    (:timer (seconds 3.335))
    (:flags (sp-cpuinfo-flag-2))
    (:func 'sparticle-motion-blur)
    (:next-time (seconds 0.085) (seconds 0.015))
    (:next-launcher 872)
    (:conerot-x '*sp-temp*)
    )
  )

;; failed to figure out what this is:
(defpart 871
  :init-specs ((:texture (new 'static 'texture-id :index #x33 :page #xc))
    (:num 1.0 1.0)
    (:scale-x (meters 1) (meters 1))
    (:rot-z (degrees 0))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 0.0)
    (:vel-y (meters 0.02) (meters 0.01))
    (:scalevel-x (meters 0.01) (meters 0.13333334))
    (:rotvel-z (degrees -0.12) (degrees 0.24))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -0.36)
    (:fade-b -4.24)
    (:fade-a 0.22068965)
    (:friction 0.95)
    (:timer (seconds 3.335))
    (:flags (sp-cpuinfo-flag-2))
    (:next-time (seconds 0.085) (seconds 0.015))
    (:next-launcher 872)
    (:conerot-x (degrees 0) (degrees 360))
    )
  )

;; failed to figure out what this is:
(defpart 872
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0) (:next-time (seconds 0.017) (seconds 0.065)) (:next-launcher 873))
  )

;; failed to figure out what this is:
(defpart 873
  :init-specs ((:scalevel-x (meters 0.016666668) (meters 0.016666668))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.44)
    (:fade-g -2.36)
    (:fade-b -2.64)
    (:next-time (seconds 0.117) (seconds 0.047))
    (:next-launcher 874)
    )
  )

;; failed to figure out what this is:
(defpart 874
  :init-specs ((:scalevel-x (meters 0.008333334) (meters 0.008333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -1.2944444)
    (:fade-g -0.7111111)
    (:fade-b -0.094444446)
    (:fade-a -0.06545454 -0.06545454)
    (:next-time (seconds 0.5) (seconds 0.097))
    (:next-launcher 875)
    )
  )

;; failed to figure out what this is:
(defpart 875
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0))
  )

;; failed to figure out what this is:
(defpart 870
  :init-specs ((:texture (new 'static 'texture-id :index #xbb :page #xc))
    (:num 1.0)
    (:scale-x (meters 5))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 96.0)
    (:scalevel-x (meters 0.5))
    (:rotvel-z (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -1.28)
    (:fade-b -5.1)
    (:fade-a 0.0)
    (:timer (seconds 0.335))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:next-time (seconds 0.167))
    (:next-launcher 876)
    )
  )

;; failed to figure out what this is:
(defpart 876
  :init-specs ((:scalevel-x (meters -0.2))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -2.56)
    (:fade-b 0.0)
    (:fade-a -1.92)
    )
  )

;; failed to figure out what this is:
(defpart 868
  :init-specs ((:texture (new 'static 'texture-id :index #x32 :page #xc))
    (:num 5.0 3.0)
    (:x (meters 0.25))
    (:scale-x (meters 1) (meters 0.25))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 16.0 48.0)
    (:vel-y (meters 0.083333336) (meters 0.083333336))
    (:scalevel-x (meters 0.006666667) (meters 0.0016666667))
    (:rotvel-z (degrees -0.12) (degrees 0.24))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -0.18)
    (:fade-b -2.12)
    (:accel-y (meters -0.00016666666) (meters -0.00033333333))
    (:friction 0.87)
    (:timer (seconds 3.335))
    (:flags (sp-cpuinfo-flag-2))
    (:next-time (seconds 0.117) (seconds 0.047))
    (:next-launcher 877)
    (:conerot-x (degrees 0) (degrees 360))
    )
  )

;; failed to figure out what this is:
(defpart 877
  :init-specs ((:scalevel-x (meters 0.0016666667))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g 0.02)
    (:fade-b 0.23555556)
    (:next-time (seconds 0.15) (seconds 0.047))
    (:next-launcher 878)
    )
  )

;; failed to figure out what this is:
(defpart 878
  :init-specs ((:fade-r -0.5543478) (:fade-g -0.5543478) (:fade-a -0.13913043))
  )

;; failed to figure out what this is:
(defpart 866
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 3.0 1.0)
    (:x (meters 0) (meters 0.6))
    (:scale-x (meters 2) (meters 1.5))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 70.0 20.0)
    (:g 70.0 20.0)
    (:b 70.0 20.0)
    (:a 0.0 40.0)
    (:vel-y (meters 0) (meters 0.1))
    (:scalevel-x (meters 0.033333335) (meters 0.016666668))
    (:rotvel-z (degrees -0.12) (degrees 0.24))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 3.3)
    (:fade-g 3.12)
    (:fade-b 1.18)
    (:fade-a 1.76)
    (:friction 0.88)
    (:timer (seconds 2.367))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:next-time (seconds 0.117) (seconds 0.047))
    (:next-launcher 879)
    (:conerot-x (degrees 0) (degrees 360))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

;; failed to figure out what this is:
(defpart 879
  :init-specs ((:scalevel-x (meters 0.0033333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.53333336)
    (:fade-g -1.9666667)
    (:fade-b -2.2)
    (:fade-a -0.41666666)
    (:next-time (seconds 0.15) (seconds 0.047))
    (:next-launcher 880)
    )
  )

;; failed to figure out what this is:
(defpart 880
  :init-specs ((:scalevel-x (meters 0))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.38833332)
    (:fade-g -0.21333334)
    (:fade-b -0.028333334)
    (:fade-a -0.38833332)
    )
  )

;; failed to figure out what this is:
(defpart 867
  :init-specs ((:texture (new 'static 'texture-id :index #x31 :page #xc))
    (:num 4.0 2.0)
    (:scale-x (meters 0.1) (meters 0.25))
    (:rot-x 4)
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.2) (meters 0.1))
    (:r 128.0 128.0)
    (:g 96.0)
    (:b 64.0)
    (:a 64.0 64.0)
    (:scalevel-x (meters 0.13333334) (meters 0.02))
    (:fade-g 1.6)
    (:fade-b 3.2)
    (:fade-a -1.6)
    (:timer (seconds 0.267))
    (:flags (sp-cpuinfo-flag-2))
    )
  )

;; definition of type cty-guard-turret
(deftype cty-guard-turret (process-focusable)
  ((incoming-attack-id  uint32)
   (jm-turret           joint-mod)
   (jm-gunsL            joint-mod)
   (jm-gunsR            joint-mod)
   (angle-turret        degrees)
   (angle-guns          degrees)
   (last-no-zero        int64)
   (next-time-shot      time-frame)
   (num-shots           uint32)
   (focus               focus  :inline)
   (id                  int32)
   (destroyed           symbol)
   (button-down?        symbol)
   (hit-points          int32)
   )
  (:state-methods
    idle
    hostile
    explode
    wait-for-pushing
    pushed
    )
  (:methods
    (cty-guard-turret-method-32 (_type_) none)
    (cty-guard-turret-method-33 (_type_) none)
    (cty-guard-turret-method-34 (_type_) none)
    (cty-guard-turret-method-35 (_type_) quaternion)
    )
  )

;; definition for method 3 of type cty-guard-turret
(defmethod inspect ((this cty-guard-turret))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-focusable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tincoming-attack-id: ~D~%" (-> this incoming-attack-id))
  (format #t "~2Tjm-turret: ~A~%" (-> this jm-turret))
  (format #t "~2Tjm-gunsL: ~A~%" (-> this jm-gunsL))
  (format #t "~2Tjm-gunsR: ~A~%" (-> this jm-gunsR))
  (format #t "~2Tangle-turret: ~f~%" (-> this angle-turret))
  (format #t "~2Tangle-guns: ~f~%" (-> this angle-guns))
  (format #t "~2Tlast-no-zero: ~D~%" (-> this last-no-zero))
  (format #t "~2Tnext-time-shot: ~D~%" (-> this next-time-shot))
  (format #t "~2Tnum-shots: ~D~%" (-> this num-shots))
  (format #t "~2Tfocus: #<focus @ #x~X>~%" (-> this focus))
  (format #t "~2Tid: ~D~%" (-> this id))
  (format #t "~2Tdestroyed: ~A~%" (-> this destroyed))
  (format #t "~2Tbutton-down?: ~A~%" (-> this button-down?))
  (format #t "~2Thit-points: ~D~%" (-> this hit-points))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-cty-guard-turret cty-guard-turret cty-guard-turret-lod0-jg cty-guard-turret-idle-ja
              ((cty-guard-turret-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 7.5)
              )

;; failed to figure out what this is:
(defskelgroup skel-cty-guard-turret-explode cty-guard-turret cty-guard-turret-explode-lod0-jg cty-guard-turret-explode-idle-ja
              ((cty-guard-turret-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15)
              )

;; definition for symbol *cty-guard-turret-exploder-params*, type joint-exploder-static-params
(define *cty-guard-turret-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index 8)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index 8)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index 6)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index 6)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index 6)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index 7)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index 6)
      )
    :collide-spec #x1
    )
  )

;; definition for function cty-guard-turret-event-handler
(defbehavior cty-guard-turret-event-handler cty-guard-turret ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('attack)
     (when (and (-> self next-state) (= (-> self next-state name) 'hostile))
       (let ((a0-1 (get-penetrate-using-from-attack-event (the-as process-drawable arg0) arg3))
             (v1-5 (the-as object (-> arg3 param 1)))
             )
         (when (!= (-> (the-as attack-info v1-5) id) (-> self incoming-attack-id))
           (set! (-> self incoming-attack-id) (-> (the-as attack-info v1-5) id))
           (cond
             ((logtest? (penetrate
                          flop
                          punch
                          spin
                          uppercut
                          mech-punch
                          mech-bonk
                          dark-punch
                          dark-bomb
                          dark-giant
                          explode
                          jak-red-shot
                          jak-dark-shot
                          enemy-dark-shot
                          )
                        a0-1
                        )
              (+! (-> self hit-points) -10)
              )
             ((logtest? (attack-mask damage) (-> (the-as attack-info v1-5) mask))
              (set! (-> self hit-points) (- (-> self hit-points) (the int (-> (the-as attack-info v1-5) damage))))
              )
             (else
               (set! (-> self hit-points) (- (-> self hit-points) (penetrate-using->damage a0-1)))
               )
             )
           (when (< (-> self hit-points) 0)
             (sound-play "gturret-explode")
             (go-virtual explode)
             )
           )
         )
       )
     )
    (('track)
     (if (and (-> self next-state) (= (-> self next-state name) 'hostile))
         #t
         #f
         )
     )
    )
  )

;; definition for method 20 of type cty-guard-turret
(defmethod get-trans ((this cty-guard-turret) (arg0 int))
  "@returns the `trans` [[vector]] from the process's `root` (typically either a [[trsqv]] or a [[collide-shape]])"
  (let ((v1-0 (-> this root)))
    (cond
      ((= arg0 3)
       (let ((v0-0 (vector<-cspace! (new 'static 'vector) (-> this node-list data 6))))
         (set! (-> v0-0 w) (-> this root root-prim prim-core world-sphere w))
         v0-0
         )
       )
      (else
        (-> v1-0 trans)
        )
      )
    )
  )

;; definition for method 26 of type cty-guard-turret
(defmethod get-inv-mass ((this cty-guard-turret))
  0.01
  )

;; failed to figure out what this is:
(defstate idle (cty-guard-turret)
  :virtual #t
  :event cty-guard-turret-event-handler
  :enter (behavior ()
    (try-update-focus (-> self focus) *target*)
    (ja-channel-push! 1 0)
    (ja-no-eval :group! cty-guard-turret-idle-ja :num! zero)
    (transform-post)
    (logior! (-> self focus-status) (focus-status ignore))
    )
  :exit (behavior ()
    (logclear! (-> self focus-status) (focus-status ignore))
    )
  :code sleep-code
  :post (behavior ()
    (when (>= (-> self id) 0)
      (let* ((v1-4 (-> *game-info* sub-task-list (game-task-node city-power-resolution)))
             (gp-0 (if (-> v1-4 info)
                       (-> v1-4 info manager)
                       (the-as handle #f)
                       )
                   )
             )
        (when (handle->process gp-0)
          (if (or (task-node-open? (game-task-node city-power-post-win))
                  (not (send-event (handle->process gp-0) 'guard-turret-status (-> self id) (-> self root trans)))
                  )
              (set! (-> self destroyed) #t)
              )
          )
        )
      )
    (if (= (level-status *level* 'lwideb) 'active)
        (set! (-> self destroyed) #t)
        )
    (let ((gp-2 (handle->process (-> self focus handle))))
      (when (and gp-2
                 (and *traffic-engine*
                      (let ((f0-0 (vector-vector-xz-distance-squared (get-trans (the-as process-focusable gp-2) 0) (-> self root trans)))
                            (f1-0 409600.0)
                            )
                        (< f0-0 (* f1-0 f1-0))
                        )
                      (not (-> self destroyed))
                      )
                 )
        (cond
          ((and (>= (-> self id) 0) (task-node-open? (game-task-node city-power-resolution)))
           (go-virtual hostile)
           )
          (else
            (if (and (focus-test? (the-as process-focusable gp-2) pilot)
                     (>= (the-as uint (get-alert-level *traffic-engine*)) (the-as uint 1))
                     )
                (go-virtual hostile)
                )
            )
          )
        )
      )
    (transform-post)
    )
  )

;; failed to figure out what this is:
(defstate explode (cty-guard-turret)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('button-down)
       (let ((v0-0 #t))
         (set! (-> self button-down?) v0-0)
         v0-0
         )
       )
      )
    )
  :enter (behavior ()
    (let ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-cty-guard-turret-explode" (the-as (pointer uint32) #f))
        6
        gp-0
        *cty-guard-turret-exploder-params*
        :to self
        )
      )
    (when (and (>= (-> self id) 0) (let ((v1-12 (-> *game-info* sub-task-list (game-task-node city-power-resolution))))
                                     (handle->process (if (-> v1-12 info)
                                                          (-> v1-12 info manager)
                                                          (the-as handle #f)
                                                          )
                                                      )
                                     )
               )
      (set! (-> self button-down?) #f)
      (let ((a1-6 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-6 from) (process->ppointer self))
        (set! (-> a1-6 num-params) 1)
        (set! (-> a1-6 message) 'guard-turret-killed)
        (set! (-> a1-6 param 0) (the-as uint (-> self id)))
        (let ((t9-5 send-event-function)
              (v1-23 (-> *game-info* sub-task-list (game-task-node city-power-resolution)))
              )
          (t9-5
            (handle->process (if (-> v1-23 info)
                                 (-> v1-23 info manager)
                                 (the-as handle #f)
                                 )
                             )
            a1-6
            )
          )
        )
      )
    (setup-masks (-> self draw) 0 2)
    (set! (-> self root root-prim specific 0) (+ (-> self root root-prim specific 1) -1))
    )
  :post (behavior ()
    (ja-post)
    )
  )

;; failed to figure out what this is:
(defstate wait-for-pushing (cty-guard-turret)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('button-down)
       (let ((v0-0 #t))
         (set! (-> self button-down?) v0-0)
         v0-0
         )
       )
      )
    )
  :enter (behavior ()
    (set! (-> self button-down?) #f)
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) (process->ppointer self))
      (set! (-> a1-0 num-params) 2)
      (set! (-> a1-0 message) 'spawn-button)
      (set! (-> a1-0 param 0) (the-as uint (-> self id)))
      (set! (-> a1-0 param 1) (the-as uint #f))
      (let ((t9-0 send-event-function)
            (v1-6 (-> *game-info* sub-task-list (game-task-node city-power-resolution)))
            )
        (t9-0
          (handle->process (if (-> v1-6 info)
                               (-> v1-6 info manager)
                               (the-as handle #f)
                               )
                           )
          a1-0
          )
        )
      )
    (setup-masks (-> self draw) 0 2)
    (set! (-> self root root-prim specific 0) (+ (-> self root root-prim specific 1) -1))
    )
  :code (behavior ()
    (ja-no-eval :group! cty-guard-turret-pop-up-down-ja :num! (seek! 20.0) :frame-num 20.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! 20.0))
      )
    (while (not (-> self button-down?))
      (suspend)
      )
    (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-2 from) (process->ppointer self))
      (set! (-> a1-2 num-params) 1)
      (set! (-> a1-2 message) 'guard-turret-button-pushed)
      (set! (-> a1-2 param 0) (the-as uint (-> self id)))
      (let ((t9-3 send-event-function)
            (v1-25 (-> *game-info* sub-task-list (game-task-node city-power-resolution)))
            )
        (t9-3
          (handle->process (if (-> v1-25 info)
                               (-> v1-25 info manager)
                               (the-as handle #f)
                               )
                           )
          a1-2
          )
        )
      )
    (loop
      (suspend)
      )
    (set! (-> self root root-prim specific 0) (-> self root root-prim specific 1))
    (setup-masks (-> self draw) 2 0)
    (go-virtual idle)
    )
  :post (behavior ()
    (ja-post)
    )
  )

;; failed to figure out what this is:
(defstate pushed (cty-guard-turret)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('close)
       (let ((v0-0 #t))
         (set! (-> self button-down?) v0-0)
         v0-0
         )
       )
      )
    )
  :enter (behavior ()
    (set! (-> self button-down?) #f)
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) (process->ppointer self))
      (set! (-> a1-0 num-params) 2)
      (set! (-> a1-0 message) 'spawn-button)
      (set! (-> a1-0 param 0) (the-as uint (-> self id)))
      (set! (-> a1-0 param 1) (the-as uint #t))
      (let ((t9-0 send-event-function)
            (v1-7 (-> *game-info* sub-task-list (game-task-node city-power-resolution)))
            )
        (t9-0
          (handle->process (if (-> v1-7 info)
                               (-> v1-7 info manager)
                               (the-as handle #f)
                               )
                           )
          a1-0
          )
        )
      )
    (setup-masks (-> self draw) 0 2)
    (set! (-> self root root-prim specific 0) (+ (-> self root root-prim specific 1) -1))
    (set! (-> self button-down?) #f)
    )
  :code (behavior ()
    (ja-no-eval :group! cty-guard-turret-pop-up-down-ja
                :num! (seek! (ja-aframe 20.0 0))
                :frame-num (ja-aframe 20.0 0)
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! (ja-aframe 20.0 0)))
      )
    (while (not (-> self button-down?))
      (suspend)
      )
    (ja-no-eval :group! cty-guard-turret-pop-up-down-ja
                :num! (seek! (ja-aframe 32.0 0))
                :frame-num (ja-aframe 20.0 0)
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! (ja-aframe 32.0 0)))
      )
    (let ((gp-4 (current-time)))
      (until (time-elapsed? gp-4 (seconds 5))
        (suspend)
        )
      )
    (set! (-> self root root-prim specific 0) (-> self root root-prim specific 1))
    (setup-masks (-> self draw) 2 0)
    (go-virtual idle)
    )
  :post (behavior ()
    (ja-post)
    )
  )

;; definition for method 34 of type cty-guard-turret
;; INFO: Used lq/sq
;; WARN: Return type mismatch (pointer process) vs none.
(defmethod cty-guard-turret-method-34 ((this cty-guard-turret))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s2-0 (-> this node-list data 7 bone transform))
          (s5-0 (-> this node-list data 8 bone transform))
          (s4-0 (new 'stack-no-clear 'projectile-init-by-other-params))
          )
      (let ((s1-0 (new 'stack-no-clear 'vector))
            (s3-0 (new 'stack-no-clear 'vector))
            )
        (vector<-matrix! s1-0 s2-0)
        (let ((a1-1 s1-0))
          (let ((v1-4 s1-0))
            (let ((a0-2 (-> s2-0 vector 2)))
              (let ((a2-1 10727.424))
                (.mov vf7 a2-1)
                )
              (.lvf vf5 (&-> a0-2 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-1 quad) vf6)
          )
        (vector<-matrix! s3-0 s5-0)
        (let ((a1-3 s3-0))
          (let ((v1-5 s3-0))
            (let ((a0-4 (-> s5-0 vector 2)))
              (let ((a2-3 -10727.424))
                (.mov vf7 a2-3)
                )
              (.lvf vf5 (&-> a0-4 quad))
              )
            (.lvf vf4 (&-> v1-5 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-3 quad) vf6)
          )
        (set! (-> s4-0 ent) (-> this entity))
        (set! (-> s4-0 charge) 1.0)
        (set! (-> s4-0 options) (projectile-options))
        (set! (-> s4-0 notify-handle) (process->handle this))
        (set! (-> s4-0 owner-handle) (the-as handle #f))
        (set! (-> s4-0 ignore-handle) (process->handle this))
        (let* ((v1-14 *game-info*)
               (a0-14 (+ (-> v1-14 attack-id) 1))
               )
          (set! (-> v1-14 attack-id) a0-14)
          (set! (-> s4-0 attack-id) a0-14)
          )
        (set! (-> s4-0 timeout) (seconds 4))
        (set! (-> s4-0 pos quad) (-> s1-0 quad))
        (set! (-> s4-0 vel quad) (-> s2-0 vector 2 quad))
        (vector-normalize! (-> s4-0 vel) 819200.0)
        (spawn-projectile guard-shot s4-0 this *default-dead-pool*)
        (set! (-> s4-0 pos quad) (-> s3-0 quad))
        )
      (vector-negate! (-> s4-0 vel) (-> s5-0 vector 2))
      (vector-normalize! (-> s4-0 vel) 819200.0)
      (spawn-projectile guard-shot s4-0 this *default-dead-pool*)
      )
    (none)
    )
  )

;; definition for method 35 of type cty-guard-turret
;; INFO: Used lq/sq
(defmethod cty-guard-turret-method-35 ((this cty-guard-turret))
  (local-vars (sv-192 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (handle->process (-> this focus handle))))
      (when s5-0
        (let ((s4-0 (new 'stack-no-clear 'vector)))
          (set! (-> s4-0 quad) (-> (get-trans (the-as process-focusable s5-0) 3) quad))
          (let ((s0-0 (new 'stack-no-clear 'vector)))
            (let ((v1-8 (-> this root trans)))
              (let ((a0-5 *y-vector*))
                (let ((a1-3 10240.0))
                  (.mov vf7 a1-3)
                  )
                (.lvf vf5 (&-> a0-5 quad))
                )
              (.lvf vf4 (&-> v1-8 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> s0-0 quad) vf6)
            (let ((f30-0 (vector-vector-xz-distance s4-0 s0-0)))
              (let ((f0-2 (* 0.0000012207031 f30-0))
                    (a0-7 s4-0)
                    )
                (let ((v1-10 s4-0))
                  (let ((a1-6 (-> (the-as process-focusable s5-0) root transv)))
                    (let ((a2-0 f0-2))
                      (.mov vf7 a2-0)
                      )
                    (.lvf vf5 (&-> a1-6 quad))
                    )
                  (.lvf vf4 (&-> v1-10 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a0-7 quad) vf6)
                )
              (let ((s3-1 (vector-! (new 'stack-no-clear 'vector) s4-0 s0-0))
                    (s1-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)))
                    )
                (set! sv-192 (new 'stack-no-clear 'vector))
                (let ((s2-0 (new 'stack-no-clear 'vector)))
                  (-> this node-list data 6 bone transform)
                  (-> this node-list data 7 bone transform)
                  (-> this node-list data 8 bone transform)
                  (vector-rotate90-around-y! sv-192 s3-1)
                  (set! (-> sv-192 y) 0.0)
                  (vector-normalize! sv-192 1.0)
                  (let* ((f26-0 (vector-vector-xz-distance-squared s0-0 s4-0))
                         (f0-4 7389.184)
                         (f28-0 (* f0-4 f0-4))
                         (t9-6 vector-vector-xz-distance-squared)
                         (a0-13 (new 'stack-no-clear 'vector))
                         )
                    (let ((v1-27 7389.184))
                      (.mov vf7 v1-27)
                      )
                    (.lvf vf5 (&-> sv-192 quad))
                    (.lvf vf4 (&-> s0-0 quad))
                    (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                    (.mul.x.vf acc vf5 vf7 :mask #b111)
                    (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                    (.svf (&-> a0-13 quad) vf6)
                    (let* ((f2-0 (t9-6 a0-13 s4-0))
                           (f28-1 (acos (fmax -1.0 (fmin 1.0 (/ (- (- f26-0 f28-0) f2-0) (* -2.0 (sqrtf f2-0) (sqrtf f28-0)))))))
                           )
                      (let ((s0-1 (new 'stack-no-clear 'vector))
                            (s4-1 (new 'stack-no-clear 'vector))
                            )
                        (if (< f28-1 11832.889)
                            (set! f28-1 11832.889)
                            )
                        (rot-zxy-from-vector! s0-1 s1-0)
                        (rot-zxy-from-vector! s2-0 s3-1)
                        (set! (-> s4-1 x) (deg- (-> s2-0 x) (-> s0-1 x)))
                        (set! (-> s4-1 y) (deg- (-> s2-0 y) (-> s0-1 y)))
                        (cond
                          ((focus-test? (the-as process-focusable s5-0) pilot)
                           (set! (-> this angle-turret) (deg-seek (-> this angle-turret) (-> s4-1 y) (* 36408.89 (seconds-per-frame))))
                           (set! (-> this angle-guns) (deg-seek (-> this angle-guns) (-> s4-1 x) (* 7281.778 (seconds-per-frame))))
                           )
                          (else
                            (set! (-> this angle-turret) (deg-seek (-> this angle-turret) (-> s4-1 y) (* 18204.445 (seconds-per-frame))))
                            (set! (-> this angle-guns) (deg-seek (-> this angle-guns) (-> s4-1 x) (* 7281.778 (seconds-per-frame))))
                            )
                          )
                        (quaternion-axis-angle! (-> this jm-turret quat) 0.0 1.0 0.0 (-> this angle-turret))
                        (when (= (+ (fabs (- (-> this angle-turret) (-> s4-1 y))) (fabs (- (-> this angle-guns) (-> s4-1 x)))) 0.0)
                          (set! (-> this next-time-shot) (+ (current-time) (seconds 1)))
                          (set! (-> this num-shots) (the-as uint 0))
                          0
                          )
                        )
                      (let ((s5-1 (new 'stack-no-clear 'quaternion)))
                        (let ((f0-42 (/ 45511.11 (* 0.00024414062 f30-0))))
                          (quaternion-axis-angle! s5-1 1.0 0.0 0.0 (fmax (fmin (-> this angle-guns) f0-42) (- f0-42)))
                          )
                        (quaternion*!
                          (-> this jm-gunsL quat)
                          (quaternion-axis-angle! (new 'stack-no-clear 'quaternion) 0.0 1.0 0.0 (+ -16384.0 f28-1))
                          s5-1
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        (quaternion-copy! (-> this jm-gunsR quat) (-> this jm-gunsL quat))
        )
      )
    )
  )

;; failed to figure out what this is:
(defstate hostile (cty-guard-turret)
  :virtual #t
  :event cty-guard-turret-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self num-shots) (the-as uint 0))
    0
    )
  :trans (behavior ()
    '()
    )
  :code (behavior ()
    (ja-no-eval :group! cty-guard-turret-pop-up-down-ja :num! (seek! 20.0 0.5) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! 20.0 0.5))
      )
    (until #f
      (cond
        ((zero? (-> self next-time-shot))
         (cty-guard-turret-method-35 self)
         )
        ((>= (current-time) (-> self next-time-shot))
         (cty-guard-turret-method-34 self)
         (+! (-> self num-shots) 1)
         (cond
           ((= (-> self num-shots) 5)
            (set! (-> self next-time-shot) 0)
            0
            )
           (else
             (set! (-> self next-time-shot) (+ (current-time) (seconds 0.1)))
             )
           )
         )
        )
      (suspend)
      (let ((gp-0 (handle->process (-> self focus handle))))
        (cond
          ((and gp-0
                (let ((f0-5 (vector-vector-xz-distance-squared (get-trans (the-as process-focusable gp-0) 0) (-> self root trans)))
                      (f1-0 491520.0)
                      )
                  (< f0-5 (* f1-0 f1-0))
                  )
                )
           (cond
             ((and (>= (-> self id) 0) (task-node-open? (game-task-node city-power-resolution)))
              )
             (else
               (if (and (not (focus-test? (the-as process-focusable gp-0) pilot))
                        *traffic-engine*
                        (zero? (get-alert-level *traffic-engine*))
                        )
                   (goto cfg-36)
                   )
               )
             )
           )
          (else
            (goto cfg-36)
            )
          )
        )
      )
    #f
    (label cfg-36)
    (ja-no-eval :group! cty-guard-turret-pop-up-down-ja :num! (seek! 32.0 0.5) :frame-num 20.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! 32.0 0.5))
      )
    (go-virtual idle)
    )
  :post (behavior ()
    (transform-post)
    )
  )

;; definition for method 7 of type cty-guard-turret
(defmethod relocate ((this cty-guard-turret) (arg0 int))
  (if (nonzero? (-> this jm-turret))
      (&+! (-> this jm-turret) arg0)
      )
  (if (nonzero? (-> this jm-gunsL))
      (&+! (-> this jm-gunsL) arg0)
      )
  (if (nonzero? (-> this jm-gunsR))
      (&+! (-> this jm-gunsR) arg0)
      )
  (call-parent-method this arg0)
  )

;; definition for method 32 of type cty-guard-turret
;; WARN: Return type mismatch int vs none.
(defmethod cty-guard-turret-method-32 ((this cty-guard-turret))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate
                                    generic-attack
                                    lunge
                                    flop
                                    punch
                                    spin
                                    roll
                                    uppercut
                                    bonk
                                    tube
                                    vehicle
                                    flut-attack
                                    board
                                    mech-punch
                                    dark-punch
                                    dark-giant
                                    )
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 4) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 5))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 26624.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-13 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-13 prim-core action) (collide-action solid rideable))
      (set! (-> v1-13 transform-index) 4)
      (set-vector! (-> v1-13 local-sphere) -6144.0 0.0 0.0 10649.6)
      )
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-15 prim-core action) (collide-action solid rideable))
      (set! (-> v1-15 transform-index) 5)
      (set-vector! (-> v1-15 local-sphere) 6144.0 0.0 0.0 10649.6)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-17 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-17 prim-core action) (collide-action solid rideable))
      (set! (-> v1-17 transform-index) 3)
      (set-vector! (-> v1-17 local-sphere) 0.0 0.0 0.0 14336.0)
      )
    (let ((v1-19 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-19 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-19 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-19 prim-core action) (collide-action solid))
      (set! (-> v1-19 transform-index) 6)
      (set-vector! (-> v1-19 local-sphere) 0.0 -8192.0 0.0 13107.2)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-22 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-22 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-22 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; definition for method 33 of type cty-guard-turret
;; WARN: Return type mismatch int vs none.
(defmethod cty-guard-turret-method-33 ((this cty-guard-turret))
  (logior! (-> this mask) (process-mask enemy))
  0
  (none)
  )

;; definition for method 11 of type cty-guard-turret
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this cty-guard-turret) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (v1-23 handle))
  (with-pp
    (cty-guard-turret-method-32 this)
    (set! (-> this entity) arg0)
    (process-drawable-from-entity! this arg0)
    (ctywide-entity-hack)
    (initialize-skeleton
      this
      (the-as skeleton-group (art-group-get-by-name *level* "skel-cty-guard-turret" (the-as (pointer uint32) #f)))
      (the-as pair 0)
      )
    (cty-guard-turret-method-33 this)
    (reset-to-collide-spec (-> this focus) (collide-spec jak player-list))
    (set! (-> this jm-turret) (new 'process 'joint-mod (joint-mod-mode joint-set*) this 6))
    (set! (-> this jm-gunsL) (new 'process 'joint-mod (joint-mod-mode joint-set*) this 7))
    (set! (-> this jm-gunsR) (new 'process 'joint-mod (joint-mod-mode joint-set*) this 8))
    (set! (-> this part) (create-launch-control (-> *part-group-id-table* 186) this))
    (set! (-> this id) (res-lump-value arg0 'extra-id int :default (the-as uint128 -1) :time -1000000000.0))
    (set! (-> this destroyed) #f)
    (set! (-> this hit-points) 6)
    (cond
      ((and (>= (-> this id) 0)
            (begin
              (let ((v1-21 (-> *game-info* sub-task-list (game-task-node city-power-resolution))))
                (set! v1-23 (if (-> v1-21 info)
                                (-> v1-21 info manager)
                                (the-as handle #f)
                                )
                      )
                )
              (nonzero? (l32-false-check v1-23))
              )
            (let ((a0-16 (-> v1-23 process 0)))
              (if (= (-> v1-23 pid) (-> a0-16 pid))
                  a0-16
                  )
              )
            )
       (let ((a1-11 (new 'stack-no-clear 'event-message-block)))
         (set! (-> a1-11 from) (process->ppointer pp))
         (set! (-> a1-11 num-params) 2)
         (set! (-> a1-11 message) 'guard-turret-status)
         (set! (-> a1-11 param 0) (the-as uint (-> this id)))
         (set! (-> a1-11 param 1) (the-as uint (-> this root trans)))
         (let* ((t9-12 send-event-function)
                (v1-33 (-> *game-info* sub-task-list (game-task-node city-power-resolution)))
                (v1-38 (t9-12
                         (handle->process (if (-> v1-33 info)
                                              (-> v1-33 info manager)
                                              (the-as handle #f)
                                              )
                                          )
                         a1-11
                         )
                       )
                )
           (cond
             ((zero? v1-38)
              (go (method-of-object this idle))
              )
             ((= v1-38 1)
              (go (method-of-object this wait-for-pushing))
              )
             ((= v1-38 2)
              (go (method-of-object this pushed))
              )
             (else
               (go (method-of-object this idle))
               )
             )
           )
         )
       )
      (else
        (go (method-of-object this idle))
        )
      )
    (none)
    )
  )

;; definition of type parking-spot
(deftype parking-spot (process-drawable)
  ((vehicle      handle)
   (spawned      symbol)
   (minimap      connection-minimap)
   (test-sphere  sphere  :inline)
   )
  (:state-methods
    idle
    )
  (:methods
    (parking-spot-method-21 (_type_) none)
    (parking-spot-method-22 (_type_) none)
    (parking-spot-method-23 (_type_ uint) none)
    (parking-spot-method-24 (_type_) none)
    )
  )

;; definition for method 3 of type parking-spot
(defmethod inspect ((this parking-spot))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tvehicle: ~D~%" (-> this vehicle))
  (format #t "~2Tspawned: ~A~%" (-> this spawned))
  (format #t "~2Tminimap: #<connection-minimap @ #x~X>~%" (-> this minimap))
  (format #t "~2Ttest-sphere: #<sphere @ #x~X>~%" (-> this test-sphere))
  (label cfg-4)
  this
  )

;; definition for method 24 of type parking-spot
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod parking-spot-method-24 ((this parking-spot))
  (let ((gp-0 (new 'stack-no-clear 'collide-query-with-2vec)))
    (set! (-> gp-0 vec quad) (-> this root trans quad))
    (set! (-> gp-0 cquery start-pos quad) (-> gp-0 vec quad))
    (vector-reset! (-> gp-0 vec2))
    (set! (-> gp-0 vec2 y) 1.0)
    (set-vector! (-> gp-0 cquery move-dist) 0.0 -40960.0 0.0 1.0)
    (let ((v1-5 (-> gp-0 cquery)))
      (set! (-> v1-5 radius) 1024.0)
      (set! (-> v1-5 collide-with) (collide-spec backgnd))
      (set! (-> v1-5 ignore-process0) #f)
      (set! (-> v1-5 ignore-process1) #f)
      (set! (-> v1-5 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
      (set! (-> v1-5 action-mask) (collide-action solid))
      )
    (let ((f30-0 (fill-and-probe-using-line-sphere *collide-cache* (-> gp-0 cquery))))
      (when (>= f30-0 0.0)
        (vector+float*! (-> gp-0 vec) (-> gp-0 cquery start-pos) (-> gp-0 cquery move-dist) f30-0)
        (set! (-> gp-0 vec2 quad) (-> gp-0 cquery best-other-tri normal quad))
        (set! (-> this root trans quad) (-> gp-0 vec quad))
        (format #t "parking-spot::find-ground: ground y ~M~%" (-> gp-0 vec y))
        )
      (if (< f30-0 0.0)
          (format #t "parking-spot::find-ground: could not find ground~%")
          )
      )
    (set! (-> this root trans quad) (-> gp-0 vec quad))
    (forward-up-nopitch->quaternion (-> this root quat) (new 'static 'vector :z 1.0 :w 1.0) (-> gp-0 vec2))
    )
  0
  (none)
  )

;; definition for method 21 of type parking-spot
;; WARN: Return type mismatch int vs none.
(defmethod parking-spot-method-21 ((this parking-spot))
  (let ((s5-0 (handle->process (-> this vehicle))))
    (cond
      (s5-0
        (cond
          ((or (focus-test? (the-as vehicle s5-0) dead inactive)
               (not (logtest? (-> (the-as vehicle s5-0) flags) (rigid-body-object-flag waiting-for-player)))
               (let ((f0-0 (-> this test-sphere r)))
                 (< (* f0-0 f0-0) (vector-vector-distance-squared (-> (the-as vehicle s5-0) root trans) (-> this test-sphere)))
                 )
               )
           (logclear! (-> (the-as vehicle s5-0) flags) (rigid-body-object-flag persistent))
           (set! (-> this vehicle) (the-as handle #f))
           )
          (else
            (if (not (-> this minimap))
                (set! (-> this minimap) (add-icon! *minimap* this (the-as uint 17) (the-as int #f) (the-as vector #t) 0))
                )
            )
          )
        )
      (else
        (when (-> this minimap)
          (logior! (-> this minimap flags) (minimap-flag fade-out))
          (set! (-> this minimap) #f)
          )
        )
      )
    )
  0
  (none)
  )

;; definition for method 23 of type parking-spot
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod parking-spot-method-23 ((this parking-spot) (arg0 uint))
  (let ((v1-0 (new 'stack-no-clear 'inline-array 'collide-query 1)))
    (let* ((a0-1 (new 'stack-no-clear 'inline-array 'vector 1))
           (a1-1 #x813f9)
           (a2-1 (logand -2 a1-1))
           )
      (set! (-> a0-1 0 quad) (-> this test-sphere quad))
      (let ((a1-3 (-> v1-0 0)))
        (set! (-> a1-3 best-dist) (the-as float a0-1))
        (set! (-> a1-3 num-spheres) (the-as uint 1))
        (set! (-> a1-3 collide-with) (the-as collide-spec a2-1))
        (set! (-> a1-3 ignore-process0) #f)
        (set! (-> a1-3 ignore-process1) #f)
        (set! (-> a1-3 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
        (set! (-> a1-3 best-my-prim) (the-as collide-shape-prim #t))
        (set! (-> a1-3 action-mask) (collide-action solid))
        )
      )
    0
    (when (not (fill-and-probe-using-spheres *collide-cache* (-> v1-0 0)))
      (let ((s4-0 (new 'stack 'traffic-object-spawn-params)))
        (set! (-> s4-0 position quad) (-> this root trans quad))
        (mem-copy! (the-as pointer (-> s4-0 rotation)) (the-as pointer (-> this root quat)) 16)
        (+! (-> s4-0 position y) 14336.0)
        (set! (-> s4-0 behavior) (the-as uint 0))
        (set! (-> s4-0 object-type) (the-as traffic-type arg0))
        (set! (-> s4-0 id) (the-as uint 0))
        (send-event *traffic-manager* 'activate-object s4-0)
        (when (-> s4-0 proc)
          (set! (-> this vehicle) (process->handle (-> s4-0 proc)))
          (set! (-> this spawned) #t)
          )
        )
      )
    )
  0
  (none)
  )

;; definition for method 11 of type parking-spot
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this parking-spot) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> this root) (new 'process 'trsqv))
  (set! (-> this minimap) #f)
  (set! (-> this vehicle) (the-as handle #f))
  (set! (-> this spawned) #f)
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause movie))
  (let ((f0-0 (res-lump-float (-> this entity) 'rotoffset)))
    (if (!= f0-0 0.0)
        (quaternion-rotate-y! (-> this root quat) (-> this root quat) f0-0)
        )
    )
  (parking-spot-method-24 this)
  (set! (-> this test-sphere quad) (-> this root trans quad))
  (set! (-> this test-sphere r) 24576.0)
  (set-time! (-> this state-time))
  (let ((a1-5 (get-random-parking-spot-type *traffic-engine*)))
    (if (!= a1-5 (traffic-type traffic-type-21))
        (parking-spot-method-23 this (the-as uint a1-5))
        )
    )
  (go (method-of-object this idle))
  (none)
  )

;; failed to figure out what this is:
(defstate idle (parking-spot)
  :virtual #t
  :exit (behavior ()
    (parking-spot-method-21 self)
    (send-event (handle->process (-> self vehicle)) 'traffic-off-force)
    )
  :code sleep-code
  :post (behavior ()
    (when (time-elapsed? (-> self state-time) (seconds 0.25))
      (set-time! (-> self state-time))
      (parking-spot-method-21 self)
      (when (not (-> self spawned))
        (let ((f0-0 (vector-vector-distance-squared (camera-pos) (-> self test-sphere)))
              (f1-0 327680.0)
              )
          (when (< (* f1-0 f1-0) f0-0)
            (let ((f1-3 614400.0))
              (when (or (< (* f1-3 f1-3) f0-0) (not (sphere-in-view-frustum? (-> self test-sphere))))
                (let ((a1-1 (get-random-parking-spot-type *traffic-engine*)))
                  (if (!= a1-1 (traffic-type traffic-type-21))
                      (parking-spot-method-23 self (the-as uint a1-1))
                      )
                  )
                )
              )
            )
          )
        )
      )
    0
    )
  )

;; definition of type propa
(deftype propa (process-focusable)
  ((sound-id            sound-id)
   (sound-index         uint32)
   (handle              handle)
   (y-rot               float)
   (hit-points          int32)
   (incoming-attack-id  uint32)
   )
  (:state-methods
    idle
    broken
    )
  (:methods
    (propa-method-29 (_type_) none)
    (propa-method-30 (_type_) none)
    (propa-method-31 (_type_ vector) none)
    )
  )

;; definition for method 3 of type propa
(defmethod inspect ((this propa))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-focusable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tsound-id: ~D~%" (-> this sound-id))
  (format #t "~2Tsound-index: ~D~%" (-> this sound-index))
  (format #t "~2Thandle: ~D~%" (-> this handle))
  (format #t "~2Ty-rot: ~f~%" (-> this y-rot))
  (format #t "~2Thit-points: ~D~%" (-> this hit-points))
  (format #t "~2Tincoming-attack-id: ~D~%" (-> this incoming-attack-id))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-propa propa propa-lod0-jg propa-idle-ja
              ((propa-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

;; definition for symbol *propa-sounds*, type (array string)
(define *propa-sounds* (new 'static 'boxed-array :type string
                         "prop009"
                         "prop010"
                         "prop011"
                         "prop012"
                         "prop013"
                         "prop014"
                         "prop015"
                         "prop016"
                         "prop017"
                         "prop018"
                         "prop019"
                         "prop020"
                         "prop021"
                         "prop022"
                         "prop023"
                         "prop024"
                         "prop025"
                         "prop026"
                         "prop028"
                         "prop027"
                         "prop029"
                         "prop030"
                         "prop031"
                         "prop032"
                         "prop033"
                         "prop034"
                         "prop035"
                         "prop036"
                         "prop037"
                         "prop038"
                         "prop039"
                         "prop040"
                         "prop041"
                         "prop042"
                         "prop043"
                         "prop008"
                         "prop006"
                         "prop005"
                         "prop004"
                         "prop002"
                         "prop003"
                         "bar001"
                         "prop044"
                         "prop045"
                         "prop046"
                         "prop047"
                         "prop048"
                         "prop049"
                         "prop051"
                         "prop052"
                         "prop053"
                         "prop054"
                         "prop055"
                         "prop056"
                         )
        )

;; definition for symbol *propa-sounds-class-3*, type (array string)
(define *propa-sounds-class-3* (new 'static 'boxed-array :type string "cityv177"))

;; definition for symbol *propa-sounds-class-2*, type (array string)
(define *propa-sounds-class-2* (new 'static 'boxed-array :type string "cityv176"))

;; definition for symbol *propa-sounds-class-1*, type (array string)
(define *propa-sounds-class-1* (new 'static 'boxed-array :type string "prop050" "spot004" "cityv175"))

;; definition for symbol *propa-sounds-metalheads*, type (array string)
(define *propa-sounds-metalheads* (new 'static 'boxed-array :type string
                                    "prop007"
                                    "prop057"
                                    "cityv096"
                                    "cityv097"
                                    "cityv098"
                                    "cityv099"
                                    "cityv142"
                                    "cityv143"
                                    )
        )

;; definition for symbol *propa-sounds-baron-construction*, type (array string)
(define *propa-sounds-baron-construction* (new 'static 'boxed-array :type string "prop058"))

;; definition for function propa-pu->knocked-type
;; WARN: Return type mismatch int vs knocked-type.
(defun propa-pu->knocked-type ((arg0 penetrate))
  (the-as knocked-type (cond
                         ((logtest? arg0 (penetrate vehicle))
                          7
                          )
                         ((logtest? (penetrate jak-blue-shot) arg0)
                          6
                          )
                         ((logtest? (penetrate jak-yellow-shot enemy-yellow-shot) arg0)
                          4
                          )
                         ((logtest? (penetrate jak-red-shot) arg0)
                          5
                          )
                         ((logtest? (penetrate explode jak-dark-shot enemy-dark-shot) arg0)
                          2
                          )
                         ((logtest? (penetrate dark-bomb dark-giant) arg0)
                          3
                          )
                         ((logtest? arg0 (penetrate mech-punch))
                          1
                          )
                         (else
                           0
                           )
                         )
          )
  )

;; failed to figure out what this is:
(defstate broken (propa)
  :virtual #t
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate idle (propa)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (case message
        (('attack)
         (get-penetrate-using-from-attack-event (the-as process-drawable proc) block)
         (let ((v1-2 (the-as object (-> block param 1))))
           (when (!= (-> (the-as attack-info v1-2) id) (-> self incoming-attack-id))
             (set! (-> self incoming-attack-id) (-> (the-as attack-info v1-2) id))
             (let ((gp-1 (get-penetrate-using-from-attack-event (the-as process-drawable proc) block)))
               (if (and (not (logtest? (penetrate dark-skin) gp-1)) (zero? (propa-pu->knocked-type gp-1)))
                   (set! (-> self hit-points) (- (-> self hit-points) (penetrate-using->damage gp-1)))
                   (+! (-> self hit-points) -10)
                   )
               )
             (cond
               ((< (-> self hit-points) 3)
                (setup-masks (-> self draw) 0 -1)
                (setup-masks (-> self draw) 1 0)
                (let* ((a0-9 (the-as collide-shape-prim-group (-> self root root-prim)))
                       (v1-17 (-> a0-9 child 0))
                       )
                  (let ((a0-11 (-> a0-9 child 1)))
                    (set! (-> a0-11 prim-core collide-as) (-> v1-17 prim-core collide-as))
                    (set! (-> a0-11 prim-core collide-with) (-> v1-17 prim-core collide-with))
                    )
                  (set! (-> v1-17 prim-core collide-as) (collide-spec))
                  (set! (-> v1-17 prim-core collide-with) (collide-spec))
                  )
                0
                (let ((gp-2 (get-process *default-dead-pool* part-tracker #x4000)))
                  (when gp-2
                    (let ((t9-7 (method-of-type part-tracker activate)))
                      (t9-7
                        (the-as part-tracker gp-2)
                        *entity-pool*
                        (symbol->string (-> part-tracker symbol))
                        (the-as pointer #x70004000)
                        )
                      )
                    (let ((t9-8 run-function-in-process)
                          (a0-14 gp-2)
                          (a1-10 part-tracker-init)
                          (a2-7 (-> *part-group-id-table* 161))
                          (a3-2 0)
                          (t0-0 #f)
                          (t1-0 #f)
                          (t2-0 #f)
                          (t3-0 *launch-matrix*)
                          )
                      (let ((v1-25 (-> t3-0 trans))
                            (t4-0 (new 'stack-no-clear 'vector))
                            )
                        (let ((t5-1 (-> self root trans)))
                          (let ((t6-0 *up-vector*))
                            (let ((t7-1 8192.0))
                              (.mov vf7 t7-1)
                              )
                            (.lvf vf5 (&-> t6-0 quad))
                            )
                          (.lvf vf4 (&-> t5-1 quad))
                          )
                        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                        (.mul.x.vf acc vf5 vf7 :mask #b111)
                        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                        (.svf (&-> t4-0 quad) vf6)
                        (set! (-> v1-25 quad) (-> t4-0 quad))
                        )
                      ((the-as (function object object object object object object object object none) t9-8)
                       a0-14
                       a1-10
                       a2-7
                       a3-2
                       t0-0
                       t1-0
                       t2-0
                       t3-0
                       )
                      )
                    (-> gp-2 ppointer)
                    )
                  )
                (go-virtual broken)
                )
               ((< (-> self hit-points) 6)
                (setup-masks (-> self draw) 0 -1)
                (setup-masks (-> self draw) 2 0)
                )
               )
             )
           )
         )
        )
      )
    )
  :exit (behavior ()
    (when (nonzero? (-> self sound-id))
      (sound-stop (-> self sound-id))
      (set! (-> self sound-id) (new 'static 'sound-id))
      0
      )
    )
  :code sleep-code
  :post (behavior ()
    (cond
      ((or (not (-> *setting-control* user-current speech-control))
           (< 245760.0 (vector-vector-distance (camera-pos) (-> self root trans)))
           )
       (when (nonzero? (-> self sound-id))
         (set-action!
           *gui-control*
           (gui-action stop)
           (-> self sound-id)
           (gui-channel none)
           (gui-action none)
           (the-as string #f)
           (the-as (function gui-connection symbol) #f)
           (the-as process #f)
           )
         (set! (-> self sound-id) (new 'static 'sound-id))
         (+! (-> self sound-index) 1)
         (when (>= (-> self sound-index) (the-as uint (-> *propa-sounds* length)))
           (set! (-> self sound-index) (the-as uint 0))
           0
           )
         )
       )
      ((< (vector-vector-distance (camera-pos) (-> self root trans)) 225280.0)
       (cond
         ((zero? (-> self sound-id))
          (set! (-> self sound-id) (add-process
                                     *gui-control*
                                     self
                                     (gui-channel alert)
                                     (gui-action play)
                                     (-> *propa-sounds* (-> self sound-index))
                                     -99.0
                                     0
                                     )
                )
          (let ((a1-4 (new 'stack-no-clear 'vector)))
            (set! (-> a1-4 quad) (-> self root trans quad))
            (set! (-> a1-4 w) 40960.0)
            (propa-method-31 self a1-4)
            )
          )
         (else
           (when *sound-player-enable*
             (let ((gp-2 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
               (set! (-> gp-2 command) (sound-command set-param))
               (set! (-> gp-2 id) (-> self sound-id))
               (set! (-> gp-2 params fo-min) 40)
               (set! (-> gp-2 params fo-max) 55)
               (set! (-> gp-2 params fo-curve) 2)
               (let ((a1-5 (-> self root trans)))
                 (let ((s5-0 self))
                   (when (= a1-5 #t)
                     (if (and s5-0 (type? s5-0 process-drawable) (nonzero? (-> s5-0 root)))
                         (set! a1-5 (-> s5-0 root trans))
                         (set! a1-5 (the-as vector #f))
                         )
                     )
                   )
                 (sound-trans-convert (the-as vector3w (-> gp-2 params trans)) a1-5)
                 )
               (set! (-> gp-2 params mask) (the-as uint 480))
               (-> gp-2 id)
               )
             )
           (when (= (get-status *gui-control* (-> self sound-id)) (gui-status unknown))
             (set! (-> self sound-id) (new 'static 'sound-id))
             (+! (-> self sound-index) 1)
             (when (>= (-> self sound-index) (the-as uint (-> *propa-sounds* length)))
               (set! (-> self sound-index) (the-as uint 0))
               0
               )
             )
           )
         )
       )
      )
    (let ((s5-1 (matrix->trans (-> self node-list data 3 bone transform) (new 'stack-no-clear 'vector)))
          (s4-0 (new 'stack-no-clear 'vector))
          (gp-3 (new 'stack-no-clear 'matrix))
          )
      (when (and (nonzero? (-> self handle)) (handle->process (-> self handle)))
        (let* ((s3-0 (handle->process (-> self handle)))
               (a0-25 (if (type? s3-0 process-focusable)
                          (the-as process-focusable s3-0)
                          )
                      )
               )
          (when a0-25
            (vector-! s4-0 (-> a0-25 root trans) (-> self root trans))
            (set! (-> self y-rot) (deg-seek
                                    (-> self y-rot)
                                    (deg- (vector-y-angle s4-0) (quaternion-y-angle (-> self root quat)))
                                    (* 36408.89 (seconds-per-frame))
                                    )
                  )
            )
          )
        )
      (matrix-rotate-y! gp-3 (-> self y-rot))
      (matrix<-trans gp-3 s5-1)
      (spawn-with-matrix (-> self part) gp-3)
      )
    )
  )

;; definition for method 31 of type propa
;; WARN: Return type mismatch int vs none.
(defmethod propa-method-31 ((this propa) (arg0 vector))
  (let ((s5-0 (the-as process-focusable #f)))
    (let ((f30-0 (the-as float #x7f800000))
          (s3-0 (new 'stack-no-clear 'array 'collide-shape 64))
          )
      (countdown (s2-0 (fill-actor-list-for-sphere *actor-hash* (the-as sphere arg0) s3-0 64))
        (let* ((s1-0 (-> s3-0 s2-0))
               (a0-3 (if (type? s1-0 collide-shape)
                         s1-0
                         )
                     )
               )
          (when a0-3
            (let* ((s0-0 (-> a0-3 process))
                   (s1-1 (if (type? s0-0 process-focusable)
                             (the-as process-focusable s0-0)
                             )
                         )
                   )
              (when (and s1-1
                         (!= this s1-1)
                         (not (focus-test? s1-1 inactive))
                         (not (focus-test? s1-1 disable))
                         (not (focus-test? s1-1 dead))
                         (not (logtest? (process-mask guard) (-> s1-1 mask)))
                         (not (logtest? (process-mask crate) (-> s1-1 mask)))
                         (not (logtest? (process-mask vehicle) (-> s1-1 mask)))
                         )
                (let ((f0-0 (vector-vector-xz-distance (-> this root trans) (-> s1-1 root trans))))
                  (when (or (not s5-0) (< f0-0 f30-0))
                    (set! s5-0 s1-1)
                    (set! f30-0 f0-0)
                    )
                  )
                )
              )
            )
          )
        )
      )
    (if (and *target* (< (vector-vector-distance (target-pos 0) arg0) (-> arg0 w)))
        (set! s5-0 *target*)
        )
    (if s5-0
        (set! (-> this handle) (process->handle s5-0))
        (set! (-> this handle) (the-as handle #f))
        )
    )
  0
  (none)
  )

;; definition for method 29 of type propa
;; WARN: Return type mismatch int vs none.
(defmethod propa-method-29 ((this propa))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec crate))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-12 prim-core action) (collide-action solid rideable))
      (set! (-> v1-12 transform-index) 3)
      (set-vector! (-> v1-12 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-14 prim-core action) (collide-action solid rideable))
      (set! (-> v1-14 transform-index) 3)
      (set-vector! (-> v1-14 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-17 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-17 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-17 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; definition for method 30 of type propa
;; WARN: Return type mismatch int vs none.
(defmethod propa-method-30 ((this propa))
  (logior! (-> this mask) (process-mask crate))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 170) this))
  0
  (none)
  )

;; definition for method 11 of type propa
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this propa) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (propa-method-29 this)
  (process-drawable-from-entity! this arg0)
  (ctywide-entity-hack)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-propa" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (propa-method-30 this)
  (set! (-> this sound-index) (the-as uint (rand-vu-int-count (-> *propa-sounds* length))))
  (setup-masks (-> this draw) 0 -1)
  (setup-masks (-> this draw) 4 0)
  (set! (-> this hit-points) 10)
  (transform-post)
  (go (method-of-object this idle))
  (none)
  )

;; definition of type baron-statue
(deftype baron-statue (process-drawable)
  ()
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type baron-statue
(defmethod inspect ((this baron-statue))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-baron-statue baron-statue baron-statue-lod0-jg baron-statue-idle-ja
              ((baron-statue-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 75 0 83)
              )

;; definition for method 12 of type baron-statue
(defmethod run-logic? ((this baron-statue))
  #t
  )

;; failed to figure out what this is:
(defstate idle (baron-statue)
  :virtual #t
  :code sleep-code
  )

;; definition for method 11 of type baron-statue
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this baron-statue) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-baron-statue" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (when (task-node-closed? (game-task-node canyon-insert-items-resolution))
    (cleanup-for-death this)
    (go empty-state)
    )
  (ja-post)
  (go (method-of-object this idle))
  (none)
  )

;; definition of type burning-bush
(deftype burning-bush (process-focusable)
  ((task        game-task-control)
   (part-off    sparticle-launch-control)
   (part-alert  sparticle-launch-control)
   (angle       degrees)
   (time        float)
   )
  (:state-methods
    idle
    talking
    menu
    )
  (:methods
    (burning-bush-method-30 (_type_) none)
    (burning-bush-method-31 (_type_) none)
    (burning-bush-method-32 (_type_) object)
    )
  )

;; definition for method 3 of type burning-bush
(defmethod inspect ((this burning-bush))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-focusable inspect)))
    (t9-0 this)
    )
  (format #t "~2Ttask: ~A~%" (-> this task))
  (format #t "~2Tpart-off: ~A~%" (-> this part-off))
  (format #t "~2Tpart-alert: ~A~%" (-> this part-alert))
  (format #t "~2Tangle: ~f~%" (-> this angle))
  (format #t "~2Ttime: ~f~%" (-> this time))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-burning-bush burning-bush burning-bush-lod0-jg burning-bush-idle-ja
              ((burning-bush-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 1.5 0 3.5)
              )

;; failed to figure out what this is:
(defstate idle (burning-bush)
  :virtual #t
  :exit (behavior ()
    '()
    )
  :trans (behavior ()
    (let ((gp-0 (get-current-task-event (-> self task)))
          (s5-0 #f)
          )
      (let ((s4-0 (new 'stack-no-clear 'matrix)))
        (let* ((a2-0 (-> self node-list data 3 bone transform))
               (v1-3 (-> a2-0 quad 0))
               (a0-1 (-> a2-0 quad 1))
               (a1-0 (-> a2-0 quad 2))
               (a2-1 (-> a2-0 trans quad))
               )
          (set! (-> s4-0 quad 0) v1-3)
          (set! (-> s4-0 quad 1) a0-1)
          (set! (-> s4-0 quad 2) a1-0)
          (set! (-> s4-0 trans quad) a2-1)
          )
        (when (< (vector-dot
                   (-> s4-0 vector 2)
                   (vector-! (new 'stack-no-clear 'vector) (camera-pos) (matrix->trans s4-0 (new 'stack-no-clear 'vector)))
                   )
                 0.0
                 )
          )
        (cond
          ((and *traffic-manager* (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
                                    (set! (-> a1-2 from) (process->ppointer self))
                                    (set! (-> a1-2 num-params) 0)
                                    (set! (-> a1-2 message) 'get-alert-level)
                                    (and (nonzero? (send-event-function *traffic-manager* a1-2))
                                         (zero? (-> *setting-control* user-current exclusive-task))
                                         )
                                    )
                )
           (spawn-with-matrix (-> self part-alert) s4-0)
           (set! s5-0 #t)
           )
          ((= (-> gp-0 action) (game-task-action show))
           (spawn-with-matrix (-> self part) s4-0)
           )
          ((= (-> gp-0 action) (game-task-action play))
           (spawn-with-matrix (-> self part-off) s4-0)
           )
          ((= (-> gp-0 action) (game-task-action menu))
           (spawn-with-matrix (-> self part) s4-0)
           )
          (else
            (spawn-with-matrix (-> self part-off) s4-0)
            )
          )
        )
      (when (and (not s5-0)
                 (or (= (-> gp-0 action) (game-task-action show)) (= (-> gp-0 action) (game-task-action menu)))
                 (and (burning-bush-method-32 self) (can-display-query? self (the-as string #f) -99.0))
                 )
        (let ((s5-1
                (new 'stack 'font-context *font-default-matrix* 32 280 0.0 (font-color default) (font-flags shadow kerning))
                )
              )
          (set! (-> s5-1 flags) (font-flags shadow kerning large))
          (let ((v1-37 s5-1))
            (set! (-> v1-37 width) (the float 340))
            )
          (let ((v1-38 s5-1))
            (set! (-> v1-38 height) (the float 80))
            )
          (let ((v1-39 s5-1))
            (set! (-> v1-39 scale) 0.9)
            )
          (let ((s4-1 print-game-text))
            (format (clear *temp-string*) (lookup-text! *common-text* (text-id press-triangle-to-talk) #f))
            (s4-1 *temp-string* s5-1 #f 44 (bucket-id progress))
            )
          )
        (when (cpad-pressed? 0 triangle)
          (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
          (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
          (if (= (-> gp-0 action) (game-task-action menu))
              (go-virtual menu)
              (go-virtual talking)
              )
          )
        )
      )
    )
  :code sleep-code
  :post (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when *target*
        (let* ((a0-0 (-> *target* neck))
               (t9-0 (method-of-object a0-0 look-at!))
               (a1-0 (new 'stack-no-clear 'vector))
               )
          (let ((v1-4 (-> self root trans)))
            (let ((a2-0 *up-vector*))
              (let ((a3-1 20480.0))
                (.mov vf7 a3-1)
                )
              (.lvf vf5 (&-> a2-0 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-0 quad) vf6)
          (t9-0 a0-0 a1-0 #f self)
          )
        )
      )
    )
  )

;; failed to figure out what this is:
(defstate talking (burning-bush)
  :virtual #t
  :enter (behavior ()
    (set-setting! 'minimap 'clear 0.0 (minimap-flag minimap))
    (set! (-> self time) -1.0)
    (process-entity-status! self (entity-perm-status no-kill) #t)
    )
  :exit (behavior ()
    (remove-setting! 'music-volume)
    (remove-setting! 'sfx-volume)
    (remove-setting! 'dialog-volume)
    (remove-setting! 'minimap)
    (set! (-> *part-id-table* 832 init-specs 4 initial-valuef) 14336.0)
    (set! (-> *part-id-table* 833 init-specs 4 initial-valuef) 16384.0)
    (send-event *camera* 'change-target *target*)
    (remove-setting! 'interp-time)
    (remove-setting! 'mode-name)
    )
  :trans (behavior ()
    (local-vars (sv-272 vector) (sv-288 quaternion))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when (!= (-> self time) -1.0)
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (new 'stack-no-clear 'vector)
          (let ((s5-0 gp-0)
                (s4-0 (-> self root trans))
                (s3-0 vector-orient-by-quat!)
                (s2-0 (new 'stack-no-clear 'vector))
                (s1-0 (new 'static 'vector :y 16384.0 :z 40960.0 :w 1.0))
                (s0-0 quaternion-rotate-local-y!)
                )
            (set! sv-272 (new 'stack-no-clear 'vector))
            (set! sv-288 (-> self root quat))
            (let ((a2-0 (* 182.04445 (* 30.0 (sin (* 7281.778 (-> self time)))))))
              (vector+! s5-0 s4-0 (s3-0 s2-0 s1-0 (s0-0 (the-as quaternion sv-272) sv-288 a2-0)))
              )
            )
          (set! (-> *camera* slave 0 trans quad) (-> gp-0 quad))
          (let ((t9-3 forward-down->inv-matrix)
                (a0-5 (-> *camera* slave 0 tracking))
                (a1-2 (new 'stack-no-clear 'vector))
                (v1-17 (new 'stack-no-clear 'vector))
                )
            (let ((a2-3 (-> self root trans)))
              (let ((a3-0 *up-vector*))
                (let ((t0-1 20480.0))
                  (.mov vf7 t0-1)
                  )
                (.lvf vf5 (&-> a3-0 quad))
                )
              (.lvf vf4 (&-> a2-3 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> v1-17 quad) vf6)
            (t9-3 (the-as matrix a0-5) (vector-! a1-2 v1-17 gp-0) (-> *camera* local-down))
            )
          )
        )
      (let ((gp-1 (new 'stack-no-clear 'matrix)))
        (let* ((a2-5 (-> self node-list data 3 bone transform))
               (v1-22 (-> a2-5 quad 0))
               (a0-6 (-> a2-5 quad 1))
               (a1-4 (-> a2-5 quad 2))
               (a2-6 (-> a2-5 trans quad))
               )
          (set! (-> gp-1 quad 0) v1-22)
          (set! (-> gp-1 quad 1) a0-6)
          (set! (-> gp-1 quad 2) a1-4)
          (set! (-> gp-1 trans quad) a2-6)
          )
        (if (< (vector-dot
                 (-> gp-1 vector 2)
                 (vector-! (new 'stack-no-clear 'vector) (camera-pos) (matrix->trans gp-1 (new 'stack-no-clear 'vector)))
                 )
               0.0
               )
            (matrix*! gp-1 (matrix-rotate-y! (new 'stack-no-clear 'matrix) 32768.0) gp-1)
            )
        (+! (-> self angle) (* 100.0 (rand-vu)))
        (set! (-> *part-id-table* 832 init-specs 4 initial-valuef)
              (+ 14336.0 (* 1228.8 (cos (* 182.04445 (-> self angle)))))
              )
        (set! (-> *part-id-table* 833 init-specs 4 initial-valuef)
              (+ 2048.0 (-> *part-id-table* 832 init-specs 4 initial-valuef))
              )
        (spawn-with-matrix (-> self part) gp-1)
        )
      )
    )
  :code (behavior ()
    (set-setting! 'mode-name 'cam-really-fixed 0.0 0)
    (suspend)
    (until (process-grab? *target* #f)
      (suspend)
      )
    (suspend)
    (if *target*
        (set! (-> *target* neck flex-blend) 1.0)
        )
    (add-setting! 'music-volume 'rel (-> *setting-control* user-current music-volume-movie) 0)
    (add-setting! 'sfx-volume 'rel (-> *setting-control* user-current sfx-movie-volume) 0)
    (add-setting! 'dialog-volume 'rel (-> *setting-control* user-current dialog-volume-hint) 0)
    (set-time! (-> self state-time))
    (let* ((v1-21 (get-current-task-event (-> self task)))
           (gp-0 (add-process
                   *gui-control*
                   self
                   (gui-channel bbush)
                   (gui-action play)
                   (the-as string (-> v1-21 scene))
                   -99.0
                   0
                   )
                 )
           )
      (while (nonzero? (get-status *gui-control* gp-0))
        (set! (-> self time) (* 0.0033333334 (the float (- (current-time) (-> self state-time)))))
        (suspend)
        (when (cpad-pressed? 0 triangle)
          (set-action!
            *gui-control*
            (gui-action stop)
            gp-0
            (gui-channel none)
            (gui-action none)
            (the-as string #f)
            (the-as (function gui-connection symbol) #f)
            (the-as process #f)
            )
          (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
          (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
          (sound-play "inter-burn-bush")
          )
        )
      )
    (until (process-release? *target*)
      (suspend)
      )
    (task-node-close! (-> self task current-node))
    (go-virtual idle)
    )
  :post (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when *target*
        (let* ((a0-0 (-> *target* neck))
               (t9-0 (method-of-object a0-0 look-at!))
               (a1-0 (new 'stack-no-clear 'vector))
               )
          (let ((v1-4 (-> self root trans)))
            (let ((a2-0 *up-vector*))
              (let ((a3-1 20480.0))
                (.mov vf7 a3-1)
                )
              (.lvf vf5 (&-> a2-0 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-0 quad) vf6)
          (t9-0 a0-0 a1-0 #f self)
          )
        )
      )
    )
  )

;; failed to figure out what this is:
(defstate menu (burning-bush)
  :virtual #t
  :enter (behavior ()
    (set-setting! 'minimap 'clear 0.0 (minimap-flag minimap))
    (set! (-> self time) -1.0)
    (set-time! (-> self state-time))
    )
  :exit (behavior ()
    (remove-setting! 'minimap)
    (send-event *camera* 'change-target *target*)
    (remove-setting! 'interp-time)
    (remove-setting! 'mode-name)
    )
  :trans (behavior ()
    (local-vars
      (sv-352 (function _varargs_ object))
      (sv-368 string)
      (sv-384 (function string font-context symbol int bucket-id float))
      (sv-400 (function _varargs_ object))
      (sv-416 string)
      (sv-432 (function string font-context symbol int bucket-id float))
      (sv-448 (function _varargs_ object))
      (sv-464 string)
      (sv-480 (function string font-context symbol int bucket-id float))
      (sv-496 (function _varargs_ object))
      (sv-512 string)
      (sv-528 (function string font-context symbol int bucket-id float))
      (sv-544 (function _varargs_ object))
      (sv-560 string)
      (sv-576 (function string font-context symbol int bucket-id float))
      (sv-592 (function _varargs_ object))
      (sv-608 string)
      (sv-624 (function string font-context symbol int bucket-id float))
      (sv-640 (function _varargs_ object))
      (sv-656 string)
      (sv-672 (function string font-context symbol int bucket-id float))
      (sv-688 (function _varargs_ object))
      (sv-704 string)
      )
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when (time-elapsed? (-> self state-time) (seconds 1.5))
        (let ((gp-0 0)
              (s5-0 0)
              )
          (let ((s4-0 310))
            (when (or (task-node-open? (the-as game-task-node s4-0)) (task-node-closed? (the-as game-task-node s4-0)))
              (if (task-node-closed? (the-as game-task-node s4-0))
                  (set! s5-0 0)
                  )
              (+! gp-0 1)
              )
            )
          (let ((s4-1 312))
            (when (or (task-node-open? (the-as game-task-node s4-1)) (task-node-closed? (the-as game-task-node s4-1)))
              (if (task-node-closed? (the-as game-task-node s4-1))
                  (set! s5-0 1)
                  )
              (+! gp-0 1)
              )
            )
          (let ((s4-2 314))
            (when (or (task-node-open? (the-as game-task-node s4-2)) (task-node-closed? (the-as game-task-node s4-2)))
              (if (task-node-closed? (the-as game-task-node s4-2))
                  (set! s5-0 2)
                  )
              (+! gp-0 1)
              )
            )
          (let ((s4-3 316))
            (when (or (task-node-open? (the-as game-task-node s4-3)) (task-node-closed? (the-as game-task-node s4-3)))
              (if (task-node-closed? (the-as game-task-node s4-3))
                  (set! s5-0 3)
                  )
              (+! gp-0 1)
              )
            )
          (let ((s4-4 318))
            (when (or (task-node-open? (the-as game-task-node s4-4)) (task-node-closed? (the-as game-task-node s4-4)))
              (if (task-node-closed? (the-as game-task-node s4-4))
                  (set! s5-0 4)
                  )
              (+! gp-0 1)
              )
            )
          (let ((s4-5 320))
            (when (or (task-node-open? (the-as game-task-node s4-5)) (task-node-closed? (the-as game-task-node s4-5)))
              (if (task-node-closed? (the-as game-task-node s4-5))
                  (set! s5-0 5)
                  )
              (+! gp-0 1)
              )
            )
          (let ((s4-6 322))
            (when (or (task-node-open? (the-as game-task-node s4-6)) (task-node-closed? (the-as game-task-node s4-6)))
              (if (task-node-closed? (the-as game-task-node s4-6))
                  (set! s5-0 6)
                  )
              (+! gp-0 1)
              )
            )
          (when (cpad-pressed? 0 down l-analog-down)
            (+! s5-0 1)
            (cond
              ((< (+ gp-0 -1) s5-0)
               (set! s5-0 (+ gp-0 -1))
               s5-0
               )
              (else
                (the-as int (sound-play "menu-up-down"))
                )
              )
            )
          (when (cpad-pressed? 0 up l-analog-up)
            (+! s5-0 -1)
            (cond
              ((< s5-0 0)
               (set! s5-0 0)
               s5-0
               )
              (else
                (the-as int (sound-play "menu-up-down"))
                )
              )
            )
          (let ((v1-43 s5-0))
            (cond
              ((zero? v1-43)
               (task-node-open! (game-task-node stadium-burning-bush-race-board-resolution))
               )
              ((= v1-43 1)
               (task-node-open! (game-task-node stadium-burning-bush-race-class3-resolution))
               )
              ((= v1-43 2)
               (task-node-open! (game-task-node stadium-burning-bush-race-class2-resolution))
               )
              ((= v1-43 3)
               (task-node-open! (game-task-node stadium-burning-bush-race-class1-resolution))
               )
              ((= v1-43 4)
               (task-node-open! (game-task-node stadium-burning-bush-race-class3-r-resolution))
               )
              ((= v1-43 5)
               (task-node-open! (game-task-node stadium-burning-bush-race-class2-r-resolution))
               )
              ((= v1-43 6)
               (task-node-open! (game-task-node stadium-burning-bush-race-class1-r-resolution))
               )
              )
            )
          (let* ((s4-9 40)
                 (s3-2 36)
                 (s2-0 (- 228 (* gp-0 (/ s4-9 2))))
                 (s1-0 (new
                         'stack
                         'font-context
                         *font-default-matrix*
                         s3-2
                         s2-0
                         0.0
                         (font-color default)
                         (font-flags shadow kerning)
                         )
                       )
                 )
            (set! (-> s1-0 flags) (font-flags shadow kerning middle middle-vert large))
            (let ((v1-48 s1-0))
              (set! (-> v1-48 width) (the float 440))
              )
            (let ((v1-49 s1-0))
              (set! (-> v1-49 height) (the float 50))
              )
            (let ((v1-50 s1-0))
              (set! (-> v1-50 scale) 1.0)
              )
            (let ((v1-51 s1-0)
                  (a1-3 s3-2)
                  (a0-59 40)
                  )
              (set! (-> v1-51 origin x) (the float a1-3))
              (set! (-> v1-51 origin y) (the float a0-59))
              )
            (let ((a0-60 s1-0))
              (set! (-> a0-60 color) (font-color progress-old-yellow))
              )
            (let ((s0-0 print-game-text))
              (set! sv-352 format)
              (set! sv-368 (clear *temp-string*))
              (let ((a1-5 (lookup-text! *common-text* (text-id select-event) #f)))
                (sv-352 sv-368 a1-5)
                )
              (s0-0 *temp-string* s1-0 #f 44 (bucket-id progress))
              )
            (let ((v1-55 s1-0))
              (set! (-> v1-55 height) (the float s4-9))
              )
            (dotimes (s0-1 gp-0)
              (let ((v1-56 s1-0)
                    (a1-7 s3-2)
                    (a0-66 s2-0)
                    )
                (set! (-> v1-56 origin x) (the float a1-7))
                (set! (-> v1-56 origin y) (the float a0-66))
                )
              (let ((v1-57 s1-0))
                (set! (-> v1-57 scale) (if (= s0-1 s5-0)
                                           0.8
                                           0.6
                                           )
                      )
                )
              (let ((a0-68 s1-0))
                (set! (-> a0-68 color) (if (= s0-1 s5-0)
                                           (font-color progress-old-selected)
                                           (font-color default)
                                           )
                      )
                )
              (let ((v1-59 s0-1))
                (cond
                  ((zero? v1-59)
                   (set! sv-384 print-game-text)
                   (set! sv-400 format)
                   (set! sv-416 (clear *temp-string*))
                   (let ((a1-9 (lookup-text! *common-text* (text-id board-name) #f)))
                     (sv-400 sv-416 a1-9)
                     )
                   (let ((a0-73 *temp-string*)
                         (a1-10 s1-0)
                         (a2-6 #f)
                         (a3-4 44)
                         (t0-4 320)
                         )
                     (sv-384 a0-73 a1-10 a2-6 a3-4 (the-as bucket-id t0-4))
                     )
                   )
                  ((= v1-59 1)
                   (set! sv-432 print-game-text)
                   (set! sv-448 format)
                   (set! sv-464 (clear *temp-string*))
                   (let ((a1-12 (lookup-text! *common-text* (text-id race-class3) #f)))
                     (sv-448 sv-464 a1-12)
                     )
                   (let ((a0-79 *temp-string*)
                         (a1-13 s1-0)
                         (a2-8 #f)
                         (a3-5 44)
                         (t0-5 320)
                         )
                     (sv-432 a0-79 a1-13 a2-8 a3-5 (the-as bucket-id t0-5))
                     )
                   )
                  ((= v1-59 2)
                   (set! sv-480 print-game-text)
                   (set! sv-496 format)
                   (set! sv-512 (clear *temp-string*))
                   (let ((a1-15 (lookup-text! *common-text* (text-id race-class2) #f)))
                     (sv-496 sv-512 a1-15)
                     )
                   (let ((a0-85 *temp-string*)
                         (a1-16 s1-0)
                         (a2-10 #f)
                         (a3-6 44)
                         (t0-6 320)
                         )
                     (sv-480 a0-85 a1-16 a2-10 a3-6 (the-as bucket-id t0-6))
                     )
                   )
                  ((= v1-59 3)
                   (set! sv-528 print-game-text)
                   (set! sv-544 format)
                   (set! sv-560 (clear *temp-string*))
                   (let ((a1-18 (lookup-text! *common-text* (text-id race-class1) #f)))
                     (sv-544 sv-560 a1-18)
                     )
                   (let ((a0-91 *temp-string*)
                         (a1-19 s1-0)
                         (a2-12 #f)
                         (a3-7 44)
                         (t0-7 320)
                         )
                     (sv-528 a0-91 a1-19 a2-12 a3-7 (the-as bucket-id t0-7))
                     )
                   )
                  ((= v1-59 4)
                   (set! sv-576 print-game-text)
                   (set! sv-592 format)
                   (set! sv-608 (clear *temp-string*))
                   (let ((a1-21 (lookup-text! *common-text* (text-id reverse-race-class3) #f)))
                     (sv-592 sv-608 a1-21)
                     )
                   (let ((a0-97 *temp-string*)
                         (a1-22 s1-0)
                         (a2-14 #f)
                         (a3-8 44)
                         (t0-8 320)
                         )
                     (sv-576 a0-97 a1-22 a2-14 a3-8 (the-as bucket-id t0-8))
                     )
                   )
                  ((= v1-59 5)
                   (set! sv-624 print-game-text)
                   (set! sv-640 format)
                   (set! sv-656 (clear *temp-string*))
                   (let ((a1-24 (lookup-text! *common-text* (text-id reverse-race-class2) #f)))
                     (sv-640 sv-656 a1-24)
                     )
                   (let ((a0-103 *temp-string*)
                         (a1-25 s1-0)
                         (a2-16 #f)
                         (a3-9 44)
                         (t0-9 320)
                         )
                     (sv-624 a0-103 a1-25 a2-16 a3-9 (the-as bucket-id t0-9))
                     )
                   )
                  ((= v1-59 6)
                   (set! sv-672 print-game-text)
                   (set! sv-688 format)
                   (set! sv-704 (clear *temp-string*))
                   (let ((a1-27 (lookup-text! *common-text* (text-id reverse-race-class1) #f)))
                     (sv-688 sv-704 a1-27)
                     )
                   (let ((a0-108 *temp-string*)
                         (a1-28 s1-0)
                         (a2-18 #f)
                         (a3-10 44)
                         (t0-10 320)
                         )
                     (sv-672 a0-108 a1-28 a2-18 a3-10 (the-as bucket-id t0-10))
                     )
                   )
                  )
                )
              (+! s2-0 s4-9)
              )
            )
          )
        )
      (when (!= (-> self time) -1.0)
        (let ((gp-1 (new 'stack-no-clear 'vector)))
          (new 'stack-no-clear 'vector)
          (vector+! gp-1 (-> self root trans) (vector-orient-by-quat!
                                                (new 'stack-no-clear 'vector)
                                                (new 'static 'vector :y 24166.4 :z 32768.0 :w 1.0)
                                                (-> self root quat)
                                                )
                    )
          (set! (-> *camera* slave 0 trans quad) (-> gp-1 quad))
          (let ((t9-66 forward-down->inv-matrix)
                (a0-112 (-> *camera* slave 0 tracking))
                (a1-30 (new 'stack-no-clear 'vector))
                (v1-96 (new 'stack-no-clear 'vector))
                )
            (let ((a2-21 (-> self root trans)))
              (let ((a3-11 *up-vector*))
                (let ((t0-12 24166.4))
                  (.mov vf7 t0-12)
                  )
                (.lvf vf5 (&-> a3-11 quad))
                )
              (.lvf vf4 (&-> a2-21 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> v1-96 quad) vf6)
            (t9-66 (the-as matrix a0-112) (vector-! a1-30 v1-96 gp-1) (-> *camera* local-down))
            )
          )
        )
      (let ((gp-2 (new 'stack-no-clear 'matrix)))
        (let* ((a2-23 (-> self node-list data 3 bone transform))
               (v1-101 (-> a2-23 quad 0))
               (a0-113 (-> a2-23 quad 1))
               (a1-32 (-> a2-23 quad 2))
               (a2-24 (-> a2-23 trans quad))
               )
          (set! (-> gp-2 quad 0) v1-101)
          (set! (-> gp-2 quad 1) a0-113)
          (set! (-> gp-2 quad 2) a1-32)
          (set! (-> gp-2 trans quad) a2-24)
          )
        (if (< (vector-dot
                 (-> gp-2 vector 2)
                 (vector-! (new 'stack-no-clear 'vector) (camera-pos) (matrix->trans gp-2 (new 'stack-no-clear 'vector)))
                 )
               0.0
               )
            (matrix*! gp-2 (matrix-rotate-y! (new 'stack-no-clear 'matrix) 32768.0) gp-2)
            )
        (spawn-with-matrix (-> self part-off) gp-2)
        )
      )
    )
  :code (behavior ()
    (set-setting! 'mode-name 'cam-really-fixed 0.0 0)
    (suspend)
    (until (process-grab? *target* #f)
      (suspend)
      )
    (set! (-> self time) 0.0)
    (let ((s5-0 #f))
      (let ((gp-0 (add-process *gui-control* self (gui-channel bbush) (gui-action play) "cityv174" -99.0 0)))
        (while (nonzero? (get-status *gui-control* gp-0))
          (suspend)
          (when (or (cpad-pressed? 0 triangle) (cpad-pressed? 0 confirm))
            (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle circle x confirm))
            (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle circle x confirm))
            (set-action!
              *gui-control*
              (gui-action stop)
              gp-0
              (gui-channel none)
              (gui-action none)
              (the-as string #f)
              (the-as (function gui-connection symbol) #f)
              (the-as process #f)
              )
            (sound-play "inter-burn-bush")
            (set! s5-0 #t)
            )
          )
        )
      (when (not s5-0)
        (until #f
          (when (or (cpad-pressed? 0 confirm) (cpad-pressed? 0 triangle))
            (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle circle x confirm))
            (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle circle x confirm))
            (sound-play "menu-pick")
            #t
            (goto cfg-17)
            )
          (suspend)
          )
        #f
        )
      )
    (until (process-release? *target*)
      (label cfg-17)
      (suspend)
      )
    (go-virtual idle)
    )
  :post (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when *target*
        (let* ((a0-0 (-> *target* neck))
               (t9-0 (method-of-object a0-0 look-at!))
               (a1-0 (new 'stack-no-clear 'vector))
               )
          (let ((v1-4 (-> self root trans)))
            (let ((a2-0 *up-vector*))
              (let ((a3-1 20480.0))
                (.mov vf7 a3-1)
                )
              (.lvf vf5 (&-> a2-0 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-0 quad) vf6)
          (t9-0 a0-0 a1-0 #f self)
          )
        )
      )
    )
  )

;; definition for method 32 of type burning-bush
(defmethod burning-bush-method-32 ((this burning-bush))
  (let* ((gp-1 (vector-! (new 'stack-no-clear 'vector) (target-pos 0) (-> this root trans)))
         (f30-0 (vector-dot (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)) gp-1))
         (f0-2 (vector-dot (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)) gp-1))
         )
    (and *target*
         (not (focus-test? *target* pilot))
         (< (fabs f30-0) 10240.0)
         (< 0.0 f0-2)
         (< (fabs f0-2) 20480.0)
         )
    )
  )

;; definition for method 30 of type burning-bush
;; WARN: Return type mismatch int vs none.
(defmethod burning-bush-method-30 ((this burning-bush))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-6 prim-core action) (collide-action solid rideable))
      (set! (-> v1-6 transform-index) 3)
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; definition for method 31 of type burning-bush
;; WARN: Return type mismatch int vs none.
(defmethod burning-bush-method-31 ((this burning-bush))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 173) this))
  (set! (-> this part-off) (create-launch-control (-> *part-group-id-table* 171) this))
  (set! (-> this part-alert) (create-launch-control (-> *part-group-id-table* 172) this))
  0
  (none)
  )

;; definition for method 7 of type burning-bush
;; WARN: Return type mismatch process-focusable vs burning-bush.
(defmethod relocate ((this burning-bush) (arg0 int))
  (if (nonzero? (-> this task))
      (&+! (-> this task) arg0)
      )
  (if (nonzero? (-> this part-off))
      (&+! (-> this part-off) arg0)
      )
  (if (nonzero? (-> this part-alert))
      (&+! (-> this part-alert) arg0)
      )
  (the-as burning-bush ((method-of-type process-focusable relocate) this arg0))
  )

;; definition for method 12 of type burning-bush
(defmethod run-logic? ((this burning-bush))
  (or (not (logtest? (-> this mask) (process-mask actor-pause)))
      (or (and (nonzero? (-> this draw))
               (logtest? (-> this draw status) (draw-control-status on-screen))
               (>= (+ (-> *ACTOR-bank* pause-dist) (-> this root pause-adjust-distance))
                   (vector-vector-distance (-> this root trans) (math-camera-pos))
                   )
               )
          (and (nonzero? (-> this skel)) (!= (-> this skel root-channel 0) (-> this skel channel)))
          (and (nonzero? (-> this draw)) (logtest? (-> this draw status) (draw-control-status uninited)))
          )
      )
  )

;; definition for method 11 of type burning-bush
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this burning-bush) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (burning-bush-method-30 this)
  (process-drawable-from-entity! this arg0)
  (ctywide-entity-hack)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-burning-bush" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (burning-bush-method-31 this)
  (let ((f0-0 (res-lump-float (-> this entity) 'rotoffset)))
    (if (!= f0-0 0.0)
        (quaternion-rotate-local-y! (-> this root quat) (-> this root quat) f0-0)
        )
    )
  (set! (-> this task)
        (new 'process 'game-task-control (res-lump-value arg0 'task-actor game-task-actor :time -1000000000.0))
        )
  (set! (-> this angle) 0.0)
  (set! (-> this root pause-adjust-distance) 819200.0)
  (transform-post)
  (go (method-of-object this idle))
  (none)
  )

;; failed to figure out what this is:
(defskelgroup skel-barons-ship-lores barons-ship-lores barons-ship-lores-lod0-jg barons-ship-lores-idle-ja
              ((barons-ship-lores-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 120)
              )

;; definition of type barons-ship-lores
(deftype barons-ship-lores (process-drawable)
  ((paths             path-control  3)
   (sync              sync-eased    :inline)
   (current-path      int32)
   (forward-backward  symbol)
   )
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type barons-ship-lores
(defmethod inspect ((this barons-ship-lores))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tpaths[3] @ #x~X~%" (-> this paths))
  (format #t "~2Tsync: #<sync-eased @ #x~X>~%" (-> this sync))
  (format #t "~2Tcurrent-path: ~D~%" (-> this current-path))
  (format #t "~2Tforward-backward: ~A~%" (-> this forward-backward))
  (label cfg-4)
  this
  )

;; definition for method 11 of type barons-ship-lores
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this barons-ship-lores) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (when (demo?)
    (process-entity-status! this (entity-perm-status dead) #t)
    (go empty-state)
    )
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-barons-ship-lores" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this root pause-adjust-distance) 32768000.0)
  (set! (-> this paths 0) (new 'process 'curve-control this 'path 0.0))
  (set! (-> this paths 1) (new 'process 'curve-control this 'path 1.0))
  (set! (-> this paths 2) (new 'process 'curve-control this 'path 2.0))
  (set! (-> this current-path) 0)
  (set! (-> this forward-backward) #t)
  (logior! (-> this paths 0 flags) (path-control-flag display draw-line draw-point draw-text))
  (logior! (-> this paths 1 flags) (path-control-flag display draw-line draw-point draw-text))
  (logior! (-> this paths 2 flags) (path-control-flag display draw-line draw-point draw-text))
  (logior! (-> this mask) (process-mask no-kill))
  (let ((a1-9 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-24 0))
      (if #t
          (set! v1-24 (logior v1-24 1))
          )
      (set! (-> a1-9 sync-type) 'sync-eased)
      (set! (-> a1-9 sync-flags) (the-as sync-flags v1-24))
      )
    (set! (-> a1-9 period) (the-as uint #x8ca0))
    (set! (-> a1-9 entity) arg0)
    (set! (-> a1-9 percent) 0.0)
    (set! (-> a1-9 ease-in) 0.15)
    (set! (-> a1-9 ease-out) 0.15)
    (set! (-> a1-9 pause-in) 0.05)
    (set! (-> a1-9 pause-out) 0.0)
    (initialize! (-> this sync) a1-9)
    )
  (go (method-of-object this idle))
  (none)
  )

;; definition for method 7 of type barons-ship-lores
(defmethod relocate ((this barons-ship-lores) (arg0 int))
  (if (nonzero? (-> this paths 0))
      (&+! (-> this paths 0) arg0)
      )
  (if (nonzero? (-> this paths 1))
      (&+! (-> this paths 1) arg0)
      )
  (if (nonzero? (-> this paths 2))
      (&+! (-> this paths 2) arg0)
      )
  (call-parent-method this arg0)
  )

;; failed to figure out what this is:
(defstate idle (barons-ship-lores)
  :virtual #t
  :code (behavior ()
    (until #f
      (ja :num-func num-func-identity :frame-num 0.0)
      (let ((v1-7 (< 0.5 (get-current-phase-no-mod (-> self sync)))))
        (if (and (!= v1-7 (-> self forward-backward)) (not (-> self forward-backward)))
            (set! (-> self current-path) (mod (+ (-> self current-path) 1) 3))
            )
        (set! (-> self forward-backward) v1-7)
        )
      (let ((f30-1 (get-norm! (-> self sync) 0)))
        (get-point-at-percent-along-path! (-> self paths (-> self current-path)) (-> self root trans) f30-1 'interp)
        (quaternion-axis-angle! (-> self root quat) 0.0 1.0 0.0 0.0)
        (let ((gp-0 (displacement-between-points-at-percent-normalized!
                      (-> self paths (-> self current-path))
                      (new 'stack-no-clear 'vector)
                      f30-1
                      )
                    )
              (s5-0 (quaternion->matrix (new-stack-matrix0) (-> self root quat)))
              )
          (vector-normalize! gp-0 1.0)
          (let* ((a2-4 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> s5-0 vector 1) 1.0))
                 (a0-18 (vector-normalize! (vector-flatten! (new 'stack-no-clear 'vector) gp-0 a2-4) 1.0))
                 (f0-2 (vector-y-angle a0-18))
                 )
            f0-2
            (set! f0-2 (cond
                         ((< f30-1 0.15)
                          (set-vector! (-> self root scale) 1.0 1.0 1.0 1.0)
                          (cond
                            ((-> self forward-backward)
                             (+ 16384.0 (* 109226.664 f30-1) f0-2)
                             )
                            (else
                              (+! f0-2 (* 109226.664 (- 0.15 f30-1)))
                              f0-2
                              )
                            )
                          )
                         (else
                           (when (< 0.9 f30-1)
                             (let ((f1-12 (- 1.0 (* 10.0 (+ -0.9 f30-1)))))
                               (set-vector! (-> self root scale) f1-12 f1-12 f1-12 1.0)
                               )
                             )
                           (if (-> self forward-backward)
                               (set! f0-2 (+ 32768.0 f0-2))
                               )
                           f0-2
                           )
                         )
                  )
            (quaternion-axis-angle! (-> self root quat) 0.0 1.0 0.0 f0-2)
            )
          )
        )
      (suspend)
      )
    #f
    )
  :post ja-post
  )

;; definition for method 9 of type city-race-ring-info
;; WARN: Return type mismatch int vs none.
(defmethod city-race-ring-info-method-9 ((this city-race-ring-info) (arg0 symbol))
  (format arg0 "(static-race-ring-info~%")
  (format arg0 "     :pos (~4,,2M ~4,,2M ~4,,2M)~%" (-> this pos x) (-> this pos y) (-> this pos z))
  (let ((f0-3 (-> this pos w)))
    (format arg0 "     :angle (deg ~f)~%" (* 0.005493164 f0-3))
    )
  (if (!= (-> this boost) 1.0)
      (format arg0 "     :boost ~4,,2f~%" (-> this boost))
      )
  (format arg0 "     :dist (meters ~4,,2M)~%" (-> this dist))
  (format arg0 "     ~%)~%")
  0
  (none)
  )

;; definition for method 9 of type city-ambush-info
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod city-ambush-info-method-9 ((this city-ambush-info) (arg0 traffic-object-spawn-params))
  (set! (-> arg0 position quad) (-> this array 0 pos quad))
  (set! (-> arg0 nav-mesh) (find-nearest-nav-mesh (-> arg0 position) (the-as float #x7f800000)))
  (vector-reset! (-> arg0 velocity))
  (dotimes (s4-0 (-> this count))
    (let ((v1-3 (-> this array s4-0)))
      (set! (-> arg0 position quad) (-> v1-3 pos quad))
      (set! (-> arg0 object-type) (the-as traffic-type (-> v1-3 obj-type)))
      )
    (send-event *traffic-manager* 'activate-object arg0)
    0
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defskelgroup skel-lurker-pipe-lid lurker-pipe-lid lurker-pipe-lid-lod0-jg lurker-pipe-lid-idle-ja
              ((lurker-pipe-lid-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

;; definition of type lurker-pipe-lid
(deftype lurker-pipe-lid (process-focusable)
  ((angle  degrees)
   (rot    float)
   )
  (:state-methods
    idle
    )
  (:methods
    (lurker-pipe-lid-method-28 (_type_) none)
    (lurker-pipe-lid-method-29 (_type_) none)
    (lurker-pipe-lid-method-30 (_type_) none)
    )
  )

;; definition for method 3 of type lurker-pipe-lid
(defmethod inspect ((this lurker-pipe-lid))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-focusable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tangle: ~f~%" (-> this angle))
  (format #t "~2Trot: ~f~%" (-> this rot))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defstate idle (lurker-pipe-lid)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('spin)
       (set! (-> self angle) 196608.0)
       (set! (-> self rot) -655360.0)
       )
      )
    )
  :enter (behavior ()
    '()
    )
  :exit (behavior ()
    '()
    )
  :trans (behavior ()
    '()
    )
  :code sleep-code
  :post (behavior ()
    (if (< 0.0 (-> self angle))
        (set! (-> self angle)
              (- (-> self angle) (* 6.0 (seconds-per-frame) (fmax 1820.4445 (fmin (-> self angle) (-> self angle)))))
              )
        (set! (-> self angle) 0.0)
        )
    (quaternion-vector-angle! (-> self root quat) *x-vector* (-> self angle))
    (ja-post)
    )
  )

;; definition for method 28 of type lurker-pipe-lid
;; WARN: Return type mismatch int vs none.
(defmethod lurker-pipe-lid-method-28 ((this lurker-pipe-lid))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-6 prim-core action) (collide-action solid rideable))
      (set! (-> v1-6 transform-index) 3)
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; definition for method 29 of type lurker-pipe-lid
;; WARN: Return type mismatch int vs none.
(defmethod lurker-pipe-lid-method-29 ((this lurker-pipe-lid))
  (logior! (-> this mask) (process-mask crate))
  0
  (none)
  )

;; definition for method 11 of type lurker-pipe-lid
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this lurker-pipe-lid) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (lurker-pipe-lid-method-28 this)
  (process-drawable-from-entity! this arg0)
  (ctywide-entity-hack)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-lurker-pipe-lid" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (lurker-pipe-lid-method-29 this)
  (set! (-> this angle) 0.0)
  (transform-post)
  (go (method-of-object this idle))
  (none)
  )

;; definition of type ctyn-lamp
(deftype ctyn-lamp (process-focusable)
  ()
  (:state-methods
    idle
    die
    )
  (:methods
    (ctyn-lamp-method-29 (_type_) none)
    (ctyn-lamp-method-30 (_type_) none)
    )
  )

;; definition for method 3 of type ctyn-lamp
(defmethod inspect ((this ctyn-lamp))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-focusable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-ctyn-lamp ctyn-lamp ctyn-lamp-lod0-jg ctyn-lamp-idle-ja
              ((ctyn-lamp-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              )

;; failed to figure out what this is:
(defskelgroup skel-ctyn-lamp-explode ctyn-lamp ctyn-lamp-explode-lod0-jg ctyn-lamp-explode-idle-ja
              ((ctyn-lamp-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 80)
              )

;; definition for symbol *ctyn-lamp-exploder-params*, type joint-exploder-static-params
(define *ctyn-lamp-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      )
    :collide-spec #x1
    )
  )

;; failed to figure out what this is:
(defstate idle (ctyn-lamp)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (-> block param 1)
       (let ((s5-0 (the-as process-drawable proc))
             (gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 1)))
             )
         (set! (-> gp-0 fountain-rand-transv-lo quad) (-> s5-0 root trans quad))
         (set! (-> gp-0 fountain-rand-transv-hi x) 16384.0)
         (set! (-> gp-0 fountain-rand-transv-hi y) 40960.0)
         (process-spawn
           joint-exploder
           (art-group-get-by-name *level* "skel-ctyn-lamp-explode" (the-as (pointer uint32) #f))
           5
           gp-0
           *ctyn-lamp-exploder-params*
           :to self
           )
         )
       (go-virtual die)
       )
      )
    )
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate die (ctyn-lamp)
  :virtual #t
  :enter #f
  :exit #f
  :trans #f
  :code (behavior ()
    (sound-play "lamp-hit")
    (let ((v1-3 (-> self root root-prim)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self draw status) (draw-control-status no-draw))
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    )
  :post #f
  )

;; definition for method 29 of type ctyn-lamp
;; WARN: Return type mismatch int vs none.
(defmethod ctyn-lamp-method-29 ((this ctyn-lamp))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate
                                    generic-attack
                                    lunge
                                    flop
                                    punch
                                    spin
                                    roll
                                    uppercut
                                    bonk
                                    tube
                                    vehicle
                                    flut-attack
                                    board
                                    mech-punch
                                    dark-punch
                                    dark-giant
                                    )
          )
    (let ((v1-7 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-7 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-7 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-7 prim-core action) (collide-action solid))
      (set! (-> v1-7 transform-index) 0)
      (set-vector! (-> v1-7 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-7)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-10 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-10 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-10 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; definition for method 30 of type ctyn-lamp
;; WARN: Return type mismatch int vs none.
(defmethod ctyn-lamp-method-30 ((this ctyn-lamp))
  (logior! (-> this mask) (process-mask crate))
  0
  (none)
  )

;; definition for method 11 of type ctyn-lamp
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this ctyn-lamp) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (ctyn-lamp-method-29 this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-ctyn-lamp" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (ctyn-lamp-method-30 this)
  (transform-post)
  (go (method-of-object this idle))
  (none)
  )
