;;-*-Lisp-*-
(in-package goal)

;; definition of type com-airlock
(deftype com-airlock (process-drawable)
  ((root                   collide-shape :override)
   (level-name             pair)
   (open-test              pair)
   (were-behind?           symbol)
   (inner?                 symbol)
   (sound-behind?          symbol)
   (visible-move?          symbol)
   (saw-pilot?             handle)
   (last-distance          meters)
   (y-height               vector)
   (pre-open-speed         float)
   (latch-closed-time      time-frame)
   (latch-open-time        time-frame)
   (gear                   joint-mod)
   (gear-rot               degrees)
   (gear-rotv              degrees)
   (open-frame             float)
   (pre-open-frame         float)
   (lock-frame             float)
   (open-distance          meters)
   (active-distance        meters)
   (sound-id               sound-id)
   (gear-sound-id          sound-id)
   (sound-gear             sound-spec)
   (sound-pre-open         sound-spec)
   (sound-pre-open-stop    sound-spec)
   (sound-lock-loop        sound-spec)
   (sound-lock-stop        sound-spec)
   (sound-open             sound-spec)
   (sound-open-loop        sound-spec)
   (sound-open-stop        sound-spec)
   (sound-close            sound-spec)
   (sound-close-loop       sound-spec)
   (sound-close-stop       sound-spec)
   (sound-post-close       sound-spec)
   (sound-post-close-stop  sound-spec)
   (spool-sound-time       time-frame)
   (door-radius            meters)
   )
  (:state-methods
    (open symbol)
    (close symbol)
    )
  (:methods
    (init-airlock! (_type_) _type_)
    (want-cross-airlock? (_type_) symbol :behavior com-airlock)
    (destination-loaded? (_type_ symbol) symbol)
    (check-crossing-distance (_type_ vector symbol) float :behavior com-airlock)
    (rotate-gear! (_type_ float) degrees :behavior com-airlock)
    (play-city-voice-sound (_type_ symbol) none :behavior com-airlock)
    )
  )

;; definition for method 3 of type com-airlock
(defmethod inspect ((this com-airlock))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tlevel-name: ~A~%" (-> this level-name))
  (format #t "~2Topen-test: ~A~%" (-> this open-test))
  (format #t "~2Twere-behind?: ~A~%" (-> this were-behind?))
  (format #t "~2Tinner?: ~A~%" (-> this inner?))
  (format #t "~2Tsound-behind?: ~A~%" (-> this sound-behind?))
  (format #t "~2Tvisible-move?: ~A~%" (-> this visible-move?))
  (format #t "~2Tsaw-pilot?: ~D~%" (-> this saw-pilot?))
  (format #t "~2Tlast-distance: (meters ~m)~%" (-> this last-distance))
  (format #t "~2Ty-height: #x~X~%" (-> this y-height))
  (format #t "~2Tpre-open-speed: ~f~%" (-> this pre-open-speed))
  (format #t "~2Tlatch-closed-time: ~D~%" (-> this latch-closed-time))
  (format #t "~2Tlatch-open-time: ~D~%" (-> this latch-open-time))
  (format #t "~2Tgear: ~A~%" (-> this gear))
  (format #t "~2Tgear-rot: (deg ~r)~%" (-> this gear-rot))
  (format #t "~2Tgear-rotv: (deg ~r)~%" (-> this gear-rotv))
  (format #t "~2Topen-frame: ~f~%" (-> this open-frame))
  (format #t "~2Tpre-open-frame: ~f~%" (-> this pre-open-frame))
  (format #t "~2Tlock-frame: ~f~%" (-> this lock-frame))
  (format #t "~2Topen-distance: (meters ~m)~%" (-> this open-distance))
  (format #t "~2Tactive-distance: (meters ~m)~%" (-> this active-distance))
  (format #t "~2Tsound-id: ~D~%" (-> this sound-id))
  (format #t "~2Tgear-sound-id: ~D~%" (-> this gear-sound-id))
  (format #t "~2Tsound-gear: ~A~%" (-> this sound-gear))
  (format #t "~2Tsound-pre-open: ~A~%" (-> this sound-pre-open))
  (format #t "~2Tsound-pre-open-stop: ~A~%" (-> this sound-pre-open-stop))
  (format #t "~2Tsound-lock-loop: ~A~%" (-> this sound-lock-loop))
  (format #t "~2Tsound-lock-stop: ~A~%" (-> this sound-lock-stop))
  (format #t "~2Tsound-open: ~A~%" (-> this sound-open))
  (format #t "~2Tsound-open-loop: ~A~%" (-> this sound-open-loop))
  (format #t "~2Tsound-open-stop: ~A~%" (-> this sound-open-stop))
  (format #t "~2Tsound-close: ~A~%" (-> this sound-close))
  (format #t "~2Tsound-close-loop: ~A~%" (-> this sound-close-loop))
  (format #t "~2Tsound-close-stop: ~A~%" (-> this sound-close-stop))
  (format #t "~2Tsound-post-close: ~A~%" (-> this sound-post-close))
  (format #t "~2Tsound-post-close-stop: ~A~%" (-> this sound-post-close-stop))
  (format #t "~2Tspool-sound-time: ~D~%" (-> this spool-sound-time))
  (format #t "~2Tdoor-radius: (meters ~m)~%" (-> this door-radius))
  (label cfg-4)
  this
  )

;; definition for method 10 of type com-airlock
(defmethod deactivate ((this com-airlock))
  (process-entity-status! this (entity-perm-status subtask-complete) #f)
  (if (nonzero? (-> this sound-id))
      (sound-stop (-> this sound-id))
      )
  (if (nonzero? (-> this gear-sound-id))
      (sound-stop (-> this gear-sound-id))
      )
  ((method-of-type process-drawable deactivate) this)
  (none)
  )

;; definition for method 7 of type com-airlock
;; WARN: Return type mismatch process-drawable vs com-airlock.
(defmethod relocate ((this com-airlock) (arg0 int))
  (if (nonzero? (-> this gear))
      (&+! (-> this gear) arg0)
      )
  (the-as com-airlock ((method-of-type process-drawable relocate) this arg0))
  )

;; definition for method 22 of type com-airlock
(defmethod init-airlock! ((this com-airlock))
  (process-entity-status! this (entity-perm-status subtask-complete) #f)
  (process-drawable-from-entity! this (-> this entity))
  (logclear! (-> this mask) (process-mask actor-pause))
  (set! (-> this were-behind?) #f)
  (set! (-> this inner?)
        (logtest? (the-as int (res-lump-value (-> this entity) 'options uint128 :time -1000000000.0)) 1)
        )
  (set! (-> this sound-behind?) #f)
  (set! (-> this saw-pilot?) (the-as handle #f))
  (set! (-> this open-frame) 0.0)
  (set! (-> this pre-open-frame) 0.0)
  (set! (-> this lock-frame) 0.0)
  (set! (-> this pre-open-speed) 2.0)
  (set! (-> this open-distance) (res-lump-float (-> this entity) 'distance :default 143360.0))
  (set! (-> this active-distance)
        (res-lump-float (-> this entity) 'idle-distance :default (+ 143360.0 (-> this open-distance)))
        )
  (set! (-> this y-height) (res-lump-data (-> this entity) 'height vector))
  (set! (-> this level-name) (res-lump-struct (-> this entity) 'on-notice pair))
  (set! (-> this open-test)
        (the-as pair ((method-of-type res-lump get-property-struct)
                      (-> this entity)
                      'open-test
                      'interp
                      -1000000000.0
                      (the-as structure '(not (or (scene-player?) (focus-test? *target* grabbed))))
                      (the-as (pointer res-tag) #f)
                      *res-static-buf*
                      )
                )
        )
  (set! (-> this sound-gear) #f)
  (set! (-> this sound-pre-open) #f)
  (set! (-> this sound-pre-open-stop) #f)
  (set! (-> this sound-lock-loop) #f)
  (set! (-> this sound-lock-stop) #f)
  (set! (-> this sound-post-close) #f)
  (set! (-> this sound-post-close-stop) #f)
  (set! (-> this sound-open) #f)
  (set! (-> this sound-close) #f)
  (set! (-> this sound-open-loop) #f)
  (set! (-> this sound-close-loop) #f)
  (set! (-> this sound-open-stop) #f)
  (set! (-> this sound-close-stop) #f)
  (set! (-> this door-radius) 20480.0)
  this
  )

;; definition for method 25 of type com-airlock
(defmethod check-crossing-distance ((this com-airlock) (arg0 vector) (arg1 symbol))
  (let ((s5-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)))
        (s4-1 (vector-! (new 'stack-no-clear 'vector) arg0 (-> this root trans)))
        )
    (set! (-> s4-1 y) 0.0)
    (let ((f30-0 (vector-dot s4-1 s5-0)))
      (cond
        ((not arg1)
         )
        ((or (< (vector-vector-xz-distance (-> this root trans) arg0) 40960.0)
             (< 0.7 (fabs (vector-dot s5-0 (vector-normalize! s4-1 1.0))))
             )
         (when (and (< f30-0 0.0) (< 0.0 (-> this last-distance)))
           (let ((s5-1 (res-lump-struct (-> this entity) 'on-cross structure)))
             (if s5-1
                 (script-eval (the-as pair s5-1))
                 )
             )
           )
         (set! (-> this last-distance) f30-0)
         )
        ((< 0.0 (-> this last-distance))
         (set! f30-0 (fmax 4096.0 f30-0))
         )
        ((< (-> this last-distance) 0.0)
         (set! f30-0 (fmin -4096.0 f30-0))
         )
        )
      f30-0
      )
    )
  )

;; definition for method 23 of type com-airlock
;; WARN: Return type mismatch object vs symbol.
(defmethod want-cross-airlock? ((this com-airlock))
  (local-vars (a0-12 entity-actor))
  (let* ((tgt (target-pos 0))
         (f30-0 (check-crossing-distance this tgt #t))
         (s5-0 (>= (-> this latch-open-time) (current-time)))
         )
    (the-as
      symbol
      (and (or s5-0 (< (vector-vector-xz-distance (-> this root trans) tgt) (-> this active-distance)))
           (or s5-0 (not (-> this y-height)) (and (>= (-> tgt y) (- (-> this root trans y) (-> this y-height y)))
                                                  (< (-> tgt y) (+ (-> this root trans y) (-> this y-height x)))
                                                  )
               )
           (begin
             (if (and (not (-> this were-behind?)) (and (< f30-0 0.0) (-> this inner?)))
                 (set! (-> this were-behind?) #t)
                 )
             (and (< (-> this latch-closed-time) (current-time))
                  (or (not (and *target* (focus-test? *target* pilot teleporting))) (< f30-0 -409.6))
                  (or (and (< f30-0 (-> this open-distance))
                           (or (not (-> this were-behind?)) (< f30-0 20480.0))
                           (and (or (< 409.6 f30-0)
                                    (begin
                                      (let ((a0-11 (-> this entity)))
                                        (set! a0-12 (entity-actor-lookup a0-11 'next-actor 0))
                                        )
                                      (not a0-12)
                                      )
                                    (logtest? (-> a0-12 extra perm status) (entity-perm-status subtask-complete))
                                    )
                                (and (script-eval (-> this open-test)) (-> *setting-control* user-current airlock))
                                )
                           )
                      s5-0
                      (let ((f0-8 (check-crossing-distance this (camera-pos) #f)))
                        (and (or (not *target*) (not (logtest? (-> *target* focus-status) (focus-status in-head))))
                             (or (< (* f30-0 f0-8) 0.0)
                                 (and (< (fabs f0-8) 4096.0)
                                      (< (vector-vector-xz-distance (camera-pos) (-> this root trans)) (-> this door-radius))
                                      )
                                 )
                             )
                        )
                      )
                  )
             )
           )
      )
    )
  )

;; definition for method 24 of type com-airlock
(defmethod destination-loaded? ((this com-airlock) (display? symbol))
  (let ((level-list (the-as pair (script-eval (-> this level-name))))
        (borrow-lev-name #f)
        )
    (cond
      ((not (the-as object level-list))
       (if display?
           'unknown
           #f
           )
       )
      (display?
        (let* ((level-list-iter level-list)
               (lev-name (car (the-as object level-list-iter)))
               )
          (while (not (null? (the-as object level-list-iter)))
            (let ((v1-4 (level-status *level* (the-as symbol lev-name))))
              (if (not (or (= v1-4 'loaded) (= v1-4 'active)))
                  (return #f)
                  )
              )
            (if (= lev-name 'ctywide)
                (set! borrow-lev-name (-> ctywide borrow-level 1))
                )
            (set! level-list-iter (cdr (the-as object level-list-iter)))
            (set! lev-name (car level-list-iter))
            )
          )
        (when borrow-lev-name
          (let ((v1-17 (level-status *level* borrow-lev-name)))
            (if (not (or (= v1-17 'loaded) (= v1-17 'active)))
                (return #f)
                )
            )
          )
        (if (!= display? 'display)
            (return #t)
            )
        (let ((a1-7 (car (the-as object level-list))))
          (while (not (null? (the-as object level-list)))
            (let ((v1-26 (level-get *level* (the-as symbol a1-7))))
              (if (not (and v1-26 (= (-> v1-26 status) 'active) (-> v1-26 display?)))
                  (return #f)
                  )
              )
            (set! level-list (cdr (the-as object level-list)))
            (set! a1-7 (car level-list))
            )
          )
        #t
        )
      (else
        (let* ((v1-33 (the-as object level-list))
               (a0-11 (car v1-33))
               )
          (while (not (null? v1-33))
            (dotimes (a1-10 6)
              (if (= a0-11 (-> *load-state* want a1-10 name))
                  (goto cfg-50)
                  )
              )
            #t
            (return #f)
            (label cfg-50)
            (set! v1-33 (cdr v1-33))
            (set! a0-11 (car (the-as pair v1-33)))
            )
          )
        #t
        )
      )
    )
  )

;; definition for method 26 of type com-airlock
(defmethod rotate-gear! ((this com-airlock) (arg0 float))
  (when (nonzero? (-> this gear))
    (if (and (zero? (-> this gear-sound-id))
             (-> this sound-gear)
             (and (-> this next-state) (= (-> this next-state name) 'open))
             (>= (check-crossing-distance this (target-pos 0) #f) 0.0)
             )
        (set! (-> this gear-sound-id) (sound-play-by-spec (-> this sound-gear) (new-sound-id) (the-as vector #t)))
        )
    (seek! (-> this gear-rotv) arg0 (* 131072.0 (seconds-per-frame)))
    (+! (-> this gear-rot) (* (-> this gear-rotv) (seconds-per-frame)))
    (twist-set! (-> this gear) (the-as float #f) (the-as float #f) (-> this gear-rot))
    )
  (-> this gear-rotv)
  )

;; definition for method 27 of type com-airlock
;; WARN: Return type mismatch int vs none.
(defmethod play-city-voice-sound ((this com-airlock) (arg0 symbol))
  (let ((gp-0 (the-as (array string) #f)))
    (case arg0
      (('enter)
       (set! gp-0 (new 'static 'boxed-array :type string "cityv005" "cityv006" "cityv007" "cityv008" "cityv009"))
       )
      (('exit)
       (set! gp-0 (new 'static 'boxed-array :type string "cityv001" "cityv002" "cityv003" "cityv004"))
       )
      )
    (cond
      ((and gp-0 (time-elapsed? (-> this spool-sound-time) (seconds 2)))
       (set-time! (-> this spool-sound-time))
       (add-process
         *gui-control*
         this
         (gui-channel alert)
         (gui-action play)
         (-> (the-as (array string) (+ (* (rand-vu-int-range 0 (+ (-> gp-0 length) -1)) 4) (the-as int gp-0))) 0)
         -99.0
         0
         )
       )
      (else
        0
        )
      )
    )
  (none)
  )

;; failed to figure out what this is:
(defskelgroup skel-com-airlock-outer com-airlock-outer com-airlock-outer-lod0-jg com-airlock-outer-idle-ja
              ((com-airlock-outer-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 5 0 14)
              )

;; failed to figure out what this is:
(defskelgroup skel-com-airlock-inner com-airlock-inner com-airlock-inner-lod0-jg com-airlock-inner-idle-ja
              ((com-airlock-inner-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 5 0 14)
              )

;; failed to figure out what this is:
(defstate close (com-airlock)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('close)
       (set! (-> self latch-closed-time) (+ (current-time) (if (>= argc 1)
                                                               (the-as int (-> block param 0))
                                                               3000
                                                               )
                                            )
             )
       (if (and (>= argc 2) (and (= (-> block param 1) #t) (not (want-cross-airlock? self))))
           (ja :group! (get-art-by-name (-> self draw art-group) "idle" art-joint-anim) :num! min)
           )
       (and (-> self next-state) (= (-> self next-state name) 'open))
       )
      (('open)
       (set! (-> self latch-open-time) (+ (current-time) (if (>= argc 1)
                                                             (the-as int (-> block param 0))
                                                             3000
                                                             )
                                          )
             )
       (if (and (>= argc 2) (and (= (-> block param 1) #t) (want-cross-airlock? self) (destination-loaded? self #f)))
           (ja :group! (get-art-by-name (-> self draw art-group) "idle" art-joint-anim) :num! max)
           )
       (and (-> self next-state) (= (-> self next-state name) 'close))
       )
      (('front)
       (let ((f30-0 (check-crossing-distance self (target-pos 0) #f))
             (f0-3 (check-crossing-distance self (camera-pos) #f))
             )
         (and (< 2048.0 f30-0) (>= (* f30-0 f0-3) 0.0))
         )
       )
      (('back)
       (let ((f30-1 (check-crossing-distance self (target-pos 0) #f))
             (f0-5 (check-crossing-distance self (camera-pos) #f))
             )
         (and (< f30-1 -2048.0) (>= (* f30-1 f0-5) 0.0))
         )
       )
      (('sound)
       (if (>= (check-crossing-distance self (target-pos 0) #f) 0.0)
           (play-city-voice-sound self (the-as symbol (-> block param 0)))
           )
       )
      (('distance)
       (* (the int (check-crossing-distance self (target-pos 0) #f)) 8)
       )
      )
    )
  :enter (behavior ((arg0 symbol))
    (set! (-> self visible-move?) #f)
    )
  :exit (behavior ()
    (when (nonzero? (-> self sound-id))
      (let ((v1-2 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> v1-2 command) (sound-command set-param))
        (set! (-> v1-2 id) (-> self sound-id))
        (set! (-> v1-2 params volume) -4)
        (set! (-> v1-2 auto-time) 24)
        (set! (-> v1-2 auto-from) 2)
        (set! (-> v1-2 params mask) (the-as uint 17))
        (-> v1-2 id)
        )
      (set! (-> self sound-id) (new 'static 'sound-id))
      0
      )
    (when (nonzero? (-> self gear-sound-id))
      (let ((v1-6 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> v1-6 command) (sound-command set-param))
        (set! (-> v1-6 id) (-> self gear-sound-id))
        (set! (-> v1-6 params volume) -4)
        (set! (-> v1-6 auto-time) 24)
        (set! (-> v1-6 auto-from) 2)
        (set! (-> v1-6 params mask) (the-as uint 17))
        (-> v1-6 id)
        )
      (set! (-> self gear-sound-id) (new 'static 'sound-id))
      0
      )
    )
  :trans (behavior ()
    (if (logtest? (-> self draw status) (draw-control-status on-screen))
        (set! (-> self visible-move?) #t)
        )
    (when (and (want-cross-airlock? self) (begin
                                            (let ((gp-0 (res-lump-struct (-> self entity) 'on-activate structure)))
                                              (if gp-0
                                                  (script-eval (the-as pair gp-0))
                                                  )
                                              )
                                            (destination-loaded? self #f)
                                            )
               )
      (when (nonzero? (-> self sound-id))
        (let ((v1-17 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-17 command) (sound-command set-param))
          (set! (-> v1-17 id) (-> self sound-id))
          (set! (-> v1-17 params volume) -4)
          (set! (-> v1-17 auto-time) 24)
          (set! (-> v1-17 auto-from) 2)
          (set! (-> v1-17 params mask) (the-as uint 17))
          (-> v1-17 id)
          )
        (set! (-> self sound-id) (new 'static 'sound-id))
        0
        )
      (go-virtual open #f)
      )
    )
  :code (behavior ((arg0 symbol))
    (process-entity-status! self (entity-perm-status subtask-complete) #f)
    (when (not arg0)
      (if (and (-> self sound-close)
               (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                    (not arg0)
                    (-> self visible-move?)
                    )
               )
          (sound-play-by-spec (-> self sound-close) (new-sound-id) (the-as vector #t))
          )
      (if (and (-> self sound-close-loop)
               (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                    (not arg0)
                    (-> self visible-move?)
                    )
               )
          (set! (-> self sound-id) (sound-play-by-spec (-> self sound-close-loop) (new-sound-id) (the-as vector #t)))
          )
      (while (< (-> self open-frame) (ja-aframe-num 0))
        (rotate-gear! self 65536.0)
        (when (and (-> self were-behind?)
                   (< 0.4 (vector-dot
                            (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat))
                            (-> (math-camera-matrix) vector 2)
                            )
                      )
                   (< 0.0 (check-crossing-distance self (target-pos 0) #f))
                   )
          (ja :num-func num-func-identity :frame-num (ja-aframe (-> self open-frame) 0))
          (goto cfg-42)
          )
        (suspend)
        (ja :num! (seek! 0.0 2.0))
        (transform-post)
        )
      (label cfg-42)
      (if (< 0.0 (check-crossing-distance self (target-pos 0) #f))
          ((lambda :behavior com-airlock
             ()
             (let ((gp-0 (res-lump-struct (-> self entity) 'on-exit structure)))
               (if (and gp-0 (not *scene-player*))
                   (script-eval (the-as pair gp-0))
                   )
               )
             (the-as pair (when (-> self were-behind?)
                            (let ((gp-1 (res-lump-struct (-> self entity) 'on-inside structure)))
                              (set! (-> self were-behind?) #f)
                              (if (and gp-1 (not *scene-player*))
                                  (script-eval (the-as pair gp-1))
                                  )
                              )
                            )
                     )
             )
           )
          )
      (when (nonzero? (-> self sound-id))
        (let ((v1-46 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-46 command) (sound-command set-param))
          (set! (-> v1-46 id) (-> self sound-id))
          (set! (-> v1-46 params volume) -4)
          (set! (-> v1-46 auto-time) 24)
          (set! (-> v1-46 auto-from) 2)
          (set! (-> v1-46 params mask) (the-as uint 17))
          (-> v1-46 id)
          )
        (set! (-> self sound-id) (new 'static 'sound-id))
        0
        )
      (if (and (-> self sound-close-stop) (not arg0) (-> self visible-move?))
          (sound-play-by-spec (-> self sound-close-stop) (new-sound-id) (the-as vector #t))
          )
      (while (not (ja-min? 0))
        (if (and (zero? (-> self sound-id))
                 (-> self sound-post-close)
                 (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                      (not arg0)
                      (-> self visible-move?)
                      )
                 )
            (set! (-> self sound-id) (sound-play-by-spec (-> self sound-post-close) (new-sound-id) (the-as vector #t)))
            )
        (rotate-gear! self 65536.0)
        (suspend)
        (ja :num! (seek! 0.0))
        (transform-post)
        )
      (when (nonzero? (-> self sound-id))
        (let ((v1-71 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-71 command) (sound-command set-param))
          (set! (-> v1-71 id) (-> self sound-id))
          (set! (-> v1-71 params volume) -4)
          (set! (-> v1-71 auto-time) 24)
          (set! (-> v1-71 auto-from) 2)
          (set! (-> v1-71 params mask) (the-as uint 17))
          (-> v1-71 id)
          )
        (set! (-> self sound-id) (new 'static 'sound-id))
        (if (-> self sound-post-close-stop)
            (sound-play-by-spec (-> self sound-post-close-stop) (new-sound-id) (the-as vector #t))
            )
        )
      (when (< 0.0 (check-crossing-distance self (target-pos 0) #f))
        (let ((gp-3 (res-lump-struct (-> self entity) 'on-deactivate structure)))
          (if (and gp-3 (not *scene-player*))
              (script-eval (the-as pair gp-3))
              )
          )
        )
      (while (!= (-> self gear-rotv) 0.0)
        (rotate-gear! self 0.0)
        (suspend)
        (transform-post)
        )
      (when (nonzero? (-> self gear-sound-id))
        (let ((v1-91 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-91 command) (sound-command set-param))
          (set! (-> v1-91 id) (-> self gear-sound-id))
          (set! (-> v1-91 params volume) -4)
          (set! (-> v1-91 auto-time) 24)
          (set! (-> v1-91 auto-from) 2)
          (set! (-> v1-91 params mask) (the-as uint 17))
          (-> v1-91 id)
          )
        (set! (-> self gear-sound-id) (new 'static 'sound-id))
        0
        )
      )
    (ja :group! (get-art-by-name (-> self draw art-group) "idle" art-joint-anim) :num! min)
    (transform-post)
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend)
    0
    )
  )

;; failed to figure out what this is:
(defstate open (com-airlock)
  :virtual #t
  :event (-> (method-of-type com-airlock close) event)
  :enter (behavior ((arg0 symbol))
    (set! (-> self visible-move?) #f)
    )
  :exit (-> (method-of-type com-airlock close) exit)
  :trans (behavior ()
    (if (logtest? (-> self draw status) (draw-control-status on-screen))
        (set! (-> self visible-move?) #t)
        )
    (if (not (want-cross-airlock? self))
        (go-virtual close #f)
        )
    (when (logtest? (-> self mask) (process-mask sleep-code))
      (let ((v1-14 (destination-loaded? self 'display)))
        (when (or (not v1-14) (= v1-14 'unknown))
          (if (and (not v1-14) (< (-> self open-frame) (ja-aframe-num 0)))
              (ja :num-func num-func-identity :frame-num (ja-aframe (-> self open-frame) 0))
              )
          (go-virtual close #f)
          )
        )
      )
    )
  :code (behavior ((arg0 symbol))
    (when (not arg0)
      (when (< (check-crossing-distance self (target-pos 0) #f) 0.0)
        (if (< (ja-aframe-num 0) (-> self pre-open-frame))
            (ja :num-func num-func-identity :frame-num (ja-aframe (-> self pre-open-frame) 0))
            )
        )
      (while (< (ja-aframe-num 0) (-> self lock-frame))
        (if (and (zero? (-> self sound-id))
                 (-> self sound-pre-open)
                 (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                      (not arg0)
                      (-> self visible-move?)
                      )
                 )
            (set! (-> self sound-id) (sound-play-by-spec (-> self sound-pre-open) (new-sound-id) (the-as vector #t)))
            )
        (rotate-gear! self 65536.0)
        (suspend)
        (ja :num! (seek! (ja-aframe (-> self lock-frame) 0) (-> self pre-open-speed)))
        (transform-post)
        )
      (when (nonzero? (-> self sound-id))
        (let ((v1-26 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-26 command) (sound-command set-param))
          (set! (-> v1-26 id) (-> self sound-id))
          (set! (-> v1-26 params volume) -4)
          (set! (-> v1-26 auto-time) 24)
          (set! (-> v1-26 auto-from) 2)
          (set! (-> v1-26 params mask) (the-as uint 17))
          (-> v1-26 id)
          )
        (set! (-> self sound-id) (new 'static 'sound-id))
        (if (-> self sound-pre-open-stop)
            (sound-play-by-spec (-> self sound-pre-open-stop) (new-sound-id) (the-as vector #t))
            )
        )
      (while (< (ja-aframe-num 0) (-> self open-frame))
        (if (and (zero? (-> self sound-id))
                 (-> self sound-lock-loop)
                 (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                      (not arg0)
                      (-> self visible-move?)
                      )
                 )
            (set! (-> self sound-id) (sound-play-by-spec (-> self sound-lock-loop) (new-sound-id) (the-as vector #t)))
            )
        (rotate-gear! self 65536.0)
        (suspend)
        (ja :num! (seek! (ja-aframe (-> self open-frame) 0) 2.0))
        (transform-post)
        )
      (when (nonzero? (-> self sound-id))
        (let ((v1-49 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-49 command) (sound-command set-param))
          (set! (-> v1-49 id) (-> self sound-id))
          (set! (-> v1-49 params volume) -4)
          (set! (-> v1-49 auto-time) 24)
          (set! (-> v1-49 auto-from) 2)
          (set! (-> v1-49 params mask) (the-as uint 17))
          (-> v1-49 id)
          )
        (set! (-> self sound-id) (new 'static 'sound-id))
        (if (-> self sound-lock-stop)
            (sound-play-by-spec (-> self sound-lock-stop) (new-sound-id) (the-as vector #t))
            )
        )
      (while (not (destination-loaded? self #t))
        (rotate-gear! self 65536.0)
        (suspend)
        (transform-post)
        )
      (process-entity-status! self (entity-perm-status subtask-complete) #t)
      (let ((s5-10 (res-lump-struct (-> self entity) 'on-enter structure)))
        (if s5-10
            (script-eval (the-as pair s5-10))
            )
        )
      (if (and (-> self sound-open)
               (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                    (not arg0)
                    (-> self visible-move?)
                    )
               )
          (sound-play-by-spec (-> self sound-open) (new-sound-id) (the-as vector #t))
          )
      (if (and (-> self sound-open-loop)
               (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                    (not arg0)
                    (-> self visible-move?)
                    )
               )
          (set! (-> self sound-id) (sound-play-by-spec (-> self sound-open-loop) (new-sound-id) (the-as vector #t)))
          )
      (set! (-> *ACTOR-bank* birth-max) 1000)
      (while (not (ja-max? 0))
        (rotate-gear! self 65536.0)
        (suspend)
        (ja :num! (seek!))
        (transform-post)
        )
      (when (nonzero? (-> self sound-id))
        (let ((v1-94 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-94 command) (sound-command set-param))
          (set! (-> v1-94 id) (-> self sound-id))
          (set! (-> v1-94 params volume) -4)
          (set! (-> v1-94 auto-time) 24)
          (set! (-> v1-94 auto-from) 2)
          (set! (-> v1-94 params mask) (the-as uint 17))
          (-> v1-94 id)
          )
        (set! (-> self sound-id) (new 'static 'sound-id))
        0
        )
      (when (nonzero? (-> self gear-sound-id))
        (let ((v1-99 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-99 command) (sound-command set-param))
          (set! (-> v1-99 id) (-> self gear-sound-id))
          (set! (-> v1-99 params volume) -4)
          (set! (-> v1-99 auto-time) 24)
          (set! (-> v1-99 auto-from) 2)
          (set! (-> v1-99 params mask) (the-as uint 17))
          (-> v1-99 id)
          )
        (set! (-> self gear-sound-id) (new 'static 'sound-id))
        0
        )
      (if (and (-> self sound-open-stop) (not arg0) (-> self visible-move?))
          (sound-play-by-spec (-> self sound-open-stop) (new-sound-id) (the-as vector #t))
          )
      )
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (ja :group! (get-art-by-name (-> self draw art-group) "idle" art-joint-anim) :num! max)
    (transform-post)
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend)
    0
    )
  )

;; definition of type com-airlock-outer
(deftype com-airlock-outer (com-airlock)
  ()
  )

;; definition for method 3 of type com-airlock-outer
(defmethod inspect ((this com-airlock-outer))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type com-airlock inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 11 of type com-airlock-outer
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this com-airlock-outer) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 20480.0 0.0 57344.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 0.0 20480.0 0.0 32768.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 7)
      (set-vector! (-> v1-10 local-sphere) 0.0 20480.0 0.0 32768.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (init-airlock! this)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-com-airlock-outer" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this pre-open-frame) 35.0)
  (set! (-> this lock-frame) 45.0)
  (set! (-> this open-frame) 45.0)
  (set! (-> this sound-pre-open) (static-sound-spec "airlock-slider"))
  (set! (-> this sound-pre-open-stop) (static-sound-spec "airlock-slide-e"))
  (set! (-> this sound-open) (static-sound-spec "airlock-seal"))
  (set! (-> this sound-open-loop) (static-sound-spec "airlock-open"))
  (set! (-> this sound-open-stop) (static-sound-spec "airlock-hit"))
  (set! (-> this sound-close-loop) (static-sound-spec "airlock-open"))
  (set! (-> this sound-close-stop) (static-sound-spec "airlock-hit"))
  (set! (-> this sound-post-close) (static-sound-spec "airlock-slider"))
  (set! (-> this sound-post-close-stop) (static-sound-spec "airlock-slide-e"))
  (go (method-of-object this close) #t)
  (none)
  )

;; definition of type com-airlock-inner
(deftype com-airlock-inner (com-airlock)
  ()
  )

;; definition for method 3 of type com-airlock-inner
(defmethod inspect ((this com-airlock-inner))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type com-airlock inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 11 of type com-airlock-inner
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this com-airlock-inner) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 20480.0 0.0 57344.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 0.0 20480.0 0.0 32768.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 8)
      (set-vector! (-> v1-10 local-sphere) 0.0 20480.0 0.0 32768.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-com-airlock-inner" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-airlock! this)
  (set! (-> this lock-frame) 37.0)
  (set! (-> this pre-open-frame) 65.0)
  (set! (-> this open-frame) 75.0)
  (set! (-> this gear) (new 'process 'joint-mod (joint-mod-mode rotate) this 12))
  (set! (-> this inner?)
        (logtest? (the-as
                    int
                    (res-lump-value (-> this entity) 'options uint128 :default (the-as uint128 1) :time -1000000000.0)
                    )
                  1
                  )
        )
  (set! (-> this pre-open-speed) 0.9)
  (set! (-> this sound-gear) (static-sound-spec "airlock-gear"))
  (set! (-> this sound-pre-open) (static-sound-spec "airlock-slider"))
  (set! (-> this sound-pre-open-stop) (static-sound-spec "airlock-slide-e"))
  (set! (-> this sound-lock-loop) (static-sound-spec "airlock-turn"))
  (set! (-> this sound-lock-stop) (static-sound-spec "airlock-unlock"))
  (set! (-> this sound-open) (static-sound-spec "airlock-seal"))
  (set! (-> this sound-open-loop) (static-sound-spec "airlock-open"))
  (set! (-> this sound-open-stop) (static-sound-spec "airlock-hit"))
  (set! (-> this sound-close-loop) (static-sound-spec "airlock-open"))
  (set! (-> this sound-close-stop) (static-sound-spec "airlock-hit"))
  (go (method-of-object this close) #t)
  (none)
  )

;; failed to figure out what this is:
(defskelgroup skel-fort-entry-gate fort-entry-gate fort-entry-gate-lod0-jg fort-entry-gate-idle-ja
              ((fort-entry-gate-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 3 0 10)
              )

;; definition of type fort-entry-gate
(deftype fort-entry-gate (com-airlock)
  ()
  )

;; definition for method 3 of type fort-entry-gate
(defmethod inspect ((this fort-entry-gate))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type com-airlock inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 11 of type fort-entry-gate
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this fort-entry-gate) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 12288.0 0.0 40960.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 8192.0 16384.0 0.0 20480.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 5)
      (set-vector! (-> v1-10 local-sphere) -8192.0 16384.0 0.0 20480.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-fort-entry-gate" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-airlock! this)
  (set! (-> this sound-open-loop) (static-sound-spec "door-open"))
  (set! (-> this sound-open-stop) (static-sound-spec "door-stop-open"))
  (set! (-> this sound-close-loop) (static-sound-spec "door-close"))
  (set! (-> this sound-close-stop) (static-sound-spec "door-stop-close"))
  (go (method-of-object this close) #t)
  (none)
  )

;; failed to figure out what this is:
(defskelgroup skel-hip-door-a hip-door-a hip-door-a-lod0-jg hip-door-a-idle-ja
              ((hip-door-a-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 2 0 5)
              )

;; definition of type hip-door-a
(deftype hip-door-a (com-airlock)
  ()
  )

;; definition for method 3 of type hip-door-a
(defmethod inspect ((this hip-door-a))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type com-airlock inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 11 of type hip-door-a
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this hip-door-a) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 8192.0 0.0 20480.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 0.0 8192.0 0.0 16384.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 5)
      (set-vector! (-> v1-10 local-sphere) 0.0 8192.0 0.0 16384.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-hip-door-a" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-airlock! this)
  (set! (-> this sound-open-loop) (static-sound-spec "wood-door-open"))
  (set! (-> this sound-open-stop) (static-sound-spec "wood-open-hit"))
  (set! (-> this sound-close-loop) (static-sound-spec "wood-door-close"))
  (set! (-> this sound-close-stop) (static-sound-spec "wood-close-hit"))
  (set! (-> this door-radius) 8192.0)
  (go (method-of-object this close) #t)
  (none)
  )

;; failed to figure out what this is:
(defskelgroup skel-tomb-mar-door tomb-mar-door tomb-mar-door-lod0-jg tomb-mar-door-idle-ja
              ((tomb-mar-door-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 6 0 18)
              :origin-joint-index 3
              )

;; definition of type tomb-mar-door
(deftype tomb-mar-door (com-airlock)
  ()
  )

;; definition for method 3 of type tomb-mar-door
(defmethod inspect ((this tomb-mar-door))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type com-airlock inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 11 of type tomb-mar-door
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this tomb-mar-door) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) 0.0 24576.0 0.0 73728.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-2)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tomb-mar-door" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-airlock! this)
  (set! (-> this sound-open-loop) (static-sound-spec "wing-door-open"))
  (set! (-> this sound-open-stop) (static-sound-spec "wing-open-hit"))
  (set! (-> this sound-close-loop) (static-sound-spec "wing-door-close"))
  (set! (-> this sound-close-stop) (static-sound-spec "wing-close-hit"))
  (go (method-of-object this close) #t)
  (none)
  )

;; definition of type cas-front-door
(deftype cas-front-door (com-airlock-outer)
  ()
  )

;; definition for method 3 of type cas-front-door
(defmethod inspect ((this cas-front-door))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type com-airlock-outer inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-pal-throne-door pal-throne-door pal-throne-door-lod0-jg pal-throne-door-idle-ja
              ((pal-throne-door-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 6 0 24)
              :origin-joint-index 3
              )

;; definition of type pal-throne-door
(deftype pal-throne-door (com-airlock)
  ()
  )

;; definition for method 3 of type pal-throne-door
(defmethod inspect ((this pal-throne-door))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type com-airlock inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 11 of type pal-throne-door
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this pal-throne-door) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 24576.0 0.0 73728.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 5)
      (set-vector! (-> v1-8 local-sphere) 0.0 -24576.0 0.0 65536.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 4)
      (set-vector! (-> v1-10 local-sphere) 0.0 -24576.0 0.0 65536.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-pal-throne-door" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-airlock! this)
  (set! (-> this sound-open-loop) (static-sound-spec "wood-door-slide"))
  (set! (-> this sound-open-stop) (static-sound-spec "wood-door-hit"))
  (set! (-> this sound-close-loop) (static-sound-spec "wood-door-slide"))
  (set! (-> this sound-close-stop) (static-sound-spec "wood-door-hit"))
  (set! (-> this sound-behind?) #t)
  (go (method-of-object this close) #t)
  (none)
  )

;; failed to figure out what this is:
(defskelgroup skel-vin-door-ctyinda vin-door-ctyinda vin-door-ctyinda-lod0-jg vin-door-ctyinda-idle-ja
              ((vin-door-ctyinda-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 3 0 6)
              )

;; definition of type vin-door-ctyinda
(deftype vin-door-ctyinda (com-airlock)
  ()
  )

;; definition for method 3 of type vin-door-ctyinda
(defmethod inspect ((this vin-door-ctyinda))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type com-airlock inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 11 of type vin-door-ctyinda
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this vin-door-ctyinda) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 12288.0 0.0 24576.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 8192.0 16384.0 0.0 20480.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 5)
      (set-vector! (-> v1-10 local-sphere) -8192.0 16384.0 0.0 20480.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-vin-door-ctyinda" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-airlock! this)
  (set! (-> this sound-open-loop) (static-sound-spec "wood-door-open"))
  (set! (-> this sound-open-stop) (static-sound-spec "wood-open-hit"))
  (set! (-> this sound-close-loop) (static-sound-spec "wood-door-close"))
  (set! (-> this sound-close-stop) (static-sound-spec "wood-close-hit"))
  (set! (-> this door-radius) 8192.0)
  (go (method-of-object this close) #t)
  (none)
  )

;; failed to figure out what this is:
(defskelgroup skel-under-door hip-door-a hip-door-a-lod0-jg hip-door-a-idle-ja
              ((hip-door-a-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 2 0 5)
              )

;; definition of type under-door
(deftype under-door (com-airlock)
  ()
  )

;; definition for method 3 of type under-door
(defmethod inspect ((this under-door))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type com-airlock inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 11 of type under-door
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this under-door) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 8192.0 0.0 20480.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 0.0 8192.0 0.0 16384.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 5)
      (set-vector! (-> v1-10 local-sphere) 0.0 8192.0 0.0 16384.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-under-door" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-airlock! this)
  (set! (-> this sound-open-loop) (static-sound-spec "wood-door-open"))
  (set! (-> this sound-open-stop) (static-sound-spec "wood-open-hit"))
  (set! (-> this sound-close-loop) (static-sound-spec "wood-door-close"))
  (set! (-> this sound-close-stop) (static-sound-spec "wood-close-hit"))
  (set! (-> this door-radius) 8192.0)
  (go (method-of-object this close) #t)
  (none)
  )

;; failed to figure out what this is:
(defskelgroup skel-oracle-door oracle-door oracle-door-lod0-jg oracle-door-idle-ja
              ((oracle-door-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 4 0 10)
              )

;; definition of type oracle-door
(deftype oracle-door (com-airlock)
  ()
  )

;; definition for method 3 of type oracle-door
(defmethod inspect ((this oracle-door))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type com-airlock inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 11 of type oracle-door
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this oracle-door) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 8192.0 0.0 20480.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 0.0 8192.0 0.0 16384.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 5)
      (set-vector! (-> v1-10 local-sphere) 0.0 8192.0 0.0 16384.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-oracle-door" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-airlock! this)
  (set! (-> this sound-open-loop) (static-sound-spec "wood-door-open"))
  (set! (-> this sound-open-stop) (static-sound-spec "wood-open-hit"))
  (set! (-> this sound-close-loop) (static-sound-spec "wood-door-close"))
  (set! (-> this sound-close-stop) (static-sound-spec "wood-close-hit"))
  (go (method-of-object this close) #t)
  (none)
  )
