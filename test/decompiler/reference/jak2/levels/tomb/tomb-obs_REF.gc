;;-*-Lisp-*-
(in-package goal)

;; definition of type tomb-plat-wall
(deftype tomb-plat-wall (plat)
  ((position  vector  :inline)
   (last-pos  float)
   )
  )

;; definition for method 3 of type tomb-plat-wall
(defmethod inspect ((this tomb-plat-wall))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type plat inspect)))
    (t9-0 this)
    )
  (format #t "~2Tposition: #<vector @ #x~X>~%" (-> this position))
  (format #t "~2Tlast-pos: ~f~%" (-> this last-pos))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-tomb-plat-wall tomb-plat-wall tomb-plat-wall-lod0-jg tomb-plat-wall-idle-ja
              ((tomb-plat-wall-lod0-mg (meters 20)) (tomb-plat-wall-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 -5 4 8.5)
              :origin-joint-index 3
              )

;; definition for method 30 of type tomb-plat-wall
(defmethod get-art-group ((this tomb-plat-wall))
  "@returns The associated [[art-group]]"
  (art-group-get-by-name *level* "skel-tomb-plat-wall" (the-as (pointer uint32) #f))
  )

;; failed to figure out what this is:
(defstate plat-idle (tomb-plat-wall)
  :virtual #t
  :event plat-event
  :exit (behavior ()
    (when (nonzero? (-> self sound-id))
      (sound-stop (-> self sound-id))
      (set! (-> self sound-id) (new 'static 'sound-id))
      0
      )
    )
  :trans (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (let ((f30-0 (get-norm! (-> self sync) 0)))
        (let ((s5-0 (-> self basetrans)))
          (let ((gp-0 (-> self position)))
            (let ((v1-3 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat))))
              (let ((a0-3 (* -32768.0 f30-0)))
                (.mov vf7 a0-3)
                )
              (.lvf vf5 (&-> v1-3 quad))
              )
            (.lvf vf4 (&-> gp-0 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> s5-0 quad) vf6)
          )
        (cond
          ((and (!= f30-0 0.0) (!= f30-0 1.0))
           (if (zero? (-> self sound-id))
               (set! (-> self sound-id) (sound-play "tomb-plat-wall"))
               )
           )
          (else
            (when (nonzero? (-> self sound-id))
              (sound-stop (-> self sound-id))
              (set! (-> self sound-id) (new 'static 'sound-id))
              0
              )
            )
          )
        (if (or (and (= f30-0 1.0) (!= (-> self last-pos) 1.0)) (and (= f30-0 0.0) (!= (-> self last-pos) 0.0)))
            (sound-play "plat-wall-hit")
            )
        (set! (-> self last-pos) f30-0)
        )
      (plat-trans)
      )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post plat-post
  )

;; definition for method 32 of type tomb-plat-wall
;; WARN: Return type mismatch int vs none.
(defmethod base-plat-method-32 ((this tomb-plat-wall))
  0
  (none)
  )

;; definition for method 31 of type tomb-plat-wall
;; WARN: Return type mismatch int vs none.
(defmethod init-plat-collision! ((this tomb-plat-wall))
  "TODO - collision stuff for setting up the platform"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable pull-rider-can-collide))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 16384.0 0.0 30720.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) (the-as collide-shape-moving s5-0))
    )
  0
  (none)
  )

;; definition for method 11 of type tomb-plat-wall
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this tomb-plat-wall) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (logior! (-> this mask) (process-mask platform))
  (init-plat-collision! this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this (the-as skeleton-group (get-art-group this)) (the-as pair 0))
  (set! (-> this draw light-index) (the-as uint 1))
  (update-transforms (-> this root))
  (stop-bouncing! this)
  (base-plat-method-32 this)
  (set! (-> this fact)
        (new 'process 'fact-info this (pickup-type eco-pill-random) (-> *FACT-bank* default-eco-pill-green-inc))
        )
  (let ((a1-4 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-16 0))
      (if (not (logtest? (-> this fact options) (actor-option loop)))
          (set! v1-16 (logior v1-16 1))
          )
      (set! (-> a1-4 sync-type) 'sync-eased)
      (set! (-> a1-4 sync-flags) (the-as sync-flags v1-16))
      )
    (set! (-> a1-4 period) (the-as uint 1200))
    (set! (-> a1-4 entity) arg0)
    (set! (-> a1-4 percent) 0.0)
    (set! (-> a1-4 ease-in) 0.15)
    (set! (-> a1-4 ease-out) 0.15)
    (set! (-> a1-4 pause-in) 0.0)
    (set! (-> a1-4 pause-out) 0.0)
    (initialize! (-> this sync) a1-4)
    )
  (set! (-> this sound-id) (new 'static 'sound-id))
  (set! (-> this position quad) (-> this root trans quad))
  (set! (-> this last-pos) 0.0)
  (go (method-of-object this plat-idle))
  (none)
  )

;; definition of type tomb-stair-block-spikes
(deftype tomb-stair-block-spikes (process-drawable)
  ((root  collide-shape-moving :override)
   )
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type tomb-stair-block-spikes
(defmethod inspect ((this tomb-stair-block-spikes))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-tomb-stair-block-spikes tomb-stair-block-spikes tomb-stair-block-spikes-lod0-jg tomb-stair-block-spikes-idle-ja
              ((tomb-stair-block-spikes-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

;; definition for function tomb-stair-block-collision
;; WARN: Return type mismatch int vs object.
(defbehavior tomb-stair-block-collision tomb-stair-block-spikes ((arg0 symbol))
  (let ((v1-1 (-> self root root-prim)))
    (cond
      (arg0
        (set! (-> v1-1 prim-core collide-with) (collide-spec jak bot player-list))
        (let ((v0-0 (the-as int (-> v1-1 specific 1))))
          (set! (-> v1-1 specific 0) (the-as uint v0-0))
          v0-0
          )
        )
      (else
        (set! (-> v1-1 prim-core collide-with) (collide-spec))
        (set! (-> v1-1 specific 0) (the-as uint 0))
        0
        )
      )
    )
  )

;; failed to figure out what this is:
(defstate idle (tomb-stair-block-spikes)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('sound)
       (sound-play "tomb-spikes")
       )
      (('set-position)
       (let ((v0-1 (the-as object (-> self root trans))))
         (set! (-> (the-as vector v0-1) quad) (-> (the-as vector (-> block param 0)) quad))
         v0-1
         )
       )
      (('enable-collision)
       (tomb-stair-block-collision #t)
       )
      (('touch)
       (when (= proc *target*)
         (send-event
           proc
           'attack
           #f
           (static-attack-info ((id (new-attack-id)) (shove-up (meters 2)) (shove-back (meters 0))))
           )
         (tomb-stair-block-collision #f)
         )
       )
      )
    )
  :code sleep-code
  :post transform-post
  )

;; definition for function tomb-stair-block-spikes-init-by-other
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defbehavior tomb-stair-block-spikes-init-by-other tomb-stair-block-spikes ((arg0 vector))
  (local-vars (sv-16 collide-shape-prim-mesh) (sv-32 type) (sv-48 collide-shape))
  (let ((s5-0 (new 'process 'collide-shape self (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 1) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 2))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 root-prim) s4-0)
      (pusher-init s5-0)
      (let* ((s3-0 (the-as object '((0 3 20480))))
             (s2-0 (-> (the-as pair s3-0) car))
             )
        (while (not (null? s3-0))
          (let ((s1-0 (method-of-type collide-shape-prim-mesh new))
                (s0-0 'process)
                )
            (set! sv-32 collide-shape-prim-mesh)
            (set! sv-48 s5-0)
            (let ((a3-2 (command-get-int (-> (the-as pair s2-0) car) 0))
                  (t0-1 0)
                  )
              (set! sv-16 (s1-0 s0-0 sv-32 sv-48 (the-as uint a3-2) (the-as uint t0-1)))
              )
            )
          (let ((s1-1 sv-16))
            (set! (-> s1-1 prim-core collide-as) (-> s4-0 prim-core collide-as))
            (set! (-> s1-1 prim-core collide-with) (-> s4-0 prim-core collide-with))
            (set! (-> s1-1 prim-core action) (-> s4-0 prim-core action))
            (set! (-> s1-1 transform-index) (command-get-int (-> (the-as pair (-> (the-as pair s2-0) cdr)) car) 0))
            )
          (set-vector!
            (-> sv-16 local-sphere)
            0.0
            0.0
            0.0
            (command-get-float (-> (the-as pair (-> (the-as pair (-> (the-as pair s2-0) cdr)) cdr)) car) 0.0)
            )
          (set! s3-0 (-> (the-as pair s3-0) cdr))
          (set! s2-0 (-> (the-as pair s3-0) car))
          )
        )
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-23 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-23 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-23 prim-core collide-with))
      )
    (set! (-> self root) (the-as collide-shape-moving s5-0))
    )
  (set! (-> self root trans quad) (-> arg0 quad))
  (initialize-skeleton
    self
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-tomb-stair-block-spikes" (the-as (pointer uint32) #f))
      )
    (the-as pair 0)
    )
  (set! (-> self draw light-index) (the-as uint 1))
  (quaternion-rotate-y! (-> self root quat) (-> self root quat) 16384.0)
  (go-virtual idle)
  (none)
  )

;; definition of type tomb-stair-block-spike-info
(deftype tomb-stair-block-spike-info (structure)
  ((spike     handle)
   (joint     int32)
   (y-offset  float)
   (up        basic)
   (sounded   basic)
   )
  )

;; definition for method 3 of type tomb-stair-block-spike-info
(defmethod inspect ((this tomb-stair-block-spike-info))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'tomb-stair-block-spike-info)
  (format #t "~1Tspike: ~D~%" (-> this spike))
  (format #t "~1Tjoint: ~D~%" (-> this joint))
  (format #t "~1Ty-offset: ~f~%" (-> this y-offset))
  (format #t "~1Tup: ~A~%" (-> this up))
  (format #t "~1Tsounded: ~A~%" (-> this sounded))
  (label cfg-4)
  this
  )

;; definition of type tomb-stair-block
(deftype tomb-stair-block (process-drawable)
  ((root          collide-shape-moving        :override)
   (initial-y     float)
   (spike-info    tomb-stair-block-spike-info  4 :inline :offset 208)
   (camera-state  int32                                  :offset 336)
   (sink-sound    sound-id                               :offset 340)
   (rise-sound    sound-id                               :offset 344)
   )
  (:state-methods
    wait-for-pools
    idle
    moving
    sink
    sunk
    )
  )

;; definition for method 3 of type tomb-stair-block
(defmethod inspect ((this tomb-stair-block))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tinitial-y: ~f~%" (-> this initial-y))
  (format #t "~2Tspike-info[4] @ #x~X~%" (-> this spike-info))
  (format #t "~2Tcamera-state: ~D~%" (-> this camera-state))
  (format #t "~2Tsink-sound: ~D~%" (-> this sink-sound))
  (format #t "~2Trise-sound: ~D~%" (-> this rise-sound))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-tomb-stair-block tomb-stair-block tomb-stair-block-lod0-jg tomb-stair-block-idle-ja
              ((tomb-stair-block-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 32 0 58)
              )

;; definition for function lift-pool
;; INFO: Used lq/sq
(defbehavior lift-pool tomb-stair-block ((arg0 int))
  (local-vars (sv-16 res-tag))
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-1 (res-lump-data (-> self entity) 'actor-groups (pointer actor-group) :tag-ptr (& sv-16))))
    (when (and v1-1 (< (the-as uint arg0) (-> sv-16 elt-count)) (-> v1-1 arg0) (> (-> v1-1 0 length) 0))
      (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-2 from) (process->ppointer self))
        (set! (-> a1-2 num-params) 1)
        (set! (-> a1-2 message) 'move-to)
        (set! (-> a1-2 param 0) (the-as uint (-> v1-1 arg0 data 0 actor trans)))
        (let ((t9-1 send-event-function)
              (v1-5 (-> v1-1 arg0 data 0 actor))
              )
          (t9-1
            (if v1-5
                (-> v1-5 extra process)
                )
            a1-2
            )
          )
        )
      )
    )
  )

;; definition for function drop-pool
;; INFO: Used lq/sq
(defbehavior drop-pool tomb-stair-block ((arg0 int))
  (local-vars (sv-16 res-tag))
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-1 (res-lump-data (-> self entity) 'actor-groups (pointer actor-group) :tag-ptr (& sv-16))))
    (when (and v1-1 (< (the-as uint arg0) (-> sv-16 elt-count)) (-> v1-1 arg0) (> (-> v1-1 0 length) 0))
      (let ((a0-12 (new 'stack-no-clear 'vector)))
        (set! (-> a0-12 quad) (-> v1-1 arg0 data 0 actor trans quad))
        (+! (-> a0-12 y) -163840.0)
        (let ((a1-4 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-4 from) (process->ppointer self))
          (set! (-> a1-4 num-params) 1)
          (set! (-> a1-4 message) 'move-to)
          (set! (-> a1-4 param 0) (the-as uint a0-12))
          (let ((t9-1 send-event-function)
                (v1-5 (-> v1-1 arg0 data 0 actor))
                )
            (t9-1
              (if v1-5
                  (-> v1-5 extra process)
                  )
              a1-4
              )
            )
          )
        )
      )
    )
  )

;; definition for function position-spikes
(defbehavior position-spikes tomb-stair-block ((arg0 int))
  (let ((s5-0 (and (nonzero? arg0) (< (mod (current-time) arg0) (/ arg0 2))))
        (s4-0 (and (nonzero? arg0) (< (mod (+ (current-time) (seconds 0.75)) arg0) (/ arg0 2))))
        )
    (dotimes (s3-0 4)
      (let ((f0-1 (seek
                    (-> self spike-info s3-0 y-offset)
                    (if s5-0
                        30720.0
                        16384.0
                        )
                    1228.8
                    )
                  )
            )
        (set! (-> self spike-info s3-0 y-offset) f0-1)
        (set! (-> self spike-info s3-0 y-offset) f0-1)
        )
      (if (and s4-0 (not (-> self spike-info s3-0 sounded)))
          (send-event (handle->process (-> self spike-info s3-0 spike)) 'sound)
          )
      (if (and s5-0 (not (-> self spike-info s3-0 up)))
          (send-event (handle->process (-> self spike-info s3-0 spike)) 'enable-collision)
          )
      (set! (-> self spike-info s3-0 up) (the-as basic s5-0))
      (set! (-> self spike-info s3-0 sounded) (the-as basic s4-0))
      (set! s5-0 (and (nonzero? arg0) (not s5-0)))
      (set! s4-0 (and (nonzero? arg0) (not s4-0)))
      )
    )
  (let ((gp-1 (new 'stack-no-clear 'vector)))
    (dotimes (s5-1 4)
      (vector<-cspace! gp-1 (-> self node-list data (-> self spike-info s5-1 joint)))
      (+! (-> gp-1 y) (-> self spike-info s5-1 y-offset))
      (send-event (handle->process (-> self spike-info s5-1 spike)) 'set-position gp-1)
      )
    )
  #f
  )

;; failed to figure out what this is:
(defstate sunk (tomb-stair-block)
  :virtual #t
  :enter (behavior ()
    (set! (-> self root trans y) (-> self initial-y))
    (ja :group! tomb-stair-block-sink-ja :num! max)
    (transform-post)
    )
  :trans (behavior ()
    (lift-pool 1)
    (drop-pool 0)
    (position-spikes 1200)
    )
  :code (behavior ()
    (suspend)
    (suspend)
    (transform-post)
    (sleep-code)
    )
  )

;; failed to figure out what this is:
(defstate sink (tomb-stair-block)
  :virtual #t
  :enter (behavior ()
    (set! (-> self camera-state) 0)
    (set-time! (-> self state-time))
    (task-node-close! (game-task-node tomb-poles-block))
    )
  :exit (behavior ()
    (remove-setting! 'entity-name)
    (remove-setting! 'interp-time)
    (remove-setting! 'string-startup-vector)
    )
  :trans (behavior ()
    (rider-trans)
    (position-spikes 1200)
    (cond
      ((>= (-> self camera-state) 3)
       )
      ((= (-> self camera-state) 2)
       (remove-setting! 'interp-time)
       (remove-setting! 'string-startup-vector)
       (set! (-> self camera-state) 3)
       )
      ((and (= (-> self camera-state) 1) (time-elapsed? (-> self state-time) (seconds 8)))
       (set-setting! 'interp-time 'abs 0.0 0)
       (set-setting! 'string-startup-vector 'abs (new 'static 'vector :x 1.0) 0)
       (remove-setting! 'entity-name)
       (set! (-> self camera-state) 2)
       (process-release? *target*)
       )
      )
    )
  :code (behavior ()
    (local-vars (v1-5 symbol) (v1-51 symbol))
    (until v1-5
      (ja :num! (loop!))
      (lift-pool 0)
      (drop-pool 1)
      (suspend)
      (set! v1-5 (or (not *target*) (process-grab? *target* #f)))
      )
    (set-setting! 'entity-name "camera-171" 0.0 0)
    (set! (-> self camera-state) 1)
    (ja-channel-push! 1 (seconds 2))
    (ja :group! tomb-stair-block-straight-ja :num! min)
    (set-time! (-> self state-time))
    (until (time-elapsed? (-> self state-time) (seconds 2))
      (lift-pool 0)
      (drop-pool 1)
      (suspend)
      )
    (while (< (-> self root trans y) (-> self initial-y))
      (let ((f0-4 (seek (-> self root trans y) (-> self initial-y) 204.8)))
        (set! (-> self root trans y) f0-4)
        (set! (-> self root trans y) f0-4)
        )
      (lift-pool 0)
      (drop-pool 1)
      (suspend)
      )
    (ja-no-eval :group! tomb-stair-block-sink-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (lift-pool 1)
      (drop-pool 0)
      (suspend)
      (ja :num! (seek!))
      )
    (until v1-51
      (lift-pool 1)
      (drop-pool 0)
      (suspend)
      (set! v1-51 (or (not *target*) (process-release? *target*)))
      )
    (go-virtual sunk)
    )
  :post rider-post
  )

;; failed to figure out what this is:
(defstate moving (tomb-stair-block)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('cue-chase)
       (set-action!
         *gui-control*
         (gui-action play)
         (-> self sink-sound)
         (gui-channel none)
         (gui-action none)
         (the-as string #f)
         (the-as (function gui-connection symbol) #f)
         (the-as process #f)
         )
       (set-falloff! *gui-control* (-> self sink-sound) #t -1 200 2)
       (go-virtual sink)
       )
      )
    )
  :enter (behavior ()
    (set! (-> self sink-sound)
          (add-process *gui-control* self (gui-channel jak) (gui-action queue) "tombpltb" -99.0 0)
          )
    (set! (-> self camera-state) 0)
    0
    )
  :exit (behavior ()
    (remove-setting! 'entity-name)
    (remove-setting! 'interp-time)
    (remove-setting! 'string-startup-vector)
    )
  :trans (behavior ()
    (rider-trans)
    (let ((f0-3 (seek (-> self root trans y) (+ -28672.0 (-> self initial-y)) 409.6)))
      (set! (-> self root trans y) f0-3)
      (set! (-> self root trans y) f0-3)
      )
    (position-spikes 0)
    (cond
      ((>= (-> self camera-state) 3)
       )
      ((= (-> self camera-state) 2)
       (remove-setting! 'interp-time)
       (remove-setting! 'string-startup-vector)
       (if (or (not *target*) (process-release? *target*))
           (set! (-> self camera-state) 3)
           )
       )
      ((and (= (-> self camera-state) 1) (time-elapsed? (-> self state-time) (seconds 4)))
       (set-setting! 'interp-time 'abs 0.0 0)
       (set-setting! 'string-startup-vector 'abs (new 'static 'vector :x 1.0) 0)
       (remove-setting! 'entity-name)
       (set! (-> self camera-state) 2)
       )
      )
    (when (and *target* (< (-> (target-pos 0) y) -294912.0))
      (set-action!
        *gui-control*
        (gui-action stop)
        (-> self sink-sound)
        (gui-channel none)
        (gui-action none)
        (the-as string #f)
        (the-as (function gui-connection symbol) #f)
        (the-as process #f)
        )
      (go-virtual idle)
      )
    (lift-pool 0)
    (drop-pool 1)
    )
  :code (behavior ()
    (local-vars (v1-1 symbol))
    (until v1-1
      (suspend)
      (set! v1-1 (or (not *target*) (process-grab? *target* #f)))
      )
    (set-setting! 'entity-name "camera-170" 0.0 0)
    (set-time! (-> self state-time))
    (set! (-> self camera-state) 1)
    (ja-channel-push! 1 (seconds 2))
    (until #f
      (ja-no-eval :group! tomb-stair-block-idle-ja :num! (seek! max 0.125) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 0.125))
        )
      )
    #f
    )
  :post rider-post
  )

;; failed to figure out what this is:
(defstate idle (tomb-stair-block)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('cue-chase)
       (set-action!
         *gui-control*
         (gui-action play)
         (-> self rise-sound)
         (gui-channel none)
         (gui-action none)
         (the-as string #f)
         (the-as (function gui-connection symbol) #f)
         (the-as process #f)
         )
       (set-falloff! *gui-control* (-> self rise-sound) #t -1 200 2)
       (go-virtual moving)
       )
      )
    )
  :enter (behavior ()
    (local-vars (sv-16 res-tag))
    (ja-channel-push! 1 (seconds 2))
    (ja :group! tomb-stair-block-straight-ja :num! min)
    (set! (-> self rise-sound)
          (add-process *gui-control* self (gui-channel jak) (gui-action queue) "tombplta" -99.0 0)
          )
    (set! sv-16 (new 'static 'res-tag))
    (let ((gp-1 (res-lump-data (-> self entity) 'actor-groups (pointer actor-group) :tag-ptr (& sv-16))))
      (when (and gp-1 (< (the-as uint 2) (-> sv-16 elt-count)) (-> gp-1 2))
        (dotimes (s5-0 (-> gp-1 2 length))
          (let ((a1-4 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-4 from) (process->ppointer self))
            (set! (-> a1-4 num-params) 0)
            (set! (-> a1-4 message) 'untrigger)
            (let ((t9-4 send-event-function)
                  (v1-15 (-> gp-1 2 data s5-0 actor))
                  )
              (t9-4
                (if v1-15
                    (-> v1-15 extra process)
                    )
                a1-4
                )
              )
            )
          )
        )
      )
    )
  :trans (behavior ()
    (let ((f0-3 (seek (-> self root trans y) (+ -104448.0 (-> self initial-y)) 409.6)))
      (set! (-> self root trans y) f0-3)
      (set! (-> self root trans y) f0-3)
      )
    (lift-pool 0)
    (drop-pool 1)
    (position-spikes 1500)
    )
  :code sleep-code
  :post transform-post
  )

;; failed to figure out what this is:
(defstate wait-for-pools (tomb-stair-block)
  :virtual #t
  :trans (behavior ()
    (local-vars (sv-16 res-tag))
    (let ((gp-0 #t))
      (set! sv-16 (new 'static 'res-tag))
      (let ((s5-0 (res-lump-data (-> self entity) 'actor-groups (pointer actor-group) :tag-ptr (& sv-16))))
        (when s5-0
          (dotimes (s4-0 (min 2 (the-as int (-> sv-16 elt-count))))
            (dotimes (s3-0 (-> s5-0 s4-0 length))
              (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
                (set! (-> a1-1 from) (process->ppointer self))
                (set! (-> a1-1 num-params) 1)
                (set! (-> a1-1 message) 'visible)
                (set! (-> a1-1 param 0) (the-as uint #t))
                (let ((t9-1 send-event-function)
                      (v1-9 (-> s5-0 s4-0 data s3-0 actor))
                      )
                  (if (not (t9-1
                             (if v1-9
                                 (-> v1-9 extra process)
                                 )
                             a1-1
                             )
                           )
                      (set! gp-0 #f)
                      )
                  )
                )
              )
            )
          )
        )
      (when gp-0
        (if (task-node-closed? (game-task-node tomb-poles-block))
            (go-virtual sunk)
            (go-virtual idle)
            )
        )
      )
    )
  :code sleep-code
  )

;; definition for method 11 of type tomb-stair-block
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this tomb-stair-block) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 8) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 9))
      (set! (-> s3-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable))
      (set-vector! (-> s3-0 local-sphere) 0.0 131072.0 0.0 237568.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid rideable))
      (set! (-> v1-10 transform-index) 3)
      (set-vector! (-> v1-10 local-sphere) 0.0 81920.0 0.0 204800.0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-12 prim-core action) (collide-action solid rideable))
      (set! (-> v1-12 transform-index) 4)
      (set-vector! (-> v1-12 local-sphere) 0.0 -63488.0 0.0 102400.0)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-14 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-14 prim-core action) (collide-action solid rideable))
      (set! (-> v1-14 transform-index) 5)
      (set-vector! (-> v1-14 local-sphere) 0.0 -16384.0 0.0 77824.0)
      )
    (let ((v1-16 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 3) (the-as uint 0))))
      (set! (-> v1-16 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-16 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-16 prim-core action) (collide-action solid rideable))
      (set! (-> v1-16 transform-index) 6)
      (set-vector! (-> v1-16 local-sphere) 0.0 -75776.0 0.0 114688.0)
      )
    (let ((v1-18 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 4) (the-as uint 0))))
      (set! (-> v1-18 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-18 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-18 prim-core action) (collide-action solid rideable))
      (set! (-> v1-18 transform-index) 7)
      (set-vector! (-> v1-18 local-sphere) 0.0 -16384.0 0.0 77824.0)
      )
    (let ((v1-20 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 5) (the-as uint 0))))
      (set! (-> v1-20 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-20 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-20 prim-core action) (collide-action solid rideable))
      (set! (-> v1-20 transform-index) 8)
      (set-vector! (-> v1-20 local-sphere) 0.0 -75776.0 0.0 114688.0)
      )
    (let ((v1-22 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 6) (the-as uint 0))))
      (set! (-> v1-22 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-22 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-22 prim-core action) (collide-action solid rideable))
      (set! (-> v1-22 transform-index) 9)
      (set-vector! (-> v1-22 local-sphere) 0.0 -16384.0 0.0 77824.0)
      )
    (let ((v1-24 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 7) (the-as uint 0))))
      (set! (-> v1-24 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-24 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-24 prim-core action) (collide-action solid rideable))
      (set! (-> v1-24 transform-index) 10)
      (set-vector! (-> v1-24 local-sphere) 0.0 -92160.0 0.0 131072.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-27 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-27 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-27 prim-core collide-with))
      )
    (set! (-> this root) (the-as collide-shape-moving s4-0))
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tomb-stair-block" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this draw light-index) (the-as uint 1))
  (logclear! (-> this mask) (process-mask actor-pause))
  (set! (-> this initial-y) (-> this root trans y))
  (ja-post)
  (set! (-> this spike-info 0 joint) 4)
  (set! (-> this spike-info 1 joint) 6)
  (set! (-> this spike-info 2 joint) 8)
  (set! (-> this spike-info 3 joint) 10)
  (let ((s5-2 (new 'stack-no-clear 'vector)))
    (dotimes (s4-2 4)
      (set! (-> this spike-info s4-2 y-offset) 0.0)
      (vector<-cspace! s5-2 (-> this node-list data (-> this spike-info s4-2 joint)))
      (set! (-> this spike-info s4-2 spike)
            (ppointer->handle (process-spawn tomb-stair-block-spikes s5-2 :to this))
            )
      (set! (-> this spike-info s4-2 up) #f)
      (set! (-> this spike-info s4-2 sounded) #f)
      )
    )
  (set! (-> this root trans y) (+ -104448.0 (-> this initial-y)))
  (let ((s5-3 (-> this skel root-channel 0)))
    (joint-control-channel-group-eval!
      s5-3
      (the-as art-joint-anim (-> this draw art-group data 3))
      num-func-identity
      )
    (set! (-> s5-3 frame-num) 0.0)
    )
  (set! (-> this rise-sound) (new-sound-id))
  (set! (-> this sink-sound) (new-sound-id))
  (go (method-of-object this wait-for-pools))
  (none)
  )

;; failed to figure out what this is:
(defskelgroup skel-tomb-bounce-web tomb-bounce-web tomb-bounce-web-lod0-jg tomb-bounce-web-idle-ja
              ((tomb-bounce-web-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

;; definition of type tomb-bounce-web
(deftype tomb-bounce-web (bouncer)
  ()
  )

;; definition for method 3 of type tomb-bounce-web
(defmethod inspect ((this tomb-bounce-web))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type bouncer inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 23 of type tomb-bounce-web
;; WARN: Return type mismatch int vs none.
(defmethod init-skeleton! ((this tomb-bounce-web))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tomb-bounce-web" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this mods) *indax-bounce-mods*)
  0
  (none)
  )

;; definition for method 24 of type tomb-bounce-web
;; WARN: Return type mismatch int vs none.
(defmethod bouncer-method-24 ((this tomb-bounce-web))
  "TODO - collision stuff"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 4) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 5))
      (set! (-> s4-0 prim-core collide-as) (collide-spec crate))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 3072.0 0.0 11059.2)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 2) (the-as uint 1))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 0)
      (set-vector! (-> v1-8 local-sphere) 0.0 3072.0 0.0 11059.2)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 3))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 3)
      (set-vector! (-> v1-10 local-sphere) 0.0 3072.0 0.0 11059.2)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 3))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-12 prim-core action) (collide-action solid))
      (set! (-> v1-12 transform-index) 3)
      (set-vector! (-> v1-12 local-sphere) 0.0 3072.0 0.0 11059.2)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 4))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-14 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-14 prim-core action) (collide-action))
      (set! (-> v1-14 transform-index) 3)
      (set-vector! (-> v1-14 local-sphere) 0.0 3072.0 0.0 8192.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-17 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-17 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-17 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; definition of type tomb-plat-pillar
(deftype tomb-plat-pillar (plat)
  ()
  )

;; definition for method 3 of type tomb-plat-pillar
(defmethod inspect ((this tomb-plat-pillar))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type plat inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-tomb-plat-pillar tomb-plat-pillar tomb-plat-pillar-lod0-jg tomb-plat-pillar-idle-ja
              ((tomb-plat-pillar-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -7 0 8)
              )

;; definition for method 30 of type tomb-plat-pillar
(defmethod get-art-group ((this tomb-plat-pillar))
  "@returns The associated [[art-group]]"
  (art-group-get-by-name *level* "skel-tomb-plat-pillar" (the-as (pointer uint32) #f))
  )

;; definition for method 32 of type tomb-plat-pillar
;; WARN: Return type mismatch int vs none.
(defmethod base-plat-method-32 ((this tomb-plat-pillar))
  0
  (none)
  )

;; definition for method 31 of type tomb-plat-pillar
;; WARN: Return type mismatch collide-shape vs none.
(defmethod init-plat-collision! ((this tomb-plat-pillar))
  "TODO - collision stuff for setting up the platform"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 36864.0 0.0 32768.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) (the-as collide-shape-moving s5-0))
    )
  (none)
  )

;; definition of type tomb-elevator
(deftype tomb-elevator (elevator)
  ((last-pos  vector  :inline)
   (speed     float)
   )
  )

;; definition for method 3 of type tomb-elevator
(defmethod inspect ((this tomb-elevator))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type elevator inspect)))
    (t9-0 this)
    )
  (format #t "~2Tlast-pos: #<vector @ #x~X>~%" (-> this last-pos))
  (format #t "~2Tspeed: ~f~%" (-> this speed))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-tomb-elevator tomb-elevator tomb-elevator-lod0-jg tomb-elevator-idle-ja
              ((tomb-elevator-lod0-mg (meters 999999)))
              :bounds (static-spherem 4 0 4 7)
              )

;; failed to figure out what this is:
(defstate running (tomb-elevator)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type elevator running) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self speed) 0.0)
    )
  :code (behavior ()
    (logior! (-> self elevator-status) (elevator-status waiting-to-ascend))
    (ja-no-eval :group! tomb-elevator-run-ja :num! (loop! 0.0))
    (until #f
      (when (= (-> self path-pos) 1.0)
        (logclear! (-> self elevator-status) (elevator-status waiting-to-ascend))
        (sound-play "t-elevator-hit")
        )
      (suspend)
      (ja :num! (loop! (* 0.00007771238 (-> self speed))))
      )
    #f
    )
  :post (behavior ()
    (set! (-> self last-pos quad) (-> self basetrans quad))
    (let ((t9-0 (-> (method-of-type elevator running) post)))
      (if t9-0
          ((the-as (function none) t9-0))
          )
      )
    (set! (-> self speed) (* (- (-> self last-pos y) (-> self basetrans y)) (-> self clock frames-per-second)))
    )
  )

;; definition for method 41 of type tomb-elevator
;; WARN: Return type mismatch int vs none.
(defmethod init-defaults! ((this tomb-elevator))
  "Initializes default settings related to the [[elevator]]:
- `elevator-xz-threshold`
- `elevator-y-threshold`
- `elevator-start-pos`
- `elevator-move-rate`
- `elevator-flags`"
  (let ((t9-0 (method-of-type elevator init-defaults!)))
    (t9-0 this)
    )
  (set! (-> this params flags) (elevator-flags elevator-flags-2))
  (set! (-> this draw light-index) (the-as uint 1))
  (none)
  )

;; definition for method 30 of type tomb-elevator
(defmethod get-art-group ((this tomb-elevator))
  "@returns The associated [[art-group]]"
  (art-group-get-by-name *level* "skel-tomb-elevator" (the-as (pointer uint32) #f))
  )

;; definition for method 31 of type tomb-elevator
;; WARN: Return type mismatch collide-shape vs none.
(defmethod init-plat-collision! ((this tomb-elevator))
  "TODO - collision stuff for setting up the platform"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 16384.0 0.0 16384.0 28672.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) (the-as collide-shape-moving s5-0))
    )
  (none)
  )

;; definition for method 42 of type tomb-elevator
;; WARN: Return type mismatch int vs none.
(defmethod set-ambient-sound! ((this tomb-elevator))
  "Sets the elevator's [[ambient-sound]] up"
  (set! (-> this sound)
        (new 'process 'ambient-sound (static-sound-spec "tomb-elevator" :fo-max 70) (-> this root trans))
        )
  0
  (none)
  )

;; failed to figure out what this is:
(defskelgroup skel-tomb-boss-door tomb-boss-door tomb-boss-door-lod0-jg tomb-boss-door-idle-ja
              ((tomb-boss-door-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 21 0 60)
              :origin-joint-index 3
              )

;; definition of type tomb-boss-door
(deftype tomb-boss-door (com-airlock)
  ()
  )

;; definition for method 3 of type tomb-boss-door
(defmethod inspect ((this tomb-boss-door))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type com-airlock inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 11 of type tomb-boss-door
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this tomb-boss-door) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 86016.0 0.0 122880.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 5)
      (set-vector! (-> v1-8 local-sphere) 0.0 86016.0 0.0 122880.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 4)
      (set-vector! (-> v1-10 local-sphere) 0.0 86016.0 0.0 122880.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tomb-boss-door" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-airlock! this)
  (set! (-> this door-radius) 61440.0)
  (go (method-of-object this close) #t)
  (none)
  )

;; definition of type water-anim-tomb
(deftype water-anim-tomb (water-anim)
  ()
  )

;; definition for method 3 of type water-anim-tomb
(defmethod inspect ((this water-anim-tomb))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type water-anim inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for symbol ripple-for-water-anim-tomb, type ripple-wave-set
(define ripple-for-water-anim-tomb (new 'static 'ripple-wave-set
                                     :count 3
                                     :converted #f
                                     :normal-scale 1.0
                                     :wave (new 'static 'inline-array ripple-wave 4
                                       (new 'static 'ripple-wave :scale 40.0 :xdiv 1 :speed 1.5)
                                       (new 'static 'ripple-wave :scale 40.0 :xdiv -1 :zdiv 1 :speed 1.5)
                                       (new 'static 'ripple-wave :scale 20.0 :xdiv 5 :zdiv 3 :speed 0.75)
                                       (new 'static 'ripple-wave)
                                       )
                                     )
        )

;; definition for method 24 of type water-anim-tomb
;; WARN: Return type mismatch ripple-wave-set vs none.
(defmethod init-water! ((this water-anim-tomb))
  "Initialize a [[water-anim]]'s default settings, this may include applying a [[riple-control]]"
  (let ((t9-0 (method-of-type water-anim init-water!)))
    (t9-0 this)
    )
  (let ((v1-2 (new 'process 'ripple-control)))
    (set! (-> this draw ripple) v1-2)
    (set-vector! (-> this draw color-mult) 0.01 0.45 0.5 0.75)
    (set! (-> v1-2 global-scale) 3072.0)
    (set! (-> v1-2 close-fade-dist) 163840.0)
    (set! (-> v1-2 far-fade-dist) 245760.0)
    (set! (-> v1-2 waveform) ripple-for-water-anim-tomb)
    )
  (none)
  )

;; failed to figure out what this is:
(defskelgroup skel-tomb-wing-door tomb-wing-door tomb-wing-door-lod0-jg tomb-wing-door-idle-ja
              ((tomb-wing-door-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -10 0 20)
              )

;; definition of type tomb-wing-door
(deftype tomb-wing-door (com-airlock)
  ()
  )

;; definition for method 3 of type tomb-wing-door
(defmethod inspect ((this tomb-wing-door))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type com-airlock inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 11 of type tomb-wing-door
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this tomb-wing-door) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 3) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 4))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 -40960.0 0.0 81920.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 5)
      (set-vector! (-> v1-8 local-sphere) 0.0 40960.0 -16384.0 61440.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 4)
      (set-vector! (-> v1-10 local-sphere) 0.0 40960.0 16384.0 61440.0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-12 prim-core action) (collide-action solid))
      (set! (-> v1-12 transform-index) 3)
      (set-vector! (-> v1-12 local-sphere) 0.0 -12288.0 0.0 61440.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-15 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-15 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-15 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tomb-wing-door" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-airlock! this)
  (set! (-> this sound-open-loop) (static-sound-spec "wing-door-open"))
  (set! (-> this sound-open-stop) (static-sound-spec "wing-open-hit"))
  (set! (-> this sound-close-loop) (static-sound-spec "wing-door-close"))
  (set! (-> this sound-close-stop) (static-sound-spec "wing-close-hit"))
  (go (method-of-object this close) #t)
  (none)
  )

;; failed to figure out what this is:
(defskelgroup skel-tomb-boulder-door tomb-boulder-door tomb-boulder-door-lod0-jg tomb-boulder-door-idle-ja
              ((tomb-boulder-door-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 7 0 10)
              :origin-joint-index 3
              )

;; definition of type tomb-boulder-door
(deftype tomb-boulder-door (process-drawable)
  ((root  collide-shape-moving :override)
   )
  (:state-methods
    open
    close
    )
  )

;; definition for method 3 of type tomb-boulder-door
(defmethod inspect ((this tomb-boulder-door))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defstate close (tomb-boulder-door)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('reset)
       (if (task-node-closed? (game-task-node tomb-poles-boulder))
           (go-virtual close)
           (go-virtual open)
           )
       )
      )
    )
  :code (behavior ()
    (ja :num-func num-func-identity :frame-num 0.0)
    (transform-post)
    (suspend)
    (transform-post)
    (logior! (-> self mask) (process-mask sleep))
    (suspend)
    0
    )
  )

;; failed to figure out what this is:
(defstate open (tomb-boulder-door)
  :virtual #t
  :event (-> (method-of-type tomb-boulder-door close) event)
  :code (behavior ()
    (ja :num-func num-func-identity :frame-num (ja-aframe 5.0 0))
    (transform-post)
    (logior! (-> self mask) (process-mask sleep))
    (suspend)
    0
    )
  )

;; definition for method 11 of type tomb-boulder-door
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this tomb-boulder-door) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) 0.0 24576.0 0.0 36864.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> this root) (the-as collide-shape-moving s4-0))
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tomb-boulder-door" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (if (task-node-closed? (game-task-node tomb-poles-boulder))
      (go (method-of-object this close))
      (go (method-of-object this open))
      )
  (none)
  )

;; definition of type tomb-plat-return
(deftype tomb-plat-return (base-plat)
  ((intro-path  path-control)
   (ride-timer  time-frame)
   (flags       tomb-plat-flags)
   (path-pos    float)
   (dest-pos    float)
   (path-speed  float)
   (sound-id    sound-id)
   )
  (:state-methods
    hidden
    run-intro
    waiting
    running
    waiting-for-no-player
    )
  )

;; definition for method 3 of type tomb-plat-return
(defmethod inspect ((this tomb-plat-return))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type base-plat inspect)))
    (t9-0 this)
    )
  (format #t "~2Tintro-path: ~A~%" (-> this intro-path))
  (format #t "~2Tride-timer: ~D~%" (-> this ride-timer))
  (format #t "~2Tflags: ~D~%" (-> this flags))
  (format #t "~2Tpath-pos: ~f~%" (-> this path-pos))
  (format #t "~2Tdest-pos: ~f~%" (-> this dest-pos))
  (format #t "~2Tpath-speed: ~f~%" (-> this path-speed))
  (format #t "~2Tsound-id: ~D~%" (-> this sound-id))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-tomb-plat-return tomb-plat-return tomb-plat-return-lod0-jg tomb-plat-return-idle-ja
              ((tomb-plat-return-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4.8)
              )

;; failed to figure out what this is:
(defstate hidden (tomb-plat-return)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger 'cue-chase)
       (go-virtual run-intro)
       )
      )
    )
  :enter (behavior ()
    (logior! (-> self draw status) (draw-control-status no-draw))
    )
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate run-intro (tomb-plat-return)
  :virtual #t
  :event plat-event
  :enter (behavior ()
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (logclear! (-> self draw status) (draw-control-status no-draw))
    (ja-channel-set! 1)
    (ja-no-eval :group! tomb-plat-return-idle-ja :num! zero)
    (set! (-> self path-pos) 0.0)
    (set-vector! (-> self root scale) 0.0 0.0 0.0 0.0)
    )
  :exit (behavior ()
    (sound-stop (-> self sound-id))
    )
  :trans (behavior ()
    (when (= (-> self path-pos) 1.0)
      (set! (-> self path-pos) 0.0)
      (go-virtual waiting)
      )
    (plat-trans)
    )
  :code sleep-code
  :post (behavior ()
    (sound-play "tomb-plat-ret" :id (-> self sound-id) :position (-> self root trans))
    (seek! (-> self path-pos) 1.0 (* 2.0 (seconds-per-frame) (-> self path-speed)))
    (let ((f30-0 (-> self path-pos)))
      (get-point-at-percent-along-path!
        (-> self intro-path)
        (-> self basetrans)
        (ease-value-in-out f30-0 0.1)
        'interp
        )
      (set-vector! (-> self root scale) f30-0 f30-0 f30-0 f30-0)
      )
    (plat-post)
    )
  )

;; failed to figure out what this is:
(defstate waiting (tomb-plat-return)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('ridden)
       (let ((v0-0 (the-as object (logior (-> self flags) (tomb-plat-flags topflags-0)))))
         (set! (-> self flags) (the-as tomb-plat-flags v0-0))
         v0-0
         )
       )
      (else
        (plat-event proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set-time! (-> self ride-timer))
    (get-point-at-percent-along-path! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
    )
  :trans (behavior ()
    (logclear! (-> self flags) (tomb-plat-flags topflags-0))
    (plat-trans)
    (if (not (logtest? (-> self flags) (tomb-plat-flags topflags-0)))
        (set-time! (-> self ride-timer))
        )
    (when (time-elapsed? (-> self ride-timer) (seconds 0.5))
      (if (= (-> self path-pos) 0.0)
          (set! (-> self dest-pos) 1.0)
          (set! (-> self dest-pos) 0.0)
          )
      (go-virtual running)
      )
    )
  :code sleep-code
  :post plat-post
  )

;; failed to figure out what this is:
(defstate running (tomb-plat-return)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('ridden)
       (let ((v0-0 (the-as object (logior (-> self flags) (tomb-plat-flags topflags-0)))))
         (set! (-> self flags) (the-as tomb-plat-flags v0-0))
         v0-0
         )
       )
      (else
        (plat-event proc argc message block)
        )
      )
    )
  :exit (behavior ()
    (sound-stop (-> self sound-id))
    )
  :trans (behavior ()
    (if (= (-> self path-pos) (-> self dest-pos))
        (go-virtual waiting-for-no-player)
        )
    (plat-trans)
    )
  :code sleep-code
  :post (behavior ()
    (sound-play "tomb-plat-ret" :id (-> self sound-id) :position (-> self root trans))
    (seek! (-> self path-pos) (-> self dest-pos) (* (-> self path-speed) (seconds-per-frame)))
    (get-point-at-percent-along-path!
      (-> self path)
      (-> self basetrans)
      (ease-value-in-out (-> self path-pos) 0.1)
      'interp
      )
    (plat-post)
    )
  )

;; failed to figure out what this is:
(defstate waiting-for-no-player (tomb-plat-return)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('ridden)
       (let ((v0-0 (the-as object (current-time))))
         (set! (-> self ride-timer) (the-as time-frame v0-0))
         v0-0
         )
       )
      (else
        (plat-event proc argc message block)
        )
      )
    )
  :trans (behavior ()
    (plat-trans)
    (when (time-elapsed? (-> self ride-timer) (seconds 1))
      (cond
        ((= (-> self path-pos) 1.0)
         (set! (-> self dest-pos) 0.0)
         (go-virtual running)
         )
        (else
          (go-virtual waiting)
          )
        )
      )
    )
  :code sleep-code
  :post plat-post
  )

;; definition for method 7 of type tomb-plat-return
;; WARN: Return type mismatch process-drawable vs tomb-plat-return.
(defmethod relocate ((this tomb-plat-return) (arg0 int))
  (if (nonzero? (-> this intro-path))
      (&+! (-> this intro-path) arg0)
      )
  (the-as tomb-plat-return ((method-of-type process-drawable relocate) this arg0))
  )

;; definition for method 10 of type tomb-plat-return
(defmethod deactivate ((this tomb-plat-return))
  (sound-stop (-> this sound-id))
  (call-parent-method this)
  (none)
  )

;; definition for method 31 of type tomb-plat-return
;; WARN: Return type mismatch int vs none.
(defmethod init-plat-collision! ((this tomb-plat-return))
  "TODO - collision stuff for setting up the platform"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 19660.8)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-11 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-11 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-11 prim-core collide-with))
      )
    (set! (-> this root) (the-as collide-shape-moving s5-0))
    )
  0
  (none)
  )

;; definition for method 11 of type tomb-plat-return
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this tomb-plat-return) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (init-plat-collision! this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tomb-plat-return" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (stop-bouncing! this)
  (set! (-> this flags) (tomb-plat-flags))
  (set! (-> this path-pos) 0.0)
  (let ((s4-1 (new 'process 'curve-control this 'path -1000000000.0)))
    (if (logtest? (-> s4-1 flags) (path-control-flag not-found))
        (go process-drawable-art-error "error in path")
        )
    (logior! (-> s4-1 flags) (path-control-flag display draw-line draw-point draw-text))
    (set! (-> this path) s4-1)
    )
  (let ((s4-2 (new 'process 'curve-control this 'intro -1000000000.0)))
    (if (logtest? (-> s4-2 flags) (path-control-flag not-found))
        (go process-drawable-art-error "error in intro-path")
        )
    (logior! (-> s4-2 flags) (path-control-flag display draw-line draw-point draw-text))
    (set! (-> this intro-path) s4-2)
    )
  (let ((f30-0 (total-distance (-> this path))))
    (set! (-> this path-speed) (/ (res-lump-float arg0 'speed :default 40960.0) f30-0))
    (set! (-> this root pause-adjust-distance) (+ 204800.0 f30-0))
    )
  (set! (-> this sound-id) (new-sound-id))
  (init-plat! this)
  (if (or (task-closed? (the-as string ((method-of-type res-lump get-property-struct)
                                        (-> this entity)
                                        'task-name
                                        'interp
                                        -1000000000.0
                                        "tomb-boss-resolution"
                                        (the-as (pointer res-tag) #f)
                                        *res-static-buf*
                                        )
                                )
                        )
          (and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete)))
          )
      (go (method-of-object this run-intro))
      (go (method-of-object this hidden))
      )
  (none)
  )

;; failed to figure out what this is:
(defpart 3159
  :init-specs ((:texture (new 'static 'texture-id :index #x83 :page #xc))
    (:birth-func 'birth-func-set-quat)
    (:num 1.0)
    (:scale-x (meters 10) (meters 1))
    (:scale-y (meters 40))
    (:r 64.0)
    (:g 64.0)
    (:b 128.0 64.0)
    (:a 128.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 sp-cpuinfo-flag-14 left-multiply-quat))
    )
  )

;; failed to figure out what this is:
(defpart 3160
  :init-specs ((:texture (new 'static 'texture-id :index #xca :page #xc))
    (:num 1.0)
    (:y (meters -0.25))
    (:z (meters 1.25))
    (:scale-x (meters 5) (meters 0.5))
    (:rot-x (degrees 2.25))
    (:scale-y :copy scale-x)
    (:r 96.0)
    (:g 96.0)
    (:b 196.0 64.0)
    (:a 128.0)
    (:rotvel-z (degrees 0.3))
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-14 glow))
    (:userdata 1024.0)
    )
  )

;; failed to figure out what this is:
(defpart 3161
  :init-specs ((:texture (new 'static 'texture-id :index #xbc :page #xc))
    (:num 1.0)
    (:y (meters -0.15))
    (:z (meters -1.25))
    (:scale-x (meters 5) (meters 0.5))
    (:rot-x (degrees 2.25))
    (:scale-y :copy scale-x)
    (:r 96.0)
    (:g 96.0)
    (:b 196.0 64.0)
    (:a 128.0)
    (:rotvel-z (degrees 0.3))
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-14 glow))
    (:userdata 1024.0)
    )
  )

;; definition for function tomb-sphinx-draw-beam
;; INFO: Used lq/sq
(defun tomb-sphinx-draw-beam ((arg0 vector) (arg1 vector))
  (let ((a2-1 (vector-! (new 'stack-no-clear 'vector) arg1 arg0)))
    (set! (-> *part-id-table* 3159 init-specs 4 initial-valuef) (vector-length a2-1))
    (draw-beam (-> *part-id-table* 3159) arg0 a2-1 #f #t)
    )
  (launch-particles (-> *part-id-table* 3160) arg0)
  (launch-particles (-> *part-id-table* 3161) arg1)
  (none)
  )

;; definition of type tomb-sphinx
(deftype tomb-sphinx (process-drawable)
  ((root          collide-shape-moving :override)
   (target-actor  entity-actor)
   (sound-id      sound-id)
   (move-dir      float                 :offset 216)
   )
  (:state-methods
    idle
    active
    doors-open
    )
  )

;; definition for method 3 of type tomb-sphinx
(defmethod inspect ((this tomb-sphinx))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Ttarget-actor: ~A~%" (-> this target-actor))
  (format #t "~2Tsound-id: ~D~%" (-> this sound-id))
  (format #t "~2Tstate-time: ~D~%" (-> this state-time))
  (format #t "~2Tmove-dir: ~f~%" (-> this move-dir))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defstate idle (tomb-sphinx)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger 'cue-chase)
       (go-virtual active)
       )
      )
    )
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate active (tomb-sphinx)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('door-left)
       (set! (-> self move-dir) -1.0)
       (go-virtual doors-open)
       )
      (('door-right)
       (set! (-> self move-dir) 1.0)
       (go-virtual doors-open)
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :code (behavior ()
    (local-vars (sv-96 vector))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (logclear! (-> self mask) (process-mask actor-pause))
      (sound-play "tomb-lasr-start")
      (let ((gp-2 (vector+!
                    (new 'stack-no-clear 'vector)
                    (-> self target-actor extra trans)
                    (new 'static 'vector :y 101580.8 :w 1.0)
                    )
                  )
            (s5-1 (new 'stack-no-clear 'vector))
            )
        (set! (-> s5-1 quad) (-> self root trans quad))
        (let ((s4-0 (new 'stack-no-clear 'vector)))
          (until #f
            (let ((s3-0 tomb-sphinx-draw-beam)
                  (s2-0 s5-1)
                  )
              (set! sv-96 s4-0)
              (let ((s1-0 s5-1))
                (let ((s0-1 (vector-! (new 'stack-no-clear 'vector) gp-2 s5-1)))
                  (let ((v1-13 (lerp-scale 0.0 1.0 (the float (- (current-time) (-> self state-time))) 0.0 300.0)))
                    (.mov vf7 v1-13)
                    )
                  (.lvf vf5 (&-> s0-1 quad))
                  )
                (.lvf vf4 (&-> s1-0 quad))
                )
              (.add.x.vf vf6 vf0 vf0 :mask #b1000)
              (.mul.x.vf acc vf5 vf7 :mask #b111)
              (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
              (.svf (&-> sv-96 quad) vf6)
              (s3-0 s2-0 sv-96)
              )
            (let ((s3-1 (new 'stack-no-clear 'vector)))
              (vector-segment-distance-point! (ear-trans 0) s5-1 s4-0 s3-1)
              (sound-play "tomb-lasr-loop" :id (-> self sound-id) :position s3-1)
              )
            (suspend)
            )
          )
        )
      #f
      )
    )
  )

;; failed to figure out what this is:
(defstate doors-open (tomb-sphinx)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :code (behavior ()
    (local-vars (sv-96 vector) (sv-112 vector))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (logclear! (-> self mask) (process-mask actor-pause))
      (let ((gp-1 (vector+!
                    (new 'stack-no-clear 'vector)
                    (-> self target-actor extra trans)
                    (new 'static 'vector :y 101580.8 :w 1.0)
                    )
                  )
            (s5-0 (new 'stack-no-clear 'vector))
            )
        (set! (-> s5-0 quad) (-> self root trans quad))
        (let ((s4-0 (new 'stack-no-clear 'vector))
              (s3-0 (new 'stack-no-clear 'vector))
              )
          (let ((a1-0 s4-0))
            (let ((v1-8 gp-1))
              (let ((a0-2 (new 'static 'vector :x 4096.0 :w 1.0)))
                (let ((a2-1 (* 14.0 (-> self move-dir))))
                  (.mov vf7 a2-1)
                  )
                (.lvf vf5 (&-> a0-2 quad))
                )
              (.lvf vf4 (&-> v1-8 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a1-0 quad) vf6)
            )
          (until #f
            (let ((s2-0 tomb-sphinx-draw-beam)
                  (s1-0 s5-0)
                  )
              (set! sv-112 s3-0)
              (let ((s0-0 gp-1))
                (set! sv-96 (new 'stack-no-clear 'vector))
                (let ((v1-10 gp-1)
                      (a0-3 s4-0)
                      )
                  (.lvf vf4 (&-> v1-10 quad))
                  (.lvf vf5 (&-> a0-3 quad))
                  )
                (.mov.vf vf6 vf0 :mask #b1000)
                (.sub.vf vf6 vf4 vf5 :mask #b111)
                (.svf (&-> sv-96 quad) vf6)
                (let ((v1-15 (lerp-scale 0.0 1.0 (the float (- (current-time) (-> self state-time))) 0.0 930.0)))
                  (.mov vf7 v1-15)
                  )
                (.lvf vf5 (&-> sv-96 quad))
                (.lvf vf4 (&-> s0-0 quad))
                )
              (.add.x.vf vf6 vf0 vf0 :mask #b1000)
              (.mul.x.vf acc vf5 vf7 :mask #b111)
              (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
              (.svf (&-> sv-112 quad) vf6)
              (s2-0 s1-0 sv-112)
              )
            (suspend)
            )
          )
        )
      #f
      )
    )
  )

;; definition for method 7 of type tomb-sphinx
;; WARN: Return type mismatch process-drawable vs tomb-sphinx.
(defmethod relocate ((this tomb-sphinx) (arg0 int))
  (the-as tomb-sphinx ((method-of-type process-drawable relocate) this arg0))
  )

;; definition for method 10 of type tomb-sphinx
(defmethod deactivate ((this tomb-sphinx))
  (sound-stop (-> this sound-id))
  (call-parent-method this)
  (none)
  )

;; definition for method 11 of type tomb-sphinx
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this tomb-sphinx) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> this root) (the-as collide-shape-moving (new 'process 'trsqv)))
  (process-drawable-from-entity! this arg0)
  (set! (-> this target-actor) (entity-actor-lookup arg0 'alt-actor 0))
  (set! (-> this sound-id) (new-sound-id))
  (set! (-> this move-dir) 0.0)
  (if (and (task-complete? *game-info* (-> this entity task))
           (not (task-node-closed? (game-task-node tomb-boss-door)))
           )
      (go (method-of-object this active))
      (go (method-of-object this idle))
      )
  (none)
  )
