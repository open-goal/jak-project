;;-*-Lisp-*-
(in-package goal)

;; definition for symbol *dice-back-way-num*, type int
(define *dice-back-way-num* 0)

;; definition for symbol *dice-back-way*, type (array vector)
(define *dice-back-way* (new 'static 'boxed-array :type vector
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          )
        )

;; failed to figure out what this is:
(defskelgroup skel-mtn-dice-button mtn-dice-button mtn-dice-button-lod0-jg mtn-dice-button-idle-ja
              ((mtn-dice-button-lod0-mg (meters 20)) (mtn-dice-button-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 1)
              )

;; definition of type mtn-dice-button
(deftype mtn-dice-button (basebutton)
  ()
  )

;; definition for method 3 of type mtn-dice-button
(defmethod inspect ((this mtn-dice-button))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type basebutton inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 33 of type mtn-dice-button
;; WARN: Return type mismatch int vs none.
(defmethod basebutton-method-33 ((this mtn-dice-button))
  "TODO - joint stuff"
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-dice-button" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (ja-channel-set! 1)
  (cond
    ((logtest? (-> this button-status) (button-status pressed))
     (let ((s5-1 (-> this skel root-channel 0)))
       (joint-control-channel-group-eval!
         s5-1
         (the-as art-joint-anim (-> this draw art-group data 3))
         num-func-identity
         )
       (set! (-> s5-1 frame-num)
             (the float (+ (-> (the-as art-joint-anim (-> this draw art-group data 3)) frames num-frames) -1))
             )
       )
     )
    (else
      (let ((s5-2 (-> this skel root-channel 0)))
        (joint-control-channel-group-eval!
          s5-2
          (the-as art-joint-anim (-> this draw art-group data 3))
          num-func-identity
          )
        (set! (-> s5-2 frame-num) 0.0)
        )
      )
    )
  (transform-post)
  (none)
  )

;; definition for method 34 of type mtn-dice-button
;; WARN: Return type mismatch int vs none.
(defmethod basebutton-method-34 ((this mtn-dice-button))
  "TODO - collision stuff"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; definition for method 35 of type mtn-dice-button
;; WARN: Return type mismatch int vs none.
(defmethod prepare-trigger-event! ((this mtn-dice-button))
  "Sets `event-going-down` to `'trigger`"
  (logior! (-> this button-status) (button-status button-status-4))
  (logior! (-> this button-status) (button-status pressed))
  (set! (-> this event-going-down) 'trigger)
  0
  (none)
  )

;; failed to figure out what this is:
(defstate down-idle (mtn-dice-button)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type basebutton down-idle) enter)))
      (if t9-0
          (t9-0)
          )
      )
    )
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type basebutton down-idle) trans)))
      (if t9-0
          (t9-0)
          )
      )
    (if (and (not (task-node-closed? (game-task-node mountain-shard-dice))) (< 1 *dice-back-way-num*))
        (go-virtual going-up)
        )
    )
  )

;; failed to figure out what this is:
(defstate going-down (mtn-dice-button)
  :virtual #t
  :enter (behavior ()
    (sound-play "dice-button")
    (press! self #t)
    )
  )

;; definition for symbol *dice-position-array*, type (array vector)
(define *dice-position-array* (new 'static 'boxed-array :type vector
                                (new 'static 'vector :z 8192.0 :w 1.0)
                                (new 'static 'vector :z -8192.0 :w 1.0)
                                (new 'static 'vector :x 8192.0 :w 1.0)
                                (new 'static 'vector :x -8192.0 :w 1.0)
                                (new 'static 'vector :y -8192.0 :w 1.0)
                                (new 'static 'vector :y 8192.0 :w 1.0)
                                )
        )

;; definition for symbol *dice-angle-array*, type (array vector)
(define *dice-angle-array* (new 'static 'boxed-array :type vector
                             (new 'static 'vector :y 16384.0)
                             (new 'static 'vector :y -16384.0)
                             (new 'static 'vector :z 32768.0)
                             (new 'static 'vector)
                             (new 'static 'vector :z 16384.0)
                             (new 'static 'vector :z -16384.0)
                             )
        )

;; definition for symbol *dice-offset-x*, type int
(define *dice-offset-x* -663)

;; definition for symbol *dice-offset-z*, type int
(define *dice-offset-z* -30)

;; definition for symbol *dice-world-array*, type (array uint16)
(define *dice-world-array* (new 'static 'boxed-array :type uint16
                             #xffff
                             #xffc7
                             #x8007
                             #x7
                             #x3
                             #x3
                             #x7
                             #x8007
                             #xc007
                             #xe003
                             #xe003
                             #xe003
                             #xe003
                             #xe003
                             #xc003
                             #x8003
                             #x7
                             #xf
                             #xf
                             #xf00f
                             #xfc1f
                             #xfe3f
                             #xff3f
                             #xff3f
                             )
        )

;; definition for symbol *dice-good-way-array*, type (array uint16)
(define *dice-good-way-array* (new 'static 'boxed-array :type uint16
                                #x0
                                #x100
                                #x100
                                #x1e0
                                #xe0
                                #xf0
                                #x30
                                #x38
                                #x18
                                #x18
                                #x78
                                #x70
                                #x70
                                #x40
                                #xc0
                                #x80
                                #x80
                                #x80
                                #x3c0
                                #x780
                                #x3e0
                                #x100
                                #x0
                                #x0
                                )
        )

;; definition for symbol *dice-blocked-array*, type (array uint16)
(define *dice-blocked-array* (new 'static 'boxed-array :type uint16 :length 0 :allocated-length 26))

;; definition for symbol *dice-last-safe-position*, type vector
(define *dice-last-safe-position* (new 'static 'vector :x -2603417.5 :y 384983.03 :z -107683.84 :w 1.0))

;; failed to figure out what this is:
(defpart 1491
  :init-specs ((:texture (new 'static 'texture-id :index #xbc :page #xc))
    (:num 1.0)
    (:scale-x (meters 1))
    (:scale-y :copy scale-x)
    (:r 128.0 64.0)
    (:g 128.0 64.0)
    (:b 128.0 64.0)
    (:a 128.0)
    (:vel-x (meters -0.006666667) (meters 0.006666667))
    (:vel-z (meters -0.006666667) (meters 0.006666667))
    (:rotvel-z (degrees 0.3))
    (:fade-g -0.4)
    (:fade-b -0.4)
    (:fade-a -1.6)
    (:timer (seconds 0.267))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 glow))
    )
  )

;; definition for function dice-wrong-way?
(defun dice-wrong-way? ()
  (dotimes (v1-0 24)
    (if (nonzero? (logclear (-> *dice-blocked-array* v1-0) (-> *dice-good-way-array* v1-0)))
        (return #t)
        )
    )
  #f
  )

;; definition of type mtn-dice
(deftype mtn-dice (process-drawable)
  ((root                collide-shape-moving :override)
   (incoming-attack-id  uint32)
   (watervol            entity-actor)
   (face-matrix         matrix                6 :inline)
   (face-matrix-back    matrix                6 :inline)
   (face-status         int32                 6)
   (time-anim           float)
   (speed-anim          float)
   (rot-axis            vector                :inline)
   (rot-org             vector                :inline)
   (first               uint32)
   (active              uint32)
   (free-face           uint32)
   (color               vector                :inline)
   (punch-anim          symbol)
   (first-touch-time    time-frame)
   (curtime             time-frame)
   (hint-count          float)
   )
  (:state-methods
    idle
    idle-done
    animate
    fall
    restart
    )
  (:methods
    (mtn-dice-method-25 (_type_ int) none)
    (mtn-dice-method-26 (_type_ process-focusable touching-shapes-entry) touching-prims-entry)
    (mtn-dice-method-27 (_type_ collide-shape process-focusable touching-shapes-entry) none)
    )
  )

;; definition for method 3 of type mtn-dice
(defmethod inspect ((this mtn-dice))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tincoming-attack-id: ~D~%" (-> this incoming-attack-id))
  (format #t "~2Twatervol: ~A~%" (-> this watervol))
  (format #t "~2Tface-matrix[6] @ #x~X~%" (-> this face-matrix))
  (format #t "~2Tface-matrix-back[6] @ #x~X~%" (-> this face-matrix-back))
  (format #t "~2Tface-status[6] @ #x~X~%" (-> this face-status))
  (format #t "~2Ttime-anim: ~f~%" (-> this time-anim))
  (format #t "~2Tspeed-anim: ~f~%" (-> this speed-anim))
  (format #t "~2Trot-axis: #<vector @ #x~X>~%" (-> this rot-axis))
  (format #t "~2Trot-org: #<vector @ #x~X>~%" (-> this rot-org))
  (format #t "~2Tfirst: ~D~%" (-> this first))
  (format #t "~2Tactive: ~D~%" (-> this active))
  (format #t "~2Tfree-face: ~D~%" (-> this free-face))
  (format #t "~2Tcolor: #<vector @ #x~X>~%" (-> this color))
  (format #t "~2Tpunch-anim: ~A~%" (-> this punch-anim))
  (format #t "~2Tfirst-touch-time: ~D~%" (-> this first-touch-time))
  (format #t "~2Tcurtime: ~D~%" (-> this curtime))
  (format #t "~2Thint-count: ~f~%" (-> this hint-count))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-mtn-dice mtn-dice mtn-dice-lod0-jg mtn-dice-idle-ja
              ((mtn-dice-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 100)
              )

;; definition for method 25 of type mtn-dice
;; WARN: Return type mismatch int vs none.
(defmethod mtn-dice-method-25 ((this mtn-dice) (arg0 int))
  (let ((s4-0 (-> this face-matrix arg0)))
    (dotimes (s3-0 6)
      (let* ((v1-4 (-> this face-matrix s3-0))
             (f0-2 (fabs (vector-dot (the-as vector s4-0) (the-as vector v1-4))))
             )
        (when (and (!= s3-0 arg0) (zero? (-> this face-status s3-0)) (< f0-2 0.001))
          (set! (-> this face-status s3-0) 1)
          (mtn-dice-method-25 this s3-0)
          )
        )
      )
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate restart (mtn-dice)
  :virtual #t
  :enter (behavior ()
    (set! (-> self time-anim) 0.0)
    (set! (-> self speed-anim) 0.0)
    (dotimes (v1-0 6)
      (let* ((a0-2 (-> self face-matrix-back v1-0))
             (t0-0 (-> self face-matrix v1-0))
             (a1-2 (-> t0-0 quad 0))
             (a2-0 (-> t0-0 quad 1))
             (a3-0 (-> t0-0 quad 2))
             (t0-1 (-> t0-0 trans quad))
             )
        (set! (-> a0-2 quad 0) a1-2)
        (set! (-> a0-2 quad 1) a2-0)
        (set! (-> a0-2 quad 2) a3-0)
        (set! (-> a0-2 trans quad) t0-1)
        )
      )
    (sound-play "dice-sink")
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (set! (-> self draw color-mult quad) (-> self color quad))
    (cond
      ((time-elapsed? (-> self state-time) (seconds 0.5))
       (+! (-> self speed-anim) (* -0.5 (seconds-per-frame) (-> self time-anim)))
       (+! (-> self speed-anim) (* -6.0 (seconds-per-frame) (-> self speed-anim)))
       (+! (-> self time-anim) (-> self speed-anim))
       )
      (else
        (set! (-> self draw color-mult quad) (-> self color quad))
        (set! (-> self speed-anim) (- (-> self speed-anim) (* 2.0 (seconds-per-frame))))
        (+! (-> self time-anim) (-> self speed-anim))
        (set! (-> self active) (the-as uint 3))
        )
      )
    (when (and (time-elapsed? (-> self state-time) (seconds 0.5)) (!= (-> self active) 2))
      (set! (-> self active) (the-as uint 2))
      (dotimes (gp-0 6)
        (matrix-rotate-xyz! (-> self face-matrix gp-0) (-> *dice-angle-array* gp-0))
        (set! (-> self face-matrix gp-0 trans quad) (-> *dice-position-array* gp-0 quad))
        (vector+! (-> self face-matrix gp-0 trans) (-> self face-matrix gp-0 trans) (-> self root trans))
        (+! (-> self face-matrix gp-0 trans y) 8192.0)
        (let* ((v1-40 (-> self face-matrix-back gp-0))
               (a3-0 (-> self face-matrix gp-0))
               (a0-18 (-> a3-0 quad 0))
               (a1-5 (-> a3-0 quad 1))
               (a2-0 (-> a3-0 quad 2))
               (a3-1 (-> a3-0 trans quad))
               )
          (set! (-> v1-40 quad 0) a0-18)
          (set! (-> v1-40 quad 1) a1-5)
          (set! (-> v1-40 quad 2) a2-0)
          (set! (-> v1-40 trans quad) a3-1)
          )
        (set! (-> self face-status gp-0) 0)
        (let ((v1-44 (-> self root root-prim)))
          (logclear! (-> (the-as collide-shape-prim-group v1-44) child gp-0 prim-core action) (collide-action rideable))
          )
        )
      (set-vector! (-> self color) 0.5 0.5 0.5 1.0)
      (set! (-> self free-face) (the-as uint 6))
      )
    (dotimes (v1-51 6)
      (set! (-> self face-matrix v1-51 trans y)
            (+ (-> self face-matrix-back v1-51 trans y) (* 4096.0 (-> self time-anim)))
            )
      )
    (when (time-elapsed? (-> self state-time) (seconds 2))
      (set! (-> self active) (-> self first))
      (go-virtual idle)
      )
    )
  :code sleep-code
  :post transform-post
  )

;; definition for method 26 of type mtn-dice
;; INFO: Used lq/sq
(defmethod mtn-dice-method-26 ((this mtn-dice) (arg0 process-focusable) (arg1 touching-shapes-entry))
  (local-vars (sv-96 vector) (sv-112 vector) (sv-128 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let* ((s3-0 (-> arg0 root))
           (s4-0 (if (type? s3-0 collide-shape)
                     s3-0
                     )
                 )
           )
      (when s4-0
        (let ((s3-1 (new 'stack-no-clear 'vector))
              (f30-0 -0.71)
              (s2-0 (the-as touching-prims-entry #f))
              )
          (let ((s0-0 vector-z-quaternion!))
            (set! sv-96 s3-1)
            (let ((a1-3 (get-quat arg0 2)))
              (s0-0 sv-96 a1-3)
              )
            )
          (let ((s1-1 (-> arg1 head)))
            (while s1-1
              (let ((v1-4 (get-touched-prim s1-1 (-> this root) arg1)))
                (-> v1-4 cshape)
                (set! sv-128 (new 'stack-no-clear 'vector))
                (set! (-> sv-128 quad) (the-as uint128 0))
                (set! sv-112 (new 'stack-no-clear 'vector))
                (let ((s0-1 (new 'stack-no-clear 'vector)))
                  (new 'stack-no-clear 'vector)
                  (when (>= (-> this face-status (-> v1-4 prim-id)) 0)
                    (set! (-> sv-128 quad) (-> this face-matrix (-> v1-4 prim-id) quad 0))
                    (set! (-> sv-128 w) (- (vector-dot (-> this face-matrix (-> v1-4 prim-id) trans) sv-128)))
                    (set! (-> sv-112 quad) (-> this face-matrix (-> v1-4 prim-id) trans quad))
                    (let ((f0-4 (vector4-dot sv-128 (-> s4-0 trans)))
                          (f28-0 (vector-dot sv-128 s3-1))
                          )
                      (when (< f0-4 0.0)
                        (let ((a2-2 s0-1))
                          (let ((a0-28 sv-112))
                            (let ((a1-18 sv-128))
                              (let ((a3-1 -8192.0))
                                (.mov vf7 a3-1)
                                )
                              (.lvf vf5 (&-> a1-18 quad))
                              )
                            (.lvf vf4 (&-> a0-28 quad))
                            )
                          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                          (.mul.x.vf acc vf5 vf7 :mask #b111)
                          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                          (.svf (&-> a2-2 quad) vf6)
                          )
                        (let* ((a0-30 (the int (* 0.00024414062 (-> s0-1 x))))
                               (a1-20 (the int (* 0.00024414062 (-> s0-1 z))))
                               (a0-32 (/ (- *dice-offset-x* a0-30) -4))
                               )
                          (if (not (logtest? (-> *dice-blocked-array* (/ (- *dice-offset-z* a1-20) -4)) (ash 1 (- 15 a0-32))))
                              (set! f28-0 -2.0)
                              )
                          )
                        (let ((a0-40 sv-112))
                          (let ((v1-8 (-> this face-matrix (-> v1-4 prim-id) trans)))
                            (let ((a1-26 sv-128))
                              (let ((a2-10 16384.0))
                                (.mov vf7 a2-10)
                                )
                              (.lvf vf5 (&-> a1-26 quad))
                              )
                            (.lvf vf4 (&-> v1-8 quad))
                            )
                          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                          (.mul.x.vf acc vf5 vf7 :mask #b111)
                          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                          (.svf (&-> a0-40 quad) vf6)
                          )
                        (vector-negate-in-place! sv-128)
                        (set! f28-0 (- f28-0))
                        (if (!= (-> this free-face) 5)
                            (set! f28-0 1.0)
                            )
                        )
                      (let ((v1-13 s0-1))
                        (let ((a0-44 -8192.0))
                          (.mov vf7 a0-44)
                          )
                        (.lvf vf5 (&-> sv-128 quad))
                        (.lvf vf4 (&-> sv-112 quad))
                        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                        (.mul.x.vf acc vf5 vf7 :mask #b111)
                        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                        (.svf (&-> v1-13 quad) vf6)
                        )
                      (let* ((v1-15 (the int (* 0.00024414062 (-> s0-1 x))))
                             (a0-48 (the int (* 0.00024414062 (-> s0-1 z))))
                             (v1-17 (/ (- *dice-offset-x* v1-15) -4))
                             (a1-31 (/ (- *dice-offset-z* a0-48) -4))
                             )
                        (when (and (< f28-0 f30-0) (not (logtest? (-> *dice-world-array* a1-31) (ash 1 (- 15 v1-17)))))
                          (set! f30-0 f28-0)
                          (set! s2-0 s1-1)
                          )
                        )
                      )
                    )
                  )
                )
              (set! s1-1 (-> s1-1 next))
              )
            )
          s2-0
          )
        )
      )
    )
  )

;; definition for method 27 of type mtn-dice
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod mtn-dice-method-27 ((this mtn-dice) (arg0 collide-shape) (arg1 process-focusable) (arg2 touching-shapes-entry))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let* ((s3-0 (-> arg1 root))
           (s0-0 (if (type? s3-0 collide-shape)
                     s3-0
                     )
                 )
           )
      (when s0-0
        (let ((s5-1 ((method-of-type touching-prims-entry get-touched-prim)
                     (the-as touching-prims-entry arg0)
                     (-> this root)
                     arg2
                     )
                    )
              )
          (-> s5-1 cshape)
          (let ((s1-0 (new-stack-vector0))
                (s2-0 (new-stack-vector0))
                (s3-1 (new 'stack-no-clear 'vector))
                (s4-1 (new 'stack-no-clear 'vector))
                )
            (let ((v1-6 (-> this face-matrix (-> s5-1 prim-id))))
              (set! (-> s1-0 quad) (-> v1-6 vector 0 quad))
              (set! (-> s1-0 w) (- (vector-dot (-> v1-6 trans) s1-0)))
              (set! (-> s4-1 quad) (-> v1-6 trans quad))
              (when (< (vector4-dot s1-0 (-> s0-0 trans)) 0.0)
                (let ((a0-10 s4-1))
                  (let ((v1-7 (-> v1-6 trans)))
                    (let ((a1-9 s1-0))
                      (let ((a2-3 16384.0))
                        (.mov vf7 a2-3)
                        )
                      (.lvf vf5 (&-> a1-9 quad))
                      )
                    (.lvf vf4 (&-> v1-7 quad))
                    )
                  (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                  (.mul.x.vf acc vf5 vf7 :mask #b111)
                  (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                  (.svf (&-> a0-10 quad) vf6)
                  )
                (vector-negate-in-place! s1-0)
                )
              )
            (+! (-> s4-1 y) -8192.0)
            (set! (-> s2-0 y) 1.0)
            (vector-cross! s3-1 s2-0 s1-0)
            (vector-normalize! s3-1 1.0)
            (set! (-> this rot-axis quad) (-> s3-1 quad))
            (set! (-> this rot-org quad) (-> s4-1 quad))
            )
          (set! (-> this face-status (-> s5-1 prim-id)) 1)
          (mtn-dice-method-25 this (the-as int (-> s5-1 prim-id)))
          )
        )
      )
    0
    (none)
    )
  )

;; definition of type mtn-dice-info
(deftype mtn-dice-info (structure)
  ((mat  float  12)
   )
  )

;; definition for method 3 of type mtn-dice-info
(defmethod inspect ((this mtn-dice-info))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'mtn-dice-info)
  (format #t "~1Tmat[12] @ #x~X~%" (-> this mat))
  (label cfg-4)
  this
  )

;; definition for symbol *mtn-dice-done-info*, type (array mtn-dice-info)
(define *mtn-dice-done-info*
  (new 'static 'boxed-array :type mtn-dice-info
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 1.0 0.9999 0.0 0.0 -2584575.8 376831.97 172032.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 -0.9999 -0.9999 0.0 0.0 -2617343.2 376831.5 204800.06)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 0.9999 0.9999 0.0 0.0 -2600959.5 376831.66 204800.03)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 0.9999 1.0 0.0 0.0 -2600959.8 376831.75 172032.06)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 -1.0 0.0 0.0 0.0 0.0 1.0 -2584575.8 376832.0 155648.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 0.9999 0.9999 0.0 0.0 -2600959.5 376831.72 188416.03)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 1.0 0.9999 0.0 0.0 -2600959.8 376831.97 -73728.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 0.9999 0.9999 0.0 0.0 -2568191.5 376832.0 -73727.945)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 -1.0 -1.0 0.0 0.0 -2584575.8 376832.0 -73727.96)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 0.9999 1.0 0.0 0.0 -2551807.2 376832.0 -73727.9)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 -1.0 0.0 0.0 0.0 0.0 1.0 -2600959.8 376832.0 -90112.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 0.9999 0.9999 0.0 0.0 -2551807.2 376832.25 -57343.875)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 1.0 0.9999 0.0 0.0 -2551807.8 376832.0 -24576.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 -0.9999 0.0 0.0 0.0 0.0 0.9999 -2519039.2 376832.0 -8191.963)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 -1.0 -1.0 0.0 0.0 -2535423.5 376832.0 -24575.994)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 -0.9999 0.0 0.0 0.0 0.0 0.9999 -2519039.2 376831.97 8192.031)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 -1.0 0.0 0.0 0.0 0.0 1.0 -2551807.8 376832.0 -40960.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 -0.9999 -0.9999 0.0 0.0 -2535423.5 376831.97 -8191.9688)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 1.0 0.9999 0.0 0.0 -2519039.8 376832.0 40960.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 0.9999 0.9999 0.0 0.0 -2551807.5 376832.0 40960.047)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 -0.9999 0.0 0.0 0.0 0.0 0.9999 -2568191.2 376831.75 57344.03)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 0.9999 1.0 0.0 0.0 -2535423.5 376832.0 40960.004)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 -1.0 0.0 0.0 0.0 0.0 1.0 -2519039.8 376832.0 24576.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 -0.9999 0.0 0.0 0.0 0.0 1.0 -2551807.5 376831.97 57344.03)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 1.0 0.9999 0.0 0.0 -2568191.8 376831.97 90112.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.9999 0.0 0.0 0.0 0.0 -0.9999 -2584575.8 376831.72 122880.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 -0.9999 0.0 0.0 0.0 0.0 0.9999 -2584575.5 376831.72 139264.03)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.9999 0.0 0.0 0.0 0.0 -0.9999 -2584575.8 376831.75 106496.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 -1.0 0.0 0.0 0.0 0.0 1.0 -2568191.8 376832.0 73728.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.9999 0.0 0.0 0.0 0.0 -1.0 -2568191.8 376831.94 106496.0)
      )
    )
  )

;; failed to figure out what this is:
(defstate idle (mtn-dice)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (sv-192 vector))
    (cond
      ((= message 'print-info)
       (dotimes (gp-1 6)
         (let ((s5-1 (-> self face-matrix gp-1)))
           (format #t "(static-mtn-dice-info (")
           (format #t "~F ~F ~F " (-> s5-1 vector 0 x) (-> s5-1 vector 0 y) (-> s5-1 vector 0 z))
           (format #t "~F ~F ~F " (-> s5-1 vector 1 x) (-> s5-1 vector 1 y) (-> s5-1 vector 1 z))
           (format #t "~F ~F ~F " (-> s5-1 vector 2 x) (-> s5-1 vector 2 y) (-> s5-1 vector 2 z))
           (format #t "~F ~F ~F " (-> s5-1 trans x) (-> s5-1 trans y) (-> s5-1 trans z))
           )
         (format #t "))~%")
         )
       #f
       )
      ((= message 'trigger)
       (mem-set32! (the-as pointer *dice-blocked-array*) 13 0)
       (set! (-> *dice-blocked-array* 1) (the-as uint 256))
       (set! *dice-back-way-num* 0)
       (set-vector! *dice-last-safe-position* -2603417.5 384983.03 -107683.84 1.0)
       (if (and (= (-> self free-face) 5) (= (-> self active) 1))
           (set! (-> self active) (-> self first))
           )
       (if (or (< (-> self free-face) (the-as uint 5)) (= (-> self active) 3))
           (go-virtual restart)
           )
       )
      ((= message 'hint)
       (when (>= (-> self hint-count) 0.0)
         (+! (-> self hint-count) (seconds-per-frame))
         (if (< 6.0 (-> self hint-count))
             (talker-spawn-func (-> *talker-speech* 61) *entity-pool* (target-pos 0) (the-as region #f))
             )
         )
       )
      ((= message 'touch)
       (let* ((s3-0 proc)
              (s2-0 proc)
              (s4-1 (if (type? s2-0 process-focusable)
                        (the-as process-focusable s2-0)
                        )
                    )
              (s2-1 (-> (the-as process-focusable s3-0) root))
              (s3-1 (if (type? s2-1 collide-shape)
                        s2-1
                        )
                    )
              )
         (when s3-1
           (let* ((s2-2 (the-as object (-> block param 0)))
                  (s1-0 (-> (the-as touching-shapes-entry s2-2) head))
                  )
             (while s1-0
               (let ((s0-0 (get-touched-tri s1-0 (-> self root) (the-as touching-shapes-entry s2-2)))
                     (a1-13 (get-touched-prim s1-0 (-> self root) (the-as touching-shapes-entry s2-2)))
                     (v1-30 (new 'stack-no-clear 'matrix))
                     )
                 (let* ((a3-6 (-> self node-list data (+ (-> a1-13 prim-id) 4) bone transform))
                        (a0-26 (-> a3-6 quad 0))
                        (a1-17 (-> a3-6 quad 1))
                        (a2-9 (-> a3-6 quad 2))
                        (a3-7 (-> a3-6 trans quad))
                        )
                   (set! (-> v1-30 quad 0) a0-26)
                   (set! (-> v1-30 quad 1) a1-17)
                   (set! (-> v1-30 quad 2) a2-9)
                   (set! (-> v1-30 trans quad) a3-7)
                   )
                 (when s0-0
                   (when (and (< 0.9 (-> s0-0 normal y)) (< (-> v1-30 vector 0 y) -0.9))
                     (when (< (vector-dot
                                (vector-! (new 'stack-no-clear 'vector) (-> s3-1 trans) (the-as vector (-> s0-0 vertex)))
                                (-> s0-0 normal)
                                )
                              409.6
                              )
                       (when s4-1
                         (let ((s0-1 (new 'stack-no-clear 'vector)))
                           (set! sv-192 *dice-last-safe-position*)
                           (let* ((v1-42 (get-trans s4-1 0))
                                  (s0-2 (vector-! s0-1 sv-192 v1-42))
                                  )
                             (vector-float*! s0-2 s0-2 0.5)
                             (send-event proc 'shove (-> block param 0) (static-attack-info ((id (new-attack-id)) (vector s0-2))))
                             )
                           )
                         )
                       )
                     )
                   )
                 )
               (set! s1-0 (-> s1-0 next))
               )
             )
           #f
           )
         )
       )
      ((= message 'attack)
       (when (= (-> self active) 1)
         (let ((v1-56 (the-as object (-> block param 1))))
           (when (!= (-> (the-as attack-info v1-56) id) (-> self incoming-attack-id))
             (set! (-> self incoming-attack-id) (-> (the-as attack-info v1-56) id))
             (let ((s3-2 proc)
                   (s4-2 (if (type? proc process-focusable)
                             (the-as process-focusable proc)
                             )
                         )
                   )
               (let ((s5-3 (-> (the-as process-focusable s3-2) root)))
                 (if (type? s5-3 collide-shape)
                     (empty)
                     )
                 )
               (let* ((gp-3 (-> block param 0))
                      (a1-26 (mtn-dice-method-26 self s4-2 (the-as touching-shapes-entry gp-3)))
                      )
                 (cond
                   (a1-26
                     (mtn-dice-method-27 self (the-as collide-shape a1-26) s4-2 (the-as touching-shapes-entry gp-3))
                     (set! (-> self punch-anim) #t)
                     (sound-play "dice-hit")
                     (set! (-> self hint-count) -1.0)
                     (go-virtual animate)
                     'push
                     )
                   (else
                     (set! (-> self incoming-attack-id) (the-as uint 0))
                     #f
                     )
                   )
                 )
               )
             )
           )
         )
       )
      )
    )
  :enter (behavior ()
    (set! (-> self curtime) 0)
    (set! (-> self first-touch-time) 0)
    0
    )
  :trans (behavior ()
    (if (nonzero? (-> self curtime))
        (set-time! (-> self first-touch-time))
        )
    (set-time! (-> self curtime))
    (when (and (zero? (-> self active)) (dice-wrong-way?))
      )
    )
  :code sleep-code
  :post (behavior ()
    (rider-trans)
    (if (= (-> self active) 1)
        (set! (-> self color x) (fmin 1.0 (+ (-> self color x) (* 2.0 (seconds-per-frame)))))
        (set! (-> self color x) (fmax 0.5 (- (-> self color x) (* 2.0 (seconds-per-frame)))))
        )
    (set! (-> self color y) (-> self color x))
    (set! (-> self color z) (-> self color x))
    (set! (-> self draw color-mult quad) (-> self color quad))
    (when (zero? (-> self active))
      (let* ((v1-15 (the int (* 0.00024414062 (-> self root trans x))))
             (a0-5 (the int (* 0.00024414062 (-> self root trans z))))
             (s5-0 (/ (- *dice-offset-x* v1-15) -4))
             (gp-0 (/ (- *dice-offset-z* a0-5) -4))
             )
        (when (or (logtest? (-> *dice-blocked-array* (+ gp-0 1)) (ash 1 (- 15 s5-0)))
                  (logtest? (-> *dice-blocked-array* (+ gp-0 -1)) (ash 1 (- 15 s5-0)))
                  (logtest? (-> *dice-blocked-array* gp-0) (ash 1 (- 15 (+ s5-0 1))))
                  (logtest? (-> *dice-blocked-array* gp-0) (ash 1 (- 15 (+ s5-0 -1))))
                  )
          (when (> *dice-back-way-num* 0)
            (set! (-> *dice-last-safe-position* quad) (-> *dice-back-way* (+ *dice-back-way-num* -1) quad))
            (+! (-> *dice-last-safe-position* y) 8192.0)
            )
          (when (not (dice-wrong-way?))
            (set! (-> *dice-back-way* *dice-back-way-num* quad) (-> self root trans quad))
            (set! *dice-back-way-num* (+ *dice-back-way-num* 1))
            )
          (set! (-> *dice-blocked-array* gp-0)
                (the-as uint (logior (ash 1 (- 15 s5-0)) (-> *dice-blocked-array* gp-0)))
                )
          (set! (-> self active) (the-as uint 1))
          )
        )
      )
    (when (= (-> self first) 1)
      )
    (rider-post)
    )
  )

;; failed to figure out what this is:
(defstate idle-done (mtn-dice)
  :virtual #t
  :enter (behavior ()
    (set! (-> self curtime) 0)
    (set! (-> self first-touch-time) 0)
    0
    )
  :trans (behavior ()
    '()
    )
  :code sleep-code
  :post (behavior ()
    (rider-trans)
    (rider-post)
    )
  )

;; failed to figure out what this is:
(defstate animate (mtn-dice)
  :virtual #t
  :enter (behavior ()
    (dotimes (v1-0 6)
      (let* ((a0-2 (-> self face-matrix-back v1-0))
             (t0-0 (-> self face-matrix v1-0))
             (a1-2 (-> t0-0 quad 0))
             (a2-0 (-> t0-0 quad 1))
             (a3-0 (-> t0-0 quad 2))
             (t0-1 (-> t0-0 trans quad))
             )
        (set! (-> a0-2 quad 0) a1-2)
        (set! (-> a0-2 quad 1) a2-0)
        (set! (-> a0-2 quad 2) a3-0)
        (set! (-> a0-2 trans quad) t0-1)
        )
      )
    (set-time! (-> self state-time))
    (set! (-> self time-anim) 1.0)
    (set! (-> self speed-anim) -0.5)
    )
  :trans (behavior ()
    (set! (-> self draw color-mult quad) (-> self color quad))
    (cond
      ((-> self punch-anim)
       (+! (-> self speed-anim) (* -4.0 (seconds-per-frame) (-> self time-anim)))
       (+! (-> self speed-anim) (* -16.0 (seconds-per-frame) (-> self speed-anim)))
       )
      (else
        (+! (-> self speed-anim) (* -3.0 (seconds-per-frame) (-> self time-anim)))
        (+! (-> self speed-anim) (* -20.0 (seconds-per-frame) (-> self speed-anim)))
        )
      )
    (+! (-> self time-anim) (-> self speed-anim))
    (when (< (-> self time-anim) 0.0)
      (set! (-> self time-anim) 0.0)
      (set! (-> self speed-anim) (- (-> self speed-anim)))
      )
    (if (time-elapsed? (-> self state-time) (seconds 0.7))
        (set! (-> self time-anim) 0.0)
        )
    (let ((s4-0 (new 'stack-no-clear 'matrix))
          (s5-0 (new 'stack-no-clear 'matrix))
          (gp-0 (new 'stack-no-clear 'matrix))
          )
      (let ((f0-16 (- 1.0 (-> self time-anim)))
            (s3-0 (new 'stack-no-clear 'vector))
            )
        (matrix-axis-angle! s4-0 (-> self rot-axis) (* 16384.0 f0-16))
        (vector-negate! s3-0 (-> self rot-org))
        (matrix-translate! s5-0 s3-0)
        )
      (matrix<-trans s4-0 (-> self rot-org))
      (matrix*! gp-0 s5-0 s4-0)
      (dotimes (s5-1 6)
        (if (= (-> self face-status s5-1) 1)
            (matrix*! (-> self face-matrix s5-1) (-> self face-matrix-back s5-1) gp-0)
            )
        )
      )
    (when (time-elapsed? (-> self state-time) (seconds 0.7))
      (dotimes (v1-34 6)
        (when (= (-> self face-status v1-34) 1)
          (set! (-> self face-status v1-34) 0)
          0
          )
        )
      (go-virtual idle)
      )
    )
  :code sleep-code
  :post (behavior ()
    (transform-post)
    )
  )

;; failed to figure out what this is:
(defstate fall (mtn-dice)
  :virtual #t
  :enter (behavior ()
    (set! (-> self time-anim) 0.0)
    (set! (-> self speed-anim) 0.0)
    (set-time! (-> self state-time))
    (sound-play "dice-sink")
    )
  :trans (behavior ()
    (set! (-> self draw color-mult quad) (-> self color quad))
    (set! (-> self speed-anim) (- (-> self speed-anim) (* 0.05 (seconds-per-frame))))
    (+! (-> self time-anim) (-> self speed-anim))
    (set! (-> self active) (the-as uint 3))
    (dotimes (v1-5 6)
      (+! (-> self face-matrix v1-5 trans y) (* 4096.0 (-> self time-anim)))
      )
    (when (time-elapsed? (-> self state-time) (seconds 1))
      (dotimes (v1-11 6)
        (when (= (-> self face-status v1-11) 1)
          (set! (-> self face-status v1-11) 0)
          0
          )
        )
      (go-virtual idle)
      )
    )
  :code sleep-code
  :post transform-post
  )

;; definition for function dice-joint-callback
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defun dice-joint-callback ((arg0 draw-control) (arg1 cspace-array) (arg2 joint-control))
  (local-vars
    (sv-544 int)
    (sv-560 vector)
    (sv-576 vector)
    (sv-592 vector)
    (sv-608 vector)
    (sv-624 vector)
    (sv-640 vector)
    (sv-656 matrix)
    (sv-672 matrix)
    (sv-688 vector)
    (sv-704 vector)
    )
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 (the-as mtn-dice (-> arg0 process))))
      (new 'stack-no-clear 'vector)
      (let ((s4-0 (new 'stack-no-clear 'vector))
            (s5-0 (new 'stack-no-clear 'vector))
            )
        (set-vector! s4-0 4095996000.0 4095996000.0 4095996000.0 1.0)
        (set-vector! s5-0 -4095996000.0 -4095996000.0 -4095996000.0 1.0)
        (dotimes (s2-0 6)
          (let ((s1-0 (-> arg1 data (+ s2-0 4) bone transform)))
            (new-stack-matrix0)
            (let* ((v1-9 s1-0)
                   (a3-0 (-> gp-0 face-matrix s2-0))
                   (a0-11 (-> a3-0 quad 0))
                   (a1-1 (-> a3-0 quad 1))
                   (a2-1 (-> a3-0 quad 2))
                   (a3-1 (-> a3-0 trans quad))
                   )
              (set! (-> v1-9 quad 0) a0-11)
              (set! (-> v1-9 quad 1) a1-1)
              (set! (-> v1-9 quad 2) a2-1)
              (set! (-> v1-9 trans quad) a3-1)
              )
            (let ((v1-12 (the int (+ 2.0 (* 0.00024414062 (-> s1-0 trans x)))))
                  (a0-14 (the int (+ 2.0 (* 0.00024414062 (-> s1-0 trans z)))))
                  )
              (set! sv-544 (/ (- *dice-offset-x* v1-12) -4))
              (let ((s0-0 (/ (- *dice-offset-z* a0-14) -4)))
                (when (and (= (-> gp-0 face-status s2-0) -1) (= (-> gp-0 active) 1))
                  (when (and (= (-> gp-0 active) 1) (not (logtest? (-> *dice-blocked-array* s0-0) (ash 1 (- 15 sv-544)))))
                    (when (> *dice-back-way-num* 0)
                      (set! (-> *dice-last-safe-position* quad) (-> *dice-back-way* (+ *dice-back-way-num* -1) quad))
                      (+! (-> *dice-last-safe-position* y) 8192.0)
                      )
                    (when (not (dice-wrong-way?))
                      (set! (-> *dice-back-way* *dice-back-way-num* quad) (-> s1-0 trans quad))
                      (set! *dice-back-way-num* (+ *dice-back-way-num* 1))
                      )
                    (set! (-> *dice-blocked-array* s0-0)
                          (the-as uint (logior (ash 1 (- 15 sv-544)) (-> *dice-blocked-array* s0-0)))
                          )
                    )
                  )
                )
              )
            (cond
              ((>= (-> gp-0 face-status s2-0) 0)
               (when (and (< 0.8 (-> s1-0 vector 0 y)) (zero? (-> gp-0 face-status s2-0)))
                 (+! (-> gp-0 free-face) -1)
                 (set! (-> gp-0 face-status s2-0) -1)
                 )
               (let* ((v1-59 (-> gp-0 face-matrix s2-0))
                      (a3-3 s1-0)
                      (a0-45 (-> a3-3 quad 0))
                      (a1-11 (-> a3-3 quad 1))
                      (a2-5 (-> a3-3 quad 2))
                      (a3-4 (-> a3-3 trans quad))
                      )
                 (set! (-> v1-59 quad 0) a0-45)
                 (set! (-> v1-59 quad 1) a1-11)
                 (set! (-> v1-59 quad 2) a2-5)
                 (set! (-> v1-59 trans quad) a3-4)
                 )
               )
              (else
                (when (!= (-> gp-0 free-face) 5)
                  (let ((a0-47 (-> gp-0 root root-prim)))
                    (logior! (-> (the-as collide-shape-prim-group a0-47) child s2-0 prim-core action) (collide-action rideable))
                    )
                  )
                )
              )
            (when (-> gp-0 watervol)
              (let* ((v1-70 (-> gp-0 watervol))
                     (s0-1 (if v1-70
                               (the-as water-anim (-> v1-70 extra process))
                               )
                           )
                     )
                (when s0-1
                  (set! sv-560 (new 'stack-no-clear 'vector))
                  (set! sv-576 (new 'stack-no-clear 'vector))
                  (set! sv-608 (new 'stack-no-clear 'vector))
                  (set! sv-592 (new 'stack-no-clear 'vector))
                  (set! sv-672 (new 'stack-no-clear 'matrix))
                  (set! sv-640 (new 'stack-no-clear 'vector))
                  (let ((a1-15 sv-560))
                    (let ((v1-79 (-> s1-0 trans)))
                      (let ((a0-50 (-> s1-0 vector)))
                        (let ((a2-7 8192.0))
                          (.mov vf7 a2-7)
                          )
                        (.lvf vf5 (&-> a0-50 0 quad))
                        )
                      (.lvf vf4 (&-> v1-79 quad))
                      )
                    (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                    (.mul.x.vf acc vf5 vf7 :mask #b111)
                    (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                    (.svf (&-> a1-15 quad) vf6)
                    )
                  (set! (-> sv-640 quad) (-> sv-560 quad))
                  (set! (-> sv-576 quad) (-> sv-560 quad))
                  (+! (-> sv-576 x) 8192.0)
                  (set! (-> sv-608 quad) (-> sv-560 quad))
                  (+! (-> sv-608 z) 8192.0)
                  (set! (-> sv-560 y) (get-ripple-height s0-1 sv-560))
                  (set! (-> sv-576 y) (get-ripple-height s0-1 sv-576))
                  (set! (-> sv-608 y) (get-ripple-height s0-1 sv-608))
                  (vector-! sv-576 sv-576 sv-560)
                  (vector-! sv-608 sv-608 sv-560)
                  (set! (-> sv-576 y) (* 0.5 (-> sv-576 y)))
                  (set! (-> sv-608 y) (* 0.5 (-> sv-608 y)))
                  (set! (-> sv-576 w) 0.0)
                  (set! (-> sv-592 w) 0.0)
                  (set! (-> sv-608 w) 0.0)
                  (vector-normalize! sv-576 1.0)
                  (vector-normalize! sv-608 1.0)
                  (vector-cross! sv-592 sv-608 sv-576)
                  (vector-normalize! sv-592 1.0)
                  (vector-cross! sv-608 sv-576 sv-592)
                  (vector-normalize! sv-608 1.0)
                  (matrix-identity! sv-672)
                  (set! (-> sv-672 vector 0 quad) (-> sv-576 quad))
                  (set! (-> sv-672 vector 1 quad) (-> sv-592 quad))
                  (set! (-> sv-672 vector 2 quad) (-> sv-608 quad))
                  (set! sv-624 (new 'stack-no-clear 'vector))
                  (set! sv-656 (new 'stack-no-clear 'matrix))
                  (set! sv-688 (new 'stack-no-clear 'vector))
                  (vector-negate! sv-624 sv-640)
                  (matrix-translate! sv-656 sv-624)
                  (matrix<-trans sv-672 sv-640)
                  (matrix*! (the-as matrix sv-688) sv-656 sv-672)
                  (matrix*! s1-0 s1-0 (the-as matrix sv-688))
                  (+! (-> s1-0 trans y) (* 0.5 (- (-> sv-560 y) (-> s0-1 water-height))))
                  (+! (-> s1-0 trans y) 8192.0)
                  (set! (-> s4-0 x) (fmin (-> s4-0 x) (-> s1-0 trans x)))
                  (set! (-> s4-0 y) (fmin (-> s4-0 y) (-> s1-0 trans y)))
                  (set! (-> s4-0 z) (fmin (-> s4-0 z) (-> s1-0 trans z)))
                  (set! (-> s5-0 x) (fmax (-> s5-0 x) (-> s1-0 trans x)))
                  (set! (-> s5-0 y) (fmax (-> s5-0 y) (-> s1-0 trans y)))
                  (set! (-> s5-0 z) (fmax (-> s5-0 z) (-> s1-0 trans z)))
                  )
                )
              )
            (let ((s0-2 (new 'stack-no-clear 'vector)))
              (set! (-> s0-2 quad) (-> s1-0 vector 0 quad))
              (set! sv-704 (new 'stack-no-clear 'vector))
              (let ((v1-125 (-> s1-0 trans quad)))
                (set! (-> sv-704 quad) v1-125)
                )
              (let ((a1-36 sv-704))
                (let ((v1-126 sv-704))
                  (let ((a0-81 s0-2))
                    (let ((a2-11 8192.0))
                      (.mov vf7 a2-11)
                      )
                    (.lvf vf5 (&-> a0-81 quad))
                    )
                  (.lvf vf4 (&-> v1-126 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a1-36 quad) vf6)
                )
              (let ((f30-0 0.0)
                    (s1-1 (new 'stack-no-clear 'vector))
                    (v0-14 (camera-pos))
                    )
                (cond
                  ((< f30-0 (vector-dot s0-2 (vector-! s1-1 sv-704 v0-14)))
                   (let ((v1-129 s2-0))
                     (cond
                       ((zero? v1-129)
                        (setup-masks (-> gp-0 draw) 2 0)
                        )
                       ((= v1-129 1)
                        (setup-masks (-> gp-0 draw) 4 0)
                        )
                       ((= v1-129 2)
                        (setup-masks (-> gp-0 draw) 8 0)
                        )
                       ((= v1-129 3)
                        (setup-masks (-> gp-0 draw) 16 0)
                        )
                       ((= v1-129 4)
                        (setup-masks (-> gp-0 draw) 32 0)
                        )
                       ((= v1-129 5)
                        (setup-masks (-> gp-0 draw) 64 0)
                        )
                       )
                     )
                   )
                  (else
                    (let ((v1-143 s2-0))
                      (cond
                        ((zero? v1-143)
                         (setup-masks (-> gp-0 draw) 0 2)
                         )
                        ((= v1-143 1)
                         (setup-masks (-> gp-0 draw) 0 4)
                         )
                        ((= v1-143 2)
                         (setup-masks (-> gp-0 draw) 0 8)
                         )
                        ((= v1-143 3)
                         (setup-masks (-> gp-0 draw) 0 16)
                         )
                        ((= v1-143 4)
                         (setup-masks (-> gp-0 draw) 0 32)
                         )
                        ((= v1-143 5)
                         (setup-masks (-> gp-0 draw) 0 64)
                         )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        (let ((s2-1 (new 'stack-no-clear 'vector))
              (s3-1 (new 'stack-no-clear 'vector))
              )
          (vector-average! s2-1 s4-0 s5-0)
          (vector-! s2-1 s2-1 (-> gp-0 root trans))
          (vector-! s3-1 s5-0 s4-0)
          (set! (-> gp-0 draw bounds quad) (-> s2-1 quad))
          (set! (-> gp-0 draw bounds w) (+ 16384.0 (* 0.5 (vector-length s3-1))))
          )
        )
      (set! (-> (the-as collide-shape (-> gp-0 root)) root-prim local-sphere quad) (-> gp-0 draw bounds quad))
      (vector-rotate90-around-y! (-> gp-0 draw bounds) (-> gp-0 draw bounds))
      )
    0
    (none)
    )
  )

;; definition for method 11 of type mtn-dice
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this mtn-dice) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 6) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 7))
      (set! (-> s3-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable pull-rider-can-collide))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 122880.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 4)
      (set-vector! (-> v1-10 local-sphere) 0.0 0.0 0.0 11878.4)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 1))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-12 prim-core action) (collide-action solid))
      (set! (-> v1-12 transform-index) 5)
      (set-vector! (-> v1-12 local-sphere) 0.0 0.0 0.0 11878.4)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 2))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-14 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-14 prim-core action) (collide-action solid))
      (set! (-> v1-14 transform-index) 6)
      (set-vector! (-> v1-14 local-sphere) 0.0 0.0 0.0 11878.4)
      )
    (let ((v1-16 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 3))))
      (set! (-> v1-16 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-16 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-16 prim-core action) (collide-action solid))
      (set! (-> v1-16 transform-index) 7)
      (set-vector! (-> v1-16 local-sphere) 0.0 0.0 0.0 11878.4)
      )
    (let ((v1-18 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 4))))
      (set! (-> v1-18 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-18 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-18 prim-core action) (collide-action solid))
      (set! (-> v1-18 transform-index) 8)
      (set-vector! (-> v1-18 local-sphere) 0.0 0.0 0.0 11878.4)
      )
    (let ((v1-20 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 5))))
      (set! (-> v1-20 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-20 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-20 prim-core action) (collide-action solid))
      (set! (-> v1-20 transform-index) 9)
      (set-vector! (-> v1-20 local-sphere) 0.0 0.0 0.0 11878.4)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-23 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-23 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-23 prim-core collide-with))
      )
    (set! (-> this root) (the-as collide-shape-moving s4-0))
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-dice" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this skel postbind-function) dice-joint-callback)
  (set! (-> this first) (the-as uint 0))
  (let ((v1-30 (res-lump-value arg0 'extra-id uint128 :default (the-as uint128 -1) :time -1000000000.0)))
    (if (= (the-as uint v1-30) 2)
        (set! (-> this first) (the-as uint 1))
        )
    )
  (let* ((a0-48 (the int (* 0.00024414062 (-> this root trans x))))
         (v1-37 (the int (* 0.00024414062 (-> this root trans y))))
         (a1-21 (the int (* 0.00024414062 (-> this root trans z))))
         (a0-49 (- a0-48 *dice-offset-x*))
         (a2-13 (- a1-21 *dice-offset-z*))
         (a1-22 (+ a0-49 1))
         (a0-50 (+ a2-13 1))
         (a1-23 (logand -4 a1-22))
         (v1-38 (logand -2 v1-37))
         (a0-51 (logand -4 a0-50))
         (a1-24 (+ a1-23 *dice-offset-x*))
         (a0-52 (+ a0-51 *dice-offset-z*))
         )
    (set! (-> this root trans x) (* 4096.0 (the float a1-24)))
    (set! (-> this root trans y) (* 4096.0 (the float v1-38)))
    (set! (-> this root trans z) (* 4096.0 (the float a0-52)))
    )
  (dotimes (s4-2 6)
    (matrix-rotate-xyz! (-> this face-matrix s4-2) (-> *dice-angle-array* s4-2))
    (set! (-> this face-matrix s4-2 trans quad) (-> *dice-position-array* s4-2 quad))
    (vector+! (-> this face-matrix s4-2 trans) (-> this face-matrix s4-2 trans) (-> this root trans))
    (+! (-> this face-matrix s4-2 trans y) 8192.0)
    )
  (mem-set32! (the-as pointer *dice-blocked-array*) 13 0)
  (set! (-> *dice-blocked-array* 1) (the-as uint 256))
  (set! *dice-back-way-num* 0)
  (set-vector! *dice-last-safe-position* -2603417.5 384983.03 -107683.84 1.0)
  (set-vector! (-> this color) 0.5 0.5 0.5 1.0)
  (set! (-> this free-face) (the-as uint 6))
  (set! (-> this watervol) (entity-actor-lookup (-> this entity) 'alt-actor 0))
  (set! (-> this hint-count) 0.0)
  (set! (-> this active) (-> this first))
  (setup-masks (-> this draw) 0 -1)
  (setup-masks (-> this draw) 1 0)
  (cond
    ((task-node-closed? (game-task-node mountain-shard-dice))
     (let ((v1-71 (res-lump-value arg0 'extra-id uint128 :default (the-as uint128 -1) :time -1000000000.0)))
       (dotimes (a0-76 6)
         (let ((a1-42 (-> *mtn-dice-done-info* (+ a0-76 (* 6 (the-as int (+ v1-71 -1)))))))
           (set! (-> this face-matrix a0-76 vector 0 x) (-> a1-42 mat 0))
           (set! (-> this face-matrix a0-76 vector 0 y) (-> a1-42 mat 1))
           (set! (-> this face-matrix a0-76 vector 0 z) (-> a1-42 mat 2))
           (set! (-> this face-matrix a0-76 vector 0 w) 0.0)
           (set! (-> this face-matrix a0-76 vector 1 x) (-> a1-42 mat 3))
           (set! (-> this face-matrix a0-76 vector 1 y) (-> a1-42 mat 4))
           (set! (-> this face-matrix a0-76 vector 1 z) (-> a1-42 mat 5))
           (set! (-> this face-matrix a0-76 vector 1 w) 0.0)
           (set! (-> this face-matrix a0-76 vector 2 x) (-> a1-42 mat 6))
           (set! (-> this face-matrix a0-76 vector 2 y) (-> a1-42 mat 7))
           (set! (-> this face-matrix a0-76 vector 2 z) (-> a1-42 mat 8))
           (set! (-> this face-matrix a0-76 vector 2 w) 0.0)
           (set! (-> this face-matrix a0-76 trans x) (-> a1-42 mat 9))
           (set! (-> this face-matrix a0-76 trans y) (-> a1-42 mat 10))
           (set! (-> this face-matrix a0-76 trans z) (-> a1-42 mat 11))
           )
         (set! (-> this face-matrix a0-76 trans w) 1.0)
         )
       )
     (go (method-of-object this idle-done))
     )
    (else
      (go (method-of-object this idle))
      )
    )
  (none)
  )

;; definition of type mtn-plat-elevator
(deftype mtn-plat-elevator (elevator)
  ()
  )

;; definition for method 3 of type mtn-plat-elevator
(defmethod inspect ((this mtn-plat-elevator))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type elevator inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-mtn-plat-elevator mtn-plat-elevator mtn-plat-elevator-lod0-jg mtn-plat-elevator-idle-ja
              ((mtn-plat-elevator-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 7)
              )

;; definition for method 30 of type mtn-plat-elevator
(defmethod get-art-group ((this mtn-plat-elevator))
  "@returns The associated [[art-group]]"
  (art-group-get-by-name *level* "skel-mtn-plat-elevator" (the-as (pointer uint32) #f))
  )

;; definition for method 42 of type mtn-plat-elevator
;; WARN: Return type mismatch int vs none.
(defmethod set-ambient-sound! ((this mtn-plat-elevator))
  "Sets the elevator's [[ambient-sound]] up"
  (set! (-> this sound)
        (new 'process 'ambient-sound (static-sound-spec "mtn-elevator-lp" :fo-max 70) (-> this root trans))
        )
  0
  (none)
  )

;; definition for method 43 of type mtn-plat-elevator
(defmethod move-between-points ((this mtn-plat-elevator) (arg0 vector) (arg1 float) (arg2 float))
  "Move between two points on the elevator's path
@param vec TODO not sure
@param point-a The first point fetched from the elevator's path
@param point-b The second point fetched from the path
@see [[path-control]] and [[elevator]]"
  (let ((s4-0 (get-point-in-path! (-> this path) (new 'stack-no-clear 'vector) arg1 'interp))
        (a0-3 (get-point-in-path! (-> this path) (new 'stack-no-clear 'vector) arg2 'interp))
        )
    (and (< (-> a0-3 y) (-> s4-0 y))
         (< (-> arg0 y) (+ -4096.0 (-> this root trans y)))
         (< (vector-vector-xz-distance a0-3 arg0) 24576.0)
         )
    )
  )

;; definition for method 31 of type mtn-plat-elevator
;; WARN: Return type mismatch int vs none.
(defmethod init-plat-collision! ((this mtn-plat-elevator))
  "TODO - collision stuff for setting up the platform"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 28672.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) (the-as collide-shape-moving s5-0))
    )
  0
  (none)
  )

;; definition of type mtn-plat-updown
(deftype mtn-plat-updown (base-plat)
  ((sync      sync-eased  :inline)
   (path-pos  float)
   )
  (:state-methods
    idle
    active
    )
  )

;; definition for method 3 of type mtn-plat-updown
(defmethod inspect ((this mtn-plat-updown))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type base-plat inspect)))
    (t9-0 this)
    )
  (format #t "~2Tsync: #<sync-eased @ #x~X>~%" (-> this sync))
  (format #t "~2Tpath-pos: ~f~%" (-> this path-pos))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-mtn-plat-updown mtn-plat-updown mtn-plat-updown-lod0-jg mtn-plat-updown-idle-ja
              ((mtn-plat-updown-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

;; failed to figure out what this is:
(defstate idle (mtn-plat-updown)
  :virtual #t
  :code sleep-code
  :post ja-post
  )

;; failed to figure out what this is:
(defstate active (mtn-plat-updown)
  :virtual #t
  :event plat-event
  :trans (behavior ()
    (set! (-> self path-pos) (get-norm! (-> self sync) 0))
    (get-point-at-percent-along-path! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
    (plat-trans)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post plat-post
  )

;; definition for method 31 of type mtn-plat-updown
;; WARN: Return type mismatch int vs none.
(defmethod init-plat-collision! ((this mtn-plat-updown))
  "TODO - collision stuff for setting up the platform"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 16384.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) (the-as collide-shape-moving s5-0))
    )
  0
  (none)
  )

;; definition for method 11 of type mtn-plat-updown
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this mtn-plat-updown) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (init-plat-collision! this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-plat-updown" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (let ((a0-5 (-> this skel root-channel 0)))
    (set! (-> a0-5 frame-group) (if (> (-> this skel active-channels) 0)
                                    (-> this skel root-channel 0 frame-group)
                                    )
          )
    (set! (-> a0-5 param 0) 1.0)
    (set! (-> a0-5 frame-num) 0.0)
    (joint-control-channel-group!
      a0-5
      (if (> (-> this skel active-channels) 0)
          (-> this skel root-channel 0 frame-group)
          )
      num-func-loop!
      )
    )
  (ja-post)
  (set! (-> this path) (new 'process 'path-control this 'path 0.0 arg0 #f))
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (set! (-> this fact)
        (new 'process 'fact-info this (pickup-type eco-pill-random) (-> *FACT-bank* default-eco-pill-green-inc))
        )
  (let ((a1-7 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-24 0))
      (if (not (logtest? (-> this fact options) (actor-option loop)))
          (set! v1-24 (logior v1-24 1))
          )
      (set! (-> a1-7 sync-type) 'sync-eased)
      (set! (-> a1-7 sync-flags) (the-as sync-flags v1-24))
      )
    (set! (-> a1-7 period) (the-as uint 1800))
    (set! (-> a1-7 entity) arg0)
    (set! (-> a1-7 percent) 0.0)
    (set! (-> a1-7 ease-in) 0.15)
    (set! (-> a1-7 ease-out) 0.15)
    (set! (-> a1-7 pause-in) 0.2)
    (set! (-> a1-7 pause-out) 0.0)
    (initialize! (-> this sync) a1-7)
    )
  (cond
    ((logtest? (-> this path flags) (path-control-flag not-found))
     (go (method-of-object this idle))
     )
    ((> (-> this sync period) 0)
     (go (method-of-object this active))
     )
    (else
      (go (method-of-object this idle))
      )
    )
  (none)
  )

;; definition of type mtn-plat-eject
(deftype mtn-plat-eject (process-drawable)
  ((dest-pos  vector  :inline)
   )
  (:state-methods
    wait
    eject
    )
  (:methods
    (mtn-plat-eject-method-22 (_type_) none)
    )
  )

;; definition for method 3 of type mtn-plat-eject
(defmethod inspect ((this mtn-plat-eject))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tdest-pos: #<vector @ #x~X>~%" (-> this dest-pos))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-mtn-plat-eject mtn-plat-eject mtn-plat-eject-lod0-jg mtn-plat-eject-idle-ja
              ((mtn-plat-eject-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 4 7.1)
              )

;; failed to figure out what this is:
(defstate wait (mtn-plat-eject)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('eject)
       (go-virtual eject)
       )
      )
    )
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate eject (mtn-plat-eject)
  :virtual #t
  :enter (behavior ()
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (ja-channel-push! 1 0)
    (ja-no-eval :group! mtn-plat-eject-idle-ja :num! (loop!) :frame-num 0.0)
    )
  :code sleep-code
  :post (behavior ()
    (let ((gp-1 (vector-! (new 'stack-no-clear 'vector) (-> self dest-pos) (-> self root trans))))
      (vector-normalize! gp-1 (* 0.25 (vector-length gp-1)))
      (vector+! (-> self root trans) (-> self root trans) gp-1)
      )
    (transform-post)
    )
  )

;; definition for method 22 of type mtn-plat-eject
;; WARN: Return type mismatch int vs none.
(defmethod mtn-plat-eject-method-22 ((this mtn-plat-eject))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) 0.0 0.0 16384.0 29081.6)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-2)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; definition for method 11 of type mtn-plat-eject
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this mtn-plat-eject) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (mtn-plat-eject-method-22 this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-plat-eject" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this dest-pos quad) (-> this root trans quad))
  (let ((s5-2 (new 'stack-no-clear 'vector)))
    (set! (-> s5-2 x) 0.0)
    (set! (-> s5-2 y) 0.0)
    (set! (-> s5-2 z) -40960.0)
    (set! (-> s5-2 w) 1.0)
    (vector-orient-by-quat! s5-2 s5-2 (-> this root quat))
    (vector+! (-> this root trans) (-> this root trans) s5-2)
    )
  (if (and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete)))
      (go (method-of-object this eject))
      (go (method-of-object this wait))
      )
  (none)
  )

;; definition of type mtn-plat-long
(deftype mtn-plat-long (base-plat)
  ((sync  sync-linear  :inline)
   )
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type mtn-plat-long
(defmethod inspect ((this mtn-plat-long))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type base-plat inspect)))
    (t9-0 this)
    )
  (format #t "~2Tsync: #<sync-linear @ #x~X>~%" (-> this sync))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-mtn-plat-long mtn-plat-long mtn-plat-long-lod0-jg mtn-plat-long-idle-ja
              ((mtn-plat-long-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15.5)
              )

;; failed to figure out what this is:
(defstate idle (mtn-plat-long)
  :virtual #t
  :event plat-event
  :trans plat-trans
  :code (behavior ()
    (until #f
      (let ((f0-1 (* (get-current-phase-no-mod (-> self sync)) (the float (+ (-> (ja-group) frames num-frames) -1))))
            (a0-1 (-> self skel root-channel 0))
            )
        (let ((v1-14 (ja-group)))
          (set! (-> a0-1 frame-group) v1-14)
          )
        (set! (-> a0-1 param 0) 1.0)
        (set! (-> a0-1 frame-num) f0-1)
        (joint-control-channel-group! a0-1 (ja-group) num-func-loop!)
        )
      (suspend)
      )
    #f
    )
  :post plat-post
  )

;; definition for method 31 of type mtn-plat-long
;; WARN: Return type mismatch int vs none.
(defmethod init-plat-collision! ((this mtn-plat-long))
  "TODO - collision stuff for setting up the platform"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 63488.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) (the-as collide-shape-moving s5-0))
    )
  0
  (none)
  )

;; definition for method 11 of type mtn-plat-long
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this mtn-plat-long) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (init-plat-collision! this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-plat-long" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (stop-bouncing! this)
  (update-transforms (-> this root))
  (base-plat-method-32 this)
  (set! (-> this fact)
        (new 'process 'fact-info this (pickup-type eco-pill-random) (-> *FACT-bank* default-eco-pill-green-inc))
        )
  (let ((a1-5 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-13 0))
      (if (not (logtest? (-> this fact options) (actor-option loop)))
          (set! v1-13 (logior v1-13 1))
          )
      (set! (-> a1-5 sync-type) 'sync-linear)
      (set! (-> a1-5 sync-flags) (the-as sync-flags v1-13))
      )
    (set! (-> a1-5 entity) arg0)
    (set! (-> a1-5 period) (the-as uint 1200))
    (set! (-> a1-5 percent) 0.0)
    (initialize! (-> this sync) a1-5)
    )
  (go (method-of-object this idle))
  (none)
  )

;; definition of type mtn-gate
(deftype mtn-gate (process-drawable)
  ()
  (:state-methods
    idle
    open
    )
  )

;; definition for method 3 of type mtn-gate
(defmethod inspect ((this mtn-gate))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-mtn-gate mtn-gate mtn-gate-lod0-jg mtn-gate-idle-ja
              ((mtn-gate-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 4 0 18)
              )

;; failed to figure out what this is:
(defstate idle (mtn-gate)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (go-virtual open)
       )
      )
    )
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate open (mtn-gate)
  :virtual #t
  :code (behavior ()
    (until (process-grab? *target* #f)
      (suspend)
      )
    (set-setting! 'entity-name "camera-259" 0.0 0)
    (let ((gp-0 (current-time)))
      (until (time-elapsed? gp-0 (seconds 1))
        (suspend)
        )
      )
    (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (let ((gp-1 (current-time)))
      (until (time-elapsed? gp-1 (seconds 1))
        (suspend)
        )
      )
    (until (process-release? *target*)
      (suspend)
      )
    (cleanup-for-death self)
    )
  :post transform-post
  )

;; definition for method 11 of type mtn-gate
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this mtn-gate) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set-vector! (-> s3-0 local-sphere) 0.0 24576.0 -2457.6 49152.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-7 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-7 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-7 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-7 prim-core action) (collide-action solid))
      (set! (-> v1-7 transform-index) 4)
      (set-vector! (-> v1-7 local-sphere) -16384.0 16384.0 0.0 32768.0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-9 prim-core action) (collide-action solid))
      (set! (-> v1-9 transform-index) 5)
      (set-vector! (-> v1-9 local-sphere) 16384.0 16384.0 0.0 32768.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-gate" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (ja-channel-push! 1 0)
  (let ((s5-2 (-> this skel root-channel 0)))
    (joint-control-channel-group-eval!
      s5-2
      (the-as art-joint-anim (-> this draw art-group data 3))
      num-func-identity
      )
    (set! (-> s5-2 frame-num) 0.0)
    )
  (transform-post)
  (go (method-of-object this idle))
  (none)
  )

;; definition of type mtn-aval-rocks
(deftype mtn-aval-rocks (process-drawable)
  ((art-name   symbol)
   (anim       spool-anim)
   (rock-data  vector-array)
   (loop-id    sound-id)
   (volume     float)
   )
  (:state-methods
    fall
    idle
    )
  )

;; definition for method 3 of type mtn-aval-rocks
(defmethod inspect ((this mtn-aval-rocks))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tart-name: ~A~%" (-> this art-name))
  (format #t "~2Tanim: ~A~%" (-> this anim))
  (format #t "~2Trock-data: ~A~%" (-> this rock-data))
  (format #t "~2Tloop-id: ~D~%" (-> this loop-id))
  (format #t "~2Tvolume: ~f~%" (-> this volume))
  (label cfg-4)
  this
  )

;; definition for method 7 of type mtn-aval-rocks
;; WARN: Return type mismatch process-drawable vs mtn-aval-rocks.
(defmethod relocate ((this mtn-aval-rocks) (arg0 int))
  (if (nonzero? (-> this rock-data))
      (&+! (-> this rock-data) arg0)
      )
  (the-as mtn-aval-rocks ((method-of-type process-drawable relocate) this arg0))
  )

;; definition of type mtn-aval-rocks-shadow
(deftype mtn-aval-rocks-shadow (process-drawable)
  ((parent-ptr    (pointer mtn-aval-rocks)  :overlay-at parent)
   (parent-joint  int32)
   (update-time   time-frame)
   )
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type mtn-aval-rocks-shadow
(defmethod inspect ((this mtn-aval-rocks-shadow))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tparent-joint: ~D~%" (-> this parent-joint))
  (format #t "~2Tupdate-time: ~D~%" (-> this update-time))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-mtn-aval-rocks-1 mtn-aval-rocks mtn-aval-rocks-1-lod0-jg mtn-aval-rocks-1-idle-ja
              ((mtn-aval-rocks-1-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 -100 140)
              )

;; failed to figure out what this is:
(defskelgroup skel-mtn-aval-rocks-shadow mtn-aval-rocks mtn-aval-rocks-shadow-lod0-jg mtn-aval-rocks-shadow-idle-ja
              ((mtn-aval-rocks-shadow-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -1.5 0 2)
              :shadow mtn-aval-rocks-shadow-shadow-mg
              )

;; definition for symbol *mtn-aval-rocks-shadow-control*, type shadow-control
(define *mtn-aval-rocks-shadow-control*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :flags (shadow-flags disable-fade)
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 245760.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 40960.0)
                                           :top-plane (new 'static 'plane :y 1.0)
                                           :fade-dist 409600.0
                                           )
                               )
  )

;; failed to figure out what this is:
(defstate idle (mtn-aval-rocks-shadow)
  :virtual #t
  :code sleep-code
  :post (behavior ()
    (let ((s5-0 (-> (the-as process-drawable (-> self parent-ptr 0)) node-list data (-> self parent-joint)))
          (gp-0 (-> self draw shadow-ctrl))
          )
      (vector<-cspace! (-> self root trans) s5-0)
      (let ((f0-1 (* 0.5 (-> s5-0 bone scale y))))
        (set-vector! (-> self root scale) f0-1 f0-1 f0-1 1.0)
        )
      (cond
        ((< (vector-vector-distance (math-camera-pos) (-> self root trans)) (-> gp-0 settings fade-dist))
         (let ((s5-2 (new 'stack-no-clear 'collide-query)))
           (set! (-> s5-2 start-pos quad) (-> self root trans quad))
           (+! (-> s5-2 start-pos z) -8192.0)
           (set-vector! (-> s5-2 move-dist) 0.0 -81920.0 0.0 1.0)
           (let ((v1-13 s5-2))
             (set! (-> v1-13 radius) 819.2)
             (set! (-> v1-13 collide-with) (collide-spec backgnd))
             (set! (-> v1-13 ignore-process0) self)
             (set! (-> v1-13 ignore-process1) #f)
             (set! (-> v1-13 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
             (set! (-> v1-13 action-mask) (collide-action solid))
             )
           (cond
             ((>= (fill-and-probe-using-line-sphere *collide-cache* s5-2) 0.0)
              (let ((v1-16 gp-0))
                (logclear! (-> v1-16 settings flags) (shadow-flags disable-draw))
                )
              0
              (set! (-> gp-0 settings bot-plane w)
                    (- (- (+ (- 4096.0 (-> s5-2 best-other-tri intersect y)) (-> self root trans y))))
                    )
              0
              )
             (else
               (let ((v1-21 gp-0))
                 (logior! (-> v1-21 settings flags) (shadow-flags disable-draw))
                 )
               0
               )
             )
           )
         )
        (else
          (let ((v1-23 gp-0))
            (logior! (-> v1-23 settings flags) (shadow-flags disable-draw))
            )
          0
          )
        )
      )
    (ja-post)
    )
  )

;; definition for function mtn-aval-rocks-shadow-init-by-other
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defbehavior mtn-aval-rocks-shadow-init-by-other mtn-aval-rocks-shadow ((arg0 int))
  (stack-size-set! (-> self main-thread) 128)
  (logclear! (-> self mask) (process-mask actor-pause movie enemy platform projectile))
  (set! (-> self parent-joint) arg0)
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> self parent-ptr 0 root trans quad))
  (quaternion-identity! (-> self root quat))
  (vector-identity! (-> self root scale))
  (initialize-skeleton
    self
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-mtn-aval-rocks-shadow" (the-as (pointer uint32) #f))
      )
    (the-as pair 0)
    )
  (set! (-> self draw shadow-ctrl) (copy *mtn-aval-rocks-shadow-control* 'process))
  (go-virtual idle)
  (none)
  )

;; failed to figure out what this is:
(defpartgroup group-aval-rock-hit
  :id 352
  :duration (seconds 0.017)
  :linger-duration (seconds 1.5)
  :bounds (static-bspherem 0 0 0 2)
  :parts ((sp-item 112) (sp-item 113) (sp-item 104))
  )

;; failed to figure out what this is:
(defstate idle (mtn-aval-rocks)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('draw)
       (if (-> block param 0)
           (go-virtual fall)
           )
       )
      )
    )
  :trans (behavior ()
    (cond
      ((not *target*)
       )
      ((string= (-> *game-info* current-continue name) "mountain-aval")
       (go-virtual fall)
       )
      )
    )
  :code (behavior ()
    (ja-channel-set! 0)
    (transform-post)
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend)
    0
    )
  )

;; failed to figure out what this is:
(defstate fall (mtn-aval-rocks)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (a2-3 int))
    (case message
      (('touch 'attack)
       (let ((s3-0 (-> block param 0))
             (s4-0 0)
             )
         (when s3-0
           (let ((a0-6 ((method-of-type touching-shapes-entry prims-touching?)
                        (the-as touching-shapes-entry s3-0)
                        (the-as collide-shape (-> self root))
                        (the-as uint -1)
                        )
                       )
                 )
             (when a0-6
               (let ((a0-7 (get-touched-prim a0-6 (the-as collide-shape (-> self root)) (the-as touching-shapes-entry s3-0))))
                 (if a0-7
                     (set! s4-0 (the-as int (-> a0-7 prim-id)))
                     )
                 )
               )
             )
           )
         (let ((a1-4 (new 'stack-no-clear 'event-message-block)))
           (set! (-> a1-4 from) (process->ppointer self))
           (set! (-> a1-4 num-params) 2)
           (set! (-> a1-4 message) 'attack)
           (set! (-> a1-4 param 0) (-> block param 0))
           (let ((v1-11 (new 'static 'attack-info :mask (attack-mask shove-up id damage))))
             (set! a2-3 (cond
                          ((nonzero? s4-0)
                           (+ s4-0 10)
                           )
                          (else
                            (let ((a0-9 *game-info*))
                              (set! a2-3 (the-as int (+ (-> a0-9 attack-id) 1)))
                              (set! (-> a0-9 attack-id) (the-as uint a2-3))
                              )
                            a2-3
                            )
                          )
                   )
             (set! (-> v1-11 id) (the-as uint a2-3))
             (set! (-> v1-11 shove-up) 12288.0)
             (set! (-> v1-11 damage) 1.0)
             (set! (-> a1-4 param 1) (the-as uint v1-11))
             )
           (send-event-function proc a1-4)
           )
         )
       )
      (('draw)
       (if (not (-> block param 0))
           (go-virtual idle)
           )
       )
      )
    )
  :exit (behavior ()
    (when (= (-> *setting-control* user-current spooling) (process->ppointer self))
      (ja-abort-spooled-anim (-> self anim) (the-as art-joint-anim #f) -1)
      (ja-channel-set! 0)
      )
    (while (-> self child)
      (deactivate (-> self child 0))
      )
    (remove-process *gui-control* self (gui-channel art-load-next))
    (let ((v1-10 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-10 command) (sound-command set-param))
      (set! (-> v1-10 id) (-> self loop-id))
      (set! (-> v1-10 params volume) -4)
      (set! (-> v1-10 auto-time) 240)
      (set! (-> v1-10 auto-from) 2)
      (set! (-> v1-10 params mask) (the-as uint 17))
      (-> v1-10 id)
      )
    )
  :code (behavior ()
    (let ((gp-0 2)
          (s5-0 (+ (-> self node-list length) -1))
          )
      (while (>= s5-0 gp-0)
        (process-spawn mtn-aval-rocks-shadow gp-0 :to self)
        (+! gp-0 1)
        )
      )
    (let ((gp-1
            (add-process *gui-control* self (gui-channel art-load-next) (gui-action queue) (-> self anim name) -1.0 0)
            )
          )
      (while (!= (get-status *gui-control* gp-1) (gui-status ready))
        (suspend)
        )
      )
    (until #f
      (let ((v1-16
              (lookup-gui-connection
                *gui-control*
                self
                (gui-channel art-load-next)
                (the-as string #f)
                (new 'static 'sound-id)
                )
              )
            )
        (if v1-16
            (set! (-> v1-16 channel) (gui-channel art-load))
            )
        )
      (add-process *gui-control* self (gui-channel art-load-next) (gui-action queue) (-> self anim name) -1.0 0)
      (ja-play-spooled-anim
        (-> self anim)
        (get-art-by-name (-> self draw art-group) "idle" art-joint-anim)
        (the-as art-joint-anim #f)
        (the-as (function process-drawable symbol) false-func)
        )
      )
    #f
    )
  :post (behavior ()
    (local-vars (sv-16 vector-array) (sv-20 vector) (sv-48 float) (sv-52 symbol))
    (transform-post)
    (if (= (-> *setting-control* user-current music) 'mountain)
        (seek! (-> self volume) 0.6 (* 0.2 (seconds-per-frame)))
        (seek! (-> self volume) 1.0 (* 0.5 (seconds-per-frame)))
        )
    (sound-play-by-name
      (static-sound-name "mtn-aval-loop")
      (-> self loop-id)
      (the int (* 1024.0 (-> self volume)))
      0
      0
      (sound-group sfx)
      (-> self draw origin)
      )
    (set! sv-16 (-> self rock-data))
    (set! sv-20 (target-pos 0))
    (dotimes (gp-0 (-> self node-list length))
      (let* ((a1-3 (-> self node-list data gp-0))
             (s5-0 (vector<-cspace! (new 'stack-no-clear 'vector) a1-3))
             )
        (+! (-> s5-0 y) -4096.0)
        (set! sv-48 (* (- (-> s5-0 y) (-> sv-16 data gp-0 x)) (-> self clock frames-per-second)))
        (set! sv-52 (the-as symbol #f))
        (when (and (< (-> sv-16 data gp-0 y) -24576.0) (< (* 0.45 (-> sv-16 data gp-0 y)) sv-48))
          (set! sv-52 #t)
          (let ((f30-0 (vector-vector-distance sv-20 s5-0)))
            (when (< f30-0 204800.0)
              (let ((s4-0 (get-process *default-dead-pool* part-tracker #x4000)))
                (when s4-0
                  (let ((t9-8 (method-of-type part-tracker activate)))
                    (t9-8
                      (the-as part-tracker s4-0)
                      *entity-pool*
                      (symbol->string (-> part-tracker symbol))
                      (the-as pointer #x70004000)
                      )
                    )
                  (let ((t9-9 run-function-in-process)
                        (a0-16 s4-0)
                        (a1-7 part-tracker-init)
                        (a2-7 (-> *part-group-id-table* 352))
                        (a3-2 0)
                        (t0-1 #f)
                        (t1-1 #f)
                        (t2-1 #f)
                        (t3-0 *launch-matrix*)
                        )
                    (set! (-> t3-0 trans quad) (-> s5-0 quad))
                    ((the-as (function object object object object object object object object none) t9-9)
                     a0-16
                     a1-7
                     a2-7
                     a3-2
                     t0-1
                     t1-1
                     t2-1
                     t3-0
                     )
                    )
                  (-> s4-0 ppointer)
                  )
                )
              (when (= (-> sv-16 data gp-0 w) 0.0)
                (sound-play-by-name
                  (static-sound-name "mtn-boulder")
                  (new-sound-id)
                  (the int
                       (* 1024.0 (* (lerp-scale 0.3 1.0 (fabs (- (-> sv-16 data gp-0 y) sv-48)) 0.0 40960.0) (-> self volume)))
                       )
                  0
                  0
                  (sound-group sfx)
                  s5-0
                  )
                (set! (-> sv-16 data gp-0 w) 20.0)
                )
              )
            (when (< f30-0 122880.0)
              (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 (the int (* 255.0 (- 1.0 (* 0.000008138021 f30-0)))) (seconds 0.2))
              (activate!
                *camera-smush-control*
                (lerp-scale 1638.4 0.0 f30-0 0.0 122880.0)
                15
                75
                1.0
                0.9
                (-> *display* camera-clock)
                )
              )
            )
          )
        (set! (-> sv-16 data gp-0 y) sv-48)
        (set! (-> sv-16 data gp-0 x) (-> s5-0 y))
        )
      (seek! (-> sv-16 data gp-0 w) 0.0 1.0)
      )
    )
  )

;; definition for method 11 of type mtn-aval-rocks
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this mtn-aval-rocks) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (sv-16 collide-shape-prim-sphere) (sv-48 collide-shape-prim-sphere) (sv-64 vector))
  (stack-size-set! (-> this main-thread) 512)
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 49) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 50))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 transform-index) 0)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 -409600.0 573440.0)
      (set! (-> s4-0 root-prim) s3-0)
      (pusher-init s4-0)
      (let* ((s2-0 1)
             (s1-0
               '((3 9011)
                 (4 9011)
                 (5 9011)
                 (6 9011)
                 (13 9011)
                 (14 9011)
                 (15 9011)
                 (16 9011)
                 (22 9011)
                 (23 9011)
                 (42 9011)
                 (26 9011)
                 (27 9011)
                 (35 9011)
                 (36 9011)
                 (37 9011)
                 (45 9011)
                 (46 9011)
                 (47 9011)
                 (48 9011)
                 (7 6144)
                 (8 6144)
                 (9 6144)
                 (10 6144)
                 (17 6144)
                 (18 6144)
                 (49 6144)
                 (19 6144)
                 (20 6144)
                 (21 6144)
                 (11 6144)
                 (12 6144)
                 (24 3686)
                 (25 3686)
                 (32 3686)
                 (33 3686)
                 (34 3686)
                 (43 3686)
                 (44 3686)
                 (50 3686)
                 (38 3686)
                 (38 3686)
                 (40 3686)
                 (39 3686)
                 (41 3686)
                 (28 3686)
                 (29 3686)
                 (30 3686)
                 (31 3686)
                 )
               )
             (s0-0 (car s1-0))
             )
        (while (not (null? s1-0))
          (set! sv-16 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0)))
          (set! sv-48 sv-16)
          (set! (-> sv-48 prim-core collide-as) (-> s3-0 prim-core collide-as))
          (set! (-> sv-48 prim-core collide-with) (-> s3-0 prim-core collide-with))
          (set! (-> sv-48 prim-core action) (-> s3-0 prim-core action))
          (set! (-> sv-48 transform-index) (command-get-int (car s0-0) 0))
          (set! (-> sv-48 prim-id) (the-as uint s2-0))
          (+! s2-0 1)
          (set! sv-64 (-> sv-16 local-sphere))
          (set! (-> sv-64 x) 0.0)
          (set! (-> sv-64 y) 0.0)
          (set! (-> sv-64 z) 0.0)
          (set! (-> sv-64 w) (command-get-float (car (cdr s0-0)) 0.0))
          (set! s1-0 (cdr s1-0))
          (set! s0-0 (car s1-0))
          )
        )
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-27 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-27 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-27 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (quaternion-rotate-y! (-> this root quat) (-> this root quat) 32768.0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-aval-rocks-1" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (logior! (-> this skel status) (joint-control-status sync-math))
  (set! (-> this art-name) (the-as symbol "mtn-aval-rocks-1"))
  (set! (-> this anim)
        (new 'static 'spool-anim :name "mtn-aval-rocks-1" :anim-name "1-fall" :parts 8 :command-list '())
        )
  (set! (-> this loop-id) (new-sound-id))
  (set! (-> this rock-data) (new 'process 'vector-array (-> this node-list length)))
  (dotimes (v1-42 (-> this node-list length))
    (let* ((a0-21 *game-info*)
           (a1-13 (the-as number (+ (-> a0-21 attack-id) 1)))
           )
      (set! (-> a0-21 attack-id) (the-as uint a1-13))
      (set! (-> this rock-data data v1-42 z) (the-as float a1-13))
      )
    (set! (-> this rock-data data v1-42 w) 0.0)
    )
  (let ((a2-7
          (matrix<-transformq! (-> this node-list data 0 bone transform) (the-as transformq (-> this root trans)))
          )
        (a1-17 (new 'stack-no-clear 'vector))
        )
    (set! (-> a1-17 quad) (-> this draw bounds quad))
    (set! (-> a1-17 w) 1.0)
    (vector-matrix*! (-> this draw origin) a1-17 a2-7)
    )
  (set! (-> this draw origin w) (-> this draw bounds w))
  (go (method-of-object this idle))
  (none)
  )

;; definition of type mtn-plat-return
(deftype mtn-plat-return (base-plat)
  ((ride-timer  time-frame)
   (flags       mtn-plat-flags)
   (path-pos    float)
   (dest-pos    float)
   (path-speed  float)
   )
  (:state-methods
    waiting
    running
    waiting-for-no-player
    )
  (:methods
    (mtn-plat-return-method-37 (_type_) none)
    )
  )

;; definition for method 3 of type mtn-plat-return
(defmethod inspect ((this mtn-plat-return))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type base-plat inspect)))
    (t9-0 this)
    )
  (format #t "~2Tride-timer: ~D~%" (-> this ride-timer))
  (format #t "~2Tflags: ~D~%" (-> this flags))
  (format #t "~2Tpath-pos: ~f~%" (-> this path-pos))
  (format #t "~2Tdest-pos: ~f~%" (-> this dest-pos))
  (format #t "~2Tpath-speed: ~f~%" (-> this path-speed))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-mtn-plat-return mtn-plat-return mtn-plat-return-lod0-jg mtn-plat-return-idle-ja
              ((mtn-plat-return-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4.8)
              )

;; failed to figure out what this is:
(defstate waiting (mtn-plat-return)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('ridden)
       (let ((v0-0 (the-as object (logior (-> self flags) (mtn-plat-flags mtpflags-0)))))
         (set! (-> self flags) (the-as mtn-plat-flags v0-0))
         v0-0
         )
       )
      (else
        (plat-event proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set-time! (-> self ride-timer))
    (get-point-at-percent-along-path! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
    )
  :trans (behavior ()
    (logclear! (-> self flags) (mtn-plat-flags mtpflags-0))
    (plat-trans)
    (if (not (logtest? (-> self flags) (mtn-plat-flags mtpflags-0)))
        (set-time! (-> self ride-timer))
        )
    (let ((v1-10 (and (time-elapsed? (-> self ride-timer) (seconds 0.5))
                      (logtest? (-> self flags) (mtn-plat-flags mtpflags-0))
                      (if (logtest? (-> self flags) (mtn-plat-flags mtpflags-1))
                          (and *target* (process-grab? *target* #f))
                          #t
                          )
                      )
                 )
          )
      (when v1-10
        (if (= (-> self path-pos) 0.0)
            (set! (-> self dest-pos) 1.0)
            (set! (-> self dest-pos) 0.0)
            )
        (go-virtual running)
        )
      )
    )
  :code sleep-code
  :post plat-post
  )

;; failed to figure out what this is:
(defstate running (mtn-plat-return)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('ridden)
       (let ((v0-0 (the-as object (logior (-> self flags) (mtn-plat-flags mtpflags-0)))))
         (set! (-> self flags) (the-as mtn-plat-flags v0-0))
         v0-0
         )
       )
      (else
        (plat-event proc argc message block)
        )
      )
    )
  :trans (behavior ()
    (if (= (-> self path-pos) (-> self dest-pos))
        (go-virtual waiting-for-no-player)
        )
    (plat-trans)
    )
  :code sleep-code
  :post (behavior ()
    (seek! (-> self path-pos) (-> self dest-pos) (* (-> self path-speed) (seconds-per-frame)))
    (get-point-at-percent-along-path!
      (-> self path)
      (-> self basetrans)
      (ease-value-in-out (-> self path-pos) 0.1)
      'interp
      )
    (plat-post)
    )
  )

;; failed to figure out what this is:
(defstate waiting-for-no-player (mtn-plat-return)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('ridden)
       (let ((v0-0 (the-as object (current-time))))
         (set! (-> self ride-timer) (the-as time-frame v0-0))
         v0-0
         )
       )
      (else
        (plat-event proc argc message block)
        )
      )
    )
  :trans (behavior ()
    (plat-trans)
    (when (time-elapsed? (-> self ride-timer) (seconds 1))
      (cond
        ((= (-> self path-pos) 1.0)
         (set! (-> self dest-pos) 0.0)
         (go-virtual running)
         )
        (else
          (go-virtual waiting)
          )
        )
      )
    )
  :code sleep-code
  :post plat-post
  )

;; definition for method 37 of type mtn-plat-return
;; WARN: Return type mismatch object vs none.
(defmethod mtn-plat-return-method-37 ((this mtn-plat-return))
  (go (method-of-object this waiting))
  (none)
  )

;; definition for method 31 of type mtn-plat-return
;; WARN: Return type mismatch int vs none.
(defmethod init-plat-collision! ((this mtn-plat-return))
  "TODO - collision stuff for setting up the platform"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 19660.8)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-11 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-11 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-11 prim-core collide-with))
      )
    (set! (-> this root) (the-as collide-shape-moving s5-0))
    )
  0
  (none)
  )

;; definition for method 11 of type mtn-plat-return
(defmethod init-from-entity! ((this mtn-plat-return) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (init-plat-collision! this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-plat-return" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (stop-bouncing! this)
  (set! (-> this flags) (mtn-plat-flags))
  (set! (-> this path-pos) 0.0)
  (set! (-> this path) (new 'process 'curve-control this 'path -1000000000.0))
  (if (logtest? (-> this path flags) (path-control-flag not-found))
      (go process-drawable-art-error "error in path")
      )
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (let ((f30-0 (total-distance (-> this path))))
    (set! (-> this path-speed) (/ (res-lump-float arg0 'speed :default 40960.0) f30-0))
    (set! (-> this root pause-adjust-distance) (+ 204800.0 f30-0))
    )
  (set! (-> this sound)
        (new 'process 'ambient-sound (static-sound-spec "mtn-plat-lp" :fo-max 70) (-> this root trans))
        )
  (init-plat! this)
  (mtn-plat-return-method-37 this)
  (none)
  )

;; definition of type mtn-plat-gap
(deftype mtn-plat-gap (mtn-plat-return)
  ()
  )

;; definition for method 3 of type mtn-plat-gap
(defmethod inspect ((this mtn-plat-gap))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type mtn-plat-return inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defstate running (mtn-plat-gap)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (plat-event proc argc message block)
    )
  :trans (behavior ()
    (plat-trans)
    )
  :code sleep-code
  :post (behavior ()
    (seek! (-> self path-pos) (-> self dest-pos) (* (-> self path-speed) (seconds-per-frame)))
    (get-point-at-percent-along-path!
      (-> self path)
      (-> self basetrans)
      (ease-value-in-out (-> self path-pos) 0.1)
      'interp
      )
    (plat-post)
    )
  )

;; failed to figure out what this is:
(defstate waiting (mtn-plat-gap)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (set! (-> self dest-pos) 0.0)
       (go-virtual running)
       )
      (else
        (plat-event proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self path-pos) 1.0)
    (get-point-at-percent-along-path! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
    )
  :trans (behavior ()
    (plat-trans)
    )
  :code sleep-code
  :post plat-post
  )

;; definition of type mtn-button
(deftype mtn-button (process-drawable)
  ((on-activate  symbol)
   )
  (:state-methods
    idle
    open
    waiting
    (pressed symbol)
    )
  )

;; definition for method 3 of type mtn-button
(defmethod inspect ((this mtn-button))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Ton-activate: ~A~%" (-> this on-activate))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-mtn-button mtn-button mtn-button-lod0-jg mtn-button-open-ja
              ((mtn-button-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

;; failed to figure out what this is:
(defstate idle (mtn-button)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (go-virtual open)
       )
      )
    )
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate open (mtn-button)
  :virtual #t
  :trans rider-trans
  :code (behavior ()
    (ja-no-eval :group! mtn-button-open-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go-virtual waiting)
    )
  :post rider-post
  )

;; failed to figure out what this is:
(defstate waiting (mtn-button)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('bonk)
       (go-virtual pressed #f)
       )
      )
    )
  :enter (behavior ()
    (ja-no-eval :group! mtn-button-press-ja :num! (seek!) :frame-num 0.0)
    (transform-post)
    )
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate pressed (mtn-button)
  :virtual #t
  :code (behavior ((arg0 symbol))
    (when (not arg0)
      (let ((gp-0 (-> self on-activate)))
        (if gp-0
            (script-eval (the-as pair gp-0) :vector (-> self root trans))
            )
        )
      (ja-no-eval :group! mtn-button-press-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (transform-post)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (ja :group! mtn-button-press-ja :num! max)
    (transform-post)
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (sleep-code)
    )
  )

;; definition for method 11 of type mtn-button
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this mtn-button) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable pull-rider-can-collide))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 122880.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid rideable))
      (set! (-> v1-10 transform-index) 3)
      (set-vector! (-> v1-10 local-sphere) 0.0 0.0 0.0 12288.0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-12 prim-core action) (collide-action solid rideable))
      (set! (-> v1-12 transform-index) 4)
      (set-vector! (-> v1-12 local-sphere) 0.0 0.0 0.0 10240.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-15 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-15 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-15 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-button" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this on-activate) (res-lump-struct (-> this entity) 'on-activate symbol))
  (let ((a0-22 (-> this skel root-channel 0)))
    (set! (-> a0-22 frame-group) (the-as art-joint-anim (-> this draw art-group data 2)))
    (set! (-> a0-22 param 0) 1.0)
    (set! (-> a0-22 frame-num) 0.0)
    (joint-control-channel-group! a0-22 (the-as art-joint-anim (-> this draw art-group data 2)) num-func-loop!)
    )
  (transform-post)
  (if (and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete)))
      (go (method-of-object this pressed) #t)
      (go (method-of-object this idle))
      )
  (none)
  )

;; definition of type mtn-gear-device
(deftype mtn-gear-device (process-drawable)
  ()
  (:state-methods
    idle
    idle-collapsed
    )
  )

;; definition for method 3 of type mtn-gear-device
(defmethod inspect ((this mtn-gear-device))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-mtn-gear-device mtn-gear-device mtn-gear-device-lod0-jg mtn-gear-device-idle-ja
              ((mtn-gear-device-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 9 0 16)
              :origin-joint-index 3
              )

;; failed to figure out what this is:
(defskelgroup skel-mtn-gear-device-collapse mtn-gear-device mtn-gear-device-collapse-lod0-jg mtn-gear-device-collapse-idle-ja
              ((mtn-gear-device-collapse-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 9 0 40)
              :origin-joint-index 33
              )

;; failed to figure out what this is:
(defstate idle (mtn-gear-device)
  :virtual #t
  :code (behavior ()
    (add-process *gui-control* self (gui-channel art-load) (gui-action queue) "mountain-gear-res" -99.0 0)
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (update! (-> self sound))
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post ja-post
  )

;; failed to figure out what this is:
(defstate idle-collapsed (mtn-gear-device)
  :virtual #t
  :code transform-and-sleep-code
  )

;; definition for method 11 of type mtn-gear-device
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this mtn-gear-device) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (cond
    ((task-complete? *game-info* (game-task mountain-gear))
     (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
       (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 9) 0)))
         (set! (-> s4-0 total-prims) (the-as uint 10))
         (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
         (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> s3-0 prim-core action) (collide-action solid))
         (set! (-> s3-0 transform-index) 0)
         (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 73728.0)
         (set! (-> s4-0 root-prim) s3-0)
         )
       (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
         (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-10 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-10 prim-core action) (collide-action solid))
         (set! (-> v1-10 transform-index) 7)
         (set-vector! (-> v1-10 local-sphere) 0.0 0.0 0.0 2048.0)
         )
       (let ((v1-12 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
         (set! (-> v1-12 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-12 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-12 prim-core action) (collide-action solid))
         (set! (-> v1-12 transform-index) 8)
         (set-vector! (-> v1-12 local-sphere) 0.0 0.0 0.0 2048.0)
         )
       (let ((v1-14 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 2) (the-as uint 0))))
         (set! (-> v1-14 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-14 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-14 prim-core action) (collide-action solid))
         (set! (-> v1-14 transform-index) 9)
         (set-vector! (-> v1-14 local-sphere) 0.0 0.0 0.0 2048.0)
         )
       (let ((v1-16 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 3) (the-as uint 0))))
         (set! (-> v1-16 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-16 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-16 prim-core action) (collide-action solid))
         (set! (-> v1-16 transform-index) 12)
         (set-vector! (-> v1-16 local-sphere) 2048.0 0.0 0.0 10240.0)
         )
       (let ((v1-18 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 4) (the-as uint 0))))
         (set! (-> v1-18 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-18 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-18 prim-core action) (collide-action solid))
         (set! (-> v1-18 transform-index) 23)
         (set-vector! (-> v1-18 local-sphere) 0.0 0.0 -8192.0 45056.0)
         )
       (let ((v1-20 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 5) (the-as uint 0))))
         (set! (-> v1-20 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-20 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-20 prim-core action) (collide-action solid))
         (set! (-> v1-20 transform-index) 24)
         (set-vector! (-> v1-20 local-sphere) 0.0 -4096.0 0.0 16384.0)
         )
       (let ((v1-22 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 6) (the-as uint 0))))
         (set! (-> v1-22 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-22 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-22 prim-core action) (collide-action solid))
         (set! (-> v1-22 transform-index) 25)
         (set-vector! (-> v1-22 local-sphere) 0.0 -4096.0 0.0 16384.0)
         )
       (let ((v1-24 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 7) (the-as uint 0))))
         (set! (-> v1-24 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-24 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-24 prim-core action) (collide-action solid))
         (set! (-> v1-24 transform-index) 34)
         (set-vector! (-> v1-24 local-sphere) 0.0 0.0 0.0 13312.0)
         )
       (let ((v1-26 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 8) (the-as uint 0))))
         (set! (-> v1-26 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-26 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-26 prim-core action) (collide-action solid))
         (set! (-> v1-26 transform-index) 38)
         (set-vector! (-> v1-26 local-sphere) 0.0 0.0 0.0 22528.0)
         )
       (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
       (let ((v1-29 (-> s4-0 root-prim)))
         (set! (-> s4-0 backup-collide-as) (-> v1-29 prim-core collide-as))
         (set! (-> s4-0 backup-collide-with) (-> v1-29 prim-core collide-with))
         )
       (set! (-> this root) s4-0)
       )
     (process-drawable-from-entity! this arg0)
     (initialize-skeleton
       this
       (the-as
         skeleton-group
         (art-group-get-by-name *level* "skel-mtn-gear-device-collapse" (the-as (pointer uint32) #f))
         )
       (the-as pair 0)
       )
     (go (method-of-object this idle-collapsed))
     )
    (else
      (let ((s4-2 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
        (let ((v1-38 (new 'process 'collide-shape-prim-sphere s4-2 (the-as uint 0))))
          (set! (-> v1-38 prim-core collide-as) (collide-spec obstacle))
          (set! (-> v1-38 prim-core collide-with) (collide-spec jak bot player-list))
          (set! (-> v1-38 prim-core action) (collide-action solid))
          (set! (-> v1-38 transform-index) 0)
          (set-vector! (-> v1-38 local-sphere) 0.0 36864.0 0.0 65536.0)
          (set! (-> s4-2 total-prims) (the-as uint 1))
          (set! (-> s4-2 root-prim) v1-38)
          )
        (set! (-> s4-2 nav-radius) (* 0.75 (-> s4-2 root-prim local-sphere w)))
        (let ((v1-41 (-> s4-2 root-prim)))
          (set! (-> s4-2 backup-collide-as) (-> v1-41 prim-core collide-as))
          (set! (-> s4-2 backup-collide-with) (-> v1-41 prim-core collide-with))
          )
        (set! (-> this root) s4-2)
        )
      (process-drawable-from-entity! this arg0)
      (initialize-skeleton
        this
        (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-gear-device" (the-as (pointer uint32) #f)))
        (the-as pair 0)
        )
      (set! (-> this root pause-adjust-distance) 450560.0)
      (add-connection *part-engine* this 24 this 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* this 25 this 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* this 21 this 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* this 22 this 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* this 14 this 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* this 13 this 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* this 15 this 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* this 16 this 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* this 17 this 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* this 18 this 1492 (new 'static 'vector :w 163840.0))
      (set! (-> this sound)
            (new 'process 'ambient-sound (static-sound-spec "mtn-gear-device" :fo-max 90) (-> this root trans))
            )
      (go (method-of-object this idle))
      )
    )
  (none)
  )

;; definition of type water-anim-mountain
(deftype water-anim-mountain (water-anim)
  ()
  )

;; definition for method 3 of type water-anim-mountain
(defmethod inspect ((this water-anim-mountain))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type water-anim inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for symbol ripple-for-water-anim-mountain, type ripple-wave-set
(define ripple-for-water-anim-mountain (new 'static 'ripple-wave-set
                                         :count 3
                                         :converted #f
                                         :normal-scale 1.0
                                         :wave (new 'static 'inline-array ripple-wave 4
                                           (new 'static 'ripple-wave :scale 40.0 :xdiv 1 :speed 1.5)
                                           (new 'static 'ripple-wave :scale 40.0 :xdiv -1 :zdiv 1 :speed 1.5)
                                           (new 'static 'ripple-wave :scale 20.0 :xdiv 5 :zdiv 3 :speed 0.75)
                                           (new 'static 'ripple-wave)
                                           )
                                         )
        )

;; definition for method 24 of type water-anim-mountain
;; WARN: Return type mismatch int vs none.
(defmethod init-water! ((this water-anim-mountain))
  "Initialize a [[water-anim]]'s default settings, this may include applying a [[riple-control]]"
  (let ((t9-0 (method-of-type water-anim init-water!)))
    (t9-0 this)
    )
  (let ((v1-2 (new 'process 'ripple-control)))
    (set! (-> this draw ripple) v1-2)
    (set-vector! (-> this draw color-mult) 0.01 0.45 0.5 0.75)
    (set! (-> v1-2 global-scale) 3072.0)
    (set! (-> v1-2 close-fade-dist) 163840.0)
    (set! (-> v1-2 far-fade-dist) 245760.0)
    (set! (-> v1-2 waveform) ripple-for-water-anim-mountain)
    )
  0
  (none)
  )

;; definition of type trans-plat
(deftype trans-plat (mtn-plat-return)
  ()
  (:state-methods
    rising
    )
  )

;; definition for method 3 of type trans-plat
(defmethod inspect ((this trans-plat))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type mtn-plat-return inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defstate rising (trans-plat)
  :virtual #t
  :event plat-event
  :code (behavior ()
    (get-point-at-percent-along-path! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
    (let ((f30-0 (-> self basetrans y))
          (f28-0 24576.0)
          )
      (while (< 0.0 f28-0)
        (set! (-> self basetrans y) (- f30-0 f28-0))
        (plat-trans)
        (set! f28-0 (seek-ease f28-0 0.0 (* 40960.0 (seconds-per-frame)) 2048.0 (* 4096.0 (seconds-per-frame))))
        (suspend)
        )
      )
    (go-virtual waiting)
    )
  :post plat-post
  )

;; failed to figure out what this is:
(defstate waiting (trans-plat)
  :virtual #t
  :enter (behavior ()
    (when (not (or (not (task-node-closed? (game-task-node forest-scouts-introduction)))
                   (task-node-closed? (game-task-node forest-scouts-pegasus))
                   (!= (-> self path-pos) 0.0)
                   )
               )
      (let ((gp-0 (new 'stack-no-clear 'task-arrow-params)))
        (set! (-> gp-0 pos quad) (-> self root trans quad))
        (quaternion-identity! (-> gp-0 quat))
        (set! (-> gp-0 flags) (task-arrow-flags))
        (set! (-> gp-0 map-icon) (the-as uint 15))
        (task-arrow-spawn gp-0 self)
        )
      )
    (let ((t9-5 (-> (the-as state (find-parent-state)) enter)))
      (if t9-5
          ((the-as (function none) t9-5))
          )
      )
    )
  :exit (behavior ()
    (while (-> self child)
      (deactivate (-> self child 0))
      )
    (let ((t9-2 (-> (the-as state (find-parent-state)) exit)))
      (if t9-2
          (t9-2)
          )
      )
    )
  :trans (behavior ()
    (cond
      ((task-node-closed? (game-task-node forest-scouts-introduction))
       (logclear! (-> self draw status) (draw-control-status no-draw))
       (let ((v1-3 (-> self root root-prim)))
         (set! (-> v1-3 prim-core collide-as) (-> self root backup-collide-as))
         (set! (-> v1-3 prim-core collide-with) (-> self root backup-collide-with))
         )
       )
      (else
        (logior! (-> self draw status) (draw-control-status no-draw))
        (let ((v1-8 (-> self root root-prim)))
          (set! (-> v1-8 prim-core collide-as) (collide-spec))
          (set! (-> v1-8 prim-core collide-with) (collide-spec))
          )
        0
        )
      )
    (let ((t9-2 (-> (the-as state (find-parent-state)) trans)))
      (if t9-2
          (t9-2)
          )
      )
    )
  )

;; failed to figure out what this is:
(defstate running (trans-plat)
  :virtual #t
  :exit (behavior ()
    (let ((t9-0 (-> (method-of-type mtn-plat-return running) exit)))
      (if t9-0
          (t9-0)
          )
      )
    (if (logtest? (-> self flags) (mtn-plat-flags mtpflags-0))
        (process-release? *target*)
        )
    )
  )

;; failed to figure out what this is:
(defstate waiting-for-no-player (trans-plat)
  :virtual #t
  :trans (behavior ()
    (plat-trans)
    (if (time-elapsed? (-> self ride-timer) (seconds 1))
        (go-virtual waiting)
        )
    )
  )

;; definition for method 37 of type trans-plat
;; WARN: Return type mismatch object vs none.
(defmethod mtn-plat-return-method-37 ((this trans-plat))
  (go (method-of-object this rising))
  (none)
  )

;; definition for method 33 of type trans-plat
;; WARN: Return type mismatch float vs none.
(defmethod init-plat! ((this trans-plat))
  "Does any necessary initial platform setup.
For example for an elevator pre-compute the distance between the first and last points (both ways) and clear the sound."
  (logior! (-> this flags) (mtn-plat-flags mtpflags-1))
  (let* ((s5-0 *target*)
         (a0-2 (if (type? s5-0 process-focusable)
                   s5-0
                   )
               )
         )
    (when a0-2
      (let ((s4-0 (get-trans a0-2 0))
            (s3-0 (-> this path))
            (f28-0 0.0)
            (f30-0 -1.0)
            (s5-1 (-> this path curve num-cverts))
            )
        (dotimes (s2-0 s5-1)
          (let ((f0-2
                  (vector-vector-distance s4-0 (get-point-in-path! s3-0 (new 'stack-no-clear 'vector) (the float s2-0) 'interp))
                  )
                )
            (when (or (= f30-0 -1.0) (< f0-2 f28-0))
              (set! f28-0 f0-2)
              (set! f30-0 (the float s2-0))
              )
            )
          )
        (if (!= f30-0 -1.0)
            (set! (-> this path-pos) (/ f30-0 (+ -1.0 (the float s5-1))))
            )
        )
      )
    )
  (none)
  )
