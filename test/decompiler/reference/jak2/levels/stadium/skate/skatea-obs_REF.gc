;;-*-Lisp-*-
(in-package goal)

;; definition of type hoverboard-training-manager
(deftype hoverboard-training-manager (process)
  ((actor-group        (pointer actor-group))
   (actor-group-count  int32)
   (trick-type         board-tricks)
   (board-picked-up    symbol)
   (boost              symbol)
   (grind              symbol)
   (text               symbol)
   (score              float)
   (challenge-done     symbol)
   (arrow              handle)
   (minimap            connection-minimap)
   (hud-score          handle)
   (hud-goal           handle)
   (voicebox           handle)
   (last-sound-id      sound-id)
   (combo-done?        symbol)
   (task-gold          uint16)
   (task-silver        uint16)
   (task-bronze        uint16)
   (game-score         uint8)
   (training?          symbol)
   (training-goal      float)
   (egg-count          int32)
   (medal              int32)
   (gui-id             sound-id)
   (hint-time          time-frame)
   )
  (:state-methods
    wait-for-pickup
    wait-for-pickup-training
    wait-for-board
    wait
    jump
    duck-jump
    boost-jump
    grind
    spin
    flip
    trick
    game
    idle
    idle-training
    )
  (:methods
    (render-text (_type_ text-id) float)
    (hoverboard-training-manager-method-29 (_type_) none)
    (hoverboard-training-manager-method-30 (_type_) none)
    )
  )

;; definition for method 3 of type hoverboard-training-manager
(defmethod inspect ((this hoverboard-training-manager))
  (when (not this)
    (set! this this)
    (goto cfg-7)
    )
  (let ((t9-0 (method-of-type process inspect)))
    (t9-0 this)
    )
  (format #t "~2Tactor-group: #x~X~%" (-> this actor-group))
  (dotimes (s5-0 (-> this actor-group-count))
    (format #t "~T  [~D]~2Tactor-group: ~`actor-group`P~%" s5-0 (-> this actor-group s5-0))
    )
  (format #t "~2Tactor-group-count: ~D~%" (-> this actor-group-count))
  (format #t "~2Ttrick-type: ~D~%" (-> this trick-type))
  (format #t "~2Tboard-picked-up: ~A~%" (-> this board-picked-up))
  (format #t "~2Tboost: ~A~%" (-> this boost))
  (format #t "~2Tgrind: ~A~%" (-> this grind))
  (format #t "~2Ttext: ~A~%" (-> this text))
  (format #t "~2Tscore: ~f~%" (-> this score))
  (format #t "~2Tchallenge-done: ~A~%" (-> this challenge-done))
  (format #t "~2Tarrow: ~D~%" (-> this arrow))
  (format #t "~2Tminimap: #<connection-minimap @ #x~X>~%" (-> this minimap))
  (format #t "~2Thud-score: ~D~%" (-> this hud-score))
  (format #t "~2Thud-goal: ~D~%" (-> this hud-goal))
  (format #t "~2Tvoicebox: ~D~%" (-> this voicebox))
  (format #t "~2Tlast-sound-id: ~D~%" (-> this last-sound-id))
  (format #t "~2Tcombo-done?: ~A~%" (-> this combo-done?))
  (format #t "~2Ttask-gold: ~D~%" (-> this task-gold))
  (format #t "~2Ttask-silver: ~D~%" (-> this task-silver))
  (format #t "~2Ttask-bronze: ~D~%" (-> this task-bronze))
  (format #t "~2Tgame-score: ~D~%" (-> this game-score))
  (format #t "~2Ttraining?: ~A~%" (-> this training?))
  (format #t "~2Ttraining-goal: ~f~%" (-> this training-goal))
  (format #t "~2Tegg-count: ~D~%" (-> this egg-count))
  (format #t "~2Tmedal: ~D~%" (-> this medal))
  (format #t "~2Tgui-id: ~D~%" (-> this gui-id))
  (format #t "~2Thint-time: ~D~%" (-> this hint-time))
  (label cfg-7)
  this
  )

;; definition for method 28 of type hoverboard-training-manager
(defmethod render-text ((this hoverboard-training-manager) (arg0 text-id))
  (when (= (get-status *gui-control* (-> this gui-id)) (gui-status active))
    (let ((s5-1
            (new 'stack 'font-context *font-default-matrix* 32 280 0.0 (font-color default) (font-flags shadow kerning))
            )
          )
      (set! (-> s5-1 flags) (font-flags shadow kerning large))
      (let ((v1-4 s5-1))
        (set! (-> v1-4 width) (the float 440))
        )
      (let ((v1-5 s5-1))
        (set! (-> v1-5 height) (the float 80))
        )
      (let ((v1-6 s5-1))
        (set! (-> v1-6 scale) 0.75)
        )
      (let ((s4-0 print-game-text))
        (format (clear *temp-string*) (lookup-text! *common-text* arg0 #f))
        (s4-0 *temp-string* s5-1 #f 44 (bucket-id progress))
        )
      )
    )
  )

;; definition for function trick-type-trick?
(defun trick-type-trick? ((arg0 board-tricks))
  (or (= arg0 (board-tricks board-spin))
      (= arg0 (board-tricks board-flip))
      (= arg0 (board-tricks board-nosegrab))
      (= arg0 (board-tricks board-method))
      (= arg0 (board-tricks board-board-spin))
      (= arg0 (board-tricks board-board-flip))
      (= arg0 (board-tricks board-noseflip))
      (= arg0 (board-tricks board-kickflip))
      )
  )

;; definition for function hoverboard-training-manager-event-handler
;; WARN: Return type mismatch object vs hoverboard-training-manager.
(defbehavior hoverboard-training-manager-event-handler hoverboard-training-manager ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (v0-0 object))
  (the-as
    hoverboard-training-manager
    (case arg2
      (('notify)
       (case (-> arg3 param 0)
         (('trick-point)
          (set! v0-0 (-> arg3 param 1))
          (set! (-> self trick-type) (the-as board-tricks v0-0))
          v0-0
          )
         (('trick-judge)
          (set! (-> self score) (the-as float (-> arg3 param 1)))
          (set! v0-0 #t)
          (set! (-> self challenge-done) (the-as symbol v0-0))
          v0-0
          )
         (('pickup)
          (set! v0-0 #t)
          (set! (-> self board-picked-up) (the-as symbol v0-0))
          v0-0
          )
         (('trick-flush)
          (the-as float (-> arg3 param 1))
          (let ((gp-0 (the-as object (-> arg3 param 2)))
                (s5-0 (-> arg3 param 3))
                )
            (dotimes (s4-0 (the-as int (+ s5-0 -2)))
              (cond
                ((= (-> (the-as (pointer board-tricks) gp-0) s4-0) (board-tricks board-rail-jump))
                 (if (and (trick-type-trick? (-> (the-as (pointer board-tricks) gp-0) (+ s4-0 1)))
                          (= (-> (the-as (pointer board-tricks) gp-0) (+ s4-0 2)) (board-tricks board-rail-jump))
                          )
                     (set! (-> self combo-done?) #t)
                     )
                 )
                ((trick-type-trick? (-> (the-as (pointer board-tricks) gp-0) s4-0))
                 (if (and (= (-> (the-as (pointer board-tricks) gp-0) (+ s4-0 1)) (board-tricks board-rail-jump))
                          (trick-type-trick? (-> (the-as (pointer board-tricks) gp-0) (+ s4-0 2)))
                          )
                     (set! (-> self combo-done?) #t)
                     )
                 )
                )
              )
            )
          #f
          )
         )
       )
      (('boost)
       (set! v0-0 #t)
       (set! (-> self boost) (the-as symbol v0-0))
       v0-0
       )
      (('grind)
       (set! v0-0 #t)
       (set! (-> self grind) (the-as symbol v0-0))
       v0-0
       )
      (('text-on)
       (set! v0-0 #t)
       (set! (-> self text) (the-as symbol v0-0))
       v0-0
       )
      (('text-off)
       (set! (-> self text) #f)
       #f
       )
      )
    )
  )

;; failed to figure out what this is:
(defstate wait-for-pickup (hoverboard-training-manager)
  :virtual #t
  :event hoverboard-training-manager-event-handler
  :enter (behavior ()
    (set! (-> self board-picked-up) #f)
    (cond
      ((task-node-closed? (game-task-node forest-scouts-get-board))
       (set! (-> self board-picked-up) #t)
       )
      (else
        (let ((v1-0 (birth-pickup-at-point
                      (new 'static 'vector :x 505282.56 :y -38912.0 :z -2533785.5 :w 1.0)
                      (pickup-type board)
                      1.0
                      #t
                      self
                      (the-as fact-info #f)
                      )
                    )
              )
          (send-event (ppointer->process v1-0) 'get-notify #t)
          )
        (let ((gp-0 (new 'stack-no-clear 'task-arrow-params)))
          (set! (-> gp-0 pos quad) (-> (new 'static 'vector :x 505282.56 :y -38912.0 :z -2533785.5 :w 1.0) quad))
          (quaternion-identity! (-> gp-0 quat))
          (set! (-> gp-0 flags) (task-arrow-flags))
          (set! (-> gp-0 map-icon) (the-as uint 15))
          (set! (-> self arrow) (process->handle (task-arrow-spawn gp-0 self)))
          )
        )
      )
    )
  :exit (behavior ()
    (set-continue! *game-info* "skatea-training" #f)
    )
  :trans (behavior ()
    (when (-> self board-picked-up)
      (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-0 from) (process->ppointer self))
        (set! (-> a1-0 num-params) 0)
        (set! (-> a1-0 message) 'complete)
        (let ((t9-0 send-event-function)
              (v1-5 (-> *game-info* sub-task-list (game-task-node stadium-board1-board)))
              )
          (t9-0
            (handle->process (if (-> v1-5 info)
                                 (-> v1-5 info manager)
                                 (the-as handle #f)
                                 )
                             )
            a1-0
            )
          )
        )
      (send-event (handle->process (-> self arrow)) 'leave)
      (go-virtual jump)
      )
    )
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate wait-for-pickup-training (hoverboard-training-manager)
  :virtual #t
  :event hoverboard-training-manager-event-handler
  :enter (behavior ()
    (set! (-> self board-picked-up) #f)
    (cond
      ((task-node-closed? (game-task-node forest-scouts-get-board))
       (set! (-> self board-picked-up) #t)
       )
      (else
        (let ((v1-0 (birth-pickup-at-point
                      (new 'static 'vector :x 505282.56 :y -38912.0 :z -2533785.5 :w 1.0)
                      (pickup-type board)
                      1.0
                      #t
                      self
                      (the-as fact-info #f)
                      )
                    )
              )
          (send-event (ppointer->process v1-0) 'get-notify #t)
          )
        )
      )
    )
  :exit (behavior ()
    (set-continue! *game-info* "skatea-training" #f)
    )
  :trans (behavior ()
    (if (-> self board-picked-up)
        (go-virtual idle-training)
        )
    )
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate wait-for-board (hoverboard-training-manager)
  :virtual #t
  :event hoverboard-training-manager-event-handler
  :trans (behavior ()
    (if (task-node-open? (game-task-node stadium-board1-board))
        (go-virtual wait-for-pickup)
        )
    )
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate wait (hoverboard-training-manager)
  :virtual #t
  :event hoverboard-training-manager-event-handler
  :trans (behavior ()
    (if (task-node-open? (game-task-node stadium-board1-training-judge))
        (go-virtual jump)
        )
    )
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate jump (hoverboard-training-manager)
  :virtual #t
  :event hoverboard-training-manager-event-handler
  :code (behavior ()
    (if (= (-> self voicebox) #f)
        (set! (-> self voicebox) (ppointer->handle (voicebox-spawn *target* (target-pos 0))))
        )
    (send-event (handle->process (-> self voicebox)) 'speak-effect #t)
    (set! (-> self last-sound-id)
          (add-process *gui-control* self (gui-channel sig) (gui-action play) "kei001" -99.0 0)
          )
    (while (or (not *target*) (not (logtest? (focus-status board) (-> *target* focus-status))))
      (if (= (get-status *gui-control* (-> self last-sound-id)) (gui-status unknown))
          (send-event (handle->process (-> self voicebox)) 'speak-effect #f)
          )
      (render-text self (text-id board-tutorial-get-on-board))
      (suspend)
      )
    (send-event (handle->process (-> self voicebox)) 'speak-effect #t)
    (set! (-> self last-sound-id)
          (add-process *gui-control* self (gui-channel sig) (gui-action play) "kei002" -99.0 0)
          )
    (while (nonzero? (get-status *gui-control* (-> self last-sound-id)))
      (suspend)
      )
    (send-event (handle->process (-> self voicebox)) 'speak-effect #f)
    (send-event *target* 'get-notify self)
    (set! (-> self trick-type) (board-tricks none))
    (until #f
      (render-text self (text-id board-tutorial-jump))
      (suspend)
      (if (= (-> self trick-type) (board-tricks board-jump))
          (goto cfg-51)
          )
      )
    #f
    (label cfg-51)
    (send-event *target* 'get-notify #f)
    (go-virtual duck-jump)
    )
  )

;; failed to figure out what this is:
(defstate duck-jump (hoverboard-training-manager)
  :virtual #t
  :event hoverboard-training-manager-event-handler
  :code (behavior ()
    (while (nonzero? (get-status *gui-control* (-> self last-sound-id)))
      (suspend)
      )
    (send-event (handle->process (-> self voicebox)) 'speak-effect #f)
    (let ((gp-0 (current-time)))
      (until (time-elapsed? gp-0 (seconds 1))
        (suspend)
        )
      )
    (send-event (handle->process (-> self voicebox)) 'speak-effect #t)
    (set! (-> self last-sound-id)
          (add-process *gui-control* self (gui-channel sig) (gui-action play) "kei006" -99.0 0)
          )
    (while (nonzero? (get-status *gui-control* (-> self last-sound-id)))
      (suspend)
      )
    (send-event (handle->process (-> self voicebox)) 'speak-effect #f)
    (send-event *target* 'get-notify self)
    (set! (-> self trick-type) (board-tricks none))
    (until #f
      (render-text self (text-id board-tutorial-duck-jump))
      (suspend)
      (if (= (-> self trick-type) (board-tricks board-duck-jump))
          (goto cfg-36)
          )
      )
    #f
    (label cfg-36)
    (send-event *target* 'get-notify #f)
    (go-virtual boost-jump)
    )
  )

;; failed to figure out what this is:
(defstate boost-jump (hoverboard-training-manager)
  :virtual #t
  :event hoverboard-training-manager-event-handler
  :exit (behavior ()
    (send-event (handle->process (-> self arrow)) 'leave)
    )
  :code (behavior ()
    (while (nonzero? (get-status *gui-control* (-> self last-sound-id)))
      (suspend)
      )
    (send-event (handle->process (-> self voicebox)) 'speak-effect #f)
    (let ((gp-0 (current-time)))
      (until (time-elapsed? gp-0 (seconds 1))
        (suspend)
        )
      )
    (send-event (handle->process (-> self voicebox)) 'speak-effect #t)
    (set! (-> self last-sound-id)
          (add-process *gui-control* self (gui-channel sig) (gui-action play) "kei008" -99.0 0)
          )
    (set! (-> self last-sound-id)
          (add-process *gui-control* self (gui-channel sig) (gui-action play) "kei009" -99.0 0)
          )
    (let ((gp-1 (new 'stack-no-clear 'task-arrow-params)))
      (set! (-> gp-1 pos quad) (-> (new 'static 'vector :x 592158.75 :y -18391.04 :z -2367201.2 :w 1.0) quad))
      (quaternion-identity! (-> gp-1 quat))
      (set! (-> gp-1 flags) (task-arrow-flags))
      (set! (-> gp-1 map-icon) (the-as uint 15))
      (set! (-> self arrow) (process->handle (task-arrow-spawn gp-1 self)))
      )
    (send-event *target* 'get-notify self)
    (set! (-> self trick-type) (board-tricks none))
    (let ((gp-2 #f)
          (s5-0 (+ (current-time) (seconds 15)))
          )
      (until #f
        (let ((a1-7 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-7 from) (process->ppointer self))
          (set! (-> a1-7 num-params) 0)
          (set! (-> a1-7 message) 'off)
          (let ((t9-8 send-event-function)
                (v1-43 (-> self actor-group 0 data 0 actor))
                )
            (t9-8
              (if v1-43
                  (-> v1-43 extra process)
                  )
              a1-7
              )
            )
          )
        (render-text self (text-id board-tutorial-boost-jump))
        (when (< s5-0 (current-time))
          (set! (-> self last-sound-id)
                (add-process *gui-control* self (gui-channel sig) (gui-action play) "kei009" -99.0 0)
                )
          (set! s5-0 (+ (current-time) (seconds 15)))
          )
        (suspend)
        (if (= (-> self trick-type) (board-tricks board-quick-jump))
            (set! gp-2 #t)
            )
        (if (and gp-2 (-> self boost))
            (goto cfg-42)
            )
        )
      )
    #f
    (label cfg-42)
    (send-event *target* 'get-notify #f)
    (go-virtual grind)
    )
  )

;; failed to figure out what this is:
(defstate grind (hoverboard-training-manager)
  :virtual #t
  :event hoverboard-training-manager-event-handler
  :exit (behavior ()
    (send-event (handle->process (-> self arrow)) 'leave)
    )
  :code (behavior ()
    (while (nonzero? (get-status *gui-control* (-> self last-sound-id)))
      (suspend)
      )
    (let ((gp-0 (current-time)))
      (until (time-elapsed? gp-0 (seconds 1))
        (suspend)
        )
      )
    (set! (-> self last-sound-id)
          (add-process *gui-control* self (gui-channel sig) (gui-action play) "kei013" -99.0 0)
          )
    (set! (-> self last-sound-id)
          (add-process *gui-control* self (gui-channel sig) (gui-action play) "kei014" -99.0 0)
          )
    (let ((gp-1 (new 'stack-no-clear 'task-arrow-params)))
      (set! (-> gp-1 pos quad) (-> (new 'static 'vector :x 520232.97 :y -18391.04 :z -1988730.9 :w 1.0) quad))
      (quaternion-identity! (-> gp-1 quat))
      (set! (-> gp-1 flags) (task-arrow-flags))
      (set! (-> gp-1 map-icon) (the-as uint 15))
      (set! (-> self arrow) (process->handle (task-arrow-spawn gp-1 self)))
      )
    (send-event *target* 'get-notify self)
    (set! (-> self trick-type) (board-tricks none))
    (let ((gp-2 #f))
      (until #f
        (let ((a1-5 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-5 from) (process->ppointer self))
          (set! (-> a1-5 num-params) 0)
          (set! (-> a1-5 message) 'off)
          (let ((t9-6 send-event-function)
                (v1-26 (-> self actor-group 0 data 1 actor))
                )
            (t9-6
              (if v1-26
                  (-> v1-26 extra process)
                  )
              a1-5
              )
            )
          )
        (render-text self (text-id board-tutorial-grind))
        (suspend)
        (if (= (-> self trick-type) (board-tricks board-rail-jump))
            (set! gp-2 #t)
            )
        (if (= (get-status *gui-control* (-> self last-sound-id)) (gui-status unknown))
            (send-event (handle->process (-> self voicebox)) 'speak-effect #f)
            )
        (if (and gp-2 (-> self grind))
            (goto cfg-35)
            )
        )
      )
    #f
    (label cfg-35)
    (send-event *target* 'get-notify #f)
    (go-virtual spin)
    )
  )

;; failed to figure out what this is:
(defstate spin (hoverboard-training-manager)
  :virtual #t
  :event hoverboard-training-manager-event-handler
  :code (behavior ()
    (while (nonzero? (get-status *gui-control* (-> self last-sound-id)))
      (suspend)
      )
    (send-event (handle->process (-> self voicebox)) 'speak-effect #f)
    (let ((gp-0 (current-time)))
      (until (time-elapsed? gp-0 (seconds 1))
        (suspend)
        )
      )
    (send-event (handle->process (-> self voicebox)) 'speak-effect #t)
    (set! (-> self last-sound-id)
          (add-process *gui-control* self (gui-channel sig) (gui-action play) "kei010" -99.0 0)
          )
    (set! (-> self last-sound-id)
          (add-process *gui-control* self (gui-channel sig) (gui-action play) "kei011" -99.0 0)
          )
    (while (nonzero? (get-status *gui-control* (-> self last-sound-id)))
      (suspend)
      )
    (send-event (handle->process (-> self voicebox)) 'speak-effect #f)
    (send-event *target* 'get-notify self)
    (set! (-> self trick-type) (board-tricks none))
    (until #f
      (render-text self (text-id board-tutorial-spin))
      (suspend)
      (if (= (-> self trick-type) (board-tricks board-spin))
          (goto cfg-36)
          )
      )
    #f
    (label cfg-36)
    (send-event *target* 'get-notify #f)
    (go-virtual flip)
    )
  )

;; failed to figure out what this is:
(defstate flip (hoverboard-training-manager)
  :virtual #t
  :event hoverboard-training-manager-event-handler
  :code (behavior ()
    (while (nonzero? (get-status *gui-control* (-> self last-sound-id)))
      (suspend)
      )
    (send-event (handle->process (-> self voicebox)) 'speak-effect #f)
    (let ((gp-0 (current-time)))
      (until (time-elapsed? gp-0 (seconds 1))
        (suspend)
        )
      )
    (send-event (handle->process (-> self voicebox)) 'speak-effect #t)
    (set! (-> self last-sound-id)
          (add-process *gui-control* self (gui-channel sig) (gui-action play) "kei016" -99.0 0)
          )
    (while (nonzero? (get-status *gui-control* (-> self last-sound-id)))
      (suspend)
      )
    (send-event (handle->process (-> self voicebox)) 'speak-effect #f)
    (send-event *target* 'get-notify self)
    (set! (-> self trick-type) (board-tricks none))
    (until #f
      (render-text self (text-id board-tutorial-flip))
      (suspend)
      (if (= (-> self trick-type) (board-tricks board-flip))
          (goto cfg-36)
          )
      )
    #f
    (label cfg-36)
    (send-event *target* 'get-notify #f)
    (go-virtual trick)
    )
  )

;; failed to figure out what this is:
(defstate trick (hoverboard-training-manager)
  :virtual #t
  :event hoverboard-training-manager-event-handler
  :code (behavior ()
    (while (nonzero? (get-status *gui-control* (-> self last-sound-id)))
      (suspend)
      )
    (send-event (handle->process (-> self voicebox)) 'speak-effect #f)
    (let ((gp-0 (current-time)))
      (until (time-elapsed? gp-0 (seconds 1))
        (suspend)
        )
      )
    (send-event (handle->process (-> self voicebox)) 'speak-effect #t)
    (set! (-> self last-sound-id)
          (add-process *gui-control* self (gui-channel sig) (gui-action play) "kei017" -99.0 0)
          )
    (while (nonzero? (get-status *gui-control* (-> self last-sound-id)))
      (suspend)
      )
    (send-event (handle->process (-> self voicebox)) 'speak-effect #f)
    (send-event *target* 'get-notify self)
    (set! (-> self trick-type) (board-tricks none))
    (until #f
      (render-text self (text-id board-tutorial-trick))
      (suspend)
      (case (-> self trick-type)
        (((board-tricks board-nosegrab)
          (board-tricks board-method)
          (board-tricks board-board-spin)
          (board-tricks board-board-flip)
          (board-tricks board-noseflip)
          (board-tricks board-kickflip)
          )
         (goto cfg-47)
         )
        )
      )
    #f
    (label cfg-47)
    (send-event *target* 'get-notify #f)
    (go-virtual game)
    )
  )

;; failed to figure out what this is:
(defstate game (hoverboard-training-manager)
  :virtual #t
  :event hoverboard-training-manager-event-handler
  :code (behavior ()
    (while (nonzero? (get-status *gui-control* (-> self last-sound-id)))
      (suspend)
      )
    (send-event (handle->process (-> self voicebox)) 'speak-effect #f)
    (send-event (handle->process (-> self voicebox)) 'speak-effect #t)
    (set! (-> self last-sound-id)
          (add-process *gui-control* self (gui-channel sig) (gui-action play) "kei018" -99.0 0)
          )
    (set! (-> self last-sound-id)
          (add-process *gui-control* self (gui-channel sig) (gui-action play) "kei019" -99.0 0)
          )
    (while (nonzero? (get-status *gui-control* (-> self last-sound-id)))
      (suspend)
      )
    (send-event (handle->process (-> self voicebox)) 'speak-effect #f)
    (when (!= (-> self voicebox) #f)
      (send-event (handle->process (-> self voicebox)) 'die)
      (set! (-> self voicebox) (the-as handle #f))
      )
    (task-node-close! (game-task-node stadium-board1-training))
    (go-virtual idle)
    )
  )

;; definition for method 29 of type hoverboard-training-manager
;; WARN: Return type mismatch int vs none.
(defmethod hoverboard-training-manager-method-29 ((this hoverboard-training-manager))
  (let ((s5-0 (get-game-score-ref *game-info* (the-as int (-> this game-score))))
        (gp-0 (handle->process (-> this hud-goal)))
        )
    (cond
      ((-> this training?)
       (cond
         ((>= (-> *game-info* score) (-> s5-0 0))
          (set! (-> *game-info* goal) (-> *game-info* score))
          (let ((s5-1 format)
                (gp-1 (the-as hud-goal (clear (-> (the-as hud-goal gp-0) strings 1 text))))
                (s4-1 "~S")
                )
            (format (clear *temp-string*) (lookup-text! *common-text* (text-id highscore-text-gold) #f))
            (s5-1 gp-1 s4-1 *temp-string*)
            )
          )
         ((>= (-> *game-info* score) (-> s5-0 1))
          (set! (-> *game-info* goal) (-> s5-0 0))
          (let ((s5-2 format)
                (gp-2 (the-as hud-goal (clear (-> (the-as hud-goal gp-0) strings 1 text))))
                (s4-2 "~S")
                )
            (format (clear *temp-string*) (lookup-text! *common-text* (text-id highscore-text-gold) #f))
            (s5-2 gp-2 s4-2 *temp-string*)
            )
          )
         ((>= (-> *game-info* score) (-> s5-0 2))
          (set! (-> *game-info* goal) (-> s5-0 1))
          (let ((s5-3 format)
                (gp-3 (the-as hud-goal (clear (-> (the-as hud-goal gp-0) strings 1 text))))
                (s4-3 "~S")
                )
            (format (clear *temp-string*) (lookup-text! *common-text* (text-id highscore-text-silver) #f))
            (s5-3 gp-3 s4-3 *temp-string*)
            )
          )
         ((>= (-> *game-info* score) (-> this training-goal))
          (set! (-> *game-info* goal) (-> s5-0 2))
          (let ((s5-4 format)
                (gp-4 (the-as hud-goal (clear (-> (the-as hud-goal gp-0) strings 1 text))))
                (s4-4 "~S")
                )
            (format (clear *temp-string*) (lookup-text! *common-text* (text-id highscore-text-bronze) #f))
            (s5-4 gp-4 s4-4 *temp-string*)
            )
          )
         (else
           (set! (-> *game-info* goal) (-> this training-goal))
           (let ((s5-5 format)
                 (gp-5 (the-as hud-goal (clear (-> (the-as hud-goal gp-0) strings 1 text))))
                 (s4-5 "~S")
                 )
             (format (clear *temp-string*) (lookup-text! *common-text* (text-id highscore-text-goal) #f))
             (s5-5 gp-5 s4-5 *temp-string*)
             )
           )
         )
       )
      ((task-node-open? (the-as game-task-node (-> this task-bronze)))
       (cond
         ((>= (-> *game-info* score) (-> s5-0 0))
          (set! (-> *game-info* goal) (-> *game-info* score))
          (let ((s5-6 format)
                (gp-6 (the-as hud-goal (clear (-> (the-as hud-goal gp-0) strings 1 text))))
                (s4-6 "~S")
                )
            (format (clear *temp-string*) (lookup-text! *common-text* (text-id highscore-text-gold) #f))
            (s5-6 gp-6 s4-6 *temp-string*)
            )
          )
         ((>= (-> *game-info* score) (-> s5-0 1))
          (set! (-> *game-info* goal) (-> s5-0 0))
          (let ((s5-7 format)
                (gp-7 (the-as hud-goal (clear (-> (the-as hud-goal gp-0) strings 1 text))))
                (s4-7 "~S")
                )
            (format (clear *temp-string*) (lookup-text! *common-text* (text-id highscore-text-gold) #f))
            (s5-7 gp-7 s4-7 *temp-string*)
            )
          )
         ((>= (-> *game-info* score) (-> s5-0 2))
          (set! (-> *game-info* goal) (-> s5-0 1))
          (let ((s5-8 format)
                (gp-8 (the-as hud-goal (clear (-> (the-as hud-goal gp-0) strings 1 text))))
                (s4-8 "~S")
                )
            (format (clear *temp-string*) (lookup-text! *common-text* (text-id highscore-text-silver) #f))
            (s5-8 gp-8 s4-8 *temp-string*)
            )
          )
         (else
           (set! (-> *game-info* goal) (-> s5-0 2))
           (let ((s5-9 format)
                 (gp-9 (the-as hud-goal (clear (-> (the-as hud-goal gp-0) strings 1 text))))
                 (s4-9 "~S")
                 )
             (format (clear *temp-string*) (lookup-text! *common-text* (text-id highscore-text-bronze) #f))
             (s5-9 gp-9 s4-9 *temp-string*)
             )
           )
         )
       )
      ((task-node-open? (the-as game-task-node (-> this task-silver)))
       (cond
         ((>= (-> *game-info* score) (-> s5-0 0))
          (set! (-> *game-info* goal) (-> *game-info* score))
          (let ((s5-10 format)
                (gp-10 (the-as hud-goal (clear (-> (the-as hud-goal gp-0) strings 1 text))))
                (s4-10 "~S")
                )
            (format (clear *temp-string*) (lookup-text! *common-text* (text-id highscore-text-gold) #f))
            (s5-10 gp-10 s4-10 *temp-string*)
            )
          )
         ((>= (-> *game-info* score) (-> s5-0 1))
          (set! (-> *game-info* goal) (-> s5-0 0))
          (let ((s5-11 format)
                (gp-11 (the-as hud-goal (clear (-> (the-as hud-goal gp-0) strings 1 text))))
                (s4-11 "~S")
                )
            (format (clear *temp-string*) (lookup-text! *common-text* (text-id highscore-text-silver) #f))
            (s5-11 gp-11 s4-11 *temp-string*)
            )
          )
         (else
           (set! (-> *game-info* goal) (-> s5-0 1))
           (let ((s5-12 format)
                 (gp-12 (the-as hud-goal (clear (-> (the-as hud-goal gp-0) strings 1 text))))
                 (s4-12 "~S")
                 )
             (format (clear *temp-string*) (lookup-text! *common-text* (text-id highscore-text-silver) #f))
             (s5-12 gp-12 s4-12 *temp-string*)
             )
           )
         )
       )
      ((or (task-node-open? (the-as game-task-node (-> this task-gold)))
           (task-node-closed? (the-as game-task-node (-> this task-gold)))
           )
       (cond
         ((>= (-> *game-info* score) (-> s5-0 0))
          (set! (-> *game-info* goal) (-> *game-info* score))
          (let ((s5-13 format)
                (gp-13 (the-as hud-goal (clear (-> (the-as hud-goal gp-0) strings 1 text))))
                (s4-13 "~S")
                )
            (format (clear *temp-string*) (lookup-text! *common-text* (text-id highscore-text-gold) #f))
            (s5-13 gp-13 s4-13 *temp-string*)
            )
          )
         (else
           (set! (-> *game-info* goal) (-> s5-0 0))
           (let ((s5-14 format)
                 (gp-14 (clear (-> (the-as hud-goal gp-0) strings 1 text)))
                 (s4-14 "~S")
                 )
             (format (clear *temp-string*) (lookup-text! *common-text* (text-id highscore-text-gold) #f))
             (s5-14 gp-14 s4-14 *temp-string*)
             )
           )
         )
       )
      )
    )
  0
  (none)
  )

;; definition for method 30 of type hoverboard-training-manager
;; WARN: Return type mismatch int vs none.
(defmethod hoverboard-training-manager-method-30 ((this hoverboard-training-manager))
  (set! (-> this egg-count) 0)
  (set! (-> this medal) 0)
  (let ((s5-0 (get-game-score-ref *game-info* (the-as int (-> this game-score)))))
    (when (or (-> this training?) (task-node-open? (the-as game-task-node (-> this task-bronze))))
      (when (>= (-> *game-info* score) (-> s5-0 2))
        (task-node-close! (the-as game-task-node (-> this task-bronze)))
        (logior! (-> *game-info* features) (game-feature board))
        (+! (-> this egg-count) 1)
        (set! (-> this medal) 2)
        )
      )
    (when (task-node-open? (the-as game-task-node (-> this task-silver)))
      (when (>= (-> *game-info* score) (-> s5-0 1))
        (task-node-close! (the-as game-task-node (-> this task-silver)))
        (logior! (-> *game-info* features) (game-feature board))
        (+! (-> this egg-count) 1)
        (set! (-> this medal) 1)
        )
      )
    (when (task-node-open? (the-as game-task-node (-> this task-gold)))
      (when (>= (-> *game-info* score) (-> s5-0 0))
        (task-node-close! (the-as game-task-node (-> this task-gold)))
        (logior! (-> *game-info* features) (game-feature board))
        (+! (-> this egg-count) 1)
        (set! (-> this medal) 0)
        0
        )
      )
    )
  (game-info-method-28 *game-info* (the-as game-score (-> this game-score)) (-> this score))
  0
  (none)
  )

;; failed to figure out what this is:
(defstate idle (hoverboard-training-manager)
  :virtual #t
  :event hoverboard-training-manager-event-handler
  :enter (behavior ()
    (if (= (-> self hud-score) #f)
        (set! (-> self hud-score) (ppointer->handle (process-spawn hud-score :init hud-init-by-other :to self)))
        )
    (if (= (-> self hud-goal) #f)
        (set! (-> self hud-goal) (ppointer->handle (process-spawn hud-goal :init hud-init-by-other :to self)))
        )
    (set! (-> self training-goal) 15000.0)
    (set! (-> self training?) #t)
    (set! (-> self game-score) (the-as uint 10))
    (set! (-> self task-gold) (the-as uint 71))
    (set! (-> self task-silver) (the-as uint 70))
    (set! (-> self task-bronze) (the-as uint 69))
    (set! (-> self challenge-done) #t)
    (if (task-node-closed? (game-task-node stadium-board1-training-judge))
        (set! (-> self training?) #f)
        )
    )
  :exit (behavior ()
    (send-event *target* 'get-notify #f)
    )
  :trans (behavior ()
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) (process->ppointer self))
      (set! (-> a1-0 num-params) 0)
      (set! (-> a1-0 message) 'off)
      (let ((t9-0 send-event-function)
            (v1-5 (-> self actor-group 0 data 0 actor))
            )
        (t9-0
          (if v1-5
              (-> v1-5 extra process)
              )
          a1-0
          )
        )
      )
    (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-1 from) (process->ppointer self))
      (set! (-> a1-1 num-params) 0)
      (set! (-> a1-1 message) 'off)
      (let ((t9-1 send-event-function)
            (v1-13 (-> self actor-group 0 data 1 actor))
            )
        (t9-1
          (if v1-13
              (-> v1-13 extra process)
              )
          a1-1
          )
        )
      )
    (cond
      ((not (logtest? (-> *game-info* features) (game-feature board)))
       (if (!= (-> self hud-score) #f)
           (send-event (handle->process (-> self hud-score)) 'force-hide)
           )
       (if (!= (-> self hud-goal) #f)
           (send-event (handle->process (-> self hud-goal)) 'force-hide)
           )
       )
      (else
        (if (!= (-> self hud-score) #f)
            (send-event (handle->process (-> self hud-score)) 'force-show)
            )
        (if (!= (-> self hud-goal) #f)
            (send-event (handle->process (-> self hud-goal)) 'force-show)
            )
        )
      )
    (send-event *target* 'get-notify self)
    (hoverboard-training-manager-method-29 self)
    (when (not (-> self challenge-done))
      (when (and (not (-> self combo-done?))
                 (time-elapsed? (-> self hint-time) (seconds 30))
                 (not (task-node-closed? (game-task-node stadium-board1-resolution)))
                 )
        (add-process *gui-control* self (gui-channel sig) (gui-action play) "kei018" -99.0 0)
        (set-time! (-> self hint-time))
        )
      )
    )
  :code (behavior ()
    (suspend)
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) (process->ppointer self))
      (set! (-> a1-0 num-params) 0)
      (set! (-> a1-0 message) 'open)
      (let ((t9-0 send-event-function)
            (v1-5 (-> self actor-group 1 data 0 actor))
            )
        (t9-0
          (if v1-5
              (-> v1-5 extra process)
              )
          a1-0
          )
        )
      )
    (until #f
      (when (not (task-node-closed? (game-task-node stadium-board1-training-judge)))
        (let ((gp-0 (new 'stack-no-clear 'task-arrow-params)))
          (set! (-> gp-0 pos quad) (-> (new 'static 'vector :x 191037.44 :y -53780.48 :z -2148638.8 :w 1.0) quad))
          (quaternion-identity! (-> gp-0 quat))
          (set! (-> gp-0 flags) (task-arrow-flags))
          (set! (-> gp-0 map-icon) (the-as uint 15))
          (set! (-> self arrow) (process->handle (task-arrow-spawn gp-0 self)))
          )
        (set! (-> self score) -1.0)
        )
      (let ((gp-1
              (ppointer->handle
                (judge-spawn self (new 'static 'vector :x 190382.08 :y -47063.04 :z -2148475.0 :w 1.0) (the-as uint 10))
                )
              )
            )
        (suspend)
        (while (send-event (handle->process gp-1) 'waiting)
          (when (-> self text)
            (cond
              ((not (task-node-closed? (game-task-node stadium-board1-resolution)))
               (cond
                 ((task-node-open? (game-task-node stadium-board1-training-judge))
                  (cond
                    ((< (-> self score) 0.0)
                     (render-text self (text-id board-score-activate-judge))
                     )
                    ((< (-> self score) 15000.0)
                     (render-text self (text-id board-score-try-again))
                     )
                    )
                  )
                 ((not (task-node-closed? (game-task-node stadium-board1-done)))
                  (if (not (movie?))
                      (render-text self (text-id board-score-return-to-garage))
                      )
                  )
                 ((task-node-closed? (game-task-node stadium-board1-done))
                  (when (!= (-> self arrow) #f)
                    (send-event (handle->process (-> self arrow)) 'leave)
                    (set! (-> self arrow) (the-as handle #f))
                    )
                  )
                 )
               )
              (else
                (go-virtual wait-for-pickup-training)
                )
              )
            )
          (suspend)
          )
        (if (!= (-> self arrow) #f)
            (send-event (handle->process (-> self arrow)) 'leave)
            )
        (set! (-> self score) 0.0)
        (set! (-> self challenge-done) #f)
        (set! (-> self combo-done?) #f)
        (set-time! (-> self hint-time))
        (while (and (not (-> self challenge-done)) (logtest? (-> *game-info* features) (game-feature board)))
          (suspend)
          )
        (send-event (handle->process gp-1) 'die)
        )
      (when (-> self challenge-done)
        (hoverboard-training-manager-method-30 self)
        (when (> (-> self egg-count) 0)
          (let ((s5-0 0))
            (let ((gp-3 (ppointer->handle (voicebox-spawn *target* (target-pos 0)))))
              (let ((v1-83 (-> self medal)))
                (cond
                  ((zero? v1-83)
                   (set! s5-0
                         (the-as int (add-process *gui-control* self (gui-channel sig) (gui-action play) "cityv179" -99.0 0))
                         )
                   )
                  ((= v1-83 1)
                   (set! s5-0
                         (the-as int (add-process *gui-control* self (gui-channel sig) (gui-action play) "cityv180" -99.0 0))
                         )
                   )
                  ((= v1-83 2)
                   (set! s5-0
                         (the-as int (add-process *gui-control* self (gui-channel sig) (gui-action play) "cityv181" -99.0 0))
                         )
                   )
                  )
                )
              (while (nonzero? (get-status *gui-control* (the-as sound-id s5-0)))
                (suspend)
                )
              (let* ((s5-1 (handle->process gp-3))
                     (v1-97 (if (type? s5-1 process-drawable)
                                (the-as process-drawable s5-1)
                                )
                            )
                     (t1-3 (new 'static 'fact-info))
                     )
                (set! (-> t1-3 options) (actor-option))
                (logior! (-> t1-3 options) (actor-option suck-in))
                (birth-pickup-at-point
                  (-> v1-97 root trans)
                  (pickup-type skill)
                  (* (the float (-> self egg-count)) (-> *FACT-bank* super-skill-inc))
                  #t
                  *entity-pool*
                  t1-3
                  )
                )
              (let ((s5-2 (current-time)))
                (until (time-elapsed? s5-2 (seconds 1))
                  (suspend)
                  )
                )
              (send-event (handle->process gp-3) 'die)
              )
            )
          (auto-save-user)
          )
        )
      (set! (-> self challenge-done) #t)
      (let ((gp-4 (new 'stack-no-clear 'task-arrow-params)))
        (cond
          ((not (task-node-closed? (game-task-node stadium-board1-training-judge)))
           (cond
             ((>= (-> self score) 15000.0)
              (add-process *gui-control* self (gui-channel sig) (gui-action play) "kei021" -99.0 0)
              (task-node-close! (game-task-node stadium-board1-training-judge))
              (set! (-> self training?) #f)
              (set! (-> gp-4 pos quad) (-> (new 'static 'vector :x 426885.12 :y -38461.44 :z -2598625.2 :w 1.0) quad))
              (quaternion-identity! (-> gp-4 quat))
              (set! (-> gp-4 flags) (task-arrow-flags))
              (set! (-> gp-4 map-icon) (the-as uint 15))
              (set! (-> self arrow) (process->handle (task-arrow-spawn gp-4 self)))
              )
             (else
               (set! (-> *game-info* sub-task-list (game-task-node stadium-board1-training-judge) death-count)
                     (the-as
                       uint
                       (seekl
                         (the-as int (-> *game-info* sub-task-list (game-task-node stadium-board1-training-judge) death-count))
                         #xffff
                         1
                         )
                       )
                     )
               (add-process *gui-control* self (gui-channel sig) (gui-action play) "kei020" -99.0 0)
               )
             )
           )
          (else
            (set! (-> self training?) #f)
            (set! (-> gp-4 pos quad) (-> (new 'static 'vector :x 426885.12 :y -38461.44 :z -2598625.2 :w 1.0) quad))
            (quaternion-identity! (-> gp-4 quat))
            (set! (-> gp-4 flags) (task-arrow-flags))
            (set! (-> gp-4 map-icon) (the-as uint 15))
            (set! (-> self arrow) (process->handle (task-arrow-spawn gp-4 self)))
            )
          )
        )
      )
    #f
    )
  )

;; failed to figure out what this is:
(defstate idle-training (hoverboard-training-manager)
  :virtual #t
  :event hoverboard-training-manager-event-handler
  :enter (behavior ()
    (if (= (-> self hud-score) #f)
        (set! (-> self hud-score) (ppointer->handle (process-spawn hud-score :init hud-init-by-other :to self)))
        )
    (if (= (-> self hud-goal) #f)
        (set! (-> self hud-goal) (ppointer->handle (process-spawn hud-goal :init hud-init-by-other :to self)))
        )
    (set! (-> self training-goal) 15000.0)
    (set! (-> self training?) #f)
    (set! (-> self game-score) (the-as uint 10))
    (set! (-> self task-gold) (the-as uint 71))
    (set! (-> self task-silver) (the-as uint 70))
    (set! (-> self task-bronze) (the-as uint 69))
    )
  :exit (behavior ()
    (send-event *target* 'get-notify #f)
    )
  :trans (behavior ()
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) (process->ppointer self))
      (set! (-> a1-0 num-params) 0)
      (set! (-> a1-0 message) 'off)
      (let ((t9-0 send-event-function)
            (v1-5 (-> self actor-group 0 data 0 actor))
            )
        (t9-0
          (if v1-5
              (-> v1-5 extra process)
              )
          a1-0
          )
        )
      )
    (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-1 from) (process->ppointer self))
      (set! (-> a1-1 num-params) 0)
      (set! (-> a1-1 message) 'off)
      (let ((t9-1 send-event-function)
            (v1-13 (-> self actor-group 0 data 1 actor))
            )
        (t9-1
          (if v1-13
              (-> v1-13 extra process)
              )
          a1-1
          )
        )
      )
    (cond
      ((not (logtest? (-> *game-info* features) (game-feature board)))
       (if (!= (-> self hud-score) #f)
           (send-event (handle->process (-> self hud-score)) 'force-hide)
           )
       (if (!= (-> self hud-goal) #f)
           (send-event (handle->process (-> self hud-goal)) 'force-hide)
           )
       )
      (else
        (if (!= (-> self hud-score) #f)
            (send-event (handle->process (-> self hud-score)) 'force-show)
            )
        (if (!= (-> self hud-goal) #f)
            (send-event (handle->process (-> self hud-goal)) 'force-show)
            )
        )
      )
    (hoverboard-training-manager-method-29 self)
    )
  :code (behavior ()
    (send-event *target* 'get-notify self)
    (until #f
      (let ((gp-0
              (ppointer->handle
                (judge-spawn self (new 'static 'vector :x 190382.08 :y -47063.04 :z -2148475.0 :w 1.0) (the-as uint 10))
                )
              )
            )
        (suspend)
        (while (send-event (handle->process (the-as handle gp-0)) 'waiting)
          (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-2 from) (process->ppointer self))
            (set! (-> a1-2 num-params) 0)
            (set! (-> a1-2 message) 'open)
            (let ((t9-2 send-event-function)
                  (v1-11 (-> self actor-group 1 data 0 actor))
                  )
              (t9-2
                (if v1-11
                    (-> v1-11 extra process)
                    )
                a1-2
                )
              )
            )
          (suspend)
          )
        )
      (set! (-> self score) 0.0)
      (set! (-> self challenge-done) #f)
      (until (-> self challenge-done)
        (suspend)
        )
      (hoverboard-training-manager-method-30 self)
      (when (> (-> self egg-count) 0)
        (let ((s5-0 0))
          (let ((gp-2 (ppointer->handle (voicebox-spawn *target* (target-pos 0)))))
            (let ((v1-30 (-> self medal)))
              (cond
                ((zero? v1-30)
                 (set! s5-0
                       (the-as int (add-process *gui-control* self (gui-channel sig) (gui-action play) "cityv179" -99.0 0))
                       )
                 )
                ((= v1-30 1)
                 (set! s5-0
                       (the-as int (add-process *gui-control* self (gui-channel sig) (gui-action play) "cityv180" -99.0 0))
                       )
                 )
                ((= v1-30 2)
                 (set! s5-0
                       (the-as int (add-process *gui-control* self (gui-channel sig) (gui-action play) "cityv181" -99.0 0))
                       )
                 )
                )
              )
            (while (nonzero? (get-status *gui-control* (the-as sound-id s5-0)))
              (suspend)
              )
            (let* ((s5-1 (handle->process gp-2))
                   (v1-44 (if (type? s5-1 process-drawable)
                              (the-as process-drawable s5-1)
                              )
                          )
                   (t1-3 (new 'static 'fact-info))
                   )
              (set! (-> t1-3 options) (actor-option))
              (logior! (-> t1-3 options) (actor-option suck-in))
              (birth-pickup-at-point
                (-> v1-44 root trans)
                (pickup-type skill)
                (* (the float (-> self egg-count)) (-> *FACT-bank* super-skill-inc))
                #t
                *entity-pool*
                t1-3
                )
              )
            (let ((s5-2 (current-time)))
              (until (time-elapsed? s5-2 (seconds 1))
                (suspend)
                )
              )
            (send-event (handle->process gp-2) 'die)
            )
          )
        (auto-save-user)
        )
      )
    #f
    )
  :post (behavior ()
    (if (not (logtest? (-> *game-info* features) (game-feature board)))
        (go-virtual wait-for-pickup-training)
        )
    )
  )

;; definition for method 10 of type hoverboard-training-manager
(defmethod deactivate ((this hoverboard-training-manager))
  (send-event *traffic-manager* 'restore-default-settings)
  (call-parent-method this)
  (none)
  )

;; definition for method 11 of type hoverboard-training-manager
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this hoverboard-training-manager) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (sv-16 res-tag))
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-1 (res-lump-data (-> this entity) 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-1 (nonzero? (-> sv-16 elt-count)))
       (set! (-> this actor-group) (the-as (pointer actor-group) v1-1))
       (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> this actor-group) (the-as (pointer actor-group) #f))
        (set! (-> this actor-group-count) 0)
        (go process-drawable-art-error "actor-group training-manager")
        )
      )
    )
  (set! (-> this boost) #f)
  (set! (-> this grind) #f)
  (set! (-> this text) #t)
  (set! (-> this combo-done?) #f)
  (set! (-> this hud-score) (the-as handle #f))
  (set! (-> this hud-goal) (the-as handle #f))
  (set! (-> this voicebox) (the-as handle #f))
  (set! (-> this arrow) (the-as handle #f))
  (set! (-> this gui-id) (new 'static 'sound-id))
  (set! (-> this gui-id)
        (add-process *gui-control* this (gui-channel message) (gui-action play) (-> this name) 81920.0 0)
        )
  (let ((s5-0 *traffic-manager*))
    (send-event s5-0 'set-object-target-count (traffic-type bikea) 0)
    (send-event s5-0 'set-object-target-count (traffic-type bikeb) 0)
    (send-event s5-0 'set-object-target-count (traffic-type bikec) 0)
    (send-event s5-0 'set-object-target-count (traffic-type cara) 0)
    (send-event s5-0 'set-object-target-count (traffic-type carb) 0)
    (send-event s5-0 'set-object-target-count (traffic-type carc) 0)
    (send-event s5-0 'set-object-target-count (traffic-type citizen-norm-1) 0)
    (send-event s5-0 'set-object-target-count (traffic-type citizen-chick) 0)
    (send-event s5-0 'set-object-target-count (traffic-type citizen-fat) 0)
    (send-event s5-0 'set-object-target-count (traffic-type crimson-guard-1) 0)
    (send-event s5-0 'set-object-target-count (traffic-type crimson-guard-2) 0)
    (send-event s5-0 'set-object-target-count (traffic-type metalhead-grunt) 0)
    (send-event s5-0 'set-object-target-count (traffic-type metalhead-flitter) 0)
    (send-event s5-0 'set-object-target-count (traffic-type metalhead-predator) 0)
    (send-event s5-0 'set-object-target-count (traffic-type guard-bike) 0)
    (send-event s5-0 'set-object-target-count (traffic-type hellcat) 0)
    (send-event s5-0 'set-guard-target-level 0)
    )
  (set-setting! 'allow-continue #f 0.0 0)
  (cond
    ((task-node-closed? (game-task-node forest-scouts-get-board))
     (go (method-of-object this idle))
     )
    ((task-node-closed? (game-task-node stadium-board1-resolution))
     (go (method-of-object this wait-for-pickup-training))
     )
    ((task-node-open? (game-task-node stadium-board1-training))
     (go (method-of-object this jump))
     )
    ((task-node-open? (game-task-node stadium-board1-training-judge))
     (go (method-of-object this idle))
     )
    ((task-node-closed? (game-task-node stadium-board1-training-judge))
     (go (method-of-object this idle))
     )
    (else
      (go (method-of-object this wait-for-board))
      )
    )
  (none)
  )

;; definition of type skate-training-ramp
(deftype skate-training-ramp (process-focusable)
  ((onoff  symbol)
   )
  (:state-methods
    idle
    )
  (:methods
    (skate-training-ramp-method-28 (_type_) collide-shape-moving)
    )
  )

;; definition for method 3 of type skate-training-ramp
(defmethod inspect ((this skate-training-ramp))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-focusable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tonoff: ~A~%" (-> this onoff))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-skate-training-ramp skate-training-ramp skate-training-ramp-lod0-jg skate-training-ramp-idle-ja
              ((skate-training-ramp-lod0-mg (meters 999999)))
              :bounds (static-spherem 4 -4 8 12)
              )

;; failed to figure out what this is:
(defstate idle (skate-training-ramp)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('open)
       (let ((v0-0 #t))
         (set! (-> self onoff) v0-0)
         v0-0
         )
       )
      (('close)
       (set! (-> self onoff) #f)
       #f
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :code (behavior ()
    (until #f
      (if (-> self onoff)
          (ja :num! (seek! max 0.05))
          (ja :num! (seek! 0.0 0.05))
          )
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (transform-post)
    )
  )

;; definition for method 28 of type skate-training-ramp
(defmethod skate-training-ramp-method-28 ((this skate-training-ramp))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 61440.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-12 prim-core action) (collide-action solid))
      (set! (-> v1-12 transform-index) 4)
      (set-vector! (-> v1-12 local-sphere) 16384.0 -16384.0 32768.0 49152.0)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-14 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-14 prim-core action) (collide-action solid))
      (set! (-> v1-14 transform-index) 3)
      (set-vector! (-> v1-14 local-sphere) 16384.0 -16384.0 32768.0 49152.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-17 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-17 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-17 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    s5-0
    )
  )

;; definition for method 11 of type skate-training-ramp
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this skate-training-ramp) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (skate-training-ramp-method-28 this)
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (initialize-skeleton
    this
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-skate-training-ramp" (the-as (pointer uint32) #f))
      )
    (the-as pair 0)
    )
  (set! (-> this onoff) #f)
  (ja-channel-push! 1 0)
  (let ((a0-7 (-> this skel root-channel 0)))
    (set! (-> a0-7 frame-group) (the-as art-joint-anim (-> this draw art-group data 2)))
    (set! (-> a0-7 frame-num) 0.0)
    (joint-control-channel-group! a0-7 (the-as art-joint-anim (-> this draw art-group data 2)) num-func-identity)
    )
  (transform-post)
  (go (method-of-object this idle))
  (none)
  )

;; definition of type skate-gate
(deftype skate-gate (process-focusable)
  ((onoff  symbol)
   )
  (:state-methods
    idle
    open
    )
  (:methods
    (skate-gate-method-29 (_type_) collide-shape-moving)
    )
  )

;; definition for method 3 of type skate-gate
(defmethod inspect ((this skate-gate))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-focusable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tonoff: ~A~%" (-> this onoff))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-skate-gate skate-gate skate-gate-lod0-jg skate-gate-idle-ja
              ((skate-gate-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 8 0 30)
              )

;; failed to figure out what this is:
(defstate idle (skate-gate)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('open)
       (remove-setting! 'minimap)
       (let ((v0-1 #t))
         (set! (-> self onoff) v0-1)
         v0-1
         )
       )
      (('close)
       (set-setting! 'minimap 'clear 0.0 (minimap-flag minimap))
       (set! (-> self onoff) #f)
       #f
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :code (behavior ()
    (until #f
      (if (-> self onoff)
          (ja :num! (seek! max 0.05))
          (ja :num! (seek! 0.0 0.05))
          )
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (if (logtest? (-> *game-info* features) (game-feature board))
        (send-event self 'close)
        (send-event self 'open)
        )
    (transform-post)
    )
  )

;; failed to figure out what this is:
(defstate open (skate-gate)
  :virtual #t
  :code sleep-code
  )

;; definition for method 29 of type skate-gate
(defmethod skate-gate-method-29 ((this skate-gate))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-6 prim-core action) (collide-action solid))
      (set! (-> v1-6 transform-index) 3)
      (set-vector! (-> v1-6 local-sphere) 32768.0 32768.0 0.0 49152.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    s5-0
    )
  )

;; definition for method 11 of type skate-gate
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this skate-gate) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (skate-gate-method-29 this)
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-skate-gate" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this onoff) #f)
  (send-event *target* 'reset-pickup 'trick-judge)
  (send-event *target* 'reset-pickup 'trick-point)
  (ja-channel-push! 1 0)
  (cond
    ((and (not (task-node-open? (game-task-node stadium-board1-training-judge)))
          (logtest? (-> *game-info* features) (game-feature board))
          )
     (let ((a0-15 (-> this skel root-channel 0)))
       (set! (-> a0-15 frame-group) (the-as art-joint-anim (-> this draw art-group data 2)))
       (set! (-> a0-15 frame-num) 1.0)
       (joint-control-channel-group! a0-15 (the-as art-joint-anim (-> this draw art-group data 2)) num-func-identity)
       )
     (transform-post)
     (go (method-of-object this open))
     )
    (else
      (let ((a0-16 (-> this skel root-channel 0)))
        (set! (-> a0-16 frame-group) (the-as art-joint-anim (-> this draw art-group data 2)))
        (set! (-> a0-16 frame-num) 0.0)
        (joint-control-channel-group! a0-16 (the-as art-joint-anim (-> this draw art-group data 2)) num-func-identity)
        )
      (transform-post)
      (go (method-of-object this idle))
      )
    )
  (none)
  )

;; failed to figure out what this is:
(defskelgroup skel-skatea-jump-pad skatea-jump-pad skatea-jump-pad-lod0-jg skatea-jump-pad-idle-ja
              ((skatea-jump-pad-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15)
              )

;; definition of type skatea-jump-pad
(deftype skatea-jump-pad (bouncer)
  ()
  )

;; definition for method 3 of type skatea-jump-pad
(defmethod inspect ((this skatea-jump-pad))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type bouncer inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 23 of type skatea-jump-pad
;; WARN: Return type mismatch int vs none.
(defmethod init-skeleton! ((this skatea-jump-pad))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-skatea-jump-pad" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  0
  (none)
  )

;; definition for method 24 of type skatea-jump-pad
;; WARN: Return type mismatch int vs none.
(defmethod bouncer-method-24 ((this skatea-jump-pad))
  "TODO - collision stuff"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec crate))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 61440.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 2))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 0)
      (set-vector! (-> v1-8 local-sphere) 0.0 0.0 0.0 12288.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 8))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-10 prim-core action) (collide-action))
      (set-vector! (-> v1-10 local-sphere) 0.0 4096.0 0.0 6144.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate fire (skatea-jump-pad)
  :virtual #t
  :code (behavior ()
    (sound-play "dig-air-lifter")
    (let ((s5-1 (vector<-cspace! (new 'stack-no-clear 'vector) (joint-node skatea-jump-pad-lod0-jg main)))
          (gp-1 (get-process *default-dead-pool* part-tracker #x4000))
          )
      (when gp-1
        (let ((t9-4 (method-of-type part-tracker activate)))
          (t9-4
            (the-as part-tracker gp-1)
            *entity-pool*
            (symbol->string (-> part-tracker symbol))
            (the-as pointer #x70004000)
            )
          )
        (let ((t9-5 run-function-in-process)
              (a0-5 gp-1)
              (a1-4 part-tracker-init)
              (a2-5 (-> *part-group-id-table* 12))
              (a3-2 0)
              (t0-1 #f)
              (t1-1 #f)
              (t2-1 #f)
              (t3-0 *launch-matrix*)
              )
          (set! (-> t3-0 trans quad) (-> s5-1 quad))
          ((the-as (function object object object object object object object object none) t9-5)
           a0-5
           a1-4
           a2-5
           a3-2
           t0-1
           t1-1
           t2-1
           t3-0
           )
          )
        (-> gp-1 ppointer)
        )
      )
    (let ((t9-6 (-> (method-of-type bouncer fire) code)))
      (if t9-6
          ((the-as (function none) t9-6))
          )
      )
    )
  )

;; failed to figure out what this is:
(defskelgroup skel-skatea-floating-ring skatea-floating-ring skatea-floating-ring-lod0-jg skatea-floating-ring-idle-ja
              ((skatea-floating-ring-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 4 0 8)
              )

;; definition of type skatea-floating-ring
(deftype skatea-floating-ring (process-focusable)
  ((pos-y   float)
   (offset  float)
   )
  (:state-methods
    idle
    )
  (:methods
    (skatea-floating-ring-method-28 (_type_) none)
    )
  )

;; definition for method 3 of type skatea-floating-ring
(defmethod inspect ((this skatea-floating-ring))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-focusable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tpos-y: ~f~%" (-> this pos-y))
  (format #t "~2Toffset: ~f~%" (-> this offset))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defstate idle (skatea-floating-ring)
  :virtual #t
  :exit (behavior ()
    '()
    )
  :code sleep-code
  :post (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (if (nonzero? (-> self sound))
          (update! (-> self sound))
          )
      (let* ((a0-1 (-> self part))
             (t9-1 (method-of-object a0-1 spawn))
             (a1-0 (new 'stack-no-clear 'vector))
             )
        (let ((v1-6 (-> self root trans)))
          (let ((a2-0 *up-vector*))
            (let ((a3-1 16384.0))
              (.mov vf7 a3-1)
              )
            (.lvf vf5 (&-> a2-0 quad))
            )
          (.lvf vf4 (&-> v1-6 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> a1-0 quad) vf6)
        (t9-1 a0-1 a1-0)
        )
      (set! (-> self root trans y)
            (+ (-> self pos-y)
               (* 2048.0 (cos (* 18204.445 (+ (-> self offset) (* 0.0033333334 (the float (current-time)))))))
               )
            )
      (transform-post)
      )
    )
  )

;; definition for method 28 of type skatea-floating-ring
;; WARN: Return type mismatch int vs none.
(defmethod skatea-floating-ring-method-28 ((this skatea-floating-ring))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec crate camera-blocker))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-6 prim-core action) (collide-action solid deadly))
      (set! (-> v1-6 transform-index) 3)
      (set-vector! (-> v1-6 local-sphere) 0.0 16384.0 0.0 32768.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; definition for method 11 of type skatea-floating-ring
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this skatea-floating-ring) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (skatea-floating-ring-method-28 this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-skatea-floating-ring" (the-as (pointer uint32) #f))
      )
    (the-as pair 0)
    )
  (logior! (-> this mask) (process-mask crate))
  (set! (-> this pos-y) (-> this root trans y))
  (set! (-> this offset) (rand-vu))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 539) this))
  (set! (-> this sound)
        (new 'process 'ambient-sound (static-sound-spec "fire-ring" :fo-min 10 :fo-max 30) (-> this root trans))
        )
  (go (method-of-object this idle))
  (none)
  )
