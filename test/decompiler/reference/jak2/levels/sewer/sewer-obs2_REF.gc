;;-*-Lisp-*-
(in-package goal)

;; definition of type sew-elevator
(deftype sew-elevator (elevator)
  ((sound-id  sound-id)
   )
  (:methods
    (configure-collision (_type_ symbol) none)
    )
  )

;; definition for method 3 of type sew-elevator
(defmethod inspect ((this sew-elevator))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type elevator inspect)))
    (t9-0 this)
    )
  (format #t "~2Tsound-id: ~D~%" (-> this sound-id))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-elevator sew-elevator sew-elevator-lod0-jg sew-elevator-idle-ja
              ((sew-elevator-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 5.6 9.2)
              )

;; definition for method 30 of type sew-elevator
(defmethod get-art-group ((this sew-elevator))
  "@returns The associated [[art-group]]"
  (art-group-get-by-name *level* "skel-sew-elevator" (the-as (pointer uint32) #f))
  )

;; definition for method 43 of type sew-elevator
(defmethod move-between-points ((this sew-elevator) (arg1 vector) (point-a float) (point-b float))
  "Move between two points on the elevator's path
@param vec TODO not sure
@param point-a The first point fetched from the elevator's path
@param point-b The second point fetched from the path
@see [[path-control]] and [[elevator]]"
  (let ((path-point-a (get-point-in-path! (-> this path) (new 'stack-no-clear 'vector) point-a 'interp))
        (path-point-b (get-point-in-path! (-> this path) (new 'stack-no-clear 'vector) point-b 'interp))
        (elevator-pos (-> this root trans))
        )
    (when (and (< (-> path-point-b y) (-> path-point-a y)) (< (-> arg1 y) (+ -8192.0 (-> elevator-pos y))))
      (let ((s4-2 (vector-! (new 'stack-no-clear 'vector) arg1 elevator-pos)))
        (vector-inv-orient-by-quat! s4-2 s4-2 (-> this root quat))
        (and (< (fabs (-> s4-2 x)) 24576.0) (< 0.0 (-> s4-2 z)) (< (-> s4-2 z) 49152.0))
        )
      )
    )
  )

;; definition for method 45 of type sew-elevator
(defmethod commited-to-ride? ((this sew-elevator))
  "@returns if the target is considered within the elevator area enough to begin descending/ascending"
  (let* ((target *target*)
         (target-proc (if (type? target process-focusable)
                          target
                          )
                      )
         )
    (when target-proc
      (let* ((target-pos (get-trans target-proc 0))
             (dist-from-center (vector-! (new 'stack-no-clear 'vector) target-pos (-> this root trans)))
             )
        (vector-inv-orient-by-quat! dist-from-center dist-from-center (-> this root quat))
        (and (< (fabs (-> dist-from-center x)) 20480.0)
             (< 0.0 (-> dist-from-center z))
             (< (-> dist-from-center z) 40960.0)
             )
        )
      )
    )
  )

;; definition for method 49 of type sew-elevator
;; WARN: Return type mismatch int vs none.
(defmethod configure-collision ((this sew-elevator) (collide-with-jak? symbol))
  "Appropriately sets the collision on the elevator
@param collide-with-jak? If set, the elevator will collide with Jak"
  (let ((prim-group (-> (the-as collide-shape-prim-group (-> this root root-prim)) child 1)))
    (cond
      (collide-with-jak?
        (set! (-> prim-group prim-core collide-as) (collide-spec obstacle pusher))
        (set! (-> prim-group prim-core collide-with) (collide-spec jak player-list))
        )
      (else
        (set! (-> prim-group prim-core collide-as) (collide-spec))
        (set! (-> prim-group prim-core collide-with) (collide-spec))
        0
        )
      )
    )
  (none)
  )

;; failed to figure out what this is:
(defstate running (sew-elevator)
  :virtual #t
  :enter (behavior ()
    (let ((func (-> (method-of-type elevator running) enter)))
      (if func
          (func)
          )
      )
    (when (and (logtest? (-> self elevator-status) (elevator-status waiting-to-descend))
               (logtest? (elevator-flags airlock-opened) (-> self params flags))
               )
      (configure-collision self #t)
      (set-setting! 'jump #f 0.0 0)
      )
    )
  :post (behavior ()
    (let ((func (-> (method-of-type elevator running) post)))
      (if func
          ((the-as (function none) func))
          )
      )
    (sound-play "sew-elevator-lp" :id (-> self sound-id) :position (-> self root trans))
    )
  )

;; failed to figure out what this is:
(defstate arrived (sew-elevator)
  :virtual #t
  :enter (behavior ()
    (let ((func (-> (method-of-type elevator arrived) enter)))
      (if func
          (func)
          )
      )
    (sound-stop (-> self sound-id))
    (sound-play "sew-elev-stop")
    (when (and (logtest? (-> self elevator-status) (elevator-status waiting-to-descend))
               (logtest? (elevator-flags airlock-opened) (-> self params flags))
               )
      (configure-collision self #f)
      (remove-setting! 'jump)
      )
    )
  )

;; definition for method 10 of type sew-elevator
(defmethod deactivate ((this sew-elevator))
  (sound-stop (-> this sound-id))
  (call-parent-method this)
  (none)
  )

;; definition for method 33 of type sew-elevator
;; WARN: Return type mismatch int vs none.
(defmethod init-plat! ((this sew-elevator))
  "Does any necessary initial platform setup.
For example for an elevator pre-compute the distance between the first and last points (both ways) and clear the sound."
  (set! (-> this sound-id) (new-sound-id))
  0
  (none)
  )

;; definition for method 41 of type sew-elevator
;; WARN: Return type mismatch int vs none.
(defmethod init-defaults! ((this sew-elevator))
  "Initializes default settings related to the [[elevator]]:
- `elevator-xz-threshold`
- `elevator-y-threshold`
- `elevator-start-pos`
- `elevator-move-rate`
- `elevator-flags`"
  (let ((func (method-of-type elevator init-defaults!)))
    (func this)
    )
  (if (name= (-> this name) "sew-elevator-15")
      (set! (-> this params xz-threshold) 348160.0)
      (set! (-> this params xz-threshold) 184320.0)
      )
  (when (and (logtest? (elevator-flags elevator-flags-17) (-> this params flags))
             (and (task-node-closed? (game-task-node sewer-escort-introduction))
                  (not (task-node-closed? (game-task-node sewer-escort-resolution)))
                  )
             )
    (set! (-> this params start-pos) 0.0)
    (logior! (-> this params flags) (elevator-flags elevator-flags-3))
    )
  0
  (none)
  )

;; definition for method 31 of type sew-elevator
(defmethod init-plat-collision! ((this sew-elevator))
  "TODO - collision stuff for setting up the platform"
  (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) cshape-reaction-default)
    (set! (-> cshape no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((prim-group (new 'process 'collide-shape-prim-group cshape (the-as uint 2) 0)))
      (set! (-> cshape total-prims) (the-as uint 3))
      (set! (-> prim-group prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> prim-group prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> prim-group prim-core action) (collide-action solid rideable))
      (set! (-> prim-group transform-index) 3)
      (set-vector! (-> prim-group local-sphere) 0.0 0.0 22937.6 37683.2)
      (set! (-> cshape root-prim) prim-group)
      )
    (pusher-init cshape)
    (let ((prim-mesh-1 (new 'process 'collide-shape-prim-mesh cshape (the-as uint 0) (the-as uint 0))))
      (set! (-> prim-mesh-1 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> prim-mesh-1 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> prim-mesh-1 prim-core action) (collide-action solid rideable))
      (set! (-> prim-mesh-1 transform-index) 3)
      (set-vector! (-> prim-mesh-1 local-sphere) 0.0 0.0 22937.6 37683.2)
      )
    (let ((prim-mesh-2 (new 'process 'collide-shape-prim-mesh cshape (the-as uint 1) (the-as uint 0))))
      (set! (-> prim-mesh-2 prim-core action) (collide-action solid))
      (set! (-> prim-mesh-2 transform-index) 3)
      (set-vector! (-> prim-mesh-2 local-sphere) 0.0 0.0 22937.6 39321.6)
      )
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (let ((root-prim (-> cshape root-prim)))
      (set! (-> cshape backup-collide-as) (-> root-prim prim-core collide-as))
      (set! (-> cshape backup-collide-with) (-> root-prim prim-core collide-with))
      )
    (set! (-> this root) cshape)
    )
  (configure-collision this #f)
  (none)
  )

;; definition of type sew-valve
(deftype sew-valve (process-drawable)
  ((joint              joint-mod-rotate-local)
   (actor-group        (pointer actor-group))
   (actor-group-count  int32)
   (water-height       float)
   (spin               float)
   (spin-rate          float)
   )
  (:state-methods
    idle
    turn
    )
  )

;; definition for method 3 of type sew-valve
(defmethod inspect ((this sew-valve))
  (when (not this)
    (set! this this)
    (goto cfg-7)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tjoint: ~A~%" (-> this joint))
  (format #t "~2Tactor-group: #x~X~%" (-> this actor-group))
  (dotimes (s5-0 (-> this actor-group-count))
    (format #t "~T  [~D]~2Tactor-group: ~`actor-group`P~%" s5-0 (-> this actor-group s5-0))
    )
  (format #t "~2Tactor-group-count: ~D~%" (-> this actor-group-count))
  (format #t "~2Twater-height: ~f~%" (-> this water-height))
  (format #t "~2Tspin: ~f~%" (-> this spin))
  (format #t "~2Tspin-rate: ~f~%" (-> this spin-rate))
  (label cfg-7)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-valve sew-valve sew-valve-lod0-jg sew-valve-idle-ja
              ((sew-valve-lod0-mg (meters 20)) (sew-valve-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 2)
              )

;; failed to figure out what this is:
(defstate idle (sew-valve)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (case (-> (the-as attack-info (-> block param 1)) mode)
         (('spin 'punch 'flop 'uppercut)
          (if (!= (-> self water-height) (get-base-height *ocean-map-sewer*))
              (go-virtual turn)
              )
          )
         )
       )
      )
    )
  :code transform-and-sleep
  )

;; failed to figure out what this is:
(defstate turn (sew-valve)
  :virtual #t
  :enter (behavior ()
    (set! (-> self joint enable) #t)
    (set! (-> self spin-rate) 196608.0)
    (logclear! (-> self mask) (process-mask actor-pause))
    (sound-play "sew-valve")
    (dotimes (group-idx (-> self actor-group-count))
      (dotimes (actor-idx (-> self actor-group group-idx length))
        (let ((actor (-> self actor-group group-idx data actor-idx actor)))
          (if actor
              (logior! (-> actor extra perm status) (entity-perm-status bit-10))
              )
          )
        )
      )
    (let ((data (res-lump-struct (-> self entity) 'on-activate structure)))
      (if data
          (script-eval (the-as pair data))
          )
      )
    )
  :exit (behavior ()
    (set! (-> self joint enable) #f)
    (logior! (-> self mask) (process-mask actor-pause))
    )
  :trans (behavior ()
    (if (= (-> self water-height) (get-base-height *ocean-map-sewer*))
        (go-virtual idle)
        )
    )
  :code sleep-code
  :post (behavior ()
    (seek! (-> self spin-rate) 0.0 (* 81920.0 (seconds-per-frame)))
    (+! (-> self spin) (* (-> self spin-rate) (seconds-per-frame)))
    (quaternion-axis-angle! (-> self joint rotation) 0.0 0.0 1.0 (-> self spin))
    (let* ((f0-8 (- (get-base-height *ocean-map-sewer*) (-> self water-height)))
           (f30-0 f0-8)
           (f28-0 (seek-ease
                    f0-8
                    0.0
                    (* (lerp 21299.2 8192.0 (* 0.000005086263 (-> self spin-rate))) (seconds-per-frame))
                    12288.0
                    2.0
                    )
                  )
           )
      (set-height! *ocean-map-sewer* (+ (-> self water-height) f28-0))
      (if (and *target* (focus-test? *target* board) (focus-test? *target* touch-water))
          (+! (-> *target* control trans y) (- f28-0 f30-0))
          )
      )
    (ja-post)
    )
  )

;; definition for method 7 of type sew-valve
(defmethod relocate ((this sew-valve) (arg0 int))
  (if (nonzero? (-> this joint))
      (&+! (-> this joint) arg0)
      )
  (call-parent-method this arg0)
  )

;; definition for method 11 of type sew-valve
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this sew-valve) (entity entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (tag-1 res-tag) (tag-2 res-tag))
  (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) cshape-reaction-default)
    (set! (-> cshape no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((prim-sphere (new 'process 'collide-shape-prim-sphere cshape (the-as uint 0))))
      (set! (-> prim-sphere prim-core collide-as) (collide-spec obstacle))
      (set! (-> prim-sphere prim-core collide-with) (collide-spec jak player-list))
      (set! (-> prim-sphere prim-core action) (collide-action solid))
      (set! (-> prim-sphere transform-index) 3)
      (set-vector! (-> prim-sphere local-sphere) 0.0 0.0 1638.4 3276.8)
      (set! (-> cshape total-prims) (the-as uint 1))
      (set! (-> cshape root-prim) prim-sphere)
      )
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (let ((root-prim (-> cshape root-prim)))
      (set! (-> cshape backup-collide-as) (-> root-prim prim-core collide-as))
      (set! (-> cshape backup-collide-with) (-> root-prim prim-core collide-with))
      )
    (set! (-> this root) cshape)
    )
  (process-drawable-from-entity! this entity)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-valve" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this spin) 0.0)
  (set! (-> this spin-rate) 0.0)
  (set! (-> this joint) (new 'process 'joint-mod-rotate-local this 4 #f))
  (set! tag-1 (new 'static 'res-tag))
  (set! (-> this actor-group)
        (res-lump-data (-> this entity) 'actor-groups (pointer actor-group) :tag-ptr (& tag-1))
        )
  (set! (-> this actor-group-count) (the-as int (-> tag-1 elt-count)))
  (set! tag-2 (new 'static 'res-tag))
  (let ((data (res-lump-data (-> this entity) 'extra-float-param pointer :tag-ptr (& tag-2))))
    (if (and data (nonzero? (-> tag-2 elt-count)))
        (set! (-> this water-height) (-> (the-as (pointer float) data)))
        (set! (-> this water-height) 0.0)
        )
    )
  (format #t "~S water-height: ~m~%" (-> this name) (-> this water-height))
  (+! (-> this water-height) -216498.17)
  (go (method-of-object this idle))
  (none)
  )

;; definition of type sew-mar-statue-debris
(deftype sew-mar-statue-debris (process-drawable)
  ()
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type sew-mar-statue-debris
(defmethod inspect ((this sew-mar-statue-debris))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition of type sew-mar-statue-debris-b
(deftype sew-mar-statue-debris-b (process-drawable)
  ()
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type sew-mar-statue-debris-b
(defmethod inspect ((this sew-mar-statue-debris-b))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition of type sew-mar-statue
(deftype sew-mar-statue (process-drawable)
  ((root             collide-shape :override)
   (spawned-debris?  symbol)
   )
  (:state-methods
    idle
    hidden
    )
  )

;; definition for method 3 of type sew-mar-statue
(defmethod inspect ((this sew-mar-statue))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tspawned-debris?: ~A~%" (-> this spawned-debris?))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-mar-statue sew-mar-statue sew-mar-statue-lod0-jg sew-mar-statue-idle-ja
              ((sew-mar-statue-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 7.5 0 14.4)
              )

;; failed to figure out what this is:
(defskelgroup skel-sew-mar-statue-explode-a sew-mar-statue-explode sew-mar-statue-explode-a-lod0-jg sew-mar-statue-explode-a-idle-ja
              ((sew-mar-statue-explode-a-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 50)
              :origin-joint-index 4
              )

;; failed to figure out what this is:
(defskelgroup skel-sew-mar-statue-explode-b sew-mar-statue-explode sew-mar-statue-explode-b-lod0-jg sew-mar-statue-explode-b-idle-ja
              ((sew-mar-statue-explode-b-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 50)
              :origin-joint-index 6
              )

;; failed to figure out what this is:
(defstate idle (sew-mar-statue-debris)
  :virtual #t
  :code sleep-code
  )

;; definition for function sew-mar-statue-debris-init-by-other
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defbehavior sew-mar-statue-debris-init-by-other sew-mar-statue-debris ()
  "Initializes a [[sew-mar-statue--debris]]"
  (let ((cshape (new 'process 'collide-shape self (collide-list-enum hit-by-player))))
    (let ((prim-group (new 'process 'collide-shape-prim-group cshape (the-as uint 3) 0)))
      (set! (-> cshape total-prims) (the-as uint 4))
      (set! (-> prim-group prim-core collide-as) (collide-spec obstacle))
      (set! (-> prim-group prim-core collide-with) (collide-spec jak player-list))
      (set! (-> prim-group prim-core action) (collide-action solid))
      (set! (-> prim-group transform-index) 3)
      (set-vector! (-> prim-group local-sphere) 10240.0 0.0 62464.0 151552.0)
      (set! (-> cshape root-prim) prim-group)
      )
    (let ((prim-mesh-1 (new 'process 'collide-shape-prim-mesh cshape (the-as uint 0) (the-as uint 0))))
      (set! (-> prim-mesh-1 prim-core collide-as) (collide-spec obstacle))
      (set! (-> prim-mesh-1 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> prim-mesh-1 prim-core action) (collide-action solid))
      (set! (-> prim-mesh-1 transform-index) 3)
      (set-vector! (-> prim-mesh-1 local-sphere) 0.0 0.0 20480.0 81920.0)
      )
    (let ((prim-mesh-2 (new 'process 'collide-shape-prim-mesh cshape (the-as uint 1) (the-as uint 0))))
      (set! (-> prim-mesh-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> prim-mesh-2 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> prim-mesh-2 prim-core action) (collide-action solid))
      (set! (-> prim-mesh-2 transform-index) 3)
      (set-vector! (-> prim-mesh-2 local-sphere) -49152.0 0.0 114688.0 61440.0)
      )
    (let ((prim-mesh-3 (new 'process 'collide-shape-prim-mesh cshape (the-as uint 2) (the-as uint 0))))
      (set! (-> prim-mesh-3 prim-core collide-as) (collide-spec obstacle))
      (set! (-> prim-mesh-3 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> prim-mesh-3 prim-core action) (collide-action solid))
      (set! (-> prim-mesh-3 transform-index) 3)
      (set-vector! (-> prim-mesh-3 local-sphere) 69632.0 0.0 102400.0 73728.0)
      )
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (let ((root-prim (-> cshape root-prim)))
      (set! (-> cshape backup-collide-as) (-> root-prim prim-core collide-as))
      (set! (-> cshape backup-collide-with) (-> root-prim prim-core collide-with))
      )
    (set! (-> self root) cshape)
    )
  (let ((parent-proc (ppointer->process (-> self parent))))
    (set! (-> self root trans quad) (-> (the-as process-drawable parent-proc) root trans quad))
    (quaternion-copy! (-> self root quat) (-> (the-as process-drawable parent-proc) root quat))
    (set! (-> self root scale quad) (-> (the-as process-drawable parent-proc) root scale quad))
    )
  (initialize-skeleton
    self
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-sew-mar-statue-explode-a" (the-as (pointer uint32) #f))
      )
    (the-as pair 0)
    )
  (set! (-> self draw light-index) (the-as uint 10))
  (transform-post)
  (go-virtual idle)
  (none)
  )

;; failed to figure out what this is:
(defstate idle (sew-mar-statue-debris-b)
  :virtual #t
  :code sleep-code
  )

;; definition for function sew-mar-statue-debris-b-init-by-other
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defbehavior sew-mar-statue-debris-b-init-by-other sew-mar-statue-debris-b ()
  "Initializes a [[sew-mar-statue--debris-b]]"
  (set! (-> self root) (new 'process 'trsqv))
  (let ((parent-proc (ppointer->process (-> self parent))))
    (set! (-> self root trans quad) (-> (the-as process-drawable parent-proc) root trans quad))
    (quaternion-copy! (-> self root quat) (-> (the-as process-drawable parent-proc) root quat))
    (set! (-> self root scale quad) (-> (the-as process-drawable parent-proc) root scale quad))
    )
  (initialize-skeleton
    self
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-sew-mar-statue-explode-b" (the-as (pointer uint32) #f))
      )
    (the-as pair 0)
    )
  (set! (-> self draw light-index) (the-as uint 10))
  (ja-post)
  (go-virtual idle)
  (none)
  )

;; definition for function sew-mar-statue-event-handler
(defbehavior sew-mar-statue-event-handler sew-mar-statue ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  "Event handler for the [[sew-mar-statue]], normally hidden, but once `trigger`ed it will spawn the debris"
  (case arg2
    (('hide)
     (if (not (and (-> self next-state) (= (-> self next-state name) 'hidden)))
         (go-virtual hidden)
         )
     )
    (('trigger)
     (when (not (-> self spawned-debris?))
       (set! (-> self spawned-debris?) #t)
       (process-spawn sew-mar-statue-debris :to self)
       (process-spawn sew-mar-statue-debris-b :to self)
       )
     )
    )
  )

;; definition for method 12 of type sew-mar-statue
(defmethod run-logic? ((this sew-mar-statue))
  #t
  )

;; failed to figure out what this is:
(defstate idle (sew-mar-statue)
  :virtual #t
  :event sew-mar-statue-event-handler
  :trans (behavior ()
    (if (< (get-base-height *ocean-map-sewer*) -286720.0)
        (setup-masks (-> self draw) 4 2)
        (setup-masks (-> self draw) 2 4)
        )
    )
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate hidden (sew-mar-statue)
  :virtual #t
  :event sew-mar-statue-event-handler
  :enter (behavior ()
    (let ((root-prim (-> self root root-prim)))
      (set! (-> root-prim prim-core collide-as) (collide-spec))
      (set! (-> root-prim prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self draw status) (draw-control-status no-draw))
    )
  :code sleep-code
  )

;; definition for method 11 of type sew-mar-statue
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this sew-mar-statue) (entity entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> this spawned-debris?) #f)
  (let ((cshape (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((prim-mesh (new 'process 'collide-shape-prim-mesh cshape (the-as uint 0) (the-as uint 0))))
      (set! (-> prim-mesh prim-core collide-as) (collide-spec obstacle))
      (set! (-> prim-mesh prim-core collide-with) (collide-spec jak player-list))
      (set! (-> prim-mesh prim-core action) (collide-action solid))
      (set! (-> prim-mesh transform-index) 0)
      (set-vector! (-> prim-mesh local-sphere) 0.0 30720.0 0.0 58982.4)
      (set! (-> cshape total-prims) (the-as uint 1))
      (set! (-> cshape root-prim) prim-mesh)
      )
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (let ((root-prim (-> cshape root-prim)))
      (set! (-> cshape backup-collide-as) (-> root-prim prim-core collide-as))
      (set! (-> cshape backup-collide-with) (-> root-prim prim-core collide-with))
      )
    (set! (-> this root) cshape)
    )
  (process-drawable-from-entity! this entity)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-mar-statue" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (transform-post)
  (set! (-> this event-hook) sew-mar-statue-event-handler)
  (cond
    ((task-node-closed? (game-task-node sewer-escort-resolution))
     (process-spawn sew-mar-statue-debris :to this)
     (process-spawn sew-mar-statue-debris-b :to this)
     (set! (-> this spawned-debris?) #t)
     (go (method-of-object this hidden))
     )
    (else
      (go (method-of-object this idle))
      )
    )
  (none)
  )

;; definition of type sew-catwalk
(deftype sew-catwalk (drop-plat)
  ()
  )

;; definition for method 3 of type sew-catwalk
(defmethod inspect ((this sew-catwalk))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type drop-plat inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-catwalk-1 sew-catwalk sew-catwalk-1-lod0-jg sew-catwalk-1-idle-ja
              ((sew-catwalk-1-lod0-mg (meters 20)) (sew-catwalk-1-lod1-mg (meters 999999)))
              :bounds (static-spherem -7 5 -25 18)
              :origin-joint-index 3
              )

;; definition for method 29 of type sew-catwalk
;; WARN: Return type mismatch int vs none.
(defmethod start-bouncing! ((this sew-catwalk))
  "Sets `bouncing` to [[#t]] and sets up the clock to periodically bounce
and translate the platform via the `smush`
@see [[smush-control]]"
  (logclear! (-> this mask) (process-mask sleep))
  (logclear! (-> this mask) (process-mask sleep-code))
  0
  (none)
  )

;; failed to figure out what this is:
(defstate fall (sew-catwalk)
  :virtual #t
  :trans rider-trans
  :code (behavior ((arg0 symbol))
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (set! (-> self draw bounds y) -102400.0)
    (set! (-> self draw bounds w) 163840.0)
    (set! (-> self root root-prim local-sphere w) 163840.0)
    (set! (-> self draw force-lod) 0)
    (let* ((art-group (-> self draw art-group))
           (art (method-of-object art-group get-art-by-name-method))
           )
      (format (clear *temp-string*) "~S-end" (-> self art-name))
      (let ((anim (the-as object (art art-group *temp-string* art-joint-anim))))
        (if (not arg0)
            (ja-play-spooled-anim
              (-> self anim)
              (ja-group)
              (the-as art-joint-anim anim)
              (the-as (function process-drawable symbol) false-func)
              )
            )
        (ja-channel-set! 1)
        (set! (-> self skel root-channel 0 frame-group) (the-as art-joint-anim anim))
        )
      )
    (suspend)
    (logior! (-> self mask) (process-mask sleep))
    (suspend)
    0
    )
  )

;; definition for method 11 of type sew-catwalk
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this sew-catwalk) (entity entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (sv-16 collide-shape-prim-mesh) (sv-32 symbol) (sv-48 type) (sv-64 collide-shape-moving))
  (stack-size-set! (-> this main-thread) 512)
  (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) cshape-reaction-default)
    (set! (-> cshape no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((prim-group (new 'process 'collide-shape-prim-group cshape (the-as uint 14) 0)))
      (set! (-> cshape total-prims) (the-as uint 15))
      (set! (-> prim-group prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> prim-group prim-core collide-with) (collide-spec jak player-list))
      (set! (-> prim-group prim-core action) (collide-action solid))
      (set! (-> prim-group transform-index) 3)
      (set-vector! (-> prim-group local-sphere) -28672.0 20480.0 -102400.0 73728.0)
      (set! (-> cshape root-prim) prim-group)
      (pusher-init cshape)
      (let* ((s2-0
               '((0 4 28672)
                 (1 5 28672)
                 (2 6 28672)
                 (3 7 28672)
                 (4 8 28672)
                 (5 9 28672)
                 (6 10 28672)
                 (7 11 28672)
                 (8 12 28672)
                 (9 13 28672)
                 (10 14 28672)
                 (11 15 28672)
                 (12 16 28672)
                 (13 17 28672)
                 )
               )
             (s1-0 (car s2-0))
             )
        (while (not (null? s2-0))
          (let ((_prim-mesh (method-of-type collide-shape-prim-mesh new)))
            (set! sv-32 'process)
            (set! sv-48 collide-shape-prim-mesh)
            (set! sv-64 cshape)
            (let ((a3-2 (command-get-int (car s1-0) 0))
                  (t0-1 0)
                  )
              (set! sv-16 (_prim-mesh sv-32 sv-48 sv-64 (the-as uint a3-2) (the-as uint t0-1)))
              )
            )
          (let ((s0-1 sv-16))
            (set! (-> s0-1 prim-core collide-as) (-> prim-group prim-core collide-as))
            (set! (-> s0-1 prim-core collide-with) (-> prim-group prim-core collide-with))
            (set! (-> s0-1 prim-core action) (-> prim-group prim-core action))
            (set! (-> s0-1 transform-index) (command-get-int (car (cdr s1-0)) 0))
            )
          (set-vector! (-> sv-16 local-sphere) 0.0 0.0 0.0 (command-get-float (car (cdr (cdr s1-0))) 0.0))
          (set! s2-0 (cdr s2-0))
          (set! s1-0 (car s2-0))
          )
        )
      )
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (let ((root-prim (-> cshape root-prim)))
      (set! (-> cshape backup-collide-as) (-> root-prim prim-core collide-as))
      (set! (-> cshape backup-collide-with) (-> root-prim prim-core collide-with))
      )
    (set! (-> this root) cshape)
    )
  (process-drawable-from-entity! this entity)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-catwalk-1" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this art-name) "sew-catwalk-1")
  (set! (-> this anim)
        (new 'static 'spool-anim :name "sew-catwalk-1" :anim-name "1-break" :parts 3 :command-list '())
        )
  (set! (-> this basetrans quad) (-> this root trans quad))
  (if (and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete)))
      (go (method-of-object this fall) #t)
      (go (method-of-object this idle))
      )
  (none)
  )

;; definition of type sew-mine
(deftype sew-mine (process-drawable)
  ((root       collide-shape-moving :override)
   (last-time  time-frame)
   )
  (:state-methods
    idle
    die
    )
  (:methods
    (init-mine! (_type_) none)
    )
  )

;; definition for method 3 of type sew-mine
(defmethod inspect ((this sew-mine))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tlast-time: ~D~%" (-> this last-time))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defstate idle (sew-mine)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch 'attack)
       (let* ((_proc proc)
              (focus-proc (if (type? _proc process-focusable)
                              (the-as process-focusable _proc)
                              )
                          )
              )
         (when focus-proc
           (let ((a0-4
                   (vector-normalize!
                     (vector-! (new 'stack-no-clear 'vector) (-> focus-proc root trans) (-> self root trans))
                     1.0
                     )
                   )
                 )
             (send-event
               focus-proc
               'attack-or-shove
               (-> block param 0)
               (static-attack-info ((id (new-attack-id))
                                    (vector a0-4)
                                    (shove-back (meters 5))
                                    (shove-up (meters 3))
                                    (control (if (focus-test? focus-proc board)
                                                 1.0
                                                 0.0
                                                 )
                                             )
                                    )
                                   )
               )
             )
           )
         )
       (go-virtual die)
       )
      )
    )
  :code transform-and-sleep-code
  :post (behavior ()
    (spawn (-> self part) (-> self root trans))
    (let ((gp-0 (mod (-> *display* part-clock frame-counter) 100)))
      (if (< gp-0 (-> self last-time))
          (sound-play "sew-mine-flash")
          )
      (set! (-> self last-time) (the-as time-frame gp-0))
      )
    )
  )

;; failed to figure out what this is:
(defstate die (sew-mine)
  :virtual #t
  :code (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self draw status) (draw-control-status no-draw))
    (sound-play "sew-mine-b")
    (process-spawn touch-tracker :init touch-tracker-init (-> self root trans) #x47200000 30 :to self)
    (let ((part (get-process *default-dead-pool* part-tracker #x4000)))
      (when part
        (let ((func (method-of-type part-tracker activate)))
          (func (the-as part-tracker part) self (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
          )
        (let ((t9-7 run-function-in-process)
              (a0-8 part)
              (a1-6 part-tracker-init)
              (a2-10 (-> *part-group-id-table* 124))
              (a3-4 0)
              (t0-2 #f)
              (t1-1 #f)
              (t2-1 #f)
              (t3-0 *launch-matrix*)
              )
          (set! (-> t3-0 trans quad) (-> self root trans quad))
          ((the-as (function object object object object object object object object none) t9-7)
           a0-8
           a1-6
           a2-10
           a3-4
           t0-2
           t1-1
           t2-1
           t3-0
           )
          )
        (-> part ppointer)
        )
      )
    (cleanup-for-death self)
    (let ((frame-counter (current-time)))
      (until (time-elapsed? frame-counter (seconds 2))
        (suspend)
        )
      )
    )
  )

;; definition for method 22 of type sew-mine
;; WARN: Return type mismatch int vs none.
(defmethod init-mine! ((this sew-mine))
  "Initializes the mine's particles and sets `last-time` to `0`"
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 345) this))
  (set! (-> this last-time) 0)
  0
  (none)
  )

;; definition of type sew-mine-a
(deftype sew-mine-a (sew-mine)
  ()
  )

;; definition for method 3 of type sew-mine-a
(defmethod inspect ((this sew-mine-a))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type sew-mine inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-mine-a sew-mine-a sew-mine-a-lod0-jg sew-mine-a-idle-ja
              ((sew-mine-a-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

;; definition for method 11 of type sew-mine-a
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this sew-mine-a) (entity entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((cshape (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((prim-mesh (new 'process 'collide-shape-prim-mesh cshape (the-as uint 0) (the-as uint 0))))
      (set! (-> prim-mesh prim-core collide-as) (collide-spec pusher))
      (set! (-> prim-mesh prim-core collide-with) (collide-spec jak player-list))
      (set! (-> prim-mesh prim-core action) (collide-action solid deadly))
      (set! (-> prim-mesh transform-index) 0)
      (set-vector! (-> prim-mesh local-sphere) 0.0 2048.0 0.0 8192.0)
      (set! (-> cshape total-prims) (the-as uint 1))
      (set! (-> cshape root-prim) prim-mesh)
      )
    (pusher-init cshape)
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (let ((root-prim (-> cshape root-prim)))
      (set! (-> cshape backup-collide-as) (-> root-prim prim-core collide-as))
      (set! (-> cshape backup-collide-with) (-> root-prim prim-core collide-with))
      )
    (set! (-> this root) (the-as collide-shape-moving cshape))
    )
  (process-drawable-from-entity! this entity)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-mine-a" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-mine! this)
  (go (method-of-object this idle))
  (none)
  )

;; definition of type sew-mine-b
(deftype sew-mine-b (sew-mine)
  ((base-height  float)
   (center       vector  :inline)
   (time-skew    uint64)
   (period       float)
   )
  )

;; definition for method 3 of type sew-mine-b
(defmethod inspect ((this sew-mine-b))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type sew-mine inspect)))
    (t9-0 this)
    )
  (format #t "~2Tbase-height: ~f~%" (-> this base-height))
  (format #t "~2Tcenter: #<vector @ #x~X>~%" (-> this center))
  (format #t "~2Ttime-skew: ~D~%" (-> this time-skew))
  (format #t "~2Tperiod: ~f~%" (-> this period))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-mine-b sew-mine-b sew-mine-b-lod0-jg sew-mine-b-idle-ja
              ((sew-mine-b-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 2.5)
              )

;; failed to figure out what this is:
(defstate idle (sew-mine-b)
  :virtual #t
  :post (behavior ()
    (let ((func (-> (method-of-type sew-mine idle) post)))
      (if func
          ((the-as (function none) func))
          )
      )
    (let* ((ocean-base-height (get-base-height *ocean-map-sewer*))
           (period (-> self period))
           (t9-2 sin-rad)
           (f1-0 -3.1415925)
           (f2-0 6.283185)
           (f3-1 (the float (+ (current-time) (the-as time-frame (-> self time-skew)))))
           (f28-0 (t9-2 (+ f1-0 (* f2-0 (/ (- f3-1 (* (the float (the int (/ f3-1 period))) period)) period)))))
           )
      (when (< ocean-base-height (-> self center y))
        (set! (-> self center y) ocean-base-height)
        (if (>= (-> self base-height) (-> self center y))
            (go-virtual die)
            )
        )
      (set! (-> self root trans quad) (-> self center quad))
      (set! (-> self root trans y) (+ (-> self center y) (* 819.2 f28-0)))
      )
    (transform-post)
    )
  )

;; definition for method 11 of type sew-mine-b
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this sew-mine-b) (entity entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((cshape (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((prim-mesh (new 'process 'collide-shape-prim-mesh cshape (the-as uint 0) (the-as uint 0))))
      (set! (-> prim-mesh prim-core collide-as) (collide-spec pusher))
      (set! (-> prim-mesh prim-core collide-with) (collide-spec jak player-list))
      (set! (-> prim-mesh prim-core action) (collide-action solid deadly))
      (set! (-> prim-mesh transform-index) 0)
      (set-vector! (-> prim-mesh local-sphere) 0.0 2048.0 0.0 8192.0)
      (set! (-> cshape total-prims) (the-as uint 1))
      (set! (-> cshape root-prim) prim-mesh)
      )
    (pusher-init cshape)
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (let ((root-prim (-> cshape root-prim)))
      (set! (-> cshape backup-collide-as) (-> root-prim prim-core collide-as))
      (set! (-> cshape backup-collide-with) (-> root-prim prim-core collide-with))
      )
    (set! (-> this root) (the-as collide-shape-moving cshape))
    )
  (process-drawable-from-entity! this entity)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-mine-b" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-mine! this)
  (let ((_entity (-> this entity)))
    (set! (-> this base-height) ((method-of-object _entity get-property-value-float)
                                 _entity
                                 'base-height
                                 'interp
                                 -1000000000.0
                                 -16384000.0
                                 (the-as (pointer res-tag) #f)
                                 *res-static-buf*
                                 )
          )
    )
  (set! (-> this time-skew) (the-as uint (the int (* 300.0 (rand-vu-float-range 0.1 1.4)))))
  (set! (-> this period) (* 300.0 (rand-vu-float-range 1.2 1.8)))
  (set! (-> this center quad) (-> this root trans quad))
  (+! (-> this base-height) -216498.17)
  (set! (-> this root pause-adjust-distance) 532480.0)
  (go (method-of-object this idle))
  (none)
  )

;; definition of type sew-wall
(deftype sew-wall (process-focusable)
  ((deadly-radius       float)
   (prev-deadly-radius  float)
   (attack-id           uint32)
   (first-wall?         symbol)
   (anim                spool-anim)
   (art-name            string)
   )
  (:state-methods
    idle
    (hit symbol)
    )
  (:methods
    (attack-target! (_type_) none)
    )
  )

;; definition for method 3 of type sew-wall
(defmethod inspect ((this sew-wall))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-focusable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tdeadly-radius: ~f~%" (-> this deadly-radius))
  (format #t "~2Tprev-deadly-radius: ~f~%" (-> this prev-deadly-radius))
  (format #t "~2Tattack-id: ~D~%" (-> this attack-id))
  (format #t "~2Tfirst-wall?: ~A~%" (-> this first-wall?))
  (format #t "~2Tanim: ~A~%" (-> this anim))
  (format #t "~2Tart-name: ~A~%" (-> this art-name))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-wall sew-wall sew-wall-lod0-jg -1
              ((sew-wall-lod0-mg (meters 20)) (sew-wall-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 10)
              :origin-joint-index 4
              )

;; definition for method 29 of type sew-wall
;; INFO: Used lq/sq
;; WARN: Return type mismatch float vs none.
(defmethod attack-target! ((this sew-wall))
  "If the target is close enough to the wall, hit it!"
  (let ((target *target*))
    (when target
      (let ((dist-from-wall (vector-vector-xz-distance (get-trans target 0) (-> this root trans)))
            (deadly-radius (-> this deadly-radius))
            (prev-deadly-radius (-> this prev-deadly-radius))
            )
        (set! (-> this prev-deadly-radius) deadly-radius)
        (when (and (>= deadly-radius dist-from-wall) (>= dist-from-wall (+ -4096.0 prev-deadly-radius)))
          (let ((cquery (new 'stack-no-clear 'collide-query)))
            (set! (-> cquery start-pos quad) (-> this root trans quad))
            (+! (-> cquery start-pos y) 12288.0)
            (vector-! (-> cquery move-dist) (get-trans target 3) (-> cquery start-pos))
            (let ((v1-9 cquery))
              (set! (-> v1-9 radius) 819.2)
              (set! (-> v1-9 collide-with) (collide-spec backgnd))
              (set! (-> v1-9 ignore-process0) this)
              (set! (-> v1-9 ignore-process1) #f)
              (set! (-> v1-9 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
              (set! (-> v1-9 action-mask) (collide-action solid))
              )
            (when (< (fill-and-probe-using-line-sphere *collide-cache* cquery) 0.0)
              (send-event
                *target*
                'attack
                #f
                (static-attack-info ((id (-> this attack-id)) (mode 'explode) (attacker-velocity (-> cquery move-dist))))
                )
              (set! (-> this deadly-radius) -1.0)
              )
            )
          )
        )
      )
    )
  (none)
  )

;; failed to figure out what this is:
(defstate idle (sew-wall)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (logclear! (-> self mask) (process-mask actor-pause))
       (if (-> self first-wall?)
           (task-node-close! (game-task-node sewer-escort-explode-wall1))
           )
       (go-virtual hit #f)
       )
      (('hide)
       (logior! (-> self draw status) (draw-control-status no-draw))
       #t
       )
      )
    )
  :code (behavior ()
    (add-process *gui-control* self (gui-channel art-load) (gui-action queue) (-> self anim name) -99.0 0)
    (until #f
      (transform-post)
      (logior! (-> self mask) (process-mask sleep))
      (suspend)
      )
    #f
    )
  )

;; failed to figure out what this is:
(defstate hit (sew-wall)
  :virtual #t
  :enter (behavior ((arg0 symbol))
    (set! (-> self deadly-radius) -1.0)
    (logclear! (-> self draw status) (draw-control-status no-draw))
    )
  :exit (behavior ()
    (ja-abort-spooled-anim (-> self anim) (the-as art-joint-anim #f) -1)
    )
  :trans (behavior ()
    (let ((f0-0 (-> self deadly-radius)))
      (when (>= f0-0 0.0)
        (set! (-> self deadly-radius) (seek f0-0 409600.0 (* 368640.0 (seconds-per-frame))))
        (attack-target! self)
        )
      )
    )
  :code (behavior ((arg0 symbol))
    (if (not (-> self first-wall?))
        (set! arg0 #t)
        )
    (let ((root-prim (-> self root root-prim)))
      (set! (-> (the-as collide-shape-prim-group root-prim) child 0 prim-core collide-with) (collide-spec))
      (set! (-> (the-as collide-shape-prim-group root-prim) child 0 prim-core collide-as) (collide-spec))
      (if (-> self first-wall?)
          (set-vector! (-> root-prim local-sphere) 43827.2 -16384.0 158924.8 204800.0)
          (set-vector! (-> root-prim local-sphere) 43827.2 -16384.0 110592.0 225280.0)
          )
      (set! (-> self draw bounds quad) (-> root-prim local-sphere quad))
      )
    (update-transforms (-> self root))
    (let* ((art-group (-> self draw art-group))
           (s4-0 (method-of-object art-group get-art-by-name-method))
           )
      (format (clear *temp-string*) "~S-end" (-> self art-name))
      (let ((anim (the-as object (s4-0 art-group *temp-string* art-joint-anim))))
        (when (not arg0)
          (set! (-> self deadly-radius) 0.0)
          (ja-play-spooled-anim
            (-> self anim)
            (ja-group)
            (the-as art-joint-anim anim)
            (the-as (function process-drawable symbol) false-func)
            )
          )
        (ja-channel-set! 1)
        (set! (-> self skel root-channel 0 frame-group) (the-as art-joint-anim anim))
        )
      )
    (set! (-> self deadly-radius) -1.0)
    (let* ((_root-prim (-> self root root-prim))
           (collide-with (-> _root-prim prim-core collide-with))
           (collide-as (-> _root-prim prim-core collide-as))
           )
      (cond
        ((-> self first-wall?)
         (set! (-> (the-as collide-shape-prim-group _root-prim) child 1 prim-core collide-with) collide-with)
         (set! (-> (the-as collide-shape-prim-group _root-prim) child 1 prim-core collide-as) collide-as)
         (set! (-> (the-as collide-shape-prim-group _root-prim) child 2 prim-core collide-with) collide-with)
         (set! (-> (the-as collide-shape-prim-group _root-prim) child 2 prim-core collide-as) collide-as)
         )
        (else
          (set! (-> (the-as collide-shape-prim-group _root-prim) child 3 prim-core collide-with) collide-with)
          (set! (-> (the-as collide-shape-prim-group _root-prim) child 3 prim-core collide-as) collide-as)
          (set! (-> (the-as collide-shape-prim-group _root-prim) child 4 prim-core collide-with) collide-with)
          (set! (-> (the-as collide-shape-prim-group _root-prim) child 4 prim-core collide-as) collide-as)
          )
        )
      )
    (logior! (-> self mask) (process-mask actor-pause))
    (suspend)
    (logior! (-> self mask) (process-mask sleep))
    (suspend)
    0
    )
  :post ja-post
  )

;; definition for method 11 of type sew-wall
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this sew-wall) (entity entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (stack-size-set! (-> this main-thread) 512)
  (logior! (-> this mask) (process-mask collectable))
  (let ((data ((method-of-type res-lump get-property-struct)
               (-> this entity)
               'art-name
               'interp
               -1000000000.0
               "sew-wall-1"
               (the-as (pointer res-tag) #f)
               *res-static-buf*
               )
              )
        (art-group (art-group-get-by-name *level* "skel-sew-wall" (the-as (pointer uint32) #f)))
        )
    (set! (-> this art-name) (the-as string data))
    (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
      (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
      (set! (-> cshape reaction) cshape-reaction-default)
      (set! (-> cshape no-reaction)
            (the-as (function collide-shape-moving collide-query vector vector object) nothing)
            )
      (let ((prim-group (new 'process 'collide-shape-prim-group cshape (the-as uint 5) 0)))
        (set! (-> cshape total-prims) (the-as uint 6))
        (set! (-> prim-group prim-core collide-as) (collide-spec obstacle))
        (set! (-> prim-group prim-core collide-with) (collide-spec jak player-list))
        (set! (-> prim-group prim-core action) (collide-action solid))
        (set! (-> prim-group transform-index) 4)
        (set-vector! (-> prim-group local-sphere) 0.0 0.0 0.0 40960.0)
        (set! (-> cshape root-prim) prim-group)
        )
      (let ((prim-mesh-1 (new 'process 'collide-shape-prim-mesh cshape (the-as uint 0) (the-as uint 0))))
        (set! (-> prim-mesh-1 prim-core collide-as) (collide-spec obstacle))
        (set! (-> prim-mesh-1 prim-core collide-with) (collide-spec jak player-list))
        (set! (-> prim-mesh-1 prim-core action) (collide-action solid))
        (set! (-> prim-mesh-1 transform-index) 4)
        (set-vector! (-> prim-mesh-1 local-sphere) 0.0 0.0 0.0 40960.0)
        )
      (let ((prim-mesh-2 (new 'process 'collide-shape-prim-mesh cshape (the-as uint 1) (the-as uint 0))))
        (set! (-> prim-mesh-2 prim-core action) (collide-action solid))
        (set! (-> prim-mesh-2 transform-index) 4)
        (set-vector! (-> prim-mesh-2 local-sphere) 77824.0 -16384.0 282624.0 36864.0)
        )
      (let ((prim-mesh-3 (new 'process 'collide-shape-prim-mesh cshape (the-as uint 2) (the-as uint 0))))
        (set! (-> prim-mesh-3 prim-core action) (collide-action solid))
        (set! (-> prim-mesh-3 transform-index) 4)
        (set-vector! (-> prim-mesh-3 local-sphere) 61440.0 -16384.0 112640.0 151552.0)
        )
      (let ((prim-mesh-4 (new 'process 'collide-shape-prim-mesh cshape (the-as uint 3) (the-as uint 0))))
        (set! (-> prim-mesh-4 prim-core action) (collide-action solid))
        (set! (-> prim-mesh-4 transform-index) 4)
        (set-vector! (-> prim-mesh-4 local-sphere) 0.0 -16384.0 40960.0 122880.0)
        )
      (let ((prim-mesh-5 (new 'process 'collide-shape-prim-mesh cshape (the-as uint 4) (the-as uint 0))))
        (set! (-> prim-mesh-5 prim-core action) (collide-action solid))
        (set! (-> prim-mesh-5 transform-index) 4)
        (set-vector! (-> prim-mesh-5 local-sphere) 81920.0 0.0 204800.0 143360.0)
        )
      (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
      (let ((root-prim (-> cshape root-prim)))
        (set! (-> cshape backup-collide-as) (-> root-prim prim-core collide-as))
        (set! (-> cshape backup-collide-with) (-> root-prim prim-core collide-with))
        )
      (set! (-> this root) cshape)
      )
    (process-drawable-from-entity! this entity)
    (logclear! (-> this mask) (process-mask actor-pause))
    (cond
      ((string= (-> this art-name) "sew-wall-1")
       (set! (-> this anim)
             (new 'static 'spool-anim :name "sew-wall-1" :anim-name "1-break" :parts 1 :command-list '())
             )
       (set! (-> this first-wall?) #t)
       )
      ((string= (-> this art-name) "sew-wall-2")
       (set! (-> this anim)
             (new 'static 'spool-anim :name "sew-wall-2" :anim-name "2-break" :parts 1 :command-list '())
             )
       (+! (-> this root trans z) 26624.0)
       (set! (-> this first-wall?) #f)
       )
      (else
        (go process-drawable-art-error (the-as string data))
        )
      )
    (initialize-skeleton this (the-as skeleton-group art-group) (the-as pair 0))
    )
  (set! (-> this draw force-lod) 0)
  (ja-channel-set! 1)
  (let* ((channel (-> this skel root-channel 0))
         (_art-group (-> this draw art-group))
         (s3-1 (method-of-object _art-group get-art-by-name-method))
         )
    (format (clear *temp-string*) "~S-idle" (-> this art-name))
    (set! (-> channel frame-group) (the-as art-joint-anim (s3-1 _art-group *temp-string* (the-as type #f))))
    )
  (let* ((game-info *game-info*)
         (id (+ (-> game-info attack-id) 1))
         )
    (set! (-> game-info attack-id) id)
    (set! (-> this attack-id) id)
    )
  (if (script-eval (res-lump-struct (-> this entity) 'on-activate pair))
      (go (method-of-object this hit) #t)
      (go (method-of-object this idle))
      )
  (none)
  )

;; definition of type sew-grill
(deftype sew-grill (process-drawable)
  ()
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type sew-grill
(defmethod inspect ((this sew-grill))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-grill sew-grill sew-grill-lod0-jg sew-grill-idle-ja
              ((sew-grill-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 3 0 7.5)
              )

;; failed to figure out what this is:
(defstate idle (sew-grill)
  :virtual #t
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post ja-post
  )

;; definition for method 11 of type sew-grill
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this sew-grill) (entity entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this entity)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-grill" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (go (method-of-object this idle))
  (none)
  )

;; definition of type sew-scare-grunt
(deftype sew-scare-grunt (grunt)
  ((anim              spool-anim)
   (manipy            (pointer manipy))
   (spooled-sound-id  sound-id)
   (grill-actor       entity-actor)
   )
  (:state-methods
    waiting
    scare
    )
  )

;; definition for method 3 of type sew-scare-grunt
(defmethod inspect ((this sew-scare-grunt))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type grunt inspect)))
    (t9-0 this)
    )
  (format #t "~2Tanim: ~A~%" (-> this anim))
  (format #t "~2Tmanipy: #x~X~%" (-> this manipy))
  (format #t "~2Tspooled-sound-id: ~D~%" (-> this spooled-sound-id))
  (format #t "~2Tgrill-actor: ~A~%" (-> this grill-actor))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-scare-grunt grunt grunt-lod0-jg grunt-idle-ja
              ((grunt-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 5 -12 20)
              )

;; definition for symbol *sew-scare-grunt-nav-enemy-info*, type nav-enemy-info
(define *sew-scare-grunt-nav-enemy-info*
  (new 'static 'nav-enemy-info
    :use-die-falling #f
    :use-victory #f
    :use-jump-blocked #f
    :debug-draw-neck #f
    :jump-debug-draw #f
    :move-to-ground #t
    :hover-if-no-ground #f
    :idle-anim-script (new 'static 'array idle-control-frame 4
      (new 'static 'idle-control-frame :command (ic-cmd push) :param0 #x1e)
      (new 'static 'idle-control-frame :command (ic-cmd play) :anim #x5 :param0 #x1 :param1 #x3)
      (new 'static 'idle-control-frame)
      (new 'static 'idle-control-frame)
      )
    :idle-anim 5
    :notice-anim 13
    :hostile-anim -1
    :hit-anim 34
    :knocked-anim -1
    :knocked-land-anim -1
    :die-anim 19
    :die-falling-anim 32
    :victory-anim -1
    :jump-wind-up-anim 45
    :jump-in-air-anim 46
    :jump-land-anim 47
    :neck-joint 5
    :look-at-joint 6
    :bullseye-joint 18
    :sound-hit (static-sound-name "grunt-hit")
    :sound-die (static-sound-name "grunt-die")
    :notice-distance (meters 30)
    :notice-distance-delta (meters 10)
    :default-hit-points 1
    :gnd-collide-with (collide-spec backgnd)
    :overlaps-others-collide-with-filter (collide-spec jak bot player-list)
    :movement-gravity (meters -100)
    :friction 0.8
    :attack-shove-back (meters 3)
    :attack-shove-up (meters 2)
    :attack-mode 'generic
    :attack-damage 2
    :recover-gnd-collide-with (collide-spec backgnd crate obstacle hit-by-others-list pusher)
    :jump-height-min (meters 3)
    :jump-height-factor 0.5
    :knocked-seek-ry-clamp 2730.6667
    :knocked-soft-vxz-lo 72089.6
    :knocked-soft-vxz-hi 108134.4
    :knocked-soft-vy-lo 81920.0
    :knocked-soft-vy-hi 122880.0
    :knocked-medium-vxz-lo 147456.0
    :knocked-medium-vxz-hi 196608.0
    :knocked-medium-vy-lo 135168.0
    :knocked-medium-vy-hi 151552.0
    :knocked-hard-vxz-lo 78643.2
    :knocked-hard-vxz-hi 117964.8
    :knocked-hard-vy-lo 183500.8
    :knocked-hard-vy-hi 209715.2
    :knocked-huge-vxz-lo 164659.2
    :knocked-huge-vxz-hi 249036.8
    :knocked-huge-vy-lo 183500.8
    :knocked-huge-vy-hi 217907.2
    :knocked-yellow-vxz-lo 40960.0
    :knocked-yellow-vxz-hi 49152.0
    :knocked-yellow-vy-lo 57344.0
    :knocked-yellow-vy-hi 81920.0
    :knocked-red-vxz-lo 4096.0
    :knocked-red-vxz-hi 90112.0
    :knocked-red-vy-lo 106496.0
    :knocked-red-vy-hi 147456.0
    :knocked-blue-vxz-lo 40960.0
    :knocked-blue-vxz-hi 49152.0
    :knocked-blue-vy-lo 24576.0
    :knocked-blue-vy-hi 81920.0
    :shadow-size (meters 2)
    :shadow-max-y (meters 1)
    :shadow-min-y (meters -1)
    :shadow-locus-dist (meters 150)
    :gem-joint 6
    :gem-seg #x2
    :gem-no-seg #x4
    :gem-offset (new 'static 'sphere :y 614.4 :z -3276.8 :r 327680.0)
    :callback-info #f
    :use-momentum #f
    :use-frustration #f
    :use-stop-chase #f
    :use-circling #f
    :use-pacing #f
    :walk-anim 11
    :turn-anim -1
    :run-anim 14
    :taunt-anim 20
    :run-travel-speed (meters 6)
    :run-acceleration (meters 1)
    :run-turning-acceleration (meters 2)
    :walk-travel-speed (meters 3)
    :walk-acceleration (meters 1)
    :walk-turning-acceleration (meters 1)
    :maximum-rotation-rate (degrees 720)
    :notice-nav-radius (meters 1)
    :frustration-distance (meters 8)
    :frustration-time (seconds 4)
    :blocked-time (seconds 0.3)
    :circle-dist-lo 20480.0
    :circle-dist-hi 61440.0
    :nav-mesh #f
    )
  )

;; failed to figure out what this is:
(set! (-> *sew-scare-grunt-nav-enemy-info* fact-defaults) *fact-info-enemy-defaults*)

;; failed to figure out what this is:
(defstate waiting (sew-scare-grunt)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (logior! (-> self draw status) (draw-control-status no-draw))
    )
  :trans (behavior ()
    (let* ((target *target*)
           (target-proc (if (type? target process-focusable)
                            target
                            )
                        )
           )
      (when target-proc
        (cond
          ((< (vector-vector-distance (-> self root trans) (get-trans target-proc 0)) 20480.0)
           (go-virtual scare)
           )
          ((< (vector-vector-distance (-> self root trans) (get-trans target-proc 0)) 102400.0)
           (gui-control-method-12
             *gui-control*
             self
             (gui-channel art-load)
             (gui-action queue)
             (-> self anim name)
             0
             -99.0
             (new 'static 'sound-id)
             )
           )
          )
        )
      )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! grunt-idle-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post ja-post
  )

;; failed to figure out what this is:
(defstate scare (sew-scare-grunt)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (logclear! (-> self draw status) (draw-control-status no-draw))
    (let* ((actor (-> self grill-actor))
           (actor-proc (if actor
                           (-> actor extra process)
                           )
                       )
           )
      (when actor-proc
        (set! (-> self manipy)
              (process-spawn
                manipy
                :init manipy-init
                (-> self root trans)
                (-> actor-proc entity)
                (art-group-get-by-name *level* "skel-sew-grill" (the-as (pointer uint32) #f))
                #f
                0
                :to self
                )
              )
        (send-event (ppointer->process (-> self manipy)) 'anim-mode 'clone-anim)
        (set! (-> self manipy 0 draw light-index) (-> (the-as sew-grill actor-proc) draw light-index))
        (logior! (-> (the-as sew-grill actor-proc) draw status) (draw-control-status no-draw))
        )
      )
    (set! (-> self spooled-sound-id)
          (lookup-gui-connection-id *gui-control* (-> self anim name) (gui-channel art-load) (gui-action none))
          )
    )
  :exit (behavior ()
    (let* ((actor (-> self grill-actor))
           (actor-proc (if actor
                           (-> actor extra process)
                           )
                       )
           )
      (if actor-proc
          (logclear! (-> (the-as sew-grill actor-proc) draw status) (draw-control-status no-draw))
          )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((anim grunt-sew-scare-grunt-end-ja))
      (ja-play-spooled-anim
        (-> self anim)
        (ja-group)
        (the-as art-joint-anim anim)
        (the-as (function process-drawable symbol) false-func)
        )
      )
    (let ((root-prim (-> self root root-prim)))
      (set! (-> root-prim prim-core collide-as) (collide-spec))
      (set! (-> root-prim prim-core collide-with) (collide-spec))
      )
    0
    (suspend)
    (logior! (-> self mask) (process-mask sleep))
    (suspend)
    0
    )
  :post (behavior ()
    (let* ((a1-1 (vector<-cspace! (new 'stack-no-clear 'vector) (joint-node grunt-lod0-jg main)))
           (f1-0 (vector-vector-xz-distance (-> self root trans) a1-1))
           )
      (vector-lerp!
        (-> self draw color-mult)
        *identity-vector*
        *null-vector*
        (fmax 0.0 (fmin 1.0 (* 0.00001994613 f1-0)))
        )
      )
    (let ((scale (lerp-scale 1.0 0.0 (vector-vector-distance (-> self root trans) (camera-pos)) 65536.0 204800.0)))
      (when *sound-player-enable*
        (let ((set-sound-param (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> set-sound-param command) (sound-command set-param))
          (set! (-> set-sound-param id) (-> self spooled-sound-id))
          (set! (-> set-sound-param params volume) (the int (* 1024.0 scale)))
          (let ((position (-> self root trans)))
            (let ((_self self))
              (when (= position #t)
                (if (and _self (type? _self process-drawable) (nonzero? (-> _self root)))
                    (set! position (-> _self root trans))
                    (set! position (the-as vector #f))
                    )
                )
              )
            (sound-trans-convert (the-as vector3w (-> set-sound-param params trans)) position)
            )
          (set! (-> set-sound-param params mask) (the-as uint 33))
          (-> set-sound-param id)
          )
        )
      )
    (transform-post)
    )
  )

;; definition for method 116 of type sew-scare-grunt
;; WARN: Return type mismatch object vs none.
(defmethod go-idle ((this sew-scare-grunt))
  (go (method-of-object this waiting))
  (none)
  )

;; definition for method 114 of type sew-scare-grunt
;; WARN: Return type mismatch int vs none.
(defmethod init-enemy-collision! ((this sew-scare-grunt))
  "Initializes the [[collide-shape-moving]] and any ancillary tasks to make the enemy collide properly"
  (stack-size-set! (-> this main-thread) 512)
  (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) cshape-reaction-default)
    (set! (-> cshape no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> cshape penetrated-by) (penetrate
                                      generic-attack
                                      lunge
                                      flop
                                      punch
                                      spin
                                      roll
                                      uppercut
                                      bonk
                                      tube
                                      vehicle
                                      flut-attack
                                      board
                                      mech-punch
                                      dark-punch
                                      dark-giant
                                      )
          )
    (let ((prim-group (new 'process 'collide-shape-prim-group cshape (the-as uint 6) 0)))
      (set! (-> cshape total-prims) (the-as uint 7))
      (set! (-> prim-group prim-core collide-as) (collide-spec enemy))
      (set! (-> prim-group prim-core collide-with) (collide-spec backgnd))
      (set! (-> prim-group prim-core action) (collide-action solid))
      (set-vector! (-> prim-group local-sphere) 0.0 6144.0 0.0 17408.0)
      (set! (-> cshape root-prim) prim-group)
      )
    (let ((prim-sphere-1 (new 'process 'collide-shape-prim-sphere cshape (the-as uint 0))))
      (set! (-> prim-sphere-1 prim-core collide-as) (collide-spec enemy))
      (set! (-> prim-sphere-1 prim-core collide-with) (collide-spec backgnd))
      (set! (-> prim-sphere-1 prim-core action) (collide-action solid))
      (set-vector! (-> prim-sphere-1 local-sphere) 0.0 4915.2 0.0 4915.2)
      )
    (let ((prim-sphere-2 (new 'process 'collide-shape-prim-sphere cshape (the-as uint 0))))
      (set! (-> prim-sphere-2 prim-core collide-as) (collide-spec enemy))
      (set! (-> prim-sphere-2 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> prim-sphere-2 prim-core action) (collide-action semi-solid))
      (set! (-> prim-sphere-2 transform-index) 4)
      (set-vector! (-> prim-sphere-2 local-sphere) 0.0 0.0 0.0 4915.2)
      )
    (let ((prim-sphere-3 (new 'process 'collide-shape-prim-sphere cshape (the-as uint 0))))
      (set! (-> prim-sphere-3 prim-core collide-as) (collide-spec enemy))
      (set! (-> prim-sphere-3 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> prim-sphere-3 prim-core action) (collide-action semi-solid))
      (set! (-> prim-sphere-3 transform-index) 18)
      (set-vector! (-> prim-sphere-3 local-sphere) 0.0 0.0 0.0 2252.8)
      )
    (let ((prim-sphere-4 (new 'process 'collide-shape-prim-sphere cshape (the-as uint 0))))
      (set! (-> prim-sphere-4 prim-core collide-as) (collide-spec enemy))
      (set! (-> prim-sphere-4 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> prim-sphere-4 prim-core action) (collide-action semi-solid))
      (set! (-> prim-sphere-4 transform-index) 16)
      (set-vector! (-> prim-sphere-4 local-sphere) 0.0 0.0 0.0 2048.0)
      )
    (let ((prim-sphere-5 (new 'process 'collide-shape-prim-sphere cshape (the-as uint 0))))
      (set! (-> prim-sphere-5 prim-core collide-as) (collide-spec enemy))
      (set! (-> prim-sphere-5 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> prim-sphere-5 prim-core action) (collide-action semi-solid))
      (set! (-> prim-sphere-5 transform-index) 12)
      (set-vector! (-> prim-sphere-5 local-sphere) 0.0 0.0 0.0 2048.0)
      )
    (let ((prim-sphere-6 (new 'process 'collide-shape-prim-sphere cshape (the-as uint 0))))
      (set! (-> prim-sphere-6 prim-core collide-as) (collide-spec enemy))
      (set! (-> prim-sphere-6 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> prim-sphere-6 prim-core action) (collide-action semi-solid))
      (set! (-> prim-sphere-6 transform-index) 6)
      (set-vector! (-> prim-sphere-6 local-sphere) 0.0 0.0 0.0 8192.0)
      )
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (let ((root-prim (-> cshape root-prim)))
      (set! (-> cshape backup-collide-as) (-> root-prim prim-core collide-as))
      (set! (-> cshape backup-collide-with) (-> root-prim prim-core collide-with))
      )
    (set! (-> cshape max-iteration-count) (the-as uint 3))
    (set! (-> this root) cshape)
    )
  0
  (none)
  )

;; definition for method 185 of type sew-scare-grunt
(defmethod get-enemy-info ((this sew-scare-grunt))
  "@returns the [[nav-enemy-info]] associated with this type of grunt"
  *sew-scare-grunt-nav-enemy-info*
  )

;; definition for method 115 of type sew-scare-grunt
;; WARN: Return type mismatch float vs none.
(defmethod init-enemy! ((this sew-scare-grunt))
  "Common method called to initialize the enemy, typically sets up default field values and calls ancillary helper methods"
  (set! (-> this anim)
        (new 'static 'spool-anim :name "sew-scare-grunt" :anim-name "sew-scare-grunt" :parts 2 :command-list '())
        )
  (set! (-> this grill-actor) (entity-actor-lookup (-> this entity) 'alt-actor 0))
  (let ((func (method-of-type grunt init-enemy!)))
    (func this)
    )
  (+! (-> this root trans y) -3276.8)
  (none)
  )
