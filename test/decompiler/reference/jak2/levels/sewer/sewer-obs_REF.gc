;;-*-Lisp-*-
(in-package goal)

;; definition of type sew-blade
(deftype sew-blade (process-drawable)
  ((y-min         float)
   (y-max         float)
   (snd-water     sound-name)
   (snd-no-water  sound-name)
   (last-sound    int32)
   (attack-id     uint32)
   )
  (:methods
    (update-sound! (_type_) none)
    )
  )

;; definition for method 3 of type sew-blade
;; INFO: Used lq/sq
(defmethod inspect ((this sew-blade))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Ty-min: ~f~%" (-> this y-min))
  (format #t "~2Ty-max: ~f~%" (-> this y-max))
  (format #t "~2Tsnd-water: ~D~%" (-> this snd-water))
  (format #t "~2Tsnd-no-water: ~D~%" (-> this snd-no-water))
  (format #t "~2Tlast-sound: ~D~%" (-> this last-sound))
  (format #t "~2Tattack-id: ~D~%" (-> this attack-id))
  (label cfg-4)
  this
  )

;; definition for method 20 of type sew-blade
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod update-sound! ((this sew-blade))
  "Updates the sound of the [[sew-blade]] based on if it's under or above the water"
  (when (nonzero? (-> this sound))
    (let ((f30-0 (+ (-> this root trans y) (-> this y-max)))
          (f28-0 (+ (-> this root trans y) (-> this y-min)))
          (ocean-base-height (get-base-height *ocean-map-sewer*))
          )
      (cond
        ((< f30-0 ocean-base-height)
         (stop! (-> this sound))
         )
        ((< ocean-base-height f28-0)
         (when (!= (-> this last-sound) 1)
           (change-sound! (-> this sound) (-> this snd-no-water))
           (set! (-> this last-sound) 1)
           )
         (update! (-> this sound))
         )
        (else
          (when (!= (-> this last-sound) 2)
            (change-sound! (-> this sound) (-> this snd-water))
            (set! (-> this last-sound) 2)
            )
          (update! (-> this sound))
          )
        )
      )
    )
  0
  (none)
  )

;; definition of type sew-single-blade
(deftype sew-single-blade (sew-blade)
  ((quat  quaternion  :inline)
   )
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type sew-single-blade
(defmethod inspect ((this sew-single-blade))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type sew-blade inspect)))
    (t9-0 this)
    )
  (format #t "~2Tquat: #<quaternion @ #x~X>~%" (-> this quat))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-single-blade sew-single-blade sew-single-blade-lod0-jg sew-single-blade-idle-ja
              ((sew-single-blade-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 4 5.5)
              )

;; failed to figure out what this is:
(defstate idle (sew-single-blade)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch 'attack)
       (let* ((_proc proc)
              (hit-proc (if (type? _proc process-focusable)
                            (the-as process-focusable _proc)
                            )
                        )
              )
         (when hit-proc
           (let ((hit-direction (vector-! (new 'stack-no-clear 'vector) (-> hit-proc root trans) (-> self root trans)))
                 (v1-5 (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)))
                 )
             (if (< (vector-dot v1-5 hit-direction) 0.0)
                 (vector-float*! v1-5 v1-5 -1.0)
                 )
             (send-event
               hit-proc
               'attack-or-shove
               (-> block param 0)
               (static-attack-info ((id (-> self attack-id)) (vector v1-5) (shove-back (meters 5)) (shove-up (meters 3))))
               )
             )
           )
         )
       )
      )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek! max 0.02) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 0.02))
        )
      )
    #f
    )
  :post (behavior ()
    (update-sound! self)
    (transform-post)
    )
  )

;; definition for method 11 of type sew-single-blade
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this sew-single-blade) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (logior! (-> this mask) (process-mask ambient))
  (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) cshape-reaction-default)
    (set! (-> cshape no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((prim-mesh (new 'process 'collide-shape-prim-mesh cshape (the-as uint 0) (the-as uint 0))))
      (set! (-> prim-mesh prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> prim-mesh prim-core collide-with) (collide-spec jak player-list))
      (set! (-> prim-mesh prim-core action) (collide-action solid deadly))
      (set! (-> prim-mesh transform-index) 0)
      (set-vector! (-> prim-mesh local-sphere) 0.0 0.0 16384.0 22528.0)
      (set! (-> cshape total-prims) (the-as uint 1))
      (set! (-> cshape root-prim) prim-mesh)
      )
    (pusher-init cshape)
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (let ((root-prim (-> cshape root-prim)))
      (set! (-> cshape backup-collide-as) (-> root-prim prim-core collide-as))
      (set! (-> cshape backup-collide-with) (-> root-prim prim-core collide-with))
      )
    (set! (-> this root) cshape)
    )
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-single-blade" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (quaternion-copy! (-> this quat) (-> this root quat))
  (set! (-> this sound) (new 'process 'ambient-sound "none" (-> this root trans)))
  (set-falloff-far! (-> this sound) 286720.0)
  (set! (-> this y-min) -16384.0)
  (set! (-> this y-max) 16384.0)
  (set! (-> this snd-water) (static-sound-name "single-blade-w"))
  (set! (-> this snd-no-water) (static-sound-name "single-blade"))
  (let* ((game-info *game-info*)
         (id (+ (-> game-info attack-id) 1))
         )
    (set! (-> game-info attack-id) id)
    (set! (-> this attack-id) id)
    )
  (transform-post)
  (go (method-of-object this idle))
  (none)
  )

;; definition of type sew-tri-blade
(deftype sew-tri-blade (sew-blade)
  ((anim-time     float)
   (anim-offset   float)
   (switch-state  int32)
   )
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type sew-tri-blade
(defmethod inspect ((this sew-tri-blade))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type sew-blade inspect)))
    (t9-0 this)
    )
  (format #t "~2Tanim-time: ~f~%" (-> this anim-time))
  (format #t "~2Tanim-offset: ~f~%" (-> this anim-offset))
  (format #t "~2Tswitch-state: ~D~%" (-> this switch-state))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-tri-blade sew-tri-blade sew-tri-blade-lod0-jg sew-tri-blade-idle-ja
              ((sew-tri-blade-lod0-mg (meters 20)) (sew-tri-blade-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 2.5 0 9)
              )

;; definition for function sew-tri-blade-joint-callback
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defun sew-tri-blade-joint-callback ((arg0 draw-control) (arg1 cspace-array) (arg2 joint-control))
  "Handles the rotation and transformation of the [[sew-tri-blade]]"
  (let ((blade (the-as sew-tri-blade (-> arg0 process)))
        (matrix (new-stack-matrix0))
        (f30-0 (* 182.04445 (* 0.0033333334 (the float (current-time)))))
        )
    (let ((s3-0 (-> arg1 data 4 bone transform)))
      (matrix-rotate-y! matrix (* 240.0 f30-0))
      (matrix*! s3-0 matrix s3-0)
      )
    (let ((s3-1 (-> arg1 data 5 bone transform)))
      (matrix-rotate-y! matrix (* -240.0 f30-0))
      (matrix*! s3-1 matrix s3-1)
      (set! (-> blade y-max) (+ (- 25395.2 (-> blade root trans y)) (-> s3-1 trans y)))
      )
    (let ((s4-1 (-> arg1 data 6 bone transform)))
      (matrix-rotate-y! matrix (* 240.0 f30-0))
      (matrix*! s4-1 matrix s4-1)
      (set! (-> blade y-max) (fmax (-> blade y-max) (+ (- 19251.2 (-> blade root trans y)) (-> s4-1 trans y))))
      )
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate idle (sew-tri-blade)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch 'attack)
       (let* ((_proc proc)
              (hit-proc (if (type? _proc process-focusable)
                            _proc
                            )
                        )
              )
         (if hit-proc
             (send-event
               hit-proc
               'attack-or-shove
               (-> block param 0)
               (static-attack-info ((id (-> self attack-id)) (shove-back (meters 5)) (shove-up (meters 2))))
               )
             )
         )
       )
      (('on)
       (when (!= (-> self anim-offset) 0.0)
         (let ((f30-0 (+ (-> self root trans y) (-> self y-max))))
           (if (< (get-base-height *ocean-map-sewer*) f30-0)
               (sound-play "tri-blade-up")
               )
           )
         )
       (let ((v0-1 (the-as object 1)))
         (set! (-> self switch-state) (the-as int v0-1))
         v0-1
         )
       )
      (('off)
       (when (= (-> self anim-offset) 0.0)
         (let ((f30-1 (+ (-> self root trans y) (-> self y-max))))
           (if (< (get-base-height *ocean-map-sewer*) f30-1)
               (sound-play "tri-blade-up")
               )
           )
         )
       (set! (-> self switch-state) 0)
       0
       )
      )
    )
  :code (behavior ()
    (until #f
      (cond
        ((zero? (-> self switch-state))
         (cond
           ((>= 3.0 (-> self anim-time))
            (+! (-> self anim-time) (* 6.0 (seconds-per-frame)))
            (set! (-> self anim-time) (fmin 3.0 (-> self anim-time)))
            )
           (else
             (+! (-> self anim-time) (* 6.0 (seconds-per-frame)))
             (if (< 6.0 (-> self anim-time))
                 (set! (-> self anim-time) 0.0)
                 )
             )
           )
         )
        (else
          (+! (-> self anim-time) (* 6.0 (seconds-per-frame)))
          (set! (-> self anim-time) (fmin 6.0 (-> self anim-time)))
          )
        )
      (let ((f30-0 (+ (-> self anim-time) (-> self anim-offset))))
        (if (< 6.0 f30-0)
            (set! f30-0 (+ -6.0 f30-0))
            )
        (ja :group! sew-tri-blade-idle-ja :num! (identity f30-0))
        )
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (update-sound! self)
    (transform-post)
    )
  )

;; definition for method 11 of type sew-tri-blade
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this sew-tri-blade) (entity entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (logior! (-> this mask) (process-mask ambient))
  (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) cshape-reaction-default)
    (set! (-> cshape no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s3-0 (new 'process 'collide-shape-prim-group cshape (the-as uint 3) 0)))
      (set! (-> cshape total-prims) (the-as uint 4))
      (set! (-> s3-0 prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid deadly))
      (set-vector! (-> s3-0 local-sphere) 0.0 10240.0 0.0 36864.0)
      (set! (-> cshape root-prim) s3-0)
      )
    (pusher-init cshape)
    (let ((v1-16 (new 'process 'collide-shape-prim-mesh cshape (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-16 prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> v1-16 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-16 prim-core action) (collide-action solid deadly))
      (set! (-> v1-16 transform-index) 4)
      (set-vector! (-> v1-16 local-sphere) 0.0 8192.0 0.0 18841.6)
      )
    (let ((v1-18 (new 'process 'collide-shape-prim-mesh cshape (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-18 prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> v1-18 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-18 prim-core action) (collide-action solid deadly))
      (set! (-> v1-18 transform-index) 5)
      (set-vector! (-> v1-18 local-sphere) 0.0 8192.0 0.0 12288.0)
      )
    (let ((v1-20 (new 'process 'collide-shape-prim-mesh cshape (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-20 prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> v1-20 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-20 prim-core action) (collide-action solid deadly))
      (set! (-> v1-20 transform-index) 6)
      (set-vector! (-> v1-20 local-sphere) 0.0 4915.2 0.0 7372.8)
      )
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (let ((v1-23 (-> cshape root-prim)))
      (set! (-> cshape backup-collide-as) (-> v1-23 prim-core collide-as))
      (set! (-> cshape backup-collide-with) (-> v1-23 prim-core collide-with))
      )
    (set! (-> this root) cshape)
    )
  (process-drawable-from-entity! this entity)
  (logclear! (-> this mask) (process-mask actor-pause))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-tri-blade" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set-time! (-> this state-time))
  (set! (-> this anim-time) 0.0)
  (set! (-> this anim-offset) 0.0)
  (set! (-> this skel postbind-function) sew-tri-blade-joint-callback)
  (let* ((v1-33 *game-info*)
         (a0-33 (+ (-> v1-33 attack-id) 1))
         )
    (set! (-> v1-33 attack-id) a0-33)
    (set! (-> this attack-id) a0-33)
    )
  (if (>= (res-lump-value entity 'extra-id int :default (the-as uint128 -1) :time -1000000000.0) 0)
      (set! (-> this anim-offset) 3.0)
      )
  (set! (-> this sound) (new 'process 'ambient-sound "none" (-> this root trans)))
  (set-falloff-far! (-> this sound) 286720.0)
  (set! (-> this y-min) 0.0)
  (set! (-> this y-max) 48332.8)
  (set! (-> this snd-water) (static-sound-name "tri-blade-w"))
  (set! (-> this snd-no-water) (static-sound-name "tri-blade"))
  (transform-post)
  (go (method-of-object this idle))
  (none)
  )

;; definition of type sew-arm-blade
(deftype sew-arm-blade (sew-blade)
  ()
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type sew-arm-blade
(defmethod inspect ((this sew-arm-blade))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type sew-blade inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-arm-blade sew-arm-blade sew-arm-blade-lod0-jg sew-arm-blade-idle-ja
              ((sew-arm-blade-lod0-mg (meters 20)) (sew-arm-blade-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 -6 0 7)
              )

;; failed to figure out what this is:
(defstate idle (sew-arm-blade)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch 'attack)
       (let* ((s5-0 proc)
              (a0-2 (if (type? s5-0 process-focusable)
                        s5-0
                        )
                    )
              )
         (if a0-2
             (send-event
               a0-2
               'attack-or-shove
               (-> block param 0)
               (static-attack-info ((id (-> self attack-id)) (shove-back (meters 5)) (shove-up (meters 2))))
               )
             )
         )
       )
      )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek! max 0.02) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 0.02))
        )
      )
    #f
    )
  :post (behavior ()
    (update-sound! self)
    (transform-post)
    )
  )

;; definition for method 11 of type sew-arm-blade
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this sew-arm-blade) (entity entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (logior! (-> this mask) (process-mask ambient))
  (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) cshape-reaction-default)
    (set! (-> cshape no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((prim-mesh (new 'process 'collide-shape-prim-mesh cshape (the-as uint 0) (the-as uint 0))))
      (set! (-> prim-mesh prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> prim-mesh prim-core collide-with) (collide-spec jak player-list))
      (set! (-> prim-mesh prim-core action) (collide-action solid deadly))
      (set! (-> prim-mesh transform-index) 0)
      (set-vector! (-> prim-mesh local-sphere) 0.0 -24576.0 0.0 28672.0)
      (set! (-> cshape total-prims) (the-as uint 1))
      (set! (-> cshape root-prim) prim-mesh)
      )
    (pusher-init cshape)
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (let ((root-prim (-> cshape root-prim)))
      (set! (-> cshape backup-collide-as) (-> root-prim prim-core collide-as))
      (set! (-> cshape backup-collide-with) (-> root-prim prim-core collide-with))
      )
    (set! (-> this root) cshape)
    )
  (process-drawable-from-entity! this entity)
  (logclear! (-> this mask) (process-mask actor-pause))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-arm-blade" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this sound) (new 'process 'ambient-sound "none" (-> this root trans)))
  (set-falloff-far! (-> this sound) 286720.0)
  (set! (-> this y-min) -43008.0)
  (set! (-> this y-max) -4096.0)
  (set! (-> this snd-water) (static-sound-name "arm-blade-w"))
  (set! (-> this snd-no-water) (static-sound-name "arm-blade"))
  (let* ((game-info *game-info*)
         (id (+ (-> game-info attack-id) 1))
         )
    (set! (-> game-info attack-id) id)
    (set! (-> this attack-id) id)
    )
  (transform-post)
  (go (method-of-object this idle))
  (none)
  )

;; definition of type sew-multi-blade
(deftype sew-multi-blade (sew-blade)
  ()
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type sew-multi-blade
(defmethod inspect ((this sew-multi-blade))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type sew-blade inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-multi-blade sew-multi-blade sew-multi-blade-lod0-jg sew-multi-blade-idle-ja
              ((sew-multi-blade-lod0-mg (meters 20)) (sew-multi-blade-lod1-mg (meters 999999)))
              :bounds (static-spherem 18 0 0 22)
              )

;; failed to figure out what this is:
(defstate idle (sew-multi-blade)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch 'attack)
       (let* ((_proc proc)
              (hit-proc (if (type? _proc process-focusable)
                            (the-as process-focusable _proc)
                            )
                        )
              )
         (when hit-proc
           (let ((hit-direction (vector-! (new 'stack-no-clear 'vector) (-> hit-proc root trans) (-> self root trans)))
                 (v1-5 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)))
                 )
             (if (< (vector-dot v1-5 hit-direction) 0.0)
                 (vector-float*! v1-5 v1-5 -1.0)
                 )
             (send-event
               hit-proc
               'attack-or-shove
               (-> block param 0)
               (static-attack-info ((id (-> self attack-id)) (vector v1-5) (shove-back (meters 7)) (shove-up (meters 4))))
               )
             )
           )
         )
       )
      )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post (behavior ()
    (update-sound! self)
    (transform-post)
    )
  )

;; definition for method 11 of type sew-multi-blade
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this sew-multi-blade) (entity entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (logior! (-> this mask) (process-mask ambient))
  (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) cshape-reaction-default)
    (set! (-> cshape no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((prim-mesh (new 'process 'collide-shape-prim-mesh cshape (the-as uint 0) (the-as uint 0))))
      (set! (-> prim-mesh prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> prim-mesh prim-core collide-with) (collide-spec jak player-list))
      (set! (-> prim-mesh prim-core action) (collide-action solid))
      (set! (-> prim-mesh transform-index) 0)
      (set-vector! (-> prim-mesh local-sphere) 73728.0 0.0 0.0 90112.0)
      (set! (-> cshape total-prims) (the-as uint 1))
      (set! (-> cshape root-prim) prim-mesh)
      )
    (pusher-init cshape)
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (let ((root-prim (-> cshape root-prim)))
      (set! (-> cshape backup-collide-as) (-> root-prim prim-core collide-as))
      (set! (-> cshape backup-collide-with) (-> root-prim prim-core collide-with))
      )
    (set! (-> this root) cshape)
    )
  (process-drawable-from-entity! this entity)
  (logclear! (-> this mask) (process-mask actor-pause))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-multi-blade" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this sound) (new 'process 'ambient-sound "none" (-> this root trans)))
  (set-falloff-far! (-> this sound) 368640.0)
  (set! (-> this y-min) -16384.0)
  (set! (-> this y-max) 16384.0)
  (set! (-> this snd-water) (static-sound-name "multi-blade-w"))
  (set! (-> this snd-no-water) (static-sound-name "multi-blade"))
  (let* ((game-info *game-info*)
         (id (+ (-> game-info attack-id) 1))
         )
    (set! (-> game-info attack-id) id)
    (set! (-> this attack-id) id)
    )
  (transform-post)
  (go (method-of-object this idle))
  (none)
  )

;; definition of type sew-twist-blade
(deftype sew-twist-blade (sew-blade)
  ((root-overide        collide-shape-moving  :overlay-at root)
   (no-collision-timer  uint64)
   )
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type sew-twist-blade
(defmethod inspect ((this sew-twist-blade))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type sew-blade inspect)))
    (t9-0 this)
    )
  (format #t "~2Tno-collision-timer: ~D~%" (-> this no-collision-timer))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-twist-blade sew-twist-blade sew-twist-blade-lod0-jg sew-twist-blade-idle-ja
              ((sew-twist-blade-lod0-mg (meters 20)) (sew-twist-blade-lod1-mg (meters 999999)))
              :bounds (static-spherem 10 0 0 12)
              )

;; failed to figure out what this is:
(defstate idle (sew-twist-blade)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch 'attack)
       (let* ((_proc proc)
              (hit-proc (if (type? _proc process-focusable)
                            (the-as process-focusable _proc)
                            )
                        )
              )
         (when hit-proc
           (let ((hit-direction (vector-! (new 'stack-no-clear 'vector) (-> hit-proc root trans) (-> self root-overide trans)))
                 (v1-5 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root-overide quat)))
                 )
             (if (< (vector-dot v1-5 hit-direction) 0.0)
                 (vector-float*! v1-5 v1-5 -1.0)
                 )
             (send-event
               hit-proc
               'attack-or-shove
               (-> block param 0)
               (static-attack-info ((id (-> self attack-id)) (vector v1-5) (shove-back (meters 4)) (shove-up (meters 2))))
               )
             )
           (set! (-> self no-collision-timer) (the-as uint (current-time)))
           (let ((root-prim (-> self root-overide root-prim)))
             (set! (-> root-prim prim-core collide-as) (collide-spec))
             (set! (-> root-prim prim-core collide-with) (collide-spec))
             )
           0
           )
         )
       )
      )
    )
  :trans (behavior ()
    (when (and (nonzero? (-> self no-collision-timer))
               (time-elapsed?
                 (the-as int (-> self no-collision-timer))
                 (the-as time-frame (-> *TARGET-bank* hit-invulnerable-timeout))
                 )
               )
      (let ((root-prim (-> self root-overide root-prim)))
        (set! (-> root-prim prim-core collide-as) (-> self root-overide backup-collide-as))
        (set! (-> root-prim prim-core collide-with) (-> self root-overide backup-collide-with))
        )
      (set! (-> self no-collision-timer) (the-as uint 0))
      0
      )
    (let ((overlap-params (new 'stack-no-clear 'overlaps-others-params)))
      (set! (-> overlap-params options) (overlaps-others-options oo0))
      (set! (-> overlap-params collide-with-filter) (the-as collide-spec -1))
      (set! (-> overlap-params tlist) *touching-list*)
      (find-overlapping-shapes (-> self root-overide) overlap-params)
      )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek! max 0.02) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 0.02))
        )
      )
    #f
    )
  :post (behavior ()
    (update-sound! self)
    (transform-post)
    )
  )

;; definition for method 11 of type sew-twist-blade
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this sew-twist-blade) (entity entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (logior! (-> this mask) (process-mask ambient))
  (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) cshape-reaction-default)
    (set! (-> cshape no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((prim-mesh (new 'process 'collide-shape-prim-mesh cshape (the-as uint 0) (the-as uint 0))))
      (set! (-> prim-mesh prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> prim-mesh prim-core collide-with) (collide-spec jak player-list))
      (set! (-> prim-mesh prim-core action) (collide-action solid deadly))
      (set! (-> prim-mesh transform-index) 0)
      (set-vector! (-> prim-mesh local-sphere) 40960.0 0.0 0.0 49152.0)
      (set! (-> cshape total-prims) (the-as uint 1))
      (set! (-> cshape root-prim) prim-mesh)
      )
    (pusher-init cshape)
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (let ((root-prim (-> cshape root-prim)))
      (set! (-> cshape backup-collide-as) (-> root-prim prim-core collide-as))
      (set! (-> cshape backup-collide-with) (-> root-prim prim-core collide-with))
      )
    (set! (-> this root-overide) cshape)
    )
  (process-drawable-from-entity! this entity)
  (logclear! (-> this mask) (process-mask actor-pause))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-twist-blade" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (transform-post)
  (set! (-> this sound) (new 'process 'ambient-sound "none" (-> this root-overide trans)))
  (set-falloff-far! (-> this sound) 245760.0)
  (set! (-> this y-min) -4096.0)
  (set! (-> this y-max) 4096.0)
  (set! (-> this snd-water) (static-sound-name "twist-blade-w"))
  (set! (-> this snd-no-water) (static-sound-name "twist-blade"))
  (let* ((game-info *game-info*)
         (id (+ (-> game-info attack-id) 1))
         )
    (set! (-> game-info attack-id) id)
    (set! (-> this attack-id) id)
    )
  (go (method-of-object this idle))
  (none)
  )

;; definition of type sew-light-switch
(deftype sew-light-switch (process-drawable)
  ((light-state        symbol)
   (actor-group        (pointer actor-group))
   (actor-group-count  int32)
   )
  (:state-methods
    idle
    pressed
    )
  (:methods
    (init-switch-collision! (_type_) none)
    (broadcast-to-actors (_type_ symbol) none)
    )
  )

;; definition for method 3 of type sew-light-switch
(defmethod inspect ((this sew-light-switch))
  (when (not this)
    (set! this this)
    (goto cfg-7)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tlight-state: ~A~%" (-> this light-state))
  (format #t "~2Tactor-group: #x~X~%" (-> this actor-group))
  (dotimes (s5-0 (-> this actor-group-count))
    (format #t "~T  [~D]~2Tactor-group: ~`actor-group`P~%" s5-0 (-> this actor-group s5-0))
    )
  (format #t "~2Tactor-group-count: ~D~%" (-> this actor-group-count))
  (label cfg-7)
  this
  )

;; definition of type sew-light-control
(deftype sew-light-control (process)
  ((search-switches  basic)
   (search-turrets   basic)
   (switch-ent       entity-actor)
   (turret-ent       entity-actor)
   )
  (:state-methods
    idle
    )
  (:methods
    (press! (_type_ symbol symbol) float)
    (sew-light-control-method-16 (_type_ object vector float) symbol)
    )
  )

;; definition for method 3 of type sew-light-control
(defmethod inspect ((this sew-light-control))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process inspect)))
    (t9-0 this)
    )
  (format #t "~2Tsearch-switches: ~A~%" (-> this search-switches))
  (format #t "~2Tsearch-turrets: ~A~%" (-> this search-turrets))
  (format #t "~2Tswitch-ent: ~A~%" (-> this switch-ent))
  (format #t "~2Tturret-ent: ~A~%" (-> this turret-ent))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-sew-light-switch sew-light-switch sew-light-switch-lod0-jg sew-light-switch-idle-ja
              ((sew-light-switch-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 1.5)
              )

;; failed to figure out what this is:
(defstate idle (sew-light-switch)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (broadcast-to-actors self 'cue-chase)
       (go-virtual pressed)
       )
      (('touch 'attack)
       (let* ((gp-0 (-> block param 0))
              (_proc proc)
              (target-proc (if (type? _proc target)
                               _proc
                               )
                           )
              )
         (when (and gp-0 target-proc)
           (broadcast-to-actors self 'cue-chase)
           (go-virtual pressed)
           )
         )
       )
      )
    )
  :enter (behavior ()
    (set! (-> self light-state) #f)
    )
  :code (behavior ()
    (ja-channel-set! 1)
    (ja :group! sew-light-switch-idle-ja :num! min)
    (transform-post)
    (sleep-code)
    )
  :post (behavior ()
    (launch-particles (-> *part-id-table* 1442) (-> self root trans))
    (ja-post)
    )
  )

;; failed to figure out what this is:
(defstate pressed (sew-light-switch)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('untrigger)
       (go-virtual idle)
       )
      )
    )
  :enter (behavior ()
    (set! (-> self light-state) #t)
    (sound-play "sew-light-switc")
    )
  :code (behavior ()
    (ja-no-eval :group! sew-light-switch-idle-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (transform-post)
      (suspend)
      (ja :num! (seek!))
      )
    (sleep-code)
    )
  )

;; definition for method 22 of type sew-light-switch
;; WARN: Return type mismatch collide-shape-moving vs none.
(defmethod init-switch-collision! ((this sew-light-switch))
  "Initializes the collision on the switch"
  (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) cshape-reaction-default)
    (set! (-> cshape no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((prim-mesh (new 'process 'collide-shape-prim-mesh cshape (the-as uint 0) (the-as uint 0))))
      (set! (-> prim-mesh prim-core collide-as) (collide-spec obstacle))
      (set! (-> prim-mesh prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> prim-mesh prim-core action) (collide-action solid rideable))
      (set! (-> prim-mesh transform-index) 3)
      (set-vector! (-> prim-mesh local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> cshape total-prims) (the-as uint 1))
      (set! (-> cshape root-prim) prim-mesh)
      )
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (let ((root-prim (-> cshape root-prim)))
      (set! (-> cshape backup-collide-as) (-> root-prim prim-core collide-as))
      (set! (-> cshape backup-collide-with) (-> root-prim prim-core collide-with))
      )
    (set! (-> this root) cshape)
    )
  (none)
  )

;; definition for method 23 of type sew-light-switch
;; WARN: Return type mismatch object vs none.
(defmethod broadcast-to-actors ((this sew-light-switch) (event-type symbol))
  "Broadcast event to all associated [[entity]]s via the `actor-group`s
@param `event-type` the symbol to broadcast"
  (with-pp
    (dotimes (group-idx (-> this actor-group-count))
      (let ((group (-> this actor-group group-idx)))
        (dotimes (actor-idx (-> group length))
          (let ((evt (new 'stack-no-clear 'event-message-block)))
            (set! (-> evt from) (process->ppointer pp))
            (set! (-> evt num-params) 0)
            (set! (-> evt message) event-type)
            (let ((func send-event-function)
                  (actor (-> group data actor-idx actor))
                  )
              (func
                (if actor
                    (-> actor extra process)
                    )
                evt
                )
              )
            )
          )
        )
      )
    (if (-> *game-info* controller 0)
        (send-event (-> *game-info* controller 0 process 0) event-type)
        )
    (none)
    )
  )

;; definition for method 11 of type sew-light-switch
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this sew-light-switch) (entity entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (tag res-tag))
  (init-switch-collision! this)
  (process-drawable-from-entity! this entity)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-light-switch" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (process-entity-status! this (entity-perm-status no-kill) #t)
  (set! tag (new 'static 'res-tag))
  (let ((data (res-lump-data (-> this entity) 'actor-groups pointer :tag-ptr (& tag))))
    (cond
      ((and data (nonzero? (-> tag elt-count)))
       (set! (-> this actor-group) (the-as (pointer actor-group) data))
       (set! (-> this actor-group-count) (the-as int (-> tag elt-count)))
       )
      (else
        (set! (-> this actor-group) (the-as (pointer actor-group) #f))
        (set! (-> this actor-group-count) 0)
        0
        )
      )
    )
  (set! (-> this light-state) #f)
  (go (method-of-object this idle))
  (none)
  )

;; definition for method 16 of type sew-light-control
;; ERROR: failed type prop at 53: Could not figure out load: (set! v1 (l.w s4))
(defmethod sew-light-control-method-16 ((a0-0 sew-light-control) (a1-0 object) (a2-0 vector) (a3-0 float))
  "@unused
@TODO - not done yet, no callers?"
  (local-vars
    (v0-0 symbol)
    (v0-1 none)
    (v0-2 none)
    (v0-3 none)
    (v1-0 int)
    (v1-1 none)
    (v1-2 none)
    (v1-3 none)
    (v1-4 none)
    (v1-5 none)
    (v1-7 none)
    (v1-8 none)
    (v1-10 none)
    (v1-12 none)
    (v1-13 none)
    (v1-14 none)
    (v1-16 none)
    (v1-17 none)
    (v1-19 none)
    (v1-22 none)
    (a1-1 none)
    (a1-2 none)
    (a2-1 none)
    (s0-0 none)
    (s1-0 none)
    (s2-0 int)
    (s5-0 symbol)
    (t9-0 none)
    (t9-1 none)
    (t9-2 none)
    (sp-0 none)
    (f0-0 none)
    (f0-1 none)
    (f0-2 none)
    (f28-0 none)
    (f30-0 int)
    )
  (when (begin a1-0)
    (if (begin
          (set! s5-0 #f)
          (set! v1-0 -1082130432)
          (set! f30-0 (gpr->fpr v1-0))
          (set! s2-0 0)
          (while (begin (set! v1-19 (the-as none (l.w a1-0))) (<.si s2-0 v1-19))
            (when (begin
                    (when (begin
                            (set! v1-1 (the-as none (sll s2-0 3)))
                            (set! v1-2 (the-as none (+ v1-1 12)))
                            (set! v1-3 (the-as none (+ v1-2 a1-0)))
                            (set! v1-4 (the-as none (l.wu v1-3)))
                            v1-4
                            )
                      (set! v1-5 (the-as none (l.wu (+ v1-4 20))))
                      (set! s1-0 (the-as none (l.wu (+ v1-5 12))))
                      )
                    s1-0
                    )
              (when (begin
                      (when (begin
                              (set! t9-0 (the-as none vector-vector-distance))
                              (set! a0-1 (the-as none a2-0))
                              (set! v1-7 (the-as none (l.wu (+ s1-0 124))))
                              (set! a1-1 (the-as none (+ v1-7 12)))
                              (set! v0-1 (the-as none (call!)))
                              (set! f28-0 (the-as none (gpr->fpr v0-1)))
                              (set! s0-0 (the-as none (+ sp-0 16)))
                              (set! t9-1 (the-as none sphere<-vector+r!))
                              (set! a0-2 (the-as none s0-0))
                              (set! v1-8 (the-as none (l.wu (+ s1-0 124))))
                              (set! a1-2 (the-as none (+ v1-8 12)))
                              (set! a2-1 (the-as none #x47f00000))
                              (call!)
                              (set! t9-2 (the-as none sphere-in-view-frustum?))
                              (set! a0-3 (the-as none s0-0))
                              (set! v0-3 (the-as none (call!)))
                              v0-3
                              )
                        (set! v1-10 (the-as none #x3f400000))
                        (set! f0-0 (the-as none (gpr->fpr v1-10)))
                        (set! f28-0 (the-as none (*.s f0-0 f28-0)))
                        (set! v1-11 (the-as none (fpr->gpr f28-0)))
                        )
                      (set! v1-12 (the-as none -1082130432))
                      (set! f0-1 (the-as none (gpr->fpr v1-12)))
                      (set! v1-13 (the-as none (=.s f30-0 f0-1)))
                      (or v1-13 (set! v1-14 (the-as none (<.s f28-0 f30-0))))
                      v1-14
                      )
                (set! f30-0 (the-as int f28-0))
                (set! v1-16 (the-as none (sll s2-0 3)))
                (set! v1-17 (the-as none (+ v1-16 12)))
                (set! s5-0 (the-as symbol (+ v1-17 a1-0)))
                (set! v1-18 (the-as none s5-0))
                )
              )
            (set! s2-0 (the-as int (+ s2-0 1)))
            )
          (and (begin s5-0)
               (begin (set! f0-2 (the-as none (gpr->fpr a3-0))) (set! v1-22 (the-as none (<.s f30-0 f0-2))))
               )
          v1-22
          )
        (set! v0-0 (the-as symbol s5-0))
        )
    )
  (ret-value v0-0)
  )

;; failed to figure out what this is:
(defstate idle (sew-light-control)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (actor entity))
    (case message
      (('use-switch)
       (set! actor (entity-by-name (the-as string (-> block param 0))))
       (set! (-> self switch-ent) (the-as entity-actor actor))
       actor
       )
      (('use-turret)
       (set! actor (entity-by-name (the-as string (-> block param 0))))
       (set! (-> self turret-ent) (the-as entity-actor actor))
       actor
       )
      )
    )
  :code (behavior ()
    (until #f
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (let* ((target *target*)
           (target-proc (if (type? target process-focusable)
                            target
                            )
                        )
           )
      (when target-proc
        (get-trans target-proc 0)
        (let ((switch-pressed? #f)
              (should-flash? (the-as object #f))
              )
          (let* ((switch (-> self switch-ent))
                 (switch-proc (if switch
                                  (-> switch extra process)
                                  )
                              )
                 )
            (if switch-proc
                (set! switch-pressed? (-> (the-as sew-light-switch switch-proc) light-state))
                )
            )
          (let* ((turret (-> self turret-ent))
                 (turret-proc (if turret
                                  (-> turret extra process)
                                  )
                              )
                 )
            (when turret-proc
              (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
                (set! (-> a1-2 from) (process->ppointer self))
                (set! (-> a1-2 num-params) 0)
                (set! (-> a1-2 message) 'flash-state)
                (set! should-flash? (send-event-function turret-proc a1-2))
                )
              )
            )
          (press! self switch-pressed? (the-as symbol should-flash?))
          )
        )
      )
    )
  )

;; definition for method 15 of type sew-light-control
(defmethod press! ((this sew-light-control) (switched-on? symbol) (should-turret-flash? symbol))
  "Turns the lights on (or off)
@param switched-on? Should the sewer lights be turned on or off?
@param should-turret-flash? Should the turret have it's `flash` set as well"
  (set-sewer-lights-flag! switched-on?)
  (if should-turret-flash?
      (set-sewer-turret-flash!)
      )
  )

;; definition for function sew-light-control-init-by-other
;; WARN: Return type mismatch object vs none.
(defbehavior sew-light-control-init-by-other sew-light-control ((switch entity-actor) (turret entity-actor))
  "Creates a [[sew-light-control]] given two entities for the turret and switch itself
@param switch The entity for the switch
@param turret The entity for the turret"
  (process-entity-set! self switch)
  (set! (-> *game-info* controller 0) (process->handle self))
  (set! (-> self switch-ent) switch)
  (set! (-> self turret-ent) turret)
  (press! self #f #f)
  (go-virtual idle)
  (none)
  )

;; definition for function sewer-startup
;; WARN: Return type mismatch int vs none.
(defun sewer-startup ()
  "Basic house-keeping for starting the sewer area:
- sets up the bigmap
- spawns the first switch and turret"
  (cond
    ((task-node-closed? (game-task-node sewer-board-introduction))
     (set! (-> sewer bigmap-id) (bigmap-id sewer-with-board-area))
     (set! (-> sewerb bigmap-id) (bigmap-id sewer-with-board-area))
     )
    (else
      (set! (-> sewer bigmap-id) (bigmap-id sewer-default))
      (set! (-> sewerb bigmap-id) (bigmap-id sewer-default))
      )
    )
  (process-spawn
    sew-light-control
    (entity-by-name "sew-light-switch-13")
    (entity-by-name "sew-gunturret-13")
    :to *entity-pool*
    )
  0
  (none)
  )
