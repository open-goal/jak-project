;;-*-Lisp-*-
(in-package goal)

;; this file is debug only
(declare-file (debug))
(when *debug-segment*
;; definition for method 0 of type editable-region
(defmethod new editable-region ((allocation symbol) (type-to-make type))
  (let ((gp-0 (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> gp-0 changed) #t)
    (set! (-> gp-0 locked) #f)
    (let ((v1-4 (level-get-target-inside *level*)))
      (set! (-> gp-0 level) (the-as string (if v1-4
                                               (-> v1-4 info dbname)
                                               )
                                    )
            )
      )
    (set! (-> gp-0 tree) (the-as string 'camera))
    (set! (-> gp-0 on-enter) #f)
    (set! (-> gp-0 on-exit) #f)
    (set! (-> gp-0 on-inside) #f)
    (set! (-> gp-0 filter) (editable-region-method-12 gp-0))
    gp-0
    )
  )

;; definition for method 2 of type editable-region
(defmethod print editable-region ((obj editable-region))
  (format #t "#<~A region-~D ~A ~A @ #x~X>" (-> obj type) (-> obj id) (-> obj level) (-> obj tree) obj)
  obj
  )

;; definition for method 10 of type editable-region
;; INFO: Used lq/sq
(defmethod editable-region-method-10 editable-region ((obj editable-region) (arg0 int))
  (local-vars (sv-16 string) (sv-32 string))
  (when (nonzero? (-> obj id))
    (let ((s5-0 (clear *temp-string*)))
      (format s5-0 "delete from region_sphere where region_id=~D" (-> obj id))
      (let ((a2-1 (sql-query s5-0)))
        (when (!= (-> a2-1 error) 'modify)
          (format 0 "ERROR: sql: modify error ~A for ~A~%" a2-1 obj)
          (return #t)
          )
        )
      (clear s5-0)
      (format s5-0 "select region_face_id from region_face where region_id=~D" (-> obj id))
      (let ((s3-0 (sql-query s5-0)))
        (when (!= (-> s3-0 error) 'select)
          (format 0 "ERROR: sql: face select error ~A for ~A~%" s3-0 obj)
          (return #t)
          )
        (when (> (-> s3-0 len) 0)
          (clear s5-0)
          (format s5-0 "delete from region_point where region_face_id in (")
          (dotimes (s2-0 (-> s3-0 len))
            (cond
              ((zero? s2-0)
               (let ((s1-0 format)
                     (s0-0 s5-0)
                     )
                 (set! sv-16 "~D")
                 (let ((a2-4 (string->int (the-as string (-> s3-0 data s2-0)))))
                   (s1-0 s0-0 sv-16 a2-4)
                   )
                 )
               )
              (else
                (let ((s1-1 format)
                      (s0-1 s5-0)
                      )
                  (set! sv-32 ",~D")
                  (let ((a2-5 (string->int (the-as string (-> s3-0 data s2-0)))))
                    (s1-1 s0-1 sv-32 a2-5)
                    )
                  )
                )
              )
            )
          (format s5-0 ")")
          (let ((a2-6 (sql-query s5-0)))
            (when (!= (-> a2-6 error) 'modify)
              (format 0 "ERROR: sql: modify error ~A for ~A~%" a2-6 obj)
              (return #t)
              )
            )
          )
        )
      (clear s5-0)
      (format s5-0 "delete from region_face where region_id=~D" (-> obj id))
      (let ((a2-8 (sql-query s5-0)))
        (when (!= (-> a2-8 error) 'modify)
          (format 0 "ERROR: sql: modify error ~A for ~A~%" a2-8 obj)
          (return #t)
          )
        )
      (when (zero? arg0)
        (clear s5-0)
        (format s5-0 "delete from region where region_id=~D" (-> obj id))
        (let ((a2-10 (sql-query s5-0)))
          (when (!= (-> a2-10 error) 'modify)
            (format 0 "ERROR: sql: modify error ~A for ~A~%" a2-10 obj)
            (return #t)
            )
          )
        )
      )
    )
  #f
  )

;; definition for method 9 of type editable-region
;; ERROR: function was not converted to expressions. Cannot decompile.

;; definition for method 11 of type editable-region
;; WARN: Return type mismatch int vs none.
(defmethod editable-region-method-11 editable-region ((obj editable-region) (arg0 vector) (arg1 int))
  (local-vars (sv-32 vector2h))
  (set! sv-32 (new 'stack 'vector2h))
  (add-debug-x #t (bucket-id bucket-318) arg0 (the-as rgba (-> (new 'static 'array uint64 1 #x8000ffff) 0)))
  (let ((s3-0 add-debug-text-3d)
        (s2-0 #t)
        (s1-0 318)
        )
    (format (clear *temp-string*) "region-~D~%" (-> obj id))
    (s3-0 s2-0 (the-as bucket-id s1-0) *temp-string* arg0 (font-color one) sv-32)
    )
  (set! (-> sv-32 y) (the-as int (+ (-> sv-32 y) 8)))
  (when (>= arg1 1)
    (let ((s4-1 (-> obj on-enter)))
      (when s4-1
        (let ((s3-1 add-debug-text-3d)
              (s2-1 #t)
              (s1-1 318)
              )
          (format (clear *temp-string*) "(on-enter ~S)" s4-1)
          (s3-1 s2-1 (the-as bucket-id s1-1) *temp-string* arg0 (font-color one) sv-32)
          )
        (set! (-> sv-32 y) (the-as int (+ (-> sv-32 y) 8)))
        )
      )
    (let ((s4-2 (-> obj on-inside)))
      (when s4-2
        (let ((s3-2 add-debug-text-3d)
              (s2-2 #t)
              (s1-2 318)
              )
          (format (clear *temp-string*) "(on-inside ~S)" s4-2)
          (s3-2 s2-2 (the-as bucket-id s1-2) *temp-string* arg0 (font-color one) sv-32)
          )
        (set! (-> sv-32 y) (the-as int (+ (-> sv-32 y) 8)))
        )
      )
    (let ((s5-1 (-> obj on-exit)))
      (when s5-1
        (let ((s4-3 add-debug-text-3d)
              (s3-3 #t)
              (s2-3 318)
              )
          (format (clear *temp-string*) "(on-exit ~S)" s5-1)
          (s4-3 s3-3 (the-as bucket-id s2-3) *temp-string* arg0 (font-color one) sv-32)
          )
        (set! (-> sv-32 y) (the-as int (+ (-> sv-32 y) 8)))
        )
      )
    )
  0
  (none)
  )

;; definition for method 12 of type editable-region
;; WARN: Return type mismatch int vs editable-filter.
(defmethod editable-region-method-12 editable-region ((obj editable-region))
  (let* ((s5-0 0)
         (s4-0 (lambda ((arg0 string)) (let ((gp-0 0))
                                         (when (not (type? arg0 string))
                                           (format (clear *temp-string*) "~A" arg0)
                                           (set! arg0 *temp-string*)
                                           )
                                         (if (>= (string-position "(sound-play" arg0) 0)
                                             (set! gp-0 (logior gp-0 4))
                                             )
                                         (if (>= (string-position "(part-tracker" arg0) 0)
                                             (set! gp-0 (logior gp-0 8))
                                             )
                                         (if (>= (string-position "(want-" arg0) 0)
                                             (set! gp-0 (logior gp-0 64))
                                             )
                                         (if (>= (string-position "(setting-" arg0) 0)
                                             (set! gp-0 (logior gp-0 16))
                                             )
                                         (if (>= (string-position "(water" arg0) 0)
                                             (set! gp-0 (logior gp-0 128))
                                             )
                                         gp-0
                                         )
                       )
               )
         (v0-3
           (logior (logior (logior s5-0 (s4-0 (-> obj on-inside))) (s4-0 (-> obj on-enter))) (s4-0 (-> obj on-exit)))
           )
         )
    (when (zero? v0-3)
      (if (and (not (-> obj on-inside)) (not (-> obj on-enter)) (not (-> obj on-exit)))
          (set! v0-3 1)
          (set! v0-3 2)
          )
      )
    (case (-> obj tree)
      (('target)
       (set! v0-3 (logior v0-3 512))
       )
      (('camera)
       (set! v0-3 (logior v0-3 256))
       )
      (('data)
       (set! v0-3 (logior v0-3 2048))
       )
      (('water)
       (set! v0-3 (logior v0-3 1024))
       )
      (('city_vis)
       (set! v0-3 4096)
       )
      (('sample)
       (set! v0-3 8192)
       )
      (('light)
       (set! v0-3 #x4000)
       )
      (('entity)
       (set! v0-3 #x8000)
       )
      )
    (the-as editable-filter v0-3)
    )
  )

;; definition for method 23 of type editable
(defmethod editable-method-23 editable ((obj editable))
  #t
  )

;; definition for method 28 of type editable
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-28 editable ((obj editable) (arg0 editable-filter))
  (let* ((s5-0 (-> obj owner))
         (a0-1 (car s5-0))
         )
    (while (not (null? s5-0))
      (editable-method-28 (the-as editable a0-1) arg0)
      (set! s5-0 (cdr s5-0))
      (set! a0-1 (car s5-0))
      )
    )
  0
  (none)
  )

;; definition for method 29 of type editable
;; WARN: Return type mismatch int vs symbol.
(defmethod editable-method-29 editable ((obj editable) (arg0 editable-filter))
  (let* ((s5-0 (-> obj owner))
         (a0-1 (car s5-0))
         )
    (while (not (null? s5-0))
      (editable-method-29 (the-as editable a0-1) arg0)
      (set! s5-0 (cdr s5-0))
      (set! a0-1 (car s5-0))
      )
    )
  (the-as symbol 0)
  )

;; definition for method 21 of type editable
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-21 editable ((obj editable) (arg0 editable-region))
  (when (not (and (-> obj region) (-> obj region locked)))
    (if arg0
        (set! (-> arg0 changed) #t)
        )
    (if (-> obj region)
        (set! (-> obj region changed) #t)
        )
    (logior! (-> obj flags) (editable-flag changed))
    (set! (-> obj region) arg0)
    )
  0
  (none)
  )

;; definition for method 9 of type editable
;; WARN: Return type mismatch int vs rgba.
(defmethod get-color editable ((obj editable) (arg0 int))
  "Returns the [[rgba]] that corresponds to the type of [[editable]] TODO - document the colors"
  (the-as rgba (cond
                 ((and (logtest? (-> obj flags) (editable-flag selected))
                       (< (mod (-> *display* real-clock frame-counter) 60) 30)
                       )
                  (the-as int (-> (new 'static 'array uint64 1 #x80ffffff) 0))
                  )
                 ((logtest? (-> obj flags) (editable-flag no-save))
                  (shl #x80ff 16)
                  )
                 ((= (-> obj type) editable-point)
                  (the-as int (-> (new 'static 'array uint64 1 #x800080ff) 0))
                  )
                 ((= (-> obj type) editable-sample)
                  (the-as int (-> (new 'static 'array uint64 1 #x80ff8000) 0))
                  )
                 ((= (-> obj type) editable-light)
                  (the-as int (-> (new 'static 'array uint64 1 #x80ff0080) 0))
                  )
                 ((= (-> obj type) editable-entity)
                  (the-as int (-> (new 'static 'array uint64 1 #x80ff00ff) 0))
                  )
                 (else
                   (the-as int (-> (new 'static 'array uint64 1 #x800000ff) 0))
                   )
                 )
          )
  )

;; definition for method 10 of type editable
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-10 editable ((obj editable))
  (when (logtest? (-> obj flags) (editable-flag selected))
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (when (editable-method-11 obj s5-0)
        (set! (-> s5-0 y) (-> s5-0 y))
        (add-debug-x #t (bucket-id bucket-318) s5-0 (the-as rgba (-> (new 'static 'array uint64 1 #x80ffffff) 0)))
        )
      )
    (add-debug-x
      #t
      (bucket-id bucket-318)
      (edit-get-trans obj)
      (the-as rgba (-> (new 'static 'array uint64 1 #x8000ffff) 0))
      )
    )
  0
  (none)
  )

;; definition for method 12 of type editable
;; WARN: Return type mismatch int vs none.
(defmethod select-editable! editable ((obj editable) (arg0 symbol))
  (case arg0
    (('toggle)
     (logxor! (-> obj flags) (editable-flag selected))
     )
    ((#f)
     (logclear! (-> obj flags) (editable-flag selected))
     )
    (else
      (logior! (-> obj flags) (editable-flag selected))
      )
    )
  0
  (none)
  )

;; definition for method 13 of type editable
(defmethod edit-get-distance editable ((obj editable) (arg0 vector))
  "Returns the distance from the camera to the [[editable]], or -1.0"
  -1.0
  )

;; definition for method 20 of type editable
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-20 editable ((obj editable) (arg0 vector) (arg1 vector) (arg2 vector) (arg3 vector))
  (local-vars (sv-48 vector) (sv-52 vector))
  (set! sv-48 (new 'stack-no-clear 'vector))
  (set! sv-52 (new 'stack-no-clear 'vector))
  (let ((s4-0 (edit-get-trans obj)))
    (reverse-transform-point! sv-48 s4-0 arg2 arg0)
    (reverse-transform-point! sv-52 s4-0 arg2 arg1)
    (vector-! arg3 sv-52 sv-48)
    (vector-! (new 'stack-no-clear 'vector) s4-0 (-> *math-camera* trans))
    )
  (if (< 20480.0 (vector-length arg3))
      (vector-normalize! arg3 20480.0)
      )
  (editable-method-15 obj arg3 56)
  0
  (none)
  )

;; definition for method 11 of type editable
;; INFO: Used lq/sq
(defmethod editable-method-11 editable ((obj editable) (arg0 vector))
  (with-pp
    (let ((s5-0 (new 'stack 'collide-query)))
      (set! (-> s5-0 start-pos quad) (-> (edit-get-trans obj) quad))
      (set-vector! (-> s5-0 move-dist) 0.0 -204800.0 0.0 1.0)
      (let ((v1-5 s5-0))
        (set! (-> v1-5 radius) 40.96)
        (set! (-> v1-5 collide-with)
              (collide-spec backgnd crate obstacle hit-by-player-list hit-by-others-list collectable pusher)
              )
        (set! (-> v1-5 ignore-process0) pp)
        (set! (-> v1-5 ignore-process1) #f)
        (set! (-> v1-5 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
        (set! (-> v1-5 action-mask) (collide-action solid))
        )
      (when (>= (fill-and-probe-using-line-sphere *collide-cache* s5-0) 0.0)
        (set! (-> arg0 quad) (-> s5-0 best-other-tri intersect quad))
        #t
        )
      )
    )
  )

;; definition for method 24 of type editable
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-24 editable ((obj editable))
  0
  (none)
  )

;; definition for method 17 of type editable
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-17 editable ((obj editable) (arg0 vector))
  0
  (none)
  )

;; definition for method 22 of type editable
(defmethod editable-method-22 editable ((obj editable) (arg0 editable-array) (arg1 int) (arg2 int))
  #t
  )

;; definition for method 15 of type editable
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-15 editable ((obj editable) (arg0 vector) (arg1 int))
  0
  (none)
  )

;; definition for method 16 of type editable
;; WARN: Return type mismatch int vs none.
(defmethod edit-coord! editable ((obj editable) (arg0 vector) (arg1 editable-flag))
  0
  (none)
  )

;; definition for method 18 of type editable
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-18 editable ((obj editable) (arg0 vector) (arg1 matrix))
  0
  (none)
  )

;; definition for method 14 of type editable
(defmethod edit-get-trans editable ((obj editable))
  "Returns the `trans` [[vector]] or [[*null-vector*]]"
  *null-vector*
  )

;; definition for method 19 of type editable
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-19 editable ((obj editable) (arg0 vector))
  0
  (none)
  )

;; definition for method 26 of type editable
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-26 editable ((obj editable) (arg0 editable) (arg1 editable-array))
  0
  (none)
  )

;; definition for method 25 of type editable
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-25 editable ((obj editable) (arg0 editable-array))
  (let ((v1-0 (-> obj region)))
    (if v1-0
        (set! (-> v1-0 changed) #t)
        )
    )
  (logior! (-> obj flags) (editable-flag changed))
  (let* ((s4-0 (-> obj owner))
         (a0-3 (car s4-0))
         )
    (while (not (null? s4-0))
      (editable-method-26 (the-as editable a0-3) obj arg0)
      (set! s4-0 (cdr s4-0))
      (set! a0-3 (car s4-0))
      )
    )
  0
  (none)
  )

;; definition for method 27 of type editable
(defmethod editable-method-27 editable ((obj editable) (arg0 editable-array))
  (local-vars (s4-0 editable))
  (let ((v1-0 0))
    (while (< v1-0 (-> arg0 selection length))
      (when (= obj (-> arg0 selection v1-0))
        (set! s4-0 (-> arg0 selection (+ v1-0 1)))
        (goto cfg-10)
        )
      (+! v1-0 2)
      )
    )
  (let ((s3-0 (editable-array-method-11 arg0)))
    (set! s4-0 (when (>= s3-0 0)
                 (set! s4-0 (copy obj 'debug))
                 (let ((v1-9 (-> arg0 region)))
                   (if v1-9
                       (set! (-> s4-0 region) v1-9)
                       )
                   )
                 (set! (-> s4-0 region changed) #t)
                 (logior! (-> obj flags) (editable-flag changed))
                 (set! (-> s4-0 id) (the-as uint 0))
                 (set! (-> s4-0 owner) '())
                 (select-editable! s4-0 #f)
                 (let ((s2-0 (new 'debug 'string 32 (the-as string #f))))
                   (format s2-0 "undefined-~d" *editable-temp-id*)
                   (set! (-> s4-0 name) s2-0)
                   )
                 (set! *editable-temp-id* (+ *editable-temp-id* 1))
                 (set! (-> arg0 data s3-0) s4-0)
                 (set! (-> arg0 selection (-> arg0 selection length)) obj)
                 (set! (-> arg0 selection (+ (-> arg0 selection length) 1)) s4-0)
                 (+! (-> arg0 selection length) 2)
                 s4-0
                 )
          )
    )
  (label cfg-10)
  s4-0
  )

;; definition for method 2 of type editable-point
(defmethod print editable-point ((obj editable-point))
  (format
    #t
    "#<~A~S~m ~m ~m :r ~m"
    (-> obj type)
    (if (logtest? (-> obj flags) (editable-flag changed))
        " (m)"
        ""
        )
    (-> obj trans x)
    (-> obj trans y)
    (-> obj trans z)
    (-> obj radius)
    )
  (format #t " @ #x~X>" obj)
  obj
  )

;; definition for method 28 of type editable-point
;; WARN: Return type mismatch int vs none.
;; WARN: Function (method 28 editable-point) has a return type of none, but the expression builder found a return statement.
(defmethod editable-method-28 editable-point ((obj editable-point) (arg0 editable-filter))
  (if (logtest? arg0 (editable-filter water-command))
      (return #f)
      )
  (let ((s4-0 (-> *editable* 0 current)))
    (cond
      ((logtest? (-> obj flags) (editable-flag top-set))
       (let* ((s3-0 (-> s4-0 length))
              (s2-0 0)
              (a0-1 (-> s4-0 data s2-0))
              )
         (while (< s2-0 s3-0)
           (if (and a0-1 (= (-> a0-1 region) (-> obj region)) (logtest? (-> a0-1 flags) (editable-flag top-set)))
               (edit-coord! a0-1 (-> obj trans) (editable-flag y no-update))
               )
           (+! s2-0 1)
           (set! a0-1 (-> s4-0 data s2-0))
           )
         )
       )
      ((logtest? (-> obj flags) (editable-flag bot-set))
       (let* ((s3-1 (-> s4-0 length))
              (s2-1 0)
              (a0-2 (-> s4-0 data s2-1))
              )
         (while (< s2-1 s3-1)
           (if (and a0-2 (= (-> a0-2 region) (-> obj region)) (logtest? (-> a0-2 flags) (editable-flag bot-set)))
               (edit-coord! a0-2 (-> obj trans) (editable-flag y no-update))
               )
           (+! s2-1 1)
           (set! a0-2 (-> s4-0 data s2-1))
           )
         )
       )
      )
    )
  ((the-as (function editable-point editable-command none) (find-parent-method editable-point 28))
   obj
   (the-as editable-command arg0)
   )
  0
  (none)
  )

;; definition for method 15 of type editable-point
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-15 editable-point ((obj editable-point) (arg0 vector) (arg1 int))
  (let ((v1-0 (-> obj region)))
    (if v1-0
        (set! (-> v1-0 changed) #t)
        )
    )
  (logior! (-> obj flags) (editable-flag changed))
  (vector+! (-> obj trans) (-> obj trans) arg0)
  (editable-method-28 obj (the-as editable-filter arg1))
  0
  (none)
  )

;; definition for method 16 of type editable-point
;; WARN: Return type mismatch int vs none.
(defmethod edit-coord! editable-point ((obj editable-point) (arg0 vector) (arg1 editable-flag))
  (let ((v1-0 (-> obj region)))
    (if v1-0
        (set! (-> v1-0 changed) #t)
        )
    )
  (logior! (-> obj flags) (editable-flag changed))
  (if (logtest? arg1 (editable-flag x))
      (set! (-> obj trans x) (-> arg0 x))
      )
  (if (logtest? arg1 (editable-flag y))
      (set! (-> obj trans y) (-> arg0 y))
      )
  (if (logtest? arg1 (editable-flag z))
      (set! (-> obj trans z) (-> arg0 z))
      )
  (editable-method-28 obj (the-as editable-filter arg1))
  0
  (none)
  )

;; definition for method 14 of type editable-point
(defmethod edit-get-trans editable-point ((obj editable-point))
  "Returns the `trans` [[vector]] or [[*null-vector*]]"
  (-> obj trans)
  )

;; definition for method 18 of type editable-point
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-18 editable-point ((obj editable-point) (arg0 vector) (arg1 matrix))
  (let ((v1-0 (-> obj region)))
    (if v1-0
        (set! (-> v1-0 changed) #t)
        )
    )
  (logior! (-> obj flags) (editable-flag changed))
  (let ((s4-1 (vector-! (new 'stack-no-clear 'vector) (-> obj trans) arg0)))
    (vector-matrix*! s4-1 s4-1 arg1)
    (vector+! (-> obj trans) s4-1 arg0)
    )
  0
  (none)
  )

;; definition for method 10 of type editable-point
(defmethod editable-method-10 editable-point ((obj editable-point))
  (let* ((s5-0 vector-vector-distance)
         (a0-1 (math-camera-pos))
         (a1-0 (-> obj trans))
         (f0-1 (- (s5-0 a0-1 a1-0) (-> obj radius)))
         (s2-0 (cond
                 ((logtest? (-> obj flags) (editable-flag selected))
                  6
                  )
                 ((>= f0-1 983040.0)
                  3
                  )
                 ((>= f0-1 491520.0)
                  4
                  )
                 ((>= f0-1 245760.0)
                  5
                  )
                 (else
                   6
                   )
                 )
               )
         )
    (add-debug-sphere-from-table
      (bucket-id bucket-324)
      (-> obj trans)
      (-> obj radius)
      (get-color obj (the-as int a1-0))
      s2-0
      )
    )
  ((method-of-type editable editable-method-10) obj)
  (none)
  )

;; definition for method 13 of type editable-point
;; INFO: Used lq/sq
(defmethod edit-get-distance editable-point ((obj editable-point) (arg0 vector))
  "Returns the distance from the camera to the [[editable]], or -1.0"
  (let ((a0-1 (new 'stack-no-clear 'sphere))
        (s5-0 (new 'stack-no-clear 'vector))
        )
    (set! (-> a0-1 quad) (-> obj trans quad))
    (set! (-> a0-1 w) (-> obj radius))
    (when (sphere-in-view-frustum? a0-1)
      (reverse-transform-point! s5-0 (-> obj trans) (-> *math-camera* inv-camera-rot vector 2) arg0)
      (let ((f0-1 (vector-vector-distance (edit-get-trans obj) s5-0)))
        (if (>= (-> obj radius) f0-1)
            (return f0-1)
            )
        )
      )
    )
  -1.0
  )

;; definition for method 19 of type editable-point
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-19 editable-point ((obj editable-point) (arg0 vector))
  (let ((v1-0 (-> obj region)))
    (if v1-0
        (set! (-> v1-0 changed) #t)
        )
    )
  (let ((s4-1 (vector-! (new 'stack-no-clear 'vector) arg0 (-> obj trans))))
    (vector-normalize! s4-1 (-> obj radius))
    (vector-! (-> obj trans) arg0 s4-1)
    )
  (editable-method-28 obj (editable-filter load))
  0
  (none)
  )

;; definition for method 22 of type editable-point
(defmethod editable-method-22 editable-point ((obj editable-point) (arg0 editable-array) (arg1 int) (arg2 int))
  (case arg1
    ((2)
     (let ((s3-0 (clear *temp-string*)))
       (format
         s3-0
         "insert into region_point set region_face_id=LAST_INSERT_ID(),idx=~D,x=~f,y=~f,z=~f"
         arg2
         (- (-> obj trans x) (-> arg0 level-offset x))
         (- (-> obj trans y) (-> arg0 level-offset y))
         (- (-> obj trans z) (-> arg0 level-offset z))
         )
       (let ((a0-5 (sql-query s3-0)))
         (when (= (-> a0-5 error) 'modify)
           (logclear! (-> obj flags) (editable-flag changed))
           #t
           )
         )
       )
     )
    (else
      #t
      )
    )
  )

;; definition for method 17 of type editable-sphere
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-17 editable-sphere ((obj editable-sphere) (arg0 vector))
  (let ((v1-0 (-> obj region)))
    (if v1-0
        (set! (-> v1-0 changed) #t)
        )
    )
  (logior! (-> obj flags) (editable-flag changed))
  (if (= (-> arg0 y) 0.0)
      (+! (-> obj radius) (-> arg0 x))
      (set! (-> obj radius) (-> arg0 y))
      )
  (if (< (-> obj radius) 0.0)
      (set! (-> obj radius) 0.0)
      )
  (editable-method-28 obj (editable-filter load))
  0
  (none)
  )

;; definition for method 22 of type editable-sphere
(defmethod editable-method-22 editable-sphere ((obj editable-sphere) (arg0 editable-array) (arg1 int) (arg2 int))
  (let ((gp-0 (clear *temp-string*)))
    (format
      gp-0
      "insert into region_sphere set region_id=~D,x=~f,y=~f,z=~f,r=~f"
      (-> obj region id)
      (- (-> obj trans x) (-> arg0 level-offset x))
      (- (-> obj trans y) (-> arg0 level-offset y))
      (- (-> obj trans z) (-> arg0 level-offset z))
      (-> obj radius)
      )
    (= (-> (sql-query gp-0) error) 'modify)
    )
  )

;; definition for method 22 of type editable-sample
(defmethod editable-method-22 editable-sample ((obj editable-sample) (arg0 editable-array) (arg1 int) (arg2 int))
  (let ((s5-0 (clear *temp-string*)))
    (format
      s5-0
      "insert into sample_point set level_info_id=~D,x=~f,y=~f,z=~f,source='manual'"
      (-> arg0 level-info-id)
      (* 0.00024414062 (- (-> obj trans x) (-> arg0 level-offset x)))
      (* 0.00024414062 (- (-> obj trans y) (-> arg0 level-offset y)))
      (* 0.00024414062 (- (-> obj trans z) (-> arg0 level-offset z)))
      )
    (let ((a0-4 (sql-query s5-0)))
      (when (= (-> a0-4 error) 'modify)
        (logclear! (-> obj flags) (editable-flag changed))
        #t
        )
      )
    )
  )

;; definition for method 2 of type editable-light
(defmethod print editable-light ((obj editable-light))
  (format
    #t
    "#<~A~S ~S ~m ~m ~m"
    (-> obj type)
    (if (logtest? (-> obj flags) (editable-flag changed))
        " (m)"
        ""
        )
    (-> obj name)
    (-> obj trans x)
    (-> obj trans y)
    (-> obj trans z)
    )
  (format #t " :r ~m @ #x~X>" (-> obj radius) obj)
  obj
  )

;; definition for method 23 of type editable-light
;; INFO: Used lq/sq
(defmethod editable-method-23 editable-light ((obj editable-light))
  (let ((v1-0 *light-hash*))
    (let* ((a2-0 (-> v1-0 num-lights))
           (a1-1 (-> v1-0 light-sphere-array a2-0))
           )
      (set! (-> a1-1 name) (-> obj name))
      (set! (-> a1-1 decay-start) (-> obj decay-start))
      (set! (-> a1-1 ambient-point-ratio) (-> obj ambient-point-ratio))
      (set! (-> a1-1 brightness) (-> obj brightness))
      (set! (-> a1-1 bsphere quad) (-> obj trans quad))
      (set! (-> a1-1 bsphere w) (-> obj radius))
      (set! (-> a1-1 direction quad) (-> obj direction quad))
      (set! (-> a1-1 color quad) (-> obj color quad))
      (set! (-> a1-1 palette-index) (the int (-> obj color w)))
      )
    (+! (-> v1-0 num-lights) 1)
    )
  #t
  )

;; definition for function update-light-sphere-from-editable-light
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defun update-light-sphere-from-editable-light ((arg0 editable-light))
  (let ((v1-0 (lookup-light-sphere-by-name (-> arg0 name) *light-hash*)))
    (when v1-0
      (set! (-> v1-0 name) (-> arg0 name))
      (set! (-> v1-0 decay-start) (-> arg0 decay-start))
      (set! (-> v1-0 ambient-point-ratio) (-> arg0 ambient-point-ratio))
      (set! (-> v1-0 brightness) (-> arg0 brightness))
      (set! (-> v1-0 bsphere quad) (-> arg0 trans quad))
      (set! (-> v1-0 bsphere w) (-> arg0 radius))
      (set! (-> v1-0 direction quad) (-> arg0 direction quad))
      (set! (-> v1-0 color quad) (-> arg0 color quad))
      (set! (-> v1-0 palette-index) (the int (-> arg0 color w)))
      )
    )
  (none)
  )

;; definition for method 17 of type editable-light
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-17 editable-light ((obj editable-light) (arg0 vector))
  (let ((v1-0 (-> obj region)))
    (if v1-0
        (set! (-> v1-0 changed) #t)
        )
    )
  (logior! (-> obj flags) (editable-flag changed))
  (if (= (-> arg0 y) 0.0)
      (+! (-> obj radius) (-> arg0 x))
      (set! (-> obj radius) (-> arg0 y))
      )
  (if (< (-> obj radius) 0.0)
      (set! (-> obj radius) 0.0)
      )
  (update-light-sphere-from-editable-light obj)
  (editable-method-28 obj (editable-filter load))
  0
  (none)
  )

;; definition for method 15 of type editable-light
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-15 editable-light ((obj editable-light) (arg0 vector) (arg1 int))
  (let ((v1-0 (-> obj region)))
    (if v1-0
        (set! (-> v1-0 changed) #t)
        )
    )
  (logior! (-> obj flags) (editable-flag changed))
  (vector+! (-> obj trans) (-> obj trans) arg0)
  (update-light-sphere-from-editable-light obj)
  (editable-method-28 obj (the-as editable-filter arg1))
  0
  (none)
  )

;; definition for method 25 of type editable-light
;; WARN: Return type mismatch int vs none.
;; WARN: Function (method 25 editable-light) has a return type of none, but the expression builder found a return statement.
(defmethod editable-method-25 editable-light ((obj editable-light) (arg0 editable-array))
  ((the-as (function editable-light editable-array none) (find-parent-method editable-light 25)) obj arg0)
  (when (nonzero? (-> obj id))
    (let ((s5-1 (clear *temp-string*)))
      (format s5-1 "delete from light where light_id=~D" (-> obj id))
      (let ((a2-1 (sql-query s5-1)))
        (when (!= (-> a2-1 error) 'modify)
          (format 0 "ERROR: sql: modify error ~A for ~A~%" a2-1 obj)
          (return 0)
          )
        )
      )
    )
  0
  (none)
  )

;; definition for method 22 of type editable-light
(defmethod editable-method-22 editable-light ((obj editable-light) (arg0 editable-array) (arg1 int) (arg2 int))
  (cond
    ((logtest? (-> obj flags) (editable-flag changed))
     (let ((s5-0 (clear *temp-string*)))
       (when (zero? (-> obj id))
         (format s5-0 "insert into light set level_name='~S'" (-> obj region level))
         (let ((s3-0 (sql-query s5-0)))
           (when (= (-> s3-0 error) 'modify)
             (let ((v1-7 (sql-query "select LAST_INSERT_ID()")))
               (when (= (-> v1-7 error) 'select)
                 (set! (-> obj id) (the-as uint (string->int (the-as string (-> v1-7 data 0)))))
                 (goto cfg-8)
                 )
               )
             )
           (format 0 "ERROR: sql: id insert error ~A for ~A~%" s3-0 obj)
           )
         (return #f)
         (label cfg-8)
         (let ((s3-1 (new 'debug 'string 32 (the-as string #f))))
           (format s3-1 "light-~d" (-> obj id))
           (set! (-> obj name) s3-1)
           )
         )
       (format (clear s5-0) "update light set level_name='~S', name='~S'" (-> obj region level) (-> obj name))
       (format
         s5-0
         ", pos_x=~f, pos_y=~f, pos_z=~f, r=~f"
         (* 0.00024414062 (- (-> obj trans x) (-> arg0 level-offset x)))
         (* 0.00024414062 (- (-> obj trans y) (-> arg0 level-offset y)))
         (* 0.00024414062 (- (-> obj trans z) (-> arg0 level-offset z)))
         (* 0.00024414062 (-> obj radius))
         )
       (if (= (-> obj direction w) 0.0)
           (format s5-0 ", dir_x=0.0, dir_y=0.0, dir_z=0.0")
           (format s5-0 ", dir_x=~f, dir_y=~f, dir_z=~f" (-> obj direction x) (-> obj direction y) (-> obj direction z))
           )
       (format
         s5-0
         ", color0_r=~f, color0_g=~f, color0_b=~f, color0_a=~f"
         (-> obj color x)
         (-> obj color y)
         (-> obj color z)
         (-> obj color w)
         )
       (format
         s5-0
         ", decay_start=~f, ambient_point_ratio=~f, brightness=~f"
         (-> obj decay-start)
         (-> obj ambient-point-ratio)
         (-> obj brightness)
         )
       (format s5-0 " where light_id=~D" (-> obj id))
       (let ((a0-21 (sql-query s5-0)))
         (when (= (-> a0-21 error) 'modify)
           (logclear! (-> obj flags) (editable-flag changed))
           #t
           )
         )
       )
     )
    (else
      #t
      )
    )
  )

;; definition for method 10 of type editable-light
(defmethod editable-method-10 editable-light ((obj editable-light))
  (if (!= (-> obj direction w) 0.0)
      (add-debug-vector
        #t
        (bucket-id bucket-318)
        (edit-get-trans obj)
        (-> obj direction)
        (* -1.2 (-> obj radius))
        (the-as rgba (-> (new 'static 'array uint64 1 #x80ff00ff) 0))
        )
      )
  (when (-> *editable* 0 light-names)
    (let ((s5-1 add-debug-text-3d)
          (s4-1 #t)
          (s3-1 318)
          )
      (format (clear *temp-string*) "~S~%" (-> obj name))
      (s5-1 s4-1 (the-as bucket-id s3-1) *temp-string* (-> obj trans) (font-color one) (the-as vector2h #f))
      )
    )
  ((method-of-type editable-sphere editable-method-10) obj)
  (none)
  )

;; definition for method 14 of type editable-face
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs vector.
(defmethod edit-get-trans editable-face ((obj editable-face))
  "Returns the `trans` [[vector]] or [[*null-vector*]]"
  "The center of the obj."
  (the-as vector (cond
                   ((>= (-> obj length) 3)
                    (let ((s5-0 (new 'static 'vector)))
                      (set! (-> s5-0 quad) (the-as uint128 0))
                      (vector+! s5-0 s5-0 (edit-get-trans (-> obj vertex 0)))
                      (vector+! s5-0 s5-0 (edit-get-trans (-> obj vertex 1)))
                      (vector+! s5-0 s5-0 (edit-get-trans (-> obj vertex 2)))
                      (vector-float*! s5-0 s5-0 0.33333334)
                      )
                    )
                   ((>= (-> obj length) 2)
                    (let ((s5-1 (new 'static 'vector)))
                      (set! (-> s5-1 quad) (the-as uint128 0))
                      (vector+! s5-1 s5-1 (edit-get-trans (-> obj vertex 0)))
                      (vector+! s5-1 s5-1 (edit-get-trans (-> obj vertex 1)))
                      (vector-float*! s5-1 s5-1 0.5)
                      )
                    )
                   (else
                     *null-vector*
                     )
                   )
          )
  )

;; definition for method 22 of type editable-face
(defmethod editable-method-22 editable-face ((obj editable-face) (arg0 editable-array) (arg1 int) (arg2 int))
  (let ((s4-0 (clear *temp-string*)))
    (format s4-0 "insert into region_face set kind='face',region_id=~D" (-> obj region id))
    (if (logtest? (-> obj flags) (editable-flag orient))
        (format s4-0 ",flags='orient'")
        )
    (let ((a0-5 (sql-query s4-0)))
      (if (!= (-> a0-5 error) 'modify)
          (return #f)
          )
      )
    )
  (dotimes (s4-1 (-> obj length))
    (editable-method-22 (-> obj vertex s4-1) arg0 2 s4-1)
    )
  (logclear! (-> obj flags) (editable-flag changed))
  #t
  )

;; definition for method 25 of type editable-face
(defmethod editable-method-25 editable-face ((obj editable-face) (arg0 editable-array))
  (dotimes (s4-0 (-> obj length))
    (let ((s3-0 (-> obj vertex s4-0)))
      (set! (-> s3-0 owner) (delete! obj (-> s3-0 owner)))
      )
    )
  ((the-as (function editable-face editable-array none) (find-parent-method editable-face 25)) obj arg0)
  (none)
  )

;; definition for method 26 of type editable-face
(defmethod editable-method-26 editable-face ((obj editable-face) (arg0 editable) (arg1 editable-array))
  (-> obj length)
  (countdown (v1-1 (-> obj length))
    (when (= (-> obj vertex v1-1) arg0)
      (let ((a0-5 v1-1)
            (a1-2 (+ (-> obj length) -2))
            )
        (while (>= a1-2 a0-5)
          (set! (-> obj vertex a0-5) (-> obj vertex (+ a0-5 1)))
          (+! a0-5 1)
          )
        )
      (+! (-> obj length) -1)
      )
    )
  (if (< (-> obj length) 3)
      (editable-array-method-15 arg1 obj)
      )
  ((method-of-type editable editable-method-26) obj arg0 arg1)
  (none)
  )

;; definition for method 27 of type editable-face
(defmethod editable-method-27 editable-face ((obj editable-face) (arg0 editable-array))
  (let ((gp-1
          ((the-as (function editable-face editable-array editable) (find-parent-method editable-face 27)) obj arg0)
          )
        )
    (dotimes (s4-0 (-> (the-as editable-face gp-1) length))
      (let ((v1-3 (editable-method-27 (the-as editable-face (l.wu (+ (* s4-0 4) (the-as int gp-1) 60))) arg0))
            (a0-5 (+ (* s4-0 4) (the-as int gp-1)))
            )
        (s.w! (+ a0-5 60) v1-3)
        )
      (let ((v0-3 (cons gp-1 (-> (the-as editable-face (+ (* s4-0 4) (the-as int gp-1))) vertex 0 owner)))
            (v1-10 (l.wu (+ (* s4-0 4) (the-as int gp-1) 60)))
            )
        (s.w! (+ v1-10 16) v0-3)
        )
      )
    gp-1
    )
  )

;; definition for method 24 of type editable-face
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-24 editable-face ((obj editable-face))
  (logxor! (-> obj flags) (editable-flag orient))
  (editable-face-method-31 obj (-> obj normal))
  (logior! (-> obj flags) (editable-flag changed))
  (set! (-> obj region changed) #t)
  0
  (none)
  )

;; definition for method 30 of type editable-face
;; INFO: Used lq/sq
(defmethod editable-face-method-30 editable-face ((obj editable-face) (arg0 (inline-array vector)))
  (let ((v1-0 (-> obj length)))
    (cond
      ((or (zero? v1-0) (= v1-0 1))
       0
       )
      ((= v1-0 2)
       (let ((s4-0 (edit-get-trans (-> obj vertex 0)))
             (v1-3 (edit-get-trans (-> obj vertex 1)))
             )
         (set! (-> arg0 0 quad) (-> s4-0 quad))
         (set! (-> arg0 1 quad) (-> s4-0 quad))
         (set! (-> arg0 1 y) (-> v1-3 y))
         (set! (-> arg0 2 quad) (-> v1-3 quad))
         (set! (-> arg0 2 y) (-> s4-0 y))
         (set! (-> arg0 3 quad) (-> v1-3 quad))
         )
       4
       )
      (else
        (dotimes (s4-1 (-> obj length))
          (set! (-> arg0 s4-1 quad) (-> (edit-get-trans (-> obj vertex s4-1)) quad))
          )
        (-> obj length)
        )
      )
    )
  )

;; definition for method 31 of type editable-face
;; INFO: Used lq/sq
(defmethod editable-face-method-31 editable-face ((obj editable-face) (arg0 vector))
  (let ((s4-0 (new 'stack-no-clear 'matrix)))
    (dotimes (v1-0 6)
      (set! (-> s4-0 vector v1-0 quad) (the-as uint128 0))
      )
    (if (>= (editable-face-method-30 obj (the-as (inline-array vector) s4-0)) 3)
        (normal-of-plane arg0 (the-as vector (-> s4-0 vector)) (-> s4-0 vector 1) (-> s4-0 vector 2))
        )
    )
  (if (logtest? (-> obj flags) (editable-flag orient))
      (vector-negate! arg0 arg0)
      )
  arg0
  )

;; definition for method 13 of type editable-face
;; INFO: Used lq/sq
;; ERROR: failed type prop at 57: add failed: object <integer 0>

;; WARN: Return type mismatch number vs float.
(defmethod edit-get-distance editable-face ((a0-0 editable-face) (a1-0 vector))
  (local-vars
    (v0-0 vector)
    (v0-1 vector)
    (v0-2 symbol)
    (v0-3 none)
    (v0-4 int)
    (v0-5 vector)
    (v0-6 symbol)
    (v0-7 symbol)
    (v0-8 vector)
    (v0-9 float)
    (v0-10 number)
    (v1-0 type)
    (v1-1 type)
    (v1-2 vector)
    (v1-3 uint128)
    (v1-5 int)
    (v1-8 type)
    (v1-9 symbol)
    (v1-12 int)
    (a0-1 editable-face)
    (a0-2 editable-point)
    (a0-3 vector)
    (a0-4 vector)
    (a0-5 int)
    (a0-6 vector)
    (a0-7 editable-face)
    (a0-8 vector)
    (a0-9 vector)
    (a0-10 vector)
    (a0-11 vector)
    (a1-1 vector)
    (a1-2 vector)
    (a1-3 vector)
    (a1-4 (inline-array vector))
    (a1-5 vector)
    (a1-6 vector)
    (a1-7 vector)
    (a1-8 vector)
    (a2-0 vector)
    (a2-1 vector)
    (a2-2 vector)
    (a3-0 vector)
    (a3-1 vector)
    (a3-2 vector)
    (t0-0 vector)
    (t0-1 vector)
    (s1-0 vector)
    (s1-1 vector)
    (s2-0 vector)
    (s2-1 int)
    (s3-1 object)
    (s4-1 int)
    (s5-0 vector)
    (s5-1 (function vector vector float))
    (t9-0 (function editable-face vector vector))
    (t9-1 (function editable-point vector))
    (t9-2 (function vector vector symbol))
    (t9-3 (function vector vector vector vector none))
    (t9-4 (function editable-face (inline-array vector) int))
    (t9-5 (function vector vector vector))
    (t9-6 (function vector vector vector vector vector symbol))
    (t9-7 (function vector vector vector vector vector symbol))
    (t9-8 (function vector))
    (t9-9 (function vector vector float))
    (gp-0 vector)
    (f0-0 float)
    (f1-0 float)
    )
  "Returns the distance from the camera to the [[editable]], or -1.0"
  (when (begin
          (set! gp-0 (new 'stack-no-clear 'vector))
          (set! a0-1 a0-0)
          (set! v1-0 (-> a0-1 type))
          (set! t9-0 (method-of-type v1-0 editable-face-method-31))
          (set! a1-1 (new 'stack-no-clear 'vector))
          (set! v0-0 (call! a0-1 a1-1))
          (set! s5-0 v0-0)
          (set! s2-0 (new 'stack-no-clear 'vector))
          (set! s1-0 s2-0)
          (set! a0-2 (-> a0-0 vertex 0))
          (set! v1-1 (-> a0-2 type))
          (set! t9-1 (method-of-type v1-1 edit-get-trans))
          (set! v0-1 (call! a0-2))
          (set! v1-2 v0-1)
          (set! v1-3 (-> v1-2 quad))
          (set! (-> s1-0 quad) v1-3)
          (set! t9-2 transform-point-vector!)
          (set! a0-3 gp-0)
          (set! a1-2 s2-0)
          (call! a0-3 a1-2)
          (set! f0-0 0.0)
          (set! f1-0 (-> gp-0 z))
          (<.s f0-0 f1-0)
          )
    (set! t9-3 reverse-transform-point!)
    (set! a0-4 gp-0)
    (set! a2-0 s5-0)
    (set! a1-3 s2-0)
    (set! a3-0 a1-0)
    (call! a0-4 a1-3 a2-0 a3-0)
    (set! s3-1 (new 'stack-no-clear 'inline-array 'vector 6))
    (set! v1-5 0)
    (while (<.si v1-5 6)
      (set! a0-5 (sll v1-5 4))
      (set! a0-6 (+ s3-1 a0-5))
      (set! (-> a0-6 quad) (the-as uint128 0))
      (set! v1-5 (+ v1-5 1))
      )
    (set! v1-8 (-> a0-0 type))
    (set! t9-4 (method-of-type v1-8 editable-face-method-30))
    (set! a1-4 s3-1)
    (set! a0-7 a0-0)
    (set! v0-4 (call! a0-7 a1-4))
    (set! s4-1 v0-4)
    (set! s2-1 0)
    (set! t9-5 vector-negate!)
    (set! a0-8 (new 'stack-no-clear 'vector))
    (set! a1-5 s5-0)
    (set! v0-5 (call! a0-8 a1-5))
    (set! s1-1 v0-5)
    (while (begin (set! v1-12 (+ s2-1 2)) (<.si v1-12 s4-1))
      (if (begin
            (or (begin
                  (set! t9-6 point-in-triangle-cross)
                  (set! a0-9 gp-0)
                  (set! a1-6 s5-0)
                  (set! a2-1 (+ s3-1 0))
                  (set! a3-1 (+ s3-1 16))
                  (set! t0-0 (+ s3-1 32))
                  (set! v0-6 (call! a0-9 a1-6 a2-1 a3-1 t0-0))
                  v0-6
                  )
                (begin
                  (set! t9-7 point-in-triangle-cross)
                  (set! a0-10 gp-0)
                  (set! a1-7 s1-1)
                  (set! a2-2 (-> s3-1 0))
                  (set! a3-2 (-> s3-1 1))
                  (set! t0-1 (-> s3-1 2))
                  (set! v0-7 (call! a0-10 a1-7 a2-2 a3-2 t0-1))
                  (set! v1-9 v0-7)
                  )
                )
            v1-9
            )
          (return (begin
                    (set! s5-1 vector-vector-distance)
                    (set! t9-8 camera-pos)
                    (set! v0-8 (call!))
                    (set! a0-11 v0-8)
                    (set! t9-9 s5-1)
                    (set! a1-8 gp-0)
                    (set! v0-9 (call! a0-11 a1-8))
                    (set! v0-10 v0-9)
                    )
                  )
          )
      (set! s2-1 (+ s2-1 1))
      (set! s3-1 (-> s3-1 1))
      )
    )
  (set! v0-10 -1082130432)
  (ret-value v0-10)
  )

;; definition for method 29 of type editable-face
;; INFO: Used lq/sq
;; WARN: Stack slot offset 292 signed mismatch
;; WARN: Stack slot offset 292 signed mismatch
;; WARN: Stack slot offset 292 signed mismatch
;; WARN: Stack slot offset 376 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 376 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 292 signed mismatch
;; WARN: Stack slot offset 292 signed mismatch
;; WARN: Stack slot offset 292 signed mismatch
;; WARN: Stack slot offset 376 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 376 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 292 signed mismatch
;; WARN: Stack slot offset 292 signed mismatch
;; WARN: Stack slot offset 292 signed mismatch
;; WARN: Stack slot offset 376 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 376 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 292 signed mismatch
;; WARN: Stack slot offset 292 signed mismatch
;; WARN: Stack slot offset 292 signed mismatch
;; WARN: Stack slot offset 292 signed mismatch
;; WARN: Stack slot offset 376 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 376 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 292 signed mismatch
;; WARN: Stack slot offset 292 signed mismatch
;; WARN: Stack slot offset 292 signed mismatch
;; WARN: Stack slot offset 376 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 376 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 292 signed mismatch
;; WARN: Stack slot offset 292 signed mismatch
;; WARN: Stack slot offset 292 signed mismatch
;; WARN: Stack slot offset 376 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 376 signed mismatch
;; WARN: Stack slot offset 400 signed mismatch
;; WARN: Stack slot offset 292 signed mismatch
;; WARN: Return type mismatch int vs symbol.
(defmethod editable-method-29 editable-face ((obj editable-face) (arg0 editable-filter))
  (local-vars
    (sv-208 (inline-array vector))
    (sv-216 int)
    (sv-288 array)
    (sv-292 int)
    (sv-296 int)
    (sv-368 matrix)
    (sv-372 uint)
    (sv-376 number)
    (sv-380 symbol)
    (sv-400 float)
    )
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
    (init-vf0-vector)
    (if (or (logtest? arg0 (editable-filter water-command)) (logtest? (-> obj flags) (editable-flag mark)))
        (return (the-as symbol #f))
        )
    (logior! (-> obj flags) (editable-flag mark))
    (let ((s5-0 (new 'stack-no-clear 'inline-array 'vector 6)))
      (dotimes (v1-7 6)
        (set! (-> s5-0 v1-7 quad) (the-as uint128 0))
        )
      (let ((s4-0 (editable-face-method-30 obj s5-0)))
        (when (and (>= s4-0 4) (>= (-> obj length) 3))
          (let ((v1-14 0))
            (dotimes (a0-7 s4-0)
              (if (logtest? (-> obj vertex a0-7 flags) (editable-flag selected))
                  (+! v1-14 1)
                  )
              )
            (cond
              ((= v1-14 s4-0)
               (set! arg0 (logior arg0 (editable-filter load)))
               )
              ((= v1-14 2)
               (let ((v1-15 (new 'stack-no-clear 'inline-array 'vector 6)))
                 (dotimes (a0-12 6)
                   (set! (-> v1-15 a0-12 quad) (the-as uint128 0))
                   )
                 (set! sv-208 v1-15)
                 )
               (set! sv-216 0)
               (dotimes (s2-2 s4-0)
                 (when (zero? (logand (-> obj vertex s2-2 flags) (editable-flag selected)))
                   (set! (-> sv-208 sv-216 quad) (-> (edit-get-trans (-> obj vertex s2-2)) quad))
                   (set! sv-216 (+ sv-216 1))
                   )
                 )
               (dotimes (s2-3 s4-0)
                 (when (logtest? (-> obj vertex s2-3 flags) (editable-flag selected))
                   (set! (-> sv-208 sv-216 quad) (-> (edit-get-trans (-> obj vertex s2-3)) quad))
                   (set! sv-216 (+ sv-216 1))
                   )
                 )
               (normal-of-plane (-> obj normal) (-> sv-208 0) (-> sv-208 1) (-> sv-208 2))
               (set! (-> obj center quad) (-> (edit-get-trans obj) quad))
               )
              )
            )
          (when (zero? (logand arg0 (editable-filter load)))
            (when (= (-> obj normal w) 0.0)
              (editable-face-method-31 obj (-> obj normal))
              (set! (-> obj center quad) (-> (edit-get-trans obj) quad))
              )
            (let ((s3-2 0)
                  (s2-5 (-> obj normal))
                  (s1-2 (-> obj center))
                  )
              (while (< s3-2 s4-0)
                (when (logtest? (-> obj vertex s3-2 flags) (editable-flag selected))
                  (let* ((a1-14 (vector-! (new 'stack-no-clear 'vector) (-> s5-0 s3-2) s1-2))
                         (f0-2 (vector-dot a1-14 s2-5))
                         (a0-27 (-> obj vertex s3-2))
                         (t9-7 (method-of-object a0-27 edit-coord!))
                         )
                    (let ((v1-76 (-> s5-0 s3-2))
                          (a2-1 s2-5)
                          (f0-3 (- f0-2))
                          )
                      (.lvf vf2 (&-> a2-1 quad))
                      (.lvf vf1 (&-> v1-76 quad))
                      (let ((v1-77 f0-3))
                        (.mov vf3 v1-77)
                        )
                      )
                    (.add.x.vf vf4 vf0 vf0 :mask #b1000)
                    (.mul.x.vf acc vf2 vf3)
                    (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
                    (.svf (&-> a1-14 quad) vf4)
                    (t9-7 a0-27 a1-14 (editable-flag x y z no-plane-snap))
                    )
                  )
                (+! s3-2 1)
                )
              )
            )
          (set! sv-288
                ((method-of-type array new)
                 (the-as symbol (new 'stack-no-clear 'array 'editable-point 6))
                 array
                 editable-point
                 6
                 )
                )
          (set! sv-292 (+ (-> obj length) -1))
          (set! sv-296 1)
          (editable-face-method-31 obj (-> obj normal))
          (dotimes (v1-86 sv-292)
            (set! (-> (the-as editable-point (+ (* v1-86 4) (the-as int sv-288))) region)
                  (the-as editable-region (-> obj vertex (+ v1-86 1)))
                  )
            )
          (set! sv-368 (new-stack-matrix0))
          (set! sv-372 (the-as uint #f))
          (set! sv-376 0.0)
          (set! sv-380 #t)
          (vector-normalize!
            (vector-! (-> sv-368 vector 2) (edit-get-trans obj) (edit-get-trans (-> obj vertex 0)))
            1.0
            )
          (vector-normalize! (editable-face-method-31 obj (-> sv-368 vector 1)) 1.0)
          (vector-normalize!
            (vector-cross! (the-as vector (-> sv-368 vector)) (-> sv-368 vector 2) (-> sv-368 vector 1))
            1.0
            )
          (set! (-> sv-368 trans quad) (-> (edit-get-trans (-> obj vertex 0)) quad))
          (set! (-> sv-368 trans w) 1.0)
          (matrix-4x4-inverse! sv-368 sv-368)
          (while (< sv-296 (-> obj length))
            (set! sv-372 (the-as uint #f))
            (dotimes (s5-4 sv-292)
              (when (l.wu (+ (* s5-4 4) (the-as int sv-288) 12))
                (let* ((a1-26 (edit-get-trans (-> (the-as (array editable-point) sv-288) s5-4)))
                       (a0-48 (vector-matrix*! (new 'stack-no-clear 'vector) a1-26 sv-368))
                       )
                  (set! sv-400 (vector-y-angle a0-48))
                  )
                (cond
                  (sv-380
                    (when (or (not sv-372) (< (the-as float (gpr->fpr sv-376)) sv-400))
                      (set! sv-372 (l.wu (+ (* s5-4 4) (the-as int sv-288) 12)))
                      (set! sv-376 sv-400)
                      )
                    )
                  (else
                    (when (or (not sv-372) (< sv-400 (the-as float (gpr->fpr sv-376))))
                      (set! sv-372 (l.wu (+ (* s5-4 4) (the-as int sv-288) 12)))
                      (set! sv-376 sv-400)
                      )
                    )
                  )
                )
              )
            (set! (-> obj vertex sv-296) (the-as editable-point sv-372))
            (dotimes (v1-138 sv-292)
              (when (= sv-372 (l.wu (+ (* v1-138 4) (the-as int sv-288) 12)))
                (let ((a0-59 (+ (* v1-138 4) (the-as int sv-288))))
                  (s.w! (+ a0-59 12) #f)
                  )
                )
              )
            (set! sv-296 (+ sv-296 1))
            (set! sv-380 (not sv-380))
            )
          (if (< (vector-dot (-> obj normal) (editable-face-method-31 obj (new 'stack-no-clear 'vector))) 0.0)
              (logxor! (-> obj flags) (editable-flag orient))
              )
          )
        )
      )
    (editable-face-method-31 obj (-> obj normal))
    (set! (-> obj center quad) (-> (edit-get-trans obj) quad))
    (the-as symbol 0)
    )
  )

;; definition for method 10 of type editable-face
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-10 editable-face ((obj editable-face))
  (local-vars (sv-112 int))
  (let ((gp-0 (new 'stack-no-clear 'inline-array 'vector 6)))
    (dotimes (v1-0 6)
      (set! (-> gp-0 v1-0 quad) (the-as uint128 0))
      )
    (set! sv-112 (editable-face-method-30 obj gp-0))
    (when (>= sv-112 3)
      (let ((s1-0 (editable-face-method-31 obj (new 'stack-no-clear 'vector))))
        (add-debug-vector
          #t
          (bucket-id bucket-318)
          (edit-get-trans obj)
          s1-0
          (the-as meters #x46000000)
          (the-as rgba (-> (new 'static 'array uint64 1 #x8000ffff) 0))
          )
        )
      (when (logtest? (-> obj flags) (editable-flag selected))
        (dotimes (s4-1 sv-112)
          (let ((s3-1 add-debug-text-3d)
                (s2-1 #t)
                (s1-1 318)
                )
            (format (clear *temp-string*) "~D" s4-1)
            (s3-1
              s2-1
              (the-as bucket-id s1-1)
              *temp-string*
              (-> gp-0 s4-1)
              (if (logtest? (-> obj flags) (editable-flag orient))
                  (font-color fc-5)
                  (font-color one)
                  )
              (the-as vector2h #f)
              )
            )
          )
        )
      (add-debug-bound
        324
        (the-as transform gp-0)
        sv-112
        (if (logtest? (-> obj flags) (editable-flag orient))
            (the-as rgba (-> (new 'static 'array uint64 1 #x800000ff) 0))
            (the-as rgba (-> (new 'static 'array uint64 1 #x8000ffff) 0))
            )
        (if (zero? (logand (-> obj flags) (editable-flag orient)))
            (the-as rgba (-> (new 'static 'array uint64 1 #x800000ff) 0))
            (the-as rgba (-> (new 'static 'array uint64 1 #x8000ffff) 0))
            )
        (if (logtest? (-> obj flags) (editable-flag selected))
            1
            0
            )
        )
      )
    )
  0
  (none)
  )

;; definition for method 14 of type editable-plane
(defmethod edit-get-trans editable-plane ((obj editable-plane))
  "Returns the `trans` [[vector]] or [[*null-vector*]]"
  (if (>= (-> obj length) 1)
      (edit-get-trans (-> obj vertex 0))
      *null-vector*
      )
  )

;; definition for method 22 of type editable-plane
(defmethod editable-method-22 editable-plane ((obj editable-plane) (arg0 editable-array) (arg1 int) (arg2 int))
  (let ((s4-0 (clear *temp-string*)))
    (format
      s4-0
      "insert into region_face set kind='plane',region_id=~D,radius=~f"
      (-> obj region id)
      (-> obj radius)
      )
    (let ((a0-4 (sql-query s4-0)))
      (if (!= (-> a0-4 error) 'modify)
          (return #f)
          )
      )
    )
  (dotimes (s4-1 (-> obj length))
    (editable-method-22 (-> obj vertex s4-1) arg0 2 s4-1)
    )
  (logclear! (-> obj flags) (editable-flag changed))
  #t
  )

;; definition for method 25 of type editable-plane
(defmethod editable-method-25 editable-plane ((obj editable-plane) (arg0 editable-array))
  (dotimes (s4-0 (-> obj length))
    (let ((s3-0 (-> obj vertex s4-0)))
      (set! (-> s3-0 owner) (delete! obj (-> s3-0 owner)))
      )
    )
  ((the-as (function editable-plane editable-array none) (find-parent-method editable-plane 25)) obj arg0)
  (none)
  )

;; definition for method 26 of type editable-plane
(defmethod editable-method-26 editable-plane ((obj editable-plane) (arg0 editable) (arg1 editable-array))
  (editable-array-method-15 arg1 obj)
  ((method-of-type editable editable-method-26) obj arg0 arg1)
  (none)
  )

;; definition for method 27 of type editable-plane
(defmethod editable-method-27 editable-plane ((obj editable-plane) (arg0 editable-array))
  (let ((gp-1
          ((the-as (function editable-plane editable-array editable) (find-parent-method editable-plane 27)) obj arg0)
          )
        )
    (dotimes (s4-0 (-> (the-as editable-plane gp-1) length))
      (let ((v1-3 (editable-method-27 (-> (the-as editable-plane (+ (* s4-0 4) (the-as int gp-1))) vertex 0) arg0))
            (a0-5 (+ (* s4-0 4) (the-as int gp-1)))
            )
        (s.w! (+ a0-5 28) v1-3)
        )
      (let ((v0-3 (cons gp-1 (-> (the-as editable-plane (+ (* s4-0 4) (the-as int gp-1))) vertex 0 owner)))
            (v1-10 (l.wu (+ (* s4-0 4) (the-as int gp-1) 28)))
            )
        (s.w! (+ v1-10 16) v0-3)
        )
      )
    gp-1
    )
  )

;; definition for method 24 of type editable-plane
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-24 editable-plane ((obj editable-plane))
  (let ((s5-1
          (vector-! (new 'stack-no-clear 'vector) (edit-get-trans (-> obj vertex 1)) (edit-get-trans (-> obj vertex 0)))
          )
        )
    (edit-coord! (-> obj vertex 1) (vector-! s5-1 (edit-get-trans (-> obj vertex 0)) s5-1) (editable-flag x y z))
    )
  (set! (-> obj region changed) #t)
  (logior! (-> obj flags) (editable-flag changed))
  0
  (none)
  )

;; definition for method 30 of type editable-plane
(defmethod editable-plane-method-30 editable-plane ((obj editable-plane) (arg0 matrix))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
    (init-vf0-vector)
    (case (-> obj length)
      ((2)
       (let* ((v1-2 (editable-plane-method-31 obj (new 'stack-no-clear 'vector)))
              (s5-1 (vector-cross!
                      (new 'stack-no-clear 'vector)
                      v1-2
                      (if (< 0.7 (fabs (vector-dot v1-2 (new 'static 'vector :z 1.0 :w 1.0))))
                          (new 'static 'vector :x 1.0 :w 1.0)
                          (new 'static 'vector :z 1.0 :w 1.0)
                          )
                      )
                    )
              (s4-1 (vector-cross! (new 'stack-no-clear 'vector) s5-1 v1-2))
              (f30-0 (-> obj radius))
              )
         (let ((v1-4 (edit-get-trans (-> obj vertex 0))))
           (let ((a0-6 (-> arg0 vector)))
             (let ((a1-6 v1-4)
                   (a2-1 s5-1)
                   (f0-1 f30-0)
                   )
               (.lvf vf2 (&-> a2-1 quad))
               (.lvf vf1 (&-> a1-6 quad))
               (let ((a1-7 f0-1))
                 (.mov vf3 a1-7)
                 )
               )
             (.add.x.vf vf4 vf0 vf0 :mask #b1000)
             (.mul.x.vf acc vf2 vf3)
             (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
             (.svf (&-> a0-6 0 quad) vf4)
             )
           (let ((a0-7 (-> arg0 vector)))
             (let ((a1-8 (-> arg0 vector))
                   (a2-2 s4-1)
                   (f0-2 (- f30-0))
                   )
               (.lvf vf2 (&-> a2-2 quad))
               (.lvf vf1 (&-> a1-8 0 quad))
               (let ((a1-9 f0-2))
                 (.mov vf3 a1-9)
                 )
               )
             (.add.x.vf vf4 vf0 vf0 :mask #b1000)
             (.mul.x.vf acc vf2 vf3)
             (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
             (.svf (&-> a0-7 0 quad) vf4)
             )
           (let ((a0-8 (-> arg0 vector 1)))
             (let ((a1-10 v1-4)
                   (a2-3 s5-1)
                   (f0-3 (- f30-0))
                   )
               (.lvf vf2 (&-> a2-3 quad))
               (.lvf vf1 (&-> a1-10 quad))
               (let ((a1-11 f0-3))
                 (.mov vf3 a1-11)
                 )
               )
             (.add.x.vf vf4 vf0 vf0 :mask #b1000)
             (.mul.x.vf acc vf2 vf3)
             (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
             (.svf (&-> a0-8 quad) vf4)
             )
           (let ((a0-9 (-> arg0 vector 1)))
             (let ((a1-12 (-> arg0 vector 1))
                   (a2-4 s4-1)
                   (f0-4 (- f30-0))
                   )
               (.lvf vf2 (&-> a2-4 quad))
               (.lvf vf1 (&-> a1-12 quad))
               (let ((a1-13 f0-4))
                 (.mov vf3 a1-13)
                 )
               )
             (.add.x.vf vf4 vf0 vf0 :mask #b1000)
             (.mul.x.vf acc vf2 vf3)
             (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
             (.svf (&-> a0-9 quad) vf4)
             )
           (let ((a0-10 (-> arg0 vector 2)))
             (let ((a1-14 v1-4)
                   (a2-5 s5-1)
                   (f0-5 f30-0)
                   )
               (.lvf vf2 (&-> a2-5 quad))
               (.lvf vf1 (&-> a1-14 quad))
               (let ((a1-15 f0-5))
                 (.mov vf3 a1-15)
                 )
               )
             (.add.x.vf vf4 vf0 vf0 :mask #b1000)
             (.mul.x.vf acc vf2 vf3)
             (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
             (.svf (&-> a0-10 quad) vf4)
             )
           (let ((a0-11 (-> arg0 vector 2)))
             (let ((a1-16 (-> arg0 vector 2))
                   (a2-6 s4-1)
                   (f0-6 f30-0)
                   )
               (.lvf vf2 (&-> a2-6 quad))
               (.lvf vf1 (&-> a1-16 quad))
               (let ((a1-17 f0-6))
                 (.mov vf3 a1-17)
                 )
               )
             (.add.x.vf vf4 vf0 vf0 :mask #b1000)
             (.mul.x.vf acc vf2 vf3)
             (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
             (.svf (&-> a0-11 quad) vf4)
             )
           (let ((a0-12 (-> arg0 trans)))
             (let ((f0-7 (- f30-0)))
               (.lvf vf2 (&-> s5-1 quad))
               (.lvf vf1 (&-> v1-4 quad))
               (let ((v1-5 f0-7))
                 (.mov vf3 v1-5)
                 )
               )
             (.add.x.vf vf4 vf0 vf0 :mask #b1000)
             (.mul.x.vf acc vf2 vf3)
             (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
             (.svf (&-> a0-12 quad) vf4)
             )
           )
         (let ((v1-6 (-> arg0 trans)))
           (let ((a0-13 (-> arg0 trans)))
             (.lvf vf2 (&-> s4-1 quad))
             (.lvf vf1 (&-> a0-13 quad))
             )
           (let ((a0-14 f30-0))
             (.mov vf3 a0-14)
             )
           (.add.x.vf vf4 vf0 vf0 :mask #b1000)
           (.mul.x.vf acc vf2 vf3)
           (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
           (.svf (&-> v1-6 quad) vf4)
           )
         )
       4
       )
      (else
        0
        )
      )
    )
  )

;; definition for method 31 of type editable-plane
(defmethod editable-plane-method-31 editable-plane ((obj editable-plane) (arg0 vector))
  (case (-> obj length)
    ((2)
     (let ((s3-0 (-> obj vertex 0))
           (a0-1 (-> obj vertex 1))
           )
       (vector-! arg0 (edit-get-trans a0-1) (edit-get-trans s3-0))
       )
     (vector-normalize! arg0 1.0)
     )
    )
  arg0
  )

;; definition for method 13 of type editable-plane
;; INFO: Used lq/sq
;; ERROR: failed type prop at 64: add failed: structure <integer 16>

(defmethod edit-get-distance editable-plane ((a0-0 editable-plane) (a1-0 vector))
  (local-vars
    (v0-0 vector)
    (v0-1 vector)
    (v0-2 symbol)
    (v0-3 vector)
    (v0-4 none)
    (v0-5 int)
    (v0-6 vector)
    (v0-7 symbol)
    (v0-8 symbol)
    (v0-9 vector)
    (v0-10 float)
    (v0-11 float)
    (v1-0 type)
    (v1-1 type)
    (v1-2 vector)
    (v1-3 uint128)
    (v1-5 type)
    (v1-6 int)
    (v1-9 type)
    (v1-10 symbol)
    (v1-13 int)
    (a0-1 editable-plane)
    (a0-2 editable-point)
    (a0-3 vector)
    (a0-4 editable-point)
    (a0-5 vector)
    (a0-6 int)
    (a0-7 int)
    (a0-8 editable-plane)
    (a0-9 transform)
    (a0-10 vector)
    (a0-11 none)
    (a0-12 vector)
    (a1-1 vector)
    (a1-2 vector)
    (a1-3 vector)
    (a1-4 matrix)
    (a1-5 vector)
    (a1-6 vector)
    (a1-7 vector)
    (a1-8 none)
    (a2-0 vector)
    (a2-1 structure)
    (a2-2 (inline-array vector))
    (a3-0 vector)
    (a3-1 vector)
    (a3-2 vector)
    (t0-0 vector)
    (t0-1 vector)
    (s1-0 vector)
    (s1-1 vector)
    (s1-2 vector)
    (s2-0 vector)
    (s2-1 (function vector vector vector vector none))
    (s2-2 int)
    (s3-1 structure)
    (s4-1 int)
    (s5-0 vector)
    (s5-1 (function vector vector float))
    (t9-0 (function editable-plane vector vector))
    (t9-1 (function editable-point vector))
    (t9-2 (function vector vector symbol))
    (t9-3 (function editable-point vector))
    (t9-4 (function vector vector vector vector none))
    (t9-5 (function editable-plane matrix int))
    (t9-6 (function vector vector vector))
    (t9-7 (function vector vector vector vector vector symbol))
    (t9-8 (function vector vector vector vector vector symbol))
    (t9-9 (function vector))
    (t9-10 (function vector vector float))
    (gp-0 vector)
    (f0-0 float)
    (f1-0 float)
    )
  "Returns the distance from the camera to the [[editable]], or -1.0"
  (when (begin
          (set! gp-0 (new 'stack-no-clear 'vector))
          (set! a0-1 a0-0)
          (set! v1-0 (-> a0-1 type))
          (set! t9-0 (method-of-type v1-0 editable-plane-method-31))
          (set! a1-1 (new 'stack-no-clear 'vector))
          (set! v0-0 (call! a0-1 a1-1))
          (set! s5-0 v0-0)
          (set! s1-0 (new 'stack-no-clear 'vector))
          (set! s2-0 s1-0)
          (set! a0-2 (-> a0-0 vertex 0))
          (set! v1-1 (-> a0-2 type))
          (set! t9-1 (method-of-type v1-1 edit-get-trans))
          (set! v0-1 (call! a0-2))
          (set! v1-2 v0-1)
          (set! v1-3 (-> v1-2 quad))
          (set! (-> s2-0 quad) v1-3)
          (set! t9-2 transform-point-vector!)
          (set! a0-3 gp-0)
          (set! a1-2 s1-0)
          (call! a0-3 a1-2)
          (set! f0-0 0.0)
          (set! f1-0 (-> gp-0 z))
          (<.s f0-0 f1-0)
          )
    (set! s2-1 reverse-transform-point!)
    (set! s1-1 gp-0)
    (set! a0-4 (-> a0-0 vertex 0))
    (set! v1-5 (-> a0-4 type))
    (set! t9-3 (method-of-type v1-5 edit-get-trans))
    (set! v0-3 (call! a0-4))
    (set! a1-3 v0-3)
    (set! a2-0 s5-0)
    (set! t9-4 s2-1)
    (set! a0-5 s1-1)
    (set! a3-0 a1-0)
    (call! a0-5 a1-3 a2-0 a3-0)
    (set! s3-1 (new 'stack-no-clear 'matrix))
    (set! v1-6 0)
    (while (<.si v1-6 4)
      (set! a0-6 (sll v1-6 4))
      (set! a0-7 (+ s3-1 a0-6))
      (set! (dynamic-array-field-access a0-7 vector PLACEHOLDER quad) 0)
      (set! v1-6 (+ v1-6 1))
      )
    (set! v1-9 (-> a0-0 type))
    (set! t9-5 (method-of-type v1-9 editable-plane-method-30))
    (set! a1-4 s3-1)
    (set! a0-8 a0-0)
    (set! v0-5 (call! a0-8 a1-4))
    (set! s4-1 v0-5)
    (set! s2-2 0)
    (set! t9-6 vector-negate!)
    (set! a0-9 (new 'stack-no-clear 'transform))
    (set! a1-5 s5-0)
    (set! v0-6 (call! a0-9 a1-5))
    (set! s1-2 v0-6)
    (while (begin (set! v1-13 (+ s2-2 2)) (<.si v1-13 s4-1))
      (if (begin
            (or (begin
                  (set! t9-7 point-in-triangle-cross)
                  (set! a0-10 gp-0)
                  (set! a1-6 s5-0)
                  (set! a2-1 (+ s3-1 0))
                  (set! a3-1 (+ s3-1 16))
                  (set! t0-0 (+ s3-1 32))
                  (set! v0-7 (call! a0-10 a1-6 a2-1 a3-1 t0-0))
                  v0-7
                  )
                (begin
                  (set! t9-8 point-in-triangle-cross)
                  (set! a0-11 (the-as none gp-0))
                  (set! a1-7 s1-2)
                  (set! a2-2 (-> s3-1 vector))
                  (set! a3-2 (-> s3-1 vector 1))
                  (set! t0-1 (-> s3-1 vector 2))
                  (set! v0-8 (call! a0-11 a1-7 a2-2 a3-2 t0-1))
                  (set! v1-10 v0-8)
                  )
                )
            v1-10
            )
          (return (begin
                    (set! s5-1 vector-vector-distance)
                    (set! t9-9 camera-pos)
                    (set! v0-9 (call!))
                    (set! a0-12 v0-9)
                    (set! t9-10 s5-1)
                    (set! a1-8 (the-as none gp-0))
                    (set! v0-10 (call! a0-12 a1-8))
                    (set! v0-11 v0-10)
                    )
                  )
          )
      (set! s2-2 (+ s2-2 1))
      (set! s3-1 (-> s3-1 vector 1))
      )
    )
  (set! v0-11 -1.0)
  (ret-value v0-11)
  )

;; definition for method 10 of type editable-plane
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-10 editable-plane ((obj editable-plane))
  (let ((gp-0 (new 'stack-no-clear 'matrix)))
    (dotimes (v1-0 4)
      (set! (-> gp-0 vector v1-0 quad) (the-as uint128 0))
      )
    (let ((s4-0 (editable-plane-method-30 obj gp-0)))
      (when (>= s4-0 3)
        (add-debug-line
          #t
          (bucket-id bucket-318)
          (edit-get-trans (-> obj vertex 0))
          (edit-get-trans (-> obj vertex 1))
          (the-as rgba (-> (new 'static 'array uint64 1 #x8000ffff) 0))
          #f
          (the-as rgba -1)
          )
        (add-debug-bound
          324
          (the-as transform gp-0)
          s4-0
          (if (logtest? (-> obj flags) (editable-flag orient))
              (the-as rgba (-> (new 'static 'array uint64 1 #x800000ff) 0))
              (the-as rgba (-> (new 'static 'array uint64 1 #x8000ffff) 0))
              )
          (if (zero? (logand (-> obj flags) (editable-flag orient)))
              (the-as rgba (-> (new 'static 'array uint64 1 #x800000ff) 0))
              (the-as rgba (-> (new 'static 'array uint64 1 #x8000ffff) 0))
              )
          (if (logtest? (-> obj flags) (editable-flag selected))
              1
              0
              )
          )
        )
      )
    )
  0
  (none)
  )

;; definition for method 17 of type editable-plane
;; WARN: Return type mismatch int vs none.
(defmethod editable-method-17 editable-plane ((obj editable-plane) (arg0 vector))
  (let ((v1-0 (-> obj region)))
    (if v1-0
        (set! (-> v1-0 changed) #t)
        )
    )
  (logior! (-> obj flags) (editable-flag changed))
  (if (= (-> arg0 y) 0.0)
      (+! (-> obj radius) (-> arg0 x))
      (set! (-> obj radius) (-> arg0 y))
      )
  (if (< (-> obj radius) 0.0)
      (set! (-> obj radius) 0.0)
      )
  (editable-method-28 obj (editable-filter load))
  0
  (none)
  )

;; definition for method 7 of type editable-array
;; WARN: Return type mismatch (array editable) vs editable-array.
(defmethod relocate editable-array ((obj editable-array) (arg0 int))
  (the-as editable-array (when (nonzero? (-> obj selection))
                           (let ((v0-0 (&+ (-> obj selection) arg0)))
                             (set! (-> obj selection) v0-0)
                             v0-0
                             )
                           )
          )
  )

;; definition for method 4 of type editable-array
(defmethod length editable-array ((obj editable-array))
  (-> obj length)
  )

;; definition for method 5 of type editable-array
;; WARN: Return type mismatch uint vs int.
(defmethod asize-of editable-array ((obj editable-array))
  (the-as int (+ (-> obj type size) (* (-> obj allocated-length) 4)))
  )

;; definition for method 11 of type editable-array
(defmethod editable-array-method-11 editable-array ((obj editable-array))
  (dotimes (v1-0 (-> obj length))
    (if (not (-> obj data v1-0))
        (return v1-0)
        )
    )
  (when (< (-> obj length) (-> obj allocated-length))
    (+! (-> obj length) 1)
    (return (+ (-> obj length) -1))
    )
  -1
  )

;; definition for method 10 of type editable-array
(defmethod editable-array-method-10 editable-array ((obj editable-array) (arg0 vector) (arg1 int))
  (when (or (!= (-> arg0 x) (-> *editable-work* last-x)) (!= (-> arg0 y) (-> *editable-work* last-y)))
    (set! (-> *editable-work* last-found) 0)
    (set! (-> *editable-work* last-x) (-> arg0 x))
    (set! (-> *editable-work* last-y) (-> arg0 y))
    )
  4095996000.0
  (let ((s5-0 (the-as editable #f)))
    (set! (-> *editable-work* num-found) 0)
    (let* ((s2-0 (-> obj length))
           (s1-0 0)
           (s0-0 (-> obj data s1-0))
           )
      (while (< s1-0 s2-0)
        (when (and s0-0 (or (and (logtest? (-> s0-0 region filter) (-> obj filter 0))
                                 (logtest? (-> s0-0 region filter) (-> obj filter 1))
                                 )
                            (logtest? (-> s0-0 flags) (editable-flag selected))
                            )
                   )
          (let ((f0-5 (edit-get-distance s0-0 arg0)))
            (when (>= f0-5 0.0)
              (set! (-> *editable-work* found (-> *editable-work* num-found)) s0-0)
              (set! (-> *editable-work* dists (-> *editable-work* num-found)) (the-as uint f0-5))
              (if (< (-> *editable-work* num-found) 255)
                  (+! (-> *editable-work* num-found) 1)
                  )
              )
            )
          )
        (+! s1-0 1)
        (set! s0-0 (-> obj data s1-0))
        )
      )
    (countdown (v1-43 (-> *editable-work* num-found))
      (when (> v1-43 0)
        (countdown (a0-12 v1-43)
          (when (< (the-as float (-> *editable-work* dists v1-43)) (the-as float (-> *editable-work* dists a0-12)))
            (let ((a1-10 (-> *editable-work* found v1-43))
                  (f0-7 (-> *editable-work* dists v1-43))
                  )
              (set! (-> *editable-work* found v1-43) (-> *editable-work* found a0-12))
              (set! (-> *editable-work* dists v1-43) (-> *editable-work* dists a0-12))
              (set! (-> *editable-work* found a0-12) a1-10)
              (set! (-> *editable-work* dists a0-12) f0-7)
              )
            )
          )
        )
      )
    (when (nonzero? (-> *editable-work* num-found))
      (when (>= (-> *editable-work* last-found) (-> *editable-work* num-found))
        (set! (-> *editable-work* last-found) 0)
        0
        )
      (set! s5-0 (cond
                   ((zero? arg1)
                    (set! s5-0 (-> *editable-work* found (-> *editable-work* last-found)))
                    (+! (-> *editable-work* last-found) 1)
                    s5-0
                    )
                   (else
                     (-> *editable-work* found 0)
                     )
                   )
            )
      )
    s5-0
    )
  )

;; definition for method 14 of type editable-array
;; WARN: Return type mismatch (array editable) vs none.
(defmethod editable-array-method-14 editable-array ((obj editable-array) (arg0 (function symbol)) (arg1 symbol))
  (let ((gp-0 (-> obj selection)))
    (set! (-> gp-0 length) 0)
    (let* ((s2-0 (-> obj length))
           (s1-0 0)
           (s0-0 (-> obj data s1-0))
           )
      (while (< s1-0 s2-0)
        (when (and s0-0 (logtest? (-> s0-0 flags) (editable-flag selected)))
          (when (arg0)
            (set! (-> gp-0 (-> gp-0 length)) s0-0)
            (+! (-> gp-0 length) 1)
            )
          )
        (+! s1-0 1)
        (set! s0-0 (-> obj data s1-0))
        )
      )
    )
  (none)
  )

;; definition for method 15 of type editable-array
;; WARN: Return type mismatch int vs none.
(defmethod editable-array-method-15 editable-array ((obj editable-array) (arg0 editable))
  (let ((gp-0 (-> arg0 region)))
    (when gp-0
      (editable-method-25 arg0 obj)
      (let* ((v1-3 (-> obj length))
             (a0-2 0)
             (a1-4 (-> obj data a0-2))
             )
        (while (< a0-2 v1-3)
          (if (and a1-4 (= arg0 a1-4))
              (set! (-> obj data a0-2) #f)
              )
          (+! a0-2 1)
          (set! a1-4 (-> obj data a0-2))
          )
        )
      (let* ((v1-6 (-> obj length))
             (a0-3 0)
             (a1-14 (-> obj data a0-3))
             )
        (while (< a0-3 v1-6)
          (if (and a1-14 (= (-> a1-14 region) gp-0) (!= a1-14 arg0))
              (goto cfg-21)
              )
          (+! a0-3 1)
          (set! a1-14 (-> obj data a0-3))
          )
        )
      (editable-region-method-10 gp-0 0)
      )
    )
  (label cfg-21)
  0
  (none)
  )

;; definition for method 12 of type editable-array
;; WARN: Stack slot offset 40 signed mismatch
;; WARN: Stack slot offset 44 signed mismatch
;; WARN: Stack slot offset 40 signed mismatch
;; WARN: Stack slot offset 44 signed mismatch
;; WARN: Stack slot offset 40 signed mismatch
;; WARN: Stack slot offset 44 signed mismatch
;; WARN: Stack slot offset 40 signed mismatch
;; WARN: Stack slot offset 44 signed mismatch
;; WARN: Stack slot offset 40 signed mismatch
;; WARN: Stack slot offset 44 signed mismatch
;; WARN: Stack slot offset 40 signed mismatch
;; WARN: Stack slot offset 44 signed mismatch
;; WARN: Stack slot offset 40 signed mismatch
;; WARN: Stack slot offset 44 signed mismatch
;; WARN: Stack slot offset 40 signed mismatch
;; WARN: Stack slot offset 44 signed mismatch
;; WARN: Stack slot offset 40 signed mismatch
;; WARN: Stack slot offset 44 signed mismatch
;; WARN: Stack slot offset 40 signed mismatch
;; WARN: Stack slot offset 44 signed mismatch
;; WARN: Stack slot offset 40 signed mismatch
;; WARN: Stack slot offset 44 signed mismatch
;; WARN: Stack slot offset 40 signed mismatch
;; WARN: Stack slot offset 44 signed mismatch
;; WARN: Return type mismatch symbol vs none.
;; WARN: Function (method 12 editable-array) has a return type of none, but the expression builder found a return statement.
(defmethod editable-array-method-12 editable-array ((obj editable-array) (arg0 editable-array))
  (local-vars
    (sv-16 sql-result)
    (sv-20 sql-result)
    (sv-24 sql-result)
    (sv-28 sql-result)
    (sv-32 sql-result)
    (sv-36 editable-region)
    (sv-40 number)
    (sv-44 number)
    (sv-64 int)
    (sv-72 int)
    (sv-80 editable-plane)
    (sv-84 symbol)
    (sv-112 vector)
    (sv-120 int)
    (sv-128 editable-point)
    (sv-136 int)
    (sv-144 int)
    (sv-152 editable-face)
    (sv-156 symbol)
    (sv-176 vector)
    (sv-180 editable)
    (sv-184 int)
    (sv-192 int)
    (sv-200 editable-point)
    (sv-208 int)
    (sv-216 sql-result)
    (sv-240 sql-result)
    )
  (format #t "sql: load from level ~A~%" arg0)
  (set! (-> *editable-sample-region* level) (the-as string arg0))
  (set! (-> *editable-light-region* level) (the-as string arg0))
  (set! (-> *editable-entity-region* level) (the-as string arg0))
  (vector-reset! (-> obj level-offset))
  (set! (-> obj level-info-id) (the-as uint -1))
  (set! (-> obj level) (the-as uint arg0))
  (let ((s4-0 sql-query))
    (format
      (clear *temp-string*)
      "select translate_x,translate_y,translate_z,level_info_id from level_info where name='~S'"
      arg0
      )
    (set! sv-16 (s4-0 *temp-string*))
    )
  (when (and (= (-> sv-16 error) 'select) (>= (-> sv-16 len) 3))
    (set-vector!
      (-> obj level-offset)
      (* 4096.0 (string->float (the-as string (-> sv-16 data 0))))
      (* 4096.0 (string->float (the-as string (-> sv-16 data 1))))
      (* 4096.0 (string->float (the-as string (-> sv-16 data 2))))
      1.0
      )
    (set! (-> obj level-info-id) (the-as uint (string->int (the-as string (-> sv-16 data 3)))))
    )
  (let ((s4-2 sql-query))
    (format
      (clear *temp-string*)
      "select region_id,level_name,tree,on_enter,on_exit,on_inside from region where level_name='~S'"
      arg0
      )
    (set! sv-20 (s4-2 *temp-string*))
    )
  (if (!= (-> sv-20 error) 'select)
      (return #f)
      )
  (format #t "sql: read region ~D~%" (/ (-> sv-20 len) 6))
  (let ((s4-3 sql-query))
    (format
      (clear *temp-string*)
      "select region_face.region_id,region_face_id,kind,flags,radius from region,region_face where level_name='~S' and region.region_id=region_face.region_id"
      arg0
      )
    (set! sv-24 (s4-3 *temp-string*))
    )
  (if (!= (-> sv-24 error) 'select)
      (return #f)
      )
  (format #t "sql: read face ~D~%" (/ (-> sv-24 len) 5))
  (let ((s4-4 sql-query))
    (format
      (clear *temp-string*)
      "select region_face.region_face_id,idx,x,y,z from region,region_face,region_point where level_name='~S' and region.region_id=region_face.region_id and region_face.region_face_id=region_point.region_face_id"
      arg0
      )
    (set! sv-28 (s4-4 *temp-string*))
    )
  (if (!= (-> sv-28 error) 'select)
      (return #f)
      )
  (format #t "sql: read point ~D~%" (/ (-> sv-28 len) 5))
  (let ((s4-5 sql-query))
    (format
      (clear *temp-string*)
      "select region_sphere.region_id,x,y,z,r from region,region_sphere where level_name='~S' and region.region_id=region_sphere.region_id"
      arg0
      )
    (set! sv-32 (s4-5 *temp-string*))
    )
  (if (!= (-> sv-32 error) 'select)
      (return #f)
      )
  (format #t "sql: read sphere ~D~%" (/ (-> sv-32 len) 5))
  (let ((s5-1 0))
    (while (< s5-1 (-> sv-20 len))
      (set! sv-36 (new 'debug 'editable-region))
      (set! sv-40 4095996000.0)
      (set! sv-44 -4095996000.0)
      (set! (-> sv-36 id) (the-as uint (string->int (the-as string (-> sv-20 data s5-1)))))
      (set! (-> sv-36 level) (the-as string (string->symbol (the-as string (-> sv-20 data (+ s5-1 1))))))
      (set! (-> sv-36 tree) (the-as string (string->symbol (the-as string (-> sv-20 data (+ s5-1 2))))))
      (set! (-> sv-36 on-enter) (the-as string (if (string= (the-as string (-> sv-20 data (+ s5-1 3))) "")
                                                   #f
                                                   (-> sv-20 data (+ s5-1 3))
                                                   )
                                        )
            )
      (set! (-> sv-36 on-exit) (the-as string (if (string= (the-as string (-> sv-20 data (+ s5-1 4))) "")
                                                  #f
                                                  (-> sv-20 data (+ s5-1 4))
                                                  )
                                       )
            )
      (set! (-> sv-36 on-inside) (the-as string (if (string= (the-as string (-> sv-20 data (+ s5-1 5))) "")
                                                    #f
                                                    (-> sv-20 data (+ s5-1 5))
                                                    )
                                         )
            )
      (let* ((v1-75 (-> obj length))
             (a0-54 0)
             (a1-17 (-> obj data a0-54))
             )
        (while (< a0-54 v1-75)
          (if (and a1-17 (-> a1-17 region) (= (-> a1-17 region id) (-> sv-36 id)))
              (set! (-> obj data a0-54) #f)
              )
          (+! a0-54 1)
          (set! a1-17 (-> obj data a0-54))
          )
        )
      (let ((s4-6 0))
        (while (< s4-6 (-> sv-32 len))
          (when (= (-> sv-36 id) (string->int (the-as string (-> sv-32 data s4-6))))
            (let ((s3-5 (editable-array-method-11 obj)))
              (when (>= s3-5 0)
                (let ((s2-1 (new 'stack-no-clear 'vector)))
                  (set! (-> s2-1 x) (string->float (the-as string (-> sv-32 data (+ s4-6 1)))))
                  (set! (-> s2-1 y) (string->float (the-as string (-> sv-32 data (+ s4-6 2)))))
                  (set! (-> s2-1 z) (string->float (the-as string (-> sv-32 data (+ s4-6 3)))))
                  (set! (-> s2-1 w) 1.0)
                  (vector+! s2-1 s2-1 (-> obj level-offset))
                  (let ((s2-2 (new 'debug 'editable-sphere s2-1 2048.0 sv-36)))
                    (set! (-> s2-2 radius) (string->float (the-as string (-> sv-32 data (+ s4-6 4)))))
                    (set! (-> obj data s3-5) s2-2)
                    )
                  )
                )
              )
            )
          (+! s4-6 5)
          )
        )
      (set! sv-64 0)
      (while (< sv-64 (-> sv-24 len))
        (when (= (-> sv-36 id) (string->int (the-as string (-> sv-24 data sv-64))))
          (cond
            ((string= (the-as string (-> sv-24 data (+ sv-64 2))) "plane")
             (set! sv-72 (editable-array-method-11 obj))
             (set! sv-80 (new 'debug 'editable-plane sv-36))
             (set! sv-84 (-> sv-24 data (+ sv-64 1)))
             (when (>= sv-72 0)
               (set! (-> obj data sv-72) sv-80)
               (set! (-> sv-80 radius) (string->float (the-as string (-> sv-24 data (+ sv-64 4)))))
               (countdown (s4-7 (/ (-> sv-28 len) 5))
                 (when (string= (the-as string (l.wu (+ (* 20 s4-7) (the-as int sv-28) 12))) (the-as string sv-84))
                   (let ((s3-6 (new 'stack-no-clear 'vector)))
                     (set! (-> s3-6 x) (string->float (the-as string (-> sv-28 data (+ (* 5 s4-7) 2)))))
                     (set! (-> s3-6 y) (string->float (the-as string (-> sv-28 data (+ (* 5 s4-7) 3)))))
                     (set! (-> s3-6 z) (string->float (the-as string (-> sv-28 data (+ (* 5 s4-7) 4)))))
                     (set! (-> s3-6 w) 1.0)
                     (set! sv-112 s3-6)
                     )
                   (vector+! sv-112 sv-112 (-> obj level-offset))
                   (set! sv-120 (editable-array-method-11 obj))
                   (when (>= sv-120 0)
                     (set! sv-128 (new 'debug 'editable-point sv-112 sv-36))
                     (set! sv-136 (string->int (the-as string (-> sv-28 data (+ (* 5 s4-7) 1)))))
                     (set! (-> obj data sv-120) sv-128)
                     (set! (-> sv-80 vertex sv-136) sv-128)
                     (set! (-> sv-80 length) (max (-> sv-80 length) (+ sv-136 1)))
                     (set! (-> sv-128 owner) (cons sv-80 (-> sv-128 owner)))
                     )
                   )
                 )
               (editable-method-28 sv-80 (editable-filter load))
               (editable-method-29 sv-80 (editable-filter load))
               )
             )
            ((string= (the-as string (-> sv-24 data (+ sv-64 2))) "face")
             (set! sv-144 (editable-array-method-11 obj))
             (set! sv-152 (new 'debug 'editable-face sv-36))
             (set! sv-156 (-> sv-24 data (+ sv-64 1)))
             (when (>= sv-144 0)
               (set! (-> obj data sv-144) sv-152)
               (if (string= (the-as string (-> sv-24 data (+ sv-64 3))) "orient")
                   (logior! (-> sv-152 flags) (editable-flag orient))
                   )
               (let ((s4-8 (/ (-> sv-28 len) 5)))
                 (while (begin (label cfg-78) (nonzero? s4-8))
                   (+! s4-8 -1)
                   (when (string= (the-as string (l.wu (+ (* 20 s4-8) (the-as int sv-28) 12))) (the-as string sv-156))
                     (let ((s3-7 (new 'stack-no-clear 'vector)))
                       (set! (-> s3-7 x) (string->float (the-as string (-> sv-28 data (+ (* 5 s4-8) 2)))))
                       (set! (-> s3-7 y) (string->float (the-as string (-> sv-28 data (+ (* 5 s4-8) 3)))))
                       (set! (-> s3-7 z) (string->float (the-as string (-> sv-28 data (+ (* 5 s4-8) 4)))))
                       (set! (-> s3-7 w) 1.0)
                       (set! sv-176 s3-7)
                       )
                     (vector+! sv-176 sv-176 (-> obj level-offset))
                     (let* ((s3-8 (-> obj length))
                            (s2-3 0)
                            (s1-0 (-> obj data s2-3))
                            )
                       (while (< s2-3 s3-8)
                         (when (and s1-0 (= (-> s1-0 region) sv-36) (type? s1-0 editable-point))
                           (when (vector= (-> (the-as editable-point s1-0) trans) sv-176)
                             (set! sv-180 s1-0)
                             (set! sv-184 (string->int (the-as string (-> sv-28 data (+ (* 5 s4-8) 1)))))
                             (set! (-> sv-152 vertex sv-184) (the-as editable-point sv-180))
                             (set! (-> sv-152 length) (max (-> sv-152 length) (+ sv-184 1)))
                             (set! (-> sv-180 owner) (cons sv-152 (-> sv-180 owner)))
                             (goto cfg-78)
                             )
                           )
                         (+! s2-3 1)
                         (set! s1-0 (-> obj data s2-3))
                         )
                       )
                     (if (< (-> sv-176 y) (the-as float (gpr->fpr sv-40)))
                         (set! sv-40 (-> sv-176 y))
                         )
                     (if (< (the-as float (gpr->fpr sv-44)) (-> sv-176 y))
                         (set! sv-44 (-> sv-176 y))
                         )
                     (set! sv-192 (editable-array-method-11 obj))
                     (when (>= sv-192 0)
                       (set! sv-200 (new 'debug 'editable-point sv-176 sv-36))
                       (set! sv-208 (string->int (the-as string (-> sv-28 data (+ (* 5 s4-8) 1)))))
                       (set! (-> obj data sv-192) sv-200)
                       (set! (-> sv-152 vertex sv-208) sv-200)
                       (set! (-> sv-152 length) (max (-> sv-152 length) (+ sv-208 1)))
                       (set! (-> sv-200 owner) (cons sv-152 (-> sv-200 owner)))
                       )
                     )
                   )
                 )
               (editable-method-28 sv-152 (editable-filter load))
               (editable-method-29 sv-152 (editable-filter load))
               )
             )
            )
          )
        (set! sv-64 (+ sv-64 5))
        )
      (let* ((v1-293 (-> obj length))
             (a0-158 0)
             (a1-57 (-> obj data a0-158))
             )
        (while (< a0-158 v1-293)
          (when (and a1-57 (= (-> a1-57 region) sv-36) (= (-> a1-57 type) editable-point))
            (let ((a2-29 (-> (the-as editable-point a1-57) trans)))
              (if (= (-> a2-29 y) (the-as float (gpr->fpr sv-40)))
                  (logior! (-> a1-57 flags) (editable-flag bot-set))
                  )
              (if (= (-> a2-29 y) (the-as float (gpr->fpr sv-44)))
                  (logior! (-> a1-57 flags) (editable-flag top-set))
                  )
              )
            )
          (+! a0-158 1)
          (set! a1-57 (-> obj data a0-158))
          )
        )
      (set! (-> sv-36 changed) #f)
      (+! s5-1 6)
      )
    )
  (let ((s5-2 sql-query))
    (format
      (clear *temp-string*)
      "select x,y,z from sample_point where level_info_id='~D' and source='manual'"
      (-> obj level-info-id)
      )
    (set! sv-216 (s5-2 *temp-string*))
    )
  (if (!= (-> sv-216 error) 'select)
      (return #f)
      )
  (let ((s5-3 0))
    (while (< s5-3 (-> sv-216 len))
      (let ((s4-10 (editable-array-method-11 obj)))
        (when (>= s4-10 0)
          (let ((s3-9 (new 'stack-no-clear 'vector)))
            (set! (-> s3-9 x) (* 4096.0 (string->float (the-as string (-> sv-216 data s5-3)))))
            (set! (-> s3-9 y) (* 4096.0 (string->float (the-as string (-> sv-216 data (+ s5-3 1))))))
            (set! (-> s3-9 z) (* 4096.0 (string->float (the-as string (-> sv-216 data (+ s5-3 2))))))
            (set! (-> s3-9 w) 1.0)
            (vector+! s3-9 s3-9 (-> obj level-offset))
            (set! (-> obj data s4-10) (new 'debug 'editable-sample s3-9 *editable-sample-region*))
            )
          )
        )
      (+! s5-3 3)
      )
    )
  (set! (-> *editable-sample-region* changed) #f)
  (let ((s5-4 sql-query))
    (format
      (clear *temp-string*)
      "select light_id,name,pos_x,pos_y,pos_z,r,dir_x,dir_y,dir_z,color0_r,color0_g,color0_b,color0_a,decay_start,ambient_point_ratio,brightness from light where level_name='~S'"
      (-> obj level)
      )
    (set! sv-240 (s5-4 *temp-string*))
    )
  (format #t "sql: read light ~D~%" (/ (-> sv-240 len) 16))
  (if (!= (-> sv-240 error) 'select)
      (return #f)
      )
  (let ((s5-5 0))
    (while (< s5-5 (-> sv-240 len))
      (let ((s3-10 (editable-array-method-11 obj)))
        (when (>= s3-10 0)
          (let ((s4-12 (new 'stack-no-clear 'vector)))
            (set! (-> s4-12 x) (* 4096.0 (string->float (the-as string (-> sv-240 data (+ s5-5 2))))))
            (set! (-> s4-12 y) (* 4096.0 (string->float (the-as string (-> sv-240 data (+ s5-5 3))))))
            (set! (-> s4-12 z) (* 4096.0 (string->float (the-as string (-> sv-240 data (+ s5-5 4))))))
            (set! (-> s4-12 w) 1.0)
            (vector+! s4-12 s4-12 (-> obj level-offset))
            (let ((s4-13 (new 'debug 'editable-light s4-12 2048.0 *editable-light-region*)))
              (set! (-> obj data s3-10) s4-13)
              (set! (-> s4-13 id) (the-as uint (string->int (the-as string (-> sv-240 data s5-5)))))
              (set! (-> s4-13 name) (the-as string (-> sv-240 data (+ s5-5 1))))
              (set! (-> s4-13 radius) (* 4096.0 (string->float (the-as string (-> sv-240 data (+ s5-5 5))))))
              (set-vector!
                (-> s4-13 direction)
                (string->float (the-as string (-> sv-240 data (+ s5-5 6))))
                (string->float (the-as string (-> sv-240 data (+ s5-5 7))))
                (string->float (the-as string (-> sv-240 data (+ s5-5 8))))
                1.0
                )
              (if (and (= (-> s4-13 direction x) 0.0) (= (-> s4-13 direction y) 0.0) (= (-> s4-13 direction z) 0.0))
                  (set! (-> s4-13 direction w) 0.0)
                  )
              (set-vector!
                (-> s4-13 color)
                (string->float (the-as string (-> sv-240 data (+ s5-5 9))))
                (string->float (the-as string (-> sv-240 data (+ s5-5 10))))
                (string->float (the-as string (-> sv-240 data (+ s5-5 11))))
                (string->float (the-as string (-> sv-240 data (+ s5-5 12))))
                )
              (set! (-> s4-13 decay-start) (string->float (the-as string (-> sv-240 data (+ s5-5 13)))))
              (set! (-> s4-13 ambient-point-ratio) (string->float (the-as string (-> sv-240 data (+ s5-5 14)))))
              (set! (-> s4-13 brightness) (string->float (the-as string (-> sv-240 data (+ s5-5 15)))))
              )
            )
          )
        )
      (+! s5-5 16)
      )
    )
  (set! (-> *editable-light-region* changed) #f)
  (editable-array-method-9 obj (editable-command refresh-filter) (the-as editable-array #f))
  #t
  (none)
  )

;; definition for method 13 of type editable-array
;; WARN: Return type mismatch int vs none.
(defmethod editable-array-method-13 editable-array ((obj editable-array) (arg0 uint) (arg1 basic) (arg2 string))
  (set! (-> obj target) #f)
  (set! (-> obj target-mode) arg0)
  (set! (-> obj target-command) arg1)
  (set! (-> obj target-message) arg2)
  0
  (none)
  )

;; definition for method 16 of type editable-array
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod editable-array-method-16 editable-array ((obj editable-array))
  (cond
    ((-> obj edit-plane)
     (editable-plane-method-31 (-> obj edit-plane) (-> obj edit-plane-normal))
     (set! (-> obj edit-plane-center quad) (-> (edit-get-trans (-> obj edit-plane vertex 0)) quad))
     )
    (else
      (vector-negate! (-> obj edit-plane-normal) (-> *math-camera* inv-camera-rot vector 2))
      (let ((v1-9 (vector-float*! (-> obj edit-plane-center) (-> *math-camera* inv-camera-rot vector 2) 24576.0)))
        (vector+! (the-as vector v1-9) (the-as vector v1-9) (-> *math-camera* trans))
        )
      )
    )
  0
  (none)
  )

;; definition for method 17 of type editable-array
;; INFO: Used lq/sq
(defmethod editable-array-method-17 editable-array ((obj editable-array) (arg0 vector) (arg1 vector))
  (cond
    ((and (cpad-hold? 0 up) *target*)
     (set! (-> arg0 quad) (-> (get-trans *target* 0) quad))
     )
    ((and (cpad-hold? 0 down) *camera*)
     (set! (-> arg0 quad) (-> (math-camera-pos) quad))
     )
    (else
      (editable-array-method-16 obj)
      (reverse-transform-point! arg0 (-> obj edit-plane-center) (-> obj edit-plane-normal) arg1)
      )
    )
  arg0
  )

;; failed to figure out what this is:
(when (zero? *editable-sample-region*)
  (let ((v1-4 (new 'debug 'editable-region)))
    (set! (-> v1-4 locked) #t)
    (set! (-> v1-4 changed) #f)
    (set! (-> v1-4 tree) (the-as string 'sample))
    (set! (-> v1-4 filter) (editable-filter sample))
    (set! *editable-sample-region* v1-4)
    )
  (let ((v1-6 (new 'debug 'editable-region)))
    (set! (-> v1-6 locked) #t)
    (set! (-> v1-6 changed) #f)
    (set! (-> v1-6 tree) (the-as string 'light))
    (set! (-> v1-6 filter) (editable-filter light))
    (set! *editable-light-region* v1-6)
    )
  (let ((v0-84 (new 'debug 'editable-region)))
    (set! (-> v0-84 locked) #t)
    (set! (-> v0-84 changed) #f)
    (set! (-> v0-84 tree) (the-as string 'entity))
    (set! (-> v0-84 filter) (editable-filter entity))
    (set! *editable-entity-region* v0-84)
    )
  )

)
