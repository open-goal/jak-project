;;-*-Lisp-*-
(in-package goal)

;; definition for function sphere-cull
;; ERROR: Bad vector register dependency: vf16
;; ERROR: Bad vector register dependency: vf17
;; ERROR: Bad vector register dependency: vf18
;; ERROR: Bad vector register dependency: vf19
(defun sphere-cull ((arg0 vector))
  (local-vars (v1-0 uint128) (v1-1 uint128) (v1-2 uint128))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf10 :class vf)
         (vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf10 (&-> arg0 quad))
    (.mul.x.vf acc vf16 vf10)
    (.add.mul.y.vf acc vf17 vf10 acc)
    (.add.mul.z.vf acc vf18 vf10 acc)
    (.sub.mul.w.vf vf9 vf19 vf0 acc)
    (.add.w.vf vf9 vf9 vf10)
    (.mov v1-0 vf9)
    (.pcgtw v1-1 0 v1-0)
    (.ppach v1-2 (the-as uint128 0) v1-1)
    (zero? (the-as int v1-2))
    )
  )

;; definition for function guard-band-cull
;; ERROR: Bad vector register dependency: vf20
;; ERROR: Bad vector register dependency: vf21
;; ERROR: Bad vector register dependency: vf22
;; ERROR: Bad vector register dependency: vf23
(defun guard-band-cull ((arg0 vector))
  (local-vars (v1-0 uint128) (v1-1 uint128) (v1-2 uint128))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf10 :class vf)
         (vf20 :class vf)
         (vf21 :class vf)
         (vf22 :class vf)
         (vf23 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf10 (&-> arg0 quad))
    (.mul.x.vf acc vf20 vf10)
    (.add.mul.y.vf acc vf21 vf10 acc)
    (.add.mul.z.vf acc vf22 vf10 acc)
    (.sub.mul.w.vf vf9 vf23 vf0 acc)
    (.sub.w.vf vf9 vf9 vf10)
    (.mov v1-0 vf9)
    (.pcgtw v1-1 0 v1-0)
    (.ppach v1-2 (the-as uint128 0) v1-1)
    (nonzero? (the-as int v1-2))
    )
  )

;; definition for function sphere-in-view-frustum?
(defun sphere-in-view-frustum? ((arg0 sphere))
  (local-vars (v1-1 uint128) (v1-2 uint128) (v1-3 uint128))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (let ((v1-0 *math-camera*))
      (.lvf vf6 (&-> arg0 quad))
      (.lvf vf1 (&-> v1-0 plane 0 quad))
      (.lvf vf2 (&-> v1-0 plane 1 quad))
      (.lvf vf3 (&-> v1-0 plane 2 quad))
      (.lvf vf4 (&-> v1-0 plane 3 quad))
      )
    (.mul.x.vf acc vf1 vf6)
    (.add.mul.y.vf acc vf2 vf6 acc)
    (.add.mul.z.vf acc vf3 vf6 acc)
    (.sub.mul.w.vf vf5 vf4 vf0 acc)
    (.add.w.vf vf5 vf5 vf6)
    (.mov v1-1 vf5)
    (.pcgtw v1-2 0 v1-1)
    (.ppach v1-3 (the-as uint128 0) v1-2)
    (zero? (the-as int v1-3))
    )
  )

;; definition for function line-in-view-frustum?
(defun line-in-view-frustum? ((arg0 vector) (arg1 vector))
  (local-vars (v1-1 uint128) (v1-2 uint128) (v1-3 uint128) (a0-1 uint128) (a0-2 uint128) (a0-3 uint128))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf10 :class vf)
         (vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (let ((v1-0 *math-camera*))
      (.lvf vf9 (&-> arg0 quad))
      (.lvf vf10 (&-> arg1 quad))
      (.lvf vf16 (&-> v1-0 plane 0 quad))
      (.lvf vf17 (&-> v1-0 plane 1 quad))
      (.lvf vf18 (&-> v1-0 plane 2 quad))
      (.lvf vf19 (&-> v1-0 plane 3 quad))
      )
    (.mul.x.vf acc vf16 vf9)
    (.add.mul.y.vf acc vf17 vf9 acc)
    (.add.mul.z.vf acc vf18 vf9 acc)
    (.sub.mul.w.vf vf9 vf19 vf0 acc)
    (.mul.x.vf acc vf16 vf10)
    (.add.mul.y.vf acc vf17 vf10 acc)
    (.add.mul.z.vf acc vf18 vf10 acc)
    (.sub.mul.w.vf vf10 vf19 vf0 acc)
    (.mov v1-1 vf9)
    (.pcgtw v1-2 0 v1-1)
    (.ppach v1-3 (the-as uint128 0) v1-2)
    (.mov a0-1 vf10)
    (.pcgtw a0-2 0 a0-1)
    (.ppach a0-3 (the-as uint128 0) a0-2)
    (not (logtest? (the-as int v1-3) (the-as int a0-3)))
    )
  )

;; definition for function vis-cull
;; ERROR: failed type prop at 3: Could not figure out load: (set! v1 (l.b (+ v1 #x38a0)))
;; WARN: Return type mismatch none vs symbol.
;; ERROR: Unsupported inline assembly instruction kind - [addiu a0, a0, 56]
(defun vis-cull ((a0-0 int))
  (local-vars (v0-0 none) (v1-0 int) (v1-1 int) (v1-2 none) (v1-3 none) (a0-1 none) (a0-2 none) (a1-0 int))
  (set! v1-0 #x70000000)
  (shift-arith-right-32 a1-0 a0-0 3)
  (set! v1-1 (+ a1-0 v1-0))
  (set! v1-2 (the-as none (l.b (+ v1-1 #x38a0))))
  (set! a0-1 (the-as none (logand a0-0 7)))
  (.addiu a0-2 a0-1 56)
  (set! v1-3 (the-as none (sll v1-2 a0-2)))
  (set! v0-0 (the-as none (<0.si v1-3)))
  (ret-value v0-0)
  )

;; definition (debug) for function vis-cull-debug
;; ERROR: Failed load: (set! v1-2 (l.b (+ v1-1 #x38a0))) at op 2
;; ERROR: Unsupported inline assembly instruction kind - [addiu a0, a0, 56]
(defun-debug vis-cull-debug ((arg0 work-area) (arg1 int))
  (local-vars (v1-0 int) (a0-2 int))
  (shift-arith-right-32 v1-0 arg1 3)
  (let ((v1-2 (l.b (+ v1-0 (the-as int arg0) #x38a0))))
    (let ((a0-1 (logand arg1 7)))
      (.addiu a0-2 a0-1 56)
      )
    (< (shl v1-2 a0-2) 0)
    )
  )

;; definition for function error-sphere
;; WARN: Return type mismatch int vs none.
(defun error-sphere ((arg0 drawable-error) (arg1 string))
  (when *artist-error-spheres*
    (when (vis-cull (-> arg0 id))
      (when (sphere-cull (-> arg0 bsphere))
        (add-debug-sphere
          #t
          (bucket-id debug2)
          (-> arg0 bsphere)
          (-> arg0 bsphere w)
          (new 'static 'rgba :r #x80 :a #x80)
          )
        (add-debug-text-3d
          #t
          (bucket-id debug-no-zbuf1)
          arg1
          (-> arg0 bsphere)
          (font-color white)
          (the-as vector2h #f)
          )
        )
      )
    )
  0
  (none)
  )

;; definition for method 9 of type drawable
(defmethod login ((this drawable))
  this
  )

;; definition for method 10 of type drawable
;; WARN: Return type mismatch int vs none.
(defmethod draw ((this drawable) (arg0 drawable) (arg1 display-frame))
  0
  (none)
  )

;; definition for method 11 of type drawable
(defmethod fill-collide-list-from-box ((this drawable) (arg0 int) (arg1 collide-list) (arg2 collide-query))
  0
  )

;; definition for method 12 of type drawable
(defmethod fill-collide-list-from-line-sphere ((this drawable) (arg0 int) (arg1 collide-list) (arg2 collide-query))
  0
  )

;; definition for method 16 of type drawable
;; WARN: Return type mismatch int vs none.
(defmethod collect-regions ((this drawable) (arg0 sphere) (arg1 int) (arg2 region-prim-list))
  "Determines the number of [[drawable]]s in the `obj` that overlap the given `area-of-interest` this number is stored in the `region-list`'s item count
@param area-of-interest The area defined by a sphere that we care about overlaps
@param _count The amount of [[drawable]]s in the object to enumerate through
@param! region-list Stores the overlapping regions and a count for how many were found
@returns none"
  0
  (none)
  )

;; definition for method 13 of type drawable
;; WARN: Return type mismatch int vs none.
(defmethod collect-stats ((this drawable))
  0
  (none)
  )

;; definition for method 14 of type drawable
;; WARN: Return type mismatch int vs none.
(defmethod debug-draw ((this drawable) (arg0 drawable) (arg1 display-frame))
  0
  (none)
  )

;; definition for method 10 of type drawable-error
;; WARN: Return type mismatch int vs none.
(defmethod draw ((this drawable-error) (arg0 drawable-error) (arg1 display-frame))
  (error-sphere arg0 (-> arg0 name))
  0
  (none)
  )

;; definition for method 15 of type drawable
(defmethod unpack-vis ((this drawable) (arg0 (pointer int8)) (arg1 (pointer int8)))
  arg1
  )

;; definition for symbol *edit-instance*, type string
(define *edit-instance* (the-as string #f))

;; this part is debug only
(when *debug-segment*
;; definition for symbol *instance-mem-usage*, type memory-usage-block
(define *instance-mem-usage* (new 'debug 'memory-usage-block))

)
;; definition for function find-instance-by-name-level
(defun find-instance-by-name-level ((arg0 string) (arg1 level))
  (let ((s5-0 (-> arg1 bsp drawable-trees)))
    (dotimes (s4-0 (-> s5-0 length))
      (let ((v1-3 (-> s5-0 trees s4-0)))
        (case (-> v1-3 type)
          ((drawable-tree-instance-shrub)
           (let ((s3-0 (-> (the-as drawable-tree-instance-shrub v1-3) info prototype-inline-array-shrub)))
             (dotimes (s2-0 (-> s3-0 length))
               (if (string= arg0 (-> s3-0 data s2-0 name))
                   (return (-> s3-0 data s2-0))
                   )
               )
             )
           )
          ((drawable-tree-instance-tie)
           (let ((s3-1 (-> (the-as drawable-tree-instance-tie v1-3) prototypes prototype-array-tie)))
             (dotimes (s2-1 (-> s3-1 length))
               (if (string= arg0 (-> s3-1 array-data s2-1 name))
                   (return (-> s3-1 array-data s2-1))
                   )
               )
             )
           )
          )
        )
      )
    )
  (the-as prototype-bucket #f)
  )

;; definition for function find-instance-by-name
(defun find-instance-by-name ((arg0 string))
  (dotimes (s5-0 (-> *level* length))
    (let ((a1-0 (-> *level* level s5-0)))
      (when (= (-> a1-0 status) 'active)
        (let ((a0-4 (find-instance-by-name-level arg0 a1-0)))
          (if a0-4
              (return a0-4)
              )
          )
        )
      )
    )
  (the-as prototype-bucket #f)
  )

;; definition for function prototypes-game-visible-set!
(defun prototypes-game-visible-set! ((arg0 pair) (arg1 symbol))
  (let ((a0-1 (car arg0)))
    (while (not (null? arg0))
      (let ((v1-0 (find-instance-by-name (the-as string a0-1))))
        (when v1-0
          (if arg1
              (logclear! (-> v1-0 flags) (prototype-flags visible no-collide))
              (logior! (-> v1-0 flags) (prototype-flags visible no-collide))
              )
          )
        )
      (set! arg0 (cdr arg0))
      (set! a0-1 (car arg0))
      )
    )
  0
  )

;; definition (debug) for function find-instance-by-index
(defun-debug find-instance-by-index ((arg0 type) (arg1 int) (arg2 bsp-header))
  (dotimes (v1-0 (-> *level* length))
    (let ((a3-3 (-> *level* level v1-0)))
      (when (= (-> a3-3 status) 'active)
        (let ((a3-4 (-> a3-3 bsp)))
          (when (or (not arg2) (= a3-4 arg2))
            (let ((a3-5 (-> a3-4 drawable-trees)))
              (dotimes (t0-5 (-> a3-5 length))
                (let ((t1-3 (-> a3-5 trees t0-5)))
                  (case (-> t1-3 type)
                    ((drawable-tree-instance-shrub)
                     (when (= arg0 (-> t1-3 type))
                       (let ((v1-2 (-> (the-as drawable-tree-instance-shrub t1-3) info prototype-inline-array-shrub)))
                         (return (-> v1-2 data arg1))
                         )
                       )
                     )
                    ((drawable-tree-instance-tie)
                     (when (= arg0 (-> t1-3 type))
                       (let ((v1-5 (-> (the-as drawable-tree-instance-tie t1-3) prototypes prototype-array-tie)))
                         (return (-> v1-5 array-data arg1))
                         )
                       )
                     )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  (the-as prototype-bucket #f)
  )

;; definition (debug) for function prototype-bucket-type
(defun-debug prototype-bucket-type ((arg0 prototype-bucket))
  (case (-> arg0 geometry 1 type)
    ((prototype-shrubbery shrubbery)
     instance-shrubbery
     )
    ((prototype-tie prototype-tie tie-fragment)
     instance-tie
     )
    )
  )

;; definition (debug) for function prototype-bucket-recalc-fields
(defun-debug prototype-bucket-recalc-fields ((arg0 prototype-bucket))
  (case (prototype-bucket-type arg0)
    ((instance-shrubbery)
     (set! (-> arg0 rdists x) (/ 1.0 (- (-> arg0 dists w) (-> arg0 dists x))))
     )
    (else
      (set! (-> arg0 dists z) (+ (-> arg0 dists x) (* 0.33333334 (- (-> arg0 dists w) (-> arg0 dists x)))))
      (set! (-> arg0 rdists x) (/ 1.0 (- (-> arg0 dists z) (-> arg0 dists x))))
      )
    )
  (set! (-> arg0 rdists z) (/ 1.0 (- (-> arg0 dists w) (-> arg0 dists z))))
  (set! (-> arg0 dists y) (* 0.5 (-> arg0 dists x)))
  (set! (-> arg0 rdists y) (/ 1.0 (-> arg0 dists y)))
  arg0
  )

;; definition (debug) for function print-prototype-list
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defun-debug print-prototype-list ()
  (local-vars (sv-16 (function prototype-bucket-shrub memory-usage-block int prototype-bucket-shrub)))
  (dotimes (gp-0 (-> *level* length))
    (let ((s5-0 (-> *level* level gp-0)))
      (when (= (-> s5-0 status) 'active)
        (format #t "-------- level ~S~%" (-> s5-0 name))
        (let ((s5-1 (-> s5-0 bsp drawable-trees)))
          (dotimes (s4-0 (-> s5-1 length))
            (let ((v1-8 (-> s5-1 trees s4-0)))
              (case (-> v1-8 type)
                ((drawable-tree-instance-shrub)
                 (let ((s3-0 (-> (the-as drawable-tree-instance-shrub v1-8) info prototype-inline-array-shrub)))
                   (dotimes (s2-0 (-> s3-0 length))
                     0
                     (let ((s1-0 (-> s3-0 data s2-0)))
                       (dotimes (s0-0 4)
                         (reset! *instance-mem-usage*)
                         (if (nonzero? (-> s1-0 geometry s0-0))
                             (mem-usage (-> s1-0 geometry s0-0) *instance-mem-usage* 0)
                             )
                         )
                       (let ((s0-1 s1-0))
                         (set! sv-16 (method-of-object s0-1 mem-usage))
                         (let ((a1-4 (reset! *instance-mem-usage*))
                               (a2-2 0)
                               )
                           (sv-16 s0-1 a1-4 a2-2)
                           )
                         )
                       (let ((v1-29 (calculate-total *instance-mem-usage*)))
                         (format
                           #t
                           " ~-48S~4D   shrub ~5,,2fK   ~4,,2fK~%"
                           (-> s1-0 name)
                           (-> s1-0 in-level)
                           (* 0.0009765625 (the float v1-29))
                           (* 0.0009765625 (the float (* (the-as uint 80) (-> s1-0 in-level))))
                           )
                         )
                       )
                     )
                   )
                 )
                ((drawable-tree-instance-tie)
                 (let ((s3-1 (-> (the-as drawable-tree-instance-tie v1-8) prototypes prototype-array-tie)))
                   (dotimes (s2-1 (-> s3-1 length))
                     0
                     (let ((s1-1 (-> s3-1 array-data s2-1)))
                       (reset! *instance-mem-usage*)
                       (dotimes (s0-2 4)
                         (when (nonzero? (-> s1-1 tie-geom s0-2))
                           (let* ((a0-13 (-> s1-1 tie-geom s0-2))
                                  (t9-8 (method-of-object a0-13 mem-usage))
                                  (a1-7 *instance-mem-usage*)
                                  (v1-47 s0-2)
                                  )
                             (t9-8 a0-13 a1-7 (logior (cond
                                                        ((= v1-47 1)
                                                         4
                                                         )
                                                        ((= v1-47 2)
                                                         8
                                                         )
                                                        ((= v1-47 3)
                                                         16
                                                         )
                                                        (else
                                                          0
                                                          )
                                                        )
                                                      2
                                                      )
                                   )
                             )
                           )
                         )
                       (mem-usage s1-1 *instance-mem-usage* 0)
                       (let ((v1-54 (calculate-total *instance-mem-usage*)))
                         (format
                           #t
                           " ~-48S~4D   tie   ~5,,2fK   ~4,,2fK~%"
                           (-> s1-1 name)
                           (-> s1-1 in-level)
                           (* 0.0009765625 (the float v1-54))
                           (* 0.0009765625 (the float (* (-> s1-1 in-level) 64)))
                           )
                         )
                       )
                     )
                   )
                 )
                )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

;; definition (debug) for function draw-instance-info
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defun-debug draw-instance-info ((arg0 string))
  (local-vars
    (sv-16 uint)
    (sv-32 uint)
    (sv-48 uint)
    (sv-64 int)
    (sv-80 int)
    (sv-96 int)
    (sv-112 int)
    (sv-128 int)
    (sv-144 int)
    )
  (when (and *display-instance-info* *edit-instance*)
    (let ((s5-0 (find-instance-by-name *edit-instance*)))
      (when s5-0
        (dotimes (s4-0 (-> *level* length))
          (let ((v1-5 (-> *level* level s4-0)))
            (when (= (-> v1-5 status) 'active)
              (let ((s3-0 (-> v1-5 bsp drawable-trees)))
                (dotimes (s2-0 (-> s3-0 length))
                  (let ((v1-9 (-> s3-0 trees s2-0)))
                    (case (-> v1-9 type)
                      ((drawable-tree-instance-shrub)
                       )
                      ((drawable-tree-instance-tie)
                       (let ((s1-0 (-> v1-9 data (+ (-> v1-9 length) -1))))
                         (dotimes (s0-0 (-> (the-as drawable-inline-array-instance-tie s1-0) length))
                           (if (string= (-> (the-as drawable-inline-array-instance-tie s1-0) data s0-0 bucket-ptr name) *edit-instance*)
                               (add-debug-sphere
                                 #t
                                 (bucket-id debug-no-zbuf1)
                                 (the-as
                                   vector
                                   (+ (the-as uint (-> (the-as drawable-inline-array-instance-tie s1-0) data 0 bsphere)) (* s0-0 64))
                                   )
                                 (-> (the-as drawable-inline-array-instance-tie s1-0) data s0-0 bsphere w)
                                 (new 'static 'rgba :g #xff :a #x80)
                                 )
                               )
                           )
                         )
                       )
                      )
                    )
                  )
                )
              )
            )
          )
        (let ((s2-1 (prototype-bucket-type s5-0)))
          (let ((s4-1 0))
            0
            (cond
              ((= s2-1 instance-shrubbery)
               (set! s4-1 80)
               )
              ((= s2-1 instance-tie)
               (reset! *instance-mem-usage*)
               (dotimes (s4-2 4)
                 (when (nonzero? (-> s5-0 geometry s4-2))
                   (let* ((a0-17 (-> s5-0 geometry s4-2))
                          (t9-5 (method-of-object a0-17 mem-usage))
                          (a1-6 *instance-mem-usage*)
                          (v1-40 s4-2)
                          )
                     (t9-5 a0-17 a1-6 (logior (cond
                                                ((= v1-40 1)
                                                 4
                                                 )
                                                ((= v1-40 2)
                                                 8
                                                 )
                                                ((= v1-40 3)
                                                 16
                                                 )
                                                (else
                                                  0
                                                  )
                                                )
                                              2
                                              )
                           )
                     )
                   )
                 )
               (set! s4-1 (+ (calculate-total *instance-mem-usage*) 64))
               )
              )
            (mem-usage s5-0 (reset! *instance-mem-usage*) 0)
            (let ((v1-50 (calculate-total *instance-mem-usage*)))
              (format
                arg0
                "~%~A ~A b @ #x~X ~,,2fK/~,,2fK~%"
                s2-1
                (-> s5-0 name)
                s5-0
                (* 0.0009765625 (the float v1-50))
                (* 0.0009765625 (the float s4-1))
                )
              )
            )
          (format arg0 "near: ~m  mid: ~m  far: ~m~%" (-> s5-0 dists x) (-> s5-0 dists z) (-> s5-0 dists w))
          (let ((s3-2 0)
                (s4-3 0)
                )
            (cond
              ((= s2-1 instance-shrubbery)
               (let ((f30-0 0.0))
                 (format
                   arg0
                   "usage: vis: ~D  shrub: ~D  trans-shrub ~D  bill: ~D   in level: ~D~%"
                   (-> (the-as prototype-bucket-shrub s5-0) count 0)
                   (-> (the-as prototype-bucket-shrub s5-0) count 1)
                   (-> (the-as prototype-bucket-shrub s5-0) count 2)
                   (-> (the-as prototype-bucket-shrub s5-0) count 3)
                   (-> (the-as prototype-bucket-shrub s5-0) in-level)
                   )
                 (format arg0 "~%frag#     tris   dverts   strlen  tex~%")
                 (let ((s1-2 (the-as prototype-shrubbery (-> (the-as prototype-bucket-shrub s5-0) geometry 1)))
                       (s2-2 (+ (-> (the-as prototype-bucket-shrub s5-0) count 1) (-> (the-as prototype-bucket-shrub s5-0) count 2)))
                       )
                   (dotimes (s0-1 (-> s1-2 length))
                     (set! sv-16 (shrub-num-tris (-> s1-2 data s0-1)))
                     (set! sv-32 (-> s1-2 data s0-1 header data 2))
                     (set! sv-48 (-> s1-2 data s0-1 header data 0))
                     (format
                       arg0
                       "~5D     ~4D    ~5D   ~6f    ~D~%"
                       s0-1
                       sv-16
                       sv-32
                       (/ (* 2.0 (the float sv-16)) (the float (- sv-32 sv-16)))
                       sv-48
                       )
                     (+! s3-2 sv-16)
                     (+! s4-3 sv-32)
                     (set! f30-0
                           (+ 29.0
                              (* 5.5 (the float (- sv-32 sv-16)))
                              (* 22.0 (the float sv-48))
                              (* 8.0 (the float sv-32))
                              (* 53.0 (the float (/ (+ s2-2 9) (the-as uint 10))))
                              (* (the float s2-2) (+ 15.0 (* 5.0 (the float sv-48)) (* 13.5 (the float sv-32))))
                              f30-0
                              )
                           )
                     )
                   (format
                     arg0
                     "total     ~4D    ~5D   ~6f    ~D  speed: ~f~%"
                     s3-2
                     s4-3
                     (/ (* 2.0 (the float s3-2)) (the float (- s4-3 s3-2)))
                     (-> s5-0 utextures)
                     (/ f30-0 (* (the float s2-2) (the float s3-2)))
                     )
                   )
                 )
               )
              ((= s2-1 instance-tie)
               (set! sv-144 0)
               (let ((s1-3 0)
                     (s0-2 0)
                     (s2-3 0)
                     )
                 (format arg0 "~%level   visible  frags   tris   dverts   strlen  tex  ttris~%")
                 (set! sv-64 1)
                 (set! sv-80 3)
                 (while (>= sv-80 sv-64)
                   (let ((v1-100 (-> (the-as prototype-bucket-tie s5-0) tie-geom sv-64)))
                     (set! sv-96 0)
                     (set! sv-112 0)
                     (set! sv-128 0)
                     (dotimes (a0-36 (-> v1-100 length))
                       (set! sv-96 (+ sv-96 (-> v1-100 data a0-36 debug num-tris)))
                       (set! sv-112 (+ sv-112 (-> v1-100 data a0-36 debug num-dverts)))
                       (set! sv-128 (+ sv-128 (-> v1-100 data a0-36 tex-count)))
                       )
                     (set! sv-144 (+ sv-144 (-> (the-as prototype-bucket-tie s5-0) count sv-64)))
                     (format
                       arg0
                       "~5D  ~7D  ~5D   ~5D"
                       sv-64
                       (-> (the-as prototype-bucket-tie s5-0) count sv-64)
                       (-> v1-100 length)
                       sv-96
                       )
                     )
                   (format
                     arg0
                     "    ~5D   ~6f  ~3D  ~5D~%"
                     sv-112
                     (/ (* 2.0 (the float sv-96)) (the float (- sv-112 sv-96)))
                     sv-128
                     (* (the-as uint sv-96) (-> (the-as prototype-bucket-tie s5-0) count sv-64))
                     )
                   (+! s1-3 (* (the-as uint sv-96) (-> (the-as prototype-bucket-tie s5-0) count sv-64)))
                   (+! s0-2 (* (the-as uint sv-112) (-> (the-as prototype-bucket-tie s5-0) count sv-64)))
                   (+! s3-2 sv-96)
                   (+! s4-3 sv-112)
                   (+! s2-3 sv-128)
                   (set! sv-64 (+ sv-64 1))
                   )
                 (let ((t9-20 format)
                       (a0-52 arg0)
                       (a1-28 "total  ~7D/~3D      ~5D")
                       (a3-12 (-> s5-0 in-level))
                       )
                   (t9-20 a0-52 a1-28 sv-144 a3-12 s3-2)
                   )
                 (format
                   arg0
                   "    ~5D   ~6f  ~3D  ~5D~%"
                   s4-3
                   (/ (* 2.0 (the float s1-3)) (the float (- s0-2 s1-3)))
                   s2-3
                   s1-3
                   )
                 )
               )
              )
            )
          )
        )
      )
    )
  (none)
  )

;; definition (debug) for function set-shadow-by-name
;; WARN: Return type mismatch uint vs none.
(defun-debug set-shadow-by-name ((arg0 string) (arg1 int) (arg2 int))
  (let ((v1-0 (process-by-name arg0 *active-pool*)))
    (when v1-0
      (let ((v1-1 (-> (the-as process-drawable v1-0) draw)))
        (cond
          ((< arg2 16)
           (logior! (-> v1-1 shadow-mask) (ash 1 arg1))
           (logclear! (-> v1-1 shadow-values) (ash 15 (* arg1 4)))
           (logior! (-> v1-1 shadow-values) (ash arg2 (* arg1 4)))
           )
          (else
            (logclear! (-> v1-1 shadow-mask) (ash 1 arg1))
            (logclear! (-> v1-1 shadow-values) (ash 15 (* arg1 4)))
            )
          )
        )
      )
    )
  (none)
  )

;; definition (debug) for function get-shadow-by-name
;; WARN: Return type mismatch object vs none.
(defun-debug get-shadow-by-name ((arg0 string))
  (let ((v1-0 (process-by-name arg0 *active-pool*)))
    (when v1-0
      (let ((s5-0 (-> (the-as process-drawable v1-0) draw)))
        (format 0 "actor ~s {~%" arg0)
        (format 0 "	SHADOW_MASK(0x~02x)~%" (-> s5-0 shadow-mask))
        (format 0 "	SHADOW_VALUES(0x~08x)~%" (-> s5-0 shadow-values))
        )
      (format 0 "}~%")
      )
    )
  (none)
  )

;; definition (debug) for function teleport-camera-by-name
;; WARN: Return type mismatch object vs none.
(defun-debug teleport-camera-by-name ((arg0 string))
  (let* ((gp-0 (entity-by-name arg0))
         (v1-0 (if (type? gp-0 entity-actor)
                   gp-0
                   )
               )
         )
    (if (and v1-0 *camera*)
        (send-event *camera* 'teleport-to-vector-start-string (-> v1-0 trans))
        )
    )
  (none)
  )

;; definition for function dma-add-process-drawable
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
;; WARN: Function dma-add-process-drawable has a return type of none, but the expression builder found a return statement.
(defun dma-add-process-drawable ((pd process-drawable) (dc draw-control) (flag symbol) (dma-buf dma-buffer))
  (local-vars
    (a0-82 int)
    (a0-84 int)
    (a3-11 uint128)
    (sv-16 process-drawable)
    (tod time-of-day-context)
    (shadow-mask uint)
    (lev-idx-for-mood uint)
    (my-origin vector)
    (lev-mood mood-context)
    (light-result-bucket light-hash-bucket)
    (index-ptr pointer)
    (index-index int)
    )
  (with-pp
    (rlet ((acc :class vf)
           (Q :class vf)
           (vf0 :class vf)
           (vf1 :class vf)
           (vf15 :class vf)
           (vf16 :class vf)
           (vf17 :class vf)
           (vf18 :class vf)
           (vf19 :class vf)
           (vf2 :class vf)
           (vf20 :class vf)
           (vf21 :class vf)
           (vf22 :class vf)
           (vf23 :class vf)
           (vf24 :class vf)
           (vf25 :class vf)
           (vf26 :class vf)
           (vf27 :class vf)
           (vf28 :class vf)
           (vf29 :class vf)
           (vf3 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           )
      (init-vf0-vector)
      (set! sv-16 pd)
      (let* ((v1-1 (-> *perf-stats* data 50))
             (a0-1 (-> v1-1 ctrl))
             )
        (+! (-> v1-1 count) 1)
        (b! (zero? a0-1) cfg-2 :delay (nop!))
        (.mtc0 Perf 0)
        (.sync.l)
        (.sync.p)
        (.mtpc pcr0 0)
        (.mtpc pcr1 0)
        (.sync.l)
        (.sync.p)
        (.mtc0 Perf a0-1)
        )
      (.sync.l)
      (.sync.p)
      (label cfg-2)
      0
      (when (-> *blit-displays-work* menu-mode)
        (if (not (logtest? (-> dc status) (draw-control-status hud)))
            (return #f)
            )
        )
      (logclear! (-> dc status) (draw-control-status on-screen))
      (when (not (logtest? (-> dc status) (draw-control-status no-draw no-draw-temp uninited)))
        (let ((fg-bounds (-> (the-as foreground-work #x70000000) bounds))
              (fg-lights (-> (the-as foreground-work #x70000000) lights))
              )
          (set! tod *time-of-day-context*)
          (.lvf vf16 (&-> dc origin quad))
          (.svf (&-> fg-bounds quad) vf16)
          (when (sphere-in-view-frustum? fg-bounds)
            (cond
              ((logtest? (-> dc global-effect) (draw-control-global-effect title-light))
               (when (not (-> tod title-updated))
                 (set! (-> tod title-updated) #t)
                 (let ((s1-0 (-> *math-camera* inv-camera-rot))
                       (a1-3 (new 'stack-no-clear 'vector))
                       (s2-0 (new 'stack-no-clear 'vector))
                       )
                   (set-vector! a1-3 0.612 0.5 -0.612 0.0)
                   (set-vector! s2-0 -0.696 0.174 0.696 0.0)
                   (vector-matrix*! (the-as vector (-> tod title-light-group)) a1-3 s1-0)
                   (vector-matrix*! (the-as vector (-> tod title-light-group dir1)) s2-0 s1-0)
                   )
                 )
               (vu-lights<-light-group! fg-lights (-> tod title-light-group))
               )
              (else
                (set! shadow-mask (-> dc shadow-mask))
                (let ((shadow-mask-not (lognot shadow-mask)))
                  (set! lev-idx-for-mood (-> dc level-index))
                  (let ((light-idx (-> dc light-index))
                        (lg (new 'stack-no-clear 'light-group))
                        )
                    (if (and (>= lev-idx-for-mood (the-as uint 6)) (< light-idx (the-as uint 20)))
                        (+! light-idx 20)
                        )
                    (let ((v1-40 (the-as
                                   mood-context
                                   (+ (the-as uint (-> *level* level0 mood-context)) (* (the-as uint 5232) lev-idx-for-mood))
                                   )
                                 )
                          )
                      (cond
                        ((< light-idx (the-as uint 8))
                         (quad-copy! (the-as pointer lg) (the-as pointer (-> v1-40 light-group light-idx)) 12)
                         )
                        ((< light-idx (the-as uint 18))
                         (quad-copy! (the-as pointer lg) (the-as pointer (-> v1-40 light-group (+ light-idx -10))) 12)
                         )
                        ((< light-idx (the-as uint 28))
                         (quad-copy! (the-as pointer lg) (the-as pointer (-> tod light-group (+ light-idx -20))) 12)
                         )
                        ((< light-idx (the-as uint 38))
                         (quad-copy! (the-as pointer lg) (the-as pointer (-> tod light-group (+ light-idx -30))) 12)
                         )
                        )
                      )
                    (when (not (or (>= lev-idx-for-mood (the-as uint 6)) (zero? shadow-mask)))
                      (let ((packed-shadow-vals (-> dc shadow-values)))
                        (dotimes (light-idx2 4)
                          (when (nonzero? (-> lg lights light-idx2 mask))
                            (when (not (logtest? (-> lg lights light-idx2 mask) shadow-mask-not))
                              (let ((light-pal-idx (-> lg lights light-idx2 palette-index)))
                                (set! (-> lg lights light-idx2 extra x)
                                      (* 0.0625
                                         (the float (logand (ash packed-shadow-vals (* -4 light-pal-idx)) 15))
                                         (-> lg lights light-idx2 extra x)
                                         )
                                      )
                                )
                              )
                            )
                          )
                        )
                      )
                    (when (or (and (>= light-idx (the-as uint 10)) (< light-idx (the-as uint 18)))
                              (and (>= light-idx (the-as uint 30)) (< light-idx (the-as uint 38)))
                              )
                      (dotimes (fg-light-lev-idx (-> *level* length))
                        (let ((lev (-> *level* level fg-light-lev-idx)))
                          (when (= (-> lev status) 'active)
                            (let ((light-hash (-> lev light-hash)))
                              (set! my-origin (-> dc origin))
                              (set! lev-mood (-> lev mood-context))
                              (when (nonzero? light-hash)
                                (let ((light-lookup-result (light-hash-get-bucket-index light-hash (-> dc origin))))
                                  (when (!= light-lookup-result -1)
                                    (set! light-result-bucket (-> light-hash bucket-array light-lookup-result))
                                    (set! index-ptr (+ (+ (-> light-result-bucket index) 0) (the-as uint (-> light-hash index-array))))
                                    (set! index-index 0)
                                    (while (< index-index (the-as int (-> light-result-bucket count)))
                                      (let* ((light-sphere (-> light-hash light-sphere-array (-> (the-as (pointer uint8) (&+ index-ptr index-index)))))
                                             (palette-idx (-> light-sphere palette-index))
                                             (interp (if (= palette-idx -1)
                                                         1.0
                                                         (-> lev-mood times palette-idx w)
                                                         )
                                                     )
                                             )
                                        (if (!= (* (-> light-sphere brightness) interp) 0.0)
                                            (add-light-sphere-to-light-group lg light-sphere my-origin lev-mood)
                                            )
                                        )
                                      (set! index-index (+ index-index 1))
                                      )
                                    )
                                  )
                                )
                              )
                            )
                          )
                        )
                      )
                    (vu-lights<-light-group! fg-lights lg)
                    (when (and (nonzero? (-> dc shadow-ctrl))
                               (-> dc shadow-ctrl)
                               (not (logtest? (-> dc shadow-ctrl settings flags) (shadow-flags disable-draw)))
                               (not (logtest? (-> dc shadow-ctrl settings flags) (shadow-flags shdf07)))
                               )
                      (let ((target-shadow-dir (new 'stack-no-clear 'vector))
                            (current-shadow-dir (-> dc shadow-ctrl settings shadow-dir))
                            (shadow-dir-w (-> dc shadow-ctrl settings shadow-dir w))
                            )
                        (.lvf vf1 (&-> lg dir0 direction quad))
                        (.lvf vf2 (&-> lg dir1 direction quad))
                        (.lvf vf3 (&-> lg dir2 direction quad))
                        (.lvf vf4 (&-> lg dir0 extra quad))
                        (.lvf vf5 (&-> lg dir1 extra quad))
                        (.lvf vf6 (&-> lg dir2 extra quad))
                        (.mul.x.vf acc vf1 vf4)
                        (.add.mul.x.vf acc vf2 vf5 acc)
                        (.add.mul.x.vf vf1 vf3 vf6 acc)
                        (.svf (&-> target-shadow-dir quad) vf1)
                        (vector-normalize! target-shadow-dir -1.0)
                        (when (< (- (-> target-shadow-dir y)) 0.9063)
                          (let* ((f0-16 0.4226)
                                 (f1-6 (-> target-shadow-dir x))
                                 (f1-8 (* f1-6 f1-6))
                                 (f2-0 (-> target-shadow-dir z))
                                 (f0-17 (/ f0-16 (sqrtf (+ f1-8 (* f2-0 f2-0)))))
                                 )
                            (set! (-> target-shadow-dir x) (* (-> target-shadow-dir x) f0-17))
                            (set! (-> target-shadow-dir y) -0.9063)
                            (set! (-> target-shadow-dir z) (* (-> target-shadow-dir z) f0-17))
                            )
                          )
                        (when (not (paused?))
                          (vector-seek! current-shadow-dir target-shadow-dir (* 0.2 (seconds-per-frame)))
                          (vector-normalize! current-shadow-dir 1.0)
                          )
                        (set! (-> dc shadow-ctrl settings shadow-dir w) shadow-dir-w)
                        )
                      )
                    )
                  )
                )
              )
            (.lvf vf28 (&-> dc color-mult quad))
            (.lvf vf29 (&-> dc color-emissive quad))
            (.lvf vf2 (&-> fg-lights color 0 quad))
            (.lvf vf3 (&-> fg-lights color 1 quad))
            (.lvf vf4 (&-> fg-lights color 2 quad))
            (.lvf vf5 (&-> fg-lights ambient quad))
            (.mul.vf vf5 vf5 vf28)
            (.mul.vf vf2 vf2 vf28)
            (.mul.vf vf3 vf3 vf28)
            (.mul.vf vf4 vf4 vf28)
            (.add.vf vf5 vf5 vf29)
            (.svf (&-> fg-lights color 0 quad) vf2)
            (.svf (&-> fg-lights color 1 quad) vf3)
            (.svf (&-> fg-lights color 2 quad) vf4)
            (.svf (&-> fg-lights ambient quad) vf5)
            (let ((at-0 *math-camera*))
              (.lvf vf16 (&-> at-0 plane 0 quad))
              (.lvf vf17 (&-> at-0 plane 1 quad))
              (.lvf vf18 (&-> at-0 plane 2 quad))
              (.lvf vf19 (&-> at-0 plane 3 quad))
              (.lvf vf20 (&-> at-0 guard-plane 0 quad))
              (.lvf vf21 (&-> at-0 guard-plane 1 quad))
              (.lvf vf22 (&-> at-0 guard-plane 2 quad))
              (.lvf vf23 (&-> at-0 guard-plane 3 quad))
              (.lvf vf24 (&-> at-0 camera-rot quad 0))
              (.lvf vf25 (&-> at-0 camera-rot quad 1))
              (.lvf vf26 (&-> at-0 camera-rot quad 2))
              (.lvf vf27 (&-> at-0 camera-rot trans quad))
              )
            (let ((fg-dist (-> (the-as foreground-work #x70000000) distance)))
              (.lvf vf15 (&-> fg-bounds quad))
              (.mul.w.vf acc vf27 vf0)
              (.add.mul.x.vf acc vf24 vf15 acc)
              (.add.mul.y.vf acc vf25 vf15 acc)
              (.add.mul.z.vf vf15 vf26 vf15 acc :mask #b111)
              (.mul.vf vf28 vf15 vf15)
              (.max.w.vf vf29 vf0 vf0)
              (.add.y.vf acc vf28 vf28)
              (.add.mul.z.vf vf28 vf29 vf28 acc :mask #b1)
              (.sqrt.vf Q vf28 :ftf #b0)
              (.sub.w.vf vf28 vf0 vf15 :mask #b1000)
              (.wait.vf)
              (.add.vf vf15 vf28 Q :mask #b1000)
              (.svf (&-> fg-dist quad) vf15)
              (when (< 0.0 (+ (-> fg-dist z) (-> dc bounds w)))
                (let ((lod-idx 0))
                  (let ((dist-w (-> fg-dist w)))
                    (set! (-> dc distance) dist-w)
                    (when (nonzero? (-> dc lod-set max-lod))
                      (cond
                        ((>= (-> dc force-lod) 0)
                         (set! lod-idx (-> dc force-lod))
                         (if (< (-> dc lod-set lod (-> dc lod-set max-lod) dist) dist-w)
                             (return #f)
                             )
                         )
                        (else
                          (while (and (< lod-idx (-> dc lod-set max-lod)) (< (-> dc lod-set lod lod-idx dist) dist-w))
                            (+! lod-idx 1)
                            )
                          )
                        )
                      )
                    (if (and (< (-> dc lod-set lod lod-idx dist) dist-w) (< (-> dc force-lod) 0))
                        (return #f)
                        )
                    (let ((src-lev (-> *level* level (-> dc level-index)))
                          (corrected-dist (* dist-w (-> *math-camera* fov-correction-factor)))
                          (tex-use (-> dc mgeo header texture-usage-group))
                          )
                      (dotimes (use-fg-idx 7)
                        (let ((use-idx (+ use-fg-idx 11)))
                          (if (not (logtest? (-> dc status) (draw-control-status no-closest-distance)))
                              (set! (-> src-lev closest-object-array use-idx) (fmin (-> src-lev closest-object-array use-idx) dist-w))
                              )
                          )
                        (let ((tex-lod (cond
                                         ((>= corrected-dist (-> tex-use data use-fg-idx data 0 dist))
                                          0
                                          )
                                         ((>= corrected-dist (-> tex-use data use-fg-idx data 1 dist))
                                          1
                                          )
                                         (else
                                           2
                                           )
                                         )
                                       )
                              (a2-23 (+ use-fg-idx 11))
                              )
                          (let ((a3-10 (-> src-lev texture-mask a2-23 mask quad))
                                (t0-3 (-> (the-as (pointer uint128) (+ (the-as uint tex-use) (* 48 use-fg-idx) (* tex-lod 16))) 0))
                                )
                            (.por a3-11 a3-10 t0-3)
                            )
                          (set! (-> src-lev texture-mask a2-23 mask quad) a3-11)
                          )
                        )
                      )
                    (if (or (guard-band-cull fg-bounds) (< dist-w (* 1.2 (-> *math-camera* d))))
                        (logior! (-> dc status) (draw-control-status close-to-screen))
                        (logclear! (-> dc status) (draw-control-status close-to-screen))
                        )
                    (logior! (-> dc status) (draw-control-status on-screen))
                    (if (logtest? (-> dc status) (draw-control-status no-draw-bounds no-draw-bounds2))
                        (return #f)
                        )
                    (set! (-> pp clock) (-> sv-16 clock))
                    (if (or (= lod-idx (-> dc cur-lod)) (logtest? (-> dc status) (draw-control-status lod-set)))
                        (foreground-draw dc dma-buf dist-w)
                        )
                    )
                  (when (and (< lod-idx (-> dc cur-lod)) (logtest? (-> dc status) (draw-control-status math-skel)))
                    (let ((v1-159 *matrix-engine*))
                      (set! (-> v1-159 (-> v1-159 length)) (process->handle sv-16))
                      (+! (-> v1-159 length) 1)
                      )
                    )
                  (lod-set! dc lod-idx)
                  )
                (logior! (-> dc status) (draw-control-status lod-set))
                )
              )
            )
          )
        )
      (let ((v1-163 (-> *perf-stats* data 50)))
        (b! (zero? (-> v1-163 ctrl)) cfg-138 :delay (nop!))
        (.mtc0 Perf 0)
        (.sync.l)
        (.sync.p)
        (.mfpc a0-82 pcr0)
        (+! (-> v1-163 accum0) a0-82)
        (.mfpc a0-84 pcr1)
        (+! (-> v1-163 accum1) a0-84)
        )
      (label cfg-138)
      0
      0
      (none)
      )
    )
  )

;; definition for symbol *hud-lights*, type vu-lights
(define *hud-lights* (new 'global 'vu-lights))

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* direction 0) 1.0 0.0 0.0 1.0)

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* direction 1) 0.0 1.0 0.0 1.0)

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* direction 2) 0.0 0.0 1.0 1.0)

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* color 0) 0.0 0.0 0.0 1.0)

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* color 1) 0.0 0.0 0.0 1.0)

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* color 2) 0.5 0.5 0.5 1.0)

;; failed to figure out what this is:
(set-vector! (-> *hud-lights* ambient) 0.5 0.5 0.5 1.0)

;; definition for function dma-add-process-drawable-hud
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defun dma-add-process-drawable-hud ((arg0 process-drawable) (arg1 draw-control) (arg2 float) (arg3 dma-buffer))
  (local-vars (a3-4 uint128))
  (logclear! (-> arg1 status) (draw-control-status on-screen))
  (when (not (logtest? (-> arg1 status) (draw-control-status no-draw no-draw-temp uninited)))
    (let ((v1-6 (-> (the-as foreground-work #x70000000) lights))
          (a0-3 *hud-lights*)
          )
      (set! (-> v1-6 direction 0 quad) (-> a0-3 direction 0 quad))
      (set! (-> v1-6 direction 1 quad) (-> a0-3 direction 1 quad))
      (set! (-> v1-6 direction 2 quad) (-> a0-3 direction 2 quad))
      (set! (-> v1-6 color 0 quad) (-> a0-3 color 0 quad))
      (set! (-> v1-6 color 1 quad) (-> a0-3 color 1 quad))
      (set! (-> v1-6 color 2 quad) (-> a0-3 color 2 quad))
      (set! (-> v1-6 ambient quad) (-> a0-3 ambient quad))
      )
    (lod-set! arg1 0)
    (logior! (-> arg1 status) (draw-control-status on-screen))
    (foreground-draw-hud arg1 arg3 arg2)
    (let ((v1-12 (-> *level* default-level))
          (a0-8 (-> arg1 mgeo header texture-usage-group))
          )
      (dotimes (a1-9 7)
        (let ((a2-1 (+ a1-9 11)))
          (let ((a3-3 (-> v1-12 texture-mask a2-1 mask quad))
                (t0-3 (-> a0-8 data a1-9 data 2 mask quad))
                )
            (.por a3-4 a3-3 t0-3)
            )
          (set! (-> v1-12 texture-mask a2-1 mask quad) a3-4)
          )
        )
      )
    )
  0
  (none)
  )

;; definition for function add-process-drawable
;; WARN: Return type mismatch symbol vs none.
(defun add-process-drawable ((arg0 process-drawable) (arg1 draw-control) (arg2 symbol) (arg3 dma-buffer))
  ((-> arg1 dma-add-func) arg0 arg1 arg2 arg3)
  (none)
  )

;; definition for function foreground-engine-execute
;; WARN: Return type mismatch int vs none.
;; ERROR: Unsupported inline assembly instruction kind - [cache dxwbin v1, 0]
;; ERROR: Unsupported inline assembly instruction kind - [cache dxwbin v1, 1]
(defun foreground-engine-execute ((arg0 engine) (arg1 display-frame))
  (when (> (length arg0) 0)
    (let ((gp-0 (-> *display* frames (-> *display* on-screen) global-buf base)))
      (when *debug-segment*
        (let ((s3-0 (-> *display* frames (-> *display* on-screen) profile-array data 0))
              (v1-16 'foreground)
              (s2-0 *profile-foreground-color*)
              )
          (when (and *dproc* *debug-segment*)
            (let ((s1-0 (-> s3-0 data (-> s3-0 count))))
              (let ((s0-0 (-> s3-0 base-time)))
                (set! (-> s1-0 name) v1-16)
                (set! (-> s1-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s0-0))))
                )
              (set! (-> s1-0 depth) (the-as uint (-> s3-0 depth)))
              (set! (-> s1-0 color) s2-0)
              (set! (-> s3-0 segment (-> s3-0 depth)) s1-0)
              )
            (+! (-> s3-0 count) 1)
            (+! (-> s3-0 depth) 1)
            (set! (-> s3-0 max-depth) (max (-> s3-0 max-depth) (-> s3-0 depth)))
            )
          )
        0
        )
      (let ((s4-1 (-> arg1 global-buf)))
        (let ((v1-29 (-> s4-1 base)))
          (.sync.l)
          (.cache dxwbin v1-29 0)
          (.sync.l)
          (.cache dxwbin v1-29 1)
          )
        (.sync.l)
        0
        (foreground-init)
        (execute-connections arg0 s4-1)
        )
      (foreground-wrapup)
      (when *debug-segment*
        (let ((s5-1 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
          (when (and *dproc* *debug-segment*)
            (let* ((v1-44 (+ (-> s5-1 depth) -1))
                   (s4-2 (-> s5-1 segment v1-44))
                   (s3-1 (-> s5-1 base-time))
                   )
              (when (>= v1-44 0)
                (set! (-> s4-2 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-1))))
                (+! (-> s5-1 depth) -1)
                )
              )
            )
          )
        0
        )
      (let ((v1-49 *dma-mem-usage*))
        (when (nonzero? v1-49)
          (set! (-> v1-49 length) (max 36 (-> v1-49 length)))
          (set! (-> v1-49 data 35 name) "pris-fragment")
          (+! (-> v1-49 data 35 count) 1)
          (+! (-> v1-49 data 35 used)
              (&- (-> *display* frames (-> *display* on-screen) global-buf base) (the-as uint gp-0))
              )
          (set! (-> v1-49 data 35 total) (-> v1-49 data 35 used))
          )
        )
      )
    )
  0
  (none)
  )

;; definition (debug) for function main-debug-hook
(defun-debug main-debug-hook ()
  (when (not (or (= *master-mode* 'menu) (= *master-mode* 'progress)))
    (let ((a0-3 *col-rend*))
      (if (-> a0-3 draw?)
          (col-rend-method-9 a0-3)
          )
      )
    (execute-connections *debug-engine* #f)
    (draw-instance-info *stdcon*)
    )
  (none)
  )

;; definition for symbol *debug-hook*, type pair
(define *debug-hook* (cons main-debug-hook '()))

;; definition for symbol *add-sphere*, type symbol
(define *add-sphere* #f)

;; definition for symbol *generic-effect-mode*, type int
(define *generic-effect-mode* 0)

;; definition for function foreground-initialize-engines
;; WARN: Return type mismatch symbol vs none.
(defun foreground-initialize-engines ()
  (let ((v1-0 *shadow-globals*))
    (dotimes (a0-0 2)
      (let ((a1-2 (-> v1-0 bucket a0-0)))
        (set! (-> a1-2 first) (the-as pointer 0))
        (set! (-> a1-2 next) (the-as pointer 0))
        (set! (-> a1-2 shadow-color) (if (zero? a0-0)
                                         (new 'static 'rgba :r #xf0 :g #xf0 :b #xf0 :a #x80)
                                         (the-as rgba (-> *setting-control* user-current spotlight-color))
                                         )
              )
        (set! (-> a1-2 constants) (the-as shadow-vu1-constants 0))
        )
      )
    )
  (none)
  )

;; definition for function foreground-execute-cpu-vu0-engines
(defun foreground-execute-cpu-vu0-engines ()
  (let ((gp-0 (-> *display* frames (-> *display* on-screen) global-buf)))
    (bones-init gp-0)
    (bones-mtx-calc-execute)
    (generic-merc-execute-all gp-0)
    (shadow-execute-all gp-0)
    )
  (lightning-draw-all)
  (none)
  )

;; definition for function real-main-draw-hook
;; WARN: Return type mismatch int vs none.
(defun real-main-draw-hook ()
  (local-vars (a0-96 int) (a0-98 int))
  (with-pp
    (when *slow-frame-rate*
      (dotimes (v1-2 #xc3500)
        (nop!)
        (nop!)
        (nop!)
        (nop!)
        (nop!)
        (nop!)
        )
      )
    "Function to be executed to set up for engine dma"
    (set! (-> *display* vu1-enable-user) (-> *display* vu1-enable-user-menu))
    (set! (-> *texture-pool* texture-enable-user) (-> *texture-pool* texture-enable-user-menu))
    (when *debug-segment*
      (when (and *stats-memory* (!= *master-mode* 'menu))
        (cond
          (*stats-memory-short*
            (dotimes (gp-0 (-> *level* length))
              (let ((s5-0 (-> *level* level gp-0)))
                (if (= (-> s5-0 status) 'active)
                    (print-mem-usage (compute-memory-usage! s5-0 #f) s5-0 *stdcon*)
                    )
                )
              )
            )
          (else
            (let ((gp-1 (-> *level* level *stats-memory-level-index*)))
              (if (and gp-1 (= (-> gp-1 status) 'active))
                  (print-mem-usage (compute-memory-usage! gp-1 #f) gp-1 *stdcon*)
                  )
              )
            )
          )
        )
      (reset! *dma-mem-usage*)
      )
    (foreground-initialize-engines)
    (let ((gp-2 (-> pp clock)))
      (if (= (-> *time-of-day-context* mode) (time-of-day-palette-id unk3))
          (set! (-> pp clock) (-> *display* bg-clock))
          (set! (-> pp clock) (-> *display* real-clock))
          )
      (if (not (paused?))
          (update-wind *wind-work* *wind-scales*)
          )
      (update-time-of-day *time-of-day-context*)
      (set! (-> pp clock) gp-2)
      )
    (when *debug-segment*
      (let ((gp-3 (-> *display* frames (-> *display* on-screen) profile-array data 0))
            (v1-55 'sky)
            (s5-1 *profile-sky-color*)
            )
        (when (and *dproc* *debug-segment*)
          (let ((s4-0 (-> gp-3 data (-> gp-3 count))))
            (let ((s3-0 (-> gp-3 base-time)))
              (set! (-> s4-0 name) v1-55)
              (set! (-> s4-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-0))))
              )
            (set! (-> s4-0 depth) (the-as uint (-> gp-3 depth)))
            (set! (-> s4-0 color) s5-1)
            (set! (-> gp-3 segment (-> gp-3 depth)) s4-0)
            )
          (+! (-> gp-3 count) 1)
          (+! (-> gp-3 depth) 1)
          (set! (-> gp-3 max-depth) (max (-> gp-3 max-depth) (-> gp-3 depth)))
          )
        )
      0
      )
    (if (-> *sky-work* draw-vortex)
        (draw-vortex)
        (draw *sky-work*)
        )
    (flush-cache 0)
    (when *debug-segment*
      (let ((gp-4 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
        (when (and *dproc* *debug-segment*)
          (let* ((v1-84 (+ (-> gp-4 depth) -1))
                 (s5-2 (-> gp-4 segment v1-84))
                 (s4-1 (-> gp-4 base-time))
                 )
            (when (>= v1-84 0)
              (set! (-> s5-2 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-1))))
              (+! (-> gp-4 depth) -1)
              )
            )
          )
        )
      0
      )
    (let ((gp-5 (-> pp clock)))
      (if (= (-> *time-of-day-context* mode) (time-of-day-palette-id unk3))
          (set! (-> pp clock) (-> *display* bg-clock))
          (set! (-> pp clock) (-> *display* real-clock))
          )
      (when *debug-segment*
        (let ((s5-3 (-> *display* frames (-> *display* on-screen) profile-array data 0))
              (v1-102 'ocean)
              (s4-2 *profile-ocean-color*)
              )
          (when (and *dproc* *debug-segment*)
            (let ((s3-1 (-> s5-3 data (-> s5-3 count))))
              (let ((s2-0 (-> s5-3 base-time)))
                (set! (-> s3-1 name) v1-102)
                (set! (-> s3-1 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s2-0))))
                )
              (set! (-> s3-1 depth) (the-as uint (-> s5-3 depth)))
              (set! (-> s3-1 color) s4-2)
              (set! (-> s5-3 segment (-> s5-3 depth)) s3-1)
              )
            (+! (-> s5-3 count) 1)
            (+! (-> s5-3 depth) 1)
            (set! (-> s5-3 max-depth) (max (-> s5-3 max-depth) (-> s5-3 depth)))
            )
          )
        0
        )
      (draw! *ocean*)
      (if *ocean-map*
          (update-map *ocean*)
          )
      (when *debug-segment*
        (let ((s5-4 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
          (when (and *dproc* *debug-segment*)
            (let* ((v1-132 (+ (-> s5-4 depth) -1))
                   (s4-3 (-> s5-4 segment v1-132))
                   (s3-2 (-> s5-4 base-time))
                   )
              (when (>= v1-132 0)
                (set! (-> s4-3 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-2))))
                (+! (-> s5-4 depth) -1)
                )
              )
            )
          )
        0
        )
      (set! (-> pp clock) gp-5)
      )
    (foreground-engine-execute *foreground-draw-engine* (-> *display* frames (-> *display* on-screen)))
    (let ((gp-6 (-> pp clock)))
      (if (= (-> *time-of-day-context* mode) (time-of-day-palette-id unk3))
          (set! (-> pp clock) (-> *display* bg-clock))
          (set! (-> pp clock) (-> *display* real-clock))
          )
      (foreground-execute-cpu-vu0-engines)
      (set! (-> pp clock) gp-6)
      )
    (when *add-sphere*
      )
    (if (not (paused?))
        (execute-part-engine)
        )
    (if (logtest? (vu1-renderer-mask sprite) (-> *display* vu1-enable-user))
        (sprite-draw *display*)
        )
    (when *debug-segment*
      (debug-draw-actors *level* *display-actor-marks*)
      (collide-shape-draw-debug-marks)
      )
    (send-events-for-touching-shapes *touching-list*)
    (free-nodes *touching-list*)
    (prepare *collide-rider-pool*)
    (send-all! *event-queue*)
    (when *debug-segment*
      (let ((gp-7 (-> *display* frames (-> *display* on-screen) profile-array data 0))
            (v1-177 'update-actors)
            (s5-5 *profile-update-actors-color*)
            )
        (when (and *dproc* *debug-segment*)
          (let ((s4-4 (-> gp-7 data (-> gp-7 count))))
            (let ((s3-3 (-> gp-7 base-time)))
              (set! (-> s4-4 name) v1-177)
              (set! (-> s4-4 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-3))))
              )
            (set! (-> s4-4 depth) (the-as uint (-> gp-7 depth)))
            (set! (-> s4-4 color) s5-5)
            (set! (-> gp-7 segment (-> gp-7 depth)) s4-4)
            )
          (+! (-> gp-7 count) 1)
          (+! (-> gp-7 depth) 1)
          (set! (-> gp-7 max-depth) (max (-> gp-7 max-depth) (-> gp-7 depth)))
          )
        )
      0
      )
    (actors-update *level*)
    (when *debug-segment*
      (let ((gp-8 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
        (when (and *dproc* *debug-segment*)
          (let* ((v1-203 (+ (-> gp-8 depth) -1))
                 (s5-6 (-> gp-8 segment v1-203))
                 (s4-5 (-> gp-8 base-time))
                 )
            (when (>= v1-203 0)
              (set! (-> s5-6 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-5))))
              (+! (-> gp-8 depth) -1)
              )
            )
          )
        )
      0
      )
    (when *debug-segment*
      (let ((gp-9 (-> *display* frames (-> *display* on-screen) profile-array data 0))
            (v1-216 'nav)
            (s5-7 *profile-nav-color*)
            )
        (when (and *dproc* *debug-segment*)
          (let ((s4-6 (-> gp-9 data (-> gp-9 count))))
            (let ((s3-4 (-> gp-9 base-time)))
              (set! (-> s4-6 name) v1-216)
              (set! (-> s4-6 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-4))))
              )
            (set! (-> s4-6 depth) (the-as uint (-> gp-9 depth)))
            (set! (-> s4-6 color) s5-7)
            (set! (-> gp-9 segment (-> gp-9 depth)) s4-6)
            )
          (+! (-> gp-9 count) 1)
          (+! (-> gp-9 depth) 1)
          (set! (-> gp-9 max-depth) (max (-> gp-9 max-depth) (-> gp-9 depth)))
          )
        )
      0
      )
    (update-nav-meshes-method *level*)
    (when *debug-segment*
      (let ((gp-10 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
        (when (and *dproc* *debug-segment*)
          (let* ((v1-242 (+ (-> gp-10 depth) -1))
                 (s5-8 (-> gp-10 segment v1-242))
                 (s4-7 (-> gp-10 base-time))
                 )
            (when (>= v1-242 0)
              (set! (-> s5-8 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-7))))
              (+! (-> gp-10 depth) -1)
              )
            )
          )
        )
      0
      )
    (when *debug-segment*
      (let ((gp-11 (-> *display* frames (-> *display* on-screen) profile-array data 0))
            (v1-255 'background)
            (s5-9 *profile-background-color*)
            )
        (when (and *dproc* *debug-segment*)
          (let ((s4-8 (-> gp-11 data (-> gp-11 count))))
            (let ((s3-5 (-> gp-11 base-time)))
              (set! (-> s4-8 name) v1-255)
              (set! (-> s4-8 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-5))))
              )
            (set! (-> s4-8 depth) (the-as uint (-> gp-11 depth)))
            (set! (-> s4-8 color) s5-9)
            (set! (-> gp-11 segment (-> gp-11 depth)) s4-8)
            )
          (+! (-> gp-11 count) 1)
          (+! (-> gp-11 depth) 1)
          (set! (-> gp-11 max-depth) (max (-> gp-11 max-depth) (-> gp-11 depth)))
          )
        )
      0
      )
    (init-background)
    (execute-connections *background-draw-engine* (-> *display* frames (-> *display* on-screen)))
    (let* ((v1-275 (-> *perf-stats* data 40))
           (a0-94 (-> v1-275 ctrl))
           )
      (+! (-> v1-275 count) 1)
      (b! (zero? a0-94) cfg-116 :delay (nop!))
      (.mtc0 Perf 0)
      (.sync.l)
      (.sync.p)
      (.mtpc pcr0 0)
      (.mtpc pcr1 0)
      (.sync.l)
      (.sync.p)
      (.mtc0 Perf a0-94)
      )
    (.sync.l)
    (.sync.p)
    (label cfg-116)
    0
    (finish-background)
    (let ((v1-278 (-> *perf-stats* data 40)))
      (b! (zero? (-> v1-278 ctrl)) cfg-118 :delay (nop!))
      (.mtc0 Perf 0)
      (.sync.l)
      (.sync.p)
      (.mfpc a0-96 pcr0)
      (+! (-> v1-278 accum0) a0-96)
      (.mfpc a0-98 pcr1)
      (+! (-> v1-278 accum1) a0-98)
      )
    (label cfg-118)
    0
    (update-wait-stats
      (-> *perf-stats* data 40)
      (-> *background-work* wait-to-vu0)
      (the-as uint 0)
      (the-as uint 0)
      )
    (b! (not *debug-segment*) cfg-126 :delay (empty-form))
    (let ((gp-12 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
      (when (and *dproc* *debug-segment*)
        (let* ((v1-295 (+ (-> gp-12 depth) -1))
               (s5-10 (-> gp-12 segment v1-295))
               (s4-9 (-> gp-12 base-time))
               )
          (when (>= v1-295 0)
            (set! (-> s5-10 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-9))))
            (+! (-> gp-12 depth) -1)
            )
          )
        )
      )
    0
    (label cfg-126)
    (end-perf-stat-collection)
    (when (and (!= *master-mode* 'menu) *stats-poly*)
      (dotimes (gp-13 (-> *level* length))
        (let ((v1-307 (-> *level* level gp-13)))
          (if (= (-> v1-307 status) 'active)
              (collect-stats (-> v1-307 bsp))
              )
          )
        )
      (print-terrain-stats)
      )
    (when (not (paused?))
      (if (and (!= *master-mode* 'menu) *stats-perf*)
          (print-perf-stats)
          )
      (if (and (!= *master-mode* 'menu) *stats-collide*)
          (print-collide-stats)
          )
      )
    (start-perf-stat-collection)
    0
    (none)
    )
  )

;; definition for function main-draw-hook
(defun main-draw-hook ()
  (real-main-draw-hook)
  (none)
  )

;; definition for symbol *draw-hook*, type (function none)
(define *draw-hook* main-draw-hook)

;; definition for function default-init-buffer
;; WARN: Return type mismatch symbol vs none.
(defun default-init-buffer ((arg0 bucket-id) (arg1 gs-zbuf) (arg2 gs-test))
  (let ((v1-6 (-> *display* frames (-> *display* on-screen) bucket-group arg0)))
    (when (!= v1-6 (-> v1-6 last))
      (let* ((a0-8 (-> *display* frames (-> *display* on-screen) global-buf))
             (a3-3 (-> a0-8 base))
             )
        (dma-buffer-add-gs-set-flusha a0-8
                                      (zbuf-1 arg1)
                                      (test-1 arg2)
                                      (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1))
                                      (pabe 0)
                                      (clamp-1 (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp)))
                                      (tex1-1 (new 'static 'gs-tex1 :mmag #x1 :mmin #x1))
                                      (texa (new 'static 'gs-texa :ta1 #x80))
                                      (texclut (new 'static 'gs-texclut :cbw #x4))
                                      (fogcol *fog-color*)
                                      )
        (let ((a1-18 (the-as object (-> a0-8 base))))
          (set! (-> (the-as dma-packet a1-18) dma) (new 'static 'dma-tag :id (dma-tag-id next) :addr (-> v1-6 next)))
          (set! (-> (the-as dma-packet a1-18) vif0) (new 'static 'vif-tag))
          (set! (-> (the-as dma-packet a1-18) vif1) (new 'static 'vif-tag))
          (set! (-> a0-8 base) (&+ (the-as pointer a1-18) 16))
          )
        (set! (-> v1-6 next) (the-as uint a3-3))
        )
      )
    )
  (none)
  )

;; definition for function default-end-buffer
;; WARN: Return type mismatch symbol vs none.
(defun default-end-buffer ((arg0 bucket-id) (arg1 gs-zbuf) (arg2 gs-test))
  (let ((v1-6 (-> *display* frames (-> *display* on-screen) bucket-group arg0)))
    (when (!= v1-6 (-> v1-6 last))
      (let* ((a3-2 (-> *display* frames (-> *display* on-screen) global-buf))
             (a0-8 (-> a3-2 base))
             )
        (dma-buffer-add-gs-set-flusha a3-2
                                      (zbuf-1 arg1)
                                      (test-1 arg2)
                                      (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1))
                                      (pabe 0)
                                      (clamp-1 (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp)))
                                      (tex1-1 (new 'static 'gs-tex1 :mmag #x1 :mmin #x1))
                                      (texa (new 'static 'gs-texa :ta1 #x80))
                                      (texclut (new 'static 'gs-texclut :cbw #x4))
                                      (fogcol *fog-color*)
                                      )
        (let ((t0-4 (-> a3-2 base)))
          (let ((a1-18 (the-as object (-> a3-2 base))))
            (set! (-> (the-as dma-packet a1-18) dma) (new 'static 'dma-tag :id (dma-tag-id next)))
            (set! (-> (the-as dma-packet a1-18) vif0) (new 'static 'vif-tag))
            (set! (-> (the-as dma-packet a1-18) vif1) (new 'static 'vif-tag))
            (set! (-> a3-2 base) (&+ (the-as pointer a1-18) 16))
            )
          (set! (-> (the-as dma-bucket (-> v1-6 last)) next) (the-as uint a0-8))
          (set! (-> v1-6 last) (the-as (pointer dma-tag) t0-4))
          )
        )
      )
    )
  (none)
  )

;; definition (debug) for function screen-shot-scale
;; WARN: Return type mismatch int vs none.
(defun-debug screen-shot-scale ((arg0 int) (arg1 string))
  (set! (-> *screen-shot-work* size) arg0)
  (set! (-> *screen-shot-work* name) arg1)
  (set! *display-profile* #f)
  0
  (none)
  )

;; definition (debug) for function screen-shot
;; WARN: Return type mismatch int vs none.
(defun-debug screen-shot ()
  (screen-shot-scale 1 "image")
  0
  (none)
  )

;; definition for function display-frame-start
;; WARN: Return type mismatch display vs none.
(defun display-frame-start ((arg0 display) (arg1 int) (arg2 float))
  (set! (-> (the-as vif-bank #x10003c00) err me0) 1)
  (set-time-ratios *display* 1.0)
  (tick! (-> arg0 frame-clock))
  (tick! (-> arg0 real-frame-clock))
  (set-time-ratios *display* arg2)
  (tick! (-> arg0 session-clock))
  (tick! (-> arg0 game-clock))
  (tick! (-> arg0 total-game-clock))
  (tick! (-> arg0 base-clock))
  (tick! (-> arg0 real-clock))
  (tick! (-> arg0 target-clock))
  (tick! (-> arg0 camera-clock))
  (tick! (-> arg0 entity-clock))
  (tick! (-> arg0 user0-clock))
  (tick! (-> arg0 bg-clock))
  (set! (-> arg0 bg-clock frame-counter) (the-as time-frame (mod (-> arg0 bg-clock frame-counter) #x69780)))
  (tick! (-> arg0 part-clock))
  (when (and (nonzero? *screen-shot-work*) (!= (-> *screen-shot-work* count) -1))
    (let ((v1-43 (-> *screen-shot-work* size)))
      (if (!= (-> *screen-shot-work* count) (* v1-43 v1-43))
          (store-image *screen-shot-work*)
          )
      )
    (+! (-> *screen-shot-work* count) -1)
    (if (= (-> *screen-shot-work* count) -1)
        (set! (-> *screen-shot-work* size) -1)
        )
    )
  (let ((s5-1 (-> arg0 frames arg1)))
    (if *sync-dma*
        (sync-path 0 0)
        )
    (let ((v1-57 (-> s5-1 global-buf)))
      (set! (-> v1-57 base) (-> v1-57 data))
      (set! (-> v1-57 end) (&-> v1-57 data-buffer (-> v1-57 allocated-length)))
      )
    (let ((v1-58 (-> s5-1 global-buf)))
      (&+! (-> v1-58 end) -65536)
      )
    (when *debug-segment*
      (let ((v1-61 (-> s5-1 debug-buf)))
        (set! (-> v1-61 base) (-> v1-61 data))
        (set! (-> v1-61 end) (&-> v1-61 data-buffer (-> v1-61 allocated-length)))
        )
      )
    (let ((v1-62 (-> s5-1 calc-buf)))
      (set! (-> v1-62 base) (-> v1-62 data))
      (set! (-> v1-62 end) (&-> v1-62 data-buffer (-> v1-62 allocated-length)))
      )
    (*pre-draw-hook* (-> s5-1 calc-buf))
    (when (not (paused?))
      (clear *stdcon1*)
      (debug-reset-buffers)
      (clear! *simple-sprite-system*)
      )
    (set! (-> s5-1 bucket-group) (dma-buffer-add-buckets (-> s5-1 calc-buf) 327))
    )
  (service-cpads)
  (service-mouse)
  (execute-connections *pad-engine* #f)
  (none)
  )

;; definition for function display-frame-finish
(defun display-frame-finish ((arg0 display))
  (with-pp
    (let* ((s4-0 (-> arg0 frames (-> arg0 on-screen)))
           (s5-0 (-> s4-0 calc-buf))
           )
      (-> s4-0 global-buf)
      (tfrag-vu1-init-buffers)
      (tie-vu1-init-buffers)
      (merc-vu1-init-buffers)
      (emerc-vu1-init-buffers)
      (generic-vu1-init-buffers)
      (when (-> *texture-pool* update-sprites-flag)
        (update-sprites *texture-pool*)
        (particle-adgif-cache-flush)
        (remap-all-particles)
        )
      (when *debug-segment*
        (let ((s3-0 (-> *display* frames (-> *display* on-screen) profile-array data 0))
              (v1-17 'texture)
              (s2-0 *profile-texture-color*)
              )
          (when (and *dproc* *debug-segment*)
            (let ((s1-0 (-> s3-0 data (-> s3-0 count))))
              (let ((s0-0 (-> s3-0 base-time)))
                (set! (-> s1-0 name) v1-17)
                (set! (-> s1-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s0-0))))
                )
              (set! (-> s1-0 depth) (the-as uint (-> s3-0 depth)))
              (set! (-> s1-0 color) s2-0)
              (set! (-> s3-0 segment (-> s3-0 depth)) s1-0)
              )
            (+! (-> s3-0 count) 1)
            (+! (-> s3-0 depth) 1)
            (set! (-> s3-0 max-depth) (max (-> s3-0 max-depth) (-> s3-0 depth)))
            )
          )
        0
        )
      (let ((s3-1 (-> pp clock)))
        (if (= (-> *time-of-day-context* mode) (time-of-day-palette-id unk3))
            (set! (-> pp clock) (-> *display* bg-clock))
            (set! (-> pp clock) (-> *display* real-clock))
            )
        (upload-textures *texture-pool*)
        (set! (-> pp clock) s3-1)
        )
      (when *debug-segment*
        (let ((s3-2 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
          (when (and *dproc* *debug-segment*)
            (let* ((v1-47 (+ (-> s3-2 depth) -1))
                   (s2-1 (-> s3-2 segment v1-47))
                   (s1-1 (-> s3-2 base-time))
                   )
              (when (>= v1-47 0)
                (set! (-> s2-1 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s1-1))))
                (+! (-> s3-2 depth) -1)
                )
              )
            )
          )
        0
        )
      (if (-> *texture-pool* update-flag)
          (update-warp-and-hud *texture-pool*)
          )
      (-> *display* frames (-> *display* on-screen) global-buf)
      (update-eyes)
      (let ((s3-3 6)
            (s2-2 324)
            )
        (while (>= s2-2 s3-3)
          (default-end-buffer
            (the-as bucket-id s3-3)
            (new 'static 'gs-zbuf :zbp #x130 :psm (gs-psm ct24))
            (new 'static 'gs-test :zte #x1 :ztst (gs-ztest greater-equal))
            )
          (+! s3-3 1)
          )
        )
      (default-init-buffer
        (bucket-id debug-no-zbuf1)
        (new 'static 'gs-zbuf :zbp #x130 :psm (gs-psm ct24) :zmsk #x1)
        (new 'static 'gs-test :zte #x1 :ztst (gs-ztest always))
        )
      (default-init-buffer
        (bucket-id debug-no-zbuf2)
        (new 'static 'gs-zbuf :zbp #x130 :psm (gs-psm ct24) :zmsk #x1)
        (new 'static 'gs-test :zte #x1 :ztst (gs-ztest always))
        )
      (default-init-buffer
        (bucket-id screen-filter)
        (new 'static 'gs-zbuf :zbp #x130 :psm (gs-psm ct24) :zmsk #x1)
        (new 'static 'gs-test :zte #x1 :ztst (gs-ztest always))
        )
      (*post-draw-hook* (-> arg0 frames (-> arg0 on-screen) calc-buf))
      (let* ((v1-70 s5-0)
             (a0-25 (the-as object (-> v1-70 base)))
             )
        (set! (-> (the-as dma-packet a0-25) dma) (new 'static 'dma-tag :id (dma-tag-id cnt)))
        (set! (-> (the-as dma-packet a0-25) vif0) (new 'static 'vif-tag :imm #x148 :cmd (vif-cmd mark)))
        (set! (-> (the-as dma-packet a0-25) vif1) (new 'static 'vif-tag :cmd (vif-cmd flushe) :irq #x1 :msk #x1))
        (set! (-> v1-70 base) (the-as pointer (&+ (the-as dma-packet a0-25) 16)))
        )
      (dma-buffer-patch-buckets (-> s4-0 bucket-group) 327)
      (let* ((v1-71 s5-0)
             (a0-28 (the-as object (-> v1-71 base)))
             )
        (set! (-> (the-as dma-packet a0-28) dma) (new 'static 'dma-tag :id (dma-tag-id end)))
        (set! (-> (the-as (pointer int64) a0-28) 1) 0)
        (set! (-> v1-71 base) (&+ (the-as pointer a0-28) 16))
        )
      (flush-cache 0)
      (when (not (paused?))
        (when *stats-buffer*
          (let* ((a0-31 (-> s4-0 global-buf))
                 (v1-75 (-> s5-0 base))
                 (a2-4 (-> s5-0 data))
                 (s4-1 (-> a0-31 base))
                 (s5-1 (-> a0-31 data))
                 (s3-4 (-> a0-31 end))
                 )
            (format *stdcon* "~0kvu1 buf = ~d~%" (&- v1-75 (the-as uint a2-4)))
            (format *stdcon* "~0kglobal buf = ~d~%" (&- s4-1 (the-as uint s5-1)))
            (format *stdcon* "~0kbase = #x~x~%" s4-1)
            (format *stdcon* "~0kend = #x~x~%" s3-4)
            )
          )
        )
      )
    arg0
    )
  )

;; definition for function determine-pause-mode
(defun determine-pause-mode ()
  (when (and (or (not *progress-process*) (can-go-back? (-> *progress-process* 0)))
             (or (!= *master-mode* 'freeze) (and *debug-segment* (cpad-pressed? 0 select start) (cpad-hold? 0 l3)))
             )
    (if (or (cpad-pressed? 0 select start)
            (cond
              ((= *master-mode* 'menu)
               (cpad-pressed? 0 r3 r2 triangle circle)
               )
              (*cam-layout*
                #f
                )
              (else
                #f
                )
              )
            (or (and (logtest? (-> *cpad-list* cpads 0 valid) 128)
                     (= *master-mode* 'game)
                     (>= (-> *display* base-clock frame-counter) (-> *game-info* blackout-time))
                     (= (-> *setting-control* user-current bg-a) 0.0)
                     (and (= (-> *setting-control* user-current bg-a-force) 0.0)
                          (< (seconds 1003) (-> *display* real-clock frame-counter))
                          )
                     )
                (and (cpad-pressed? 0 r2) (or (= *master-mode* 'pause) (= *master-mode* 'menu)))
                *pause-lock*
                )
            )
        (toggle-pause)
        )
    )
  (if (and *progress-process* (!= *master-mode* 'progress))
      (deactivate-progress)
      )
  0
  )

;; definition for function display-sync
(defun display-sync ((arg0 display))
  (sync-path 0 0)
  (let* ((just-rendered-frame (-> arg0 last-screen))
         (current-time (shl (timer-count (the-as timer-bank #x10000800)) 48))
         (just-rendered-frame-start-time (shl (-> arg0 frames just-rendered-frame start-time) 48))
         (prev-vblank-time-1 (shl (-> arg0 vblank-start-time 0) 48))
         (prev-vblank-time-2 (shl (-> arg0 vblank-start-time 1) 48))
         )
    (set! *ticks-per-frame* (sar (- prev-vblank-time-2 prev-vblank-time-1) 48))
    (let* ((ticks-per-frame-f (the float *ticks-per-frame*))
           (frame-duration (the float (sar (- current-time (the-as uint just-rendered-frame-start-time)) 48)))
           (frame-time-ratio (/ frame-duration ticks-per-frame-f))
           )
      (/ (the float (sar (- current-time (the-as uint prev-vblank-time-2)) 48)) ticks-per-frame-f)
      (let ((vysnc-progress (/ (the float (sar (- current-time (the-as uint prev-vblank-time-2)) 48)) ticks-per-frame-f))
            (last-dog (fmax 1.0 (fmin 4.0 (-> *display* dog-ratio))))
            )
        (set! (-> arg0 frames just-rendered-frame run-time) (the int frame-duration))
        (set! frame-time-ratio
              (cond
                ((-> arg0 run-half-speed)
                 (syncv 0)
                 (if (and (< (/ (the float
                                     (sar
                                       (- (shl (timer-count (the-as timer-bank #x10000800)) 48) (the-as uint just-rendered-frame-start-time))
                                       48
                                       )
                                     )
                                ticks-per-frame-f
                                )
                             2.0
                             )
                          (< vysnc-progress 0.9)
                          )
                     (syncv 0)
                     )
                 2.0
                 )
                (else
                  (cond
                    ((< 1.0 frame-time-ratio)
                     (when (not (or (zero? prev-vblank-time-1) (zero? prev-vblank-time-2)))
                       (when (> (-> arg0 force-sync) 0)
                         (syncv 0)
                         (+! (-> arg0 force-sync) -1)
                         (let ((v1-23 (shl (timer-count (the-as timer-bank #x10000800)) 48)))
                           (the float (sar (- v1-23 (the-as uint just-rendered-frame-start-time)) 48))
                           (set! frame-time-ratio
                                 (/ (the float (sar (- v1-23 (the-as uint just-rendered-frame-start-time)) 48)) ticks-per-frame-f)
                                 )
                           )
                         )
                       )
                     (set! (-> arg0 dog-count) 0.0)
                     )
                    ((or (= last-dog 1.0) (!= (-> arg0 dog-count) 0.0))
                     (if (< vysnc-progress 0.9)
                         (syncv 0)
                         )
                     (set! frame-time-ratio 1.0)
                     (set! (-> arg0 dog-count) 0.0)
                     )
                    (else
                      (when (not (or (zero? prev-vblank-time-1) (zero? prev-vblank-time-2)))
                        (while (or (< frame-time-ratio last-dog) (and (< 0.333 vysnc-progress) (< vysnc-progress 0.667)))
                          (let ((v1-34 (shl (timer-count (the-as timer-bank #x10000800)) 48)))
                            (set! frame-time-ratio
                                  (/ (the float (sar (- v1-34 (the-as uint just-rendered-frame-start-time)) 48)) ticks-per-frame-f)
                                  )
                            (if (< frame-time-ratio 0.0)
                                (set! frame-time-ratio last-dog)
                                )
                            (set! vysnc-progress
                                  (/ (the float (sar (- v1-34 (the-as uint (shl (-> arg0 vblank-start-time 1) 48))) 48)) ticks-per-frame-f)
                                  )
                            )
                          )
                        )
                      (set! (-> arg0 dog-count) 1.0)
                      )
                    )
                  frame-time-ratio
                  )
                )
              )
        (if (< frame-time-ratio 0.0)
            (set! frame-time-ratio last-dog)
            )
        )
      (let ((next-dog (fmax 1.0 frame-time-ratio))
            (frame-to-render (-> arg0 on-screen))
            )
        (let ((time-after-vsync (timer-count (the-as timer-bank #x10000800))))
          (+! (-> arg0 total-run-time)
              (sar (- (shl time-after-vsync 48) (the-as uint just-rendered-frame-start-time)) 48)
              )
          (set! (-> arg0 frames frame-to-render start-time) (the-as int time-after-vsync))
          )
        (set-graphics-mode)
        (let ((next-dma-buf (-> arg0 frames frame-to-render calc-buf)))
          (when (nonzero? (dma-buffer-length next-dma-buf))
            (+! frame-to-render 1)
            (if (< 1 frame-to-render)
                (set! frame-to-render 0)
                )
            (set! (-> arg0 last-screen) (-> arg0 on-screen))
            (set! (-> arg0 on-screen) frame-to-render)
            (when *debug-segment*
              (set! *profile-interrupt-segment* (-> *display* frames (-> *display* last-screen) profile-array data 1))
              (set! (-> *profile-interrupt-segment* depth) 0)
              (set! (-> *profile-interrupt-segment* max-depth) 1)
              )
            (dma-buffer-send-chain (the-as dma-bank-source #x10009000) next-dma-buf)
            )
          )
        (determine-pause-mode)
        (when (and (nonzero? *screen-shot-work*) (= (-> *screen-shot-work* count) -1) (!= (-> *screen-shot-work* size) -1))
          (let ((v1-77 (-> *screen-shot-work* size)))
            (set! (-> *screen-shot-work* count) (* v1-77 v1-77))
            )
          (set-master-mode 'pause)
          )
        (display-frame-start arg0 frame-to-render next-dog)
        )
      )
    )
  (none)
  )

;; definition for function swap-display
(defun swap-display ((arg0 display))
  (display-frame-finish arg0)
  (display-sync arg0)
  (none)
  )
