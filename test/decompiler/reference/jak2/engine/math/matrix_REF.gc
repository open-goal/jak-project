;;-*-Lisp-*-
(in-package goal)

;; definition for method 3 of type matrix
;; INFO: this function exists in multiple non-identical object files
(defmethod inspect matrix ((obj matrix))
  (format #t "[~8x] matrix~%" obj)
  (format #t "~T[~F] [~F] [~F] [~F]~%" (-> obj data 0) (-> obj data 1) (-> obj data 2) (-> obj data 3))
  (format #t "~T[~F] [~F] [~F] [~F]~%" (-> obj data 4) (-> obj data 5) (-> obj data 6) (-> obj data 7))
  (format #t "~T[~F] [~F] [~F] [~F]~%" (-> obj data 8) (-> obj data 9) (-> obj data 10) (-> obj data 11))
  (format #t "~T[~F] [~F] [~F] [~F]~%" (-> obj trans x) (-> obj trans y) (-> obj trans z) (-> obj trans w))
  obj
  )

;; definition for method 3 of type matrix3
;; INFO: this function exists in multiple non-identical object files
(defmethod inspect matrix3 ((obj matrix3))
  (format #t "[~8x] matrix3~%" obj)
  (format #t "~T[~F] [~F] [~F]~%" (-> obj data 0) (-> obj data 1) (-> obj data 2))
  (format #t "~T[~F] [~F] [~F]~%" (-> obj data 4) (-> obj data 5) (-> obj data 6))
  (format #t "~T[~F] [~F] [~F]~%" (-> obj data 8) (-> obj data 9) (-> obj data 10))
  obj
  )

;; definition for function matrix-identity!
;; INFO: Used lq/sq
(defun matrix-identity! ((arg0 matrix))
  (set! (-> arg0 vector 0 quad) (the-as uint128 0))
  (set! (-> arg0 vector 1 quad) (the-as uint128 0))
  (set! (-> arg0 vector 2 quad) (the-as uint128 0))
  (set! (-> arg0 trans quad) (the-as uint128 0))
  (let ((f0-0 1.0))
    (set! (-> arg0 trans w) f0-0)
    (set! (-> arg0 data 10) f0-0)
    (set! (-> arg0 data 5) f0-0)
    (set! (-> arg0 data 0) f0-0)
    )
  arg0
  )

;; definition for symbol *identity-matrix*, type matrix
(define *identity-matrix* (matrix-identity! (new 'global 'matrix)))

;; definition for symbol *hermite-matrix*, type matrix
(define *hermite-matrix*
  (new 'static 'matrix
    :data (new 'static 'array float 16 2.0 -2.0 1.0 1.0 -3.0 3.0 -2.0 -1.0 0.0 0.0 1.0 0.0 1.0 0.0 0.0 0.0)
    )
  )

;; definition for function matrix+!
(defun matrix+! ((arg0 matrix) (arg1 matrix) (arg2 matrix))
  (dotimes (v1-0 16)
    (set! (-> arg0 data v1-0) (+ (-> arg1 data v1-0) (-> arg2 data v1-0)))
    )
  arg0
  )

;; definition for function matrix-!
(defun matrix-! ((arg0 matrix) (arg1 matrix) (arg2 matrix))
  (dotimes (v1-0 16)
    (set! (-> arg0 data v1-0) (- (-> arg1 data v1-0) (-> arg2 data v1-0)))
    )
  arg0
  )

;; definition for function matrix*!
(defun matrix*! ((arg0 matrix) (arg1 matrix) (arg2 matrix))
  (rlet ((acc :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf12 :class vf)
         (vf13 :class vf)
         (vf14 :class vf)
         (vf15 :class vf)
         (vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf20 :class vf)
         (vf21 :class vf)
         )
    (.lvf vf10 (&-> arg1 vector 0 quad))
    (.lvf vf14 (&-> arg2 vector 0 quad))
    (.lvf vf15 (&-> arg2 vector 1 quad))
    (.lvf vf16 (&-> arg2 vector 2 quad))
    (.lvf vf17 (&-> arg2 trans quad))
    (.lvf vf11 (&-> arg1 vector 1 quad))
    (.lvf vf12 (&-> arg1 vector 2 quad))
    (.lvf vf13 (&-> arg1 trans quad))
    (.mul.x.vf acc vf14 vf10)
    (.add.mul.y.vf acc vf15 vf10 acc)
    (.add.mul.z.vf acc vf16 vf10 acc)
    (.add.mul.w.vf vf18 vf17 vf10 acc)
    (.mul.x.vf acc vf14 vf11)
    (.add.mul.y.vf acc vf15 vf11 acc)
    (.add.mul.z.vf acc vf16 vf11 acc)
    (.add.mul.w.vf vf19 vf17 vf11 acc)
    (.mul.x.vf acc vf14 vf12)
    (.add.mul.y.vf acc vf15 vf12 acc)
    (.add.mul.z.vf acc vf16 vf12 acc)
    (.add.mul.w.vf vf20 vf17 vf12 acc)
    (.mul.x.vf acc vf14 vf13)
    (.add.mul.y.vf acc vf15 vf13 acc)
    (.add.mul.z.vf acc vf16 vf13 acc)
    (.add.mul.w.vf vf21 vf17 vf13 acc)
    (.svf (&-> arg0 vector 0 quad) vf18)
    (.svf (&-> arg0 vector 1 quad) vf19)
    (.svf (&-> arg0 vector 2 quad) vf20)
    (.svf (&-> arg0 trans quad) vf21)
    arg0
    )
  )

;; definition for function matrixp*!
;; INFO: Used lq/sq
(defun matrixp*! ((arg0 matrix) (arg1 matrix) (arg2 matrix))
  (let ((s5-0 (new-stack-matrix0)))
    (matrix*! s5-0 arg1 arg2)
    (set! (-> arg0 vector 0 quad) (-> s5-0 vector 0 quad))
    (set! (-> arg0 vector 1 quad) (-> s5-0 vector 1 quad))
    (set! (-> arg0 vector 2 quad) (-> s5-0 vector 2 quad))
    (set! (-> arg0 trans quad) (-> s5-0 trans quad))
    )
  arg0
  )

;; definition for function vector-matrix*!
(defun vector-matrix*! ((arg0 vector) (arg1 vector) (arg2 matrix))
  (rlet ((acc :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         )
    (.lvf vf1 (&-> arg2 vector 0 quad))
    (.lvf vf2 (&-> arg2 vector 1 quad))
    (.lvf vf3 (&-> arg2 vector 2 quad))
    (.lvf vf4 (&-> arg2 trans quad))
    (.lvf vf5 (&-> arg1 quad))
    (.mul.x.vf acc vf1 vf5)
    (.add.mul.y.vf acc vf2 vf5 acc)
    (.add.mul.z.vf acc vf3 vf5 acc)
    (.add.mul.w.vf vf5 vf4 vf5 acc)
    (.svf (&-> arg0 quad) vf5)
    arg0
    )
  )

;; definition for function vector-rotate*!
(defun vector-rotate*! ((arg0 vector) (arg1 vector) (arg2 matrix))
  (rlet ((acc :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         )
    (nop!)
    (nop!)
    (.lvf vf5 (&-> arg1 quad))
    (nop!)
    (.lvf vf1 (&-> arg2 vector 0 quad))
    (nop!)
    (.lvf vf2 (&-> arg2 vector 1 quad))
    (.mul.x.vf acc vf1 vf5)
    (.lvf vf3 (&-> arg2 vector 2 quad))
    (.add.mul.y.vf acc vf2 vf5 acc)
    (.lvf vf4 (&-> arg2 trans quad))
    (.add.mul.z.vf vf5 vf3 vf5 acc)
    (nop!)
    (nop!)
    (.svf (&-> arg0 quad) vf5)
    arg0
    )
  )

;; definition for function vector3s-matrix*!
;; INFO: Used lq/sq
(defun vector3s-matrix*! ((arg0 vector3s) (arg1 vector3s) (arg2 matrix))
  (let ((s5-0 (new-stack-vector0)))
    (set-vector! s5-0 (-> arg1 x) (-> arg1 y) (-> arg1 z) 1.0)
    (vector-matrix*! s5-0 s5-0 arg2)
    (set! (-> arg0 x) (-> s5-0 x))
    (set! (-> arg0 y) (-> s5-0 y))
    (set! (-> arg0 z) (-> s5-0 z))
    )
  arg0
  )

;; definition for function vector3s-rotate*!
;; INFO: Used lq/sq
(defun vector3s-rotate*! ((arg0 vector3s) (arg1 vector3s) (arg2 matrix))
  (let ((s5-0 (new-stack-vector0)))
    (set-vector! s5-0 (-> arg1 x) (-> arg1 y) (-> arg1 z) 1.0)
    (vector-rotate*! s5-0 s5-0 arg2)
    (set! (-> arg0 x) (-> s5-0 x))
    (set! (-> arg0 y) (-> s5-0 y))
    (set! (-> arg0 z) (-> s5-0 z))
    )
  arg0
  )

;; definition for function matrix-transpose!
;; INFO: Used lq/sq
;; ERROR: Function may read a register that is not set: f31
(defun matrix-transpose! ((arg0 matrix) (arg1 matrix))
  (local-vars
    (r0-0 int)
    (r0-1 int)
    (r0-2 int)
    (r0-3 int)
    (v1-0 uint128)
    (v1-1 uint128)
    (v1-2 uint128)
    (a1-1 uint128)
    (a2-1 uint128)
    (t0-1 uint128)
    (f31-0 none)
    )
  (nop!)
  (nop!)
  (let ((t0-0 (-> arg1 vector 0 quad)))
    (nop!)
    (let ((t1-0 (-> arg1 vector 1 quad)))
      (nop!)
      (let ((a2-0 (-> arg1 vector 2 quad)))
        (.pextlw v1-0 t1-0 t0-0)
        (let ((a3-0 (-> arg1 trans quad)))
          (.pextuw a1-1 t1-0 t0-0)
          (.mov r0-0 f31-0)
          (.pextlw t0-1 a3-0 a2-0)
          (.mov r0-1 f31-0)
          (.pextuw a2-1 a3-0 a2-0)
          )
        )
      )
    )
  (.mov r0-2 f31-0)
  (let ((a3-1 (make-u128 t0-1 v1-0)))
    (.mov r0-3 f31-0)
    (.pcpyud v1-1 v1-0 t0-1)
    (set! (-> arg0 vector 0 quad) (the-as uint128 a3-1))
    )
  (let ((a3-2 (make-u128 a2-1 a1-1)))
    (set! (-> arg0 vector 1 quad) v1-1)
    (.pcpyud v1-2 a1-1 a2-1)
    (set! (-> arg0 vector 2 quad) (the-as uint128 a3-2))
    )
  (nop!)
  (set! (-> arg0 trans quad) v1-2)
  arg0
  )

;; definition for function matrix-inverse-of-rot-trans!
(defun matrix-inverse-of-rot-trans! ((arg0 matrix) (arg1 matrix))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf8 :class vf)
         )
    (init-vf0-vector)
    (matrix-transpose! arg0 arg1)
    (.lvf vf1 (&-> arg0 vector 0 quad))
    (.lvf vf2 (&-> arg0 vector 1 quad))
    (.lvf vf3 (&-> arg0 vector 2 quad))
    (.sub.vf vf1 vf1 vf1 :mask #b1000)
    (.sub.vf vf2 vf2 vf2 :mask #b1000)
    (.sub.vf vf3 vf3 vf3 :mask #b1000)
    (.lvf vf8 (&-> arg1 trans quad))
    (.mul.x.vf acc vf1 vf8)
    (.add.mul.y.vf acc vf2 vf8 acc)
    (.add.mul.z.vf vf4 vf3 vf8 acc)
    (.sub.vf vf4 vf0 vf4)
    (.mov.vf vf4 vf0 :mask #b1000)
    (.svf (&-> arg0 vector 0 quad) vf1)
    (.svf (&-> arg0 vector 1 quad) vf2)
    (.svf (&-> arg0 vector 2 quad) vf3)
    (.svf (&-> arg0 trans quad) vf4)
    arg0
    )
  )

;; definition for function matrix-4x4-inverse!
;; ERROR: Bad vector register dependency: vf3
;; ERROR: Bad vector register dependency: vf4
;; ERROR: Bad vector register dependency: vf5
(defun matrix-4x4-inverse! ((arg0 matrix) (arg1 matrix))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf12 :class vf)
         (vf13 :class vf)
         (vf14 :class vf)
         (vf15 :class vf)
         (vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf2 :class vf)
         (vf20 :class vf)
         (vf23 :class vf)
         (vf24 :class vf)
         (vf25 :class vf)
         (vf26 :class vf)
         (vf27 :class vf)
         (vf28 :class vf)
         (vf29 :class vf)
         (vf3 :class vf)
         (vf30 :class vf)
         (vf31 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (nop!)
    (nop!)
    (.lvf vf23 (&-> arg1 vector 0 quad))
    (nop!)
    (.lvf vf24 (&-> arg1 vector 1 quad))
    (nop!)
    (.lvf vf25 (&-> arg1 vector 2 quad))
    (nop!)
    (.lvf vf1 (&-> arg1 trans quad))
    (.mul.x.vf vf7 vf24 vf23)
    (nop!)
    (.mul.y.vf vf8 vf24 vf23)
    (nop!)
    (.mul.z.vf vf9 vf24 vf23)
    (nop!)
    (.mul.x.vf vf10 vf25 vf23)
    (nop!)
    (.mul.y.vf vf11 vf25 vf23)
    (nop!)
    (.mul.z.vf vf12 vf25 vf23)
    (nop!)
    (.mul.x.vf vf13 vf25 vf24)
    (nop!)
    (.mul.y.vf vf14 vf25 vf24)
    (nop!)
    (.mul.z.vf vf15 vf25 vf24)
    (nop!)
    (.mul.z.vf vf26 vf7 vf25 :mask #b10)
    (nop!)
    (.mul.z.vf vf27 vf11 vf24 :mask #b1)
    (nop!)
    (.mul.y.vf vf28 vf9 vf25 :mask #b1)
    (nop!)
    (.mul.z.vf vf29 vf14 vf23 :mask #b1)
    (nop!)
    (.mul.z.vf vf30 vf8 vf25 :mask #b1)
    (nop!)
    (.mul.y.vf vf31 vf7 vf25 :mask #b100)
    (nop!)
    (.add.y.vf vf16 vf27 vf26 :mask #b1)
    (nop!)
    (.sub.vf vf1 vf0 vf1)
    (nop!)
    (.add.x.vf vf17 vf29 vf30 :mask #b1)
    (nop!)
    (.sub.z.vf vf18 vf28 vf31 :mask #b1)
    (nop!)
    (.sub.y.vf vf23 vf14 vf15 :mask #b100)
    (nop!)
    (.sub.z.vf vf26 vf15 vf13 :mask #b1)
    (nop!)
    (.sub.x.vf vf29 vf13 vf14 :mask #b10)
    (nop!)
    (.sub.vf vf19 vf16 vf17 :mask #b1)
    (nop!)
    (.sub.z.vf vf24 vf12 vf11 :mask #b10)
    (nop!)
    (.sub.x.vf vf27 vf10 vf12 :mask #b100)
    (nop!)
    (.sub.y.vf vf30 vf11 vf10 :mask #b1)
    (nop!)
    (.add.vf vf20 vf19 vf18 :mask #b1)
    (nop!)
    (.sub.y.vf vf25 vf8 vf9 :mask #b100)
    (nop!)
    (.sub.z.vf vf28 vf9 vf7 :mask #b1)
    (nop!)
    (.sub.x.vf vf31 vf7 vf8 :mask #b10)
    (nop!)
    (.div.vf Q vf0 vf20 :fsf #b11 :ftf #b0)
    (nop!)
    (.sub.w.vf vf3 vf3 vf3 :mask #b1000)
    (nop!)
    (.sub.w.vf vf4 vf4 vf4 :mask #b1000)
    (nop!)
    (.sub.w.vf vf5 vf5 vf5 :mask #b1000)
    (nop!)
    (.mov.vf vf6 vf0 :mask #b1000)
    (nop!)
    (.wait.vf)
    (nop!)
    (.add.vf vf2 vf0 Q :mask #b1)
    (nop!)
    (.add.x.vf vf2 vf0 vf2 :mask #b111)
    (nop!)
    (.mul.z.vf vf3 vf2 vf23 :mask #b1)
    (nop!)
    (.mul.x.vf vf4 vf2 vf26 :mask #b1)
    (nop!)
    (.mul.y.vf vf5 vf2 vf29 :mask #b1)
    (nop!)
    (.mul.y.vf vf3 vf2 vf24 :mask #b10)
    (nop!)
    (.mul.z.vf vf4 vf2 vf27 :mask #b10)
    (nop!)
    (.mul.x.vf vf5 vf2 vf30 :mask #b10)
    (nop!)
    (.mul.z.vf vf3 vf2 vf25 :mask #b100)
    (nop!)
    (.mul.x.vf vf4 vf2 vf28 :mask #b100)
    (nop!)
    (.mul.y.vf vf5 vf2 vf31 :mask #b100)
    (nop!)
    (.mul.x.vf acc vf3 vf1)
    (.svf (&-> arg0 vector 0 quad) vf3)
    (.add.mul.y.vf acc vf4 vf1 acc)
    (.svf (&-> arg0 vector 1 quad) vf4)
    (.add.mul.z.vf vf6 vf5 vf1 acc :mask #b111)
    (.svf (&-> arg0 vector 2 quad) vf5)
    (nop!)
    (.svf (&-> arg0 trans quad) vf6)
    arg0
    )
  )

;; definition for function matrix-translate!
(defun matrix-translate! ((arg0 matrix) (arg1 vector))
  (matrix-identity! arg0)
  (set! (-> arg0 trans x) (-> arg1 x))
  (set! (-> arg0 trans y) (-> arg1 y))
  (set! (-> arg0 trans z) (-> arg1 z))
  arg0
  )

;; definition for function matrix-translate+!
;; INFO: Used lq/sq
(defun matrix-translate+! ((arg0 matrix) (arg1 matrix) (arg2 vector))
  (set! (-> arg0 trans x) (+ (-> arg1 trans x) (-> arg2 x)))
  (set! (-> arg0 trans y) (+ (-> arg1 trans y) (-> arg2 y)))
  (set! (-> arg0 trans z) (+ (-> arg1 trans z) (-> arg2 z)))
  (when (!= arg0 arg1)
    (set! (-> arg0 vector 0 quad) (-> arg1 vector 0 quad))
    (set! (-> arg0 vector 1 quad) (-> arg1 vector 1 quad))
    (set! (-> arg0 vector 2 quad) (-> arg1 vector 2 quad))
    )
  arg0
  )

;; definition for function matrix-scale!
;; INFO: Used lq/sq
(defun matrix-scale! ((arg0 matrix) (arg1 vector))
  (set! (-> arg0 vector 0 quad) (the-as uint128 0))
  (set! (-> arg0 vector 1 quad) (the-as uint128 0))
  (set! (-> arg0 vector 2 quad) (the-as uint128 0))
  (set! (-> arg0 trans quad) (the-as uint128 0))
  (set! (-> arg0 data 0) (-> arg1 x))
  (set! (-> arg0 data 5) (-> arg1 y))
  (set! (-> arg0 data 10) (-> arg1 z))
  (set! (-> arg0 trans w) 1.0)
  arg0
  )

;; definition for function scale-matrix!
(defun scale-matrix! ((arg0 matrix) (arg1 vector) (arg2 matrix))
  (rlet ((vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         )
    (.lvf vf4 (&-> arg1 quad))
    (.lvf vf5 (&-> arg2 vector 0 quad))
    (.lvf vf6 (&-> arg2 vector 1 quad))
    (.lvf vf7 (&-> arg2 vector 2 quad))
    (.lvf vf8 (&-> arg2 trans quad))
    (.mul.x.vf vf5 vf5 vf4)
    (.mul.y.vf vf6 vf6 vf4)
    (.mul.z.vf vf7 vf7 vf4)
    (.mul.w.vf vf8 vf8 vf4)
    (.svf (&-> arg0 vector 0 quad) vf5)
    (.svf (&-> arg0 vector 1 quad) vf6)
    (.svf (&-> arg0 vector 2 quad) vf7)
    (.svf (&-> arg0 trans quad) vf8)
    arg0
    )
  )

;; definition for function matrix-inv-scale!
;; INFO: Used lq/sq
(defun matrix-inv-scale! ((arg0 matrix) (arg1 vector))
  (set! (-> arg0 vector 0 quad) (the-as uint128 0))
  (set! (-> arg0 vector 1 quad) (the-as uint128 0))
  (set! (-> arg0 vector 2 quad) (the-as uint128 0))
  (set! (-> arg0 trans quad) (the-as uint128 0))
  (set! (-> arg0 data 0) (/ 1.0 (-> arg1 x)))
  (set! (-> arg0 data 5) (/ 1.0 (-> arg1 y)))
  (set! (-> arg0 data 10) (/ 1.0 (-> arg1 z)))
  (set! (-> arg0 trans w) 1.0)
  arg0
  )

;; definition for function column-scale-matrix!
(defun column-scale-matrix! ((arg0 matrix) (arg1 vector) (arg2 matrix))
  (rlet ((vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         )
    (.lvf vf4 (&-> arg1 quad))
    (.lvf vf5 (&-> arg2 vector 0 quad))
    (.lvf vf6 (&-> arg2 vector 1 quad))
    (.lvf vf7 (&-> arg2 vector 2 quad))
    (.lvf vf8 (&-> arg2 trans quad))
    (.mul.vf vf5 vf5 vf4)
    (.mul.vf vf6 vf6 vf4)
    (.mul.vf vf7 vf7 vf4)
    (.mul.vf vf8 vf8 vf4)
    (.svf (&-> arg0 vector 0 quad) vf5)
    (.svf (&-> arg0 vector 1 quad) vf6)
    (.svf (&-> arg0 vector 2 quad) vf7)
    (.svf (&-> arg0 trans quad) vf8)
    arg0
    )
  )

;; definition for function matrix-rotate-x!
;; INFO: Used lq/sq
(defun matrix-rotate-x! ((arg0 matrix) (arg1 float))
  (let ((f30-0 (sin arg1))
        (f0-0 (cos arg1))
        )
    (set! (-> arg0 vector 0 quad) (the-as uint128 0))
    (set! (-> arg0 vector 1 quad) (the-as uint128 0))
    (set! (-> arg0 vector 2 quad) (the-as uint128 0))
    (set! (-> arg0 trans quad) (the-as uint128 0))
    (set! (-> arg0 data 0) 1.0)
    (set! (-> arg0 data 5) f0-0)
    (set! (-> arg0 data 6) f30-0)
    (set! (-> arg0 data 9) (- f30-0))
    (set! (-> arg0 data 10) f0-0)
    )
  (set! (-> arg0 trans w) 1.0)
  arg0
  )

;; definition for function matrix-rotate-y!
;; INFO: Used lq/sq
(defun matrix-rotate-y! ((arg0 matrix) (arg1 float))
  (let ((f30-0 (sin arg1))
        (f0-0 (cos arg1))
        )
    (set! (-> arg0 vector 0 quad) (the-as uint128 0))
    (set! (-> arg0 vector 1 quad) (the-as uint128 0))
    (set! (-> arg0 vector 2 quad) (the-as uint128 0))
    (set! (-> arg0 trans quad) (the-as uint128 0))
    (set! (-> arg0 data 0) f0-0)
    (set! (-> arg0 data 2) (- f30-0))
    (set! (-> arg0 data 5) 1.0)
    (set! (-> arg0 data 8) f30-0)
    (set! (-> arg0 data 10) f0-0)
    )
  (set! (-> arg0 trans w) 1.0)
  arg0
  )

;; definition for function matrix-rotate-z!
;; INFO: Used lq/sq
(defun matrix-rotate-z! ((arg0 matrix) (arg1 float))
  (let ((f30-0 (sin arg1))
        (f0-0 (cos arg1))
        )
    (set! (-> arg0 vector 0 quad) (the-as uint128 0))
    (set! (-> arg0 vector 1 quad) (the-as uint128 0))
    (set! (-> arg0 vector 2 quad) (the-as uint128 0))
    (set! (-> arg0 trans quad) (the-as uint128 0))
    (set! (-> arg0 data 0) f0-0)
    (set! (-> arg0 data 1) f30-0)
    (set! (-> arg0 data 4) (- f30-0))
    (set! (-> arg0 data 5) f0-0)
    )
  (set! (-> arg0 data 10) 1.0)
  (set! (-> arg0 trans w) 1.0)
  arg0
  )

;; definition for function matrix-rotate-zyx!
;; INFO: Used lq/sq
(defun matrix-rotate-zyx! ((arg0 matrix) (arg1 vector))
  (let ((gp-0 (new-stack-matrix0))
        (s5-0 (new-stack-matrix0))
        )
    (matrix-rotate-x! arg0 (-> arg1 x))
    (matrix-rotate-y! gp-0 (-> arg1 y))
    (matrix*! s5-0 gp-0 arg0)
    (matrix-rotate-z! gp-0 (-> arg1 z))
    (matrix*! arg0 gp-0 s5-0)
    )
  arg0
  )

;; definition (debug) for function matrix-rotate-xyz-2!
(defun-debug matrix-rotate-xyz-2! ((arg0 matrix) (arg1 vector))
  (let ((gp-0 (new 'stack-no-clear 'matrix))
        (s5-0 (new 'stack-no-clear 'matrix))
        )
    (matrix-rotate-z! arg0 (-> arg1 z))
    (matrix-rotate-y! gp-0 (-> arg1 y))
    (matrix*! s5-0 gp-0 arg0)
    (matrix-rotate-x! gp-0 (-> arg1 x))
    (matrix*! arg0 gp-0 s5-0)
    )
  arg0
  )

;; definition for function matrix-rotate-xyz!
(defun matrix-rotate-xyz! ((arg0 matrix) (arg1 vector))
  (rlet ((vf0 :class vf))
    (init-vf0-vector)
    (let ((s4-0 (new 'stack-no-clear 'vector))
          (s5-0 (new 'stack-no-clear 'vector))
          )
      (vector-sincos! s4-0 s5-0 arg1)
      (let ((f2-0 (-> s4-0 x))
            (f5-0 (-> s4-0 y))
            (f3-0 (-> s4-0 z))
            (f0-0 (-> s5-0 x))
            (f1-0 (-> s5-0 y))
            )
        (let ((f4-0 (-> s5-0 z)))
          (set! (-> arg0 data 0) (* f1-0 f4-0))
          (set! (-> arg0 data 1) (* f1-0 f3-0))
          (set! (-> arg0 data 2) (- f5-0))
          (set! (-> arg0 data 3) 0.0)
          (let ((f6-4 (* f2-0 f5-0))
                (f5-1 (* f0-0 f5-0))
                )
            (set! (-> arg0 data 4) (- (* f6-4 f4-0) (* f0-0 f3-0)))
            (set! (-> arg0 data 5) (+ (* f6-4 f3-0) (* f0-0 f4-0)))
            (set! (-> arg0 data 6) (* f2-0 f1-0))
            (set! (-> arg0 data 7) 0.0)
            (set! (-> arg0 data 8) (+ (* f2-0 f3-0) (* f5-1 f4-0)))
            (set! (-> arg0 data 9) (- (* f5-1 f3-0) (* f2-0 f4-0)))
            )
          )
        (set! (-> arg0 data 10) (* f0-0 f1-0))
        )
      )
    (set! (-> arg0 data 11) 0.0)
    (.svf (&-> arg0 trans quad) vf0)
    arg0
    )
  )

;; definition for function matrix-rotate-zxy!
;; INFO: Used lq/sq
(defun matrix-rotate-zxy! ((arg0 matrix) (arg1 vector))
  (let ((gp-0 (new-stack-matrix0))
        (s5-0 (new-stack-matrix0))
        )
    (matrix-rotate-y! arg0 (-> arg1 y))
    (matrix-rotate-x! gp-0 (-> arg1 x))
    (matrix*! s5-0 gp-0 arg0)
    (matrix-rotate-z! gp-0 (-> arg1 z))
    (matrix*! arg0 gp-0 s5-0)
    )
  arg0
  )

;; definition for function matrix-rotate-yxz!
;; INFO: Used lq/sq
(defun matrix-rotate-yxz! ((arg0 matrix) (arg1 vector))
  (let ((gp-0 (new-stack-matrix0))
        (s5-0 (new-stack-matrix0))
        )
    (matrix-rotate-z! arg0 (-> arg1 z))
    (matrix-rotate-x! gp-0 (-> arg1 x))
    (matrix*! s5-0 gp-0 arg0)
    (matrix-rotate-y! gp-0 (-> arg1 y))
    (matrix*! arg0 gp-0 s5-0)
    )
  arg0
  )

;; definition for function matrix-rotate-yzx!
;; INFO: Used lq/sq
(defun matrix-rotate-yzx! ((arg0 matrix) (arg1 vector))
  (let ((gp-0 (new-stack-matrix0))
        (s5-0 (new-stack-matrix0))
        )
    (matrix-rotate-z! arg0 (-> arg1 x))
    (matrix-rotate-x! gp-0 (-> arg1 z))
    (matrix*! s5-0 gp-0 arg0)
    (matrix-rotate-y! gp-0 (-> arg1 y))
    (matrix*! arg0 gp-0 s5-0)
    )
  arg0
  )

;; definition for function matrix-rotate-yxy!
(defun matrix-rotate-yxy! ((arg0 matrix) (arg1 vector))
  (let ((a2-0 (new 'stack-no-clear 'vector))
        (s5-0 (new 'stack-no-clear 'vector))
        (s4-0 (new 'stack-no-clear 'vector))
        )
    (set-vector! a2-0 (-> arg1 x) (- (-> arg1 y) (-> arg1 z)) (-> arg1 z) 1.0)
    (vector-sincos! s5-0 s4-0 a2-0)
    (let ((f1-1 (-> s4-0 y))
          (f0-5 (-> s5-0 y))
          (f2-0 (-> s4-0 x))
          (f5-0 (-> s5-0 x))
          (f3-0 (-> s4-0 z))
          (f4-0 (-> s5-0 z))
          )
      (set! (-> arg0 data 0) (- (* f1-1 f3-0) (* f0-5 f2-0 f4-0)))
      (set! (-> arg0 data 1) (* f0-5 f5-0))
      (set! (-> arg0 data 2) (- (+ (* f1-1 f4-0) (* f0-5 f2-0 f3-0))))
      (set! (-> arg0 data 3) 0.0)
      (set! (-> arg0 data 4) (* f5-0 f4-0))
      (set! (-> arg0 data 5) f2-0)
      (set! (-> arg0 data 6) (* f5-0 f3-0))
      (set! (-> arg0 data 7) 0.0)
      (set! (-> arg0 data 8) (+ (* f0-5 f3-0) (* f1-1 f2-0 f4-0)))
      (set! (-> arg0 data 9) (- (* f1-1 f5-0)))
      (set! (-> arg0 data 10) (- (* f1-1 f2-0 f3-0) (* f0-5 f4-0)))
      )
    )
  (set! (-> arg0 data 11) 0.0)
  (set! (-> arg0 trans x) 0.0)
  (set! (-> arg0 trans y) 0.0)
  (set! (-> arg0 trans z) 0.0)
  (set! (-> arg0 trans w) 1.0)
  arg0
  )

;; definition for function matrix-rotate-yx!
;; INFO: Used lq/sq
(defun matrix-rotate-yx! ((arg0 matrix) (arg1 float) (arg2 float))
  (matrix-rotate-y! arg0 arg1)
  (let ((a1-2 (matrix-rotate-x! (new-stack-matrix0) arg2)))
    (matrix*! arg0 a1-2 arg0)
    )
  arg0
  )

;; definition for function matrix-axis-sin-cos-vu!
;; INFO: Used lq/sq
;; INFO: Return type mismatch matrix vs none.
;; ERROR: Function may read a register that is not set: f31
;; ERROR: Unsupported inline assembly instruction kind - [prot3w a1, v1]
;; ERROR: Unsupported inline assembly instruction kind - [prot3w a2, a1]
(defun matrix-axis-sin-cos-vu! ((arg0 matrix) (arg1 vector) (arg2 float) (arg3 float))
  (local-vars
    (r0-0 int)
    (r0-1 int)
    (r0-2 int)
    (r0-3 int)
    (a1-2 uint128)
    (a2-1 uint128)
    (a3-1 uint128)
    (a3-2 uint128)
    (f31-0 none)
    )
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (nop!)
    (let* ((t0-0 #xffff)
           (v1-0 (-> arg1 quad))
           (a1-1 (shl t0-0 48))
           )
      (.mov vf6 arg3)
      (.pceqw a3-1 v1-0 0)
      (.mov r0-0 f31-0)
      (.ppach a3-2 (the-as uint128 0) a3-1)
      (.mov r0-1 f31-0)
      (nop!)
      (.mov vf1 v1-0)
      (let ((v1-1 (logior a3-2 a1-1)))
        (.mov vf5 arg2)
        (let ((v1-2 (+ v1-1 1)))
          (.sub.x.vf vf5 vf0 vf6 :mask #b1000)
          (b! (zero? v1-2) cfg-2 :delay (.add.x.vf vf5 vf0 vf6 :mask #b10))
          )
        )
      )
    (.sub.w.vf vf2 vf0 vf0 :mask #b1000)
    (nop!)
    (.sub.w.vf vf3 vf0 vf0 :mask #b1000)
    (nop!)
    (.sub.w.vf vf4 vf0 vf0 :mask #b1000)
    (nop!)
    (.mul.x.vf vf11 vf1 vf5 :mask #b111)
    (nop!)
    (.add.y.vf vf7 vf0 vf5 :mask #b1)
    (nop!)
    (.add.y.vf vf8 vf0 vf5 :mask #b10)
    (nop!)
    (.add.y.vf vf9 vf0 vf5 :mask #b100)
    (nop!)
    (.mul.w.vf vf10 vf1 vf5 :mask #b111)
    (nop!)
    (.sub.z.vf vf7 vf0 vf11 :mask #b10)
    (nop!)
    (.add.y.vf vf7 vf0 vf11 :mask #b100)
    (nop!)
    (.add.z.vf vf8 vf0 vf11 :mask #b1)
    (nop!)
    (.sub.x.vf vf8 vf0 vf11 :mask #b100)
    (nop!)
    (.mul.x.vf vf2 vf10 vf1 :mask #b111)
    (nop!)
    (.mul.y.vf vf3 vf10 vf1 :mask #b111)
    (nop!)
    (.mul.z.vf vf4 vf10 vf1 :mask #b111)
    (nop!)
    (.sub.y.vf vf9 vf0 vf11 :mask #b1)
    (nop!)
    (.add.x.vf vf9 vf0 vf11 :mask #b10)
    (nop!)
    (.add.vf vf2 vf2 vf7 :mask #b111)
    (nop!)
    (.add.vf vf3 vf3 vf8 :mask #b111)
    (nop!)
    (nop!)
    (nop!)
    (.add.vf vf4 vf4 vf9 :mask #b111)
    (nop!)
    (nop!)
    (.svf (&-> arg0 vector 0 quad) vf2)
    (nop!)
    (.svf (&-> arg0 vector 1 quad) vf3)
    (nop!)
    (.svf (&-> arg0 trans quad) vf0)
    (b! #t cfg-3 :delay (.svf (&-> arg0 vector 2 quad) vf4))
    (label cfg-2)
    (let ((v1-3 #x3f800000))
      (.svf (&-> arg0 trans quad) vf0)
      (let ((v1-4 (the-as uint128 (make-u128 0 v1-3))))
        (.mov r0-2 f31-0)
        (.prot3w a1-2 (the-as uint v1-4))
        (.mov r0-3 f31-0)
        (.prot3w a2-1 (the-as int a1-2))
        (set! (-> arg0 vector 0 quad) v1-4)
        )
      )
    (nop!)
    (set! (-> arg0 vector 2 quad) a1-2)
    (nop!)
    (set! (-> arg0 vector 1 quad) a2-1)
    (label cfg-3)
    (none)
    )
  )

;; definition for function matrix-axis-sin-cos!
;; INFO: Used lq/sq
;; ERROR: Function may read a register that is not set: f31
;; ERROR: Unsupported inline assembly instruction kind - [prot3w a0, v1]
;; ERROR: Unsupported inline assembly instruction kind - [prot3w a1, a0]
(defun matrix-axis-sin-cos! ((arg0 matrix) (arg1 vector) (arg2 float) (arg3 float))
  (local-vars
    (r0-0 int)
    (r0-1 int)
    (r0-2 int)
    (r0-3 int)
    (a0-4 uint128)
    (a1-2 uint128)
    (a1-3 uint128)
    (a1-4 uint128)
    (f31-0 none)
    )
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (let ((v0-0 arg0))
      (let ((v1-0 arg1)
            (f0-0 arg2)
            (f1-0 arg3)
            )
        (nop!)
        (let* ((a0-1 #xffff)
               (v1-1 (-> v1-0 quad))
               (a0-2 (shl a0-1 48))
               )
          (let ((a1-1 f1-0))
            (.mov vf6 a1-1)
            )
          (.pceqw a1-2 v1-1 0)
          (.mov r0-0 f31-0)
          (.ppach a1-3 (the-as uint128 0) a1-2)
          (.mov r0-1 f31-0)
          (nop!)
          (.mov vf1 v1-1)
          (let ((v1-2 (logior a1-3 a0-2)))
            (let ((a0-3 f0-0))
              (.mov vf5 a0-3)
              )
            (let ((v1-3 (+ v1-2 1)))
              (.sub.x.vf vf5 vf0 vf6 :mask #b1000)
              (b! (zero? v1-3) cfg-2 :delay (.add.x.vf vf5 vf0 vf6 :mask #b10))
              )
            )
          )
        )
      (.sub.w.vf vf2 vf0 vf0 :mask #b1000)
      (nop!)
      (.sub.w.vf vf3 vf0 vf0 :mask #b1000)
      (nop!)
      (.sub.w.vf vf4 vf0 vf0 :mask #b1000)
      (nop!)
      (.mul.x.vf vf11 vf1 vf5 :mask #b111)
      (nop!)
      (.add.y.vf vf7 vf0 vf5 :mask #b1)
      (nop!)
      (.add.y.vf vf8 vf0 vf5 :mask #b10)
      (nop!)
      (.add.y.vf vf9 vf0 vf5 :mask #b100)
      (nop!)
      (.mul.w.vf vf10 vf1 vf5 :mask #b111)
      (nop!)
      (.sub.z.vf vf7 vf0 vf11 :mask #b10)
      (nop!)
      (.add.y.vf vf7 vf0 vf11 :mask #b100)
      (nop!)
      (.add.z.vf vf8 vf0 vf11 :mask #b1)
      (nop!)
      (.sub.x.vf vf8 vf0 vf11 :mask #b100)
      (nop!)
      (.mul.x.vf vf2 vf10 vf1 :mask #b111)
      (nop!)
      (.mul.y.vf vf3 vf10 vf1 :mask #b111)
      (nop!)
      (.mul.z.vf vf4 vf10 vf1 :mask #b111)
      (nop!)
      (.sub.y.vf vf9 vf0 vf11 :mask #b1)
      (nop!)
      (.add.x.vf vf9 vf0 vf11 :mask #b10)
      (nop!)
      (.add.vf vf2 vf2 vf7 :mask #b111)
      (nop!)
      (.add.vf vf3 vf3 vf8 :mask #b111)
      (nop!)
      (nop!)
      (nop!)
      (.add.vf vf4 vf4 vf9 :mask #b111)
      (nop!)
      (nop!)
      (.svf (&-> v0-0 vector 0 quad) vf2)
      (nop!)
      (.svf (&-> v0-0 vector 1 quad) vf3)
      (nop!)
      (.svf (&-> v0-0 trans quad) vf0)
      (b! #t cfg-3 :delay (.svf (&-> v0-0 vector 2 quad) vf4))
      (label cfg-2)
      (let ((v1-4 #x3f800000))
        (.svf (&-> v0-0 trans quad) vf0)
        (let ((v1-5 (the-as uint128 (make-u128 0 v1-4))))
          (.mov r0-2 f31-0)
          (.prot3w a0-4 (the-as uint v1-5))
          (.mov r0-3 f31-0)
          (.prot3w a1-4 (the-as int a0-4))
          (set! (-> v0-0 vector 0 quad) v1-5)
          )
        )
      (nop!)
      (set! (-> v0-0 vector 2 quad) a0-4)
      (nop!)
      (set! (-> v0-0 vector 1 quad) a1-4)
      (label cfg-3)
      v0-0
      )
    )
  )

;; definition for function matrix-axis-angle!
;; INFO: Return type mismatch matrix vs none.
(defun matrix-axis-angle! ((arg0 matrix) (arg1 vector) (arg2 float))
  (matrix-axis-sin-cos! arg0 arg1 (sin arg2) (cos arg2))
  (none)
  )

;; definition for function matrix-lerp!
(defun matrix-lerp! ((arg0 matrix) (arg1 matrix) (arg2 matrix) (arg3 float))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (.mov vf9 arg3)
    (.lvf vf1 (&-> arg1 vector 0 quad))
    (.lvf vf2 (&-> arg1 vector 1 quad))
    (.lvf vf3 (&-> arg1 vector 2 quad))
    (.lvf vf4 (&-> arg1 trans quad))
    (.lvf vf5 (&-> arg2 vector 0 quad))
    (.lvf vf6 (&-> arg2 vector 1 quad))
    (.lvf vf7 (&-> arg2 vector 2 quad))
    (.lvf vf8 (&-> arg2 trans quad))
    (.sub.vf vf5 vf5 vf1)
    (.sub.vf vf6 vf6 vf2)
    (.sub.vf vf7 vf7 vf3)
    (.sub.vf vf8 vf8 vf4)
    (.mul.x.vf vf5 vf5 vf9)
    (.mul.x.vf vf6 vf6 vf9)
    (.mul.x.vf vf7 vf7 vf9)
    (.mul.x.vf vf8 vf8 vf9)
    (.add.vf vf1 vf1 vf5)
    (.add.vf vf2 vf2 vf6)
    (.add.vf vf3 vf3 vf7)
    (.add.vf vf4 vf4 vf8)
    (.svf (&-> arg0 vector 0 quad) vf1)
    (.svf (&-> arg0 vector 1 quad) vf2)
    (.svf (&-> arg0 vector 2 quad) vf3)
    (.svf (&-> arg0 trans quad) vf4)
    arg0
    )
  )

;; definition for function matrix-3x3-determinant
(defun matrix-3x3-determinant ((arg0 matrix))
  (let ((f8-0 (-> arg0 data 0))
        (f1-0 (-> arg0 data 1))
        (f4-0 (-> arg0 data 2))
        (f2-0 (-> arg0 data 4))
        (f5-0 (-> arg0 data 5))
        (f9-0 (-> arg0 data 6))
        (f3-0 (-> arg0 data 8))
        (f6-0 (-> arg0 data 9))
        (f0-0 (-> arg0 data 10))
        )
    (- (+ (* f8-0 f5-0 f0-0) (* f1-0 f9-0 f3-0) (* f4-0 f2-0 f6-0))
       (+ (* f8-0 f9-0 f6-0) (* f4-0 f5-0 f3-0) (* f1-0 f2-0 f0-0))
       )
    )
  )

;; definition for function matrix3-determinant
(defun matrix3-determinant ((arg0 matrix))
  (local-vars (v0-0 float))
  (rlet ((acc :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf12 :class vf)
         (vf13 :class vf)
         )
    (.lvf vf11 (&-> arg0 vector 1 quad))
    (.lvf vf12 (&-> arg0 vector 2 quad))
    (.lvf vf10 (&-> arg0 vector 0 quad))
    (.outer.product.a.vf acc vf11 vf12)
    (.outer.product.b.vf vf13 vf12 vf11 acc)
    (.mul.vf vf13 vf13 vf10 :mask #b111)
    (.add.y.vf vf13 vf13 vf13 :mask #b1)
    (.add.z.vf vf13 vf13 vf13 :mask #b1)
    (.mov v0-0 vf13)
    v0-0
    )
  )

;; definition for function matrix-3x3-inverse!
(defun matrix-3x3-inverse! ((arg0 matrix) (arg1 matrix))
  (let ((f0-0 (matrix-3x3-determinant arg1)))
    (set! (-> arg0 data 0)
          (/ (- (* (-> arg1 data 5) (-> arg1 data 10)) (* (-> arg1 data 6) (-> arg1 data 9))) f0-0)
          )
    (set! (-> arg0 data 4)
          (/ (- (* (-> arg1 data 6) (-> arg1 data 8)) (* (-> arg1 data 4) (-> arg1 data 10))) f0-0)
          )
    (set! (-> arg0 data 8)
          (/ (- (* (-> arg1 data 4) (-> arg1 data 9)) (* (-> arg1 data 5) (-> arg1 data 8))) f0-0)
          )
    (set! (-> arg0 data 1)
          (/ (- (* (-> arg1 data 9) (-> arg1 data 2)) (* (-> arg1 data 10) (-> arg1 data 1))) f0-0)
          )
    (set! (-> arg0 data 5)
          (/ (- (* (-> arg1 data 10) (-> arg1 data 0)) (* (-> arg1 data 8) (-> arg1 data 2))) f0-0)
          )
    (set! (-> arg0 data 9)
          (/ (- (* (-> arg1 data 8) (-> arg1 data 1)) (* (-> arg1 data 9) (-> arg1 data 0))) f0-0)
          )
    (set! (-> arg0 data 2)
          (/ (- (* (-> arg1 data 1) (-> arg1 data 6)) (* (-> arg1 data 2) (-> arg1 data 5))) f0-0)
          )
    (set! (-> arg0 data 6)
          (/ (- (* (-> arg1 data 2) (-> arg1 data 4)) (* (-> arg1 data 0) (-> arg1 data 6))) f0-0)
          )
    (set! (-> arg0 data 10)
          (/ (- (* (-> arg1 data 0) (-> arg1 data 5)) (* (-> arg1 data 1) (-> arg1 data 4))) f0-0)
          )
    )
  arg0
  )

;; definition for function matrix-3x3-inverse-transpose!
(defun matrix-3x3-inverse-transpose! ((arg0 matrix) (arg1 matrix))
  (let ((f0-0 (matrix-3x3-determinant arg1)))
    (set! (-> arg0 data 0)
          (/ (- (* (-> arg1 data 5) (-> arg1 data 10)) (* (-> arg1 data 6) (-> arg1 data 9))) f0-0)
          )
    (set! (-> arg0 data 1)
          (/ (- (* (-> arg1 data 6) (-> arg1 data 8)) (* (-> arg1 data 4) (-> arg1 data 10))) f0-0)
          )
    (set! (-> arg0 data 2)
          (/ (- (* (-> arg1 data 4) (-> arg1 data 9)) (* (-> arg1 data 5) (-> arg1 data 8))) f0-0)
          )
    (set! (-> arg0 data 4)
          (/ (- (* (-> arg1 data 9) (-> arg1 data 2)) (* (-> arg1 data 10) (-> arg1 data 1))) f0-0)
          )
    (set! (-> arg0 data 5)
          (/ (- (* (-> arg1 data 10) (-> arg1 data 0)) (* (-> arg1 data 8) (-> arg1 data 2))) f0-0)
          )
    (set! (-> arg0 data 6)
          (/ (- (* (-> arg1 data 8) (-> arg1 data 1)) (* (-> arg1 data 9) (-> arg1 data 0))) f0-0)
          )
    (set! (-> arg0 data 8)
          (/ (- (* (-> arg1 data 1) (-> arg1 data 6)) (* (-> arg1 data 2) (-> arg1 data 5))) f0-0)
          )
    (set! (-> arg0 data 9)
          (/ (- (* (-> arg1 data 2) (-> arg1 data 4)) (* (-> arg1 data 0) (-> arg1 data 6))) f0-0)
          )
    (set! (-> arg0 data 10)
          (/ (- (* (-> arg1 data 0) (-> arg1 data 5)) (* (-> arg1 data 1) (-> arg1 data 4))) f0-0)
          )
    )
  arg0
  )

;; definition for function matrix3-inverse-transpose!
(defun matrix3-inverse-transpose! ((arg0 matrix) (arg1 matrix))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf12 :class vf)
         (vf13 :class vf)
         (vf14 :class vf)
         (vf15 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf10 (&-> arg1 vector 0 quad))
    (.lvf vf11 (&-> arg1 vector 1 quad))
    (.lvf vf12 (&-> arg1 vector 2 quad))
    (.outer.product.a.vf acc vf11 vf12)
    (.outer.product.b.vf vf13 vf12 vf11 acc)
    (.outer.product.a.vf acc vf12 vf10)
    (.outer.product.b.vf vf14 vf10 vf12 acc)
    (.mul.vf vf1 vf10 vf13 :mask #b111)
    (.outer.product.a.vf acc vf10 vf11)
    (.outer.product.b.vf vf15 vf11 vf10 acc)
    (.nop.vf)
    (.add.y.vf vf1 vf1 vf1 :mask #b1)
    (.nop.vf)
    (.nop.vf)
    (.nop.vf)
    (.add.z.vf vf1 vf1 vf1 :mask #b1)
    (.nop.vf)
    (.nop.vf)
    (.nop.vf)
    (.div.vf Q vf0 vf1 :fsf #b11 :ftf #b0)
    (.wait.vf)
    (.mul.vf vf13 vf13 Q)
    (.mul.vf vf14 vf14 Q)
    (.mul.vf vf15 vf15 Q)
    (.nop.vf)
    (.nop.vf)
    (.svf (&-> arg0 vector 0 quad) vf13)
    (.svf (&-> arg0 vector 1 quad) vf14)
    (.svf (&-> arg0 vector 2 quad) vf15)
    arg0
    )
  )

;; definition for function matrix-3x3-normalize!
;; ERROR: Unsupported inline assembly instruction kind - [mula.s f2, f2]
;; ERROR: Unsupported inline assembly instruction kind - [madda.s f0, f0]
;; ERROR: Unsupported inline assembly instruction kind - [madd.s f0, f1, f1]
;; ERROR: Unsupported inline assembly instruction kind - [rsqrt.s f0, f2, f0]
(defun matrix-3x3-normalize! ((arg0 matrix) (arg1 matrix))
  (local-vars (f0-1 float) (f0-2 float))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf12 :class vf)
         (vf13 :class vf)
         (vf14 :class vf)
         (vf15 :class vf)
         (vf16 :class vf)
         )
    (init-vf0-vector)
    (let ((f2-0 (-> arg1 data 0))
          (f0-0 (-> arg1 data 1))
          (f1-0 (-> arg1 data 2))
          (v1-0 #x3f800000)
          )
      (.lvf vf10 (&-> arg1 vector 0 quad))
      (.mula.s f2-0 f2-0)
      (.lvf vf11 (&-> arg1 vector 1 quad))
      (let ((f2-1 (gpr->fpr v1-0)))
        (.lvf vf12 (&-> arg1 vector 2 quad))
        (.madda.s f0-0 f0-0)
        (.sub.w.vf vf13 vf0 vf0 :mask #b1000)
        (.madd.s f0-1 f1-0 f1-0)
        (.sub.w.vf vf14 vf0 vf0 :mask #b1000)
        (.rsqrt.s f0-2 f2-1 f0-1)
        )
      )
    (.sub.w.vf vf15 vf0 vf0 :mask #b1000)
    (let ((v1-1 f0-2))
      (.mov vf16 v1-1)
      )
    (.mul.x.vf vf13 vf10 vf16 :mask #b111)
    (.outer.product.a.vf acc vf11 vf13)
    (.outer.product.b.vf vf14 vf13 vf11 acc)
    (.outer.product.a.vf acc vf13 vf14)
    (.outer.product.b.vf vf14 vf14 vf13 acc)
    (.mul.vf vf16 vf14 vf14 :mask #b111)
    (.mul.x.vf acc vf0 vf16 :mask #b1000)
    (.add.mul.y.vf acc vf0 vf16 acc :mask #b1000)
    (.add.mul.z.vf vf16 vf0 vf16 acc :mask #b1000)
    (.isqrt.vf Q vf0 vf16 :fsf #b11 :ftf #b11)
    (.wait.vf)
    (.mul.vf vf14 vf14 Q :mask #b111)
    (.outer.product.a.vf acc vf13 vf14)
    (.outer.product.b.vf vf15 vf14 vf13 acc)
    (.svf (&-> arg0 vector 0 quad) vf13)
    (.svf (&-> arg0 vector 1 quad) vf14)
    (.svf (&-> arg0 vector 2 quad) vf15)
    arg0
    )
  )

;; definition for function matrix-4x4-determinant
(defun matrix-4x4-determinant ((arg0 matrix))
  (let ((f15-0 (-> arg0 data 0))
        (f14-0 (-> arg0 data 1))
        (f10-0 (-> arg0 data 2))
        (f2-0 (-> arg0 data 3))
        (f9-0 (-> arg0 data 4))
        (f6-0 (-> arg0 data 5))
        (f3-0 (-> arg0 data 6))
        (f11-0 (-> arg0 data 7))
        (f5-0 (-> arg0 data 8))
        (f1-0 (-> arg0 data 9))
        (f8-0 (-> arg0 data 10))
        (f13-0 (-> arg0 data 11))
        (f0-0 (-> arg0 trans x))
        (f7-0 (-> arg0 trans y))
        (f4-0 (-> arg0 trans z))
        (f12-0 (-> arg0 trans w))
        )
    (- (+ (* f15-0 f6-0 f8-0 f12-0)
          (* f15-0 f3-0 f13-0 f7-0)
          (* f15-0 f11-0 f1-0 f4-0)
          (* f14-0 f9-0 f13-0 f4-0)
          (* f14-0 f3-0 f5-0 f4-0)
          (* f14-0 f11-0 f8-0 f0-0)
          (* f10-0 f9-0 f1-0 f12-0)
          (* f10-0 f6-0 f13-0 f0-0)
          (* f10-0 f11-0 f5-0 f7-0)
          (* f2-0 f9-0 f1-0 f4-0)
          (* f2-0 f6-0 f8-0 f0-0)
          (* f2-0 f3-0 f5-0 f7-0)
          )
       (+ (* f15-0 f6-0 f13-0 f4-0)
          (* f15-0 f3-0 f1-0 f12-0)
          (* f15-0 f11-0 f8-0 f7-0)
          (* f14-0 f9-0 f8-0 f12-0)
          (* f14-0 f3-0 f13-0 f0-0)
          (* f14-0 f11-0 f5-0 f4-0)
          (* f10-0 f9-0 f13-0 f7-0)
          (* f10-0 f6-0 f5-0 f12-0)
          (* f10-0 f11-0 f1-0 f0-0)
          (* f2-0 f9-0 f8-0 f7-0)
          (* f2-0 f6-0 f5-0 f4-0)
          (* f2-0 f3-0 f1-0 f0-0)
          )
       )
    )
  )

;; definition for function matrix-4x4-inverse-transpose!
(defun matrix-4x4-inverse-transpose! ((arg0 matrix) (arg1 matrix))
  (let ((f0-0 (matrix-4x4-determinant arg1)))
    (let ((f9-0 (-> arg1 data 5))
          (f2-0 (-> arg1 data 6))
          (f5-0 (-> arg1 data 7))
          (f3-0 (-> arg1 data 9))
          (f6-0 (-> arg1 data 10))
          (f10-0 (-> arg1 data 11))
          (f4-0 (-> arg1 trans y))
          (f7-0 (-> arg1 trans z))
          (f1-0 (-> arg1 trans w))
          )
      (set! (-> arg0 data 0) (/ (- (+ (* f9-0 f6-0 f1-0) (* f2-0 f10-0 f4-0) (* f5-0 f3-0 f7-0))
                                   (+ (* f9-0 f10-0 f7-0) (* f5-0 f6-0 f4-0) (* f2-0 f3-0 f1-0))
                                   )
                                f0-0
                                )
            )
      )
    (let ((f9-2 (-> arg1 data 4))
          (f2-2 (-> arg1 data 6))
          (f5-2 (-> arg1 data 7))
          (f3-1 (-> arg1 data 8))
          (f6-1 (-> arg1 data 10))
          (f10-1 (-> arg1 data 11))
          (f4-3 (-> arg1 trans x))
          (f7-2 (-> arg1 trans z))
          (f1-6 (-> arg1 trans w))
          )
      (set! (-> arg0 data 1) (- (/ (- (+ (* f9-2 f6-1 f1-6) (* f2-2 f10-1 f4-3) (* f5-2 f3-1 f7-2))
                                      (+ (* f9-2 f10-1 f7-2) (* f5-2 f6-1 f4-3) (* f2-2 f3-1 f1-6))
                                      )
                                   f0-0
                                   )
                                )
            )
      )
    (let ((f9-4 (-> arg1 data 4))
          (f2-4 (-> arg1 data 5))
          (f5-4 (-> arg1 data 7))
          (f3-2 (-> arg1 data 8))
          (f6-2 (-> arg1 data 9))
          (f10-2 (-> arg1 data 11))
          (f4-6 (-> arg1 trans x))
          (f7-4 (-> arg1 trans y))
          (f1-13 (-> arg1 trans w))
          )
      (set! (-> arg0 data 2) (/ (- (+ (* f9-4 f6-2 f1-13) (* f2-4 f10-2 f4-6) (* f5-4 f3-2 f7-4))
                                   (+ (* f9-4 f10-2 f7-4) (* f5-4 f6-2 f4-6) (* f2-4 f3-2 f1-13))
                                   )
                                f0-0
                                )
            )
      )
    (let ((f9-6 (-> arg1 data 4))
          (f2-6 (-> arg1 data 5))
          (f5-6 (-> arg1 data 6))
          (f3-3 (-> arg1 data 8))
          (f6-3 (-> arg1 data 9))
          (f10-3 (-> arg1 data 10))
          (f4-9 (-> arg1 trans x))
          (f7-6 (-> arg1 trans y))
          (f1-19 (-> arg1 trans z))
          )
      (set! (-> arg0 data 3) (- (/ (- (+ (* f9-6 f6-3 f1-19) (* f2-6 f10-3 f4-9) (* f5-6 f3-3 f7-6))
                                      (+ (* f9-6 f10-3 f7-6) (* f5-6 f6-3 f4-9) (* f2-6 f3-3 f1-19))
                                      )
                                   f0-0
                                   )
                                )
            )
      )
    (let ((f9-8 (-> arg1 data 1))
          (f2-8 (-> arg1 data 2))
          (f5-8 (-> arg1 data 3))
          (f3-4 (-> arg1 data 9))
          (f6-4 (-> arg1 data 10))
          (f10-4 (-> arg1 data 11))
          (f4-12 (-> arg1 trans y))
          (f7-8 (-> arg1 trans z))
          (f1-26 (-> arg1 trans w))
          )
      (set! (-> arg0 data 4) (- (/ (- (+ (* f9-8 f6-4 f1-26) (* f2-8 f10-4 f4-12) (* f5-8 f3-4 f7-8))
                                      (+ (* f9-8 f10-4 f7-8) (* f5-8 f6-4 f4-12) (* f2-8 f3-4 f1-26))
                                      )
                                   f0-0
                                   )
                                )
            )
      )
    (let ((f9-10 (-> arg1 data 0))
          (f2-10 (-> arg1 data 2))
          (f5-10 (-> arg1 data 3))
          (f3-5 (-> arg1 data 8))
          (f6-5 (-> arg1 data 10))
          (f10-5 (-> arg1 data 11))
          (f4-15 (-> arg1 trans x))
          (f7-10 (-> arg1 trans z))
          (f1-33 (-> arg1 trans w))
          )
      (set! (-> arg0 data 5) (/ (- (+ (* f9-10 f6-5 f1-33) (* f2-10 f10-5 f4-15) (* f5-10 f3-5 f7-10))
                                   (+ (* f9-10 f10-5 f7-10) (* f5-10 f6-5 f4-15) (* f2-10 f3-5 f1-33))
                                   )
                                f0-0
                                )
            )
      )
    (let ((f9-12 (-> arg1 data 0))
          (f2-12 (-> arg1 data 1))
          (f5-12 (-> arg1 data 3))
          (f3-6 (-> arg1 data 8))
          (f6-6 (-> arg1 data 9))
          (f10-6 (-> arg1 data 11))
          (f4-18 (-> arg1 trans x))
          (f7-12 (-> arg1 trans y))
          (f1-39 (-> arg1 trans w))
          )
      (set! (-> arg0 data 6) (- (/ (- (+ (* f9-12 f6-6 f1-39) (* f2-12 f10-6 f4-18) (* f5-12 f3-6 f7-12))
                                      (+ (* f9-12 f10-6 f7-12) (* f5-12 f6-6 f4-18) (* f2-12 f3-6 f1-39))
                                      )
                                   f0-0
                                   )
                                )
            )
      )
    (let ((f9-14 (-> arg1 data 0))
          (f2-14 (-> arg1 data 1))
          (f5-14 (-> arg1 data 2))
          (f3-7 (-> arg1 data 8))
          (f6-7 (-> arg1 data 9))
          (f10-7 (-> arg1 data 10))
          (f4-21 (-> arg1 trans x))
          (f7-14 (-> arg1 trans y))
          (f1-46 (-> arg1 trans z))
          )
      (set! (-> arg0 data 7) (/ (- (+ (* f9-14 f6-7 f1-46) (* f2-14 f10-7 f4-21) (* f5-14 f3-7 f7-14))
                                   (+ (* f9-14 f10-7 f7-14) (* f5-14 f6-7 f4-21) (* f2-14 f3-7 f1-46))
                                   )
                                f0-0
                                )
            )
      )
    (let ((f9-16 (-> arg1 data 1))
          (f2-16 (-> arg1 data 2))
          (f5-16 (-> arg1 data 3))
          (f3-8 (-> arg1 data 5))
          (f6-8 (-> arg1 data 6))
          (f10-8 (-> arg1 data 7))
          (f4-24 (-> arg1 trans y))
          (f7-16 (-> arg1 trans z))
          (f1-52 (-> arg1 trans w))
          )
      (set! (-> arg0 data 8) (/ (- (+ (* f9-16 f6-8 f1-52) (* f2-16 f10-8 f4-24) (* f5-16 f3-8 f7-16))
                                   (+ (* f9-16 f10-8 f7-16) (* f5-16 f6-8 f4-24) (* f2-16 f3-8 f1-52))
                                   )
                                f0-0
                                )
            )
      )
    (let ((f9-18 (-> arg1 data 0))
          (f2-18 (-> arg1 data 2))
          (f5-18 (-> arg1 data 3))
          (f3-9 (-> arg1 data 4))
          (f6-9 (-> arg1 data 6))
          (f10-9 (-> arg1 data 7))
          (f4-27 (-> arg1 trans x))
          (f7-18 (-> arg1 trans z))
          (f1-58 (-> arg1 trans w))
          )
      (set! (-> arg0 data 9) (- (/ (- (+ (* f9-18 f6-9 f1-58) (* f2-18 f10-9 f4-27) (* f5-18 f3-9 f7-18))
                                      (+ (* f9-18 f10-9 f7-18) (* f5-18 f6-9 f4-27) (* f2-18 f3-9 f1-58))
                                      )
                                   f0-0
                                   )
                                )
            )
      )
    (let ((f9-20 (-> arg1 data 0))
          (f2-20 (-> arg1 data 1))
          (f5-20 (-> arg1 data 3))
          (f3-10 (-> arg1 data 4))
          (f6-10 (-> arg1 data 5))
          (f10-10 (-> arg1 data 7))
          (f4-30 (-> arg1 trans x))
          (f7-20 (-> arg1 trans y))
          (f1-65 (-> arg1 trans w))
          )
      (set! (-> arg0 data 10) (/ (- (+ (* f9-20 f6-10 f1-65) (* f2-20 f10-10 f4-30) (* f5-20 f3-10 f7-20))
                                    (+ (* f9-20 f10-10 f7-20) (* f5-20 f6-10 f4-30) (* f2-20 f3-10 f1-65))
                                    )
                                 f0-0
                                 )
            )
      )
    (let ((f9-22 (-> arg1 data 0))
          (f2-22 (-> arg1 data 1))
          (f5-22 (-> arg1 data 2))
          (f3-11 (-> arg1 data 4))
          (f6-11 (-> arg1 data 5))
          (f10-11 (-> arg1 data 6))
          (f4-33 (-> arg1 trans x))
          (f7-22 (-> arg1 trans y))
          (f1-71 (-> arg1 trans z))
          )
      (set! (-> arg0 data 11) (- (/ (- (+ (* f9-22 f6-11 f1-71) (* f2-22 f10-11 f4-33) (* f5-22 f3-11 f7-22))
                                       (+ (* f9-22 f10-11 f7-22) (* f5-22 f6-11 f4-33) (* f2-22 f3-11 f1-71))
                                       )
                                    f0-0
                                    )
                                 )
            )
      )
    (let ((f9-24 (-> arg1 data 1))
          (f2-24 (-> arg1 data 2))
          (f5-24 (-> arg1 data 3))
          (f3-12 (-> arg1 data 5))
          (f6-12 (-> arg1 data 6))
          (f10-12 (-> arg1 data 7))
          (f4-36 (-> arg1 data 9))
          (f7-24 (-> arg1 data 10))
          (f1-78 (-> arg1 data 11))
          )
      (set! (-> arg0 trans x) (- (/ (- (+ (* f9-24 f6-12 f1-78) (* f2-24 f10-12 f4-36) (* f5-24 f3-12 f7-24))
                                       (+ (* f9-24 f10-12 f7-24) (* f5-24 f6-12 f4-36) (* f2-24 f3-12 f1-78))
                                       )
                                    f0-0
                                    )
                                 )
            )
      )
    (let ((f9-26 (-> arg1 data 0))
          (f2-26 (-> arg1 data 2))
          (f5-26 (-> arg1 data 3))
          (f3-13 (-> arg1 data 4))
          (f6-13 (-> arg1 data 6))
          (f10-13 (-> arg1 data 7))
          (f4-39 (-> arg1 data 8))
          (f7-26 (-> arg1 data 10))
          (f1-85 (-> arg1 data 11))
          )
      (set! (-> arg0 trans y) (/ (- (+ (* f9-26 f6-13 f1-85) (* f2-26 f10-13 f4-39) (* f5-26 f3-13 f7-26))
                                    (+ (* f9-26 f10-13 f7-26) (* f5-26 f6-13 f4-39) (* f2-26 f3-13 f1-85))
                                    )
                                 f0-0
                                 )
            )
      )
    (let ((f9-28 (-> arg1 data 0))
          (f2-28 (-> arg1 data 1))
          (f5-28 (-> arg1 data 3))
          (f3-14 (-> arg1 data 4))
          (f6-14 (-> arg1 data 5))
          (f10-14 (-> arg1 data 7))
          (f4-42 (-> arg1 data 8))
          (f7-28 (-> arg1 data 9))
          (f1-91 (-> arg1 data 11))
          )
      (set! (-> arg0 trans z) (- (/ (- (+ (* f9-28 f6-14 f1-91) (* f2-28 f10-14 f4-42) (* f5-28 f3-14 f7-28))
                                       (+ (* f9-28 f10-14 f7-28) (* f5-28 f6-14 f4-42) (* f2-28 f3-14 f1-91))
                                       )
                                    f0-0
                                    )
                                 )
            )
      )
    (let ((f8-60 (-> arg1 data 0))
          (f1-98 (-> arg1 data 1))
          (f5-30 (-> arg1 data 2))
          (f2-30 (-> arg1 data 4))
          (f6-15 (-> arg1 data 5))
          (f9-30 (-> arg1 data 6))
          (f4-45 (-> arg1 data 8))
          (f7-30 (-> arg1 data 9))
          (f3-15 (-> arg1 data 10))
          )
      (set! (-> arg0 trans w) (/ (- (+ (* f8-60 f6-15 f3-15) (* f1-98 f9-30 f4-45) (* f5-30 f2-30 f7-30))
                                    (+ (* f8-60 f9-30 f7-30) (* f5-30 f6-15 f4-45) (* f1-98 f2-30 f3-15))
                                    )
                                 f0-0
                                 )
            )
      )
    )
  arg0
  )

;; definition for function matrix-y-angle
(defun matrix-y-angle ((arg0 matrix))
  (let ((v1-0 (&-> arg0 data 8)))
    (atan (-> v1-0 0) (-> v1-0 2))
    )
  )

;; definition for function matrix->trans
(defun matrix->trans ((arg0 matrix) (arg1 vector))
  (rlet ((Q :class vf)
         (vf0 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf2 (&-> arg0 trans quad))
    (.div.vf Q vf0 vf2 :fsf #b11 :ftf #b11)
    (.wait.vf)
    (.mul.vf vf2 vf2 Q :mask #b111)
    (.nop.vf)
    (.nop.vf)
    (.mov.vf vf2 vf0 :mask #b1000)
    (.svf (&-> arg1 quad) vf2)
    arg1
    )
  )

;; definition for function matrix<-trans
;; INFO: Used lq/sq
(defun matrix<-trans ((arg0 matrix) (arg1 vector))
  (set! (-> arg0 trans quad) (-> arg1 quad))
  arg0
  )

;; definition for function matrix->scale
(defun matrix->scale ((arg0 matrix) (arg1 vector))
  (set! (-> arg1 x) (vector-length (the-as vector (-> arg0 data))))
  (set! (-> arg1 y) (vector-length (the-as vector (&-> arg0 data 4))))
  (set! (-> arg1 z) (vector-length (the-as vector (&-> arg0 data 8))))
  (set! (-> arg1 w) 1.0)
  arg1
  )

;; definition for function matrix<-scale
(defun matrix<-scale ((arg0 matrix) (arg1 vector))
  (vector-normalize! (the-as vector (-> arg0 data)) (-> arg1 x))
  (vector-normalize! (the-as vector (&-> arg0 data 4)) (-> arg1 y))
  (vector-normalize! (the-as vector (&-> arg0 data 8)) (-> arg1 z))
  arg0
  )

;; definition for function matrix->quat
;; INFO: Used lq/sq
(defun matrix->quat ((arg0 matrix) (arg1 quaternion))
  (let ((s5-0 (new 'stack-no-clear 'matrix)))
    (let* ((a2-0 arg0)
           (v1-0 (-> a2-0 vector 0 quad))
           (a0-1 (-> a2-0 vector 1 quad))
           (a1-1 (-> a2-0 vector 2 quad))
           (a2-1 (-> a2-0 trans quad))
           )
      (set! (-> s5-0 vector 0 quad) v1-0)
      (set! (-> s5-0 vector 1 quad) a0-1)
      (set! (-> s5-0 vector 2 quad) a1-1)
      (set! (-> s5-0 trans quad) a2-1)
      )
    (vector-reset! (-> s5-0 trans))
    (vector-normalize! (the-as vector (-> s5-0 data)) 1.0)
    (vector-normalize! (the-as vector (&-> s5-0 data 4)) 1.0)
    (vector-normalize! (the-as vector (&-> s5-0 data 8)) 1.0)
    (matrix->quaternion arg1 s5-0)
    )
  )

;; definition for function matrix<-quat
(defun matrix<-quat ((arg0 matrix) (arg1 quaternion))
  (let ((s5-0 (matrix->scale arg0 (new 'stack-no-clear 'vector)))
        (s4-1 (quaternion->matrix (new 'stack-no-clear 'matrix) arg1))
        )
    (vector-normalize-copy! (the-as vector (-> arg0 data)) (the-as vector (-> s4-1 data)) (-> s5-0 x))
    (vector-normalize-copy! (the-as vector (&-> arg0 data 4)) (the-as vector (&-> s4-1 data 4)) (-> s5-0 y))
    (vector-normalize-copy! (the-as vector (&-> arg0 data 8)) (the-as vector (&-> s4-1 data 8)) (-> s5-0 z))
    )
  (set! (-> arg0 data 3) 0.0)
  (set! (-> arg0 data 7) 0.0)
  (set! (-> arg0 data 11) 0.0)
  arg0
  )

;; definition for function matrix->transformq
;; INFO: Used lq/sq
(defun matrix->transformq ((arg0 transformq) (arg1 matrix))
  (rlet ((Q :class vf)
         (vf0 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf2 (&-> arg1 trans quad))
    (.div.vf Q vf0 vf2 :fsf #b11 :ftf #b11)
    (.wait.vf)
    (.mul.vf vf2 vf2 Q :mask #b111)
    (.nop.vf)
    (.nop.vf)
    (.mov.vf vf2 vf0 :mask #b1000)
    (.svf (&-> arg0 trans quad) vf2)
    (let ((s4-0 (new 'stack-no-clear 'matrix)))
      (let* ((a2-0 arg1)
             (v1-0 (-> a2-0 vector 0 quad))
             (a0-1 (-> a2-0 vector 1 quad))
             (a1-1 (-> a2-0 vector 2 quad))
             (a2-1 (-> a2-0 trans quad))
             )
        (set! (-> s4-0 vector 0 quad) v1-0)
        (set! (-> s4-0 vector 1 quad) a0-1)
        (set! (-> s4-0 vector 2 quad) a1-1)
        (set! (-> s4-0 trans quad) a2-1)
        )
      (vector-normalize! (the-as vector (-> s4-0 data)) 1.0)
      (vector-normalize! (the-as vector (&-> s4-0 data 4)) 1.0)
      (vector-normalize! (the-as vector (&-> s4-0 data 8)) 1.0)
      (vector-cross!
        (the-as vector (&-> s4-0 data 8))
        (the-as vector (-> s4-0 data))
        (the-as vector (&-> s4-0 data 4))
        )
      (vector-cross!
        (the-as vector (&-> s4-0 data 4))
        (the-as vector (&-> s4-0 data 8))
        (the-as vector (-> s4-0 data))
        )
      (matrix->quaternion (-> arg0 quat) s4-0)
      )
    (set-vector!
      (-> arg0 scale)
      (vector-length (the-as vector (-> arg1 data)))
      (vector-length (the-as vector (&-> arg1 data 4)))
      (vector-length (the-as vector (&-> arg1 data 8)))
      1.0
      )
    arg0
    )
  )

;; definition for method 9 of type matrix
;; ERROR: function was not converted to expressions. Cannot decompile.

;; definition for function matrix-mirror!
(defun matrix-mirror! ((arg0 matrix) (arg1 vector) (arg2 vector))
  (let ((f10-0 -2.0)
        (f0-0 1.0)
        )
    (let* ((f1-0 0.0)
           (f9-0 (-> arg2 x))
           (f12-0 (-> arg2 y))
           (f11-0 (-> arg2 z))
           (f6-0 (-> arg1 x))
           (f5-0 (-> arg1 y))
           (f2-0 (-> arg1 z))
           (f3-2 (+ f0-0 (* f10-0 f9-0 f9-0)))
           (f4-2 (+ f0-0 (* f10-0 f12-0 f12-0)))
           (f7-2 (+ f0-0 (* f10-0 f11-0 f11-0)))
           (f8-1 (* f10-0 f9-0 f12-0))
           (f9-2 (* f10-0 f9-0 f11-0))
           (f10-2 (* f10-0 f12-0 f11-0))
           (f11-4 (- f6-0 (+ (* f6-0 f3-2) (* f5-0 f8-1) (* f2-0 f9-2))))
           (f12-6 (- f5-0 (+ (* f6-0 f8-1) (* f5-0 f4-2) (* f2-0 f10-2))))
           (f2-1 (- f2-0 (+ (* f6-0 f9-2) (* f5-0 f10-2) (* f2-0 f7-2))))
           )
      (set! (-> arg0 data 0) f3-2)
      (set! (-> arg0 data 1) f8-1)
      (set! (-> arg0 data 2) f9-2)
      (set! (-> arg0 data 3) f1-0)
      (set! (-> arg0 data 4) f8-1)
      (set! (-> arg0 data 5) f4-2)
      (set! (-> arg0 data 6) f10-2)
      (set! (-> arg0 data 7) f1-0)
      (set! (-> arg0 data 8) f9-2)
      (set! (-> arg0 data 9) f10-2)
      (set! (-> arg0 data 10) f7-2)
      (set! (-> arg0 data 11) f1-0)
      (set! (-> arg0 trans x) f11-4)
      (set! (-> arg0 trans y) f12-6)
      (set! (-> arg0 trans z) f2-1)
      )
    (set! (-> arg0 trans w) f0-0)
    )
  arg0
  )
