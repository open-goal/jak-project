;;-*-Lisp-*-
(in-package goal)

;; definition for function target-darkjak-setup
;; WARN: Return type mismatch int vs none.
(defbehavior target-darkjak-setup target ((arg0 symbol))
  (when (zero? (-> self darkjak))
    (set! (-> self darkjak) (new 'process 'darkjak-info))
    (set! (-> self darkjak process) (the-as (pointer target) (process->ppointer self)))
    (let* ((v1-4 (-> self game))
           (a0-5 (+ (-> v1-4 attack-id) 1))
           )
      (set! (-> v1-4 attack-id) a0-5)
      (set! (-> self darkjak attack-id) a0-5)
      )
    (set! (-> self darkjak hud 0) (the-as handle #f))
    (set! (-> self darkjak tone) (new-sound-id))
    (set! (-> self darkjak-giant-interp) 1.0)
    )
  0
  (none)
  )

;; definition for function want-to-darkjak?
(defbehavior want-to-darkjak? target ()
  (and (cpad-pressed? (-> self control cpad number) l2)
       (not *pause-lock*)
       (-> *setting-control* user-current darkjak)
       (logtest? (-> self game features) (game-feature darkjak))
       (not (focus-test?
              self
              dead
              hit
              grabbed
              in-head
              under-water
              edge-grab
              pole
              flut
              tube
              board
              pilot
              mech
              carry
              indax
              teleporting
              )
            )
       (not (and (logtest? (-> self water flags) (water-flags under-water))
                 (not (logtest? (-> self water flags) (water-flags swim-ground)))
                 )
            )
       (or (and (not (and (focus-test? self dark) (nonzero? (-> self darkjak))))
                (and (time-elapsed? (-> (the-as fact-info-target (-> self fact)) darkjak-start-time) (seconds 0.05))
                     (>= (-> self game eco-pill-dark) (-> *FACT-bank* eco-pill-dark-max-default))
                     )
                )
           (and (and (focus-test? self dark) (nonzero? (-> self darkjak)))
                (not (and (focus-test? self dark)
                          (nonzero? (-> self darkjak))
                          (logtest? (-> self darkjak stage) (darkjak-stage giant))
                          )
                     )
                (logtest? (game-feature darkjak-giant) (-> self game features))
                )
           )
       )
  )

;; failed to figure out what this is:
(let ((v1-3 (copy *walk-mods* 'global)))
  (set! (-> v1-3 name) 'darkjak)
  (set! (-> v1-3 flags) (surface-flag gun-off))
  (set! *darkjak-trans-mods* v1-3)
  )

;; definition for function target-darkjak-end-mode
;; WARN: Return type mismatch int vs none.
(defbehavior target-darkjak-end-mode target ()
  (when (and (focus-test? self dark) (nonzero? (-> self darkjak)))
    (logclear! (-> self focus-status) (focus-status dark))
    (send-event self 'reset-collide)
    (logclear! (-> self state-flags) (state-flags sf4))
    (remove-setting! 'sound-flava)
    (remove-setting! 'string-min-length)
    (remove-setting! 'string-max-length)
    (remove-setting! 'string-spline-max-move)
    (remove-setting! 'string-spline-accel)
    (remove-setting! 'string-spline-max-move-player)
    (remove-setting! 'string-spline-accel-player)
    (sound-stop (-> self darkjak tone))
    )
  0
  (none)
  )

;; definition for function target-darkjak-process
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defbehavior target-darkjak-process target ()
  (local-vars (gp-0 vector))
  (cond
    ((and (focus-test? self dark) (nonzero? (-> self darkjak)))
     (let ((a1-0 'eco-red))
       (target-danger-set! (-> self control danger-mode) a1-0)
       )
     (update-transforms (-> self control))
     (let ((a1-1 (new 'stack-no-clear 'overlaps-others-params)))
       (set! (-> a1-1 options) (overlaps-others-options))
       (set! (-> a1-1 collide-with-filter) (the-as collide-spec -1))
       (set! (-> a1-1 tlist) *touching-list*)
       (find-overlapping-shapes (-> self control) a1-1)
       )
     (target-danger-set! (-> self control danger-mode) #f)
     (update-transforms (-> self control))
     (if (and (or (time-elapsed?
                    (-> (the-as fact-info-target (-> self fact)) darkjak-start-time)
                    (-> (the-as fact-info-target (-> self fact)) darkjak-effect-time)
                    )
                  (not (-> *setting-control* user-current darkjak))
                  )
              (not (focus-test? self dead dangerous hit grabbed))
              (not (and (-> self next-state) (= (-> self next-state name) 'target-darkjak-get-off)))
              (not (logtest? (-> self darkjak stage) (darkjak-stage force-on)))
              )
         (go target-darkjak-get-off)
         )
     )
    (else
      (seek! (-> self darkjak-interp) 0.0 (* 2.0 (seconds-per-frame)))
      (if (= (-> self darkjak-interp) 0.0)
          (set! (-> self darkjak-giant-interp) 1.0)
          )
      )
    )
  (let ((f30-0 (-> self darkjak-interp)))
    (let ((f28-0 (lerp-scale 1.0 (* 1.05 (-> self darkjak-giant-interp)) f30-0 0.0 1.0))
          (f26-0 (lerp-scale 1.0 (* 0.20000002 (+ 5.0 (-> self darkjak-giant-interp))) f30-0 0.0 1.0))
          )
      (set-vector! (-> self control scale) f28-0 f28-0 f28-0 1.0)
      (let ((a3-2 (new 'stack-no-clear 'vector)))
        (set! (-> a3-2 x) f26-0)
        (set! (-> a3-2 y) 1.0)
        (set! (-> a3-2 z) f26-0)
        (set! (-> a3-2 w) 1.0)
        (trs-set! (-> self upper-body) (the-as vector #f) (the-as quaternion #f) a3-2)
        )
      (let ((f26-1 (* 1.1 f26-0)))
        (cond
          ((and (focus-test? self dark)
                (nonzero? (-> self darkjak))
                (logtest? (-> self darkjak stage) (darkjak-stage giant))
                )
           (set! gp-0 (new 'stack-no-clear 'vector))
           (set! (-> gp-0 x) (/ f28-0 (* f28-0 f26-1 (lerp-scale 1.0 1.3 f30-0 0.0 1.0))))
           (set! (-> gp-0 y) (/ f28-0 (* f28-0 (lerp-scale 1.0 1.4 f30-0 0.0 1.0))))
           (set! (-> gp-0 z) (/ f28-0 (* f28-0 f26-1 (lerp-scale 1.0 1.3 f30-0 0.0 1.0))))
           (set! (-> gp-0 w) 1.0)
           )
          (else
            (set! gp-0 (new 'stack-no-clear 'vector))
            (set! (-> gp-0 x) (/ f28-0 (* f28-0 f26-1)))
            (set! (-> gp-0 y) (/ f28-0 f28-0))
            (set! (-> gp-0 z) (/ f28-0 (* f28-0 f26-1)))
            (set! (-> gp-0 w) 1.0)
            )
          )
        )
      )
    (cond
      ((logtest? (game-secrets little-head) (-> self game secrets))
       (dotimes (v1-56 3)
         (set! (-> gp-0 data v1-56) (* 0.4 (-> gp-0 data v1-56)))
         )
       )
      ((logtest? (game-secrets big-head) (-> self game secrets))
       (dotimes (v1-62 3)
         (set! (-> gp-0 data v1-62) (* 2.0 (-> gp-0 data v1-62)))
         )
       )
      )
    (trs-set! (-> self neck) (the-as vector #f) (the-as quaternion #f) gp-0)
    (let* ((a0-43 (-> self horns))
           (t9-14 (method-of-object a0-43 trs-set!))
           (a1-11 #f)
           (a2-8 #f)
           (a3-7 (new 'stack-no-clear 'vector))
           )
      (set! (-> a3-7 x) f30-0)
      (set! (-> a3-7 y) f30-0)
      (set! (-> a3-7 z) f30-0)
      (set! (-> a3-7 w) 1.0)
      (t9-14 a0-43 (the-as vector a1-11) (the-as quaternion a2-8) a3-7)
      )
    (set-darkjak-texture-morph! f30-0)
    (cond
      ((and (= f30-0 0.0) (not (time-elapsed? (-> self teleport-time) (seconds 0.5))))
       (set! (-> self skel override 0) 0.00001)
       (set! (-> self skel override 41) 0.000001)
       )
      ((= f30-0 0.0)
       (set! (-> self skel override 0) 0.0)
       (set! (-> self skel override 41) 0.0)
       )
      (else
        (set! (-> self skel override 0) 1.0)
        (set! (-> self skel override 1) f30-0)
        (set! (-> self skel override 2) f30-0)
        (set! (-> self skel override 3) f30-0)
        (set! (-> self skel override 4) f30-0)
        (set! (-> self skel override 5) f30-0)
        (set! (-> self skel override 41) 1.0)
        (set! (-> self skel override 46) 2.0)
        (set! (-> self skel override 52) 2.0)
        )
      )
    (when (and (>= f30-0 0.5)
               (not (focus-test? self in-head))
               (not (logtest? (-> self draw status) (draw-control-status no-draw no-draw-temp)))
               (not (movie?))
               )
      (launch-particles
        (-> *part-id-table* 178)
        (process-drawable-random-point! self (new 'stack-no-clear 'vector))
        )
      (cond
        ((rand-vu-percent? 0.25)
         (when (>= (- (-> *display* game-clock frame-counter) (-> self shock-effect-time)) (seconds 0.02))
           (set! (-> self shock-effect-time) (-> *display* game-clock frame-counter))
           (process-drawable-shock-wall-effect
             self
             (-> *lightning-spec-id-table* 8)
             lightning-probe-callback
             (-> *part-id-table* 179)
             )
           )
         )
        ((rand-vu-percent? 0.1)
         (when (>= (- (-> *display* game-clock frame-counter) (-> self shock-effect-time)) (seconds 0.02))
           (set! (-> self shock-effect-time) (-> *display* game-clock frame-counter))
           (process-drawable-shock-effect
             self
             (-> *lightning-spec-id-table* 6)
             lightning-probe-callback
             (-> *part-id-table* 179)
             0
             0
             40960.0
             )
           )
         )
        )
      )
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate target-darkjak-get-on (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('darkjak)
       (when (zero? (-> self darkjak want-stage))
         (set! (-> self darkjak want-stage) (the-as darkjak-stage (-> block param 0)))
         #t
         )
       )
      (else
        (target-generic-event-handler proc argc message block)
        )
      )
    )
  :exit (behavior ()
    (logclear! (-> self state-flags) (state-flags lleg-still rleg-still))
    (set! (-> self darkjak-interp) 1.0)
    (remove-setting! 'bg-r)
    (remove-setting! 'bg-g)
    (remove-setting! 'bg-b)
    (remove-setting! 'bg-a)
    (persist-with-delay *setting-control* 'bg-a-speed (seconds 3) 'bg-a-speed 'abs 0.5 0)
    (if (not (and (-> self next-state) (= (-> self next-state name) 'target-darkjak-get-off)))
        (pickup-collectable!
          (-> self fact)
          (pickup-type eco-pill-dark)
          (- (-> *FACT-bank* eco-pill-dark-max-default))
          (the-as handle #f)
          )
        )
    )
  :code (behavior ((arg0 darkjak-stage))
    (send-event (handle->process (-> self notify)) 'notify 'attack 15)
    (if (and (focus-test? self dark) (nonzero? (-> self darkjak)))
        (go target-darkjak-giant)
        )
    (set! (-> self darkjak stage) (logior arg0 (darkjak-stage active)))
    (if (logtest? (game-feature darkjak-bomb0) (-> self game features))
        (logior! (-> self darkjak stage) (darkjak-stage bomb0))
        )
    (if (logtest? (game-feature darkjak-bomb1) (-> self game features))
        (logior! (-> self darkjak stage) (darkjak-stage bomb1))
        )
    (if (logtest? (game-feature darkjak-invinc) (-> self game features))
        (logior! (-> self darkjak stage) (darkjak-stage invinc))
        )
    (set! (-> self darkjak want-stage) (-> self darkjak stage))
    (set! (-> self neck flex-blend) 0.0)
    (set! (-> self control mod-surface) *darkjak-trans-mods*)
    (set-time! (-> self darkjak start-time))
    (set! (-> self darkjak attack-count) (the-as uint 0))
    (set! (-> self darkjak-giant-interp) 1.0)
    (set-setting! 'sound-flava #f 30.0 4)
    (logior! (-> self focus-status) (focus-status dark))
    (set-time! (-> (the-as fact-info-target (-> self fact)) darkjak-start-time))
    (set! (-> (the-as fact-info-target (-> self fact)) darkjak-effect-time) (seconds 20))
    (if (logtest? (-> self darkjak stage) (darkjak-stage invinc))
        (logior! (-> self state-flags) (state-flags sf4))
        (logclear! (-> self state-flags) (state-flags sf4))
        )
    (if (logtest? arg0 (darkjak-stage no-anim))
        (go target-stance)
        )
    (set-setting! 'bg-r 'abs 0.1 0)
    (set-setting! 'bg-b 'abs 0.1 0)
    (set-forward-vel 0.0)
    (let ((s5-0 0))
      (while (not (logtest? (-> self control status) (collide-status on-surface)))
        (target-falling-anim-trans)
        (+! s5-0 (- (current-time) (-> self clock old-frame-counter)))
        (if (>= s5-0 300)
            (go target-falling #f)
            )
        (suspend)
        )
      )
    (let ((s5-2 (sound-play "djak-transform")))
      (cond
        ((task-node-open? (game-task-node city-help-kid-battle))
         (ja-channel-push! 1 (seconds 0.1))
         (ja-no-eval :group! jakb-darkjak-get-on-ja :num! (seek!) :frame-num 0.0)
         (until (ja-done? 0)
           (set! (-> self darkjak-interp) (lerp-scale 0.0 1.0 (ja-aframe-num 0) 10.0 25.0))
           (set-setting! 'bg-a 'abs (* 0.45 (-> self darkjak-interp)) 0)
           (suspend)
           (ja :num! (seek!))
           )
         )
        (else
          (ja-channel-push! 1 (seconds 0.1))
          (ja-no-eval :group! jakb-darkjak-get-on-fast-ja :num! (seek! (ja-aframe 17.0 0)) :frame-num 0.0)
          (until (ja-done? 0)
            (set! (-> self darkjak-interp) (lerp-scale 0.0 1.0 (ja-aframe-num 0) 5.0 15.0))
            (set-setting! 'bg-a 'abs (* 0.45 (-> self darkjak-interp)) 0)
            (when (and (or (not (cpad-hold? (-> self control cpad number) l2))
                           (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control cpad number) r2))
                           )
                       (and (< (ja-aframe-num 0) 5.0) (not (logtest? arg0 (darkjak-stage force-on))))
                       )
              (let ((v1-131 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
                (set! (-> v1-131 command) (sound-command set-param))
                (set! (-> v1-131 id) s5-2)
                (set! (-> v1-131 params volume) -4)
                (set! (-> v1-131 auto-time) 24)
                (set! (-> v1-131 auto-from) 2)
                (set! (-> v1-131 params mask) (the-as uint 17))
                (-> v1-131 id)
                )
              (go target-darkjak-get-off)
              )
            (suspend)
            (ja :num! (seek! (ja-aframe 17.0 0)))
            )
          )
        )
      )
    (send-event
      *traffic-manager*
      'increase-alert-level
      (if (and (focus-test? self dark)
               (nonzero? (-> self darkjak))
               (logtest? (-> self darkjak stage) (darkjak-stage invinc))
               )
          3
          2
          )
      )
    (go target-stance)
    )
  :post (-> target-grab post)
  )

;; failed to figure out what this is:
(defstate target-darkjak-get-off (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('pole-grab 'darkjak 'slide 'wade 'launch 'edge-grab)
       #f
       )
      (('change-mode)
       (case (-> block param 0)
         (('grab)
          (when (not (focus-test? self dead))
            (if (not (-> block param 1))
                #t
                (go target-grab 'stance)
                )
            )
          )
         )
       )
      (else
        (target-generic-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (logior! (-> self state-flags) (state-flags lleg-still rleg-still))
    (set! (-> self neck flex-blend) 0.0)
    (set! (-> self control mod-surface) *darkjak-trans-mods*)
    (kill-persister *setting-control* (the-as engine-pers 'bg-a-speed) 'bg-a-speed)
    (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-1 from) (process->ppointer self))
      (set! (-> a1-1 num-params) 1)
      (set! (-> a1-1 message) 'target)
      (set! (-> a1-1 param 0) (the-as uint 'normal))
      (let ((t9-1 send-event-function)
            (v1-12 (-> *game-info* sub-task-list (game-task-node city-help-kid-introduction)))
            )
        (t9-1
          (handle->process (if (-> v1-12 info)
                               (-> v1-12 info manager)
                               (the-as handle #f)
                               )
                           )
          a1-1
          )
        )
      )
    )
  :exit (behavior ()
    (logclear! (-> self state-flags) (state-flags lleg-still rleg-still))
    (target-darkjak-end-mode)
    )
  :trans (-> target-darkjak-get-on trans)
  :code (behavior ()
    (let ((v1-1 (-> self water flags)))
      (cond
        ((and (logtest? (water-flags touch-water) v1-1)
              (logtest? (water-flags under-water swimming) v1-1)
              (not (logtest? (focus-status mech) (-> self focus-status)))
              )
         (go target-swim-stance)
         )
        ((let ((v1-10 (ja-group)))
           (not (and v1-10 (= v1-10 jakb-darkjak-get-on-fast-ja)))
           )
         (let ((gp-0 0))
           (while (not (logtest? (-> self control status) (collide-status on-surface)))
             (target-falling-anim-trans)
             (+! gp-0 (- (current-time) (-> self clock old-frame-counter)))
             (if (>= gp-0 300)
                 (go target-falling #f)
                 )
             (suspend)
             )
           )
         )
        )
      )
    (cond
      ((logtest? (-> self control status) (collide-status on-water))
       )
      (else
        (let ((v1-30 (ja-group)))
          (cond
            ((and v1-30 (= v1-30 jakb-darkjak-get-on-fast-ja))
             (ja-no-eval :num! (seek! 0.0))
             (while (not (ja-done? 0))
               (seek! (-> self darkjak-interp) 0.0 (* 2.0 (seconds-per-frame)))
               (suspend)
               (ja-eval)
               )
             (ja-channel-push! 1 (seconds 0.1))
             )
            ((let ((v1-43 (ja-group)))
               (and v1-43 (or (= v1-43 jakb-darkjak-bomb-pre-ja)
                              (= v1-43 jakb-darkjak-bomb-ja)
                              (= v1-43 jakb-darkjak-bomb-loop-ja)
                              (= v1-43 jakb-darkjak-bomb-land-ja)
                              )
                    )
               )
             (ja-no-eval :group! jakb-darkjak-bomb-end-ja :num! (seek!) :frame-num 0.0)
             (until (ja-done? 0)
               (set! (-> self darkjak-interp) (lerp-scale 1.0 0.0 (ja-aframe-num 0) 90.0 115.0))
               (if (and (!= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
                        (or (not (and (focus-test? self dark)
                                      (nonzero? (-> self darkjak))
                                      (logtest? (-> self darkjak stage) (darkjak-stage giant))
                                      )
                                 )
                            (= (-> self darkjak-interp) 0.0)
                            )
                        )
                   (goto cfg-133)
                   )
               (suspend)
               (ja :num! (seek!))
               )
             )
            ((let ((v1-88 (ja-group)))
               (and v1-88 (= v1-88 jakb-darkjak-bomb-end-ja))
               )
             (ja-no-eval :num! (seek!))
             (while (not (ja-done? 0))
               (set! (-> self darkjak-interp) (lerp-scale 1.0 0.0 (ja-aframe-num 0) 90.0 115.0))
               (if (and (!= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
                        (or (not (and (focus-test? self dark)
                                      (nonzero? (-> self darkjak))
                                      (logtest? (-> self darkjak stage) (darkjak-stage giant))
                                      )
                                 )
                            (= (-> self darkjak-interp) 0.0)
                            )
                        )
                   (goto cfg-133)
                   )
               (suspend)
               (ja-eval)
               )
             )
            (else
              (ja-channel-push! 1 (seconds 0.05))
              (ja-no-eval :group! jakb-darkjak-get-off-ja :num! (seek!) :frame-num 0.0)
              (until (ja-done? 0)
                (set! (-> self darkjak-interp) (lerp-scale 1.0 0.0 (ja-aframe-num 0) 10.0 60.0))
                (if (and (>= (ja-aframe-num 0) 24.0)
                         (!= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
                         (or (not (and (focus-test? self dark)
                                       (nonzero? (-> self darkjak))
                                       (logtest? (-> self darkjak stage) (darkjak-stage giant))
                                       )
                                  )
                             (= (-> self darkjak-interp) 0.0)
                             )
                         )
                    (goto cfg-133)
                    )
                (suspend)
                (ja :num! (seek!))
                )
              (ja-no-eval :group! jakb-darkjak-get-off-end-ja :num! (seek!) :frame-num 0.0)
              (until (ja-done? 0)
                (set! (-> self darkjak-interp) (lerp-scale 1.0 0.0 (ja-aframe-num 0) 10.0 60.0))
                (if (and (>= (ja-aframe-num 0) 24.0)
                         (!= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
                         (or (not (and (focus-test? self dark)
                                       (nonzero? (-> self darkjak))
                                       (logtest? (-> self darkjak stage) (darkjak-stage giant))
                                       )
                                  )
                             (= (-> self darkjak-interp) 0.0)
                             )
                         )
                    (goto cfg-133)
                    )
                (suspend)
                (ja :num! (seek!))
                )
              )
            )
          )
        )
      )
    (label cfg-133)
    (vector-reset! (-> self control transv))
    ((-> target-darkjak-get-off exit))
    (go target-stance)
    )
  :post (-> target-grab post)
  )

;; failed to figure out what this is:
(defstate target-darkjak-running-attack (target)
  :event (-> target-running-attack event)
  :enter (-> target-running-attack enter)
  :exit (behavior ()
    (remove-setting! 'rapid-tracking)
    ((-> target-running-attack exit))
    )
  :trans (-> target-running-attack trans)
  :code (behavior ()
    (local-vars
      (sv-16 float)
      (sv-20 float)
      (sv-24 int)
      (sv-32 int)
      (sv-40 int)
      (sv-48 float)
      (sv-56 handle)
      (sv-64 int)
      )
    (set-setting! 'rapid-tracking #f 0.0 0)
    ((lambda :behavior target
       ()
       (set! (-> self control bend-target) (* 0.5 (-> self control bend-target)))
       (if (logtest? (water-flags touch-water) (-> self water flags))
           (sound-play "swim-stroke")
           )
       (set! (-> self control dynam gravity-max) 368640.0)
       (set! (-> self control dynam gravity-length) 368640.0)
       (let ((gp-1 (cond
                     ((zero? (-> self control unknown-word000))
                      (set! (-> self control unknown-word000) 1)
                      jakb-darkjak-attack-combo1-ja
                      )
                     (else
                       (set! (-> self control unknown-word000) 0)
                       jakb-darkjak-attack-combo1b-ja
                       )
                     )
                   )
             )
         (ja-channel-push! 1 (seconds 0.02))
         (ja-no-eval :group! gp-1 :num! (seek!))
         )
       (target-start-attack)
       (target-danger-set! 'punch #f)
       (let ((a0-8 (-> self control impact-ctrl))
             (t9-6 (method-of-type impact-control initialize))
             (a1-4 self)
             (v1-33 (ja-group))
             )
         (t9-6
           a0-8
           a1-4
           (if (and v1-33 (= v1-33 jakb-darkjak-attack-combo1-ja))
               22
               18
               )
           3276.8
           (-> self control root-prim prim-core collide-with)
           )
         )
       )
     )
    (set! sv-16 (the-as float 0.0))
    (set! sv-20 1.0)
    (set! sv-24 0)
    (set! sv-32 0)
    (set! sv-40 0)
    (set! sv-48 1.0)
    (set! sv-56 (the-as handle #f))
    (set! sv-64 0)
    (until (ja-done? 0)
      (if (and (cpad-pressed? (-> self control cpad number) square)
               (not (logtest? (-> self state-flags) (state-flags prevent-jump prevent-attack)))
               (not (logtest? (-> self control current-surface flags) (surface-flag no-attack)))
               (and (focus-test? self dark)
                    (nonzero? (-> self darkjak))
                    (logtest? (-> self darkjak stage) (darkjak-stage active))
                    )
               (< sv-32 2)
               )
          (set! sv-40 (the-as int (current-time)))
          )
      (when (time-elapsed? (the-as time-frame sv-40) (seconds 0.5))
        (set! sv-40 0)
        0
        )
      (if (and (nonzero? sv-40)
               (< (- (the float (+ (-> (ja-group) frames num-frames) -1)) (/ 2.0 (-> (ja-group) artist-step)))
                  (ja-frame-num 0)
                  )
               )
          ((lambda :behavior target
             ((arg0 (pointer float)) (arg1 (pointer uint64)) (arg2 (pointer uint64)))
             (let ((s4-0 (the-as process-focusable (combo-tracker-method-13
                                                     (-> self control unknown-combo-tracker00)
                                                     (-> self control send-attack-dest)
                                                     (-> self control trans)
                                                     24576.0
                                                     (-> self control c-R-w vector 2)
                                                     65536.0
                                                     )
                                 )
                         )
                   )
               (when #t
                 (+! (-> arg1 0) 1)
                 (if s4-0
                     (combo-tracker-method-12
                       (-> self control unknown-combo-tracker00)
                       (-> self control trans)
                       (get-trans s4-0 3)
                       s4-0
                       (current-time)
                       )
                     )
                 (target-start-attack)
                 (target-danger-set! 'punch #f)
                 (let ((v1-18 (ja-group)))
                   (cond
                     ((and v1-18 (or (= v1-18 jakb-darkjak-attack-combo1-ja) (= v1-18 jakb-darkjak-attack-combo1b-ja)))
                      (ja-channel-push! 1 (seconds 0.1))
                      (ja-no-eval :group! jakb-darkjak-attack-combo2-ja :num! (seek!))
                      )
                     (else
                       (ja-channel-push! 1 (seconds 0.1))
                       (ja-no-eval :group! jakb-darkjak-attack-combo3c-ja :num! (seek!))
                       )
                     )
                   )
                 (initialize (-> self control impact-ctrl) self 22 3276.8 (-> self control root-prim prim-core collide-with))
                 (set! (-> arg0 0) (fmax 0.0 (-> arg0 0)))
                 )
               )
             (set! (-> arg2 0) (the-as uint 0))
             0
             (none)
             )
           (& sv-16)
           (the-as (pointer uint64) (& sv-32))
           (the-as (pointer uint64) (& sv-40))
           )
          )
      (compute-alignment! (-> self align))
      (when (not (ja-min? 0))
        (cond
          ((and (>= (ja-frame-num 0) 20.0)
                (and (and (not (logtest? (-> self control status) (collide-status on-surface)))
                          (time-elapsed? (-> self control last-time-on-surface) (the-as time-frame (-> *TARGET-bank* ground-timeout)))
                          (>= 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                          (>= (target-height-above-ground) (-> *TARGET-bank* fall-height))
                          )
                     (time-elapsed? (-> self control sliding-start-time) (seconds 0.04))
                     )
                )
           (go target-falling #f)
           )
          ((and (nonzero? sv-32)
                (>= sv-16 -40960.0)
                (let ((v1-84 (ja-group)))
                  (not (and (and v1-84 (= v1-84 jakb-darkjak-attack-combo3-ja)) (>= (ja-aframe-num 0) 77.0)))
                  )
                (send-event (handle->process (-> self control unknown-combo-tracker00 target)) 'combo)
                )
           (let* ((s5-0 (handle->process (-> self control unknown-combo-tracker00 target)))
                  (gp-0 (if (type? s5-0 process-focusable)
                            s5-0
                            )
                        )
                  )
             (let ((s5-1 (get-trans (the-as process-focusable gp-0) 3)))
               (when (and (< 2048.0 (vector-vector-distance (-> self control trans) s5-1))
                          (or (and (= gp-0 (handle->process sv-56)) (not (time-elapsed? (the-as time-frame sv-64) (seconds 0.1))))
                              (time-elapsed? (the-as time-frame sv-64) (seconds 1))
                              )
                          )
                 (forward-up-nopitch->quaternion
                   (-> self control dir-targ)
                   (vector-! (new 'stack-no-clear 'vector) s5-1 (-> self control trans))
                   (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> self control quat))
                   )
                 (let ((v1-125
                         (point-tracker-method-11
                           (-> self control unknown-combo-tracker00)
                           (new 'stack-no-clear 'vector)
                           (-> self control trans)
                           s5-1
                           (* 0.009107469 (the float (- (current-time) (-> self control unknown-combo-tracker00 move-start-time))))
                           )
                         )
                       )
                   (set! sv-16 (fmin 163840.0 (sqrtf (+ (* (-> v1-125 x) (-> v1-125 x)) (* (-> v1-125 z) (-> v1-125 z))))))
                   )
                 (set-forward-vel sv-16)
                 )
               )
             (when (!= gp-0 (handle->process sv-56))
               (set! sv-56 (process->handle gp-0))
               (set! sv-64 (the-as int (current-time)))
               )
             )
           )
          ((< sv-16 0.0)
           (set! sv-16 (seek sv-16 -0.04096 (* 491520.0 (seconds-per-frame))))
           (set-forward-vel sv-16)
           )
          ((and (nonzero? (-> self control unknown-time-frame18))
                (time-elapsed? (-> self control unknown-time-frame18) (seconds 0.04))
                )
           (set-forward-vel 0.0)
           )
          ((and (not (cpad-hold? (-> self control cpad number) square))
                (zero? sv-32)
                (time-elapsed? (-> self control unknown-combo-tracker00 move-start-time) (seconds 0.2))
                )
           (if (= (-> self control ground-pat material) (pat-material ice))
               (set-forward-vel (fmax 32768.0 (* 0.8 (-> self control ctrl-xz-vel))))
               (set-forward-vel (* 0.8 (-> self control ctrl-xz-vel)))
               )
           )
          ((ja-done? 0)
           (set-forward-vel sv-16)
           )
          (else
            (set! sv-16
                  (* (target-align-vel-z-adjust (-> self align delta trans z)) (-> self clock frames-per-second) sv-20)
                  )
            (set-forward-vel sv-16)
            )
          )
        )
      (let ((gp-1 (new-stack-vector0)))
        (vector-matrix*! gp-1 (-> self control transv) (-> self control w-R-c))
        (set! (-> gp-1 y) 0.0)
        (vector-matrix*! (-> self control align-xz-vel) gp-1 (-> self control c-R-w))
        )
      (when (!= (the-as float (-> self control unknown-word04)) 0.0)
        (activate! *camera-smush-control* 819.2 15 75 1.0 0.9 (-> *display* camera-clock))
        (set! sv-16 (the-as float (-> self control unknown-word04)))
        (set! (-> self control unknown-word04) (the-as uint 0.0))
        )
      (when (and (>= sv-16 0.0)
                 (let ((gp-2 (ja-group))
                       (f30-2 (ja-aframe-num 0))
                       )
                   (if (or (and (= gp-2 jakb-darkjak-attack-combo1-ja)
                                (>= f30-2 11.0)
                                (>= (the float (+ (-> (the-as art-joint-anim jakb-darkjak-attack-combo1-ja) frames num-frames) -1))
                                    (ja-frame-num 0)
                                    )
                                )
                           (and (= gp-2 jakb-darkjak-attack-combo1b-ja)
                                (>= f30-2 11.0)
                                (>= (the float (+ (-> (the-as art-joint-anim jakb-darkjak-attack-combo1b-ja) frames num-frames) -1))
                                    (ja-frame-num 0)
                                    )
                                )
                           (and (= gp-2 jakb-darkjak-attack-combo2-ja)
                                (>= f30-2 49.0)
                                (>= (the float (+ (-> (the-as art-joint-anim jakb-darkjak-attack-combo2-ja) frames num-frames) -1))
                                    (ja-frame-num 0)
                                    )
                                )
                           (and (= gp-2 jakb-darkjak-attack-combo3-ja)
                                (or (and (>= f30-2 62.0) (>= 77.0 f30-2))
                                    (and (>= f30-2 82.0)
                                         (>= (the float (+ (-> (the-as art-joint-anim jakb-darkjak-attack-combo3-ja) frames num-frames) -1))
                                             (ja-frame-num 0)
                                             )
                                         )
                                    )
                                )
                           (and (= gp-2 jakb-darkjak-attack-combo3c-ja)
                                (>= f30-2 62.0)
                                (>= (the float (+ (-> (the-as art-joint-anim jakb-darkjak-attack-combo3c-ja) frames num-frames) -1))
                                    (ja-frame-num 0)
                                    )
                                )
                           )
                       #t
                       )
                   )
                 )
        (let ((gp-3 (new 'stack-no-clear 'collide-query)))
          (when (and (>= (impact-control-method-11
                           (-> self control impact-ctrl)
                           gp-3
                           (the-as process #f)
                           (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1)
                           )
                         0.0
                         )
                     (>= 0.0 (vector-dot (-> gp-3 best-other-tri normal) (-> self control impact-ctrl dir)))
                     )
            (when (= (-> gp-3 best-other-tri pat mode) (pat-mode wall))
              (let ((s5-2 (get-process *default-dead-pool* part-tracker #x4000)))
                (when s5-2
                  (let ((t9-38 (method-of-type part-tracker activate)))
                    (t9-38 (the-as part-tracker s5-2) self (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
                    )
                  (let ((t9-39 run-function-in-process)
                        (a0-96 s5-2)
                        (a1-21 part-tracker-init)
                        (a2-12 (-> *part-group-id-table* 11))
                        (a3-7 0)
                        (t0-3 #f)
                        (t1-2 #f)
                        (t2-1 #f)
                        (t3-0 *launch-matrix*)
                        )
                    (set! (-> t3-0 trans quad) (-> gp-3 best-other-tri intersect quad))
                    ((the-as (function object object object object object object object object none) t9-39)
                     a0-96
                     a1-21
                     a2-12
                     a3-7
                     t0-3
                     t1-2
                     t2-1
                     t3-0
                     )
                    )
                  (-> s5-2 ppointer)
                  )
                )
              (let ((t1-3 (make-u128 (the-as uint #x7469682d6863) (the-as uint #x6e75702d6b616a64))))
                (play-effect-sound
                  (-> self skel effect)
                  'punch
                  -1.0
                  (-> self control impact-ctrl joint)
                  (the-as basic #f)
                  (the-as sound-name t1-3)
                  )
                )
              (activate! *camera-smush-control* 819.2 15 75 1.0 0.9 (-> *display* camera-clock))
              (set! sv-16 (the-as float -61440.0))
              )
            )
          )
        )
      (let ((gp-4 (ja-group))
            (f0-53 (ja-aframe-num 0))
            )
        (if (and (= gp-4 jakb-darkjak-attack-combo3-ja)
                 (>= f0-53 80.0)
                 (>= (the float (+ (-> (the-as art-joint-anim jakb-darkjak-attack-combo3-ja) frames num-frames) -1))
                     (ja-frame-num 0)
                     )
                 )
            (align! (-> self align) (align-opts adjust-y-vel) 1.0 1.6 1.0)
            )
        )
      (suspend)
      (ja :num! (seek! max (* (-> self control current-surface align-speed) (the-as float sv-48))))
      (if (time-elapsed? (-> self state-time) (seconds 0.1))
          (set! (-> *run-attack-mods* turnvv) 0.0)
          )
      (if (< 2 sv-24)
          (set! sv-20 (* sv-20 (fmin 1.0 (-> self control zx-vel-frac))))
          )
      (set! sv-24 (+ sv-24 1))
      )
    (if (and (not (logtest? (-> self control status) (collide-status on-surface)))
             (time-elapsed? (-> self control last-time-on-surface) (the-as time-frame (-> *TARGET-bank* ground-timeout)))
             (>= 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
             (>= (target-height-above-ground) (-> *TARGET-bank* fall-height))
             )
        (go target-falling #f)
        )
    (go target-stance)
    )
  :post target-post
  )

;; definition for method 9 of type darkjak-info
;; WARN: Return type mismatch int vs none.
(defmethod update-clock! ((this darkjak-info) (arg0 int))
  (when (-> this clock-on)
    (+! (-> this clock-pos) (* (-> this clock-vel) (seconds-per-frame)))
    (+! (-> this clock-vel) (* 4.0 (seconds-per-frame)))
    (cond
      ((< 1.0 (-> this clock-pos))
       (set! (-> this clock-pos) 1.0)
       (set! (-> this clock-vel) 0.0)
       )
      ((< (-> this clock-pos) 0.05)
       (set! (-> this clock-pos) 0.05)
       (set! (-> this clock-vel) 1.0)
       )
      )
    (update-rates! (-> *display* entity-clock) (-> this clock-pos))
    (update-rates! (-> *display* bg-clock) (-> this clock-pos))
    (if (= arg0 4)
        (update-rates! (-> *display* target-clock) (-> this clock-pos))
        )
    (when *sound-player-enable*
      (let ((v1-27 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> v1-27 command) (sound-command set-param))
        (set! (-> v1-27 id) (-> this process 0 control unknown-sound-id00))
        (set! (-> v1-27 params pitch-mod) (the int (* 1524.0 (- (- 1.0 (-> this clock-pos))))))
        (set! (-> v1-27 params mask) (the-as uint 2))
        (-> v1-27 id)
        )
      )
    )
  0
  (none)
  )

;; definition for function target-darkjak-bomb-collide
;; WARN: Return type mismatch int vs none.
(defbehavior target-darkjak-bomb-collide target ((arg0 float) (arg1 float))
  (seek! (-> (the-as (pointer float) arg0) 0) arg1 (* 4.0 (seconds-per-frame)))
  (set! (-> self control bomb-scale) (-> (the-as (pointer float) arg0) 0))
  (target-danger-set! 'bomb #f)
  (update-transforms (-> self control))
  (let ((a1-2 (new 'stack-no-clear 'overlaps-others-params)))
    (set! (-> a1-2 options) (overlaps-others-options))
    (set! (-> a1-2 collide-with-filter) (the-as collide-spec -1))
    (set! (-> a1-2 tlist) *touching-list*)
    (find-overlapping-shapes (-> self control) a1-2)
    )
  (set! (-> self control bomb-scale) 0.0)
  (target-danger-set! 'bomb #f)
  (update-transforms (-> self control))
  0
  (none)
  )

;; failed to figure out what this is:
(defstate target-darkjak-bomb0 (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('pole-grab 'darkjak 'slide 'wade 'launch 'edge-grab 'jump 'shove 'attack 'attack-or-shove)
       #f
       )
      (('hit)
       (let ((v1-1 (the-as object (-> block param 1))))
         (when (and (= (-> block param 0) 'bomb)
                    (logtest? (process-mask enemy) (-> (the-as process v1-1) mask))
                    (let ((v1-7 (ja-group)))
                      (and v1-7 (= v1-7 jakb-darkjak-bomb-land-ja))
                      )
                    (>= (ja-aframe-num 0) 35.0)
                    (not (-> self darkjak clock-on))
                    )
           (set! (-> self darkjak clock-vel) -8.0)
           (let ((v0-0 (the-as object #t)))
             (set! (-> self darkjak clock-on) (the-as symbol v0-0))
             v0-0
             )
           )
         )
       )
      (('attack 'attack-or-shove 'swim)
       #f
       )
      (else
        (target-dangerous-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (logior! (-> self state-flags) (state-flags sf4))
    (set! (-> self darkjak clock-pos) 1.0)
    (set! (-> self darkjak clock-vel) 0.0)
    (set! (-> self darkjak clock-on) #f)
    (set! (-> self control unknown-sound-id00)
          (add-process *gui-control* self (gui-channel jak) (gui-action queue) "darkbom0" -99.0 0)
          )
    )
  :exit (behavior ()
    (set-action!
      *gui-control*
      (gui-action fade)
      (-> self control unknown-sound-id00)
      (gui-channel none)
      (gui-action none)
      (the-as string #f)
      (the-as (function gui-connection symbol) #f)
      (the-as process #f)
      )
    (logclear! (-> self state-flags) (state-flags sf6))
    (target-exit)
    (remove-setting! 'music-volume)
    (remove-setting! 'sfx-volume)
    (remove-setting! 'ambient-volume)
    (set! (-> self darkjak clock-pos) 1.0)
    (set! (-> self darkjak clock-vel) 0.0)
    (set! (-> self darkjak clock-on) #f)
    (update-rates! (-> *display* entity-clock) 1.0)
    (update-rates! (-> *display* bg-clock) 1.0)
    (update-rates! (-> *display* target-clock) 1.0)
    (if (not (and (-> self next-state) (= (-> self next-state name) 'target-darkjak-get-off)))
        ((-> target-darkjak-get-off exit))
        )
    )
  :trans (behavior ()
    (update-clock! (-> self darkjak) 4)
    )
  :code (behavior ()
    (local-vars
      (v1-100 symbol)
      (sv-16 float)
      (sv-20 float)
      (sv-80 vector)
      (sv-84 (function vector :behavior target))
      )
    (set! (-> self darkjak stage) (-> self darkjak want-stage))
    (set! (-> self neck flex-blend) 0.0)
    (set! (-> self control mod-surface) *roll-flip-mods*)
    (set! (-> self alt-cam-pos quad) (-> self control trans quad))
    (set! sv-16 (the-as float 0.0))
    (set! sv-20 1.0)
    (ja-channel-push! 1 (seconds 0.15))
    (when (jump-hit-ground-stuck?)
      (ja-no-eval :group! jakb-darkjak-bomb-pre-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (set! (-> self alt-cam-pos x) (-> self control trans x))
        (set! (-> self alt-cam-pos z) (-> self control trans z))
        (set-forward-vel (* 0.85 (-> self control ctrl-xz-vel)))
        (suspend)
        (ja :num! (seek!))
        )
      )
    (set-setting! 'music-volume 'rel 0.0 0)
    (set-setting! 'sfx-volume 'rel 0.0 0)
    (set-setting! 'ambient-volume 'rel 0.0 0)
    (ja-no-eval :group! jakb-darkjak-bomb-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (compute-alignment! (-> self align))
      (align! (-> self align) (align-opts adjust-y-vel) 1.0 1.0 1.0)
      (set! (-> self alt-cam-pos x) (-> self control trans x))
      (set! (-> self alt-cam-pos z) (-> self control trans z))
      (set-forward-vel (* 0.98 (-> self control ctrl-xz-vel)))
      (suspend)
      (ja :num! (seek!))
      )
    (ja-no-eval :group! jakb-darkjak-bomb-loop-ja :num! (seek!) :frame-num 0.0)
    (let ((f30-0 (the float (target-time-to-ground))))
      (until v1-100
        (set! (-> self alt-cam-pos x) (-> self control trans x))
        (set! (-> self alt-cam-pos z) (-> self control trans z))
        (set-forward-vel (* 0.98 (-> self control ctrl-xz-vel)))
        (let ((v1-92 (new-stack-vector0))
              (f0-35 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
              )
          0.0
          (vector-! v1-92 (-> self control transv) (vector-float*! v1-92 (-> self control dynam gravity-normal) f0-35))
          (let* ((f1-5 (vector-length v1-92))
                 (f2-0 f1-5)
                 (f0-36 (+ f0-35 (* -491520.0 (seconds-per-frame))))
                 )
            (vector+!
              (-> self control transv)
              (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-36)
              (vector-float*! v1-92 v1-92 (/ f1-5 f2-0))
              )
            )
          )
        (suspend)
        (ja :num! (seek! max (lerp-scale 1.5 0.3 f30-0 30.0 210.0)))
        (set! v1-100 (or (ja-done? 0) (logtest? (-> self control status) (collide-status on-surface))))
        )
      )
    (logclear! (-> self state-flags) (state-flags sf6))
    (while (not (jump-hit-ground-stuck?))
      (let ((v1-105 (new-stack-vector0))
            (f0-42 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
            )
        0.0
        (vector-!
          v1-105
          (-> self control transv)
          (vector-float*! v1-105 (-> self control dynam gravity-normal) f0-42)
          )
        (let* ((f1-8 (vector-length v1-105))
               (f2-1 f1-8)
               (f0-43 (+ f0-42 (* -491520.0 (seconds-per-frame))))
               )
          (vector+!
            (-> self control transv)
            (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-43)
            (vector-float*! v1-105 v1-105 (/ f1-8 f2-1))
            )
          )
        )
      (ja :num! (seek! (ja-aframe 33.0 0)))
      (suspend)
      )
    (set-forward-vel 0.0)
    (ja-no-eval :group! jakb-darkjak-bomb-land-ja :num! (seek! (ja-aframe 35.0 0)) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! (ja-aframe 35.0 0)))
      )
    (set-action!
      *gui-control*
      (gui-action play)
      (-> self control unknown-sound-id00)
      (gui-channel none)
      (gui-action none)
      (the-as string #f)
      (the-as (function gui-connection symbol) #f)
      (the-as process #f)
      )
    (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.5))
    (activate! *camera-smush-control* 819.2 15 75 1.0 0.9 (-> *display* camera-clock))
    (target-start-attack)
    (target-danger-set! 'bomb #f)
    (set! sv-80 (vector<-cspace! (new 'stack-no-clear 'vector) (joint-node jakb-lod0-jg sk_lhand)))
    (set! sv-84 (lambda :behavior target
                  ()
                  (set-vector! (-> self draw color-mult) 0.0 0.0 0.0 1.0)
                  (cond
                    ((>= 10.0 (ja-aframe-num 0))
                     (let ((v0-1 (the-as vector (-> self draw color-emissive))))
                       (set! (-> (the-as rgbaf v0-1) x) 1.0)
                       (set! (-> (the-as rgbaf v0-1) y) 1.0)
                       (set! (-> (the-as rgbaf v0-1) z) 1.0)
                       (set! (-> (the-as rgbaf v0-1) w) 1.0)
                       v0-1
                       )
                     )
                    ((>= 20.0 (ja-aframe-num 0))
                     (vector-lerp!
                       (-> self draw color-emissive)
                       (new 'static 'vector :x 1.0 :y 1.0 :z 1.0 :w 1.0)
                       (new 'static 'vector :x 0.5 :z 1.0 :w 1.0)
                       (lerp-scale 0.0 1.0 (ja-aframe-num 0) 10.0 20.0)
                       )
                     )
                    (else
                      (vector-lerp!
                        (-> self draw color-emissive)
                        (new 'static 'vector :x 0.5 :z 1.0 :w 1.0)
                        (new 'static 'vector :w 1.0)
                        (lerp-scale 0.0 1.0 (ja-aframe-num 0) 20.0 30.0)
                        )
                      )
                    )
                  )
          )
    (if (and (focus-test? self dark)
             (nonzero? (-> self darkjak))
             (logtest? (-> self darkjak stage) (darkjak-stage giant))
             )
        (set! (-> sv-80 y) (* 0.5 (+ (-> self control trans y) (-> self control root-prim prim-core world-sphere y))))
        (set! (-> sv-80 y) (-> self control root-prim prim-core world-sphere y))
        )
    (let ((gp-4 (get-process *default-dead-pool* part-tracker #x4000)))
      (when gp-4
        (let ((t9-37 (method-of-type part-tracker activate)))
          (t9-37
            (the-as part-tracker gp-4)
            *entity-pool*
            (symbol->string (-> part-tracker symbol))
            (the-as pointer #x70004000)
            )
          )
        (let ((t9-38 run-function-in-process)
              (a0-75 gp-4)
              (a1-37 part-tracker-init)
              (a2-35 (-> *part-group-id-table* 63))
              (a3-15 0)
              (t0-7 #f)
              (t1-5 #f)
              (t2-2 #f)
              (t3-1 *launch-matrix*)
              )
          (set! (-> t3-1 trans quad) (-> sv-80 quad))
          ((the-as (function object object object object object object object object none) t9-38)
           a0-75
           a1-37
           a2-35
           a3-15
           t0-7
           t1-5
           t2-2
           t3-1
           )
          )
        (-> gp-4 ppointer)
        )
      )
    (let ((gp-5 (process-spawn
                  manipy
                  :init manipy-init
                  sv-80
                  (-> self entity)
                  (art-group-get-by-name *level* "skel-bomb-blast" (the-as (pointer uint32) #f))
                  #f
                  0
                  :to self
                  )
                )
          )
      (when gp-5
        (send-event (ppointer->process gp-5) 'anim-mode 'play1)
        (send-event (ppointer->process gp-5) 'anim "idle")
        (set-vector! (-> (the-as process-drawable (-> gp-5 0)) root scale) sv-20 1.0 sv-20 1.0)
        (send-event (ppointer->process gp-5) 'trans-hook sv-84)
        )
      )
    (let ((gp-7 (process-spawn
                  manipy
                  :init manipy-init
                  sv-80
                  (-> self entity)
                  (art-group-get-by-name *level* "skel-generic-blast" (the-as (pointer uint32) #f))
                  #f
                  0
                  :to self
                  )
                )
          )
      (when gp-7
        (send-event (ppointer->process gp-7) 'anim-mode 'play1)
        (send-event (ppointer->process gp-7) 'anim "idle")
        (set-vector! (-> (the-as process-drawable (-> gp-7 0)) root scale) sv-20 1.0 sv-20 1.0)
        )
      )
    (ja-no-eval :num! (seek! (ja-aframe 38.0 0)))
    (while (not (ja-done? 0))
      (target-darkjak-bomb-collide (the-as float (& sv-16)) sv-20)
      (set-forward-vel 0.0)
      (suspend)
      (ja-eval)
      )
    (when (and (focus-test? self dark)
               (and (nonzero? (-> self darkjak)) (logtest? (-> self darkjak stage) (darkjak-stage giant)))
               )
      (let ((gp-10 (process-spawn
                     manipy
                     :init manipy-init
                     sv-80
                     (-> self entity)
                     (art-group-get-by-name *level* "skel-bomb-blast" (the-as (pointer uint32) #f))
                     #f
                     0
                     :to self
                     )
                   )
            )
        (when gp-10
          (send-event (ppointer->process gp-10) 'anim-mode 'play1)
          (send-event (ppointer->process gp-10) 'anim "idle")
          (set-vector! (-> (the-as process-drawable (-> gp-10 0)) root scale) sv-20 1.0 sv-20 1.0)
          (send-event
            (ppointer->process gp-10)
            'trans-hook
            (lambda :behavior target
              ()
              (set-vector! (-> self draw color-mult) 0.0 0.0 0.0 1.0)
              (cond
                ((>= 10.0 (ja-aframe-num 0))
                 (let ((v0-1 (the-as vector (-> self draw color-emissive))))
                   (set! (-> (the-as rgbaf v0-1) x) 0.5)
                   (set! (-> (the-as rgbaf v0-1) y) 0.25)
                   (set! (-> (the-as rgbaf v0-1) z) 1.0)
                   (set! (-> (the-as rgbaf v0-1) w) 1.0)
                   v0-1
                   )
                 )
                ((>= 20.0 (ja-aframe-num 0))
                 (vector-lerp!
                   (-> self draw color-emissive)
                   (new 'static 'vector :x 0.5 :z 1.0 :w 1.0)
                   (new 'static 'vector :x 0.5 :y 0.25 :z 1.0 :w 1.0)
                   (lerp-scale 0.0 1.0 (ja-aframe-num 0) 10.0 20.0)
                   )
                 )
                (else
                  (vector-lerp!
                    (-> self draw color-emissive)
                    (new 'static 'vector :x 0.25 :z 1.0 :w 1.0)
                    (new 'static 'vector :w 1.0)
                    (lerp-scale 0.0 1.0 (ja-aframe-num 0) 20.0 30.0)
                    )
                  )
                )
              )
            )
          )
        )
      (let ((gp-12 (process-spawn
                     manipy
                     :init manipy-init
                     sv-80
                     (-> self entity)
                     (art-group-get-by-name *level* "skel-generic-blast" (the-as (pointer uint32) #f))
                     #f
                     0
                     :to self
                     )
                   )
            )
        (when gp-12
          (send-event (ppointer->process gp-12) 'anim-mode 'play1)
          (send-event (ppointer->process gp-12) 'anim "idle")
          (set-vector! (-> (the-as process-drawable (-> gp-12 0)) root scale) sv-20 0.5 sv-20 1.0)
          )
        )
      )
    (ja-no-eval :num! (seek!))
    (while (not (ja-done? 0))
      (target-darkjak-bomb-collide (the-as float (& sv-16)) sv-20)
      (set-forward-vel 0.0)
      (suspend)
      (ja-eval)
      )
    (remove-setting! 'music-volume)
    (remove-setting! 'sfx-volume)
    (remove-setting! 'ambient-volume)
    (ja-no-eval :group! jakb-darkjak-bomb-end-ja :num! (seek! (ja-aframe 90.0 0)) :frame-num 0.0)
    (until (ja-done? 0)
      (target-darkjak-bomb-collide (the-as float (& sv-16)) sv-20)
      (suspend)
      (ja :num! (seek! (ja-aframe 90.0 0)))
      )
    (logior! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (send-event (handle->process (-> self notify)) 'notify 'attack 16)
    (go target-darkjak-get-off)
    )
  :post target-no-stick-post
  )

;; failed to figure out what this is:
(set! (-> *lightning-spec-id-table* 10) (new 'static 'lightning-spec
                                          :name "lightning-darkjak-bomb1"
                                          :flags (lightning-spec-flags lsf0 size-from-adjust-dist)
                                          :adjust-distance #xa
                                          :start-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :end-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :fade-to-color (new 'static 'rgba :r #xbf :b #x8f :a #x5)
                                          :fade-start-factor 0.2
                                          :texture (new 'static 'texture-id :index #x84 :page #xc)
                                          :reduction 0.42
                                          :num-points 96
                                          :box-size 32768.0
                                          :merge-factor 0.2
                                          :merge-count 2
                                          :radius 2048.0
                                          :duration 300.0
                                          :duration-rand 90.0
                                          :sound (static-sound-spec "transform-zap")
                                          )
      )

;; definition for function target-bomb1-fire-shot
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defbehavior target-bomb1-fire-shot target ((arg0 (pointer handle)) (arg1 int) (arg2 int) (arg3 int))
  (local-vars (sv-128 target) (sv-144 int) (sv-160 vector) (sv-176 vector) (sv-192 vector))
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (cond
      ((and (>= arg1 0) (< arg1 arg2))
       (let ((gp-0 (handle->process (-> arg0 arg1))))
         (when gp-0
           (get-trans (the-as process-focusable gp-0) 3)
           (process-spawn
             lightning-tracker
             :init lightning-tracker-init
             (-> *lightning-spec-id-table* 10)
             0
             lightning-probe-callback
             gp-0
             3
             3
             :to self
             )
           (send-event
             gp-0
             'attack
             #f
             (static-attack-info ((id (the-as uint arg3))
                                  (mode 'ice)
                                  (damage 15.0)
                                  (penetrate-using (if (and (focus-test? self dark)
                                                            (nonzero? (-> self darkjak))
                                                            (logtest? (-> self darkjak stage) (darkjak-stage giant))
                                                            )
                                                       (penetrate touch dark-skin dark-bomb dark-giant)
                                                       (penetrate touch dark-skin dark-bomb)
                                                       )
                                                   )
                                  )
                                 )
             )
           )
         )
       )
      (else
        (let ((gp-1 (get-process *default-dead-pool* lightning-tracker #x4000)))
          (when gp-1
            (let ((t9-6 (method-of-type lightning-tracker activate)))
              (t9-6
                (the-as lightning-tracker gp-1)
                self
                (symbol->string (-> lightning-tracker symbol))
                (the-as pointer #x70004000)
                )
              )
            (let ((s5-1 run-function-in-process)
                  (s4-1 gp-1)
                  (s3-0 lightning-tracker-init)
                  (s2-0 (-> *lightning-spec-id-table* 10))
                  (s1-0 0)
                  (s0-0 lightning-probe-callback)
                  )
              (set! sv-128 self)
              (set! sv-144 3)
              (set! sv-192 (new 'stack-no-clear 'vector))
              (set! sv-160 (-> self control trans))
              (set! sv-176 (new 'stack-no-clear 'vector))
              (set! (-> sv-176 x) (rand-vu-float-range -40960.0 40960.0))
              (set! (-> sv-176 y) (rand-vu-float-range -8192.0 8192.0))
              (set! (-> sv-176 z) (rand-vu-float-range -40960.0 40960.0))
              (set! (-> sv-176 w) 1.0)
              (.mov.vf vf6 vf0 :mask #b1000)
              (.lvf vf4 (&-> sv-160 quad))
              (.lvf vf5 (&-> sv-176 quad))
              (.add.vf vf6 vf4 vf5 :mask #b111)
              (.svf (&-> sv-192 quad) vf6)
              ((the-as (function object object object object object object object object none) s5-1)
               s4-1
               s3-0
               s2-0
               s1-0
               s0-0
               sv-128
               sv-144
               sv-192
               )
              )
            (-> gp-1 ppointer)
            )
          )
        )
      )
    (none)
    )
  )

;; failed to figure out what this is:
(defstate target-darkjak-bomb1 (target)
  :event (-> target-darkjak-bomb0 event)
  :enter (-> target-attack-uppercut-jump enter)
  :exit (-> target-darkjak-bomb0 exit)
  :trans (behavior ()
    (if (logtest? (-> self control status) (collide-status on-surface))
        (go target-hit-ground #f)
        )
    (mod-var-jump #t #t (cpad-hold? (-> self control cpad number) x) (-> self control transv))
    (if (and (= (-> self control danger-mode) 'uppercut)
             (< (vector-dot (-> self control dynam gravity-normal) (-> self control transv)) -8192.0)
             )
        (target-danger-set! 'harmless #f)
        )
    (slide-down-test)
    (update-clock! (-> self darkjak) 8)
    )
  :code (behavior ((arg0 float) (arg1 float))
    (local-vars
      (sv-32 (array collide-shape))
      (sv-40 int)
      (sv-48 int)
      (sv-56 sphere)
      (sv-60 (pointer handle))
      (sv-64 int)
      (sv-72 time-frame)
      (sv-80 time-frame)
      (sv-88 float)
      (sv-92 number)
      (sv-96 time-frame)
      (sv-104 uint)
      )
    (logior! (-> self state-flags) (state-flags sf4))
    (set! (-> self neck flex-blend) 0.0)
    (set-setting! 'music-volume 'rel 0.0 0)
    (set-setting! 'ambient-volume 'rel 0.0 0)
    (compute-alignment! (-> self align))
    (set-action!
      *gui-control*
      (gui-action play)
      (-> self control unknown-sound-id00)
      (gui-channel none)
      (gui-action none)
      (the-as string #f)
      (the-as (function gui-connection symbol) #f)
      (the-as process #f)
      )
    (let ((f0-1 0.9))
      (ja-no-eval :num! (seek! max f0-1))
      )
    (while (not (ja-done? 0))
      (compute-alignment! (-> self align))
      (set! (-> self control turn-go-the-long-way) 1.0)
      (set! (-> self darkjak clock-vel) -4.0)
      (set! (-> self darkjak clock-on) #t)
      (align! (-> self align) (align-opts adjust-y-vel) 1.0 1.0 1.0)
      (suspend)
      (ja-eval)
      )
    (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.5))
    (activate! *camera-smush-control* 819.2 15 75 1.0 0.9 (-> *display* camera-clock))
    (let ((gp-0 (-> self post-hook)))
      (set! (-> self post-hook) target-no-move-post)
      (set! sv-32 (-> self focus-search))
      (set! sv-40 0)
      (set! sv-48 0)
      (set! sv-56 (the-as sphere (vector<-cspace! (new 'stack-no-clear 'vector) (joint-node jakb-lod0-jg main))))
      (set! sv-60
            (new 'static 'array handle 128
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              (new 'static 'handle)
              )
            )
      (set! (-> sv-56 r)
            (if (and (focus-test? self dark)
                     (and (nonzero? (-> self darkjak)) (logtest? (-> self darkjak stage) (darkjak-stage giant)))
                     )
                614400.0
                327680.0
                )
            )
      (set! sv-40 (fill-actor-list-for-sphere *actor-hash* sv-56 (-> sv-32 data) (-> sv-32 allocated-length)))
      (set! (-> sv-32 length) sv-40)
      (countdown (s5-0 sv-40)
        (let* ((s4-0 (-> sv-32 s5-0 process))
               (v1-53 (if (type? s4-0 process-focusable)
                          s4-0
                          )
                      )
               )
          (when (and v1-53 (logtest? (process-mask enemy guard vehicle) (-> v1-53 mask)))
            (set! (-> sv-60 sv-48) (process->handle v1-53))
            (set! sv-48 (+ sv-48 1))
            (if (< 128 sv-48)
                (set! sv-48 128)
                )
            )
          )
        )
      (set! (-> self control mod-surface) (new 'static 'surface
                                            :name 'uppercut
                                            :turnv 524288.0
                                            :tiltv 32768.0
                                            :tiltvv 262144.0
                                            :transv-max 32768.0
                                            :target-speed 32768.0
                                            :fric 0.2
                                            :nonlin-fric-dist 1.0
                                            :slip-factor 1.0
                                            :slide-factor 1.0
                                            :slope-up-factor 1.0
                                            :slope-down-factor 1.0
                                            :slope-slip-angle 1.0
                                            :impact-fric 1.0
                                            :bend-factor 1.0
                                            :bend-speed 1.0
                                            :alignv 1.0
                                            :slope-up-traction 1.0
                                            :align-speed 1.0
                                            :turnvf 15.0
                                            :tiltvf 150.0
                                            :tiltvvf 15.0
                                            :mode 'air
                                            :flags (surface-flag air attack spin gun-off laser-hide)
                                            )
            )
      (set! sv-64 0)
      (set! sv-72 (current-time))
      (set! sv-80 (current-time))
      (set! sv-88 (the-as float 0.0))
      (set! sv-92 0.0)
      (set! sv-96 (current-time))
      (let* ((v1-70 (-> self game))
             (a0-33 (+ (-> v1-70 attack-id) 1))
             )
        (set! (-> v1-70 attack-id) a0-33)
        (set! sv-104 a0-33)
        )
      (ja-channel-push! 2 (seconds 0.05))
      (ja :group! jakb-darkjak-attack-ice-loop-ja)
      (ja :chan 1 :group! jakb-darkjak-attack-ice-loop2-ja)
      (while (or (< sv-64 sv-48) (not (time-elapsed? sv-80 (seconds 1.5))))
        (let ((v1-77 (new-stack-vector0)))
          (let ((f0-8 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
            0.0
            (vector-! v1-77 (-> self control transv) (vector-float*! v1-77 (-> self control dynam gravity-normal) f0-8))
            )
          (let* ((f0-9 (vector-length v1-77))
                 (f1-3 f0-9)
                 (f2-0 0.0)
                 )
            (vector+!
              (-> self control transv)
              (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-0)
              (vector-float*! v1-77 v1-77 (/ f0-9 f1-3))
              )
            )
          )
        (set! (-> self darkjak clock-vel) -4.0)
        (set! (-> self darkjak clock-on) #t)
        (send-event *camera* 'joystick -0.25 1.0)
        (when (time-elapsed? sv-72 (seconds 0.1))
          (set! sv-72 (current-time))
          (target-bomb1-fire-shot sv-60 sv-64 sv-48 (the-as int sv-104))
          (set! sv-64 (+ sv-64 1))
          (if (time-elapsed? (-> self state-time) (seconds 1))
              (set! sv-92 1.0)
              )
          )
        (set! sv-88 (seek sv-88 (the-as float sv-92) (* 6.0 (seconds-per-frame))))
        (ja :num! (loop!))
        (let ((a0-60 (-> self skel root-channel 1)))
          (let ((f0-17 sv-88))
            (set! (-> a0-60 frame-interp 1) f0-17)
            (set! (-> a0-60 frame-interp 0) f0-17)
            )
          (set! (-> a0-60 param 0) 0.0)
          (joint-control-channel-group-eval! a0-60 (the-as art-joint-anim #f) num-func-chan)
          )
        (suspend)
        )
      0
      (set! (-> self post-hook) gp-0)
      )
    (set! (-> self control mod-surface) *double-jump-mods*)
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! jakb-darkjak-attack-ice-end-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (ja-blend-eval)
      (compute-alignment! (-> self align))
      (set! (-> self control turn-go-the-long-way) 1.0)
      (set! (-> self darkjak clock-vel) 4.0)
      (suspend)
      (ja :num! (seek!))
      )
    (set-time! (-> self gun surpress-time))
    (send-event (handle->process (-> self notify)) 'notify 'attack 17)
    (go target-darkjak-get-off)
    )
  :post target-post
  )

;; failed to figure out what this is:
(defstate target-darkjak-giant (target)
  :event target-standard-event-handler
  :exit (behavior ()
    (logclear! (-> self state-flags) (state-flags lleg-still rleg-still))
    (set! (-> self darkjak-interp) 1.0)
    (set! (-> self darkjak-giant-interp) (the-as float (-> self control unknown-word04)))
    (when (= (the-as float (-> self control unknown-word04)) 1.0)
      (logclear! (-> self darkjak stage) (darkjak-stage giant))
      (set! (-> self darkjak want-stage) (-> self darkjak stage))
      )
    )
  :code (behavior ()
    (send-event (handle->process (-> self notify)) 'notify 'attack 18)
    (set! (-> self darkjak want-stage) (-> self darkjak stage))
    (logior! (-> self state-flags) (state-flags sf4))
    (set! (-> self neck flex-blend) 0.0)
    (set! (-> self control mod-surface) *darkjak-trans-mods*)
    (logior! (-> self darkjak stage) (darkjak-stage giant))
    (set! (-> self darkjak want-stage) (-> self darkjak stage))
    (sound-play "djak-transform")
    (let ((gp-1 (new 'stack-no-clear 'collide-query)))
      (let ((s5-1 (new 'stack-no-clear 'inline-array 'sphere 1)))
        (dotimes (s4-0 1)
          ((method-of-type sphere new) (the-as symbol (-> s5-1 s4-0)) sphere)
          )
        (set! (-> s5-1 0 quad) (-> self control trans quad))
        (+! (-> s5-1 0 y) 12697.6)
        (set! (-> s5-1 0 r) 11878.4)
        (let ((v1-29 gp-1))
          (set! (-> v1-29 best-dist) (the-as float s5-1))
          (set! (-> v1-29 num-spheres) (the-as uint 1))
          (set! (-> v1-29 collide-with) (logclear
                                          (-> self control root-prim prim-core collide-with)
                                          (collide-spec civilian enemy vehicle-sphere projectile)
                                          )
                )
          (set! (-> v1-29 ignore-process0) #f)
          (set! (-> v1-29 ignore-process1) #f)
          (set! (-> v1-29 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
          (set! (-> v1-29 best-my-prim) (the-as collide-shape-prim #t))
          (set! (-> v1-29 action-mask) (collide-action solid))
          )
        )
      (let ((gp-2 (not (fill-and-probe-using-spheres *collide-cache* gp-1))))
        (set! (-> self control unknown-word04) (the-as uint (if gp-2
                                                                2.0
                                                                1.0
                                                                )
                                                       )
              )
        (when gp-2
          (set-setting! 'string-min-length 'rel 1.8 0)
          (set-setting! 'string-max-length 'rel 1.5 0)
          (set-setting! 'string-spline-max-move 'abs (meters 2) 0)
          (set-setting! 'string-spline-accel 'abs (meters 0.045) 0)
          (set-setting! 'string-spline-max-move-player 'abs (meters 1.5) 0)
          (set-setting! 'string-spline-accel-player 'abs (meters 0.035) 0)
          )
        (ja-channel-push! 1 (seconds 0.1))
        (ja-no-eval :group! jakb-darkjak-get-on-fast-ja :num! (seek! (ja-aframe 17.0 0)) :frame-num 0.0)
        (until (ja-done? 0)
          (cond
            (gp-2
              (set! (-> self darkjak-giant-interp) (lerp-scale 1.0 2.0 (ja-aframe-num 0) 5.0 15.0))
              )
            ((>= (ja-aframe-num 0) 10.0)
             (set! (-> self darkjak-giant-interp) (lerp-scale 2.0 1.0 (ja-aframe-num 0) 5.0 15.0))
             )
            (else
              (set! (-> self darkjak-giant-interp) (lerp-scale 1.0 2.0 (ja-aframe-num 0) 5.0 15.0))
              )
            )
          (suspend)
          (ja :num! (seek! (ja-aframe 17.0 0)))
          )
        )
      )
    (send-event *traffic-manager* 'increase-alert-level 4)
    (go target-stance)
    )
  :post (-> target-grab post)
  )
