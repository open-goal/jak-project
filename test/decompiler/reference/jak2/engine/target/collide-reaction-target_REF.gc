;;-*-Lisp-*-
(in-package goal)

;; definition for function poly-find-nearest-edge
;; INFO: Used lq/sq
;; WARN: Stack slot offset 36 signed mismatch
;; WARN: Stack slot offset 36 signed mismatch
;; WARN: Stack slot offset 48 signed mismatch
;; WARN: Stack slot offset 36 signed mismatch
;; WARN: Stack slot offset 36 signed mismatch
;; WARN: Stack slot offset 48 signed mismatch
;; WARN: Stack slot offset 36 signed mismatch
;; WARN: Stack slot offset 36 signed mismatch
;; WARN: Stack slot offset 48 signed mismatch
;; WARN: Stack slot offset 36 signed mismatch
;; WARN: Stack slot offset 36 signed mismatch
;; WARN: Stack slot offset 48 signed mismatch
(defun poly-find-nearest-edge ((arg0 nav-poly) (arg1 (inline-array vector)) (arg2 vector) (arg3 vector))
  "TODO- Not 100% sure here, but unused"
  (local-vars (sv-32 vector) (sv-36 float) (sv-40 int) (sv-48 float) (sv-80 vector))
  (set! sv-32 (new 'stack-no-clear 'vector))
  (set! sv-36 (the-as float 4095996000.0))
  (set! sv-40 -1)
  (set! sv-48 (the-as float 0.0))
  (dotimes (s2-0 3)
    (let ((s0-0 (-> arg1 s2-0)))
      (set! sv-80 (-> arg1 (mod (+ s2-0 1) 3)))
      (let ((f30-0 (vector-line-distance-point! arg2 s0-0 sv-80 sv-32))
            (s1-1 (vector-! (new 'stack-no-clear 'vector) sv-80 s0-0))
            )
        0.0
        (vector-normalize! s1-1 1.0)
        (let ((f0-5 (fabs (vector-dot arg3 s1-1))))
          (when (or (< f30-0 sv-36) (and (= f30-0 sv-36) (< sv-48 f0-5)))
            (set! sv-36 f30-0)
            (set! sv-40 s2-0)
            (set! sv-48 f0-5)
            )
          )
        )
      )
    )
  (set! (-> arg0 vertex 0 quad) (-> arg1 sv-40 quad))
  (set! (-> arg0 vertex1 quad) (-> arg1 (mod (+ sv-40 1) 3) quad))
  arg0
  )

;; definition for function target-collision-low-coverage
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defun target-collision-low-coverage ((arg0 control-info)
                             (arg1 collide-query)
                             (arg2 vector)
                             (arg3 (pointer uint32))
                             (arg4 (pointer int64))
                             (arg5 (pointer symbol))
                             )
  (local-vars
    (sv-16 vector)
    (sv-20 (pointer uint32))
    (sv-24 (pointer int64))
    (sv-28 (pointer symbol))
    (sv-32 uint)
    (sv-40 int)
    (sv-48 symbol)
    (sv-52 vector)
    (sv-56 vector)
    )
  (with-pp
    (set! sv-16 arg2)
    (set! sv-20 arg3)
    (set! sv-24 arg4)
    (set! sv-28 arg5)
    (set! sv-32 (-> arg3 0))
    (set! sv-40 (-> arg4 0))
    (set! sv-48 (-> arg5 0))
    (set! sv-52 (-> arg0 unknown-vector26))
    (set! sv-56 (vector-cross! (-> arg0 unknown-vector-kjh1n23kj1n23) (-> arg0 poly-normal) sv-16))
    (vector-normalize! sv-56 1.0)
    (if (>= (fabs (vector-dot (-> arg0 dynam gravity-normal) sv-56)) 0.866)
        (set! sv-32 (logior sv-32 512))
        )
    (vector-cross! sv-52 sv-16 sv-56)
    (if (< 0.0 (vector-dot (-> arg0 dynam gravity-normal) sv-52))
        (vector-negate! sv-52 sv-52)
        )
    (vector-normalize! sv-52 1.0)
    (let ((s4-0 (new 'stack-no-clear 'collide-query)))
      (let ((s3-0 (vector-flatten! (-> arg0 unknown-vector-lkjk12nj3n) sv-52 (-> arg0 dynam gravity-normal))))
        (let ((v1-19 s4-0))
          (set! (-> v1-19 radius) 409.6)
          (set! (-> v1-19 collide-with) (-> arg1 best-my-prim prim-core collide-with))
          (set! (-> v1-19 ignore-process0) #f)
          (set! (-> v1-19 ignore-process1) #f)
          (set! (-> v1-19 ignore-pat) (-> arg0 pat-ignore-mask))
          (set! (-> v1-19 action-mask) (collide-action solid))
          )
        (vector-normalize! s3-0 1.0)
        (if (< (vector-dot s3-0 sv-16) 0.0)
            (vector-negate! s3-0 s3-0)
            )
        (set! (-> arg0 unknown-float-kj1n23k1) 4095996000.0)
        (set! (-> arg0 unknown-float-n234n23) 4095996000.0)
        (vector+float*! (-> s4-0 start-pos) (-> arg1 best-other-tri intersect) s3-0 2867.2)
        (vector-normalize-copy! (-> s4-0 move-dist) (-> arg0 dynam gravity-normal) -20480.0)
        (vector+float*! (-> s4-0 move-dist) (-> s4-0 move-dist) s3-0 4096.0)
        (when (>= (probe-using-line-sphere *collide-cache* s4-0) 0.0)
          (set! (-> arg0 unknown-float-kj1n23k1)
                (vector-dot
                  (-> arg0 dynam gravity-normal)
                  (vector-! (new 'stack-no-clear 'vector) (-> arg1 best-other-tri intersect) (-> s4-0 best-other-tri intersect))
                  )
                )
          (set! (-> arg0 unknown-float-kj1n23j) (the-as float (-> s4-0 best-other-tri pat)))
          (set! (-> arg0 unknown-vector-l1jn23j quad) (-> s4-0 best-other-tri normal quad))
          0
          )
        (vector+float*! (-> s4-0 start-pos) (-> arg1 best-other-tri intersect) (-> arg0 dynam gravity-normal) 819.2)
        (vector-normalize-copy! (-> s4-0 move-dist) (-> arg0 dynam gravity-normal) -20480.0)
        (vector+float*! (-> s4-0 start-pos) (-> s4-0 start-pos) s3-0 -819.2)
        (vector+float*! (-> s4-0 move-dist) (-> s4-0 move-dist) s3-0 -4096.0)
        )
      (when (>= (probe-using-line-sphere *collide-cache* s4-0) 0.0)
        (set! (-> arg0 unknown-float-n234n23)
              (vector-vector-distance (-> s4-0 start-pos) (-> s4-0 best-other-tri intersect))
              )
        (set! (-> arg0 unknown-float-m32j45nhn) (the-as float (-> s4-0 best-other-tri pat)))
        (set! (-> arg0 unknown-vector-kj1n23k quad) (-> s4-0 best-other-tri normal quad))
        0
        )
      )
    (when (and (not (logtest? sv-32 512))
               (and (or (< (* 1.25 (-> arg1 best-my-prim local-sphere w)) (-> arg0 unknown-float-kj1n23k1))
                        (= (shr (shl (the-as int (-> arg0 unknown-float-kj1n23j)) 54) 61) 1)
                        )
                    (and (< (-> arg0 unknown-float-n234n23) (* 2.0 (-> arg1 best-my-prim local-sphere w)))
                         (or (zero? (shr (shl (the-as int (-> arg0 unknown-float-m32j45nhn)) 54) 61))
                             (= (shr (shl (the-as int (-> arg0 unknown-float-m32j45nhn)) 54) 61) 3)
                             )
                         )
                    )
               )
      (set! sv-32 (logior sv-32 128))
      (set! (-> arg0 unknown-time-frame-kjh1n23hkjn) (-> pp clock frame-counter))
      (set! sv-40 (logior sv-40 128))
      (set! (-> arg0 unknown-time-frame08) (-> pp clock frame-counter))
      (let ((f30-0 (vector-dot sv-52 (-> arg0 unknown-vector10)))
            (f0-27 (if (logtest? sv-32 2)
                       (cos (- 16384.0 (acos (-> arg0 coverage))))
                       (-> arg0 coverage)
                       )
                   )
            (f1-11 (vector-dot
                     (-> arg0 dynam gravity-normal)
                     (vector-! (new 'stack-no-clear 'vector) (-> arg0 trans) (-> arg1 best-other-tri intersect))
                     )
                   )
            )
        (if (or (not (logtest? sv-32 32)) (< 0.5 f0-27))
            (set! sv-48 (the-as symbol #f))
            )
        (when (and (or (and (< f0-27 0.95) (>= f30-0 0.0))
                       (and (logtest? sv-32 32) (< f0-27 0.3))
                       (< f1-11 (* -0.25 (-> arg1 best-my-prim local-sphere w)))
                       )
                   (>= (vector-dot sv-52 sv-16) -0.000001)
                   )
          (set! (-> arg0 surf) *edge-surface*)
          (set! sv-32 (logior sv-32 1024))
          (set! sv-48 (the-as symbol #f))
          (when (logtest? sv-32 32)
            (set! sv-48 #t)
            (set! sv-32 (logior sv-32 4096))
            )
          )
        )
      )
    (if (< (-> arg0 surface-angle) 0.0)
        (set! sv-48 #t)
        )
    (when sv-48
      (cond
        ((and (or (or (= (-> arg0 poly-pat mode) (pat-mode ground)) (= (-> arg0 poly-pat mode) (pat-mode halfpipe)))
                  (and (logtest? sv-32 8)
                       (>= (* 1.25 (-> arg1 best-my-prim local-sphere w)) (-> arg0 unknown-float-kj1n23k1))
                       (or (zero? (shr (shl (the-as int (-> arg0 unknown-float-kj1n23j)) 54) 61))
                           (= (shr (shl (the-as int (-> arg0 unknown-float-kj1n23j)) 54) 61) 3)
                           )
                       (< 0.3 (fabs (-> arg0 surface-angle)))
                       )
                  )
              (zero? (logand sv-32 128))
              )
         (set! sv-32 (logior sv-32 64))
         (set! sv-40 (logior sv-40 128))
         (set! (-> arg0 unknown-time-frame08) (-> pp clock frame-counter))
         (set! sv-48 (the-as symbol #f))
         )
        (#t
          (set! sv-32 (logior sv-32 64))
          (set! sv-40 (logior sv-40 128))
          (set! (-> arg0 unknown-time-frame08) (-> pp clock frame-counter))
          )
        )
      )
    (set! (-> sv-24 0) sv-40)
    (set! (-> sv-20 0) sv-32)
    (set! (-> sv-28 0) sv-48)
    0
    (none)
    )
  )

;; definition for function target-collision-reaction
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs collide-status.
(defbehavior target-collision-reaction target ((arg0 control-info) (arg1 collide-query) (arg2 vector) (arg3 vector))
  (local-vars (sv-80 vector) (sv-84 vector) (sv-88 matrix) (sv-96 int) (sv-104 int) (sv-240 symbol))
  (set! sv-80 (new-stack-vector0))
  (set! sv-84 (new-stack-vector0))
  (let ((v1-2 (new 'stack-no-clear 'matrix)))
    (dotimes (a0-1 2)
      (set! (-> v1-2 vector a0-1 quad) (the-as uint128 0))
      )
    (set! sv-88 v1-2)
    )
  (set! sv-96 0)
  (set! sv-104 0)
  (set! (-> sv-88 vector 0 quad) (-> arg3 quad))
  (set! (-> sv-88 vector 1 quad) (-> arg3 quad))
  (let ((a1-3 (new 'stack-no-clear 'vector)))
    (vector-float*! a1-3 (-> arg1 move-dist) (-> arg1 best-dist))
    (move-by-vector! arg0 a1-3)
    )
  (set! sv-104 (logior sv-104 (react-to-pat! arg0 (-> arg1 best-other-tri pat))))
  (if (= (-> arg0 poly-pat mode) (pat-mode wall))
      (set! sv-104 (logior sv-104 1))
      )
  (if (logtest? (-> arg0 unknown-surface00 flags) (surface-flag air))
      (set! sv-104 (logior sv-104 32))
      )
  (let ((v1-24 (new 'stack-no-clear 'vector)))
    (set! (-> v1-24 quad) (-> arg1 best-my-prim prim-core world-sphere quad))
    (vector-! sv-80 v1-24 (-> arg1 best-other-tri intersect))
    )
  (vector-normalize! sv-80 1.0)
  (set! (-> arg0 coverage) (vector-dot sv-80 (-> arg1 best-other-tri normal)))
  (when (< (-> arg0 coverage) 0.0)
    (set! (-> arg0 coverage) 0.0)
    (vector-flatten! sv-80 sv-80 (-> arg1 best-other-tri normal))
    (vector-normalize! sv-80 1.0)
    )
  (if (< (-> arg0 coverage) 0.9999)
      (set! sv-104 (logior sv-104 24))
      )
  (let ((v1-35 (-> sv-80 quad)))
    (set! (-> sv-84 quad) v1-35)
    )
  (if (= (-> arg1 best-dist) 0.0)
      (move-by-vector! arg0 (vector-normalize-copy! (new-stack-vector0) sv-84 3.0))
      )
  (set! (-> arg0 poly-normal quad) (-> arg1 best-other-tri normal quad))
  (collide-shape-moving-angle-set! arg0 sv-84 (the-as vector (-> sv-88 vector)))
  (if (< (-> arg0 poly-angle) -0.2)
      (set! sv-96 (logior sv-96 16))
      )
  (if (< (-> arg0 poly-angle) 0.0)
      (set! sv-96 (logior sv-96 #x4000))
      )
  (if (!= (-> arg1 best-my-prim prim-id) 6)
      (set! sv-104 (logior sv-104 #x8000))
      )
  (if (and (= (-> arg0 cur-pat mode) (pat-mode halfpipe)) (< (-> arg0 poly-angle) 0.75))
      (send-event (-> arg0 process) 'slide)
      )
  (set! sv-240 (< (fabs (-> arg0 surface-angle)) (-> *pat-mode-info* (-> arg0 cur-pat mode) wall-angle)))
  (if (and sv-240 (and (= (-> arg0 unknown-surface00 mode) 'dive) (< 0.4 (fabs (-> arg0 surface-angle)))))
      (set! sv-240 (the-as symbol #f))
      )
  (if (and (logtest? sv-104 #x8000) (logtest? sv-104 32) (>= (-> arg0 poly-angle) 0.0) (not sv-240))
      (set! sv-240 #t)
      )
  (if sv-240
      (set! sv-104 (logior sv-104 2))
      )
  (if (logtest? sv-104 8)
      (target-collision-low-coverage
        arg0
        arg1
        sv-84
        (the-as (pointer uint32) (& sv-104))
        (the-as (pointer int64) (& sv-96))
        (& sv-240)
        )
      )
  (when (not (logtest? (-> arg0 prev-status) (collide-status on-surface)))
    (set! (-> arg0 unknown-vector-kj1n231 quad) (-> arg0 transv quad))
    (set! (-> arg0 ground-impact-vel) (- (vector-dot (-> arg0 transv) (-> arg0 dynam gravity-normal))))
    (set! (-> arg0 unknown-float21) (- (vector-dot (-> arg0 transv) sv-84)))
    (set! sv-96 (logior sv-96 2048))
    (if (nonzero? (-> arg0 unknown-surface01 impact-hook))
        ((-> arg0 unknown-surface01 impact-hook) arg0 (the-as (pointer float) (-> sv-88 vector)) sv-84)
        )
    (when (not sv-240)
      (let ((f0-21 (- 1.0 (-> arg0 unknown-surface01 impact-fric))))
        (when (< f0-21 1.0)
          (let ((v1-113 (new-stack-vector0))
                (f1-13 (vector-dot (-> arg0 dynam gravity-normal) (the-as vector (-> sv-88 vector))))
                )
            0.0
            (vector-!
              v1-113
              (the-as vector (-> sv-88 vector))
              (vector-float*! v1-113 (-> arg0 dynam gravity-normal) f1-13)
              )
            (let* ((f2-2 (vector-length v1-113))
                   (f3-0 f2-2)
                   )
              (if (< f1-13 0.0)
                  (set! f1-13 (* f1-13 f0-21))
                  )
              (vector+!
                (the-as vector (-> sv-88 vector))
                (vector-float*! (the-as vector (-> sv-88 vector)) (-> arg0 dynam gravity-normal) f1-13)
                (vector-float*! v1-113 v1-113 (/ f2-2 f3-0))
                )
              )
            )
          )
        )
      )
    )
  (set! sv-96 (logior sv-96 4))
  (cond
    ((-> arg1 num-spheres)
     (set! sv-96 (logior sv-96 32))
     (set! (-> arg0 unknown-vector001 quad) (-> arg1 best-other-tri intersect quad))
     (set! (-> arg0 unknown-vector-kij1b231 quad) (-> arg0 poly-normal quad))
     (set! (-> arg0 unknown-handle00)
           (process->handle (-> (the-as collide-shape-prim (-> arg1 num-spheres)) cshape process))
           )
     )
    ((= (-> arg0 poly-pat material) (pat-material waterbottom))
     )
    (else
      (set! sv-96 (logior sv-96 4096))
      )
    )
  (cond
    (sv-240
      (set! sv-104 (logior sv-104 4))
      (set! sv-96 (logior sv-96 8))
      (set! (-> arg0 cur-pat mode) 1)
      (set! (-> arg0 unknown-vector24 quad) (-> arg1 best-other-tri intersect quad))
      (set! (-> arg0 unknown-vector-kj1hj2b3 quad) (-> arg0 poly-normal quad))
      (set! (-> arg0 unknown-vector25 quad) (-> sv-84 quad))
      (set! (-> arg0 unknown-pat-surface00) (-> arg1 best-other-tri pat))
      (cond
        ((and (logtest? (focus-status mech) (-> (the-as process-focusable (-> arg0 process)) focus-status))
              (logtest? sv-104 #x8000)
              (logtest? sv-104 32)
              (< 0.0 (vector-dot sv-84 (-> arg0 dynam gravity-normal)))
              (< 0.0 (vector-dot (the-as vector (-> sv-88 vector)) (-> arg0 dynam gravity-normal)))
              )
         (set! (-> arg0 surf) *edge-surface*)
         (set! sv-104 (logior #x10000 sv-104))
         (vector-flatten! arg2 (vector-negate! (new 'stack-no-clear 'vector) (-> arg0 dynam gravity-normal)) sv-84)
         (vector-normalize! arg2 (vector-dot arg2 (the-as vector (-> sv-88 vector))))
         )
        (else
          (vector-reflect-flat! arg2 (the-as vector (-> sv-88 vector)) sv-84)
          )
        )
      (cond
        ((and (or (and (>= (-> arg1 best-my-prim local-sphere w)
                           (vector-dot
                             (-> arg0 ground-poly-normal)
                             (vector-! (new 'stack-no-clear 'vector) (-> arg1 best-other-tri intersect) (-> arg0 grount-touch-point))
                             )
                           )
                       (< (- (-> self clock frame-counter) (-> arg0 unknown-time-frame05)) (seconds 0.3))
                       )
                  (logtest? sv-104 #x8000)
                  )
              (>= (vector-dot
                    (-> arg0 dynam gravity-normal)
                    (vector-! (new 'stack-no-clear 'vector) (-> arg1 best-other-tri intersect) (-> arg0 grount-touch-point))
                    )
                  0.0
                  )
              (and (< 0.0 (vector-dot (-> arg0 ground-poly-normal) arg2)) (zero? (logand sv-104 32)))
              )
         (set! sv-104 (logior sv-104 256))
         (set! sv-104 (logand -65 sv-104))
         (let ((s3-4 (vector-cross! (new 'stack-no-clear 'vector) (-> arg0 poly-normal) (-> arg0 ground-poly-normal))))
           (vector-normalize! s3-4 1.0)
           (vector-float*! arg2 s3-4 (vector-dot (the-as vector (-> sv-88 vector)) s3-4))
           )
         (vector+! arg2 arg2 (-> arg0 poly-normal))
         )
        (else
          )
        )
      )
    (else
      (set! sv-96 (logior sv-96 1))
      (set! (-> arg0 cur-pat mode) 0)
      (if (= (-> arg1 best-my-prim prim-id) 6)
          (set! (-> arg0 local-normal quad) (-> sv-84 quad))
          )
      (if (and (logtest? (focus-status board) (-> (the-as process-focusable (-> arg0 process)) focus-status))
               (not (logtest? (focus-status halfpipe) (-> (the-as process-focusable (-> arg0 process)) focus-status)))
               (!= (-> arg0 cur-pat mode) 3)
               (!= (-> arg0 ground-pat mode) 3)
               )
          (vector-reflect-flat-gravity! arg2 (the-as vector (-> sv-88 vector)) sv-84 (-> arg0 dynam gravity-normal))
          (vector-reflect-flat! arg2 (the-as vector (-> sv-88 vector)) sv-84)
          )
      (vector+! arg2 arg2 sv-84)
      (let ((f0-32 (-> arg0 unknown-surface01 slope-change-preserve)))
        (when (< 0.0 f0-32)
          (let ((v1-223 (new-stack-vector0)))
            (let ((f1-25 (vector-dot (-> arg0 unknown-vector14) (the-as vector (-> sv-88 vector)))))
              0.0
              (vector-! v1-223 (the-as vector (-> sv-88 vector)) (vector-float*! v1-223 (-> arg0 unknown-vector14) f1-25))
              )
            (let ((f1-26 (vector-length v1-223)))
              f1-26
              (let ((f1-27 f1-26)
                    (f2-5 (vector-length arg2))
                    )
                (if (and (< 409.6 (fabs (- f2-5 f1-27))) (< f2-5 f1-27))
                    (vector-normalize! arg2 (lerp-scale f2-5 f1-27 f0-32 0.0 1.0))
                    )
                )
              )
            )
          )
        )
      (set! (-> arg0 grount-touch-point w) 0.0)
      (when (not (logtest? sv-104 #x400f))
        (set! sv-96 (logior sv-96 2))
        (set! (-> arg0 ground-poly-normal quad) (-> arg0 poly-normal quad))
        (set! (-> arg0 unknown-vector22 quad) (-> sv-84 quad))
        (set! (-> arg0 unknown-float0000) (vector-dot sv-84 (-> arg0 dynam gravity-normal)))
        (set! (-> arg0 unknown-time-frame05) (-> self clock frame-counter))
        (set! (-> arg0 ground-pat) (-> arg0 poly-pat))
        (set! (-> arg0 grount-touch-point quad) (-> arg1 best-other-tri intersect quad))
        (set! (-> arg0 unknown-vector-kjh1n23k1 quad) (-> arg1 best-my-prim prim-core world-sphere quad))
        (set! sv-104 (logior sv-104 2048))
        (if (= (-> arg0 poly-pat material) (pat-material waterbottom))
            (set! sv-96 (logior sv-96 1024))
            )
        )
      )
    )
  (logior! (-> arg0 status) sv-96)
  (set! (-> arg0 reaction-flag) (the-as cshape-reaction-flags sv-104))
  (when *debug-segment*
    (+! (-> arg0 unknown-halfword00) 1)
    (let ((v1-260
            (clear-record-tags! *history* (history-channel surface-normal) (-> arg0 unknown-halfword00) (the-as uint 2))
            )
          )
      (set! (-> v1-260 origin quad) (-> arg1 best-other-tri intersect quad))
      (set! (-> v1-260 vector quad) (-> arg0 surface-normal quad))
      )
    (let ((v1-263
            (clear-record-tags! *history* (history-channel local-normal) (-> arg0 unknown-halfword00) (the-as uint 2))
            )
          )
      (set! (-> v1-263 origin quad) (-> arg1 best-other-tri intersect quad))
      (set! (-> v1-263 vector quad) (-> arg0 local-normal quad))
      )
    (set! (-> (clear-record-tags! *history* (history-channel intersect) (-> arg0 unknown-halfword00) (the-as uint 2))
              vector
              quad
              )
          (-> arg1 best-other-tri intersect quad)
          )
    (let ((v1-269
            (clear-record-tags! *history* (history-channel transv-out) (-> arg0 unknown-halfword00) (the-as uint 2))
            )
          )
      (set! (-> v1-269 origin quad) (-> arg1 best-other-tri intersect quad))
      (set! (-> v1-269 vector quad) (-> arg2 quad))
      )
    (let ((v1-272
            (clear-record-tags! *history* (history-channel transv-in) (-> arg0 unknown-halfword00) (the-as uint 2))
            )
          )
      (set! (-> v1-272 origin quad) (-> arg1 best-other-tri intersect quad))
      (set! (-> v1-272 vector quad) (-> sv-88 vector 1 quad))
      )
    (let ((v1-275 (clear-record-tags! *history* (history-channel transv) (-> arg0 unknown-halfword00) (the-as uint 2)))
          )
      (set! (-> v1-275 origin quad) (-> arg0 trans quad))
      (set! (-> v1-275 vector quad) (-> arg0 transv quad))
      )
    (set! (-> (clear-record-tags! *history* (history-channel trans) (-> arg0 unknown-halfword00) (the-as uint 2))
              vector
              quad
              )
          (-> arg0 trans quad)
          )
    (let ((v1-281 (clear-record-tags! *history* (history-channel pat) (-> arg0 unknown-halfword00) (the-as uint 2))))
      (set! (-> v1-281 vector x) (the-as float (-> arg0 cur-pat)))
      )
    (let ((v1-283
            (clear-record-tags! *history* (history-channel collide-status) (-> arg0 unknown-halfword00) (the-as uint 2))
            )
          )
      (set! (-> v1-283 collide-status) (-> arg0 status))
      (set! (-> v1-283 vector z) (the-as float (-> arg0 reaction-flag)))
      )
    )
  (the-as collide-status sv-96)
  )

;; definition for function target-collision-no-reaction
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defun target-collision-no-reaction ((arg0 control-info) (arg1 collide-query) (arg2 vector) (arg3 vector))
  (if (= (-> arg0 unknown-surface00 mode) 'air)
      (logior! (-> arg0 reaction-flag) (cshape-reaction-flags csrf05))
      )
  (when *debug-segment*
    (+! (-> arg0 unknown-halfword00) 1)
    (let ((v1-9
            (clear-record-tags! *history* (history-channel transv-out) (-> arg0 unknown-halfword00) (the-as uint 2))
            )
          )
      (set! (-> v1-9 origin quad) (-> arg0 trans quad))
      (set! (-> v1-9 vector quad) (-> arg2 quad))
      )
    (let ((v1-12
            (clear-record-tags! *history* (history-channel transv-in) (-> arg0 unknown-halfword00) (the-as uint 2))
            )
          )
      (set! (-> v1-12 origin quad) (-> arg0 trans quad))
      (set! (-> v1-12 vector quad) (-> arg3 quad))
      )
    (let ((v1-15 (clear-record-tags! *history* (history-channel transv) (-> arg0 unknown-halfword00) (the-as uint 2))))
      (set! (-> v1-15 origin quad) (-> arg0 trans quad))
      (set! (-> v1-15 vector quad) (-> arg0 transv quad))
      )
    (set! (-> (clear-record-tags! *history* (history-channel trans) (-> arg0 unknown-halfword00) (the-as uint 2))
              vector
              quad
              )
          (-> arg0 trans quad)
          )
    (let ((v1-21
            (clear-record-tags! *history* (history-channel collide-status) (-> arg0 unknown-halfword00) (the-as uint 2))
            )
          )
      (set! (-> v1-21 collide-status) (logior (-> arg0 status) (collide-status no-touch)))
      (set! (-> v1-21 vector z) (the-as float (-> arg0 reaction-flag)))
      )
    )
  0
  (none)
  )

;; definition for symbol *collide-edge-board-spec*, type collide-edge-spec
(define *collide-edge-board-spec* (new 'static 'collide-edge-spec
                                    :split-dists (new 'static 'array float 2 1024.0 1433.6)
                                    :outward-offset (new 'static 'vector :x 708.608 :y 13312.0 :w 1.0)
                                    :flags (collide-edge-spec-flags find-adjacent-edge send-event)
                                    :ignore-pat (new 'static 'pat-surface :noentity #x1 :nogrind #x1 :probe #x1)
                                    :max-dist-sqrd-to-outward-pt 67108864.0
                                    :max-dir-cosa-delta -1.0
                                    :max-dir-cosa-player -2.0
                                    :touching-segment #f
                                    :local-cache-fill-box (new 'static 'bounding-box
                                      :min (new 'static 'vector :x -12288.0 :y -11059.2 :z -12288.0 :w 1.0)
                                      :max (new 'static 'vector :x 12288.0 :y 16384.0 :z 12288.0 :w 1.0)
                                      )
                                    :local-within-reach-box (new 'static 'bounding-box
                                      :min (new 'static 'vector :x -11878.4 :y -2867.2 :z -11878.4 :w 1.0)
                                      :max (new 'static 'vector :x 11878.4 :y 2867.2 :z 11878.4 :w 1.0)
                                      )
                                    :local-player-spheres (new 'static 'inline-array sphere 12
                                      (new 'static 'sphere :x 2539.52 :y -819.2 :r 1433.6)
                                      (new 'static 'sphere :x 2539.52 :y -819.2 :r 1433.6)
                                      (new 'static 'sphere :x 2539.52 :y -819.2 :r 1433.6)
                                      (new 'static 'sphere :x 2539.52 :y -819.2 :r 1433.6)
                                      (new 'static 'sphere :x 2539.52 :y -819.2 :r 1433.6)
                                      (new 'static 'sphere :x 2539.52 :y -819.2 :r 1433.6)
                                      (new 'static 'sphere :x -737.28 :y 4096.0 :r 3072.0)
                                      (new 'static 'sphere :x -737.28 :y 6553.6 :r 3072.0)
                                      (new 'static 'sphere :x -737.28 :y 9420.8 :r 3072.0)
                                      (new 'static 'sphere :x 1720.32 :y 3686.4 :r 2949.12)
                                      (new 'static 'sphere :x 1720.32 :y 5734.4 :r 2949.12)
                                      (new 'static 'sphere :x 1720.32 :y 8601.6 :r 2949.12)
                                      )
                                    )
        )

;; definition for function rail-surface-touch
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defbehavior rail-surface-touch target ()
  (when (>= (- (-> self clock frame-counter) (-> self control unknown-time-frame02)) (seconds 0.2))
    (logclear! (-> *collide-edge-board-spec* flags) (collide-edge-spec-flags one send-event))
    (set! (-> *collide-edge-board-spec* touching-segment) #f)
    (do-edge-grabs *target* *collide-cache* *collide-edge-board-spec*)
    (logior! (-> *collide-edge-board-spec* flags) (collide-edge-spec-flags send-event))
    (let ((gp-0 *edge-grab-info*))
      (when (-> gp-0 found-edge?)
        (vector-normalize!
          (vector-! (-> self control unknown-vector34) (the-as vector (-> gp-0 world-vertex)) (-> gp-0 world-vertex 1))
          1.0
          )
        (set! (-> self control unknown-vector36 quad) (-> gp-0 hanging-matrix vector 0 quad))
        (send-event
          self
          'push-transv
          (vector-float*!
            (new 'stack-no-clear 'vector)
            (-> self control unknown-vector36)
            (seek
              (vector-length (-> self control unknown-vector18))
              40960.0
              (* 81920.0 (-> self clock seconds-per-frame))
              )
            )
          90
          )
        )
      )
    )
  0
  (none)
  )

;; definition for function gravel-surface-touch
;; WARN: Return type mismatch int vs none.
(defun gravel-surface-touch ()
  0
  (none)
  )
