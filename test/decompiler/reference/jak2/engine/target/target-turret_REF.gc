;;-*-Lisp-*-
(in-package goal)

;; failed to figure out what this is:
(defpartgroup group-turret-explode
  :id 201
  :duration (seconds 0.5)
  :linger-duration (seconds 1)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 15)
  :parts ((sp-item 924 :period (seconds 5) :length (seconds 0.085) :offset -10)
    (sp-item 925 :fade-after (meters 60) :period (seconds 5) :length (seconds 0.1))
    (sp-item 926 :fade-after (meters 60) :falloff-to (meters 60) :period (seconds 5) :length (seconds 0.335))
    (sp-item 927 :fade-after (meters 200) :falloff-to (meters 200) :period (seconds 5) :length (seconds 0.167))
    (sp-item 928 :period (seconds 5) :length (seconds 0.017) :offset -10)
    (sp-item 929 :fade-after (meters 150) :falloff-to (meters 150) :period (seconds 5) :length (seconds 0.167))
    )
  )

;; failed to figure out what this is:
(defpart 927
  :init-specs ((:texture (new 'static 'texture-id :index #x34 :page #xc))
    (:num 1.0 1.0)
    (:scale-x (meters 1) (meters 1))
    (:rot-z (degrees 0) (degrees 360) :store)
    (:scale-y (meters 0.8) (meters 0.2))
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 32.0 32.0)
    (:vel-y (meters 0.02) (meters 0.01))
    (:scalevel-x (meters 0.01) (meters 0.13333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -0.36)
    (:fade-b -4.24)
    (:fade-a -0.22068965)
    (:friction 0.95)
    (:timer (seconds 3.335))
    (:flags (sp-cpuinfo-flag-2))
    (:func 'sparticle-motion-blur)
    (:next-time (seconds 0.085) (seconds 0.015))
    (:next-launcher 930)
    (:conerot-x '*sp-temp*)
    )
  )

;; failed to figure out what this is:
(defpart 929
  :init-specs ((:texture (new 'static 'texture-id :index #x33 :page #xc))
    (:num 1.0 1.0)
    (:scale-x (meters 1) (meters 1))
    (:rot-z (degrees 0))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 0.0)
    (:vel-y (meters 0.02) (meters 0.01))
    (:scalevel-x (meters 0.01) (meters 0.13333334))
    (:rotvel-z (degrees -0.12) (degrees 0.24))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -0.36)
    (:fade-b -4.24)
    (:fade-a 0.22068965)
    (:friction 0.95)
    (:timer (seconds 3.335))
    (:flags (sp-cpuinfo-flag-2))
    (:next-time (seconds 0.085) (seconds 0.015))
    (:next-launcher 930)
    (:conerot-x (degrees 0) (degrees 360))
    )
  )

;; failed to figure out what this is:
(defpart 930
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0) (:next-time (seconds 0.017) (seconds 0.065)) (:next-launcher 931))
  )

;; failed to figure out what this is:
(defpart 931
  :init-specs ((:scalevel-x (meters 0.016666668) (meters 0.016666668))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.44)
    (:fade-g -2.36)
    (:fade-b -2.64)
    (:next-time (seconds 0.117) (seconds 0.047))
    (:next-launcher 932)
    )
  )

;; failed to figure out what this is:
(defpart 932
  :init-specs ((:scalevel-x (meters 0.008333334) (meters 0.008333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -1.2944444)
    (:fade-g -0.7111111)
    (:fade-b -0.094444446)
    (:fade-a -0.06545454 -0.06545454)
    (:next-time (seconds 0.5) (seconds 0.097))
    (:next-launcher 933)
    )
  )

;; failed to figure out what this is:
(defpart 933
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0))
  )

;; failed to figure out what this is:
(defpart 928
  :init-specs ((:texture (new 'static 'texture-id :index #x47 :page #xc))
    (:num 1.0)
    (:scale-x (meters 5))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 96.0)
    (:scalevel-x (meters 0.5))
    (:rotvel-z (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -1.28)
    (:fade-b -5.1)
    (:fade-a 0.0)
    (:timer (seconds 0.335))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:next-time (seconds 0.167))
    (:next-launcher 934)
    )
  )

;; failed to figure out what this is:
(defpart 934
  :init-specs ((:scalevel-x (meters -0.2))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -2.56)
    (:fade-b 0.0)
    (:fade-a -1.92)
    )
  )

;; failed to figure out what this is:
(defpart 926
  :init-specs ((:texture (new 'static 'texture-id :index #x32 :page #xc))
    (:num 5.0 3.0)
    (:x (meters 0.25))
    (:scale-x (meters 1) (meters 0.25))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 16.0 48.0)
    (:vel-y (meters 0.083333336) (meters 0.083333336))
    (:scalevel-x (meters 0.006666667) (meters 0.0016666667))
    (:rotvel-z (degrees -0.12) (degrees 0.24))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -0.18)
    (:fade-b -2.12)
    (:accel-y (meters -0.00016666666) (meters -0.00033333333))
    (:friction 0.87)
    (:timer (seconds 3.335))
    (:flags (sp-cpuinfo-flag-2))
    (:next-time (seconds 0.117) (seconds 0.047))
    (:next-launcher 935)
    (:conerot-x (degrees 0) (degrees 360))
    )
  )

;; failed to figure out what this is:
(defpart 935
  :init-specs ((:scalevel-x (meters 0.0016666667))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g 0.02)
    (:fade-b 0.23555556)
    (:next-time (seconds 0.15) (seconds 0.047))
    (:next-launcher 936)
    )
  )

;; failed to figure out what this is:
(defpart 936
  :init-specs ((:fade-r -0.5543478) (:fade-g -0.5543478) (:fade-a -0.13913043))
  )

;; failed to figure out what this is:
(defpart 924
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 3.0 1.0)
    (:x (meters 0) (meters 0.6))
    (:scale-x (meters 2) (meters 1.5))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 70.0 20.0)
    (:g 70.0 20.0)
    (:b 70.0 20.0)
    (:a 0.0 40.0)
    (:vel-y (meters 0) (meters 0.1))
    (:scalevel-x (meters 0.033333335) (meters 0.016666668))
    (:rotvel-z (degrees -0.12) (degrees 0.24))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 3.3)
    (:fade-g 3.12)
    (:fade-b 1.18)
    (:fade-a 1.76)
    (:friction 0.88)
    (:timer (seconds 2.367))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:next-time (seconds 0.117) (seconds 0.047))
    (:next-launcher 937)
    (:conerot-x (degrees 0) (degrees 360))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

;; failed to figure out what this is:
(defpart 937
  :init-specs ((:scalevel-x (meters 0.0033333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.53333336)
    (:fade-g -1.9666667)
    (:fade-b -2.2)
    (:fade-a -0.41666666)
    (:next-time (seconds 0.15) (seconds 0.047))
    (:next-launcher 938)
    )
  )

;; failed to figure out what this is:
(defpart 938
  :init-specs ((:scalevel-x (meters 0))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.38833332)
    (:fade-g -0.21333334)
    (:fade-b -0.028333334)
    (:fade-a -0.38833332)
    )
  )

;; failed to figure out what this is:
(defpart 925
  :init-specs ((:texture (new 'static 'texture-id :index #x31 :page #xc))
    (:num 4.0 2.0)
    (:scale-x (meters 0.1) (meters 0.25))
    (:rot-x 4)
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.2) (meters 0.1))
    (:r 128.0 128.0)
    (:g 96.0)
    (:b 64.0)
    (:a 64.0 64.0)
    (:scalevel-x (meters 0.13333334) (meters 0.02))
    (:fade-g 1.6)
    (:fade-b 3.2)
    (:fade-a -1.6)
    (:timer (seconds 0.267))
    (:flags (sp-cpuinfo-flag-2))
    )
  )

;; definition of type hud-turret-health
(deftype hud-turret-health (hud)
  ((fade-interp  float)
   )
  )

;; definition for method 3 of type hud-turret-health
(defmethod inspect ((this hud-turret-health))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type hud inspect)))
    (t9-0 this)
    )
  (format #t "~2Tfade-interp: ~f~%" (-> this fade-interp))
  (label cfg-4)
  this
  )

;; definition for method 15 of type hud-turret-health
;; WARN: Return type mismatch int vs none.
(defmethod draw ((this hud-turret-health))
  (with-pp
    (seek!
      (-> this fade-interp)
      (if (>= (-> *camera-combiner* interp-val) 1.0)
          80.0
          0.0
          )
      (-> pp clock time-adjust-ratio)
      )
    (dotimes (v1-3 30)
      (set! (-> this sprites v1-3 color w) (the int (* (-> this fade-interp) (- 1.0 (-> this offset)))))
      )
    (set-as-offset-from! (-> this sprites 1) (the-as vector4w (-> this sprites)) 44 0)
    (set-as-offset-from! (-> this sprites 2) (the-as vector4w (-> this sprites)) 0 44)
    (set-as-offset-from! (-> this sprites 3) (the-as vector4w (-> this sprites)) 44 44)
    (dotimes (v1-6 16)
      (set! (-> this sprites (- 19 v1-6) scale-x) (if (< v1-6 (-> this values 0 current))
                                                      0.7
                                                      0.0
                                                      )
            )
      )
    (set-as-offset-from! (-> this sprites 4) (the-as vector4w (-> this sprites)) 13 6)
    (set-as-offset-from! (-> this sprites 5) (the-as vector4w (-> this sprites)) 25 10)
    (set-as-offset-from! (-> this sprites 6) (the-as vector4w (-> this sprites)) 34 19)
    (set-as-offset-from! (-> this sprites 7) (the-as vector4w (-> this sprites)) 39 32)
    (set-as-offset-from! (-> this sprites 8) (the-as vector4w (-> this sprites)) 39 47)
    (set-as-offset-from! (-> this sprites 9) (the-as vector4w (-> this sprites)) 34 59)
    (set-as-offset-from! (-> this sprites 10) (the-as vector4w (-> this sprites)) 25 67)
    (set-as-offset-from! (-> this sprites 11) (the-as vector4w (-> this sprites)) 13 71)
    (set-as-offset-from! (-> this sprites 12) (the-as vector4w (-> this sprites)) -1 71)
    (set-as-offset-from! (-> this sprites 13) (the-as vector4w (-> this sprites)) -14 67)
    (set-as-offset-from! (-> this sprites 14) (the-as vector4w (-> this sprites)) -22 59)
    (set-as-offset-from! (-> this sprites 15) (the-as vector4w (-> this sprites)) -27 47)
    (set-as-offset-from! (-> this sprites 16) (the-as vector4w (-> this sprites)) -27 32)
    (set-as-offset-from! (-> this sprites 17) (the-as vector4w (-> this sprites)) -22 19)
    (set-as-offset-from! (-> this sprites 18) (the-as vector4w (-> this sprites)) -14 10)
    (set-as-offset-from! (-> this sprites 19) (the-as vector4w (-> this sprites)) -1 6)
    (let ((f0-9 (the float (-> this values 1 current))))
      (cond
        ((>= f0-9 100.0)
         (let ((f0-10 (if (< 100 (mod (-> *display* game-clock frame-counter) 200))
                          0.0
                          90.0
                          )
                      )
               )
           (set! (-> this sprites 26 angle) (* 182.04445 (- 270.0 f0-10)))
           (set! (-> this sprites 24 angle) (* 182.04445 (- f0-10)))
           (set! (-> this sprites 22 angle) (* 182.04445 (- 90.0 f0-10)))
           (set! (-> this sprites 20 angle) (* 182.04445 (- 180.0 f0-10)))
           )
         )
        ((< 75.0 f0-9)
         (set! (-> this sprites 26 angle) (* 182.04445 (- 180.0 (* 3.6 (+ -75.0 f0-9)))))
         (set! (-> this sprites 24 angle) 32768.0)
         (set! (-> this sprites 22 angle) 49152.0)
         (set! (-> this sprites 20 angle) 0.0)
         )
        ((< 50.0 f0-9)
         (set! (-> this sprites 26 angle) 32768.0)
         (set! (-> this sprites 24 angle) (* 182.04445 (- 270.0 (* 3.6 (+ -50.0 f0-9)))))
         (set! (-> this sprites 22 angle) 49152.0)
         (set! (-> this sprites 20 angle) 0.0)
         )
        ((< 25.0 f0-9)
         (set! (-> this sprites 26 angle) 32768.0)
         (set! (-> this sprites 24 angle) 49152.0)
         (set! (-> this sprites 22 angle) (* 182.04445 (- (* 3.6 (+ -25.0 f0-9)))))
         (set! (-> this sprites 20 angle) 0.0)
         )
        (else
          (set! (-> this sprites 26 angle) 32768.0)
          (set! (-> this sprites 24 angle) 49152.0)
          (set! (-> this sprites 22 angle) 0.0)
          (set! (-> this sprites 20 angle) (* 182.04445 (- 90.0 (* 3.6 f0-9))))
          )
        )
      )
    (set-as-offset-from! (-> this sprites 20) (the-as vector4w (-> this sprites)) 0 45)
    (set-as-offset-from! (-> this sprites 22) (the-as vector4w (-> this sprites)) 0 44)
    (set-as-offset-from! (-> this sprites 24) (the-as vector4w (-> this sprites)) 2 44)
    (set-as-offset-from! (-> this sprites 26) (the-as vector4w (-> this sprites)) 2 45)
    (set-as-offset-from! (-> this sprites 21) (the-as vector4w (-> this sprites)) 0 14)
    (set-as-offset-from! (-> this sprites 23) (the-as vector4w (-> this sprites)) 0 44)
    (set-as-offset-from! (-> this sprites 25) (the-as vector4w (-> this sprites)) -30 44)
    (set-as-offset-from! (-> this sprites 27) (the-as vector4w (-> this sprites)) -30 14)
    (set-as-offset-from! (-> this sprites 29) (the-as vector4w (-> this sprites)) -10 36)
    (let ((f0-34 (if (and (= (-> this values 4 current) 1) (< 25 (mod (-> *display* game-clock frame-counter) 50)))
                     250.0
                     100.0
                     )
                 )
          )
      (set! (-> this sprites 29 color x) (the int f0-34))
      (set! (-> this sprites 29 color y) (the int (if (>= (-> this values 1 current) 100)
                                                      0.0
                                                      f0-34
                                                      )
                                              )
            )
      )
    (set! (-> this sprites 29 color z) (-> this sprites 29 color y))
    (let ((f30-0 (- (the float (-> this values 3 current)))))
      (let ((a1-31 (new 'stack-no-clear 'vector)))
        (set! (-> a1-31 x) 128.0)
        (set! (-> a1-31 y) 128.0)
        (set! (-> a1-31 z) 128.0)
        (set! (-> a1-31 w) 0.0)
        (let ((a2-29 (new 'stack-no-clear 'vector)))
          (set! (-> a2-29 x) 255.0)
          (set! (-> a2-29 y) 24.0)
          (set! (-> a2-29 z) 32.0)
          (set! (-> a2-29 w) 0.0)
          (let ((s5-0 (new 'stack-no-clear 'vector)))
            (vector-lerp! s5-0 a1-31 a2-29 (* 0.01 (the float (-> this values 5 current))))
            (vector-cvt.w.s! (the-as vector (-> this sprites 28 color2)) s5-0)
            )
          )
        )
      (set! (-> this sprites 28 color w)
            (the int (* 0.00390625 (-> this fade-interp) (the float (-> this values 2 current))))
            )
      (set-as-offset-from!
        (-> this sprites 28)
        (the-as vector4w (-> this sprites))
        (the int (* -70.0 (sin f30-0)))
        (+ (the int (* -70.0 (cos f30-0))) 44)
        )
      (set! (-> this sprites 28 angle) (+ -8192.0 f30-0))
      )
    ((method-of-type hud draw) this)
    0
    (none)
    )
  )

;; definition for method 16 of type hud-turret-health
;; WARN: Return type mismatch int vs none.
(defmethod update-values ((this hud-turret-health))
  (set! (-> this values 0 target) (the int (-> *game-info* score)))
  ((method-of-type hud update-values) this)
  0
  (none)
  )

;; definition for method 18 of type hud-turret-health
(defmethod event-callback ((this hud-turret-health) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('set-heat)
     (set! (-> this values 1 target) (the int (* 100.0 (the-as float (-> arg3 param 0)))))
     )
    (('set-arrow-alpha)
     (set! (-> this values 2 target) (the int (* 256.0 (the-as float (-> arg3 param 0)))))
     )
    (('set-arrow-angle)
     (set! (-> this values 3 target) (the int (the-as float (-> arg3 param 0))))
     )
    (('set-target-flash)
     (set! (-> this values 4 target) (if (-> arg3 param 0)
                                         1
                                         0
                                         )
           )
     )
    (('set-arrow-red)
     (set! (-> this values 5 target) (the int (* 100.0 (the-as float (-> arg3 param 0)))))
     )
    (('set-hud-pos)
     (set-hud-piece-position!
       (the-as hud-sprite (-> this sprites))
       (the-as int (-> arg3 param 0))
       (the-as int (+ (-> arg3 param 1) -4))
       )
     )
    )
  ((method-of-type hud event-callback) this arg0 arg1 arg2 arg3)
  )

;; definition for function init-turret-hud
;; WARN: Return type mismatch int vs none.
(defun init-turret-hud ((arg0 hud-turret-health) (arg1 string))
  (set! (-> arg0 gui-id)
        (add-process *gui-control* arg0 (gui-channel hud-middle-right) (gui-action hidden) (-> arg0 name) 81920.0 0)
        )
  (logior! (-> arg0 flags) (hud-flags show))
  (set! (-> arg0 fade-interp) 0.0)
  (dotimes (v1-4 30)
    (set! (-> arg0 sprites v1-4 scale-x) 0.7)
    (set! (-> arg0 sprites v1-4 scale-y) 0.7)
    (set! (-> arg0 sprites v1-4 pos z) #xfffff0)
    )
  (set! (-> arg0 sprites 0 tex)
        (lookup-texture-by-name "drill-turret-hud-ring-01" arg1 (the-as (pointer texture-page) #f))
        )
  (set! (-> arg0 sprites 0 flags) (the-as uint 4))
  (set! (-> arg0 sprites 1 tex) (-> arg0 sprites 0 tex))
  (set! (-> arg0 sprites 1 flags) (the-as uint 5))
  (set! (-> arg0 sprites 2 tex) (-> arg0 sprites 0 tex))
  (set! (-> arg0 sprites 2 flags) (the-as uint 6))
  (set! (-> arg0 sprites 3 tex) (-> arg0 sprites 0 tex))
  (set! (-> arg0 sprites 3 flags) (the-as uint 7))
  (set! (-> arg0 sprites 4 tex)
        (lookup-texture-by-name "drill-turret-hud-health-04" arg1 (the-as (pointer texture-page) #f))
        )
  (set! (-> arg0 sprites 4 flags) (the-as uint 5))
  (set! (-> arg0 sprites 5 tex)
        (lookup-texture-by-name "drill-turret-hud-health-03" arg1 (the-as (pointer texture-page) #f))
        )
  (set! (-> arg0 sprites 5 flags) (the-as uint 5))
  (set! (-> arg0 sprites 6 tex)
        (lookup-texture-by-name "drill-turret-hud-health-02" arg1 (the-as (pointer texture-page) #f))
        )
  (set! (-> arg0 sprites 6 flags) (the-as uint 5))
  (set! (-> arg0 sprites 7 tex)
        (lookup-texture-by-name "drill-turret-hud-health-01" arg1 (the-as (pointer texture-page) #f))
        )
  (set! (-> arg0 sprites 7 flags) (the-as uint 5))
  (set! (-> arg0 sprites 8 tex) (-> arg0 sprites 7 tex))
  (set! (-> arg0 sprites 8 flags) (the-as uint 7))
  (set! (-> arg0 sprites 9 tex) (-> arg0 sprites 6 tex))
  (set! (-> arg0 sprites 9 flags) (the-as uint 7))
  (set! (-> arg0 sprites 10 tex) (-> arg0 sprites 5 tex))
  (set! (-> arg0 sprites 10 flags) (the-as uint 7))
  (set! (-> arg0 sprites 11 tex) (-> arg0 sprites 4 tex))
  (set! (-> arg0 sprites 11 flags) (the-as uint 7))
  (set! (-> arg0 sprites 12 tex) (-> arg0 sprites 4 tex))
  (set! (-> arg0 sprites 12 flags) (the-as uint 6))
  (set! (-> arg0 sprites 13 tex) (-> arg0 sprites 5 tex))
  (set! (-> arg0 sprites 13 flags) (the-as uint 6))
  (set! (-> arg0 sprites 14 tex) (-> arg0 sprites 6 tex))
  (set! (-> arg0 sprites 14 flags) (the-as uint 6))
  (set! (-> arg0 sprites 15 tex) (-> arg0 sprites 7 tex))
  (set! (-> arg0 sprites 15 flags) (the-as uint 6))
  (set! (-> arg0 sprites 16 tex) (-> arg0 sprites 7 tex))
  (set! (-> arg0 sprites 16 flags) (the-as uint 4))
  (set! (-> arg0 sprites 17 tex) (-> arg0 sprites 6 tex))
  (set! (-> arg0 sprites 17 flags) (the-as uint 4))
  (set! (-> arg0 sprites 18 tex) (-> arg0 sprites 5 tex))
  (set! (-> arg0 sprites 18 flags) (the-as uint 4))
  (set! (-> arg0 sprites 19 tex) (-> arg0 sprites 4 tex))
  (set! (-> arg0 sprites 19 flags) (the-as uint 4))
  (set! (-> arg0 sprites 20 tex)
        (lookup-texture-by-name "hud-transparent-01" (the-as string #f) (the-as (pointer texture-page) #f))
        )
  (set! (-> arg0 sprites 20 pos z) #xfffff1)
  (set! (-> arg0 sprites 21 tex)
        (lookup-texture-by-name "drill-turret-hud-heat-ring-02" arg1 (the-as (pointer texture-page) #f))
        )
  (set! (-> arg0 sprites 21 pos z) #xfffff0)
  (set! (-> arg0 sprites 22 tex) (-> arg0 sprites 20 tex))
  (set! (-> arg0 sprites 22 pos z) #xfffff3)
  (set! (-> arg0 sprites 23 tex)
        (lookup-texture-by-name "drill-turret-hud-heat-ring-04" arg1 (the-as (pointer texture-page) #f))
        )
  (set! (-> arg0 sprites 23 pos z) #xfffff2)
  (set! (-> arg0 sprites 24 tex) (-> arg0 sprites 20 tex))
  (set! (-> arg0 sprites 24 pos z) #xfffff5)
  (set! (-> arg0 sprites 25 tex)
        (lookup-texture-by-name "drill-turret-hud-heat-ring-03" arg1 (the-as (pointer texture-page) #f))
        )
  (set! (-> arg0 sprites 25 pos z) #xfffff4)
  (set! (-> arg0 sprites 26 tex) (-> arg0 sprites 20 tex))
  (set! (-> arg0 sprites 26 pos z) #xfffff7)
  (set! (-> arg0 sprites 27 tex)
        (lookup-texture-by-name "drill-turret-hud-heat-ring-01" arg1 (the-as (pointer texture-page) #f))
        )
  (set! (-> arg0 sprites 27 pos z) #xfffff6)
  (set! (-> arg0 sprites 28 tex)
        (lookup-texture-by-name "drill-turret-hud-arrow-01" arg1 (the-as (pointer texture-page) #f))
        )
  (set! (-> arg0 sprites 28 pos z) #xffffff)
  (set! (-> arg0 sprites 29 tex)
        (lookup-texture-by-name "drill-turret-hud-centre-01" arg1 (the-as (pointer texture-page) #f))
        )
  (set! (-> arg0 sprites 29 pos z) #xffffff)
  (set! (-> arg0 sprites 20 scale-x) 8.0)
  (set! (-> arg0 sprites 20 scale-y) 8.0)
  (set! (-> arg0 sprites 22 scale-x) 8.0)
  (set! (-> arg0 sprites 22 scale-y) 8.0)
  (set! (-> arg0 sprites 24 scale-x) 8.0)
  (set! (-> arg0 sprites 24 scale-y) 8.0)
  (set! (-> arg0 sprites 26 scale-x) 8.0)
  (set! (-> arg0 sprites 26 scale-y) 8.0)
  0
  (none)
  )

;; definition of type hud-drill-turret-health
(deftype hud-drill-turret-health (hud-turret-health)
  ()
  )

;; definition for method 3 of type hud-drill-turret-health
(defmethod inspect ((this hud-drill-turret-health))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type hud-turret-health inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 17 of type hud-drill-turret-health
;; WARN: Return type mismatch int vs none.
(defmethod init-callback ((this hud-drill-turret-health))
  (set! (-> this level) (level-get *level* 'drillmid))
  (init-turret-hud this "drillmid-minimap")
  ((method-of-type hud init-callback) this)
  0
  (none)
  )

;; definition of type hud-port-turret-health
(deftype hud-port-turret-health (hud-turret-health)
  ()
  )

;; definition for method 3 of type hud-port-turret-health
(defmethod inspect ((this hud-port-turret-health))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type hud-turret-health inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 17 of type hud-port-turret-health
;; WARN: Return type mismatch int vs none.
(defmethod init-callback ((this hud-port-turret-health))
  (set! (-> this level) (level-get *level* 'portblmp))
  (init-turret-hud this "portblmp-minimap")
  ((method-of-type hud init-callback) this)
  0
  (none)
  )

;; definition of type turret-info
(deftype turret-info (basic)
  ((process   (pointer process))
   (handle    handle)
   (turret    (pointer base-turret))
   (grabbed?  symbol)
   (quat      quaternion  :inline)
   (trans     vector      :inline)
   )
  )

;; definition for method 3 of type turret-info
(defmethod inspect ((this turret-info))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this (-> this type))
  (format #t "~1Tprocess: #x~X~%" (-> this process))
  (format #t "~1Thandle: ~D~%" (-> this handle))
  (format #t "~1Tturret: #x~X~%" (-> this turret))
  (format #t "~1Tgrabbed?: ~A~%" (-> this grabbed?))
  (format #t "~1Tquat: #<quaternion @ #x~X>~%" (-> this quat))
  (format #t "~1Ttrans: ~`vector`P~%" (-> this trans))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defskelgroup skel-turret drill-turret-ext drill-turret-ext-lod0-jg drill-turret-ext-idle-ja
              ((drill-turret-ext-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 1.8 0 3.8)
              :origin-joint-index 3
              )

;; failed to figure out what this is:
(defskelgroup skel-turret-explode drill-turret-ext drill-turret-ext-explode-lod0-jg drill-turret-ext-explode-idle-ja
              ((drill-turret-ext-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 1.8 0 3.8)
              :origin-joint-index 3
              )

;; definition for symbol *turret-exploder-params*, type joint-exploder-static-params
(define *turret-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index -1)
      )
    :collide-spec #x1
    )
  )

;; definition of type turret-path-event
(deftype turret-path-event (structure)
  ((pos         float)
   (event-type  symbol)
   (param       object)
   )
  )

;; definition for method 3 of type turret-path-event
(defmethod inspect ((this turret-path-event))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'turret-path-event)
  (format #t "~1Tpos: ~f~%" (-> this pos))
  (format #t "~1Tevent-type: ~A~%" (-> this event-type))
  (format #t "~1Tparam: ~A~%" (-> this param))
  (label cfg-4)
  this
  )

;; definition of type turret-path
(deftype turret-path (structure)
  ((event-count  int32)
   (event-tbl    (inline-array turret-path-event))
   )
  )

;; definition for method 3 of type turret-path
(defmethod inspect ((this turret-path))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'turret-path)
  (format #t "~1Tevent-count: ~D~%" (-> this event-count))
  (format #t "~1Tevent-tbl: #x~X~%" (-> this event-tbl))
  (label cfg-4)
  this
  )

;; definition of type base-turret
(deftype base-turret (process-focusable)
  ((hud                    handle)
   (condition              int32)
   (shadow-backup          symbol)
   (rider                  handle)
   (actor-group            (pointer actor-group))
   (actor-group-count      int32)
   (alt-actor              symbol)
   (smush-control          smush-control        :inline)
   (sound-id               sound-id             3)
   (sound-playing          symbol               3)
   (cam-string-vector      vector               :inline)
   (path-event             turret-path)
   (path-u                 float)
   (path-u-prev            float)
   (path-mode              uint16)
   (path-speed             float)
   (path-speed-mult        float)
   (path-speed-mult-final  float)
   (path-old-pos           vector               :inline)
   (path-direction         symbol)
   (pause-proc             (function base-turret symbol))
   (gun-recoil-jmod        joint-mod-add-local  4)
   (gun-index              int32)
   (shot-timeout           time-frame)
   (fire-time              time-frame)
   (fire-time-interval     time-frame)
   (enable-controls        symbol)
   (available-for-pickup   symbol)
   (roty                   degrees)
   (rotyv                  degrees)
   (rotyvv                 degrees)
   (roty-min               degrees)
   (roty-max               degrees)
   (rotx                   degrees)
   (rotxv                  degrees)
   (rotxvv                 degrees)
   (rotx-min               degrees)
   (rotx-max               degrees)
   (target-quat            quaternion           :inline)
   (init-quat              quaternion           :inline)
   (health                 float)
   (track-handle           handle)
   (heat                   float)
   (heat-target            float)
   (arrow-angle            degrees)
   (arrow-alpha            float)
   (arrow-red              float)
   (red-filter-timer       time-frame)
   (ride-height            float)
   )
  (:state-methods
    idle
    setup
    active
    shutdown
    dormant
    die
    )
  (:methods
    (turret-init! (_type_ entity-actor matrix) none)
    (base-turret-method-34 (_type_ process) none)
    (base-turret-method-35 (_type_) none)
    (base-turret-method-36 (_type_) none)
    (base-turret-method-37 (_type_) none)
    (base-turret-method-38 (_type_) none)
    (base-turret-method-39 (_type_ turret-path-event) none)
    (base-turret-method-40 (_type_) none)
    (base-turret-method-41 (_type_ vector) symbol)
    (base-turret-method-42 (_type_ vector vector float) float)
    (base-turret-method-43 (_type_) none)
    (base-turret-method-44 (_type_ vector vector) none)
    (base-turret-method-45 (_type_ object symbol) none)
    (base-turret-method-46 (_type_ process) process)
    (base-turret-method-47 (_type_) none)
    (turret-event-handler (_type_ process int symbol event-message-block) object)
    )
  )

;; definition for method 3 of type base-turret
(defmethod inspect ((this base-turret))
  (when (not this)
    (set! this this)
    (goto cfg-7)
    )
  (let ((t9-0 (method-of-type process-focusable inspect)))
    (t9-0 this)
    )
  (format #t "~2Thud: ~D~%" (-> this hud))
  (format #t "~2Tcondition: ~D~%" (-> this condition))
  (format #t "~2Tshadow-backup: ~A~%" (-> this shadow-backup))
  (format #t "~2Trider: ~D~%" (-> this rider))
  (format #t "~2Tactor-group: #x~X~%" (-> this actor-group))
  (dotimes (s5-0 (-> this actor-group-count))
    (format #t "~T  [~D]~2Tactor-group: ~`actor-group`P~%" s5-0 (-> this actor-group s5-0))
    )
  (format #t "~2Tactor-group-count: ~D~%" (-> this actor-group-count))
  (format #t "~2Talt-actor: ~A~%" (-> this alt-actor))
  (format #t "~2Tsmush-control: #<smush-control @ #x~X>~%" (-> this smush-control))
  (format #t "~2Tsound-id[3] @ #x~X~%" (-> this sound-id))
  (format #t "~2Tsound-playing[3] @ #x~X~%" (-> this sound-playing))
  (format #t "~2Tcam-string-vector: #<vector @ #x~X>~%" (-> this cam-string-vector))
  (format #t "~2Tpath-event: #<turret-path @ #x~X>~%" (-> this path-event))
  (format #t "~2Tpath-u: ~f~%" (-> this path-u))
  (format #t "~2Tpath-u-prev: ~f~%" (-> this path-u-prev))
  (format #t "~2Tpath-mode: ~D~%" (-> this path-mode))
  (format #t "~2Tpath-speed: ~f~%" (-> this path-speed))
  (format #t "~2Tpath-speed-mult: ~f~%" (-> this path-speed-mult))
  (format #t "~2Tpath-speed-mult-final: ~f~%" (-> this path-speed-mult-final))
  (format #t "~2Tpath-old-pos: ~`vector`P~%" (-> this path-old-pos))
  (format #t "~2Tpath-direction: ~A~%" (-> this path-direction))
  (format #t "~2Tpause-proc: ~A~%" (-> this pause-proc))
  (format #t "~2Tgun-recoil-jmod[4] @ #x~X~%" (-> this gun-recoil-jmod))
  (format #t "~2Tgun-index: ~D~%" (-> this gun-index))
  (format #t "~2Tshot-timeout: ~D~%" (-> this shot-timeout))
  (format #t "~2Tfire-time: ~D~%" (-> this fire-time))
  (format #t "~2Tfire-time-interval: ~D~%" (-> this fire-time-interval))
  (format #t "~2Tenable-controls: ~A~%" (-> this enable-controls))
  (format #t "~2Tavailable-for-pickup: ~A~%" (-> this available-for-pickup))
  (format #t "~2Troty: (deg ~r)~%" (-> this roty))
  (format #t "~2Trotyv: (deg ~r)~%" (-> this rotyv))
  (format #t "~2Trotyvv: (deg ~r)~%" (-> this rotyvv))
  (format #t "~2Troty-min: (deg ~r)~%" (-> this roty-min))
  (format #t "~2Troty-max: (deg ~r)~%" (-> this roty-max))
  (format #t "~2Trotx: (deg ~r)~%" (-> this rotx))
  (format #t "~2Trotxv: (deg ~r)~%" (-> this rotxv))
  (format #t "~2Trotxvv: (deg ~r)~%" (-> this rotxvv))
  (format #t "~2Trotx-min: (deg ~r)~%" (-> this rotx-min))
  (format #t "~2Trotx-max: (deg ~r)~%" (-> this rotx-max))
  (format #t "~2Ttarget-quat: #<quaternion @ #x~X>~%" (-> this target-quat))
  (format #t "~2Tinit-quat: #<quaternion @ #x~X>~%" (-> this init-quat))
  (format #t "~2Thealth: ~f~%" (-> this health))
  (format #t "~2Ttrack-handle: ~D~%" (-> this track-handle))
  (format #t "~2Theat: ~f~%" (-> this heat))
  (format #t "~2Theat-target: ~f~%" (-> this heat-target))
  (format #t "~2Tarrow-angle: ~f~%" (-> this arrow-angle))
  (format #t "~2Tarrow-alpha: ~f~%" (-> this arrow-alpha))
  (format #t "~2Tarrow-red: ~f~%" (-> this arrow-red))
  (format #t "~2Tred-filter-timer: ~D~%" (-> this red-filter-timer))
  (format #t "~2Tride-height: ~f~%" (-> this ride-height))
  (label cfg-7)
  this
  )

;; definition for method 7 of type base-turret
;; WARN: Return type mismatch process-drawable vs base-turret.
(defmethod relocate ((this base-turret) (arg0 int))
  (countdown (v1-0 4)
    (if (-> this gun-recoil-jmod v1-0)
        (&+! (-> this gun-recoil-jmod v1-0) arg0)
        )
    )
  (the-as base-turret ((method-of-type process-drawable relocate) this arg0))
  )

;; definition for method 34 of type base-turret
;; WARN: Return type mismatch int vs none.
(defmethod base-turret-method-34 ((this base-turret) (arg0 process))
  0
  (none)
  )

;; definition for method 35 of type base-turret
;; WARN: Return type mismatch int vs none.
(defmethod base-turret-method-35 ((this base-turret))
  (send-event (handle->process (-> this hud)) 'force-show)
  0
  (none)
  )

;; definition for method 36 of type base-turret
;; WARN: Return type mismatch int vs none.
(defmethod base-turret-method-36 ((this base-turret))
  (if (nonzero? (-> this part))
      (spawn (-> this part) (-> this root trans))
      )
  0
  (none)
  )

;; definition for method 40 of type base-turret
;; WARN: Return type mismatch int vs none.
(defmethod base-turret-method-40 ((this base-turret))
  (let ((s3-0 (new 'stack-no-clear 'matrix))
        (s4-0 (new 'stack-no-clear 'matrix))
        (gp-0 (new 'stack-no-clear 'quaternion))
        )
    (matrix-rotate-y! s3-0 (-> this roty))
    (matrix-rotate-x! s4-0 (-> this rotx))
    (matrix*! s3-0 s4-0 s3-0)
    (matrix->quaternion gp-0 s3-0)
    (quaternion-smooth-seek! (-> this target-quat) (-> this target-quat) gp-0 0.33)
    (let ((f0-2 (update! (-> this smush-control))))
      (quaternion-rotate-local-x! (-> this root quat) gp-0 (* -910.2222 f0-2))
      )
    )
  0
  (none)
  )

;; definition for method 37 of type base-turret
;; WARN: Return type mismatch int vs none.
(defmethod base-turret-method-37 ((this base-turret))
  (let ((f30-0 (fabs (* 0.00006866455 (-> this rotyv))))
        (f28-0 (fabs (* 0.00010986328 (-> this rotxv))))
        (f26-0 0.33333334)
        (f24-0 0.5)
        (s5-0 (-> this sound-playing 0))
        (s4-0 (-> this sound-playing 1))
        )
    (cond
      ((and (-> this sound-playing 0) (< f30-0 f26-0))
       (sound-stop (-> this sound-id 0))
       (set! (-> this sound-playing 0) #f)
       )
      ((< (* 1.2 f26-0) f30-0)
       (sound-play "drill-turret-lp" :id (-> this sound-id 0) :position (-> this root trans))
       (set! (-> this sound-playing 0) #t)
       )
      )
    (cond
      ((and (-> this sound-playing 1) (< f28-0 f24-0))
       (sound-stop (-> this sound-id 1))
       (set! (-> this sound-playing 1) #f)
       )
      ((< (* 1.2 f24-0) f28-0)
       (sound-play "drill-turret-l2" :id (-> this sound-id 1) :position (-> this root trans))
       (set! (-> this sound-playing 1) #t)
       )
      )
    (if (and (or s5-0 s4-0) (< f30-0 f26-0) (< f28-0 f24-0))
        (sound-play "drill-tur-stop" :position (-> this root trans))
        )
    )
  (case (-> this path-mode)
    ((2 3 4)
     (sound-play-by-name
       (static-sound-name "turret-track")
       (-> this sound-id 2)
       (the int (* 1024.0 (lerp-clamp 0.0 1.0 (-> this path-speed-mult))))
       (the int (* 1524.0 (lerp-scale -0.3 0.3 (-> this path-speed-mult) 0.0 4.0)))
       0
       (sound-group sfx)
       (-> this root trans)
       )
     (set! (-> this sound-playing 2) #t)
     )
    (else
      (when (-> this sound-playing 2)
        (sound-stop (-> this sound-id 2))
        (set! (-> this sound-playing 2) #f)
        )
      )
    )
  0
  (none)
  )

;; definition for method 48 of type base-turret
;; INFO: Used lq/sq
(defmethod turret-event-handler ((this base-turret) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (v0-0 object))
  (case arg2
    (('trans)
     (set! v0-0 (-> arg3 param 0))
     (set! (-> (the-as vector v0-0) quad) (-> this root trans quad))
     v0-0
     )
    (('quat)
     (quaternion-copy! (the-as quaternion (-> arg3 param 0)) (-> this target-quat))
     )
    (('path)
     (if (not (logtest? (-> this path flags) (path-control-flag not-found)))
         (-> this path)
         #f
         )
     )
    (('shadow)
     (cond
       ((-> arg3 param 0)
        (set! v0-0 (-> this shadow-backup))
        (set! (-> this draw shadow) (the-as shadow-geo v0-0))
        v0-0
        )
       (else
         (set! (-> this draw shadow) #f)
         #f
         )
       )
     )
    )
  )

;; definition for function turret-handler
(defbehavior turret-handler base-turret ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (turret-event-handler self arg0 arg1 arg2 arg3)
  )

;; definition for method 20 of type base-turret
(defmethod get-trans ((this base-turret) (arg0 int))
  "@returns the `trans` [[vector]] from the process's `root` (typically either a [[trsqv]] or a [[collide-shape]])"
  (if (= arg0 1)
      (-> this root trans)
      ((method-of-type process-focusable get-trans) this arg0)
      )
  )

;; failed to figure out what this is:
(defstate idle (base-turret)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack 'bonk)
       (send-event proc 'target-turret-get-off 90)
       (send-event
         proc
         'shove
         #f
         (static-attack-info ((id (new-attack-id)) (shove-back (meters 3)) (shove-up (meters 1))))
         )
       #f
       )
      (('touch)
       (send-event proc 'target-turret-get-off 90)
       (send-shoves (-> self root) proc (the-as touching-shapes-entry (-> block param 0)) 0.7 6144.0 16384.0)
       #f
       )
      (('exit)
       #t
       )
      (else
        (turret-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set-zero! (-> self smush-control))
    (base-turret-method-43 self)
    (set! (-> self focus-status) (focus-status disable ignore inactive))
    )
  :code (behavior ()
    (ja-channel-set! 1)
    (ja :group! (-> self draw art-group data 2))
    0.0
    (let ((f30-0 20480.0))
      (until #f
        (when (and (and *target*
                        (and (>= f30-0 (vector-vector-distance (-> self root trans) (-> *target* control trans)))
                             (not (logtest? (focus-status teleporting) (-> *target* focus-status)))
                             )
                        )
                   (and (not (task-node-closed? (game-task-node drill-ship-resolution)))
                        (can-display-query? self (the-as string #f) -99.0)
                        (not (focus-test? *target* in-head board mech dark))
                        (let ((f28-0 24576.0)
                              (s4-0 (-> self root))
                              (s5-0 (target-pos 0))
                              )
                          (and (< f28-0
                                  (fabs
                                    (deg-diff (y-angle s4-0) (vector-y-angle (vector-! (new 'stack-no-clear 'vector) s5-0 (-> s4-0 trans))))
                                    )
                                  )
                               (-> self available-for-pickup)
                               )
                          )
                        )
                   )
          (let ((gp-1
                  (new 'stack 'font-context *font-default-matrix* 32 320 0.0 (font-color default) (font-flags shadow kerning))
                  )
                )
            (let ((v1-21 gp-1))
              (set! (-> v1-21 width) (the float 340))
              )
            (let ((v1-22 gp-1))
              (set! (-> v1-22 height) (the float 80))
              )
            (let ((v1-23 gp-1))
              (set! (-> v1-23 scale) 0.9)
              )
            (set! (-> gp-1 flags) (font-flags shadow kerning large))
            (print-game-text
              (lookup-text! *common-text* (text-id press-triangle-to-use) #f)
              gp-1
              #f
              44
              (bucket-id progress)
              )
            )
          (when (and (cpad-pressed? 0 triangle) (send-event *target* 'change-mode 'turret self))
            (set! (-> self rider) (process->handle *target*))
            (let ((gp-2 (res-lump-struct (-> self entity) 'on-exit structure)))
              (if (and gp-2 (not *scene-player*))
                  (script-eval (the-as pair gp-2))
                  )
              )
            (go-virtual setup)
            )
          )
        (if *target*
            (look-at!
              (-> *target* neck)
              (vector+!
                (new 'stack-no-clear 'vector)
                (the-as vector (-> self root root-prim prim-core))
                (new 'static 'vector :y 2048.0 :w 1.0)
                )
              'nothing-special
              self
              )
            )
        (base-turret-method-36 self)
        (suspend)
        )
      )
    #f
    )
  :post (behavior ()
    (cond
      ((-> self enable-controls)
       (quaternion-slerp! (-> self root quat) (-> self root quat) (-> self init-quat) (* 3.0 (seconds-per-frame)))
       (quaternion-copy! (-> self target-quat) (-> self root quat))
       )
      (else
        (let ((s4-0 (new 'stack-no-clear 'matrix))
              (s5-0 (new 'stack-no-clear 'matrix))
              (gp-0 (new 'stack-no-clear 'quaternion))
              )
          (matrix-rotate-y! s4-0 (-> self roty))
          (matrix-rotate-x! s5-0 (-> self rotx))
          (matrix*! s4-0 s5-0 s4-0)
          (matrix->quaternion gp-0 s4-0)
          (quaternion-smooth-seek! (-> self target-quat) (-> self target-quat) gp-0 0.33)
          (let ((f0-4 (update! (-> self smush-control))))
            (quaternion-rotate-local-x! (-> self root quat) gp-0 (* -910.2222 f0-4))
            )
          )
        )
      )
    (transform-post)
    )
  )

;; failed to figure out what this is:
(defstate setup (base-turret)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('change-mode)
       (go-virtual active)
       )
      (else
        (turret-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set-setting! 'mode-name 'cam-turret 0.0 0)
    )
  :code sleep-code
  :post transform-post
  )

;; definition for function set-recoil
;; WARN: Return type mismatch symbol vs none.
(defun set-recoil ((arg0 joint-mod) (arg1 float) (arg2 symbol))
  (set! (-> arg0 target z) arg1)
  (set! (-> arg0 twist-min-y) (the-as float #t))
  (none)
  )

;; failed to figure out what this is:
(defstate active (base-turret)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('draw)
       (cond
         ((-> block param 0)
          (ja-channel-set! 1)
          (ja :group! (-> self draw art-group data 2))
          (transform-post)
          )
         (else
           (ja-channel-set! 0)
           (transform-post)
           )
         )
       )
      (('fire-down)
       (cond
         ((>= (-> self heat) 1.0)
          (let ((v1-8 (- (current-time) (-> self fire-time)))
                (a0-7 6)
                (a1-1 (-> self fire-time-interval))
                )
            (when (>= v1-8 (* a0-7 a1-1))
              (set-time! (-> self fire-time))
              (base-turret-method-45 self a1-1 message)
              )
            )
          )
         (else
           (when (time-elapsed? (-> self fire-time) (-> self fire-time-interval))
             (set-time! (-> self fire-time))
             (base-turret-method-45 self argc message)
             )
           )
         )
       )
      (('fire-pressed)
       (set-time! (-> self fire-time))
       (base-turret-method-45 self argc message)
       )
      (('bonk)
       #f
       )
      (('touch 'attack)
       (let* ((gp-0 (-> block param 0))
              (s5-0 (the-as object (-> block param 1)))
              (s4-0 proc)
              (v1-21 (if (type? s4-0 projectile)
                         s4-0
                         )
                     )
              )
         (when (and gp-0 v1-21)
           (case (-> (the-as attack-info s5-0) mode)
             (('wasp-shot 'guard-shot)
              (seek! (-> self health) 0.0 0.25)
              (activate! (-> self smush-control) 0.2 15 75 1.0 0.9 (-> *display* entity-clock))
              (sound-play "turret-take-hit")
              (let ((v0-1 (the-as object (+ (current-time) (seconds 0.08)))))
                (set! (-> self red-filter-timer) (the-as time-frame v0-1))
                v0-1
                )
              )
             (('drill-ship-shot)
              (seek! (-> self health) 0.0 0.5)
              (activate! (-> self smush-control) 0.2 24 144 1.0 0.9 (-> *display* entity-clock))
              (sound-play "turret-take-hit")
              )
             )
           )
         )
       )
      (('test)
       (set! (-> self health) (seek (-> self health) 0.0 (the-as float (-> block param 0))))
       )
      (('exit-valid)
       (let ((v1-33 (-> self path-mode)))
         (cond
           ((or (zero? v1-33) (= v1-33 5) (= v1-33 1))
            (base-turret-method-41 self (the-as vector (-> block param 0)))
            #t
            )
           (else
             #f
             )
           )
         )
       )
      (('exit)
       (let ((v1-37 (-> self path-mode)))
         (when (if (or (zero? v1-37) (= v1-37 5) (= v1-37 1))
                   #t
                   )
           (go-virtual shutdown)
           #f
           )
         )
       )
      (else
        (turret-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (logior! (-> self skel status) (joint-control-status sync-math))
    (process-entity-status! self (entity-perm-status no-kill) #t)
    (set! (-> self focus-status) (focus-status))
    (set! (-> self red-filter-timer) 0)
    (set! (-> self ride-height) 0.0)
    (set! (-> self roty) (y-angle (-> self root)))
    (set! (-> self rotyv) 0.0)
    (set! (-> self rotx) 0.0)
    (set! (-> self rotxv) 0.0)
    (let ((a1-1 (handle->process (-> self rider))))
      (if a1-1
          (base-turret-method-34 self a1-1)
          )
      )
    (let ((v1-14 (-> (the-as collide-shape-prim-group (-> self root root-prim)) child 1)))
      (set! (-> v1-14 prim-core action) (collide-action solid))
      (set! (-> v1-14 prim-core collide-as) (collide-spec obstacle))
      )
    )
  :exit (behavior ()
    (set-filter-color! 1.0 1.0 1.0)
    (let ((v1-3 (-> (the-as collide-shape-prim-group (-> self root root-prim)) child 1)))
      (set! (-> v1-3 prim-core action) (collide-action))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      )
    0
    (send-event (handle->process (-> self hud)) 'hide-and-die)
    )
  :trans (behavior ()
    (if (<= (the int (-> self health)) 0)
        (go-virtual die)
        )
    )
  :code (behavior ()
    (ja-channel-set! 1)
    (ja :group! (-> self draw art-group data 2))
    (while (handle->process (-> self rider))
      (base-turret-method-35 self)
      (base-turret-method-37 self)
      (when (>= (-> *camera-combiner* interp-val) 1.0)
        (seek! (-> self path-speed-mult) (-> self path-speed-mult-final) (seconds-per-frame))
        (let ((gp-0 (-> self path-mode)))
          (case gp-0
            ((1)
             (set! (-> self path-mode) (the-as uint 2))
             )
            ((2 3 4)
             (let ((s5-0 (new 'stack-no-clear 'vector)))
               (get-point-at-percent-along-path! (-> self path) s5-0 (-> self path-u) 'interp)
               (set! (-> self root trans quad) (-> s5-0 quad))
               (set! (-> self root trans y) (+ (-> s5-0 y) (-> self ride-height)))
               )
             (seek! (-> self ride-height) 2048.0 (* 2048.0 (seconds-per-frame)))
             (set! (-> self path-u-prev) (-> self path-u))
             (seek!
               (-> self path-u)
               (if (-> self path-direction)
                   0.0
                   1.0
                   )
               (* (-> self path-speed) (-> self path-speed-mult) (seconds-per-frame))
               )
             (base-turret-method-38 self)
             (when (= (-> self path-u) 1.0)
               (get-point-at-percent-along-path! (-> self path) (-> self root trans) 1.0 'interp)
               (let ((a1-9 (displacement-between-points-at-percent-normalized! (-> self path) (new 'stack-no-clear 'vector) 1.0)))
                 (forward-up-nopitch->quaternion (-> self init-quat) a1-9 *y-vector*)
                 )
               (activate! (-> self smush-control) 0.2 30 240 0.8 0.8 (-> *display* entity-clock))
               (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.5))
               (set! (-> self path-mode) (the-as uint 5))
               (send-event *target* 'end-mode)
               )
             )
            ((5)
             (go-virtual shutdown)
             )
            )
          (cond
            ((= gp-0 3)
             (when ((-> self pause-proc) self)
               (set! (-> self path-mode) (the-as uint 2))
               (set! (-> self path-speed-mult-final) 1.0)
               )
             )
            ((= gp-0 4)
             (when (not ((-> self pause-proc) self))
               (set! (-> self path-mode) (the-as uint 2))
               (set! (-> self path-speed-mult-final) 1.0)
               )
             )
            )
          )
        )
      (set! (-> self path-old-pos quad) (-> self root trans quad))
      (base-turret-method-36 self)
      (suspend)
      )
    (go-virtual shutdown)
    )
  :post (behavior ()
    (when (nonzero? (-> self red-filter-timer))
      (cond
        ((< (current-time) (-> self red-filter-timer))
         (let* ((v1-5 (- (-> self red-filter-timer) (current-time)))
                (f0-1 (- 1.0 (* 0.041666668 (the float v1-5))))
                )
           (set-filter-color! 1.0 f0-1 f0-1)
           )
         )
        (else
          (set! (-> self red-filter-timer) 0)
          (set-filter-color! 1.0 1.0 1.0)
          )
        )
      )
    (dotimes (gp-0 4)
      (let ((s5-0 (-> self gun-recoil-jmod gp-0)))
        (when (-> s5-0 enable)
          (let ((s4-0 (-> s5-0 transform)))
            (let ((f0-3 (* 2.4 (fabs (-> s4-0 trans z)))))
              (seek! (-> s4-0 trans z) 0.0 (* f0-3 (seconds-per-frame)))
              )
            (if (= (-> s4-0 trans z) 0.0)
                (set! (-> s5-0 enable) #f)
                )
            )
          )
        )
      )
    (when (and (-> self enable-controls) (>= (-> *camera-combiner* interp-val) 1.0))
      (set! (-> self rotyvv) (analog-input (the-as int (-> *cpad-list* cpads 0 leftx)) 128.0 32.0 110.0 -98304.0))
      (set! (-> self rotxvv) (analog-input (the-as int (-> *cpad-list* cpads 0 lefty)) 128.0 32.0 110.0 -65536.0))
      )
    (+! (-> self rotyv) (* (-> self rotyvv) (seconds-per-frame)))
    (seek! (-> self rotyv) 0.0 (* 32768.0 (seconds-per-frame)))
    (set! (-> self rotyv) (fmax -14563.556 (fmin 14563.556 (-> self rotyv))))
    (set! (-> self roty)
          (the float (sar (shl (the int (+ (-> self roty) (* (-> self rotyv) (seconds-per-frame)))) 48) 48))
          )
    (+! (-> self rotxv) (* (-> self rotxvv) (seconds-per-frame)))
    (seek! (-> self rotxv) 0.0 (* 32768.0 (seconds-per-frame)))
    (set! (-> self rotxv) (fmax -9102.223 (fmin 9102.223 (-> self rotxv))))
    (set! (-> self rotx)
          (the float (sar (shl (the int (+ (-> self rotx) (* (-> self rotxv) (seconds-per-frame)))) 48) 48))
          )
    (cond
      ((>= (-> self rotx) (-> self rotx-max))
       (set! (-> self rotx) (-> self rotx-max))
       (set! (-> self rotxv) 0.0)
       )
      ((>= (-> self rotx-min) (-> self rotx))
       (set! (-> self rotx) (-> self rotx-min))
       (set! (-> self rotxv) 0.0)
       )
      )
    (when (!= (-> self roty-min) (-> self roty-max))
      (cond
        ((>= (-> self roty) (-> self roty-max))
         (set! (-> self roty) (-> self roty-max))
         (set! (-> self rotyv) 0.0)
         )
        ((>= (-> self roty-min) (-> self roty))
         (set! (-> self roty) (-> self roty-min))
         (set! (-> self rotyv) 0.0)
         )
        )
      )
    (base-turret-method-40 self)
    (base-turret-method-47 self)
    (set! (-> *game-info* score) (-> self health))
    (send-event (handle->process (-> self hud)) 'set-heat (-> self heat))
    (send-event (handle->process (-> self hud)) 'set-arrow-alpha (-> self arrow-alpha))
    (send-event (handle->process (-> self hud)) 'set-arrow-angle (-> self arrow-angle))
    (send-event (handle->process (-> self hud)) 'set-arrow-red (-> self arrow-red))
    (let ((s5-1 (new 'stack-no-clear 'vector)))
      (set! (-> s5-1 x) 0.0)
      (set! (-> s5-1 y) 20480.0)
      (set! (-> s5-1 z) 81920.0)
      (set! (-> s5-1 w) 1.0)
      (let ((gp-1 (new 'stack-no-clear 'vector4w)))
        (set! (-> gp-1 quad) (the-as uint128 0))
        (vector-matrix*! s5-1 s5-1 (-> self node-list data 0 bone transform))
        (if (transform-point-qword! gp-1 s5-1)
            (send-event
              (handle->process (-> self hud))
              'set-hud-pos
              (+ (/ (-> gp-1 x) 16) -1792)
              (+ (/ (-> gp-1 y) 16) -1840)
              )
            )
        )
      )
    (seek!
      (-> self heat)
      (-> self heat-target)
      (* (fmin 0.5 (fabs (- (-> self heat) (-> self heat-target)))) (seconds-per-frame))
      )
    (seek! (-> self heat-target) 0.0 (* 0.4 (seconds-per-frame)))
    (transform-post)
    )
  )

;; failed to figure out what this is:
(defstate shutdown (base-turret)
  :virtual #t
  :event turret-handler
  :exit (behavior ()
    (remove-setting! 'mode-name)
    (sound-stop (-> self sound-id 0))
    (sound-stop (-> self sound-id 1))
    (sound-stop (-> self sound-id 2))
    (set-zero! (-> self smush-control))
    (logclear! (-> self skel status) (joint-control-status sync-math))
    )
  :trans (behavior ()
    (when (< 0.99 (vector-dot
                    (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat))
                    (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self init-quat))
                    )
             )
      (cond
        ((= (-> self path-mode) 5)
         (if (= (-> self ride-height) 0.0)
             (go-virtual dormant)
             )
         )
        (else
          (go-virtual idle)
          )
        )
      )
    )
  :code (behavior ()
    (ja-channel-set! 1)
    (ja :group! (-> self draw art-group data 2))
    (until #f
      (base-turret-method-37 self)
      (if *target*
          (look-at!
            (-> *target* neck)
            (vector+!
              (new 'stack-no-clear 'vector)
              (the-as vector (-> self root root-prim prim-core))
              (new 'static 'vector :y 2048.0 :w 1.0)
              )
            'nothing-special
            self
            )
          )
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (when (= (-> self path-mode) 5)
      (let ((gp-0 (new 'stack-no-clear 'vector)))
        (get-point-at-percent-along-path! (-> self path) gp-0 1.0 'interp)
        (set! (-> self root trans quad) (-> gp-0 quad))
        (set! (-> self root trans y) (+ (-> gp-0 y) (-> self ride-height)))
        )
      (seek! (-> self ride-height) 0.0 (* 2048.0 (seconds-per-frame)))
      )
    (dotimes (gp-1 4)
      (let ((s5-0 (-> self gun-recoil-jmod gp-1)))
        (when (-> s5-0 enable)
          (let ((s4-0 (-> s5-0 transform)))
            (let ((f0-7 (* 2.4 (fabs (-> s4-0 trans z)))))
              (seek! (-> s4-0 trans z) 0.0 (* f0-7 (seconds-per-frame)))
              )
            (if (= (-> s4-0 trans z) 0.0)
                (set! (-> s5-0 enable) #f)
                )
            )
          )
        )
      )
    (set! (-> self rotxv)
          (* (deg-diff (-> self rotx) (deg-seek-smooth (-> self rotx) 0.0 (* 16384.0 (seconds-per-frame)) 0.1))
             (-> self clock frames-per-second)
             )
          )
    (set! (-> self rotyv)
          (* (deg-diff
               (-> self roty)
               (deg-seek-smooth
                 (-> self roty)
                 (the float (sar (shl (the int (quaternion-y-angle (-> self init-quat))) 48) 48))
                 (* 21845.334 (seconds-per-frame))
                 0.1
                 )
               )
             (-> self clock frames-per-second)
             )
          )
    (set! (-> self roty)
          (the float (sar (shl (the int (+ (-> self roty) (* (-> self rotyv) (seconds-per-frame)))) 48) 48))
          )
    (set! (-> self rotx)
          (the float (sar (shl (the int (+ (-> self rotx) (* (-> self rotxv) (seconds-per-frame)))) 48) 48))
          )
    (base-turret-method-40 self)
    (transform-post)
    )
  )

;; failed to figure out what this is:
(defstate dormant (base-turret)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack 'bonk)
       (send-event proc 'target-turret-get-off 90)
       (send-event
         proc
         'shove
         #f
         (static-attack-info ((id (new-attack-id)) (shove-back (meters 3)) (shove-up (meters 1))))
         )
       #f
       )
      (('touch)
       (send-event proc 'target-turret-get-off 90)
       (send-shoves (-> self root) proc (the-as touching-shapes-entry (-> block param 0)) 0.7 6144.0 16384.0)
       #f
       )
      (('exit)
       #t
       )
      (else
        (turret-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set-zero! (-> self smush-control))
    (base-turret-method-43 self)
    (set! (-> self focus-status) (focus-status disable ignore inactive))
    )
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate die (base-turret)
  :virtual #t
  :code (behavior ()
    (remove-setting! 'mode-name)
    (sound-stop (-> self sound-id 0))
    (sound-stop (-> self sound-id 1))
    (sound-stop (-> self sound-id 2))
    (set! (-> self focus-status) (focus-status disable ignore inactive))
    (let ((gp-0 (current-time)))
      (until (time-elapsed? gp-0 (seconds 0.8))
        (suspend)
        )
      )
    (send-event
      (handle->process (-> self rider))
      'attack
      #f
      (static-attack-info ((id (new-attack-id)) (mode 'turret)))
      )
    (let ((v1-17 (-> self root root-prim)))
      (set! (-> v1-17 prim-core collide-as) (collide-spec))
      (set! (-> v1-17 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self draw status) (draw-control-status no-draw))
    (sound-play "turret-die" :position (-> self root trans))
    (let ((gp-2 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-turret-explode" (the-as (pointer uint32) #f))
        6
        gp-2
        *turret-exploder-params*
        :to self
        )
      )
    (let ((gp-3 (new 'stack-no-clear 'vector)))
      (set! (-> gp-3 quad) (-> self root trans quad))
      (+! (-> gp-3 y) 8192.0)
      (let ((s5-2 (get-process *default-dead-pool* part-tracker #x4000)))
        (when s5-2
          (let ((t9-13 (method-of-type part-tracker activate)))
            (t9-13 (the-as part-tracker s5-2) self (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
            )
          (let ((t9-14 run-function-in-process)
                (a0-20 s5-2)
                (a1-14 part-tracker-init)
                (a2-12 (-> *part-group-id-table* 201))
                (a3-4 0)
                (t0-2 #f)
                (t1-2 #f)
                (t2-1 #f)
                (t3-0 *launch-matrix*)
                )
            (set! (-> t3-0 trans quad) (-> gp-3 quad))
            ((the-as (function object object object object object object object object none) t9-14)
             a0-20
             a1-14
             a2-12
             a3-4
             t0-2
             t1-2
             t2-1
             t3-0
             )
            )
          (-> s5-2 ppointer)
          )
        )
      )
    (while (-> self child)
      (suspend)
      )
    )
  )

;; definition for method 46 of type base-turret
;; WARN: Return type mismatch symbol vs process.
(defmethod base-turret-method-46 ((this base-turret) (arg0 process))
  (the-as process #t)
  )

;; definition for method 47 of type base-turret
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod base-turret-method-47 ((this base-turret))
  (let ((a0-1 (-> this root trans))
        (f30-0 0.0)
        (s4-0 (the-as process-drawable #f))
        )
    (let ((s5-0 (new 'stack-no-clear 'array 'collide-shape 32))
          (a1-0 (new 'stack-no-clear 'vector))
          )
      (set! (-> a1-0 quad) (-> a0-1 quad))
      (set! (-> a1-0 w) 409600.0)
      (countdown (s3-0 (fill-actor-list-for-sphere *actor-hash* (the-as sphere a1-0) s5-0 32))
        (let* ((s2-0 (-> s5-0 s3-0))
               (a0-5 (if (type? s2-0 collide-shape)
                         s2-0
                         )
                     )
               )
          (when a0-5
            (let* ((s1-0 (-> a0-5 process))
                   (s2-1 (if (type? s1-0 process-focusable)
                             s1-0
                             )
                         )
                   )
              (when (and s2-1
                         (logtest? (process-mask enemy) (-> s2-1 mask))
                         (logtest? (process-mask collectable) (-> s2-1 mask))
                         (not (focus-test? (the-as process-focusable s2-1) disable dead ignore inactive))
                         (!= s2-1 this)
                         (!= s2-1 *target*)
                         (base-turret-method-46 this s2-1)
                         )
                (let ((f0-1 (vector-vector-xz-distance (-> this root trans) (-> s2-1 root trans))))
                  (when (or (not s4-0) (< f0-1 f30-0))
                    (set! s4-0 s2-1)
                    (set! f30-0 f0-1)
                    )
                  )
                )
              )
            )
          )
        )
      )
    (cond
      (s4-0
        (let ((s5-1 (new 'stack-no-clear 'vector)))
          (set! (-> s5-1 x) 0.0)
          (set! (-> s5-1 y) 10240.0)
          (set! (-> s5-1 z) 0.0)
          (set! (-> s5-1 w) 1.0)
          (let ((s1-1 (new 'stack-no-clear 'vector))
                (s3-1 (vector<-cspace! (new 'stack-no-clear 'vector) (-> this node-list data 12)))
                (s2-2 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)))
                )
            (vector-matrix*! s5-1 s5-1 (-> (the-as process-focusable s4-0) node-list data 0 bone transform))
            (vector-line-distance-point! s5-1 s3-1 (vector+float*! (new 'stack-no-clear 'vector) s3-1 s2-2 4096.0) s1-1)
            (let* ((a1-10 (vector-! (new 'stack-no-clear 'vector) s5-1 s1-1))
                   (s4-1 (vector-inv-orient-by-quat! (new 'stack-no-clear 'vector) a1-10 (-> this root quat)))
                   (f30-1 (vector-vector-angle-safe s2-2 (vector-! (new 'stack-no-clear 'vector) s5-1 s3-1)))
                   )
              (let ((f0-10 (- (atan (-> s4-1 x) (-> s4-1 y)))))
                (if (logtest? (-> *game-info* secrets) (game-secrets hflip-screen))
                    (set! f0-10 (* -1.0 f0-10))
                    )
                (set! (-> this arrow-angle) (deg-seek (-> this arrow-angle) f0-10 (* 65536.0 (seconds-per-frame))))
                )
              (cond
                ((< 910.2222 f30-1)
                 (seek! (-> this arrow-alpha) 1.0 (seconds-per-frame))
                 (send-event (handle->process (-> this hud)) 'set-target-flash #f)
                 )
                (else
                  (seek! (-> this arrow-alpha) 0.0 (* 4.0 (seconds-per-frame)))
                  (send-event (handle->process (-> this hud)) 'set-target-flash #t)
                  )
                )
              )
            )
          (seek!
            (-> this arrow-red)
            (lerp-scale 1.0 0.0 (vector-vector-distance s5-1 (-> this root trans)) 122880.0 245760.0)
            (seconds-per-frame)
            )
          )
        )
      (else
        (seek! (-> this arrow-alpha) 0.0 (seconds-per-frame))
        (send-event (handle->process (-> this hud)) 'set-target-flash #f)
        )
      )
    )
  0
  (none)
  )

;; definition for method 43 of type base-turret
;; WARN: Return type mismatch int vs none.
(defmethod base-turret-method-43 ((this base-turret))
  (set! (-> this roty) (y-angle (-> this root)))
  (set! (-> this rotyv) 0.0)
  (set! (-> this rotyvv) 0.0)
  (set! (-> this rotx) 0.0)
  (set! (-> this rotxv) 0.0)
  (set! (-> this rotxvv) 0.0)
  0
  (none)
  )

;; definition for method 33 of type base-turret
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod turret-init! ((this base-turret) (arg0 entity-actor) (arg1 matrix))
  (local-vars (sv-16 res-tag))
  (stack-size-set! (-> this main-thread) 512)
  (let ((s3-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-others))))
    (set! (-> s3-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s3-0 reaction) cshape-reaction-default)
    (set! (-> s3-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s2-0 (new 'process 'collide-shape-prim-group s3-0 (the-as uint 2) 0)))
      (set! (-> s3-0 total-prims) (the-as uint 3))
      (set! (-> s2-0 prim-core collide-as) (collide-spec bot))
      (set! (-> s2-0 prim-core action) (collide-action solid))
      (set! (-> s2-0 transform-index) 3)
      (set-vector! (-> s2-0 local-sphere) 0.0 7372.8 0.0 14745.6)
      (set! (-> s3-0 root-prim) s2-0)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-sphere s3-0 (the-as uint 0))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec bot camera-blocker))
      (set! (-> v1-14 prim-core action) (collide-action solid))
      (set! (-> v1-14 transform-index) 3)
      (set-vector! (-> v1-14 local-sphere) 0.0 8192.0 0.0 9830.4)
      )
    (let ((v1-16 (new 'process 'collide-shape-prim-sphere s3-0 (the-as uint 0))))
      (set! (-> v1-16 transform-index) 3)
      (set-vector! (-> v1-16 local-sphere) 0.0 6553.6 0.0 12288.0)
      )
    (set! (-> s3-0 nav-radius) (* 0.75 (-> s3-0 root-prim local-sphere w)))
    (let ((v1-19 (-> s3-0 root-prim)))
      (set! (-> s3-0 backup-collide-as) (-> v1-19 prim-core collide-as))
      (set! (-> s3-0 backup-collide-with) (-> v1-19 prim-core collide-with))
      )
    (set! (-> this root) s3-0)
    )
  (when arg0
    (process-drawable-from-entity! this arg0)
    (set-yaw-angle-clear-roll-pitch! (-> this root) (res-lump-float arg0 'rotoffset))
    )
  (when arg1
    (set! (-> this root trans quad) (-> arg1 vector 0 quad))
    (quaternion-copy! (-> this root quat) (the-as quaternion (-> arg1 vector 1)))
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-turret" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this shadow-backup) (the-as symbol (-> this draw shadow)))
  (logclear! (-> this mask) (process-mask actor-pause))
  (set! (-> this condition) (res-lump-value arg0 'index int :time -1000000000.0))
  (set! (-> this fact)
        (new 'process 'fact-info this (pickup-type eco-pill-random) (-> *FACT-bank* default-eco-pill-green-inc))
        )
  (if (-> this entity)
      (move-to-ground (the-as collide-shape-moving (-> this root)) 40960.0 40960.0 #t (collide-spec backgnd))
      )
  (set-zero! (-> this smush-control))
  (set! (-> this hud) (the-as handle #f))
  (base-turret-method-43 this)
  (set! (-> this alt-actor) (the-as symbol (entity-actor-lookup (-> this entity) 'alt-actor 0)))
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-49 (res-lump-data (-> this entity) 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-49 (nonzero? (-> sv-16 elt-count)))
       (set! (-> this actor-group) (the-as (pointer actor-group) v1-49))
       (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> this actor-group) (the-as (pointer actor-group) #f))
        (set! (-> this actor-group-count) 0)
        0
        )
      )
    )
  (set! (-> this sound-id 0) (new-sound-id))
  (set! (-> this sound-id 1) (new-sound-id))
  (set! (-> this sound-id 2) (new-sound-id))
  (set! (-> this sound-playing 0) #f)
  (set! (-> this sound-playing 1) #f)
  (set! (-> this sound-playing 2) #f)
  (let ((s5-1 (new 'process 'curve-control this 'path -1000000000.0)))
    (set! (-> this path) s5-1)
    (set! (-> this path-u) 0.0)
    (set! (-> this path-u-prev) 0.0)
    (set! (-> this path-speed) (/ 16384.0 (total-distance s5-1)))
    (set! (-> this path-speed-mult) 0.0)
    (set! (-> this path-speed-mult-final) 1.0)
    (set! (-> this path-direction) #f)
    (cond
      ((logtest? (-> s5-1 flags) (path-control-flag not-found))
       (set! (-> this path-mode) (the-as uint 0))
       0
       )
      (else
        (set! (-> this path-mode) (the-as uint 1))
        )
      )
    (logior! (-> s5-1 flags) (path-control-flag display draw-line draw-point draw-text))
    )
  (when (not (logtest? (-> this path flags) (path-control-flag not-found)))
    (get-point-at-percent-along-path! (-> this path) (-> this root trans) 0.0 'interp)
    (set! (-> this path-old-pos quad) (-> this root trans quad))
    )
  (set! (-> this path-speed-mult) 1.0)
  (quaternion-copy! (-> this target-quat) *unity-quaternion*)
  (quaternion-copy! (-> this init-quat) (-> this root quat))
  (set! (-> this gun-index) 0)
  (set! (-> this shot-timeout) (seconds 0.667))
  (set! (-> this gun-recoil-jmod 0) (new 'process 'joint-mod-add-local this 5 #t #f #f))
  (set! (-> this gun-recoil-jmod 0 enable) #f)
  (set! (-> this gun-recoil-jmod 1) (new 'process 'joint-mod-add-local this 11 #t #f #f))
  (set! (-> this gun-recoil-jmod 1 enable) #f)
  (set! (-> this gun-recoil-jmod 2) (new 'process 'joint-mod-add-local this 7 #t #f #f))
  (set! (-> this gun-recoil-jmod 2 enable) #f)
  (set! (-> this gun-recoil-jmod 3) (new 'process 'joint-mod-add-local this 9 #t #f #f))
  (set! (-> this gun-recoil-jmod 3 enable) #f)
  (set! (-> this health) 16.0)
  (set! (-> this heat) 0.0)
  (set! (-> this heat-target) 0.0)
  (set! (-> this arrow-angle) 0.0)
  (set! (-> this enable-controls) #t)
  (set! (-> this available-for-pickup) #t)
  (set! (-> this rotx-min) -10922.667)
  (set! (-> this rotx-max) 5461.3335)
  (set! (-> this roty-min) 0.0)
  (set! (-> this roty-max) 0.0)
  (set! (-> this fire-time-interval) (seconds 0.15))
  0
  (none)
  )

;; definition for method 41 of type base-turret
;; INFO: Used lq/sq
(defmethod base-turret-method-41 ((this base-turret) (arg0 vector))
  (local-vars (sv-592 int))
  (let* ((s3-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this init-quat)))
         (s1-0 (-> this root trans))
         (s5-0 (new 'stack-no-clear 'vector))
         (s2-0 (new 'stack 'collide-query))
         (s0-0 8)
         (f30-0 (/ 65536.0 (+ -1.0 (the float s0-0))))
         )
    (set! (-> s3-0 y) 0.0)
    (vector-xz-normalize! s3-0 -18432.0)
    (set! sv-592 0)
    (while (< sv-592 s0-0)
      (vector+! s5-0 s1-0 s3-0)
      (vector-rotate-y! s3-0 s3-0 f30-0)
      (set! (-> s2-0 start-pos quad) (-> s5-0 quad))
      (set-vector! (-> s2-0 move-dist) 0.0 -24576.0 0.0 0.0)
      (+! (-> s2-0 start-pos y) 2048.0)
      (let ((v1-9 s2-0))
        (set! (-> v1-9 radius) 409.6)
        (set! (-> v1-9 collide-with) (collide-spec backgnd))
        (set! (-> v1-9 ignore-process0) this)
        (set! (-> v1-9 ignore-process1) #f)
        (set! (-> v1-9 ignore-pat) (-> this root pat-ignore-mask))
        (set! (-> v1-9 action-mask) (collide-action solid))
        )
      (when (>= (fill-and-probe-using-line-sphere *collide-cache* s2-0) 0.0)
        (set! (-> s5-0 y) (+ 4096.0 (-> s2-0 best-other-tri intersect y)))
        (set! (-> arg0 quad) (-> s5-0 quad))
        (return #t)
        )
      (set! sv-592 (+ sv-592 1))
      )
    )
  #f
  )

;; definition for method 44 of type base-turret
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod base-turret-method-44 ((this base-turret) (arg0 vector) (arg1 vector))
  (let ((gp-0 (new 'stack-no-clear 'projectile-init-by-other-params)))
    (set! (-> gp-0 ent) (-> this entity))
    (set! (-> gp-0 charge) 1.0)
    (set! (-> gp-0 options) (projectile-options account-for-target-velocity proj-options-8000))
    (set! (-> gp-0 pos quad) (-> arg0 quad))
    (set! (-> gp-0 vel quad) (-> (vector-normalize-copy! (new 'stack-no-clear 'vector) arg1 1228800.0) quad))
    (set! (-> gp-0 notify-handle) (the-as handle #f))
    (set! (-> gp-0 owner-handle) (the-as handle #f))
    (set! (-> gp-0 ignore-handle) (process->handle this))
    (let* ((v1-9 *game-info*)
           (a0-9 (+ (-> v1-9 attack-id) 1))
           )
      (set! (-> v1-9 attack-id) a0-9)
      (set! (-> gp-0 attack-id) a0-9)
      )
    (set! (-> gp-0 timeout) (-> this shot-timeout))
    (spawn-projectile turret-shot gp-0 this *default-dead-pool*)
    )
  0
  (none)
  )

;; definition for method 42 of type base-turret
;; INFO: Used lq/sq
(defmethod base-turret-method-42 ((this base-turret) (arg0 vector) (arg1 vector) (arg2 float))
  (let ((s5-0 (new 'stack-no-clear 'collide-query)))
    (set! (-> s5-0 start-pos quad) (-> arg0 quad))
    (vector-normalize-copy! (-> s5-0 move-dist) arg1 819200.0)
    (let ((v1-1 s5-0))
      (set! (-> v1-1 radius) 2048.0)
      (set! (-> v1-1 collide-with) (collide-spec backgnd enemy obstacle hit-by-others-list))
      (set! (-> v1-1 ignore-process0) this)
      (set! (-> v1-1 ignore-process1) #f)
      (set! (-> v1-1 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
      (set! (-> v1-1 action-mask) (collide-action solid))
      )
    (let ((f0-1 (fill-and-probe-using-line-sphere *collide-cache* s5-0)))
      (cond
        ((>= f0-1 0.0)
         (* arg2 f0-1)
         )
        (else
          (empty)
          arg2
          )
        )
      )
    )
  )

;; definition for method 45 of type base-turret
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod base-turret-method-45 ((this base-turret) (arg0 object) (arg1 symbol))
  (local-vars (sv-112 vector) (sv-128 vector) (sv-144 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
    (init-vf0-vector)
    (when (< (-> this heat) 1.0)
      (let ((s3-0 (new 'static 'array int32 4 5 11 7 9))
            (s4-0 (* (-> this gun-index) 2))
            (s2-0 (+ (* (-> this gun-index) 2) 1))
            (s5-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)))
            )
        (set-recoil (the-as joint-mod (-> this gun-recoil-jmod s4-0)) -819.2 arg1)
        (set-recoil (the-as joint-mod (-> this gun-recoil-jmod s2-0)) 819.2 arg1)
        (let ((s4-1 (vector<-cspace! (new 'stack-no-clear 'vector) (-> this node-list data (-> s3-0 s4-0))))
              (s3-1 (vector<-cspace! (new 'stack-no-clear 'vector) (-> this node-list data (-> s3-0 s2-0))))
              (s0-0 (vector<-cspace! (new 'stack-no-clear 'vector) (-> this node-list data 12)))
              (s1-0 (new 'stack-no-clear 'vector))
              (s2-1 (new 'stack-no-clear 'vector))
              )
          (set! sv-144 s0-0)
          (set! sv-112 s0-0)
          (set! sv-128 s5-0)
          (let ((f0-2 (+ 20480.0 (base-turret-method-42 this s0-0 s5-0 819200.0))))
            (.lvf vf2 (&-> sv-128 quad))
            (.lvf vf1 (&-> sv-112 quad))
            (let ((v1-25 f0-2))
              (.mov vf3 v1-25)
              )
            )
          (.add.x.vf vf4 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf2 vf3)
          (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
          (.svf (&-> sv-144 quad) vf4)
          (vector-! s1-0 s0-0 s4-1)
          (vector-! s2-1 s0-0 s3-1)
          (vector-normalize! s1-0 1.0)
          (vector-normalize! s2-1 1.0)
          (base-turret-method-44 this s4-1 s1-0)
          (base-turret-method-44 this s3-1 s2-1)
          )
        )
      (set! (-> this gun-index) (- 1 (-> this gun-index)))
      (activate! (-> this smush-control) 0.1 30 120 0.8 0.9 (-> *display* entity-clock))
      )
    (seek! (-> this heat-target) 1.05 0.1)
    0
    (none)
    )
  )

;; definition for method 39 of type base-turret
;; WARN: Return type mismatch int vs none.
(defmethod base-turret-method-39 ((this base-turret) (arg0 turret-path-event))
  (case (-> arg0 event-type)
    (('script)
     (script-eval (the-as pair (-> arg0 param)))
     )
    (('cue-chase)
     (let ((a0-4 (process-by-name (the-as string (-> arg0 param)) *active-pool*)))
       (if a0-4
           (send-event a0-4 'cue-chase)
           )
       )
     )
    (('pause-until)
     (set! (-> this path-mode) (the-as uint 3))
     (set! (-> this pause-proc) (the-as (function base-turret symbol) (-> arg0 param)))
     (set! (-> this path-speed-mult-final) 0.0)
     )
    (('pause-while)
     (set! (-> this path-mode) (the-as uint 4))
     (set! (-> this pause-proc) (the-as (function base-turret symbol) (-> arg0 param)))
     (set! (-> this path-speed-mult-final) 0.0)
     )
    (('set-speed-mult)
     (set! (-> this path-speed-mult-final) (* 0.1 (the float (/ (the-as int (-> arg0 param)) 8))))
     )
    (('enable-controls)
     (set! (-> this enable-controls) #t)
     )
    (('disable-controls)
     (set! (-> this enable-controls) #f)
     )
    (('set-roty-min)
     (set! (-> this roty-min) (* 182.04445 (the float (/ (the-as int (-> arg0 param)) 8))))
     )
    (('set-roty-max)
     (set! (-> this roty-max) (* 182.04445 (the float (/ (the-as int (-> arg0 param)) 8))))
     )
    (('set-rotyvv)
     (set! (-> this rotyvv) (* 182.04445 (the float (/ (the-as int (-> arg0 param)) 8))))
     )
    )
  0
  (none)
  )

;; definition for method 38 of type base-turret
;; WARN: Return type mismatch int vs none.
(defmethod base-turret-method-38 ((this base-turret))
  (when (nonzero? (-> this path-event))
    (let* ((s5-0 (-> this path-event))
           (f0-0 (get-num-segments (-> this path)))
           (f30-0 (* f0-0 (-> this path-u)))
           (f28-0 (* f0-0 (-> this path-u-prev)))
           )
      (dotimes (s4-0 (-> s5-0 event-count))
        (let ((a1-0 (-> s5-0 event-tbl s4-0)))
          (if (and (>= f30-0 (-> a1-0 pos)) (< f28-0 (-> a1-0 pos)))
              (base-turret-method-39 this a1-0)
              )
          )
        )
      )
    )
  0
  (none)
  )

;; definition for method 10 of type base-turret
(defmethod deactivate ((this base-turret))
  (if (valid? (-> this hud) (the-as type #f) "" #t 0)
      (send-event (handle->process (-> this hud)) 'hide-and-die)
      )
  (sound-stop (-> this sound-id 0))
  (sound-stop (-> this sound-id 1))
  (sound-stop (-> this sound-id 2))
  ((method-of-type process-drawable deactivate) this)
  (none)
  )

;; definition for method 11 of type base-turret
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this base-turret) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (turret-init! this arg0 (the-as matrix #f))
  (go (method-of-object this idle))
  (none)
  )

;; failed to figure out what this is:
(defstate cam-turret (camera-slave)
  :event cam-standard-event-handler
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self saved-pt quad) (-> self trans quad))
      (set! (-> self blend-from-type) (the-as uint 1))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-0))
      0
      )
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) (cam-master-options-u32 HAVE_TARGET)))
        (cam-slave-go cam-free-floating)
        )
    )
  :code (behavior ()
    (until #f
      (when (not (paused?))
        (let ((gp-0 (handle->process (-> *camera* focus handle))))
          (when gp-0
            (quaternion->matrix (the-as matrix (-> self tracking)) (get-quat (the-as process-focusable gp-0) 1))
            (let ((v1-9 (handle->process (-> (the-as target gp-0) turret handle))))
              (if v1-9
                  (vector<-cspace! (-> self trans) (-> (the-as process-focusable v1-9) node-list data 12))
                  )
              )
            )
          )
        )
      (suspend)
      )
    #f
    )
  )

;; definition for function target-turret-post
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defbehavior target-turret-post target ()
  (send-event (handle->process (-> self turret handle)) 'trans (-> self turret trans))
  (send-event (handle->process (-> self turret handle)) 'quat (-> self control dir-targ))
  (set-quaternion! (-> self control) (-> self control dir-targ))
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    (set! (-> gp-0 quad) (-> self turret trans quad))
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (set! (-> s5-0 x) 0.0)
      (set! (-> s5-0 y) 0.0)
      (set! (-> s5-0 z) -10649.6)
      (set! (-> s5-0 w) 1.0)
      (vector-orient-by-quat! s5-0 s5-0 (-> self control dir-targ))
      (vector+! gp-0 gp-0 s5-0)
      )
    (move-to-point! (-> self control) gp-0)
    )
  (update-transforms (-> self control))
  (target-no-move-post)
  (cond
    ((cpad-pressed? (-> self control cpad number) r1)
     (send-event (handle->process (-> self turret handle)) 'fire-pressed)
     )
    ((cpad-hold? (-> self control cpad number) r1)
     (send-event (handle->process (-> self turret handle)) 'fire-down)
     )
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate target-turret-stance (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('change-mode)
       (case (-> block param 0)
         (('grab)
          (when (not (focus-test? self dead))
            (if (-> block param 1)
                (set! (-> self turret grabbed?) #t)
                )
            #t
            )
          )
         )
       )
      (('end-mode)
       (cond
         ((-> self turret grabbed?)
          (set! (-> self turret grabbed?) #f)
          #t
          )
         (else
           (when (-> self control unknown-handle02)
             (set! (-> self control unknown-handle02) (the-as handle #f))
             #t
             )
           )
         )
       )
      (('attack 'attack-invinc)
       (let ((gp-0
               (the-as object (mem-copy! (the-as pointer (-> self attack-info-rec)) (the-as pointer (-> block param 1)) 160))
               )
             )
         ((method-of-type attack-info compute-intersect-info)
          (the-as attack-info gp-0)
          (-> block param 1)
          self
          (if (type? proc process-drawable)
              proc
              )
          (the-as touching-shapes-entry (-> block param 0))
          )
         (case (-> (the-as attack-info gp-0) mode)
           (('turret)
            (let ((a0-12 (-> self attack-info)))
              (let ((v1-17 a0-12))
                (set! (-> v1-17 attacker) (the-as handle #f))
                (set! (-> v1-17 mode) 'generic)
                (set! (-> v1-17 shove-back) 6144.0)
                (set! (-> v1-17 shove-up) 4915.2)
                (set! (-> v1-17 angle) #f)
                (set! (-> v1-17 trans quad) (-> self control trans quad))
                (set! (-> v1-17 control) 0.0)
                (set! (-> v1-17 invinc-time) (the-as time-frame (-> *TARGET-bank* hit-invulnerable-timeout)))
                (set! (-> v1-17 damage) (-> *FACT-bank* health-default-inc))
                )
              (combine! a0-12 (the-as attack-info gp-0) self)
              )
            (cond
              ((= (-> self game mode) 'play)
               (send-event (handle->process (-> self turret handle)) 'trans (-> self control trans))
               (go target-death 'turret)
               #t
               )
              (else
                (go target-turret-get-off)
                #f
                )
              )
            )
           (('bot)
            (let ((a0-22 (-> self attack-info)))
              (let ((v1-33 a0-22))
                (set! (-> v1-33 attacker) (the-as handle #f))
                (set! (-> v1-33 mode) 'generic)
                (set! (-> v1-33 shove-back) 6144.0)
                (set! (-> v1-33 shove-up) 4915.2)
                (set! (-> v1-33 angle) #f)
                (set! (-> v1-33 trans quad) (-> self control trans quad))
                (set! (-> v1-33 control) 0.0)
                (set! (-> v1-33 invinc-time) (the-as time-frame (-> *TARGET-bank* hit-invulnerable-timeout)))
                (set! (-> v1-33 damage) (-> *FACT-bank* health-default-inc))
                )
              (combine! a0-22 (the-as attack-info gp-0) self)
              )
            (go target-death 'bot)
            )
           )
         )
       )
      (else
        (target-generic-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ((arg0 handle))
    (send-event (handle->process arg0) 'change-mode)
    (set! (-> self turret trans quad) (-> self control trans quad))
    (set! (-> self turret turret) (the-as (pointer base-turret) #f))
    (target-exit)
    (set! (-> self neck flex-blend) 0.0)
    (logior! (-> self state-flags) (state-flags sf2 sf5))
    (logior! (-> self focus-status) (focus-status disable grabbed))
    (set! (-> self control mod-surface) *empty-mods*)
    )
  :exit (behavior ()
    (target-exit)
    (logclear! (-> self state-flags) (state-flags sf2 sf5))
    (logclear! (-> self focus-status) (focus-status disable grabbed))
    (set! (-> self turret grabbed?) #f)
    (let ((v1-6 (-> self turret turret)))
      (if v1-6
          (deactivate (-> v1-6 0))
          )
      )
    )
  :trans (behavior ()
    '()
    )
  :code (behavior ((arg0 handle))
    (local-vars
      (v1-19 object)
      (a0-28 process)
      (a1-6 event-message-block)
      (t9-5 (function process-tree event-message-block object))
      )
    (let ((v1-2 (handle->process (-> self turret handle))))
      (if v1-2
          (quaternion<-rotate-y-vector (-> self control dir-targ) (vector-!
                                                                    (new 'stack-no-clear 'vector)
                                                                    (-> (the-as process-focusable v1-2) root trans)
                                                                    (-> self control trans)
                                                                    )
                                       )
          )
      )
    (set! (-> self control unknown-handle02) (-> self turret handle))
    (ja-channel-set! 1)
    (ja :group! jakb-turret-stance-ja)
    (until v1-19
      (suspend)
      (can-play-stance-amibent?)
      (ja :num! (loop! 0.5))
      (set! v1-19
            (and (or (not (-> self control unknown-handle02)) (cpad-pressed? (-> self control cpad number) triangle))
                 (send-event (handle->process (-> self turret handle)) 'exit-valid (-> self control unknown-vector38))
                 )
            )
      )
    (until (t9-5 a0-28 a1-6)
      (suspend)
      (set! a1-6 (new 'stack-no-clear 'event-message-block))
      (set! (-> a1-6 from) (process->ppointer self))
      (set! (-> a1-6 num-params) 0)
      (set! (-> a1-6 message) 'exit)
      (set! t9-5 send-event-function)
      (set! a0-28 (handle->process (-> self turret handle)))
      )
    (send-event self 'end-mode)
    (go target-turret-get-off)
    )
  :post (behavior ()
    (target-turret-post)
    )
  )

;; failed to figure out what this is:
(let ((a0-74 (copy *empty-mods* 'loading-level)))
  (set! (-> a0-74 flags) (surface-flag gun-off gun-fast-exit))
  (set! *turret-get-on-mods* a0-74)
  )

;; failed to figure out what this is:
(defstate target-turret-get-on (target)
  :event target-generic-event-handler
  :exit (behavior ()
    (logclear! (-> self state-flags) (state-flags sf6))
    )
  :code (behavior ((arg0 handle))
    (when (zero? (-> self turret))
      (set! (-> self turret) (new 'process 'turret-info))
      (set! (-> self turret process) (process->ppointer self))
      )
    (set! (-> self turret handle) arg0)
    (set! (-> self turret grabbed?) #f)
    (ja-channel-set! 1)
    (set! (-> self control mod-surface) *turret-get-on-mods*)
    (set! (-> self neck flex-blend) 0.0)
    (set! (-> self control unknown-vector37 quad) (-> self control trans quad))
    (set! (-> self control unknown-vector38 quad) (-> self control trans quad))
    (set! (-> self control unknown-vector39 quad) (-> self control quat quad))
    (set! (-> self control unknown-vector40 quad) (-> self control quat quad))
    (let* ((s4-0 (handle->process arg0))
           (s5-0 (if (type? s4-0 process-drawable)
                     s4-0
                     )
                 )
           )
      (when s5-0
        (vector-matrix*!
          (-> self control unknown-vector38)
          (new 'static 'vector :z -10649.6 :w 1.0)
          (-> (the-as process-focusable s5-0) node-list data 0 bone transform)
          )
        (set! (-> self control unknown-vector40 quad) (-> (the-as process-focusable s5-0) root quat quad))
        )
      )
    (set! (-> self alt-cam-pos quad) (-> self control camera-pos quad))
    (ja-no-eval :group! jakb-turret-get-on-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (let ((f30-0 (sin (lerp-scale 0.0 16384.0 (ja-aframe-num 0) 0.0 12.0))))
        (let ((f28-0 (lerp-scale 0.0 1.0 (ja-aframe-num 0) 0.0 12.0)))
          (let* ((s5-3 (handle->process arg0))
                 (a0-39 (if (type? s5-3 process-drawable)
                            s5-3
                            )
                        )
                 )
            (if a0-39
                (set! (-> self alt-cam-pos quad) (-> (the-as process-focusable a0-39) root trans quad))
                )
            )
          (vector-lerp!
            (-> self control trans)
            (-> self control unknown-vector37)
            (-> self control unknown-vector38)
            f30-0
            )
          (set! (-> self control trans y)
                (lerp (-> self control unknown-vector37 y) (-> self control unknown-vector38 y) f28-0)
                )
          )
        (quaternion-slerp!
          (-> self control quat-for-control)
          (the-as quaternion (-> self control unknown-vector39))
          (the-as quaternion (-> self control unknown-vector40))
          f30-0
          )
        )
      (rot->dir-targ! (-> self control))
      (suspend)
      (ja :num! (seek!))
      )
    (go target-turret-stance arg0)
    )
  :post target-no-move-post
  )

;; failed to figure out what this is:
(defstate target-turret-get-off (target)
  :event target-generic-event-handler
  :exit (behavior ()
    (target-exit)
    (logclear! (-> self state-flags) (state-flags sf6))
    )
  :code (behavior ()
    (set! (-> self control mod-surface) *empty-mods*)
    (rot->dir-targ! (-> self control))
    (set! (-> self neck flex-blend) 0.0)
    (send-event (handle->process (-> self turret handle)) 'trans (-> self turret trans))
    (let ((s5-0 (new 'stack-no-clear 'vector))
          (gp-0 (new 'stack-no-clear 'quaternion))
          )
      (vector-! s5-0 (-> self turret trans) (-> self control unknown-vector38))
      (vector-normalize! s5-0 1.0)
      (forward-up-nopitch->quaternion gp-0 s5-0 *y-vector*)
      (set! (-> self control unknown-vector40 quad) (-> gp-0 quad))
      )
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! jakb-turret-get-off-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (cond
        ((< (ja-aframe-num 0) 88.0)
         (send-event (handle->process (-> self turret handle)) 'quat (-> self control dir-targ))
         (set-quaternion! (-> self control) (-> self control dir-targ))
         (quaternion-copy! (the-as quaternion (-> self control unknown-vector39)) (-> self control quat-for-control))
         (let ((gp-1 (new 'stack-no-clear 'vector)))
           (set! (-> gp-1 quad) (-> self turret trans quad))
           (let ((s5-1 (new 'stack-no-clear 'vector)))
             (set! (-> s5-1 x) 0.0)
             (set! (-> s5-1 y) 0.0)
             (set! (-> s5-1 z) -10649.6)
             (set! (-> s5-1 w) 1.0)
             (vector-orient-by-quat! s5-1 s5-1 (-> self control dir-targ))
             (vector+! gp-1 gp-1 s5-1)
             )
           (move-to-point! (-> self control) gp-1)
           )
         (set! (-> self control unknown-vector37 quad) (-> self control trans quad))
         )
        (else
          (let ((f30-0 (sin (lerp-scale 0.0 16384.0 (ja-aframe-num 0) 88.0 102.0))))
            (let ((f28-0 (lerp-scale 0.0 1.0 (ja-aframe-num 0) 88.0 102.0)))
              (vector-lerp!
                (-> self control trans)
                (-> self control unknown-vector37)
                (-> self control unknown-vector38)
                f30-0
                )
              (set! (-> self control trans y)
                    (lerp (-> self control unknown-vector37 y) (-> self control unknown-vector38 y) f28-0)
                    )
              )
            (quaternion-slerp!
              (-> self control quat-for-control)
              (the-as quaternion (-> self control unknown-vector39))
              (the-as quaternion (-> self control unknown-vector40))
              f30-0
              )
            )
          )
        )
      (rot->dir-targ! (-> self control))
      (if (< 86.0 (ja-aframe-num 0))
          (vector<-cspace! (-> self alt-cam-pos) (joint-node jakb-lod0-jg Rankle))
          )
      (suspend)
      (ja :num! (seek!))
      )
    (rot->dir-targ! (-> self control))
    (ja-post)
    (let ((gp-4 (new 'stack-no-clear 'vector)))
      (vector<-cspace! gp-4 (joint-node jakb-lod0-jg main))
      (+! (-> gp-4 y) -9011.2)
      (move-to-point! (-> self control) gp-4)
      )
    (send-event *camera* 'ease-in)
    (ja-channel-set! 0)
    (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (let ((v1-96 (new-stack-vector0)))
      (let ((f0-20 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
        0.0
        (vector-! v1-96 (-> self control transv) (vector-float*! v1-96 (-> self control dynam gravity-normal) f0-20))
        )
      (let* ((f0-21 (vector-length v1-96))
             (f1-3 f0-21)
             (f2-0 -49152.0)
             (a0-61 (vector+!
                      (-> self control transv)
                      (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-0)
                      (vector-float*! v1-96 v1-96 (/ f0-21 f1-3))
                      )
                    )
             )
        (go target-falling (the-as symbol a0-61))
        )
      )
    )
  :post (behavior ()
    (target-no-move-post)
    )
  )
