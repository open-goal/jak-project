;;-*-Lisp-*-
(in-package goal)

;; definition of type elevator-params
(deftype elevator-params (structure)
  ((xz-threshold float   :offset-assert   0)
   (y-threshold  float   :offset-assert   4)
   (start-pos    float   :offset-assert   8)
   (move-rate    float   :offset-assert  12)
   (flags        uint64  :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x18
  :flag-assert         #x900000018
  )

;; definition for method 3 of type elevator-params
(defmethod inspect elevator-params ((obj elevator-params))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" obj 'elevator-params)
  (format #t "~1Txz-threshold: ~f~%" (-> obj xz-threshold))
  (format #t "~1Ty-threshold: ~f~%" (-> obj y-threshold))
  (format #t "~1Tstart-pos: ~f~%" (-> obj start-pos))
  (format #t "~1Tmove-rate: ~f~%" (-> obj move-rate))
  (format #t "~1Tflags: ~D~%" (-> obj flags))
  (label cfg-4)
  obj
  )

;; definition of type path-step
(deftype path-step (structure)
  ((next-pos float  :offset-assert   0)
   (dist     float  :offset-assert   4)
   )
  :method-count-assert 9
  :size-assert         #x8
  :flag-assert         #x900000008
  )

;; definition for method 3 of type path-step
(defmethod inspect path-step ((obj path-step))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" obj 'path-step)
  (format #t "~1Tnext-pos: ~f~%" (-> obj next-pos))
  (format #t "~1Tdist: ~f~%" (-> obj dist))
  (label cfg-4)
  obj
  )

;; definition of type path-step-inline-array
(deftype path-step-inline-array (inline-array-class)
  ((data path-step :inline :dynamic :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x10
  :flag-assert         #x900000010
  )

;; definition for method 3 of type path-step-inline-array
(defmethod inspect path-step-inline-array ((obj path-step-inline-array))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" obj (-> obj type))
  (format #t "~1Tlength: ~D~%" (-> obj length))
  (format #t "~1Tallocated-length: ~D~%" (-> obj allocated-length))
  (format #t "~1Tdata[0] @ #x~X~%" (-> obj data))
  (label cfg-4)
  obj
  )

;; failed to figure out what this is:
(set! (-> path-step-inline-array heap-base) (the-as uint 16))

;; definition of type elevator
(deftype elevator (base-plat)
  ((params                       elevator-params        :inline :offset-assert 272)
   (path-seq                     path-step-inline-array         :offset-assert 296)
   (path-dest                    float                          :offset-assert 300)
   (bottom-top                   float                  2       :offset-assert 304)
   (move-pos                     float                  2       :offset-assert 312)
   (move-dist                    float                          :offset-assert 320)
   (path-pos                     float                          :offset-assert 324)
   (path-eased-pos               float                          :offset-assert 328)
   (ride-timer                   uint64                         :offset-assert 336)
   (sticky-player-last-ride-time time-frame                     :offset-assert 344)
   (elevator-status              uint64                         :offset-assert 352)
   (on-activate                  basic                          :offset-assert 360)
   (on-deactivate                basic                          :offset-assert 364)
   )
  :heap-base #xf0
  :method-count-assert 49
  :size-assert         #x170
  :flag-assert         #x3100f00170
  (:methods
    (dormant () _type_ :state 34)
    (waiting () _type_ :state 35)
    (running () _type_ :state 36)
    (arrived () _type_ :state 37)
    (elevator-method-38 (_type_) none 38)
    (elevator-method-39 (_type_ int int) none 39)
    (elevator-method-40 (_type_) object 40)
    (elevator-method-41 (_type_) none 41)
    (elevator-method-42 (_type_) none 42)
    (elevator-method-43 (_type_) object 43)
    (elevator-method-44 (_type_) symbol 44)
    (elevator-method-45 (_type_) symbol 45)
    (elevator-method-46 (_type_) none 46)
    (elevator-method-47 (_type_ vector vector symbol symbol) symbol 47)
    (elevator-method-48 (_type_) none 48)
    )
  )

;; definition for method 3 of type elevator
(defmethod inspect elevator ((obj elevator))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type base-plat inspect)))
    (t9-0 obj)
    )
  (format #t "~2Tparams: #<elevator-params @ #x~X>~%" (-> obj params))
  (format #t "~2Tpath-seq: ~A~%" (-> obj path-seq))
  (format #t "~2Tpath-dest: ~f~%" (-> obj path-dest))
  (format #t "~2Tbottom-top[2] @ #x~X~%" (-> obj bottom-top))
  (format #t "~2Tmove-pos[2] @ #x~X~%" (-> obj move-pos))
  (format #t "~2Tmove-dist: ~f~%" (-> obj move-dist))
  (format #t "~2Tpath-pos: ~f~%" (-> obj path-pos))
  (format #t "~2Tpath-eased-pos: ~f~%" (-> obj path-eased-pos))
  (format #t "~2Tride-timer: ~D~%" (-> obj ride-timer))
  (format #t "~2Tsticky-player-last-ride-time: ~D~%" (-> obj sticky-player-last-ride-time))
  (format #t "~2Televator-status: ~D~%" (-> obj elevator-status))
  (format #t "~2Ton-activate: ~A~%" (-> obj on-activate))
  (format #t "~2Ton-deactivate: ~A~%" (-> obj on-deactivate))
  (label cfg-4)
  obj
  )

;; definition for method 43 of type elevator
;; WARN: Return type mismatch symbol vs object.
(defmethod elevator-method-43 elevator ((obj elevator))
  (the-as object #f)
  )

;; definition for method 48 of type elevator
;; INFO: Used lq/sq
(defmethod elevator-method-48 elevator ((obj elevator))
  (let ((gp-0 *target*))
    (when gp-0
      (let ((s4-0 (-> gp-0 control unknown-sphere-array00 0))
            (s5-0 (new 'stack-no-clear 'collide-query))
            )
        (set! (-> s5-0 start-pos quad) (-> s4-0 prim-core world-sphere quad))
        (set! (-> s5-0 start-pos y) (+ 8192.0 (-> s5-0 start-pos y)))
        (set! (-> s5-0 start-pos w) 1.0)
        (vector-reset! (-> s5-0 move-dist))
        (set! (-> s5-0 move-dist y) -90112.0)
        (let ((v1-6 s5-0))
          (set! (-> v1-6 radius) (-> s4-0 local-sphere w))
          (set! (-> v1-6 collide-with) (collide-spec hit-by-others-list pusher))
          (set! (-> v1-6 ignore-process0) gp-0)
          (set! (-> v1-6 ignore-process1) #f)
          (set! (-> v1-6 ignore-pat) (-> gp-0 control pat-ignore-mask))
          (set! (-> v1-6 action-mask) (collide-action solid))
          )
        (let ((f0-5 (fill-and-probe-using-line-sphere *collide-cache* s5-0)))
          (when (< 0.0 f0-5)
            (vector-float*! (-> s5-0 move-dist) (-> s5-0 move-dist) f0-5)
            (vector+! (-> s5-0 move-dist) (-> s5-0 move-dist) (-> s5-0 start-pos))
            (vector-! (-> s5-0 move-dist) (-> s5-0 move-dist) (the-as vector (-> s4-0 prim-core)))
            (let ((t9-1 (method-of-object (-> gp-0 control) collide-shape-method-28)))
              (-> s5-0 move-dist)
              (t9-1)
              )
            )
          )
        )
      )
    )
  (none)
  )

;; definition for method 41 of type elevator
;; WARN: Return type mismatch int vs none.
(defmethod elevator-method-41 elevator ((obj elevator))
  (let ((a0-1 (-> obj entity)))
    (set! (-> obj params xz-threshold) ((method-of-object a0-1 get-property-value-float)
                                        a0-1
                                        'elevator-xz-threshold
                                        'interp
                                        -1000000000.0
                                        81920.0
                                        (the-as (pointer res-tag) #f)
                                        *res-static-buf*
                                        )
          )
    )
  (let ((a0-2 (-> obj entity)))
    (set! (-> obj params y-threshold) ((method-of-object a0-2 get-property-value-float)
                                       a0-2
                                       'elevator-y-threshold
                                       'interp
                                       -1000000000.0
                                       20480.0
                                       (the-as (pointer res-tag) #f)
                                       *res-static-buf*
                                       )
          )
    )
  (let ((a0-3 (-> obj entity)))
    (set! (-> obj params start-pos) ((method-of-object a0-3 get-property-value-float)
                                     a0-3
                                     'elevator-start-pos
                                     'interp
                                     -1000000000.0
                                     0.0
                                     (the-as (pointer res-tag) #f)
                                     *res-static-buf*
                                     )
          )
    )
  (let ((a0-4 (-> obj entity)))
    (set! (-> obj params move-rate) ((method-of-object a0-4 get-property-value-float)
                                     a0-4
                                     'elevator-move-rate
                                     'interp
                                     -1000000000.0
                                     25600.0
                                     (the-as (pointer res-tag) #f)
                                     *res-static-buf*
                                     )
          )
    )
  (let ((a0-5 (-> obj entity)))
    (set! (-> obj params flags) (the-as uint ((method-of-object a0-5 get-property-value)
                                              a0-5
                                              'elevator-flags
                                              'interp
                                              -1000000000.0
                                              (the-as uint128 1)
                                              (the-as (pointer res-tag) #f)
                                              *res-static-buf*
                                              )
                                        )
          )
    )
  0
  (none)
  )

;; definition for function ease-value-in-out
(defun ease-value-in-out ((arg0 float) (arg1 float))
  (let* ((f0-0 arg1)
         (f4-0 (- 1.0 arg1))
         (f3-0 (/ f0-0 (- 1.0 f4-0)))
         (f2-1 (* f0-0 f0-0))
         (f1-6 (+ (* 2.0 f0-0 (- f4-0 f0-0)) f2-1))
         (f1-7 (+ (* (- 1.0 f4-0) (- 1.0 f4-0) f3-0) f1-6))
         )
    (/ (cond
         ((< arg0 f0-0)
          (* arg0 arg0)
          )
         ((< arg0 f4-0)
          (+ (* 2.0 f0-0 (- arg0 f0-0)) f2-1)
          )
         (else
           (let ((f0-7 (- 1.0 arg0)))
             (- f1-7 (* f0-7 f0-7 f3-0))
             )
           )
         )
       f1-7
       )
    )
  )

;; definition for function elevator-event
;; WARN: Return type mismatch none vs object.
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 18]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 119]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 209]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 222]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 236]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 246]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 257]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 264]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 276]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 301]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 326]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 334]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 337]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 174]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 40]
;; WARN: disable def twice: 11. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defbehavior elevator-event elevator ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (let ((v1-0 arg2))
    (the-as
      object
      (cond
        ((= v1-0 'status?)
         (and (= (the float (/ (the-as int (-> arg3 param 0)) 8)) (-> self move-pos 0))
              (= (the float (/ (the-as int (-> arg3 param 1)) 8)) (-> self move-pos 1))
              )
         )
        ((= v1-0 'ridden)
         (let ((v1-8 (handle->process (-> (the-as focus (-> arg3 param 0)) handle))))
           (if (= (-> v1-8 type) target)
               (set! (-> self sticky-player-last-ride-time) (-> self clock frame-counter))
               )
           )
         #t
         )
        ((= v1-0 'use-camera)
         (if (-> arg3 param 0)
             (set-setting! 'entity-name (-> arg3 param 0) 0 0)
             (remove-setting! 'entity-name)
             )
         )
        ((= v1-0 'move-to)
         (when (and (-> self next-state) (let ((v1-20 (-> self next-state name)))
                                           (or (= v1-20 'waiting) (= v1-20 'arrived))
                                           )
                    )
           (set! (-> self move-pos 0) (-> self move-pos 1))
           (cond
             ((not (logtest? (-> arg3 param 0) 7))
              (let ((gp-0 (the-as number (-> arg3 param 0))))
                (set! (-> self move-pos 1) (if (type? (the-as uint gp-0) float)
                                               (the-as float gp-0)
                                               )
                      )
                )
              )
             (else
               (case (-> arg3 param 0)
                 (('quote 'bottom)
                  (set! (-> self move-pos 1) (-> self bottom-top 0))
                  )
                 (('quote 'top)
                  (set! (-> self move-pos 1) (-> self bottom-top 1))
                  )
                 )
               )
             )
           (go-virtual running)
           )
         )
        ((= v1-0 'jump-to)
         (cond
           ((not (logtest? (-> arg3 param 0) 7))
            (let ((gp-1 (the-as number (-> arg3 param 0))))
              (set! (-> self move-pos 1) (if (type? (the-as uint gp-1) float)
                                             (the-as float gp-1)
                                             )
                    )
              )
            )
           (else
             (case (-> arg3 param 0)
               (('quote 'bottom)
                (set! (-> self move-pos 1) (-> self bottom-top 0))
                )
               (('quote 'top)
                (set! (-> self move-pos 1) (-> self bottom-top 1))
                )
               )
             )
           )
         (set! (-> self move-pos 0) (-> self move-pos 1))
         (get-point-in-path! (-> self path) (-> self basetrans) (-> self move-pos 0) 'interp)
         (go-virtual waiting)
         )
        ((= v1-0 'trigger)
         (when (and (-> self next-state) (let ((v1-48 (-> self next-state name)))
                                           (or (= v1-48 'waiting) (= v1-48 'arrived))
                                           )
                    )
           (set! (-> self move-pos 0) (-> self move-pos 1))
           (cond
             ((= (-> self move-pos 0) (-> self bottom-top 0))
              (set! (-> self move-pos 1) (-> self bottom-top 1))
              )
             ((= (-> self move-pos 0) (-> self bottom-top 1))
              (set! (-> self move-pos 1) (-> self bottom-top 0))
              )
             )
           (go-virtual running)
           )
         )
        ((= v1-0 'query)
         (case (-> arg3 param 0)
           (('waiting?)
            (and (-> self next-state) (= (-> self next-state name) 'waiting))
            )
           (('arrived?)
            (and (-> self next-state) (let ((v1-61 (-> self next-state name)))
                                        (or (= v1-61 'arrived) (= v1-61 'waiting))
                                        )
                 )
            )
           (('running?)
            (and (-> self next-state) (= (-> self next-state name) 'running))
            )
           (('path-pos?)
            (+ (-> self move-pos 0) (* (-> self path-pos) (- (-> self move-pos 1) (-> self move-pos 0))))
            )
           (('player-standing-on?)
            (= (-> self sticky-player-last-ride-time) (-> self clock frame-counter))
            )
           (('point-inside-shaft?)
            (let* ((a0-45 self)
                   (t9-8 (method-of-object a0-45 elevator-method-43))
                   )
              (-> arg3 param 1)
              (-> self bottom-top 1)
              (-> self bottom-top 0)
              (t9-8 a0-45)
              )
            )
           (('going-down?)
            (< (-> (get-point-in-path! (-> self path) (new 'stack-no-clear 'vector) (-> self move-pos 1) 'interp) y)
               (-> (get-point-in-path! (-> self path) (new 'stack-no-clear 'vector) (-> self move-pos 0) 'interp) y)
               )
            )
           (('going-up?)
            (< (-> (get-point-in-path! (-> self path) (new 'stack-no-clear 'vector) (-> self move-pos 0) 'interp) y)
               (-> (get-point-in-path! (-> self path) (new 'stack-no-clear 'vector) (-> self move-pos 1) 'interp) y)
               )
            )
           )
         )
        ((= v1-0 'go-dormant)
         (go-virtual dormant)
         )
        (else
          (plat-event arg0 arg1 arg2 arg3)
          )
        )
      )
    )
  )

;; definition for method 47 of type elevator
;; INFO: Used lq/sq
(defmethod elevator-method-47 elevator ((obj elevator) (arg0 vector) (arg1 vector) (arg2 symbol) (arg3 symbol))
  (local-vars (sv-32 vector))
  (let ((s1-0 (-> obj params))
        (f28-0 0.0)
        (f30-0 -1.0)
        )
    (dotimes (s0-0 (-> obj path curve num-cverts))
      (set! sv-32 (get-point-in-path! (-> obj path) (new 'stack-no-clear 'vector) (the float s0-0) 'interp))
      (when (and (or (not arg2) (< (vector-vector-xz-distance sv-32 arg0) (-> s1-0 xz-threshold)))
                 (or (not arg3)
                     (< (fabs (- (-> sv-32 y) (-> arg0 y))) (-> s1-0 y-threshold))
                     (and (= s0-0 (the int (-> obj bottom-top 0))) (< (-> arg0 y) (-> sv-32 y)))
                     (and (= s0-0 (the int (-> obj bottom-top 1))) (< (-> sv-32 y) (-> arg0 y)))
                     )
                 )
        (let* ((t9-2 vector-vector-distance)
               (a1-3 arg0)
               (f0-12 (t9-2 sv-32 a1-3))
               )
          (when (or (= f30-0 -1.0) (< f0-12 f28-0))
            (set! f28-0 f0-12)
            (set! f30-0 (the float s0-0))
            )
          )
        )
      )
    (when (!= f30-0 -1.0)
      (set! (-> arg1 x) f30-0)
      #t
      )
    )
  )

;; definition for method 44 of type elevator
;; WARN: Return type mismatch object vs symbol.
(defmethod elevator-method-44 elevator ((obj elevator))
  (let* ((s5-0 *target*)
         (a0-2 (if (type? s5-0 process-focusable)
                   s5-0
                   )
               )
         )
    (the-as symbol (and a0-2 (let* ((s5-1 obj)
                                    (s4-0 (method-of-object s5-1 elevator-method-43))
                                    )
                               (get-trans a0-2 0)
                               (-> obj move-pos 0)
                               (-> obj move-pos 1)
                               (s4-0 s5-1)
                               )
                        )
            )
    )
  )

;; definition for method 45 of type elevator
(defmethod elevator-method-45 elevator ((obj elevator))
  #t
  )

;; definition for method 46 of type elevator
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Return type mismatch int vs none.
(defmethod elevator-method-46 elevator ((obj elevator))
  (local-vars (sv-16 float))
  (let ((a0-1 *target*))
    (when (and a0-1
               (zero? (logand (focus-status dead inactive in-air grabbed edge-grab pole pilot-riding pilot teleporting)
                              (-> a0-1 focus-status)
                              )
                      )
               )
      (set! sv-16 (the-as float 0.0))
      (when (and (elevator-method-47 obj (get-trans a0-1 0) (new 'stack-no-clear 'vector) #t #t)
                 (!= (-> obj move-pos 1) sv-16)
                 )
        (set! (-> obj move-pos 0) (-> obj move-pos 1))
        (set! (-> obj move-pos 1) sv-16)
        (logior! (-> obj elevator-status) 4)
        (go (method-of-object obj running))
        )
      )
    )
  0
  (none)
  )

;; definition for function move-post
(defbehavior move-post elevator ()
  (when (nonzero? (-> self sound))
    (let ((f0-3 (sqrtf (sin-rad (* 3.1415925 (-> self path-pos))))))
      (update-vol! (-> self sound) f0-3)
      )
    (update-trans! (-> self sound) (-> self root-override trans))
    (update! (-> self sound))
    )
  (plat-post)
  (none)
  )

;; failed to figure out what this is:
(defstate dormant (elevator)
  :virtual #t
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (case arg2
      (('trigger)
       (go-virtual waiting)
       )
      (('bonk)
       #f
       )
      (else
        (plat-event arg0 arg1 arg2 arg3)
        )
      )
    )
  :trans (the-as (function none :behavior elevator) plat-trans)
  :code (the-as (function none :behavior elevator) sleep-code)
  :post (the-as (function none :behavior elevator) plat-post)
  )

;; failed to figure out what this is:
(defstate waiting (elevator)
  :virtual #t
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (case arg2
      (('ridden)
       (if (elevator-method-45 self)
           (logior! (-> self elevator-status) 1)
           )
       (elevator-event arg0 arg1 arg2 arg3)
       )
      (else
        (elevator-event arg0 arg1 arg2 arg3)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self ride-timer) (the-as uint (-> self clock frame-counter)))
    (set! (-> self elevator-status) (logand -6 (-> self elevator-status)))
    (logior! (-> self mask) (process-mask actor-pause))
    (if (nonzero? (-> self sound))
        (update-vol! (-> self sound) 0.0)
        )
    (none)
    )
  :trans (behavior ()
    (plat-trans)
    (when (not (logtest? (-> self elevator-status) 1))
      (set! (-> self ride-timer) (the-as uint (-> self clock frame-counter)))
      (-> self params)
      (if (and (logtest? (-> self params flags) 1) (zero? (logand (-> self params flags) 8)))
          (elevator-method-46 self)
          )
      )
    (when (and (not (logtest? (-> self params flags) 8))
               (>= (- (-> self clock frame-counter) (the-as int (-> self ride-timer))) (seconds 1))
               )
      (set! (-> self move-pos 0) (-> self move-pos 1))
      (set! (-> self move-pos 1) (-> self path-seq data (the int (-> self move-pos 1)) next-pos))
      (go-virtual running)
      )
    (none)
    )
  :code (the-as (function none :behavior elevator) sleep-code)
  :post (behavior ()
    (set! (-> self elevator-status) (logand -2 (-> self elevator-status)))
    (debug-draw (-> self path))
    (plat-post)
    (none)
    )
  )

;; failed to figure out what this is:
(defstate running (elevator)
  :virtual #t
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (case arg2
      (('running?)
       #t
       )
      (('player-ridden?)
       (logtest? (-> self elevator-status) 1)
       )
      (else
        (elevator-event arg0 arg1 arg2 arg3)
        )
      )
    )
  :enter (behavior ()
    (if (not (logtest? (-> self params flags) 128))
        (process-entity-status! self (entity-perm-status no-kill) #t)
        )
    (set! (-> self elevator-status) (logand -3 (-> self elevator-status)))
    (when (logtest? (-> self params flags) 4)
      (set! (-> self params flags) (logand -5 (-> self params flags)))
      (logior! (-> self params flags) 1)
      )
    (set! (-> self move-dist) 0.0)
    (let ((v1-13 (the int (-> self move-pos 0)))
          (a0-3 (the int (-> self move-pos 1)))
          (a1-1 0)
          )
      (while (let ((a2-3 (abs (- a0-3 v1-13))))
               (< a1-1 a2-3)
               )
        (+! (-> self move-dist) (-> self path-seq data (+ (min v1-13 a0-3) a1-1) dist))
        (+! a1-1 1)
        )
      )
    (logclear! (-> self mask) (process-mask actor-pause))
    (set-setting! 'board #f 0 0)
    (let ((gp-0 (-> self on-activate)))
      (if gp-0
          (eval!
            (new
              'stack
              'script-context
              (the-as basic (* (the int (-> self move-pos 0)) 8))
              self
              (-> self root-override trans)
              )
            (the-as pair gp-0)
            )
          )
      )
    (set! (-> self path-pos) 0.0)
    (if (nonzero? (-> self sound))
        (update-vol! (-> self sound) 0.0)
        )
    (when (logtest? (-> self params flags) 32)
      (set-setting! 'jump #f 0 0)
      (apply-settings *setting-control*)
      )
    (none)
    )
  :exit (behavior ()
    (if (not (logtest? (-> self params flags) 128))
        (process-entity-status! self (entity-perm-status no-kill) #f)
        )
    (remove-setting! 'board)
    (if (logtest? (-> self params flags) 32)
        (remove-setting! 'jump)
        )
    (none)
    )
  :trans (behavior ()
    (if (and (not (logtest? (-> self elevator-status) 2)) (= (-> self path-pos) 1.0))
        (go-virtual arrived)
        )
    (if (elevator-method-44 self)
        (set! (-> self path-dest) 0.0)
        (set! (-> self path-dest) 1.0)
        )
    (if (logtest? (-> self params flags) 32)
        (elevator-method-48 self)
        )
    (plat-trans)
    (none)
    )
  :code (behavior ()
    (logior! (-> self elevator-status) 2)
    (until #f
      (suspend)
      (if (= (-> self path-pos) 1.0)
          (set! (-> self elevator-status) (logand -3 (-> self elevator-status)))
          )
      )
    #f
    (none)
    )
  :post (behavior ()
    (when (logtest? (-> self elevator-status) 2)
      (seek!
        (-> self path-pos)
        (-> self path-dest)
        (* (/ (-> self params move-rate) (-> self move-dist)) (-> self clock seconds-per-frame))
        )
      (let* ((f30-0 (-> self move-pos 0))
             (f28-0 (-> self move-pos 1))
             (f0-9 (+ f30-0 (* (ease-value-in-out (-> self path-pos) 0.08) (- f28-0 f30-0))))
             )
        (get-point-in-path! (-> self path) (-> self basetrans) f0-9 'interp)
        )
      )
    (move-post)
    (none)
    )
  )

;; failed to figure out what this is:
(defstate arrived (elevator)
  :virtual #t
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (case arg2
      (('ridden)
       (set! (-> self ride-timer) (the-as uint (-> self clock frame-counter)))
       (elevator-event arg0 arg1 arg2 arg3)
       )
      (else
        (elevator-event arg0 arg1 arg2 arg3)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self ride-timer) (the-as uint (-> self clock frame-counter)))
    (if (not (-> *setting-control* user-current jump))
        (remove-setting! 'jump)
        )
    (let ((gp-0 (-> self on-deactivate)))
      (if gp-0
          (eval!
            (new
              'stack
              'script-context
              (the-as basic (* (the int (-> self move-pos 1)) 8))
              self
              (-> self root-override trans)
              )
            (the-as pair gp-0)
            )
          )
      )
    (none)
    )
  :trans (behavior ()
    (if (and (< (the-as int (- (-> self ride-timer) (the-as uint (-> self sticky-player-last-ride-time)))) 600)
             (begin *target* *target*)
             (logtest? (-> *target* focus-status) (focus-status in-air))
             )
        (set! (-> self ride-timer) (the-as uint (-> self clock frame-counter)))
        )
    (when (or (logtest? (-> self elevator-status) 4)
              (>= (- (-> self clock frame-counter) (the-as int (-> self ride-timer))) (seconds 0.5))
              )
      (cond
        ((and (logtest? (-> self params flags) 2) (!= (-> self move-pos 1) (-> self params start-pos)))
         (set! (-> self move-pos 0) (-> self move-pos 1))
         (set! (-> self move-pos 1) (-> self params start-pos))
         (go-virtual running)
         )
        (else
          (go-virtual waiting)
          )
        )
      )
    (plat-trans)
    (none)
    )
  :code (the-as (function none :behavior elevator) sleep-code)
  :post (the-as (function none :behavior elevator) plat-post)
  )

;; definition for method 39 of type elevator
;; WARN: Return type mismatch int vs none.
(defmethod elevator-method-39 elevator ((obj elevator) (arg0 int) (arg1 int))
  (set! (-> obj path-seq data arg0 next-pos) (the float arg1))
  (let ((s3-0 (get-point-in-path! (-> obj path) (new 'stack-no-clear 'vector) (the float arg0) 'interp))
        (a1-3 (get-point-in-path! (-> obj path) (new 'stack-no-clear 'vector) (the float arg1) 'interp))
        )
    (set! (-> obj path-seq data arg0 dist) (vector-vector-distance s3-0 a1-3))
    )
  0
  (none)
  )

;; definition for method 42 of type elevator
;; WARN: Return type mismatch int vs none.
(defmethod elevator-method-42 elevator ((obj elevator))
  (set! (-> obj sound) (the-as ambient-sound 0))
  0
  (none)
  )

;; definition for method 33 of type elevator
;; WARN: Return type mismatch int vs none.
(defmethod base-plat-method-33 elevator ((obj elevator))
  0
  (none)
  )

;; definition for method 7 of type elevator
;; WARN: Return type mismatch base-plat vs elevator.
(defmethod relocate elevator ((obj elevator) (arg0 int))
  (if (nonzero? (-> obj path-seq))
      (&+! (-> obj path-seq) arg0)
      )
  (the-as elevator ((the-as (function base-plat int base-plat) (find-parent-method elevator 7)) obj arg0))
  )

;; definition for method 40 of type elevator
(defmethod elevator-method-40 elevator ((obj elevator))
  (if (logtest? (-> obj params flags) 64)
      (go (method-of-object obj arrived))
      (go (method-of-object obj waiting))
      )
  )

;; definition for method 11 of type elevator
;; WARN: Stack slot offset 32 signed mismatch
;; WARN: Stack slot offset 32 signed mismatch
;; WARN: Stack slot offset 32 signed mismatch
;; WARN: Stack slot offset 32 signed mismatch
;; WARN: Stack slot offset 32 signed mismatch
;; WARN: Stack slot offset 32 signed mismatch
;; WARN: Stack slot offset 32 signed mismatch
;; WARN: Stack slot offset 32 signed mismatch
;; WARN: Stack slot offset 32 signed mismatch
;; WARN: Stack slot offset 32 signed mismatch
;; WARN: Stack slot offset 32 signed mismatch
;; WARN: Stack slot offset 32 signed mismatch
;; WARN: Stack slot offset 32 signed mismatch
;; WARN: Stack slot offset 32 signed mismatch
;; WARN: Stack slot offset 32 signed mismatch
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! elevator ((obj elevator) (arg0 entity-actor))
  (local-vars (sv-32 float) (sv-36 path-control) (sv-40 target))
  (base-plat-method-31 obj)
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj (the-as skeleton-group (base-plat-method-30 obj)) (the-as pair 0))
  (base-plat-method-28 obj)
  (set! (-> obj elevator-status) (the-as uint 0))
  (collide-shape-method-46 (-> obj root-override))
  (base-plat-method-32 obj)
  (elevator-method-41 obj)
  (set! (-> obj on-activate) (res-lump-struct (-> obj entity) 'on-activate basic))
  (set! (-> obj on-deactivate) (res-lump-struct (-> obj entity) 'on-deactivate basic))
  (set! (-> obj path) (new 'process 'path-control obj 'path 0.0 arg0 #f))
  (if (logtest? (-> obj path flags) (path-control-flag not-found))
      (go process-drawable-art-error "error in path")
      )
  (logior! (-> obj path flags) (path-control-flag display draw-line draw-point draw-text))
  (let ((s5-1 (-> obj path curve num-cverts))
        (s4-1 0)
        (f30-0 0.0)
        (f28-0 0.0)
        )
    (set! (-> obj path-seq) (new 'process 'path-step-inline-array s5-1))
    (dotimes (s3-1 s5-1)
      (elevator-method-39 obj s3-1 (mod (+ s3-1 1) s5-1))
      (let ((v1-31 (get-point-in-path! (-> obj path) (new 'stack-no-clear 'vector) (the float s3-1) 'interp)))
        (when (or (not (logtest? s4-1 1)) (< (-> v1-31 y) f28-0))
          (set! (-> obj bottom-top 0) (the float s3-1))
          (set! f28-0 (-> v1-31 y))
          (set! s4-1 (logior s4-1 1))
          )
        (when (or (not (logtest? s4-1 2)) (< f30-0 (-> v1-31 y)))
          (set! (-> obj bottom-top 1) (the float s3-1))
          (set! f30-0 (-> v1-31 y))
          (set! s4-1 (logior s4-1 2))
          )
        )
      )
    )
  (set! sv-32 (the-as float 0.0))
  (set! sv-36 (-> obj path))
  (let ((s5-2 *target*))
    (set! sv-40 (if (type? s5-2 process-focusable)
                    s5-2
                    )
          )
    )
  (if (not (and sv-40
                (logtest? (-> obj params flags) 16)
                (elevator-method-47 obj (get-trans sv-40 0) (the-as vector (& sv-32)) #f #t)
                )
           )
      (set! sv-32 (-> obj params start-pos))
      )
  (set! (-> obj move-pos 0) sv-32)
  (set! (-> obj move-pos 1) sv-32)
  (get-point-in-path! sv-36 (-> obj basetrans) sv-32 'interp)
  (set! (-> obj root-override pause-adjust-distance)
        (+ 122880.0 (-> obj params xz-threshold) (total-distance (-> obj path)))
        )
  (elevator-method-42 obj)
  (base-plat-method-33 obj)
  (elevator-method-40 obj)
  (none)
  )
