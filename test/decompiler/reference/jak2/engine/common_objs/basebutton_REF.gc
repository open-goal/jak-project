;;-*-Lisp-*-
(in-package goal)

;; definition of type basebutton
(deftype basebutton (process-focusable)
  ((button-status     uint16                        :offset-assert 204)
   (notify-actor      entity-actor                  :offset-assert 208)
   (actor-group       (pointer actor-group)         :offset-assert 212)
   (actor-group-count int32                         :offset-assert 216)
   (timeout           float                         :offset-assert 220)
   (button-id         int32                         :offset-assert 224)
   (event-going-down  symbol                        :offset-assert 228)
   (event-down        symbol                        :offset-assert 232)
   (event-going-up    symbol                        :offset-assert 236)
   (event-up          symbol                        :offset-assert 240)
   (anim-speed        float                         :offset-assert 244)
   (move-to-pos       vector                :inline :offset-assert 256)
   (move-to-quat      quaternion            :inline :offset-assert 272)
   )
  :heap-base #xa0
  :method-count-assert 39
  :size-assert         #x120
  :flag-assert         #x2700a00120
  (:methods
    (down-idle () _type_ :state 27)
    (going-down () _type_ :state 28)
    (going-up () _type_ :state 29)
    (up-idle () _type_ :state 30)
    (basebutton-method-31 (_type_) none 31)
    (basebutton-method-32 (_type_) none 32)
    (basebutton-method-33 (_type_) none 33)
    (basebutton-method-34 (_type_) none 34)
    (basebutton-method-35 (_type_) none 35)
    (basebutton-method-36 (_type_ symbol) none 36)
    (basebutton-method-37 (_type_ vector quaternion) none 37)
    (basebutton-method-38 (_type_ symbol) none 38)
    )
  )

;; definition for method 3 of type basebutton
(defmethod inspect basebutton ((obj basebutton))
  (when (not obj)
    (set! obj obj)
    (goto cfg-7)
    )
  (let ((t9-0 (method-of-type process-focusable inspect)))
    (t9-0 obj)
    )
  (format #t "~2Tbutton-status: ~D~%" (-> obj button-status))
  (format #t "~2Tnotify-actor: ~A~%" (-> obj notify-actor))
  (format #t "~2Tactor-group: #x~X~%" (-> obj actor-group))
  (dotimes (s5-0 (-> obj actor-group-count))
    (format #t "~T  [~D]~2Tactor-group: ~`actor-group`P~%" s5-0 (-> obj actor-group s5-0))
    )
  (format #t "~2Tactor-group-count: ~D~%" (-> obj actor-group-count))
  (format #t "~2Ttimeout: ~f~%" (-> obj timeout))
  (format #t "~2Tbutton-id: ~D~%" (-> obj button-id))
  (format #t "~2Tevent-going-down: ~A~%" (-> obj event-going-down))
  (format #t "~2Tevent-down: ~A~%" (-> obj event-down))
  (format #t "~2Tevent-going-up: ~A~%" (-> obj event-going-up))
  (format #t "~2Tevent-up: ~A~%" (-> obj event-up))
  (format #t "~2Tanim-speed: ~f~%" (-> obj anim-speed))
  (format #t "~2Tmove-to-pos: #<vector @ #x~X>~%" (-> obj move-to-pos))
  (format #t "~2Tmove-to-quat: #<quaternion @ #x~X>~%" (-> obj move-to-quat))
  (label cfg-7)
  obj
  )

;; failed to figure out what this is:
(let ((a0-2 (new 'static 'skeleton-group
              :name "skel-generic-button"
              :extra #f
              :info #f
              :art-group-name "mtn-dice-button"
              :bounds (new 'static 'vector :w 12288.0)
              :version #x7
              )
            )
      )
  (set! (-> a0-2 jgeo) 0)
  (set! (-> a0-2 janim) 3)
  (set! (-> a0-2 mgeo 0) 1)
  (set! (-> a0-2 lod-dist 0) 4095996000.0)
  (add-to-loading-level a0-2)
  )

;; definition for method 37 of type basebutton
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod basebutton-method-37 basebutton ((obj basebutton) (arg0 vector) (arg1 quaternion))
  (set! (-> obj button-status) (logand -5 (-> obj button-status)))
  (if arg0
      (set! (-> obj move-to-pos quad) (-> arg0 quad))
      (set! (-> obj move-to-pos quad) (-> obj root trans quad))
      )
  (if arg1
      (quaternion-copy! (-> obj move-to-quat) arg1)
      (quaternion-copy! (-> obj move-to-quat) (-> obj root quat))
      )
  0
  (none)
  )

;; definition for method 32 of type basebutton
;; WARN: Return type mismatch object vs none.
(defmethod basebutton-method-32 basebutton ((obj basebutton))
  (if (logtest? (-> obj button-status) 1)
      (go (method-of-object obj down-idle))
      (go (method-of-object obj up-idle))
      )
  (none)
  )

;; failed to figure out what this is:
(defstate up-idle (basebutton)
  :virtual #t
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (let ((v1-0 arg2))
      (the-as
        object
        (cond
          ((= v1-0 'attack)
           (let ((v1-1 (the-as attack-info (-> arg3 param 1))))
             (case (-> v1-1 mode)
               (('flop 'spin 'punch 'eco-yellow 'eco-red 'eco-blue 'eco-dark)
                (when (or (not (or (= (-> v1-1 mode) 'spin) (= (-> v1-1 mode) 'punch))) (logtest? (-> self button-status) 8))
                  (basebutton-method-36 self (-> self event-going-down))
                  (go-virtual going-down)
                  )
                )
               )
             )
           )
          ((= v1-0 'trigger)
           (sound-play "silo-button")
           (go-virtual going-down)
           )
          ((= v1-0 'touch)
           (when (logtest? (-> self button-status) 16)
             (basebutton-method-36 self (-> self event-going-down))
             (go-virtual going-down)
             )
           )
          ((= v1-0 'move-to)
           (basebutton-method-37 self (the-as vector (-> arg3 param 0)) (the-as quaternion (-> arg3 param 1)))
           )
          )
        )
      )
    )
  :enter (behavior ()
    (basebutton-method-38 self #f)
    (none)
    )
  :trans (behavior ()
    (if (logtest? (-> self button-status) 4)
        (rider-trans)
        )
    (none)
    )
  :code (the-as (function none :behavior basebutton) sleep-code)
  :post (behavior ()
    (when (logtest? (-> self button-status) 4)
      (set! (-> self button-status) (logand -5 (-> self button-status)))
      (set! (-> self root trans quad) (-> self move-to-pos quad))
      (quaternion-copy! (-> self root quat) (-> self move-to-quat))
      (rider-post)
      )
    (none)
    )
  )

;; failed to figure out what this is:
(defstate going-down (basebutton)
  :virtual #t
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (let ((v1-0 arg2))
      (the-as
        object
        (cond
          ((= v1-0 'untrigger)
           (go-virtual going-up)
           )
          ((= v1-0 'move-to)
           (basebutton-method-37 self (the-as vector (-> arg3 param 0)) (the-as quaternion (-> arg3 param 1)))
           )
          )
        )
      )
    )
  :enter (behavior ()
    (basebutton-method-38 self #t)
    (none)
    )
  :trans (the-as (function none :behavior basebutton) rider-trans)
  :code (behavior ()
    (ja-no-eval :num! (seek! max (-> self anim-speed)))
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max (-> self anim-speed)))
      )
    (basebutton-method-36 self (-> self event-down))
    (let ((gp-0 (res-lump-struct (-> self entity) 'on-activate structure)))
      (if gp-0
          (eval!
            (new 'stack 'script-context (the-as basic (process->ppointer self)) self (the-as vector #f))
            (the-as pair gp-0)
            )
          )
      )
    (go-virtual down-idle)
    (none)
    )
  :post (behavior ()
    (when (logtest? (-> self button-status) 4)
      (set! (-> self button-status) (logand -5 (-> self button-status)))
      (set! (-> self root trans quad) (-> self move-to-pos quad))
      (quaternion-copy! (-> self root quat) (-> self move-to-quat))
      )
    (rider-post)
    (none)
    )
  )

;; failed to figure out what this is:
(defstate down-idle (basebutton)
  :virtual #t
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (let ((v1-0 arg2))
      (the-as
        object
        (cond
          ((= v1-0 'untrigger)
           (go-virtual going-up)
           )
          ((= v1-0 'move-to)
           (basebutton-method-37 self (the-as vector (-> arg3 param 0)) (the-as quaternion (-> arg3 param 1)))
           )
          )
        )
      )
    )
  :enter (behavior ()
    (basebutton-method-38 self #t)
    (set! (-> self state-time) (-> self clock frame-counter))
    (none)
    )
  :trans (behavior ()
    (if (logtest? (-> self button-status) 4)
        (rider-trans)
        )
    (none)
    )
  :code (behavior ()
    (cond
      ((= (-> self timeout) 0.0)
       (sleep-code)
       )
      (else
        (until (>= (- (-> self clock frame-counter) (-> self state-time)) (the int (* 300.0 (-> self timeout))))
          (suspend)
          )
        (basebutton-method-36 self (-> self event-going-up))
        (sound-play "silo-button")
        (go-virtual going-up)
        )
      )
    (none)
    )
  :post (behavior ()
    (when (logtest? (-> self button-status) 4)
      (set! (-> self button-status) (logand -5 (-> self button-status)))
      (set! (-> self root trans quad) (-> self move-to-pos quad))
      (quaternion-copy! (-> self root quat) (-> self move-to-quat))
      (rider-post)
      )
    (none)
    )
  )

;; failed to figure out what this is:
(defstate going-up (basebutton)
  :virtual #t
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (let ((v1-0 arg2))
      (the-as
        object
        (cond
          ((= v1-0 'move-to)
           (basebutton-method-37 self (the-as vector (-> arg3 param 0)) (the-as quaternion (-> arg3 param 1)))
           )
          ((= v1-0 'trigger)
           (go-virtual going-down)
           )
          )
        )
      )
    )
  :enter (behavior ()
    (basebutton-method-38 self #f)
    (none)
    )
  :trans (the-as (function none :behavior basebutton) rider-trans)
  :code (behavior ()
    (ja-no-eval :num! (seek! 0.0 (-> self anim-speed)))
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! 0.0 (-> self anim-speed)))
      )
    (basebutton-method-36 self (-> self event-up))
    (go-virtual up-idle)
    (none)
    )
  :post (behavior ()
    (when (logtest? (-> self button-status) 4)
      (set! (-> self button-status) (logand -5 (-> self button-status)))
      (set! (-> self root trans quad) (-> self move-to-pos quad))
      (quaternion-copy! (-> self root quat) (-> self move-to-quat))
      )
    (rider-post)
    (none)
    )
  )

;; definition for method 38 of type basebutton
;; WARN: Return type mismatch int vs none.
(defmethod basebutton-method-38 basebutton ((obj basebutton) (arg0 symbol))
  (if arg0
      (logior! (-> obj button-status) 1)
      (set! (-> obj button-status) (logand -2 (-> obj button-status)))
      )
  (when (not (logtest? (-> obj button-status) 2))
    (if arg0
        (process-entity-status! obj (entity-perm-status subtask-complete) #t)
        (process-entity-status! obj (entity-perm-status subtask-complete) #f)
        )
    )
  (none)
  )

;; definition for method 36 of type basebutton
;; WARN: Return type mismatch int vs none.
(defmethod basebutton-method-36 basebutton ((obj basebutton) (arg0 symbol))
  (with-pp
    (when arg0
      (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-1 from) (process->ppointer pp))
        (set! (-> a1-1 num-params) 0)
        (set! (-> a1-1 message) arg0)
        (let ((t9-0 send-event-function)
              (v1-2 (-> obj notify-actor))
              )
          (t9-0
            (if v1-2
                (-> v1-2 extra process)
                )
            a1-1
            )
          )
        )
      (dotimes (s4-0 (-> obj actor-group-count))
        (let ((s3-0 (-> obj actor-group s4-0)))
          (dotimes (s2-0 (-> s3-0 length))
            (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
              (set! (-> a1-2 from) (process->ppointer pp))
              (set! (-> a1-2 num-params) 0)
              (set! (-> a1-2 message) arg0)
              (let ((t9-1 send-event-function)
                    (v1-10 (-> s3-0 data s2-0 actor))
                    )
                (t9-1
                  (if v1-10
                      (-> v1-10 extra process)
                      )
                  a1-2
                  )
                )
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

;; definition for method 31 of type basebutton
;; WARN: Return type mismatch int vs none.
(defmethod basebutton-method-31 basebutton ((obj basebutton))
  (set! (-> obj button-status) (the-as uint 0))
  (set! (-> obj notify-actor) #f)
  (set! (-> obj timeout) 0.0)
  (set! (-> obj event-going-down) #f)
  (set! (-> obj event-down) #f)
  (set! (-> obj event-going-up) #f)
  (set! (-> obj event-up) #f)
  (set! (-> obj anim-speed) 1.0)
  0
  (none)
  )

;; definition for method 35 of type basebutton
;; WARN: Return type mismatch int vs none.
(defmethod basebutton-method-35 basebutton ((obj basebutton))
  (set! (-> obj event-going-down) 'trigger)
  0
  (none)
  )

;; definition for method 33 of type basebutton
;; WARN: Return type mismatch int vs none.
(defmethod basebutton-method-33 basebutton ((obj basebutton))
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-generic-button" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (ja-channel-set! 1)
  (cond
    ((logtest? (-> obj button-status) 1)
     (let ((s5-1 (-> obj skel root-channel 0)))
       (joint-control-channel-group-eval!
         s5-1
         (the-as art-joint-anim (-> obj draw art-group data 3))
         num-func-identity
         )
       (set! (-> s5-1 frame-num)
             (the float (+ (-> (the-as art-joint-anim (-> obj draw art-group data 3)) frames num-frames) -1))
             )
       )
     )
    (else
      (let ((s5-2 (-> obj skel root-channel 0)))
        (joint-control-channel-group-eval!
          s5-2
          (the-as art-joint-anim (-> obj draw art-group data 3))
          num-func-identity
          )
        (set! (-> s5-2 frame-num) 0.0)
        )
      )
    )
  (set! (-> obj anim-speed) 2.0)
  (transform-post)
  (none)
  )

;; definition for method 34 of type basebutton
;; WARN: Return type mismatch int vs none.
(defmethod basebutton-method-34 basebutton ((obj basebutton))
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 12288.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    ((method-of-object s5-0 collide-shape-method-54))
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collde-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> obj root) s5-0)
    )
  0
  (none)
  )

;; definition for method 11 of type basebutton
;; INFO: Used lq/sq
(defmethod init-from-entity! basebutton ((obj basebutton) (arg0 entity-actor))
  (local-vars (r0-0 uint128) (v1-17 uint128) (a0-14 object) (a1-6 uint128) (sv-16 int))
  (basebutton-method-31 obj)
  (set! (-> obj button-id) -1)
  (let ((v1-4 (res-lump-value (-> obj entity) 'extra-id uint128 :default (the-as uint128 -1) :time -1000000000.0)))
    (if (>= (the-as int v1-4) 0)
        (set! (-> obj button-id) (the-as int v1-4))
        )
    )
  (basebutton-method-34 obj)
  (process-drawable-from-entity! obj arg0)
  (if (and (-> obj entity) (logtest? (-> obj entity extra perm status) (entity-perm-status subtask-complete)))
      (logior! (-> obj button-status) 1)
      (set! (-> obj button-status) (logand -2 (-> obj button-status)))
      )
  (set! (-> obj notify-actor) (entity-actor-lookup arg0 'alt-actor 0))
  (set! sv-16 0)
  (let ((v1-15 (res-lump-data (-> obj entity) 'actor-groups pointer :tag-ptr (the-as (pointer res-tag) (& sv-16)))))
    (cond
      ((and v1-15 (begin
                    (let ((a0-15 #t))
                      (let ((a1-5 (the-as uint128 sv-16)))
                        (.pcpyud a1-6 a1-5 r0-0)
                        )
                      (let ((a1-8 (the-as int (shr (* (the-as int a1-6) 2) 49))))
                        (cmove-#f-zero a0-14 a1-8 a0-15)
                        )
                      )
                    a0-14
                    )
            )
       (set! (-> obj actor-group) (the-as (pointer actor-group) v1-15))
       (let ((v1-16 (the-as uint128 sv-16)))
         (.pcpyud v1-17 v1-16 r0-0)
         )
       (set! (-> obj actor-group-count) (shr (* (the-as int v1-17) 2) 49))
       )
      (else
        (set! (-> obj actor-group) (the-as (pointer actor-group) #f))
        (set! (-> obj actor-group-count) 0)
        0
        )
      )
    )
  (set! (-> obj timeout) (res-lump-float arg0 'timeout))
  (if (not (logtest? (-> obj button-status) 2))
      (nav-mesh-connect-from-ent (the-as entity-nav-mesh obj))
      )
  (basebutton-method-35 obj)
  (basebutton-method-33 obj)
  (basebutton-method-32 obj)
  (none)
  )

;; definition for function basebutton-init-by-other
;; INFO: Used lq/sq
(defbehavior basebutton-init-by-other basebutton ((arg0 entity-actor) (arg1 vector) (arg2 quaternion) (arg3 entity-actor) (arg4 symbol) (arg5 float))
  (basebutton-method-31 self)
  (logior! (-> self button-status) 2)
  (set! (-> self button-id) -1)
  (if arg4
      (logior! (-> self button-status) 1)
      )
  (set! (-> self notify-actor) arg3)
  (set! (-> self timeout) arg5)
  (if arg0
      (process-entity-set! self arg0)
      )
  (set! (-> self actor-group) (the-as (pointer actor-group) #f))
  (set! (-> self actor-group-count) 0)
  (basebutton-method-34 self)
  (set! (-> self root trans quad) (-> arg1 quad))
  (quaternion-copy! (-> self root quat) arg2)
  (set-vector! (-> self root scale) 1.0 1.0 1.0 1.0)
  (basebutton-method-35 self)
  (basebutton-method-33 self)
  (basebutton-method-32 self)
  (none)
  )




