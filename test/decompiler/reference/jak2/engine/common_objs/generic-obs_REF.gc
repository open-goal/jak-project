;;-*-Lisp-*-
(in-package goal)

;; failed to figure out what this is:
(defskelgroup skel-spotlight spotlight spotlight-lod0-jg -1
              ((spotlight-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 10)
              :origin-joint-index 5
              )

;; definition for function entity-lookup-part-group
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs (pointer sparticle-launch-group).
(defun entity-lookup-part-group ((arg0 entity-actor) (arg1 (pointer string)) (arg2 symbol))
  (local-vars (sv-16 res-tag))
  (let ((gp-0 (the-as object #f)))
    (set! sv-16 (new 'static 'res-tag))
    (let ((s4-0 (res-lump-data arg0 arg2 pointer :tag-ptr (& sv-16))))
      (if (not s4-0)
          (go process-drawable-art-error (the-as string #f))
          )
      (let ((s3-0 (the-as object (-> (the-as (pointer uint32) s4-0)))))
        (cond
          ((part-group-pointer? (the-as pointer s3-0))
           (set! gp-0 (-> (the-as (pointer uint32) s4-0)))
           )
          ((= (-> (the-as basic s3-0) type) string)
           (if arg1
               (set! (-> arg1 0) (the-as string s3-0))
               )
           (set! gp-0 (lookup-part-group-pointer-by-name (the-as string s3-0)))
           (if (the-as (pointer object) gp-0)
               (set! (-> (the-as (pointer int32) s4-0)) (the-as (pointer object) gp-0))
               )
           )
          (else
            (go process-drawable-art-error (the-as string s3-0))
            )
          )
        )
      )
    (the-as (pointer sparticle-launch-group) gp-0)
    )
  )

;; definition for function clone-anim-once
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defbehavior clone-anim-once process-drawable ((arg0 handle) (arg1 symbol) (arg2 string))
  (logclear! (-> self skel status) (joint-control-status valid-spooled-frame))
  (let ((gp-0 (handle->process arg0)))
    (if gp-0
        (joint-control-copy! (-> self skel) (-> (the-as process-drawable gp-0) skel))
        )
    (cond
      ((and (the-as process-drawable gp-0) (joint-control-remap!
                                             (-> self skel)
                                             (-> self draw art-group)
                                             (-> (the-as process-drawable gp-0) draw art-group)
                                             '()
                                             0
                                             arg2
                                             )
            )
       (when arg1
         (let* ((s5-1 (-> self root))
                (a0-7 (if (type? s5-1 collide-shape)
                          (the-as collide-shape s5-1)
                          )
                      )
                )
           (if a0-7
               (move-to-point! a0-7 (-> (the-as process-drawable gp-0) root trans))
               (set! (-> self root trans quad) (-> (the-as process-drawable gp-0) root trans quad))
               )
           )
         (quaternion-copy! (-> self root quat) (-> (the-as process-drawable gp-0) root quat))
         )
       (if (logtest? (-> (the-as process-drawable gp-0) skel status) (joint-control-status valid-spooled-frame))
           (logior! (-> self skel status) (joint-control-status valid-spooled-frame))
           )
       (logclear! (-> self draw status) (draw-control-status no-draw no-draw-temp uninited))
       (if (or (zero? (-> self skel active-channels)) (not (-> self skel root-channel 0 frame-group)))
           (logior! (-> self draw status) (draw-control-status no-draw-temp))
           )
       (let* ((gp-1 self)
              (v1-38 (if (type? gp-1 manipy)
                         gp-1
                         )
                     )
              )
         (if (and v1-38 (not (-> (the-as manipy v1-38) draw?)))
             (logior! (-> self draw status) (draw-control-status no-draw-temp))
             )
         )
       (update-anim-data (-> self skel))
       (do-joint-math (-> self draw) (-> self node-list) (-> self skel))
       (let ((a0-22 (-> self skel effect)))
         (if a0-22
             (update-effects a0-22)
             )
         )
       (if (logtest? (-> self skel status) (joint-control-status blend-shape blend-shape-valid))
           (merc-blend-shape self)
           )
       (if (logtest? (-> self skel status) (joint-control-status eye-anim-valid eye-anim))
           (merc-eye-anim self)
           )
       )
      (else
        (set! (-> self skel active-channels) (the-as uint 0))
        (logior! (-> self draw status) (draw-control-status no-draw))
        (ja-post)
        )
      )
    )
  0
  (none)
  )

;; definition for function clone-anim
;; WARN: Return type mismatch int vs none.
(defbehavior clone-anim process-drawable ((arg0 handle) (arg1 symbol) (arg2 string))
  (ja-post)
  (while (handle->process arg0)
    (clone-anim-once arg0 #t arg2)
    (suspend)
    )
  (logclear! (-> self skel status) (joint-control-status valid-spooled-frame))
  0
  (none)
  )

;; definition for method 22 of type swingpole
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod move-along-path ((this swingpole))
  (with-pp
    (if (nonzero? (-> this draw))
        (ja-post)
        )
    (cond
      ((nonzero? (-> this path))
       (set! (-> this path-pos) (get-norm! (-> this sync) 0))
       (let ((s5-0 (new 'stack-no-clear 'vector)))
         (get-point-at-percent-along-path! (-> this path) s5-0 (-> this path-pos) 'interp)
         (set! (-> this speed) (* (vector-vector-distance s5-0 (-> this root trans)) (-> pp clock frames-per-second)))
         (move-to-point! (-> this root) s5-0)
         )
       )
      ((>= (-> this joint-track) 0)
       (let ((v1-15 (ppointer->process (-> this parent)))
             (s5-1 (new 'stack-no-clear 'vector))
             )
         (let ((s4-0 (-> (the-as process-drawable v1-15) node-list data (-> this joint-track))))
           (vector<-cspace! s5-1 s4-0)
           (vector-normalize-copy! (-> this dir) (the-as vector (-> s4-0 bone transform)) 1.0)
           )
         (move-to-point! (-> this root) s5-1)
         )
       )
      )
    (when (nonzero? (-> this sound))
      (set! (-> this sound trans quad) (-> this root trans quad))
      (let ((f30-0 (lerp-scale -0.1 -0.05 (-> this speed) 8192.0 20480.0))
            (f0-6 (lerp-scale 0.7 1.0 (-> this speed) 8192.0 20480.0))
            )
        (set! (-> this sound pitch) (the int (* 1524.0 f30-0)))
        (set! (-> this sound volume) (the int (* 1024.0 f0-6)))
        )
      (update! (-> this sound))
      )
    0
    (none)
    )
  )

;; failed to figure out what this is:
(defstate idle (swingpole)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch 'attack)
       (if (send-event proc 'pole-grab (-> block param 0))
           (go-virtual active (process->handle proc))
           )
       #f
       )
      )
    )
  :code (behavior ()
    (if (nonzero? (-> self draw))
        (ja-post)
        )
    (update-transforms (-> self root))
    (cond
      ((or (nonzero? (-> self path)) (>= (-> self joint-track) 0))
       (until #f
         (move-along-path self)
         (suspend)
         )
       #f
       )
      (else
        (logior! (-> self mask) (process-mask sleep))
        (suspend)
        0
        )
      )
    )
  )

;; failed to figure out what this is:
(defstate active (swingpole)
  :virtual #t
  :code (behavior ((arg0 handle))
    (move-along-path self)
    (suspend)
    (while (let* ((s5-0 (handle->process arg0))
                  (a0-7 (if (type? s5-0 process-focusable)
                            s5-0
                            )
                        )
                  )
             (and a0-7 (focus-test? (the-as process-focusable a0-7) pole))
             )
      (move-along-path self)
      (suspend)
      )
    (let ((gp-1 (current-time)))
      (until (time-elapsed? gp-1 (seconds 0.5))
        (move-along-path self)
        (suspend)
        )
      )
    (go-virtual idle)
    )
  )

;; definition for method 11 of type swingpole
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this swingpole) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  "Copy defaults from the entity."
  (stack-size-set! (-> this main-thread) 128)
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((v1-5 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-5 prim-core collide-as) (collide-spec collectable))
      (set! (-> v1-5 prim-core collide-with) (collide-spec jak player-list tobot))
      (set-vector! (-> v1-5 local-sphere) 0.0 0.0 0.0 12288.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-5)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-8 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-8 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-8 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (set! (-> this root trans quad) (-> arg0 extra trans quad))
  (quaternion-copy! (-> this root quat) (-> arg0 quat))
  (vector-identity! (-> this root scale))
  (vector-y-quaternion! (-> this dir) (-> this root quat))
  (set! (-> this joint-track) -1)
  (let ((a1-8 (res-lump-struct (-> this entity) 'art-name structure)))
    (if a1-8
        (initialize-skeleton-by-name this (the-as string a1-8))
        )
    )
  (set! (-> this dir y) 0.0)
  (vector-normalize! (-> this dir) 1.0)
  (set! (-> this edge-length) 8192.0)
  (let ((s4-1 (new 'stack-no-clear 'sync-info-params)))
    (let ((a0-19 (res-lump-value arg0 'options uint128 :time -1000000000.0))
          (v1-22 0)
          )
      (if (not (logtest? (the-as int a0-19) 8))
          (set! v1-22 (logior v1-22 1))
          )
      (set! (-> s4-1 sync-type) 'sync-eased)
      (set! (-> s4-1 sync-flags) (the-as sync-flags v1-22))
      )
    (set! (-> s4-1 period) (the-as uint 0))
    (set! (-> s4-1 entity) arg0)
    (set! (-> s4-1 percent) 0.0)
    (set! (-> s4-1 ease-in) 0.2)
    (set! (-> s4-1 ease-out) 0.2)
    (set! (-> s4-1 pause-in) 0.0)
    (set! (-> s4-1 pause-out) 0.0)
    (initialize! (-> this sync) s4-1)
    )
  (when (nonzero? (-> this sync period))
    (set! (-> this path) (new 'process 'curve-control this 'path -1000000000.0))
    (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
    )
  (set! (-> this sound) (new 'process 'ambient-sound (-> this entity) (-> this root trans)))
  (go (method-of-object this idle))
  (none)
  )

;; definition for function swingpole-init
;; INFO: Used lq/sq
(defbehavior swingpole-init swingpole ((arg0 int))
  (stack-size-set! (-> self main-thread) 128)
  (let ((s5-0 (new 'process 'collide-shape self (collide-list-enum hit-by-player))))
    (let ((v1-4 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-4 prim-core collide-as) (collide-spec collectable))
      (set! (-> v1-4 prim-core collide-with) (collide-spec jak player-list tobot))
      (set-vector! (-> v1-4 local-sphere) 0.0 0.0 0.0 12288.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-4)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-7 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-7 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-7 prim-core collide-with))
      )
    (set! (-> self root) s5-0)
    )
  (set! (-> self root trans quad) (-> (the-as swingpole (-> self parent 0)) root trans quad))
  (quaternion-identity! (-> self root quat))
  (vector-identity! (-> self root scale))
  (set! (-> self joint-track) arg0)
  (set-vector! (-> self dir) 0.0 0.0 1.0 1.0)
  (set! (-> self edge-length) 8192.0)
  (go-virtual idle)
  )

;; failed to figure out what this is:
(defstate die (process-hidden)
  :virtual #t
  :code nothing
  )

;; definition for method 11 of type process-hidden
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this process-hidden) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  "Copy defaults from the entity."
  (process-entity-status! this (entity-perm-status dead) #t)
  (go (method-of-object this die))
  (none)
  )

;; definition of type target-start
(deftype target-start (process-hidden)
  ()
  )

;; definition for method 3 of type target-start
(defmethod inspect ((this target-start))
  (when (not this)
    (set! this this)
    (goto cfg-68)
    )
  (format #t "[~8x] ~A~%" this (-> this type))
  (format #t "~1Tname: ~A~%" (-> this name))
  (format #t "~1Tmask: #x~X : (process-mask " (-> this mask))
  (let ((s5-0 (-> this mask)))
    (if (= (logand s5-0 (process-mask process-tree)) (process-mask process-tree))
        (format #t "process-tree ")
        )
    (if (= (logand s5-0 (process-mask target)) (process-mask target))
        (format #t "target ")
        )
    (if (= (logand (process-mask collectable) s5-0) (process-mask collectable))
        (format #t "attackable ")
        )
    (if (= (logand (process-mask bit18) s5-0) (process-mask bit18))
        (format #t "collectable ")
        )
    (if (= (logand (process-mask projectile) s5-0) (process-mask projectile))
        (format #t "projectile ")
        )
    (if (= (logand (process-mask no-track) s5-0) (process-mask no-track))
        (format #t "no-track ")
        )
    (if (= (logand s5-0 (process-mask sleep-code)) (process-mask sleep-code))
        (format #t "sleep-code ")
        )
    (if (= (logand s5-0 (process-mask actor-pause)) (process-mask actor-pause))
        (format #t "actor-pause ")
        )
    (if (= (logand (process-mask bot) s5-0) (process-mask bot))
        (format #t "bot ")
        )
    (if (= (logand (process-mask vehicle) s5-0) (process-mask vehicle))
        (format #t "vehicle ")
        )
    (if (= (logand (process-mask enemy) s5-0) (process-mask enemy))
        (format #t "enemy ")
        )
    (if (= (logand (process-mask entity) s5-0) (process-mask entity))
        (format #t "entity ")
        )
    (if (= (logand s5-0 (process-mask heap-shrunk)) (process-mask heap-shrunk))
        (format #t "heap-shrunk ")
        )
    (if (= (logand (process-mask sidekick) s5-0) (process-mask sidekick))
        (format #t "sidekick ")
        )
    (if (= (logand s5-0 (process-mask going)) (process-mask going))
        (format #t "going ")
        )
    (if (= (logand s5-0 (process-mask execute)) (process-mask execute))
        (format #t "execute ")
        )
    (if (= (logand (process-mask civilian) s5-0) (shl #x8000 16))
        (format #t "civilian ")
        )
    (if (= (logand (process-mask death) s5-0) (process-mask death))
        (format #t "death ")
        )
    (if (= (logand (process-mask guard) s5-0) (process-mask guard))
        (format #t "guard ")
        )
    (if (= (logand s5-0 (process-mask no-kill)) (process-mask no-kill))
        (format #t "no-kill ")
        )
    (if (= (logand (process-mask platform) s5-0) (process-mask platform))
        (format #t "platform ")
        )
    (if (= (logand s5-0 (process-mask freeze)) (process-mask freeze))
        (format #t "freeze ")
        )
    (if (= (logand s5-0 (process-mask sleep)) (process-mask sleep))
        (format #t "sleep ")
        )
    (if (= (logand s5-0 (process-mask progress)) (process-mask progress))
        (format #t "progress ")
        )
    (if (= (logand s5-0 (process-mask menu)) (process-mask menu))
        (format #t "menu ")
        )
    (if (= (logand (process-mask camera) s5-0) (process-mask camera))
        (format #t "camera ")
        )
    (if (= (logand (process-mask ambient) s5-0) (process-mask ambient))
        (format #t "ambient ")
        )
    (if (= (logand s5-0 (process-mask dark-effect)) (process-mask dark-effect))
        (format #t "dark-effect ")
        )
    (if (= (logand (process-mask crate) s5-0) (process-mask crate))
        (format #t "crate ")
        )
    (if (= (logand s5-0 (process-mask kernel-run)) (process-mask kernel-run))
        (format #t "kernel-run ")
        )
    (if (= (logand s5-0 (process-mask movie)) (process-mask movie))
        (format #t "movie ")
        )
    (if (= (logand s5-0 (process-mask pause)) (process-mask pause))
        (format #t "pause ")
        )
    )
  (format #t ")~%")
  (format #t "~1Tclock: ~A~%" (-> this clock))
  (format #t "~1Tparent: #x~X~%" (-> this parent))
  (format #t "~1Tbrother: #x~X~%" (-> this brother))
  (format #t "~1Tchild: #x~X~%" (-> this child))
  (format #t "~1Tppointer: #x~X~%" (-> this ppointer))
  (format #t "~1Tself: ~A~%" (-> this self))
  (format #t "~1Tpool: ~A~%" (-> this pool))
  (format #t "~1Tstatus: ~A~%" (-> this status))
  (format #t "~1Tpid: ~D~%" (-> this pid))
  (format #t "~1Tmain-thread: ~A~%" (-> this main-thread))
  (format #t "~1Ttop-thread: ~A~%" (-> this top-thread))
  (format #t "~1Tentity: ~A~%" (-> this entity))
  (format #t "~1Tlevel: ~A~%" (-> this level))
  (format #t "~1Tstate: ~A~%" (-> this state))
  (format #t "~1Tnext-state: ~A~%" (-> this next-state))
  (format #t "~1Ttrans-hook: ~A~%" (-> this trans-hook))
  (format #t "~1Tpost-hook: ~A~%" (-> this post-hook))
  (format #t "~1Tevent-hook: ~A~%" (-> this event-hook))
  (format #t "~1Tallocated-length: ~D~%" (-> this allocated-length))
  (format #t "~1Theap-base: #x~X~%" (-> this heap-base))
  (format #t "~1Theap-top: #x~X~%" (-> this heap-top))
  (format #t "~1Theap-cur: #x~X~%" (-> this heap-cur))
  (format #t "~1Tstack-frame-top: ~A~%" (-> this stack-frame-top))
  (format #t "~1Theap: #<kheap @ #x~X>~%" (&-> this heap-base))
  (format #t "~1Tconnection-list: ~`connectable`P~%" (-> this connection-list))
  (format #t "~1Tstack[0] @ #x~X~%" (-> this stack))
  (label cfg-68)
  this
  )

;; definition of type camera-start
(deftype camera-start (process-hidden)
  ()
  )

;; definition for method 3 of type camera-start
(defmethod inspect ((this camera-start))
  (when (not this)
    (set! this this)
    (goto cfg-68)
    )
  (format #t "[~8x] ~A~%" this (-> this type))
  (format #t "~1Tname: ~A~%" (-> this name))
  (format #t "~1Tmask: #x~X : (process-mask " (-> this mask))
  (let ((s5-0 (-> this mask)))
    (if (= (logand s5-0 (process-mask process-tree)) (process-mask process-tree))
        (format #t "process-tree ")
        )
    (if (= (logand s5-0 (process-mask target)) (process-mask target))
        (format #t "target ")
        )
    (if (= (logand (process-mask collectable) s5-0) (process-mask collectable))
        (format #t "attackable ")
        )
    (if (= (logand (process-mask bit18) s5-0) (process-mask bit18))
        (format #t "collectable ")
        )
    (if (= (logand (process-mask projectile) s5-0) (process-mask projectile))
        (format #t "projectile ")
        )
    (if (= (logand (process-mask no-track) s5-0) (process-mask no-track))
        (format #t "no-track ")
        )
    (if (= (logand s5-0 (process-mask sleep-code)) (process-mask sleep-code))
        (format #t "sleep-code ")
        )
    (if (= (logand s5-0 (process-mask actor-pause)) (process-mask actor-pause))
        (format #t "actor-pause ")
        )
    (if (= (logand (process-mask bot) s5-0) (process-mask bot))
        (format #t "bot ")
        )
    (if (= (logand (process-mask vehicle) s5-0) (process-mask vehicle))
        (format #t "vehicle ")
        )
    (if (= (logand (process-mask enemy) s5-0) (process-mask enemy))
        (format #t "enemy ")
        )
    (if (= (logand (process-mask entity) s5-0) (process-mask entity))
        (format #t "entity ")
        )
    (if (= (logand s5-0 (process-mask heap-shrunk)) (process-mask heap-shrunk))
        (format #t "heap-shrunk ")
        )
    (if (= (logand (process-mask sidekick) s5-0) (process-mask sidekick))
        (format #t "sidekick ")
        )
    (if (= (logand s5-0 (process-mask going)) (process-mask going))
        (format #t "going ")
        )
    (if (= (logand s5-0 (process-mask execute)) (process-mask execute))
        (format #t "execute ")
        )
    (if (= (logand (process-mask civilian) s5-0) (shl #x8000 16))
        (format #t "civilian ")
        )
    (if (= (logand (process-mask death) s5-0) (process-mask death))
        (format #t "death ")
        )
    (if (= (logand (process-mask guard) s5-0) (process-mask guard))
        (format #t "guard ")
        )
    (if (= (logand s5-0 (process-mask no-kill)) (process-mask no-kill))
        (format #t "no-kill ")
        )
    (if (= (logand (process-mask platform) s5-0) (process-mask platform))
        (format #t "platform ")
        )
    (if (= (logand s5-0 (process-mask freeze)) (process-mask freeze))
        (format #t "freeze ")
        )
    (if (= (logand s5-0 (process-mask sleep)) (process-mask sleep))
        (format #t "sleep ")
        )
    (if (= (logand s5-0 (process-mask progress)) (process-mask progress))
        (format #t "progress ")
        )
    (if (= (logand s5-0 (process-mask menu)) (process-mask menu))
        (format #t "menu ")
        )
    (if (= (logand (process-mask camera) s5-0) (process-mask camera))
        (format #t "camera ")
        )
    (if (= (logand (process-mask ambient) s5-0) (process-mask ambient))
        (format #t "ambient ")
        )
    (if (= (logand s5-0 (process-mask dark-effect)) (process-mask dark-effect))
        (format #t "dark-effect ")
        )
    (if (= (logand (process-mask crate) s5-0) (process-mask crate))
        (format #t "crate ")
        )
    (if (= (logand s5-0 (process-mask kernel-run)) (process-mask kernel-run))
        (format #t "kernel-run ")
        )
    (if (= (logand s5-0 (process-mask movie)) (process-mask movie))
        (format #t "movie ")
        )
    (if (= (logand s5-0 (process-mask pause)) (process-mask pause))
        (format #t "pause ")
        )
    )
  (format #t ")~%")
  (format #t "~1Tclock: ~A~%" (-> this clock))
  (format #t "~1Tparent: #x~X~%" (-> this parent))
  (format #t "~1Tbrother: #x~X~%" (-> this brother))
  (format #t "~1Tchild: #x~X~%" (-> this child))
  (format #t "~1Tppointer: #x~X~%" (-> this ppointer))
  (format #t "~1Tself: ~A~%" (-> this self))
  (format #t "~1Tpool: ~A~%" (-> this pool))
  (format #t "~1Tstatus: ~A~%" (-> this status))
  (format #t "~1Tpid: ~D~%" (-> this pid))
  (format #t "~1Tmain-thread: ~A~%" (-> this main-thread))
  (format #t "~1Ttop-thread: ~A~%" (-> this top-thread))
  (format #t "~1Tentity: ~A~%" (-> this entity))
  (format #t "~1Tlevel: ~A~%" (-> this level))
  (format #t "~1Tstate: ~A~%" (-> this state))
  (format #t "~1Tnext-state: ~A~%" (-> this next-state))
  (format #t "~1Ttrans-hook: ~A~%" (-> this trans-hook))
  (format #t "~1Tpost-hook: ~A~%" (-> this post-hook))
  (format #t "~1Tevent-hook: ~A~%" (-> this event-hook))
  (format #t "~1Tallocated-length: ~D~%" (-> this allocated-length))
  (format #t "~1Theap-base: #x~X~%" (-> this heap-base))
  (format #t "~1Theap-top: #x~X~%" (-> this heap-top))
  (format #t "~1Theap-cur: #x~X~%" (-> this heap-cur))
  (format #t "~1Tstack-frame-top: ~A~%" (-> this stack-frame-top))
  (format #t "~1Theap: #<kheap @ #x~X>~%" (&-> this heap-base))
  (format #t "~1Tconnection-list: ~`connectable`P~%" (-> this connection-list))
  (format #t "~1Tstack[0] @ #x~X~%" (-> this stack))
  (label cfg-68)
  this
  )

;; definition for function manipy-post
;; WARN: Return type mismatch int vs none.
(defbehavior manipy-post manipy ()
  ((-> self cur-post-hook))
  (when (and (>= (-> self shadow-volume-joint) 0) (-> self draw shadow-ctrl))
    (let ((a2-0 (-> self node-list data (-> self shadow-volume-joint)))
          (a3-0 (-> self draw shadow-ctrl))
          )
      (format *stdcon* "shadow-volume for ~A ~A~%" a2-0 a3-0)
      )
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate idle (manipy)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (s4-0 object))
    (case message
      (('attackable)
       (cond
         ((-> block param 0)
          (set! s4-0 (logior (process-mask collectable) (-> self mask)))
          (set! (-> self mask) (the-as process-mask s4-0))
          )
         (else
           (set! s4-0 (logclear (-> self mask) (process-mask collectable)))
           (set! (-> self mask) (the-as process-mask s4-0))
           )
         )
       s4-0
       )
      (('blend-shape)
       (when (nonzero? (-> self skel))
         (cond
           ((-> block param 0)
            (set! s4-0 (logior (-> self skel status) (joint-control-status blend-shape eye-anim)))
            (set! (-> self skel status) (the-as joint-control-status s4-0))
            )
           (else
             (set! s4-0 (logclear (-> self skel status) (joint-control-status blend-shape eye-anim)))
             (set! (-> self skel status) (the-as joint-control-status s4-0))
             )
           )
         s4-0
         )
       )
      (('shadow)
       (when (nonzero? (-> self draw))
         (cond
           ((-> block param 0)
            (set! s4-0 (-> self shadow-backup))
            (set! (-> self draw shadow) (the-as shadow-geo s4-0))
            s4-0
            )
           (else
             (set! (-> self draw shadow) #f)
             #f
             )
           )
         )
       )
      (('shadow-volume)
       (let ((v1-17 (get-art-by-name-method (-> self draw jgeo) (the-as string (-> block param 0)) (the-as type #f))))
         (if v1-17
             (set! (-> self shadow-volume-joint) (+ (-> (the-as joint v1-17) number) 1))
             )
         )
       (when (and (-> self draw shadow-ctrl) (< 1 argc) (>= (the-as int (-> block param 1)) 0))
         (let ((v0-1 (command-get-int (-> block param 1) 0)))
           (set! (-> self draw shadow-ctrl settings flags) (the-as shadow-flags v0-1))
           v0-1
           )
         )
       )
      (('shadow-type)
       (if (and (-> self draw shadow-ctrl) (> argc 0))
           (set! (-> self draw shadow-ctrl settings shadow-type) (command-get-int (-> block param 0) 0))
           )
       )
      (('shadow-dir)
       (when (and (-> self draw shadow-ctrl) (> argc 0))
         (set! s4-0 (-> self draw shadow-ctrl settings shadow-dir))
         (set! (-> (the-as vector s4-0) x) (command-get-float (-> block param 0) 0.0))
         (set! (-> (the-as vector s4-0) y) (command-get-float (-> block param 1) 0.0))
         (set! (-> (the-as vector s4-0) z) (command-get-float (-> block param 2) 0.0))
         (set! (-> (the-as vector s4-0) w) (if (< 3 argc)
                                               (command-get-float (-> block param 3) 0.0)
                                               409600.0
                                               )
               )
         s4-0
         )
       )
      (('shadow-top-plane)
       (when (and (-> self draw shadow-ctrl) (>= argc 4))
         (set! s4-0 (-> self draw shadow-ctrl settings top-plane))
         (set! (-> (the-as plane s4-0) x) (command-get-float (-> block param 0) 0.0))
         (set! (-> (the-as plane s4-0) y) (command-get-float (-> block param 1) 0.0))
         (set! (-> (the-as plane s4-0) z) (command-get-float (-> block param 2) 0.0))
         (set! (-> (the-as plane s4-0) w) (command-get-float (-> block param 3) 0.0))
         s4-0
         )
       )
      (('shadow-bot-plane)
       (when (and (-> self draw shadow-ctrl) (>= argc 4))
         (set! s4-0 (-> self draw shadow-ctrl settings bot-plane))
         (set! (-> (the-as plane s4-0) x) (command-get-float (-> block param 0) 0.0))
         (set! (-> (the-as plane s4-0) y) (command-get-float (-> block param 1) 0.0))
         (set! (-> (the-as plane s4-0) z) (command-get-float (-> block param 2) 0.0))
         (set! (-> (the-as plane s4-0) w) (command-get-float (-> block param 3) 0.0))
         s4-0
         )
       )
      (('no-fog)
       (set! s4-0 (logior (-> self draw status) (draw-control-status disable-fog)))
       (set! (-> self draw status) (the-as draw-control-status s4-0))
       s4-0
       )
      (('setup-spotlight-shadow)
       (when (-> self draw shadow-ctrl)
         (let ((v1-53 (command-get-process "spotlight" *target*)))
           (when v1-53
             (let ((s5-1 (-> (the-as process-drawable v1-53) node-list data 3)))
               (vector<-cspace! (new 'stack-no-clear 'vector) s5-1)
               (let ((s5-2 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> s5-1 bone transform vector 2) -1.0))
                     (s4-1
                       (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data (-> self draw shadow-joint-index)))
                       )
                     (f30-0 1638400.0)
                     (s3-0 (new 'stack-no-clear 'collide-query))
                     (f28-0 122880.0)
                     )
                 (set! (-> s3-0 start-pos quad) (-> s4-1 quad))
                 (vector-normalize-copy! (-> s3-0 move-dist) s5-2 f28-0)
                 (let ((v1-64 s3-0))
                   (set! (-> v1-64 radius) 1638.4)
                   (set! (-> v1-64 collide-with) (collide-spec obstacle hit-by-others-list))
                   (set! (-> v1-64 ignore-process0) self)
                   (set! (-> v1-64 ignore-process1) #f)
                   (set! (-> v1-64 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
                   (set! (-> v1-64 action-mask) (collide-action solid))
                   )
                 (let* ((f0-13 (fill-and-probe-using-line-sphere *collide-cache* s3-0))
                        (f28-1 (if (< 0.0 f0-13)
                                   (* f0-13 f28-0)
                                   122880.0
                                   )
                               )
                        )
                   (shadow-control-method-14
                     (-> self draw shadow-ctrl)
                     s4-1
                     s5-2
                     f30-0
                     (- f28-1 (command-get-float (-> block param 0) 0.0))
                     (+ f28-1 (command-get-float (-> block param 1) 0.0))
                     )
                   )
                 )
               )
             )
           )
         )
       )
      (('color-mult)
       (when (>= argc 4)
         (set! s4-0 (-> self draw color-mult))
         (set! (-> (the-as rgbaf s4-0) x) (command-get-float (-> block param 0) 0.0))
         (set! (-> (the-as rgbaf s4-0) y) (command-get-float (-> block param 1) 0.0))
         (set! (-> (the-as rgbaf s4-0) z) (command-get-float (-> block param 2) 0.0))
         (set! (-> (the-as rgbaf s4-0) w) (command-get-float (-> block param 3) 0.0))
         s4-0
         )
       )
      (('color-mult-vector)
       (set! s4-0 (-> self draw color-mult))
       (set! (-> (the-as rgbaf s4-0) quad) (-> (the-as vector (-> block param 0)) quad))
       s4-0
       )
      (('color-emissive-vector)
       (set! s4-0 (-> self draw color-emissive))
       (set! (-> (the-as rgbaf s4-0) quad) (-> (the-as vector (-> block param 0)) quad))
       s4-0
       )
      (('segment)
       (let ((a1-44 (/ (the-as int (-> block param 0)) 8))
             (a2-5 (/ (the-as int (-> block param 1)) 8))
             )
         (setup-masks (-> self draw) (the-as int a1-44) (the-as int a2-5))
         )
       )
      (('trans-hook)
       (set! s4-0 (-> block param 0))
       (set! (-> self new-trans-hook) (the-as (function none) s4-0))
       s4-0
       )
      (('post-hook)
       (set! s4-0 (-> block param 0))
       (set! (-> self new-post-hook) (the-as (function none) s4-0))
       s4-0
       )
      (('user-data)
       (set! s4-0 (-> block param 0))
       (set! (-> self userdata) (the-as uint s4-0))
       s4-0
       )
      (('eval)
       ((the-as (function manipy object) (-> block param 0)) self)
       )
      (('speed)
       (set! (-> self speed) (the-as float (-> block param 0)))
       )
      (('event-hook)
       (set! s4-0 (-> block param 0))
       (set! (-> self cur-event-hook) (the-as (function none) s4-0))
       s4-0
       )
      (('art-joint-anim)
       (set! (-> self new-joint-anim)
             (get-art-by-name (-> self draw art-group) (the-as string (-> block param 0)) art-joint-anim)
             )
       (set! s4-0 (-> block param 1))
       (set! (-> self new-joint-anim-blend) (the-as uint s4-0))
       s4-0
       )
      (('anim-mode)
       (when (nonzero? (-> self skel))
         (set! (-> self anim-mode) (the-as symbol (-> block param 0)))
         (if (= (-> self anim-mode) 'clone-anim)
             (ja-post)
             )
         (-> self anim-mode)
         )
       )
      (('origin-joint-index 'center-joint)
       (set! (-> self draw origin-joint-index) (-> block param 0))
       (set! s4-0 (-> block param 0))
       (set! (-> self draw shadow-joint-index) (the-as uint s4-0))
       s4-0
       )
      (('max-vis-dist)
       (set! (-> self draw lod-set lod (-> self draw lod-set max-lod) dist) (the-as float (-> block param 0)))
       )
      (('grab)
       (set! (-> self cur-grab-handle) (process->handle (the-as process (-> block param 0))))
       (let ((v1-98 (handle->process (-> self cur-grab-handle))))
         (when v1-98
           (set! s4-0 (-> self old-grab-pos))
           (set! (-> (the-as vector s4-0) quad) (-> (the-as process-drawable v1-98) root trans quad))
           s4-0
           )
         )
       )
      (('target)
       (set! s4-0 (process->handle (the-as process (-> block param 0))))
       (set! (-> self cur-target-handle) (the-as handle s4-0))
       s4-0
       )
      (('trans)
       (cond
         ((type? (-> self root) collide-shape)
          (move-to-point! (-> self root) (the-as vector (-> block param 0)))
          )
         (else
           (set! s4-0 (-> self root trans))
           (set! (-> (the-as vector s4-0) quad) (-> (the-as vector (-> block param 0)) quad))
           s4-0
           )
         )
       )
      (('rot)
       (let ((s5-3 (new 'stack-no-clear 'matrix)))
         (matrix-rotate-y! s5-3 (the-as float (-> block param 0)))
         (matrix->quaternion (-> self root quat) s5-3)
         )
       )
      (('rot-quat)
       (quaternion-copy! (-> self root quat) (the-as quaternion (-> block param 0)))
       )
      (('clone-copy-trans)
       (set! s4-0 (-> block param 0))
       (set! (-> self clone-copy-trans) (the-as symbol s4-0))
       s4-0
       )
      (('release)
       (set! (-> self cur-grab-handle) (the-as handle #f))
       #f
       )
      (('draw)
       (set! (-> self draw?) (the-as symbol (-> block param 0)))
       (cond
         ((-> block param 0)
          (let ((v1-114 (logtest? (-> self draw status) (draw-control-status no-draw))))
            (logclear! (-> self draw status) (draw-control-status no-draw))
            (when v1-114
              (cond
                ((nonzero? (-> self skel))
                 (let ((gp-1 (-> self skel status)))
                   (logior! (-> self skel status) (joint-control-status sync-math))
                   (set! s4-0 (ja-post))
                   (set! (-> self skel status) gp-1)
                   )
                 s4-0
                 )
                (else
                  (ja-post)
                  )
                )
              )
            )
          )
         (else
           (set! s4-0 (logior (-> self draw status) (draw-control-status no-draw)))
           (set! (-> self draw status) (the-as draw-control-status s4-0))
           s4-0
           )
         )
       )
      (('sync)
       (when (nonzero? (-> self skel))
         (cond
           ((-> block param 0)
            (set! s4-0 (logior (-> self skel status) (joint-control-status sync-math)))
            (set! (-> self skel status) (the-as joint-control-status s4-0))
            )
           (else
             (set! s4-0 (logclear (-> self skel status) (joint-control-status sync-math)))
             (set! (-> self skel status) (the-as joint-control-status s4-0))
             )
           )
         s4-0
         )
       )
      (('query)
       (case (-> block param 0)
         (('grab)
          (handle->process (-> self cur-grab-handle))
          )
         (('done)
          (case (-> self anim-mode)
            (('play1 'play)
             (>= (ja-frame-num 0) (the float (+ (-> (ja-group) frames num-frames) -2)))
             )
            )
          )
         )
       )
      (('set-frame-num)
       (let ((v1-147 (-> self skel root-channel 0)))
         (set! (-> v1-147 num-func) num-func-identity)
         (set! (-> v1-147 frame-num) (the-as float (-> block param 0)))
         )
       )
      (('prefix)
       (set! s4-0 (-> block param 0))
       (set! (-> self prefix) (the-as basic s4-0))
       s4-0
       )
      (('light-index)
       (let ((v0-40 (command-get-int (-> block param 0) 0)))
         (set! (-> self draw light-index) (the-as uint v0-40))
         v0-40
         )
       )
      (('eye-slot)
       (set! (-> self draw mgeo header eye-ctrl eye-slot) (command-get-int (-> block param 0) 0))
       )
      (('shadow-mask)
       (let ((v0-42 (command-get-int (-> block param 0) 0)))
         (set! (-> self draw shadow-mask) (the-as uint v0-42))
         v0-42
         )
       )
      (('shadow-values)
       (let ((v0-43 (command-get-int (-> block param 0) 0)))
         (set! (-> self draw shadow-values) (the-as uint v0-43))
         v0-43
         )
       )
      (('mirror)
       (cond
         ((-> block param 0)
          (set! s4-0 (-> self node-list data 2))
          (set! (-> (the-as cspace s4-0) param0)
                (the-as (function cspace transformq none) cspace<-parented-matrix-mirror!)
                )
          (set! (-> (the-as cspace s4-0) param1) (the-as basic (-> *math-camera* mirror-trans)))
          (set! (-> (the-as cspace s4-0) param2) (the-as basic (-> *math-camera* mirror-normal)))
          )
         (else
           (set! s4-0 (-> self node-list data 2))
           (set! (-> (the-as cspace s4-0) param0) #f)
           )
         )
       s4-0
       )
      (('draw-mirror)
       (send-event (ppointer->process (-> self child)) 'draw (-> block param 0))
       )
      (('user)
       (set! s4-0 (-> block param 1))
       (set! (-> self user-uint64 (/ (the-as int (-> block param 0)) 8)) (the-as uint s4-0))
       s4-0
       )
      (('die)
       (deactivate self)
       )
      (('do-effect)
       (if (and (nonzero? (-> self skel)) (-> self skel effect))
           (do-effect (-> self skel effect) (the-as symbol (-> block param 0)) (the-as float (-> block param 1)) -1)
           )
       )
      (else
        (if (-> self cur-event-hook)
            ((-> self cur-event-hook))
            )
        )
      )
    )
  :trans (behavior ()
    (if (!= (-> self cur-trans-hook) (-> self new-trans-hook))
        (set! (-> self cur-trans-hook) (-> self new-trans-hook))
        )
    (if (!= (-> self cur-post-hook) (-> self new-post-hook))
        (set! (-> self cur-post-hook) (-> self new-post-hook))
        )
    (when (and (-> self new-joint-anim)
               (nonzero? (-> self skel))
               (and (!= (ja-group) (-> self new-joint-anim)) (!= (-> self anim-mode) 'clone-anim))
               )
      (ja-channel-push! 1 (the-as time-frame (-> self new-joint-anim-blend)))
      (ja :group! (-> self new-joint-anim) :num! min)
      )
    (let ((v1-20 (handle->process (-> self cur-grab-handle))))
      (when v1-20
        (let ((gp-1 (-> (the-as process-drawable v1-20) root trans)))
          (if (type? (-> self root) collide-shape)
              (move-by-vector!
                (the-as collide-shape (-> self root))
                (vector-! (new 'stack-no-clear 'vector) gp-1 (-> self old-grab-pos))
                )
              (vector+!
                (-> self root trans)
                (-> self root trans)
                (vector-! (new 'stack-no-clear 'vector) gp-1 (-> self old-grab-pos))
                )
              )
          (set! (-> self old-grab-pos quad) (-> gp-1 quad))
          )
        )
      )
    ((-> self cur-trans-hook))
    )
  :code (behavior ()
    (logclear! (-> self mask) (process-mask heap-shrunk))
    (until #f
      (case (-> self anim-mode)
        (('loop)
         (ja-post)
         (manipy-post)
         (suspend)
         (ja :num! (loop!))
         )
        (('play)
         (ja-post)
         (manipy-post)
         (suspend)
         (ja :num! (seek!))
         )
        (('copy-parent)
         (let ((v1-17 (-> self skel root-channel 0)))
           (set! (-> v1-17 num-func) num-func-identity)
           (let ((a0-10 (-> self parent)))
             (set! (-> v1-17 frame-num) (-> (the-as process-drawable (if a0-10
                                                                         (the-as process-drawable (-> a0-10 0 self))
                                                                         )
                                                    )
                                            skel
                                            root-channel
                                            0
                                            frame-num
                                            )
                   )
             )
           )
         (ja-post)
         (manipy-post)
         (suspend)
         0
         )
        (('clone-parent)
         (let ((gp-0 (ppointer->process (-> self parent))))
           (set! (-> self post-hook) #f)
           (joint-control-copy! (-> self skel) (-> (the-as process-drawable gp-0) skel))
           (joint-control-remap!
             (-> self skel)
             (-> self draw art-group)
             (-> (the-as process-drawable gp-0) draw art-group)
             '()
             0
             ""
             )
           )
         (update-anim-data (-> self skel))
         (do-joint-math (-> self draw) (-> self node-list) (-> self skel))
         (manipy-post)
         (suspend)
         0
         )
        (('clone-anim)
         (clone-anim-once
           (if (handle->process (-> self cur-target-handle))
               (the-as handle (-> self cur-target-handle))
               (ppointer->handle (-> self parent))
               )
           (-> self clone-copy-trans)
           (the-as string (-> self prefix))
           )
         (manipy-post)
         (suspend)
         0
         )
        (('mirror)
         (let ((gp-1 (if (handle->process (-> self cur-target-handle))
                         (-> self cur-target-handle)
                         (ppointer->handle (-> self parent))
                         )
                     )
               )
           (clone-anim-once gp-1 (-> self clone-copy-trans) (the-as string (-> self prefix)))
           (logior! (-> self draw global-effect) (draw-control-global-effect disable-envmap))
           (set! (-> self draw light-index) (the-as uint 5))
           (if (logtest? (-> (the-as process-drawable (handle->process gp-1)) draw status)
                         (draw-control-status no-draw no-draw-temp no-draw-bounds)
                         )
               (logior! (-> self draw status) (draw-control-status no-draw-temp))
               )
           )
         (manipy-post)
         (suspend)
         0
         )
        (('still)
         (ja-post)
         (manipy-post)
         (suspend)
         0
         )
        (('play1)
         (ja-post)
         (manipy-post)
         (suspend)
         (ja :num! (seek! max (-> self speed)))
         (if (ja-done? 0)
             (deactivate self)
             )
         )
        )
      )
    #f
    )
  )

;; definition for function manipy-init
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defbehavior manipy-init manipy ((arg0 vector) (arg1 entity-actor) (arg2 skeleton-group) (arg3 vector) (arg4 object))
  (stack-size-set! (-> self main-thread) 128)
  (logior! (-> self mask) (process-mask heap-shrunk))
  (process-entity-set! self arg1)
  (cond
    ((= arg3 'collide-shape-moving)
     (let ((s3-1 (new 'process 'collide-shape-moving self (collide-list-enum hit-by-player))))
       (set! (-> s3-1 dynam) (copy *standard-dynamics* 'process))
       (set! (-> s3-1 reaction) cshape-reaction-default)
       (set! (-> s3-1 no-reaction)
             (the-as (function collide-shape-moving collide-query vector vector object) nothing)
             )
       (let ((v1-11 (new 'process 'collide-shape-prim-sphere s3-1 (the-as uint 0))))
         (set-vector! (-> v1-11 local-sphere) 0.0 0.0 0.0 4096.0)
         (set! (-> s3-1 total-prims) (the-as uint 1))
         (set! (-> s3-1 root-prim) v1-11)
         )
       (set! (-> s3-1 nav-radius) (* 0.75 (-> s3-1 root-prim local-sphere w)))
       (let ((v1-14 (-> s3-1 root-prim)))
         (set! (-> s3-1 backup-collide-as) (-> v1-14 prim-core collide-as))
         (set! (-> s3-1 backup-collide-with) (-> v1-14 prim-core collide-with))
         )
       (set! (-> self root) s3-1)
       )
     )
    (arg3
      (let ((s3-2 (new 'process 'collide-shape self (collide-list-enum hit-by-player))))
        (let ((v1-18 (new 'process 'collide-shape-prim-sphere s3-2 (the-as uint 0))))
          (set! (-> v1-18 prim-core collide-as) (collide-spec collectable notice-blue-eco-powerup))
          (set! (-> v1-18 prim-core collide-with) (collide-spec jak player-list))
          (set-vector! (-> v1-18 local-sphere) (-> arg3 x) (-> arg3 y) (-> arg3 z) (-> arg3 w))
          (set! (-> s3-2 total-prims) (the-as uint 1))
          (set! (-> s3-2 root-prim) v1-18)
          )
        (set! (-> s3-2 nav-radius) (* 0.75 (-> s3-2 root-prim local-sphere w)))
        (let ((v1-21 (-> s3-2 root-prim)))
          (set! (-> s3-2 backup-collide-as) (-> v1-21 prim-core collide-as))
          (set! (-> s3-2 backup-collide-with) (-> v1-21 prim-core collide-with))
          )
        (set! (-> self root) s3-2)
        )
      )
    (else
      (set! (-> self root) (the-as collide-shape (new 'process 'trsqv)))
      )
    )
  (set! (-> self root trans quad) (-> arg0 quad))
  (initialize-skeleton self arg2 (the-as pair 0))
  (if (type? (-> self root) collide-shape)
      (update-transforms (the-as collide-shape (-> self root)))
      )
  (set! (-> self shadow-backup) (-> self draw shadow))
  (set! (-> self shadow-volume-joint) -1)
  (set! (-> self options) (the-as manipy-options arg4))
  (when (-> self draw shadow)
    (set! (-> self draw shadow-ctrl)
          (new 'process 'shadow-control 0.0 0.0 614400.0 (shadow-flags shdf02 shdf03 shdf04 disable-draw) 245760.0)
          )
    (quad-copy! (the-as pointer (-> self draw shadow-ctrl settings)) (the-as pointer *default-shadow-settings*) 5)
    )
  (set! (-> self new-trans-hook) nothing)
  (set! (-> self cur-trans-hook) nothing)
  (set! (-> self new-post-hook) nothing)
  (set! (-> self cur-post-hook) nothing)
  (set! (-> self cur-event-hook) #f)
  (set! (-> self cur-grab-handle) (the-as handle #f))
  (set! (-> self cur-target-handle) (the-as handle #f))
  (set! (-> self clone-copy-trans) #t)
  (set! (-> self draw?) #t)
  (set! (-> self prefix) "")
  (set! (-> self speed) 1.0)
  (when (logtest? (-> self options) (manipy-options mo-0))
    (let ((v1-56 (get-art-by-name-method (-> self draw jgeo) "neckA" (the-as type #f))))
      (when v1-56
        (set! (-> self joint 0)
              (new 'process 'joint-mod (joint-mod-mode flex-blend) self (+ (-> (the-as joint v1-56) number) 1))
              )
        (set! (-> self joint 0 parented-scale?) #t)
        )
      )
    )
  (cond
    ((nonzero? (-> self skel))
     (set! (-> self new-joint-anim) (ja-group))
     (set! (-> self anim-mode) 'loop)
     )
    (else
      (set! (-> self anim-mode) 'still)
      )
    )
  (set! (-> self event-hook) (-> (method-of-object self idle) event))
  (go-virtual idle)
  (none)
  )

;; definition for method 10 of type part-tracker
(defmethod deactivate ((this part-tracker))
  (if (nonzero? (-> this part))
      (kill-and-free-particles (-> this part))
      )
  ((method-of-type process deactivate) this)
  (none)
  )

;; definition for method 15 of type part-tracker
;; WARN: Return type mismatch object vs none.
(defmethod notify-parent-of-death ((this part-tracker))
  (with-pp
    (let ((gp-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> gp-0 from) (process->ppointer pp))
      (set! (-> gp-0 num-params) 1)
      (set! (-> gp-0 message) 'notify)
      (set! (-> gp-0 param 0) (the-as uint 'die))
      (let ((s5-0 send-event-function)
            (s4-0 (ppointer->process (-> this parent)))
            )
        (s5-0
          (if (type? s4-0 process)
              s4-0
              )
          gp-0
          )
        )
      )
    (none)
    )
  )

;; failed to figure out what this is:
(defstate active (part-tracker)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('die)
       (deactivate self)
       )
      )
    )
  :code (behavior ()
    (set-time! (-> self start-time))
    (while (or (zero? (-> self duration))
               (not (time-elapsed? (-> self start-time) (the-as time-frame (-> self duration))))
               )
      (if (-> self callback)
          ((-> self callback) self)
          )
      (let* ((gp-0 (handle->process (-> self target)))
             (v1-8 (if (type? gp-0 process-drawable)
                       gp-0
                       )
                   )
             )
        (cond
          ((and v1-8
                (nonzero? (-> (the-as process-drawable v1-8) root))
                (nonzero? (-> (the-as process-drawable v1-8) node-list))
                )
           (spawn-with-cspace (-> self part) (-> (the-as process-drawable v1-8) node-list data (-> self target-joint)))
           (set! (-> self root trans quad) (-> self part origin trans quad))
           )
          (else
            (let ((a0-12 (-> self root trans)))
              (set! (-> self mat trans quad) (-> a0-12 quad))
              )
            (spawn-with-matrix (-> self part) (-> self mat))
            )
          )
        )
      (suspend)
      )
    (let ((gp-1 (current-time)))
      (until (time-elapsed? gp-1 (the-as time-frame (-> self linger-duration)))
        (if (-> self linger-callback)
            ((-> self linger-callback) self)
            )
        (let* ((s5-0 (handle->process (-> self target)))
               (v1-30 (if (type? s5-0 process-drawable)
                          s5-0
                          )
                      )
               )
          (if (and v1-30
                   (nonzero? (-> (the-as process-drawable v1-30) root))
                   (nonzero? (-> (the-as process-drawable v1-30) node-list))
                   )
              (vector<-cspace!
                (-> self root trans)
                (-> (the-as process-drawable v1-30) node-list data (-> self target-joint))
                )
              )
          )
        (suspend)
        )
      )
    (if (-> self linger-callback)
        ((-> self linger-callback) self)
        )
    (notify-parent-of-death self)
    (suspend)
    0
    )
  )

;; definition for function part-tracker-init
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defbehavior part-tracker-init part-tracker ((arg0 sparticle-launch-group)
                                   (arg1 time-frame)
                                   (arg2 (function part-tracker none))
                                   (arg3 (pointer process-drawable))
                                   (arg4 process)
                                   (arg5 matrix)
                                   )
  (stack-size-set! (-> self main-thread) 128)
  (if (= pointer process-tree)
      (set! (-> self clock) (-> *display* part-clock))
      )
  (set! (-> self target) (process->handle arg4))
  (cond
    (arg4
      (set! (-> self target-joint) (the-as int arg5))
      )
    ((logtest? (-> arg0 flags) (sp-group-flag unk-5))
     (let* ((s1-1 (-> self mat))
            (a2-1 (math-camera-matrix))
            (v1-11 (-> a2-1 quad 0))
            (a0-7 (-> a2-1 quad 1))
            (a1-2 (-> a2-1 quad 2))
            (a2-2 (-> a2-1 trans quad))
            )
       (set! (-> s1-1 quad 0) v1-11)
       (set! (-> s1-1 quad 1) a0-7)
       (set! (-> s1-1 quad 2) a1-2)
       (set! (-> s1-1 trans quad) a2-2)
       )
     (set! (-> self mat trans quad) (-> arg5 trans quad))
     (set! (-> self offset quad) (-> self mat trans quad))
     )
    (else
      (let* ((v1-14 (-> self mat))
             (a3-1 arg5)
             (a0-12 (-> a3-1 quad 0))
             (a1-3 (-> a3-1 quad 1))
             (a2-3 (-> a3-1 quad 2))
             (a3-2 (-> a3-1 trans quad))
             )
        (set! (-> v1-14 quad 0) a0-12)
        (set! (-> v1-14 quad 1) a1-3)
        (set! (-> v1-14 quad 2) a2-3)
        (set! (-> v1-14 trans quad) a3-2)
        )
      (set! (-> self offset quad) (-> self mat trans quad))
      )
    )
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> self mat trans quad))
  (if (zero? arg0)
      (go process-drawable-art-error "null group")
      )
  (set! (-> self callback) (the-as (function part-tracker vector) arg2))
  (set! (-> self linger-callback) #f)
  (set! (-> self userdata) (the-as uint arg3))
  (set! arg1 (cond
               ((> arg1 0)
                (empty)
                arg1
                )
               ((= arg1 -1)
                0
                )
               (else
                 (the-as time-frame (-> arg0 duration))
                 )
               )
        )
  (set! (-> self duration) (the-as uint arg1))
  (set! (-> self linger-duration) (-> arg0 linger-duration))
  (set! (-> self part) (create-launch-control arg0 self))
  (go-virtual active)
  (none)
  )

;; definition for function part-tracker-track-root
;; WARN: Return type mismatch int vs none.
(defun part-tracker-track-root ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 vector))
  (let ((v1-3 (-> arg1 key proc root trans)))
    (set! (-> arg2 x) (-> v1-3 x))
    (set! (-> arg2 y) (-> v1-3 y))
    (set! (-> arg2 z) (-> v1-3 z))
    )
  0
  (none)
  )

;; definition for function part-tracker-move-to-target
(defun part-tracker-move-to-target ((arg0 part-tracker))
  (let* ((a0-1 *target*)
         (a2-0 (if (not a0-1)
                   (-> arg0 root trans)
                   (get-trans a0-1 3)
                   )
               )
         )
    (vector-lerp!
      (-> arg0 root trans)
      (-> arg0 offset)
      a2-0
      (* 0.006666667 (the float (- (current-time) (-> arg0 start-time))))
      )
    )
  )

;; definition for function part-tracker-track-target
;; INFO: Used lq/sq
(defun part-tracker-track-target ((arg0 part-tracker))
  (set! (-> arg0 linger-callback) (-> arg0 callback))
  (let* ((a0-1 *target*)
         (v1-2 (if (not a0-1)
                   (-> arg0 root trans)
                   (get-trans a0-1 3)
                   )
               )
         (v0-1 (-> arg0 root trans))
         )
    (set! (-> v0-1 quad) (-> v1-2 quad))
    v0-1
    )
  )

;; definition for method 15 of type lightning-tracker
;; WARN: Return type mismatch object vs none.
(defmethod notify-parent-of-death ((this lightning-tracker))
  (with-pp
    (let ((gp-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> gp-0 from) (process->ppointer pp))
      (set! (-> gp-0 num-params) 1)
      (set! (-> gp-0 message) 'notify)
      (set! (-> gp-0 param 0) (the-as uint 'die))
      (let ((s5-0 send-event-function)
            (s4-0 (ppointer->process (-> this parent)))
            )
        (s5-0
          (if (type? s4-0 process)
              s4-0
              )
          gp-0
          )
        )
      )
    (none)
    )
  )

;; definition for method 16 of type lightning-tracker
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod update ((this lightning-tracker))
  (if (-> this callback)
      ((-> this callback) this)
      )
  (let ((a0-6 (cond
                ((>= (-> this target-joint0) 0)
                 (let ((s5-0 (handle->process (-> this target0))))
                   (if (type? s5-0 process-drawable)
                       s5-0
                       )
                   )
                 )
                (else
                  (the-as process #f)
                  )
                )
              )
        )
    (cond
      ((< (-> this target-joint0) 0)
       (when (and (!= (-> this lightning spec rand-func) 3) (!= (-> this lightning spec rand-func) 2))
         (let ((v1-17 (-> this lightning))
               (a0-9 (-> this offset0))
               )
           (set! (-> v1-17 state meet data 0 quad) (-> a0-9 quad))
           )
         )
       )
      ((or (not a0-6) (zero? (-> (the-as process-focusable a0-6) root)))
       (deactivate this)
       )
      ((= (-> this target-joint0) 256)
       (let ((s5-1 (-> this lightning))
             (a0-12 (get-trans (the-as process-focusable a0-6) 3))
             )
         (set! (-> s5-1 state meet data 0 quad) (-> a0-12 quad))
         )
       )
      (else
        (let ((s5-2 (-> this lightning))
              (a0-16 (vector<-cspace!
                       (new 'stack-no-clear 'vector)
                       (-> (the-as process-focusable a0-6) node-list data (-> this target-joint0))
                       )
                     )
              )
          (set! (-> s5-2 state meet data 0 quad) (-> a0-16 quad))
          )
        )
      )
    )
  (let ((a0-22 (cond
                 ((>= (-> this target-joint1) 0)
                  (let ((s5-3 (handle->process (-> this target1))))
                    (if (type? s5-3 process-drawable)
                        s5-3
                        )
                    )
                  )
                 (else
                   (the-as process #f)
                   )
                 )
               )
        )
    (cond
      ((< (-> this target-joint1) 0)
       (when (and (!= (-> this lightning spec rand-func) 3) (!= (-> this lightning spec rand-func) 2))
         (let ((a0-26 (-> this lightning))
               (v1-44 (-> this offset1))
               )
           (set! (-> a0-26 state meet data (+ (-> a0-26 state points-to-draw) -1) quad) (-> v1-44 quad))
           )
         )
       )
      ((or (not a0-22) (zero? (-> (the-as process-focusable a0-22) root)))
       (deactivate this)
       )
      ((= (-> this target-joint1) 256)
       (let ((gp-1 (-> this lightning))
             (v1-51 (get-trans (the-as process-focusable a0-22) 3))
             )
         (set! (-> gp-1 state meet data (+ (-> gp-1 state points-to-draw) -1) quad) (-> v1-51 quad))
         )
       )
      (else
        (let ((s5-4 (-> this lightning))
              (v1-54 (vector<-cspace!
                       (new 'stack-no-clear 'vector)
                       (-> (the-as process-drawable a0-22) node-list data (-> this target-joint1))
                       )
                     )
              )
          (set! (-> s5-4 state meet data (+ (-> s5-4 state points-to-draw) -1) quad) (-> v1-54 quad))
          )
        )
      )
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate active (lightning-tracker)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('die)
       (deactivate self)
       )
      )
    )
  :exit (behavior ()
    (when (nonzero? (-> self sound))
      (let ((v1-1 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> v1-1 command) (sound-command set-param))
        (set! (-> v1-1 id) (-> self sound))
        (set! (-> v1-1 params volume) -4)
        (set! (-> v1-1 auto-time) 240)
        (set! (-> v1-1 auto-from) 2)
        (set! (-> v1-1 params mask) (the-as uint 17))
        (-> v1-1 id)
        )
      )
    )
  :code (behavior ()
    (set! (-> self sound) (new 'static 'sound-id))
    (when (!= (+ (-> self lightning spec delay) (-> self lightning spec delay-rand)) 0.0)
      (let ((gp-0 (current-time))
            (s5-0 (the int (rand-vu-float-range
                             (-> self lightning spec delay)
                             (+ (-> self lightning spec delay) (-> self lightning spec delay-rand))
                             )
                       )
                  )
            )
        (while (not (time-elapsed? gp-0 s5-0))
          (suspend)
          )
        )
      )
    (let ((gp-1 (-> self lightning spec sound)))
      (when gp-1
        (let ((s5-1 (new 'stack-no-clear 'vector)))
          (set! (-> s5-1 quad) (-> self offset1 quad))
          (when (and (>= (-> self target-joint1) 0) (< (-> self target-joint1) 256))
            (let* ((s4-0 (handle->process (-> self target1)))
                   (v1-28 (if (type? s4-0 process-drawable)
                              s4-0
                              )
                          )
                   )
              (if (and v1-28 (nonzero? (-> (the-as process-drawable v1-28) root)))
                  (set! (-> s5-1 quad) (-> (vector<-cspace!
                                             (new 'stack-no-clear 'vector)
                                             (-> (the-as process-drawable v1-28) node-list data (-> self target-joint1))
                                             )
                                           quad
                                           )
                        )
                  )
              )
            )
          (set! (-> self sound) (sound-play-by-spec (the-as sound-spec gp-1) (new-sound-id) s5-1))
          )
        )
      )
    (let ((v1-33 (-> self lightning))
          (a0-10 1)
          )
      (let ((a1-10 (!= a0-10 (-> v1-33 state mode))))
        (case a0-10
          ((3)
           (if a1-10
               (set! (-> v1-33 state counter) 0.0)
               )
           )
          ((1)
           (set! (-> v1-33 state start-color) (-> v1-33 spec start-color))
           (set! (-> v1-33 state end-color) (-> v1-33 spec end-color))
           )
          )
        )
      (set! (-> v1-33 state mode) (the-as lightning-mode a0-10))
      )
    (set-time! (-> self start-time))
    (while (or (zero? (-> self duration))
               (not (time-elapsed? (-> self start-time) (the-as time-frame (-> self duration))))
               )
      (update self)
      (suspend)
      )
    (let ((f30-0 (-> self lightning spec fade-time)))
      (when (< 0.0 f30-0)
        (let ((v1-47 (-> self lightning))
              (a0-14 3)
              )
          (let ((a1-20 (!= a0-14 (-> v1-47 state mode))))
            (case a0-14
              ((3)
               (if a1-20
                   (set! (-> v1-47 state counter) 0.0)
                   )
               )
              ((1)
               (set! (-> v1-47 state start-color) (-> v1-47 spec start-color))
               (set! (-> v1-47 state end-color) (-> v1-47 spec end-color))
               )
              )
            )
          (set! (-> v1-47 state mode) (the-as lightning-mode a0-14))
          )
        (set-time! (-> self start-time))
        (while (not (time-elapsed? (-> self start-time) (the int f30-0)))
          (suspend)
          )
        )
      )
    (let ((v1-54 (-> self lightning))
          (a0-17 0)
          )
      (let ((a1-30 (!= a0-17 (-> v1-54 state mode))))
        (case a0-17
          ((3)
           (if a1-30
               (set! (-> v1-54 state counter) 0.0)
               )
           )
          ((1)
           (set! (-> v1-54 state start-color) (-> v1-54 spec start-color))
           (set! (-> v1-54 state end-color) (-> v1-54 spec end-color))
           )
          )
        )
      (set! (-> v1-54 state mode) (the-as lightning-mode a0-17))
      )
    (notify-parent-of-death self)
    (suspend)
    0
    )
  )

;; definition for function lightning-tracker-init
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defbehavior lightning-tracker-init lightning-tracker ((arg0 lightning-spec) (arg1 time-frame) (arg2 symbol) (arg3 process-drawable) (arg4 vector) (arg5 vector))
  (stack-size-set! (-> self main-thread) 128)
  (set! (-> self target0) (process->handle arg3))
  (let ((s1-1 (ppointer->process (-> self parent))))
    (set! (-> self target1) (process->handle (the-as process (if (type? s1-1 process-drawable)
                                                                 s1-1
                                                                 )
                                                     )
                                             )
          )
    )
  (cond
    ((>= 256 (the-as int arg4))
     (set! (-> self target-joint0) (the-as int arg4))
     (vector-identity! (-> self offset0))
     )
    (else
      (set! (-> self target-joint0) -1)
      (set! (-> self offset0 quad) (-> arg4 quad))
      )
    )
  (cond
    ((>= 256 (the-as int arg5))
     (set! (-> self target-joint1) (the-as int arg5))
     (vector-identity! (-> self offset1))
     )
    (else
      (set! (-> self target-joint1) -1)
      (set! (-> self offset1 quad) (-> arg5 quad))
      )
    )
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self callback) (the-as (function lightning-tracker none) arg2))
  (set! arg1
        (cond
          ((> arg1 0)
           (empty)
           arg1
           )
          ((= arg1 -1)
           0
           )
          (else
            (the-as
              time-frame
              (the int (rand-vu-float-range (-> arg0 duration) (+ (-> arg0 duration) (-> arg0 duration-rand))))
              )
            )
          )
        )
  (set! (-> self duration) (the-as uint arg1))
  (set! (-> self lightning) (new 'process 'lightning-control arg0 self 0.0))
  (let ((v1-21 (-> self lightning))
        (a0-17 0)
        )
    (let ((a1-7 (!= a0-17 (-> v1-21 state mode))))
      (case a0-17
        ((3)
         (if a1-7
             (set! (-> v1-21 state counter) 0.0)
             )
         )
        ((1)
         (set! (-> v1-21 state start-color) (-> v1-21 spec start-color))
         (set! (-> v1-21 state end-color) (-> v1-21 spec end-color))
         )
        )
      )
    (set! (-> v1-21 state mode) (the-as lightning-mode a0-17))
    )
  (go-virtual active)
  (none)
  )

;; definition for function process-grab?
;; WARN: Return type mismatch object vs symbol.
(defbehavior process-grab? process ((arg0 process) (arg1 symbol))
  (let ((a0-1 (command-get-process arg0 *target*)))
    (the-as symbol (if a0-1
                       (send-event a0-1 'change-mode 'grab (cond
                                                             ((= arg1 #t)
                                                              #f
                                                              )
                                                             ((= arg1 'dead)
                                                              'dead
                                                              )
                                                             (else
                                                               #t
                                                               )
                                                             )
                                   )
                       )
            )
    )
  )

;; definition for function process-release?
;; WARN: Return type mismatch object vs symbol.
(defbehavior process-release? process ((arg0 process))
  (let* ((gp-0 (command-get-process arg0 *target*))
         (a0-2 (if (type? gp-0 process-focusable)
                   (the-as process-focusable gp-0)
                   )
               )
         )
    (the-as symbol (if (and a0-2 (focus-test? a0-2 grabbed))
                       (send-event a0-2 'end-mode)
                       #t
                       )
            )
    )
  )

;; definition for function camera-look-at
(defun camera-look-at ((arg0 pair) (arg1 uint))
  (let ((gp-0 (command-get-process arg0 *target*)))
    (if gp-0
        (send-event *camera* 'change-target gp-0 arg1)
        )
    gp-0
    )
  )

;; definition for function ja-anim-done?
;; WARN: Return type mismatch object vs symbol.
(defun ja-anim-done? ((arg0 process))
  (with-pp
    (let ((gp-0 (command-get-process arg0 *target*)))
      (the-as
        symbol
        (when gp-0
          (cond
            ((type? gp-0 manipy)
             (send-event gp-0 'query 'done)
             )
            ((type? gp-0 process-drawable)
             (when (not (logtest? (-> (the-as process-drawable gp-0) skel status) (joint-control-status spooling-not-last-block))
                        )
               (let ((s5-0 pp))
                 (set! pp gp-0)
                 (let ((v0-1 (the-as object (ja-done? 0))))
                   (set! pp s5-0)
                   v0-1
                   )
                 )
               )
             )
            )
          )
        )
      )
    )
  )

;; definition for function camera-pov-from
;; WARN: Return type mismatch target vs process.
(defun camera-pov-from ((arg0 pair) (arg1 uint))
  (let ((gp-0 (the-as target (command-get-process arg0 *target*))))
    (when gp-0
      (when (= arg1 -10)
        (set! arg1 (the-as uint 0))
        (when (> (-> gp-0 skel active-channels) 0)
          (let ((v1-7 (get-art-by-name-method (-> gp-0 draw jgeo) "camera" (the-as type #f))))
            (if v1-7
                (set! arg1 (the-as uint (+ (-> (the-as joint v1-7) number) 1)))
                )
            )
          )
        )
      (let ((v1-9 (process->ppointer gp-0)))
        (set-setting! 'pov-handle (the-as joint v1-9) (the float arg1) (-> (the-as (pointer process) v1-9) 0 pid))
        )
      )
    (the-as process gp-0)
    )
  )

;; definition of type med-res-level
(deftype med-res-level (process-drawable)
  ((level-name  basic)
   (part-mode   basic)
   (index       int32)
   )
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type med-res-level
(defmethod inspect ((this med-res-level))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tlevel-name: ~A~%" (-> this level-name))
  (format #t "~2Tpart-mode: ~A~%" (-> this part-mode))
  (format #t "~2Tindex: ~D~%" (-> this index))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defstate idle (med-res-level)
  :virtual #t
  :code (behavior ()
    (until #f
      (let ((v1-1 (level-get *level* (the-as symbol (-> self level-name)))))
        (cond
          ((and v1-1 (= (-> v1-1 display?) 'special))
           (logclear! (-> self draw status) (draw-control-status no-draw))
           (if (nonzero? (-> self skel))
               (ja :num! (loop!))
               )
           )
          ((and v1-1 (= (-> v1-1 status) 'active))
           (logior! (-> self draw status) (draw-control-status no-draw))
           )
          (else
            (logclear! (-> self draw status) (draw-control-status no-draw))
            (if (nonzero? (-> self skel))
                (ja :num! (loop!))
                )
            )
          )
        )
      (suspend)
      )
    #f
    )
  :post ja-post
  )

;; definition for method 11 of type med-res-level
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this med-res-level) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (stack-size-set! (-> this main-thread) 128)
  (let ((s4-0 (res-lump-struct arg0 'art-name structure))
        (s3-0 (res-lump-struct (-> this entity) 'level structure))
        (v1-5 (res-lump-value (-> this entity) 'index uint128 :time -1000000000.0))
        )
    (when s3-0
      (set! (-> this level-name) (the-as basic s3-0))
      (set! (-> this index) (the-as int v1-5))
      (set! (-> this root) (new 'process 'trsqv))
      (process-drawable-from-entity! this arg0)
      (logclear! (-> this mask) (process-mask actor-pause))
      (initialize-skeleton-by-name this (the-as string s4-0))
      (logior! (-> this draw status) (draw-control-status no-closest-distance))
      (if (nonzero? (-> this draw))
          (go (method-of-object this idle))
          )
      )
    )
  (none)
  )

;; definition for method 10 of type part-spawner
(defmethod deactivate ((this part-spawner))
  (if (nonzero? (-> this part))
      (kill-and-free-particles (-> this part))
      )
  (if (nonzero? (-> this sound))
      (stop! (-> this sound))
      )
  ((method-of-type process deactivate) this)
  (none)
  )

;; definition for method 15 of type part-spawner
(defmethod is-in-view? ((this part-spawner))
  (sphere<-vector+r! (-> this world-sphere) (-> this root trans) (-> this radius))
  (sphere-in-view-frustum? (-> this world-sphere))
  )

;; failed to figure out what this is:
(defstate active (part-spawner)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('stop)
       (process-entity-status! self (entity-perm-status subtask-complete) #t)
       (set! (-> self enable) #f)
       #t
       )
      (('start)
       (process-entity-status! self (entity-perm-status subtask-complete) #f)
       (set! (-> self enable) #t)
       #t
       )
      (('trans)
       (let ((v0-1 (the-as object (-> (the-as vector (-> block param 0)) quad))))
         (set! (-> self root trans quad) (the-as uint128 v0-1))
         v0-1
         )
       )
      )
    )
  :code (behavior ()
    (until #f
      (when (-> self enable)
        (spawn (-> self part) (-> self root trans))
        (if (nonzero? (-> self sound))
            (update! (-> self sound))
            )
        )
      (suspend)
      )
    #f
    )
  )

;; definition for method 11 of type part-spawner
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this part-spawner) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (sv-16 string))
  (stack-size-set! (-> this main-thread) 128)
  (logior! (-> this mask) (process-mask ambient))
  (set! (-> this clock) (-> *display* part-clock))
  (set! (-> this root) (new 'process 'trsqv))
  (set! (-> this root trans quad) (-> arg0 extra trans quad))
  (quaternion-copy! (-> this root quat) (-> arg0 quat))
  (vector-identity! (-> this root scale))
  (set! (-> this radius) 12288.0)
  (set! (-> this enable)
        (not (and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete)))
             )
        )
  (set! (-> this sound) (new 'process 'ambient-sound (-> this entity) (-> this root trans)))
  (set! sv-16 "#f")
  (set! (-> this mode) (entity-lookup-part-group arg0 (& sv-16) 'art-name))
  (when (-> this mode)
    (let ((a0-15 (-> this mode 0)))
      (when (and (nonzero? a0-15) (= (-> a0-15 type) sparticle-launch-group))
        (cond
          ((logtest? (-> a0-15 flags) (sp-group-flag unk-8))
           (countdown (v1-27 (-> a0-15 length))
             (let* ((a1-8 (-> a0-15 launcher v1-27))
                    (a3-2 (-> *part-id-table* (-> a1-8 launcher)))
                    )
               (when (nonzero? a3-2)
                 (let ((a2-7 (-> this level part-engine)))
                   (when (and a2-7 (< (-> a2-7 length) (-> a2-7 allocated-length)))
                     (let ((t0-7 (-> a2-7 data (-> a2-7 length))))
                       (set! (-> t0-7 next1) (the-as connectable a3-2))
                       (set! (-> t0-7 prev1) (the-as connectable (-> a1-8 hour-mask)))
                       (set! (-> (the-as vector (&-> t0-7 param0)) quad) (-> this root trans quad))
                       (set! (-> t0-7 param3) (the-as int (-> a1-8 fade-after)))
                       )
                     (+! (-> a2-7 length) 1)
                     )
                   )
                 )
               )
             )
           (process-entity-status! this (entity-perm-status dead) #t)
           (deactivate this)
           )
          (else
            (set! (-> this part) (create-launch-control a0-15 this))
            (go (method-of-object this active))
            )
          )
        )
      )
    )
  (go process-drawable-art-error sv-16)
  (none)
  )

;; definition of type launcher
(deftype launcher (process-drawable)
  ((root             collide-shape :override)
   (spring-height    meters)
   (camera           state)
   (active-distance  float)
   (seek-time        time-frame)
   (dest             vector         :inline)
   (sound-id         sound-id)
   )
  (:state-methods
    idle
    active
    deactivated
    )
  )

;; definition for method 3 of type launcher
(defmethod inspect ((this launcher))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tspring-height: (meters ~m)~%" (-> this spring-height))
  (format #t "~2Tcamera: ~A~%" (-> this camera))
  (format #t "~2Tactive-distance: ~f~%" (-> this active-distance))
  (format #t "~2Tseek-time: ~D~%" (-> this seek-time))
  (format #t "~2Tdest: ~`vector`P~%" (-> this dest))
  (format #t "~2Tsound-id: ~D~%" (-> this sound-id))
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defpartgroup group-beach-launcher
  :id 6
  :bounds (static-bspherem 0 3 0 5)
  :parts ((sp-item 77 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 78 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 79 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 80 :fade-after (meters 50) :falloff-to (meters 80))
    (sp-item 81 :fade-after (meters 70) :falloff-to (meters 100))
    )
  )

;; failed to figure out what this is:
(defpart 77
  :init-specs ((:num 1.5)
    (:x (meters 1.5))
    (:y (meters -0.5))
    (:rot-x 5)
    (:r 4096.0)
    (:g 2867.2)
    (:b 3276.8)
    (:vel-y (meters 0.026666667))
    (:timer (seconds 0.9))
    (:flags (distort))
    (:next-time (seconds 0.6))
    (:next-launcher 82)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

;; failed to figure out what this is:
(defpart 82
  :init-specs ((:fade-b -4.551111))
  )

;; failed to figure out what this is:
(defpart 78
  :init-specs ((:texture (new 'static 'texture-id :index #xc9 :page #xc))
    (:num 1.0)
    (:x (meters 0) (meters 1.8))
    (:scale-x (meters 0.2))
    (:rot-x (degrees 90))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 2.5) (meters 2.5))
    (:r 0.0 1 128.0)
    (:g 64.0 196.0)
    (:b 128.0 128.0)
    (:a 128.0)
    (:scalevel-x (meters -0.0025))
    (:scalevel-y (meters 0.24414062) (meters 0.48828125))
    (:timer (seconds 0.27))
    (:flags (sp-cpuinfo-flag-3))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

;; failed to figure out what this is:
(defpart 79
  :init-specs ((:texture (new 'static 'texture-id :index #xc9 :page #xc))
    (:num 2.0)
    (:x (meters 1.8) (meters 1))
    (:scale-x (meters 0.2))
    (:rot-x (degrees 90))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.5) (meters 1))
    (:r 0.0 1 128.0)
    (:g 64.0 196.0)
    (:b 128.0 128.0)
    (:a 128.0)
    (:scalevel-x (meters -0.0025))
    (:scalevel-y (meters 0.048828125) (meters 0.09765625))
    (:timer (seconds 0.27))
    (:flags (sp-cpuinfo-flag-3))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

;; failed to figure out what this is:
(defpart 80
  :init-specs ((:texture (new 'static 'texture-id :index #x2f :page #xc))
    (:num 1.5)
    (:x (meters 2.9) (meters 2.5))
    (:y (meters -0.5))
    (:scale-x (meters 0.3) (meters 0.4))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.1) (meters 0.1))
    (:r 10.0 6.0)
    (:g 64.0 128.0)
    (:b 10.0 6.0)
    (:a 80.0)
    (:vel-x (meters -0.011666667) (meters -0.0033333334))
    (:vel-y (meters 0))
    (:rotvel-z (degrees -1.2) 1 (degrees 2.4))
    (:fade-a -0.2)
    (:accel-y (meters 0.0016666667))
    (:friction 0.996)
    (:timer (seconds 0.6) (seconds 0.397))
    (:flags (sp-cpuinfo-flag-2))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

;; failed to figure out what this is:
(defpart 81
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 0.5)
    (:x (meters 2.9) (meters 2.5))
    (:y (meters -0.5))
    (:scale-x (meters 2) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 32.0 32.0)
    (:g 32.0 32.0)
    (:b 10.0 5.0)
    (:a 0.0)
    (:vel-x (meters -0.011666667) (meters -0.0033333334))
    (:vel-y (meters 0))
    (:rotvel-z (degrees -1.2) 1 (degrees 2.4))
    (:fade-a 0.6)
    (:accel-y (meters 0.0016666667))
    (:friction 0.996)
    (:timer (seconds 0.9))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:next-time (seconds 0.15))
    (:next-launcher 83)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

;; failed to figure out what this is:
(defpart 83
  :init-specs ((:fade-a -0.18))
  )

;; failed to figure out what this is:
(defpartgroup group-jungle-launcher
  :id 7
  :bounds (static-bspherem 0 3 0 5)
  :parts ((sp-item 77 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 84 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 85 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 86 :fade-after (meters 70) :falloff-to (meters 100))
    )
  )

;; failed to figure out what this is:
(defpart 84
  :init-specs ((:texture (new 'static 'texture-id :index #xc9 :page #xc))
    (:num 1.0)
    (:x (meters 0) (meters 1.4))
    (:scale-x (meters 0.2))
    (:rot-x (degrees 90))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 2.5) (meters 2.5))
    (:r 0.0 1 128.0)
    (:g 64.0 196.0)
    (:b 128.0 128.0)
    (:a 128.0)
    (:scalevel-x (meters -0.0025))
    (:scalevel-y (meters 0.24414062) (meters 0.48828125))
    (:timer (seconds 0.27))
    (:flags (sp-cpuinfo-flag-3))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

;; failed to figure out what this is:
(defpart 85
  :init-specs ((:texture (new 'static 'texture-id :index #xc9 :page #xc))
    (:num 2.0)
    (:x (meters 1.4) (meters 0.9))
    (:scale-x (meters 0.2))
    (:rot-x (degrees 90))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.5) (meters 1))
    (:r 0.0 1 128.0)
    (:g 64.0 196.0)
    (:b 128.0 128.0)
    (:a 128.0)
    (:scalevel-x (meters -0.0025))
    (:scalevel-y (meters 0.048828125) (meters 0.09765625))
    (:timer (seconds 0.27))
    (:flags (sp-cpuinfo-flag-3))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

;; failed to figure out what this is:
(defpart 86
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 0.5)
    (:x (meters 2.9) (meters 2.5))
    (:y (meters -0.5))
    (:scale-x (meters 2) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 64.0 32.0)
    (:g 32.0 32.0)
    (:b 10.0 5.0)
    (:a 0.0)
    (:vel-x (meters -0.011666667) (meters -0.0033333334))
    (:vel-y (meters 0))
    (:rotvel-z (degrees -1.2) 1 (degrees 2.4))
    (:fade-a 0.6)
    (:accel-y (meters 0.0016666667))
    (:friction 0.996)
    (:timer (seconds 0.9))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:next-time (seconds 0.15))
    (:next-launcher 83)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

;; failed to figure out what this is:
(defpartgroup group-swamp-launcher
  :id 8
  :bounds (static-bspherem 0 3 0 5)
  :parts ((sp-item 77 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 78 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 79 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 87 :fade-after (meters 70) :falloff-to (meters 100))
    )
  )

;; failed to figure out what this is:
(defpart 87
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 0.5)
    (:x (meters 2.9) (meters 2.5))
    (:y (meters -0.5))
    (:scale-x (meters 2) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 16.0 16.0)
    (:g 16.0 16.0)
    (:b 5.0 2.5)
    (:a 0.0)
    (:vel-x (meters -0.011666667) (meters -0.0033333334))
    (:vel-y (meters 0))
    (:rotvel-z (degrees -1.2) 1 (degrees 2.4))
    (:fade-a 0.6)
    (:accel-y (meters 0.0016666667))
    (:friction 0.996)
    (:timer (seconds 0.9))
    (:flags (sp-cpuinfo-flag-2))
    (:next-time (seconds 0.15))
    (:next-launcher 83)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

;; definition for function cam-launcher-joystick
;; INFO: Used lq/sq
(defbehavior cam-launcher-joystick camera-slave ()
  (when (not (logtest? (-> *camera* settings master-options) (cam-master-options IGNORE_ANALOG)))
    (let ((s5-0 (new-stack-matrix0))
          (gp-0 (vector-reset! (new 'stack-no-clear 'vector)))
          )
      (let* ((f0-0 (analog-input (the-as int (+ (-> *cpad-list* cpads 0 rightx) -128)) 0.0 48.0 110.0 -1.0))
             (f0-1 (* -546.13336 f0-0))
             (f0-3 (fmin 546.13336 (fmax -546.13336 f0-1)))
             )
        (matrix-axis-angle! s5-0 (-> *camera* local-down) f0-3)
        )
      (vector-! gp-0 (-> self trans) (-> *camera* tpos-curr))
      (vector-matrix*! gp-0 gp-0 s5-0)
      (vector+! (-> self trans) gp-0 (-> *camera* tpos-curr))
      )
    )
  )

;; failed to figure out what this is:
(defstate cam-launcher-shortfall (camera-slave)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('teleport)
       #f
       )
      (else
        (cam-standard-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (let ((gp-0 (new 'stack-no-clear 'vector)))
        (vector--float*! (-> self trans) (-> *camera* tpos-curr) (-> *camera* local-down) 28672.0)
        (vector-flatten! gp-0 (-> self tracking inv-mat vector 2) (-> *camera* local-down))
        (vector-normalize! gp-0 1.0)
        (set! (-> self pivot-pt quad) (-> gp-0 quad))
        (vector+float*! gp-0 gp-0 (-> *camera* local-down) 1000.0)
        (vector-normalize-copy! (-> self tracking inv-mat vector 2) gp-0 1.0)
        )
      (vector-cross!
        (-> self tracking inv-mat vector 1)
        (-> self tracking inv-mat vector 2)
        (the-as vector (-> self tracking))
        )
      (set! (-> self blend-from-type) (the-as uint 0))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-0))
      0
      )
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) (cam-master-options-u32 HAVE_TARGET)))
        (cam-slave-go cam-free-floating)
        )
    )
  :code (behavior ()
    (let ((gp-0 (current-time)))
      (until #f
        (when (not (paused?))
          (vector--float*! (-> self trans) (-> *camera* tpos-curr) (-> *camera* local-down) 28672.0)
          (send-event *camera* 'teleport)
          (if (and (-> *camera* on-ground) (time-elapsed? gp-0 (seconds 1)))
              (send-event *camera* 'change-state cam-string (seconds 0.5))
              )
          )
        (suspend)
        )
      )
    #f
    )
  )

;; definition for function cam-launcher-long-joystick
;; INFO: Used lq/sq
(defbehavior cam-launcher-long-joystick camera-slave ()
  (when (not (logtest? (-> *camera* settings master-options) (cam-master-options IGNORE_ANALOG)))
    (let ((gp-0 (new-stack-matrix0)))
      (let* ((f0-0 (analog-input (the-as int (+ (-> *cpad-list* cpads 0 rightx) -128)) 0.0 48.0 110.0 -1.0))
             (f0-1 (* -546.13336 f0-0))
             (f0-3 (fmin 546.13336 (fmax -546.13336 f0-1)))
             )
        (matrix-axis-angle! gp-0 (-> *camera* local-down) f0-3)
        )
      (vector-matrix*! (-> self view-flat) (-> self view-flat) gp-0)
      )
    (vector-normalize! (-> self view-flat) 4096.0)
    )
  )

;; failed to figure out what this is:
(defstate cam-launcher-longfall (camera-slave)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('teleport)
       #f
       )
      (else
        (cam-standard-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (new 'stack-no-clear 'vector)
      (vector-negate! (-> self view-flat) (-> self tracking inv-mat vector 2))
      (vector-normalize! (-> self view-flat) 4096.0)
      (vector--float*! (-> self trans) (-> *camera* tpos-curr) (-> *camera* local-down) 28672.0)
      (vector+! (-> self trans) (-> self trans) (-> self view-flat))
      (set! (-> self blend-from-type) (the-as uint 0))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-0))
      (cam-calc-follow! (-> self tracking) (-> self trans) #f)
      (slave-set-rotation! (-> self tracking) (-> self trans) (-> self options) (-> self fov) #f)
      )
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) (cam-master-options-u32 HAVE_TARGET)))
        (cam-slave-go cam-free-floating)
        )
    (cam-launcher-long-joystick)
    )
  :code (behavior ()
    (let ((gp-0 (current-time)))
      (until #f
        (when (not (paused?))
          (let ((s4-0 (new 'stack-no-clear 'vector))
                (s5-0 (new 'stack-no-clear 'vector))
                )
            0.0
            0.0
            0.0
            (send-event *camera* 'teleport)
            (let* ((f0-4 (vector-dot (-> self velocity) (-> *camera* local-down)))
                   (f30-0 (* 0.975 f0-4))
                   )
              (vector--float*! s4-0 (-> *camera* tpos-curr) (-> *camera* local-down) 28672.0)
              (vector-! s4-0 s4-0 (-> self trans))
              (let ((f28-0 (vector-dot s4-0 (-> *camera* local-down))))
                (vector--float*! s5-0 s4-0 (-> *camera* local-down) f28-0)
                (cond
                  ((< f28-0 f30-0)
                   (set! f30-0 f28-0)
                   )
                  ((< 20480.0 f28-0)
                   (let ((f28-1 (+ -20480.0 f28-0)))
                     (let ((f0-8 (lerp f30-0 f28-1 0.005)))
                       (if (< f30-0 f0-8)
                           (set! f30-0 f0-8)
                           )
                       )
                     (if (< (* 0.09 f28-1) f30-0)
                         (set! f30-0 (* 0.09 f28-1))
                         )
                     )
                   )
                  )
                )
              (vector+float*! (-> self velocity) s5-0 (-> *camera* local-down) f30-0)
              )
            )
          (vector+! (-> self trans) (-> self trans) (-> self velocity))
          (set! (-> self trans x) (-> *camera* tpos-curr x))
          (set! (-> self trans z) (-> *camera* tpos-curr z))
          (vector+! (-> self trans) (-> self trans) (-> self view-flat))
          (if (and (-> *camera* on-ground) (time-elapsed? gp-0 (seconds 1)))
              (send-event *camera* 'change-state cam-string (seconds 0.5))
              )
          )
        (vector-reset! (-> self tracking follow-off))
        (vector+! (-> self tracking follow-pt) (-> *camera* tpos-curr-adj) (-> self tracking follow-off))
        (vector--float*!
          (-> self tracking follow-pt)
          (-> self tracking follow-pt)
          (-> *camera* local-down)
          (-> *camera* settings target-height)
          )
        (slave-set-rotation! (-> self tracking) (-> self trans) (-> self options) (-> self fov) #f)
        (suspend)
        )
      )
    #f
    )
  )

;; failed to figure out what this is:
(defstate idle (launcher)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('instant-death)
       (go-virtual deactivated)
       )
      (('trans)
       (move-to-point! (-> self root) (the-as vector (-> block param 0)))
       (update-transforms (-> self root))
       )
      )
    )
  :trans (behavior ()
    (when (and *target*
               (and (>= (-> self active-distance) (vector-vector-distance (-> self root trans) (-> *target* control trans)))
                    (not (logtest? (focus-status teleporting) (-> *target* focus-status)))
                    )
               )
      (cond
        ((send-event *target* 'query 'powerup (pickup-type eco-blue))
         (go-virtual active)
         )
        (else
          (let ((gp-0 'target-launch))
            (if (= (send-event *target* 'query 'mode) gp-0)
                (send-event *target* 'end-mode)
                )
            )
          )
        )
      (if (and (and *target* (and (>= 32768.0 (vector-vector-distance (-> self root trans) (-> *target* control trans)))
                                  (not (logtest? (focus-status teleporting) (-> *target* focus-status)))
                                  )
                    )
               (not (send-event *target* 'query 'powerup (pickup-type eco-blue)))
               )
          (talker-spawn-func (-> *talker-speech* 322) *entity-pool* (target-pos 0) (the-as region #f))
          )
      )
    )
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate active (launcher)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (when (or (= message 'touch) (= message 'attack))
      (set-time! (-> self state-time))
      (send-event proc 'launch (-> self spring-height) (-> self camera) (-> self dest) (-> self seek-time))
      )
    (cond
      ((= message 'instant-death)
       (go-virtual deactivated)
       )
      ((= message 'trans)
       (move-to-point! (-> self root) (the-as vector (-> block param 0)))
       (update-transforms (-> self root))
       )
      )
    )
  :exit (behavior ()
    (let ((v1-0 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-0 command) (sound-command set-param))
      (set! (-> v1-0 id) (-> self sound-id))
      (set! (-> v1-0 params volume) -4)
      (set! (-> v1-0 auto-time) 120)
      (set! (-> v1-0 auto-from) 2)
      (set! (-> v1-0 params mask) (the-as uint 17))
      (-> v1-0 id)
      )
    )
  :trans (behavior ()
    (if (or (or (not *target*)
                (or (< (-> self active-distance) (vector-vector-distance (-> self root trans) (-> *target* control trans)))
                    (focus-test? *target* teleporting)
                    )
                )
            (not (send-event *target* 'query 'powerup (pickup-type eco-blue)))
            )
        (go-virtual idle)
        )
    (spawn (-> self part) (-> self root trans))
    (sound-play "launch-idle" :id (-> self sound-id))
    (if (and (and *target* (and (>= (+ 2867.2 (-> self root root-prim prim-core world-sphere w))
                                    (vector-vector-distance (-> self root trans) (-> *target* control trans))
                                    )
                                (not (logtest? (focus-status teleporting) (-> *target* focus-status)))
                                )
                  )
             (not (time-elapsed? (-> self state-time) (seconds 0.5)))
             )
        (send-event *target* 'launch (-> self spring-height) (-> self camera) (-> self dest) (-> self seek-time))
        )
    )
  :code (behavior ()
    (sound-play "launch-start")
    (sleep-code)
    )
  )

;; failed to figure out what this is:
(defstate deactivated (launcher)
  :virtual #t
  :code sleep-code
  )

;; definition for method 11 of type launcher
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this launcher) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (stack-size-set! (-> this main-thread) 128)
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((v1-4 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-4 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-4 prim-core collide-with) (collide-spec jak player-list))
      (set-vector! (-> v1-4 local-sphere) 0.0 0.0 0.0 12288.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-4)
      )
    (set! (-> s4-0 nav-radius) 13926.4)
    (let ((v1-6 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-6 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-6 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (update-transforms (-> this root))
  (set! (-> this active-distance) 409600.0)
  (set! (-> this spring-height) (res-lump-float arg0 'spring-height :default 163840.0))
  (let ((s4-1 (res-lump-value arg0 'mode uint128 :time -1000000000.0)))
    (let ((v1-14 (-> this level name)))
      (set! (-> this part) (create-launch-control
                             (cond
                               ((= v1-14 'beach)
                                (-> *part-group-id-table* 6)
                                )
                               ((= v1-14 'swamp)
                                (-> *part-group-id-table* 8)
                                )
                               (else
                                 (-> *part-group-id-table* 7)
                                 )
                               )
                             this
                             )
            )
      )
    (let ((v1-20 (logand (the-as int s4-1) 255)))
      (cond
        ((= (the-as uint v1-20) 1)
         (set! (-> this camera) cam-launcher-longfall)
         )
        ((= (the-as uint v1-20) 2)
         (set! (-> this camera) #f)
         )
        (else
          (set! (-> this camera) cam-launcher-shortfall)
          )
        )
      )
    )
  (let ((v1-25 (res-lump-struct arg0 'alt-vector vector)))
    (when v1-25
      (set-vector! (-> this dest) (-> v1-25 x) (-> v1-25 y) (-> v1-25 z) 1.0)
      (set! (-> this seek-time) (the-as time-frame (the int (* 300.0 (-> v1-25 w)))))
      )
    )
  (set! (-> this sound-id) (new-sound-id))
  (nav-mesh-connect-from-ent this)
  (go (method-of-object this idle))
  (none)
  )

;; definition for function launcher-init-by-other
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defbehavior launcher-init-by-other launcher ((arg0 vector) (arg1 float) (arg2 int) (arg3 float))
  (stack-size-set! (-> self main-thread) 128)
  (let ((s2-0 (new 'process 'collide-shape self (collide-list-enum hit-by-player))))
    (let ((v1-4 (new 'process 'collide-shape-prim-sphere s2-0 (the-as uint 0))))
      (set! (-> v1-4 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-4 prim-core collide-with) (collide-spec jak player-list))
      (set-vector! (-> v1-4 local-sphere) 0.0 0.0 0.0 12288.0)
      (set! (-> s2-0 total-prims) (the-as uint 1))
      (set! (-> s2-0 root-prim) v1-4)
      )
    (set! (-> s2-0 nav-radius) (* 0.75 (-> s2-0 root-prim local-sphere w)))
    (let ((v1-7 (-> s2-0 root-prim)))
      (set! (-> s2-0 backup-collide-as) (-> v1-7 prim-core collide-as))
      (set! (-> s2-0 backup-collide-with) (-> v1-7 prim-core collide-with))
      )
    (set! (-> self root) s2-0)
    )
  (set! (-> self root trans quad) (-> arg0 quad))
  (set-vector! (-> self root scale) 1.0 1.0 1.0 1.0)
  (set-vector! (-> self root quat) 0.0 0.0 0.0 1.0)
  (update-transforms (-> self root))
  (set! (-> self spring-height) arg1)
  (set! (-> self active-distance) arg3)
  (let ((v1-18 (-> self level name)))
    (set! (-> self part) (create-launch-control
                           (cond
                             ((= v1-18 'beach)
                              (-> *part-group-id-table* 6)
                              )
                             ((= v1-18 'swamp)
                              (-> *part-group-id-table* 8)
                              )
                             (else
                               (-> *part-group-id-table* 7)
                               )
                             )
                           self
                           )
          )
    )
  (case (logand arg2 255)
    ((1)
     (set! (-> self camera) cam-launcher-longfall)
     )
    ((2)
     (set! (-> self camera) #f)
     )
    (else
      (set! (-> self camera) cam-launcher-shortfall)
      )
    )
  (let ((v1-29 (res-lump-struct (-> self entity) 'alt-vector vector)))
    (when v1-29
      (set-vector! (-> self dest) (-> v1-29 x) (-> v1-29 y) (-> v1-29 z) 1.0)
      (set! (-> self seek-time) (the-as time-frame (the int (* 300.0 (-> v1-29 w)))))
      )
    )
  (set! (-> self sound-id) (new-sound-id))
  (go-virtual idle)
  (none)
  )

;; failed to figure out what this is:
(defstate active (touch-tracker)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (v0-0 object))
    (case message
      (('touched)
       (let ((v1-1 (ppointer->process (-> self parent))))
         (when (!= v1-1 proc)
           (cond
             ((= (-> self event) 'attack)
              (send-event
                proc
                (-> self event)
                :from v1-1
                #f
                (static-attack-info ((mode (the-as symbol (-> self event-mode))) (id (new-attack-id))))
                )
              )
             ((-> self event)
              (send-event proc (-> self event) :from v1-1)
              )
             (else
               (let ((t0-5 (new 'stack-no-clear 'event-message-block)))
                 (set! (-> t0-5 from) (process->ppointer proc))
                 (set! (-> t0-5 num-params) argc)
                 (set! (-> t0-5 message) message)
                 (set! (-> t0-5 param 0) (-> block param 0))
                 (set! (-> t0-5 param 1) (-> block param 1))
                 (set! (-> t0-5 param 2) (-> block param 2))
                 (set! (-> t0-5 param 3) (-> block param 3))
                 (set! (-> t0-5 param 4) (-> block param 4))
                 (set! (-> t0-5 param 5) (-> block param 5))
                 (send-event-function v1-1 t0-5)
                 )
               )
             )
           )
         )
       )
      (('target)
       (set! v0-0 (process->handle (the-as process (-> block param 0))))
       (set! (-> self target) (the-as handle v0-0))
       v0-0
       )
      (('event)
       (set! (-> self event) (the-as symbol (-> block param 0)))
       (set! v0-0 (-> block param 1))
       (set! (-> self event-mode) (the-as basic v0-0))
       v0-0
       )
      (('exit)
       (set! v0-0 (-> block param 0))
       (set! (-> self run-function) (the-as (function object) v0-0))
       v0-0
       )
      (('eval)
       ((the-as (function touch-tracker object) (-> block param 0)) self)
       )
      (('function)
       (set! v0-0 (-> block param 0))
       (set! (-> self callback) (the-as (function touch-tracker none) v0-0))
       v0-0
       )
      )
    )
  :code (behavior ()
    (set-time! (-> self state-time))
    (while ((-> self run-function))
      (let* ((gp-0 (handle->process (-> self target)))
             (a0-4 (if (type? gp-0 process-drawable)
                       gp-0
                       )
                   )
             )
        (when a0-4
          (let* ((gp-1 (-> (the-as process-drawable a0-4) root))
                 (a0-6 (if (type? gp-1 collide-shape)
                           gp-1
                           )
                       )
                 )
            (if a0-6
                (set! (-> self root trans quad) (-> (the-as collide-shape a0-6) root-prim prim-core world-sphere quad))
                )
            )
          )
        )
      (if (-> self callback)
          ((-> self callback) self)
          )
      (update-transforms (-> self root))
      (let ((a1-3 (new 'stack-no-clear 'overlaps-others-params)))
        (set! (-> a1-3 options) (overlaps-others-options oo1))
        (set! (-> a1-3 collide-with-filter) (the-as collide-spec -1))
        (set! (-> a1-3 tlist) *touching-list*)
        (find-overlapping-shapes (-> self root) a1-3)
        )
      (suspend)
      )
    (let ((v1-21 (-> self root root-prim)))
      (set! (-> v1-21 prim-core collide-as) (collide-spec))
      (set! (-> v1-21 prim-core collide-with) (collide-spec))
      )
    0
    (suspend)
    0
    )
  )

;; definition for function touch-tracker-init
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defbehavior touch-tracker-init touch-tracker ((arg0 vector) (arg1 float) (arg2 time-frame))
  (let ((s4-0 (new 'process 'collide-shape-moving self (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec jak enemy))
      (set! (-> v1-6 prim-core collide-with)
            (collide-spec
              crate
              civilian
              enemy
              obstacle
              vehicle-sphere
              hit-by-player-list
              hit-by-others-list
              collectable
              pusher
              )
            )
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 arg1)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-6)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> s4-0 event-self) 'touched)
    (set! (-> self root) s4-0)
    )
  (set! (-> self root trans quad) (-> arg0 quad))
  (set! (-> self duration) arg2)
  (set! (-> self target) (the-as handle #f))
  (set! (-> self event) #f)
  (set! (-> self callback) #f)
  (set! (-> self run-function)
        (lambda :behavior touch-tracker () (not (time-elapsed? (-> self state-time) (-> self duration))))
        )
  (set! (-> self event-hook) (-> (method-of-object self active) event))
  (go-virtual active)
  (none)
  )

;; definition for method 21 of type explosion
;; WARN: Return type mismatch int vs none.
(defmethod setup-explosion-collision ((this explosion))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (set! (-> s5-0 penetrate-using) (penetrate explode))
    (let ((v1-3 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-3 prim-core action) (collide-action solid))
      (set-vector! (-> v1-3 local-sphere) 0.0 0.0 0.0 0.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-3)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-6 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-6 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-6 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (set! (-> this root event-self) 'touched)
  0
  (none)
  )

;; definition for method 22 of type explosion
;; WARN: Return type mismatch int vs none.
(defmethod explosion-method-22 ((this explosion))
  0
  (none)
  )

;; definition for function explosion-init-by-other
;; INFO: Used lq/sq
(defbehavior explosion-init-by-other explosion ((arg0 explosion-init-params))
  (logclear! (-> self mask) (process-mask actor-pause movie))
  (setup-explosion-collision self)
  (set! (-> self root trans quad) (-> arg0 spawn-point quad))
  (quaternion-copy! (-> self root quat) (-> arg0 spawn-quat))
  (set! (-> self root penetrate-using) (-> arg0 penetrate-using))
  (let ((v1-9 (-> self root root-prim)))
    (set! (-> v1-9 local-sphere w) (-> arg0 radius))
    (set! (-> v1-9 prim-core world-sphere w) (-> arg0 radius))
    (set! (-> v1-9 prim-core collide-with) (-> arg0 collide-with))
    )
  (let* ((v1-10 *game-info*)
         (a0-9 (+ (-> v1-10 attack-id) 1))
         )
    (set! (-> v1-10 attack-id) a0-9)
    (set! (-> self attack-id) a0-9)
    )
  (let ((a0-10 (-> arg0 group)))
    (when a0-10
      (set! (-> self duration) (-> a0-10 duration))
      (set! (-> self linger-duration) (-> a0-10 linger-duration))
      (set! (-> self part) (create-launch-control a0-10 self))
      )
    )
  (let ((v1-16 (new 'stack-no-clear 'traffic-danger-info)))
    (set! (-> v1-16 sphere quad) (-> self root trans quad))
    (vector-reset! (-> v1-16 velocity))
    (set! (-> v1-16 sphere r) (* 2.0 (-> arg0 radius)))
    (set! (-> v1-16 notify-radius) 204800.0)
    (set! (-> v1-16 danger-level) 1.0)
    (set! (-> v1-16 decay-rate) 0.0)
    (set! (-> v1-16 flags) (traffic-danger-flags tdf0))
    (set! (-> v1-16 danger-type) (traffic-danger-type tdt5))
    (send-event *traffic-manager* 'add-danger-sphere v1-16)
    )
  (explosion-method-22 self)
  (go-virtual explode)
  )

;; definition for function explosion-spawn
;; WARN: Return type mismatch (pointer process) vs none.
(defun explosion-spawn ((arg0 process-drawable) (arg1 type) (arg2 explosion-init-params))
  (let ((s4-0 (get-process *default-dead-pool* arg1 #x4000)))
    (when s4-0
      (let ((t9-1 (method-of-type process activate)))
        (t9-1 s4-0 arg0 (symbol->string (-> arg1 symbol)) (the-as pointer #x70004000))
        )
      (run-now-in-process s4-0 explosion-init-by-other arg2)
      (-> s4-0 ppointer)
      )
    )
  (none)
  )

;; failed to figure out what this is:
(defstate explode (explosion)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touched)
       (let* ((s4-0 proc)
              (v1-1 (if (type? s4-0 process-drawable)
                        s4-0
                        )
                    )
              )
         (when v1-1
           (let ((a0-3 (-> (the-as process-drawable v1-1) root))
                 (a1-2 (new 'stack-no-clear 'collide-query))
                 )
             (let ((v1-4 (-> self root root-prim prim-core))
                   (a0-5 (-> (the-as collide-shape a0-3) root-prim prim-core))
                   )
               0.0
               (set! (-> a1-2 start-pos quad) (-> v1-4 world-sphere quad))
               (vector-! (-> a1-2 move-dist) (the-as vector a0-5) (the-as vector v1-4))
               )
             (let ((v1-5 a1-2))
               (set! (-> v1-5 radius) 40.96)
               (set! (-> v1-5 collide-with) (collide-spec backgnd))
               (set! (-> v1-5 ignore-process0) #f)
               (set! (-> v1-5 ignore-process1) #f)
               (set! (-> v1-5 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
               (set! (-> v1-5 action-mask) (collide-action solid))
               )
             (if (< (fill-and-probe-using-line-sphere *collide-cache* a1-2) 0.0)
                 (send-event proc 'attack (-> block param 0) (static-attack-info ((id (-> self attack-id)) (mode 'explode))))
                 )
             )
           )
         )
       )
      )
    )
  :code (behavior ()
    (set-time! (-> self start-time))
    (update-transforms (-> self root))
    (let ((a1-0 (new 'stack-no-clear 'overlaps-others-params)))
      (set! (-> a1-0 options) (overlaps-others-options))
      (set! (-> a1-0 collide-with-filter) (the-as collide-spec -1))
      (set! (-> a1-0 tlist) *touching-list*)
      (find-overlapping-shapes (-> self root) a1-0)
      )
    (let ((v1-9 (-> self root root-prim)))
      (set! (-> v1-9 prim-core collide-as) (collide-spec))
      (set! (-> v1-9 prim-core collide-with) (collide-spec))
      )
    0
    (while (not (time-elapsed? (-> self start-time) (the-as time-frame (-> self duration))))
      (let ((a1-1 (-> self root trans)))
        (spawn (-> self part) a1-1)
        )
      (suspend)
      )
    (set-time! (-> self start-time))
    (while (not (time-elapsed? (-> self start-time) (the-as time-frame (-> self linger-duration))))
      (suspend)
      )
    )
  )

;; definition for function process-drawable-random-point!
(defun process-drawable-random-point! ((arg0 process-drawable) (arg1 vector))
  (let ((v1-1 (-> arg0 node-list length))
        (s4-0 (-> arg0 root))
        )
    (cond
      ((>= v1-1 7)
       (let ((v1-2 (rand-vu-int-range 3 (+ v1-1 -1))))
         (vector<-cspace! arg1 (-> arg0 node-list data v1-2))
         )
       )
      ((and (nonzero? s4-0) (type? s4-0 collide-shape))
       (vector+!
         arg1
         (the-as vector (-> (the-as collide-shape s4-0) root-prim prim-core))
         (rand-vu-sphere-point! arg1 (-> (the-as collide-shape s4-0) root-prim prim-core world-sphere w))
         )
       )
      (else
        (vector+! arg1 (-> arg0 root trans) (rand-vu-sphere-point! arg1 (-> arg0 draw bounds w)))
        )
      )
    )
  arg1
  )

;; definition for function process-drawable-pair-random-point!
;; INFO: Used lq/sq
(defun process-drawable-pair-random-point! ((arg0 process-drawable) (arg1 process-drawable) (arg2 vector) (arg3 float))
  (let ((s4-0 (new-stack-vector0))
        (s3-0 (new-stack-vector0))
        )
    (process-drawable-random-point! arg0 s4-0)
    (process-drawable-random-point! arg1 s3-0)
    (vector-lerp! arg2 s4-0 s3-0 arg3)
    )
  )
