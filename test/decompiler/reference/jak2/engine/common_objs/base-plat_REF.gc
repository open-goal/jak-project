;;-*-Lisp-*-
(in-package goal)

;; definition of type base-plat
(deftype base-plat (process-focusable)
  ((root-override collide-shape-moving         :offset        128)
   (smush         smush-control        :inline :offset-assert 208)
   (basetrans     vector               :inline :offset-assert 240)
   (bounce-time   time-frame                   :offset-assert 256)
   (bouncing      basic                        :offset-assert 264)
   (bounce-scale  meters                       :offset-assert 268)
   )
  :heap-base #x90
  :method-count-assert 34
  :size-assert         #x110
  :flag-assert         #x2200900110
  (:methods
    (base-plat-method-27 (_type_) none 27)
    (base-plat-method-28 (_type_) none 28)
    (base-plat-method-29 (_type_) none :behavior base-plat 29)
    (base-plat-method-30 (_type_) none 30)
    (base-plat-method-31 (_type_) none 31)
    (base-plat-method-32 (_type_) none 32)
    (base-plat-method-33 (_type_) none 33)
    )
  )

;; definition for method 3 of type base-plat
(defmethod inspect base-plat ((obj base-plat))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-focusable inspect)))
    (t9-0 obj)
    )
  (format #t "~2Tsmush: #<smush-control @ #x~X>~%" (-> obj smush))
  (format #t "~2Tbasetrans: #<vector @ #x~X>~%" (-> obj basetrans))
  (format #t "~2Tbounce-time: ~D~%" (-> obj bounce-time))
  (format #t "~2Tbouncing: ~A~%" (-> obj bouncing))
  (format #t "~2Tbounce-scale: (meters ~m)~%" (-> obj bounce-scale))
  (label cfg-4)
  obj
  )

;; definition for method 33 of type base-plat
;; WARN: Return type mismatch int vs none.
(defmethod base-plat-method-33 base-plat ((obj base-plat))
  0
  (none)
  )

;; definition for method 28 of type base-plat
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod base-plat-method-28 base-plat ((obj base-plat))
  (set! (-> obj basetrans quad) (-> obj root-override trans quad))
  (set! (-> obj bouncing) #f)
  (set! (-> obj bounce-scale) 819.2)
  0
  (none)
  )

;; definition for method 29 of type base-plat
;; WARN: Return type mismatch int vs none.
(defmethod base-plat-method-29 base-plat ((obj base-plat))
  (activate! (-> obj smush) -1.0 60 150 1.0 1.0 (-> self clock))
  (set! (-> obj bounce-time) (-> self clock frame-counter))
  (set! (-> obj bouncing) (the-as basic #t))
  (sound-play "plat-bounce" :position (-> obj root-override trans))
  (logclear! (-> obj mask) (process-mask sleep))
  (logclear! (-> obj mask) (process-mask sleep-code))
  0
  (none)
  )

;; definition for function plat-code
;; WARN: Return type mismatch symbol vs none.
;; WARN: new jak 2 until loop case, check carefully
(defbehavior plat-code base-plat ()
  (transform-post)
  (suspend)
  (transform-post)
  (suspend)
  (until #f
    (when (not (-> self bouncing))
      (logior! (-> self mask) (process-mask sleep))
      (suspend)
      0
      )
    (while (-> self bouncing)
      (suspend)
      )
    )
  #f
  (none)
  )

;; definition for function plat-trans
;; INFO: Used lq/sq
(defbehavior plat-trans base-plat ()
  (rider-trans)
  (cond
    ((-> self bouncing)
     (let ((gp-0 (new 'stack-no-clear 'vector)))
       (set! (-> gp-0 quad) (-> self basetrans quad))
       (+! (-> gp-0 y) (* (-> self bounce-scale) (update! (-> self smush))))
       (collide-shape-method-29 (-> self root-override) gp-0)
       )
     (if (not (!= (-> self smush amp) 0.0))
         (set! (-> self bouncing) #f)
         )
     )
    (else
      (collide-shape-method-29 (-> self root-override) (-> self basetrans))
      )
    )
  (none)
  )

;; definition for function plat-post
(defbehavior plat-post base-plat ()
  (base-plat-method-27 self)
  (rider-post)
  (none)
  )

;; definition for method 32 of type base-plat
;; WARN: Return type mismatch int vs none.
(defmethod base-plat-method-32 base-plat ((obj base-plat))
  0
  (none)
  )

;; definition for method 27 of type base-plat
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod base-plat-method-27 base-plat ((obj base-plat))
  (if (nonzero? (-> obj part))
      (sparticle-launch-control-method-11 (-> obj part) (-> obj root-override trans))
      )
  (when (nonzero? (-> obj sound))
    (set! (-> obj sound trans quad) (-> obj root-override trans quad))
    (update! (-> obj sound))
    )
  (none)
  )

;; definition for function plat-event
;; WARN: Return type mismatch none vs object.
(defbehavior plat-event base-plat ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (let ((v1-0 arg2))
    (the-as object (if (= v1-0 'bonk)
                       (base-plat-method-29 self)
                       )
            )
    )
  )

;; definition of type eco-door
(deftype eco-door (process-drawable)
  ((root-override  collide-shape         :offset        128)
   (speed          float                 :offset-assert 200)
   (open-distance  float                 :offset-assert 204)
   (close-distance float                 :offset-assert 208)
   (out-dir        vector        :inline :offset-assert 224)
   (open-sound     sound-name            :offset-assert 240)
   (close-sound    sound-name            :offset-assert 256)
   (state-actor    entity-actor          :offset-assert 272)
   (flags          int32                 :offset-assert 276)
   (locked         symbol                :offset-assert 280)
   (auto-close     symbol                :offset-assert 284)
   (one-way        symbol                :offset-assert 288)
   )
  :heap-base #xb0
  :method-count-assert 27
  :size-assert         #x124
  :flag-assert         #x1b00b00124
  (:methods
    (door-closed () _type_ :state 20)
    (door-opening () _type_ :state 21)
    (door-open () _type_ :state 22)
    (door-closing () _type_ :state 23)
    (eco-door-method-24 (_type_) none 24)
    (eco-door-method-25 (_type_) none 25)
    (eco-door-method-26 (_type_) none 26)
    )
  )

;; definition for method 3 of type eco-door
;; INFO: Used lq/sq
(defmethod inspect eco-door ((obj eco-door))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 obj)
    )
  (format #t "~2Tspeed: ~f~%" (-> obj speed))
  (format #t "~2Topen-distance: ~f~%" (-> obj open-distance))
  (format #t "~2Tclose-distance: ~f~%" (-> obj close-distance))
  (format #t "~2Tout-dir: #<vector @ #x~X>~%" (-> obj out-dir))
  (format #t "~2Topen-sound: ~D~%" (-> obj open-sound))
  (format #t "~2Tclose-sound: ~D~%" (-> obj close-sound))
  (format #t "~2Tstate-actor: ~A~%" (-> obj state-actor))
  (format #t "~2Tflags: ~D~%" (-> obj flags))
  (format #t "~2Tlocked: ~A~%" (-> obj locked))
  (format #t "~2Tauto-close: ~A~%" (-> obj auto-close))
  (format #t "~2Tone-way: ~A~%" (-> obj one-way))
  (label cfg-4)
  obj
  )

;; definition for function eco-door-event-handler
;; WARN: Return type mismatch symbol vs object.
(defbehavior eco-door-event-handler eco-door ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (let ((v1-0 arg2))
    (the-as object (when (= v1-0 'trigger)
                     (set! (-> self locked) (not (-> self locked)))
                     (cond
                       ((-> self locked)
                        (if (and (-> self next-state) (= (-> self next-state name) 'door-closed))
                            (sound-play "door-lock")
                            )
                        )
                       (else
                         (sound-play "door-unlock")
                         )
                       )
                     #t
                     )
            )
    )
  )

;; failed to figure out what this is:
eco-door-event-handler

;; failed to figure out what this is:
(defstate door-closed (eco-door)
  :virtual #t
  :event eco-door-event-handler
  :code (behavior ()
    (ja :num-func num-func-identity :frame-num 0.0)
    (suspend)
    (collide-shape-method-46 (-> self root-override))
    (ja-post)
    (until #f
      (when (and *target* (and (>= (-> self open-distance)
                                   (vector-vector-distance (-> self root-override trans) (-> *target* control trans))
                                   )
                               (zero? (logand (focus-status teleporting) (-> *target* focus-status)))
                               )
                 )
        (eco-door-method-24 self)
        (if (and (not (-> self locked))
                 (or (and (-> self entity) (logtest? (-> self entity extra perm status) (entity-perm-status subtask-complete)))
                     (send-event *target* 'query 'powerup (pickup-type eco-blue))
                     (and (-> self one-way) (< (vector4-dot (-> self out-dir) (target-pos 0)) -8192.0))
                     )
                 )
            (go-virtual door-opening)
            )
        )
      (suspend)
      )
    #f
    (none)
    )
  )

;; failed to figure out what this is:
(defstate door-opening (eco-door)
  :virtual #t
  :event eco-door-event-handler
  :code (behavior ()
    (if (and (not (and (-> self entity) (logtest? (-> self entity extra perm status) (entity-perm-status subtask-complete)))
                  )
             (send-event *target* 'query 'powerup (pickup-type eco-blue))
             )
        (sound-play "blue-eco-on" :position (-> self root-override trans))
        )
    (sound-play-by-name (-> self open-sound) (new-sound-id) 1024 0 0 (sound-group sfx) #t)
    (let ((v1-14 (-> self root-override root-prim)))
      (set! (-> v1-14 prim-core collide-as) (collide-spec))
      (set! (-> v1-14 prim-core collide-with) (collide-spec))
      )
    0
    (until (ja-done? 0)
      (ja :num! (seek! max (-> self speed)))
      (suspend)
      )
    (go-virtual door-open)
    (none)
    )
  :post (the-as (function none :behavior eco-door) transform-post)
  )

;; failed to figure out what this is:
(defstate door-open (eco-door)
  :virtual #t
  :event eco-door-event-handler
  :code (behavior ()
    (set! (-> self state-time) (-> self clock frame-counter))
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (let ((v1-3 (-> self root-override root-prim)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (ja :num-func num-func-identity :frame-num max)
    (logior! (-> self draw status) (draw-control-status no-draw))
    (suspend)
    (collide-shape-method-46 (-> self root-override))
    (ja-post)
    (until #f
      (let ((f30-0 (vector4-dot (-> self out-dir) (target-pos 0)))
            (f28-0 (vector4-dot (-> self out-dir) (camera-pos)))
            )
        (when (and (-> self auto-close)
                   (or (not *target*) (or (< (-> self close-distance)
                                             (vector-vector-distance (-> self root-override trans) (-> *target* control trans))
                                             )
                                          (logtest? (focus-status teleporting) (-> *target* focus-status))
                                          )
                       )
                   )
          (if (and (>= (* f30-0 f28-0) 0.0) (< 16384.0 (fabs f28-0)))
              (go-virtual door-closing)
              )
          )
        )
      (suspend)
      )
    #f
    (none)
    )
  )

;; failed to figure out what this is:
(defstate door-closing (eco-door)
  :virtual #t
  :event eco-door-event-handler
  :code (behavior ()
    (let ((v1-1 (-> self root-override root-prim)))
      (set! (-> v1-1 prim-core collide-as) (-> self root-override backup-collide-as))
      (set! (-> v1-1 prim-core collide-with) (-> self root-override backup-collde-with))
      )
    (logclear! (-> self draw status) (draw-control-status no-draw))
    (let ((gp-0 (new 'stack 'overlaps-others-params)))
      (set! (-> gp-0 options) (overlaps-others-options oo0))
      (set! (-> gp-0 tlist) #f)
      (while (find-overlapping-shapes (-> self root-override) gp-0)
        (suspend)
        )
      )
    (sound-play-by-name (-> self close-sound) (new-sound-id) 1024 0 0 (sound-group sfx) #t)
    (until (ja-done? 0)
      (ja :num! (seek! 0.0 (-> self speed)))
      (suspend)
      )
    (if (-> self locked)
        (sound-play "door-lock")
        )
    (go-virtual door-closed)
    (none)
    )
  :post (the-as (function none :behavior eco-door) transform-post)
  )

;; definition for method 24 of type eco-door
;; WARN: Return type mismatch int vs none.
(defmethod eco-door-method-24 eco-door ((obj eco-door))
  (when (-> obj state-actor)
    (if (logtest? (-> obj state-actor extra perm status) (entity-perm-status subtask-complete))
        (set! (-> obj locked) (logtest? (-> obj flags) 2))
        (set! (-> obj locked) (logtest? (-> obj flags) 1))
        )
    )
  0
  (none)
  )

;; definition for method 25 of type eco-door
;; WARN: Return type mismatch int vs none.
(defmethod eco-door-method-25 eco-door ((obj eco-door))
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 0)
      (set-vector! (-> v1-2 local-sphere) 0.0 0.0 0.0 16384.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-2)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s5-0 backup-collde-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

;; definition for method 26 of type eco-door
;; WARN: Return type mismatch int vs none.
(defmethod eco-door-method-26 eco-door ((obj eco-door))
  0
  (none)
  )

;; definition for method 11 of type eco-door
;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! eco-door ((obj eco-door) (arg0 entity-actor))
  (eco-door-method-25 obj)
  (process-drawable-from-entity! obj arg0)
  (let ((f0-0 (res-lump-float (-> obj entity) 'scale :default 1.0)))
    (set-vector! (-> obj root-override scale) f0-0 f0-0 f0-0 1.0)
    )
  (set! (-> obj open-distance) 32768.0)
  (set! (-> obj close-distance) 49152.0)
  (set! (-> obj speed) 1.0)
  (set! (-> obj state-actor) #f)
  (let ((v1-8 (entity-actor-lookup arg0 'state-actor 0)))
    (if v1-8
        (set! (-> obj state-actor) v1-8)
        )
    )
  (set! (-> obj locked) #f)
  (set! (-> obj flags) (res-lump-value arg0 'flags int :time -1000000000.0))
  (eco-door-method-24 obj)
  (set! (-> obj auto-close) (logtest? (-> obj flags) 4))
  (set! (-> obj one-way) (logtest? (-> obj flags) 8))
  (vector-z-quaternion! (-> obj out-dir) (-> obj root-override quat))
  (set! (-> obj out-dir w) (- (vector-dot (-> obj out-dir) (-> obj root-override trans))))
  (collide-shape-method-46 (-> obj root-override))
  (eco-door-method-26 obj)
  (if (and (not (-> obj auto-close))
           (-> obj entity)
           (logtest? (-> obj entity extra perm status) (entity-perm-status subtask-complete))
           )
      (go (method-of-object obj door-open))
      (go (method-of-object obj door-closed))
      )
  (none)
  )




