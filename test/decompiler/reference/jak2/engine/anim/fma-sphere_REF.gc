;;-*-Lisp-*-
(in-package goal)

;; definition of type fma-sphere
(deftype fma-sphere (process-drawable)
  ((root          collide-shape       :override)
   (first-time?   symbol)
   (mode          fma-sphere-mode)
   (track-handle  handle)
   (track-joint   int32)
   (attack-id     uint32)
   (duration      time-frame)
   (sphere        sphere               :inline)
   (danger        traffic-danger-info  :inline)
   )
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type fma-sphere
(defmethod inspect ((this fma-sphere))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (format #t "~2Tfirst-time?: ~A~%" (-> this first-time?))
  (format #t "~2Tmode: ~D~%" (-> this mode))
  (format #t "~2Ttrack-handle: ~D~%" (-> this track-handle))
  (format #t "~2Ttrack-joint: ~D~%" (-> this track-joint))
  (format #t "~2Tattack-id: ~D~%" (-> this attack-id))
  (format #t "~2Tduration: ~D~%" (-> this duration))
  (format #t "~2Tstate-time: ~D~%" (-> this state-time))
  (format #t "~2Tsphere: #<sphere @ #x~X>~%" (-> this sphere))
  (format #t "~2Tdanger: #<traffic-danger-info @ #x~X>~%" (-> this danger))
  (label cfg-4)
  this
  )

;; definition for method 12 of type fma-sphere
(defmethod run-logic? ((this fma-sphere))
  "Should this process be run? Checked by execute-process-tree."
  (or (logtest? *display-scene-control* (scene-controls display-controls))
      (and *display-nav-marks* (logtest? (-> this mode) (fma-sphere-mode nav)))
      (logtest? (-> this mode) (fma-sphere-mode deadly-overlap))
      (>= (-> this track-joint) 0)
      (-> this first-time?)
      )
  )

;; failed to figure out what this is:
(defstate idle (fma-sphere)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touched)
       (let ((v1-1 (-> block param 0)))
         (if v1-1
             (send-event proc 'attack v1-1 (static-attack-info ((id (-> self attack-id))
                                                                (mode 'eco-red)
                                                                (attacker-velocity (-> self root transv))
                                                                (damage 2.0)
                                                                (knock (knocked-type knocked-type-2))
                                                                )
                                                               )
                         )
             )
         )
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self first-time?) #f)
    (if (logtest? (-> self mode) (fma-sphere-mode kill-once))
        (send-event *traffic-manager* 'kill-traffic-sphere (-> self sphere))
        )
    )
  :trans (behavior ()
    (local-vars (at-0 int))
    (rlet ((vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (let ((v1-0 (-> self duration)))
        (if (and (nonzero? v1-0) (time-elapsed? (-> self state-time) v1-0))
            (go empty-state)
            )
        )
      (let ((v1-5 (-> self track-joint)))
        (when (>= v1-5 0)
          (let ((a2-0 (handle->process (-> self track-handle)))
                (gp-0 (new 'stack-no-clear 'vector))
                )
            (when a2-0
              (set! (-> gp-0 quad) (-> self sphere quad))
              (set! (-> gp-0 w) 1.0)
              (vector-matrix*! gp-0 gp-0 (-> (the-as process-drawable a2-0) node-list data v1-5 bone transform))
              (let ((v1-9 (-> self root)))
                (vector-! (-> v1-9 transv) gp-0 (-> v1-9 trans))
                (let ((a0-12 (-> v1-9 transv)))
                  (.lvf vf1 (&-> (-> v1-9 transv) quad))
                  (let ((f0-1 (-> self clock frames-per-second)))
                    (.mov at-0 f0-1)
                    )
                  (.mov vf2 at-0)
                  (.mov.vf vf1 vf0 :mask #b1000)
                  (.mul.x.vf vf1 vf1 vf2 :mask #b111)
                  (.svf (&-> a0-12 quad) vf1)
                  )
                )
              (move-to-point! (-> self root) gp-0)
              (set! (-> self danger sphere x) (-> gp-0 x))
              (set! (-> self danger sphere y) (-> gp-0 y))
              (set! (-> self danger sphere z) (-> gp-0 z))
              )
            )
          )
        )
      (if (logtest? (-> self mode) (fma-sphere-mode danger))
          (send-event *traffic-manager* 'add-danger-sphere (-> self danger))
          )
      (when (logtest? (-> self mode) (fma-sphere-mode deadly-overlap))
        (let ((a1-10 (new 'stack-no-clear 'overlaps-others-params)))
          (set! (-> a1-10 options) (overlaps-others-options))
          (set! (-> a1-10 collide-with-filter) (the-as collide-spec -1))
          (set! (-> a1-10 tlist) *touching-list*)
          (find-overlapping-shapes (-> self root) a1-10)
          )
        )
      (if (or (logtest? *display-scene-control* (scene-controls display-controls))
              (and *display-nav-marks* (logtest? (-> self mode) (fma-sphere-mode nav)))
              )
          (add-debug-sphere
            #t
            (bucket-id debug2)
            (-> self root trans)
            (-> self sphere r)
            (new 'static 'rgba :r #x80 :g #x40 :a #x80)
            )
          )
      )
    )
  :code sleep-code
  )

;; definition for function fma-sphere-init-by-other
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defbehavior fma-sphere-init-by-other fma-sphere ((arg0 fma-sphere-mode) (arg1 process-drawable) (arg2 int) (arg3 time-frame) (arg4 vector) (arg5 vector))
  (set! (-> self mode) arg0)
  (set! (-> self first-time?) #t)
  (set! (-> self duration) arg3)
  (cond
    ((and arg1 (>= arg2 0))
     (set! (-> self track-joint) arg2)
     (set! (-> self track-handle) (process->handle arg1))
     )
    (else
      (set! (-> self track-joint) -1)
      (set! (-> self track-handle) (the-as handle #f))
      )
    )
  (cond
    (arg5
      (mem-copy! (the-as pointer (-> self danger)) (the-as pointer arg5) 54)
      (cond
        (arg4
          (set! (-> self sphere quad) (-> arg4 quad))
          (set! (-> self danger sphere quad) (-> arg4 quad))
          )
        (else
          (set! (-> self sphere quad) (-> self danger sphere quad))
          )
        )
      )
    (arg4
      (set! (-> self sphere quad) (-> arg4 quad))
      (when (logtest? (-> self mode) (fma-sphere-mode danger))
        (set! (-> self danger sphere quad) (-> arg4 quad))
        (set! (-> self danger velocity quad) (the-as uint128 0))
        (set! (-> self danger notify-radius) (+ 40960.0 (-> self sphere r)))
        (set! (-> self danger danger-level) 1.0)
        (set! (-> self danger decay-rate) 0.0)
        (set! (-> self danger flags) (traffic-danger-flags tdf0))
        (set! (-> self danger danger-type) (traffic-danger-type tdt4))
        )
      )
    (else
      (format 0 "ERROR: Initializing an fma-sphere without a sphere or danger info!~%")
      (go empty-state)
      )
    )
  (let ((gp-1 (new 'process 'collide-shape self (collide-list-enum hit-by-player))))
    (let ((v1-24 (new 'process 'collide-shape-prim-sphere gp-1 (the-as uint 0))))
      (set! (-> v1-24 prim-core collide-as) (collide-spec obstacle))
      (set-vector! (-> v1-24 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> gp-1 total-prims) (the-as uint 1))
      (set! (-> gp-1 root-prim) v1-24)
      )
    (set! (-> gp-1 nav-radius) (* 0.75 (-> gp-1 root-prim local-sphere w)))
    (let ((v1-27 (-> gp-1 root-prim)))
      (set! (-> gp-1 backup-collide-as) (-> v1-27 prim-core collide-as))
      (set! (-> gp-1 backup-collide-with) (-> v1-27 prim-core collide-with))
      )
    (set! (-> self root) gp-1)
    )
  (let ((gp-2 (-> self root)))
    (set! (-> gp-2 nav-radius) (-> self sphere r))
    (set! (-> gp-2 root-prim local-sphere w) (-> self sphere r))
    (set! (-> gp-2 trans quad) (-> self sphere quad))
    (set! (-> gp-2 trans w) 1.0)
    (vector-identity! (-> gp-2 scale))
    (quaternion-identity! (-> gp-2 quat))
    (cond
      ((logtest? (-> self mode) (fma-sphere-mode deadly-overlap))
       (set! (-> gp-2 event-self) 'touched)
       (let ((v1-35 (-> gp-2 root-prim)))
         (set! (-> v1-35 prim-core collide-with) (collide-spec crate civilian enemy hit-by-others-list))
         (logior! (-> v1-35 prim-core action) (collide-action deadly))
         )
       )
      (else
        (let ((v1-36 (-> gp-2 root-prim)))
          (set! (-> v1-36 prim-core collide-as) (collide-spec))
          (set! (-> v1-36 prim-core collide-with) (collide-spec))
          )
        0
        )
      )
    (update-transforms gp-2)
    )
  (logclear! (-> self mask) (process-mask actor-pause enemy))
  (when (logtest? (-> self mode) (fma-sphere-mode nav))
    (let ((a0-32 (find-nearest-nav-mesh (-> self root trans) (the-as float #x7f800000))))
      (cond
        (a0-32
          (add-process-drawable-to-navmesh a0-32 self #f)
          )
        (else
          (format 0 "ERROR: fma-sphere-init-by-other: failed to find nearest nav-mesh!~%")
          (go empty-state)
          )
        )
      )
    )
  (when (logtest? (-> self mode) (fma-sphere-mode deadly-overlap))
    (let* ((v1-53 *game-info*)
           (a0-35 (+ (-> v1-53 attack-id) 1))
           )
      (set! (-> v1-53 attack-id) a0-35)
      (set! (-> self attack-id) a0-35)
      )
    )
  (go-virtual idle)
  (none)
  )
