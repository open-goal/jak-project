;;-*-Lisp-*-
(in-package goal)

;; definition of type rigid-body-work
(deftype rigid-body-work (structure)
  ((max-ang-momentum float  :offset-assert   0)
   (max-ang-velocity float  :offset-assert   4)
   )
  :method-count-assert 9
  :size-assert         #x8
  :flag-assert         #x900000008
  )

;; definition for method 3 of type rigid-body-work
(defmethod inspect rigid-body-work ((obj rigid-body-work))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" obj 'rigid-body-work)
  (format #t "~1Tmax-ang-momentum: ~f~%" (-> obj max-ang-momentum))
  (format #t "~1Tmax-ang-velocity: ~f~%" (-> obj max-ang-velocity))
  (label cfg-4)
  obj
  )

;; definition for symbol *rigid-body-work*, type rigid-body-work
(define *rigid-body-work* (new 'static 'rigid-body-work))

;; definition for method 0 of type rigid-body-control
(defmethod new rigid-body-control ((allocation symbol) (type-to-make type) (arg0 process))
  (let ((v0-0 (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> v0-0 process) arg0)
    v0-0
    )
  )

;; definition for method 7 of type rigid-body-control
(defmethod relocate rigid-body-control ((obj rigid-body-control) (arg0 int))
  (&+! (-> obj process) arg0)
  obj
  )

;; definition for method 9 of type rigid-body-info
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-info-method-9 rigid-body-info ((obj rigid-body-info))
  (let ((f24-0 (-> obj mass))
        (f28-0 (-> obj inertial-tensor-box 0))
        (f30-0 (-> obj inertial-tensor-box 1))
        (f26-0 (-> obj inertial-tensor-box 2))
        )
    (let ((f0-0 f24-0))
      (set! (-> obj inv-mass) (/ 1.0 f0-0))
      )
    (matrix-identity! (-> obj inertial-tensor))
    (matrix-identity! (-> obj inv-inertial-tensor))
    (let ((f0-4 (* 0.083333336 f24-0)))
      (let* ((f1-1 f30-0)
             (f1-3 (* f1-1 f1-1))
             (f2-0 f26-0)
             )
        (set! (-> obj inertial-tensor vector 0 x) (* f0-4 (+ f1-3 (* f2-0 f2-0))))
        )
      (let ((f1-6 f28-0))
        (set! (-> obj inertial-tensor vector 1 y) (* f0-4 (+ (* f1-6 f1-6) (* f26-0 f26-0))))
        )
      (set! (-> obj inertial-tensor vector 2 z) (* f0-4 (+ (* f28-0 f28-0) (* f30-0 f30-0))))
      )
    )
  (let ((f0-6 (-> obj inertial-tensor vector 0 x)))
    (set! (-> obj inv-inertial-tensor vector 0 x) (/ 1.0 f0-6))
    )
  (let ((f0-9 (-> obj inertial-tensor vector 1 y)))
    (set! (-> obj inv-inertial-tensor vector 1 y) (/ 1.0 f0-9))
    )
  (let ((f0-12 (-> obj inertial-tensor vector 2 z)))
    (set! (-> obj inv-inertial-tensor vector 2 z) (/ 1.0 f0-12))
    )
  0
  (none)
  )

;; definition for method 16 of type rigid-body
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod clear-force-torque! rigid-body ((obj rigid-body))
  (set! (-> obj force quad) (the-as uint128 0))
  (set! (-> obj torque quad) (the-as uint128 0))
  0
  (none)
  )

;; definition for method 17 of type rigid-body
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod clear-momentum! rigid-body ((obj rigid-body))
  (set! (-> obj lin-momentum quad) (the-as uint128 0))
  (set! (-> obj ang-momentum quad) (the-as uint128 0))
  0
  (none)
  )

;; definition for method 24 of type rigid-body
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-method-24 rigid-body ((obj rigid-body))
  (when #t
    (quaternion->matrix (-> obj matrix) (-> obj rotation))
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (vector-rotate*! s5-0 (-> obj info cm-offset-joint) (-> obj matrix))
      (vector-! (-> obj matrix trans) (-> obj position) s5-0)
      )
    )
  0
  (none)
  )

;; definition for method 26 of type rigid-body
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-method-26 rigid-body ((obj rigid-body) (arg0 vector) (arg1 quaternion))
  (let ((s3-0 (new 'stack-no-clear 'inline-array 'vector 8)))
    (quaternion->matrix (the-as matrix (-> s3-0 1)) arg1)
    (vector-rotate*! (-> s3-0 0) (-> obj info cm-offset-joint) (the-as matrix (-> s3-0 1)))
    (vector+! (-> obj position) arg0 (-> s3-0 0))
    )
  (quaternion-copy! (-> obj rotation) arg1)
  (quaternion-normalize! (-> obj rotation))
  (rigid-body-method-24 obj)
  0
  (none)
  )

;; definition for method 25 of type rigid-body
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-method-25 rigid-body ((obj rigid-body) (arg0 rigid-body-info) (arg1 vector) (arg2 quaternion) (arg3 function))
  (set! (-> obj work) *rigid-body-work*)
  (set! (-> obj info) arg0)
  (set! (-> obj force-callback) (the-as (function object float none) arg3))
  (rigid-body-info-method-9 (-> obj info))
  (let ((v1-3 obj))
    (set! (-> v1-3 force quad) (the-as uint128 0))
    (set! (-> v1-3 torque quad) (the-as uint128 0))
    )
  0
  (clear-momentum! obj)
  (rigid-body-method-26 obj arg1 arg2)
  (rigid-body-method-13 obj)
  0
  (none)
  )

;; definition for method 22 of type rigid-body
(defmethod rigid-body-method-22 rigid-body ((obj rigid-body) (arg0 vector) (arg1 vector))
  (let ((v1-1 (vector-! (new 'stack-no-clear 'vector) arg0 (-> obj position))))
    (vector-cross! arg1 (-> obj ang-velocity) v1-1)
    )
  (vector+! arg1 arg1 (-> obj lin-velocity))
  arg1
  )

;; definition for function matrix-3x3-triple-transpose-product
;; INFO: Used lq/sq
(defun matrix-3x3-triple-transpose-product ((arg0 matrix) (arg1 matrix) (arg2 matrix))
  (let ((s5-0 (new 'stack-no-clear 'inline-array 'matrix 3)))
    (let* ((v1-0 (-> s5-0 0))
           (a3-0 arg1)
           (a0-1 (-> a3-0 quad 0))
           (a1-1 (-> a3-0 quad 1))
           (a2-1 (-> a3-0 quad 2))
           (a3-1 (-> a3-0 trans quad))
           )
      (set! (-> v1-0 quad 0) a0-1)
      (set! (-> v1-0 quad 1) a1-1)
      (set! (-> v1-0 quad 2) a2-1)
      (set! (-> v1-0 trans quad) a3-1)
      )
    (vector-reset! (-> s5-0 0 trans))
    (matrix-transpose! (-> s5-0 1) (-> s5-0 0))
    (matrix*! (-> s5-0 2) arg2 (-> s5-0 0))
    (matrix*! arg0 (-> s5-0 1) (-> s5-0 2))
    )
  arg0
  )

;; definition for method 12 of type rigid-body
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-method-12 rigid-body ((obj rigid-body) (arg0 float))
  (local-vars (v1-6 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((a2-0 (-> obj lin-momentum)))
      (let ((v1-0 (-> obj lin-momentum)))
        (let ((a0-1 (-> obj force)))
          (let ((a3-0 arg0))
            (.mov vf7 a3-0)
            )
          (.lvf vf5 (&-> a0-1 quad))
          )
        (.lvf vf4 (&-> v1-0 quad))
        )
      (.add.x.vf vf6 vf0 vf0 :mask #b1000)
      (.mul.x.vf acc vf5 vf7 :mask #b111)
      (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
      (.svf (&-> a2-0 quad) vf6)
      )
    (let ((a2-1 (-> obj ang-momentum)))
      (let ((v1-1 (-> obj ang-momentum)))
        (let ((a0-2 (-> obj torque)))
          (let ((a1-1 arg0))
            (.mov vf7 a1-1)
            )
          (.lvf vf5 (&-> a0-2 quad))
          )
        (.lvf vf4 (&-> v1-1 quad))
        )
      (.add.x.vf vf6 vf0 vf0 :mask #b1000)
      (.mul.x.vf acc vf5 vf7 :mask #b111)
      (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
      (.svf (&-> a2-1 quad) vf6)
      )
    (let* ((f0-3 (* 500000000.0 (-> obj info mass)))
           (f1-1 f0-3)
           (f1-3 (* f1-1 f1-1))
           )
      (.lvf vf1 (&-> (-> obj ang-momentum) quad))
      (.add.w.vf vf2 vf0 vf0 :mask #b1)
      (.mul.vf vf1 vf1 vf1)
      (.mul.x.vf acc vf2 vf1 :mask #b1)
      (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
      (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
      (.mov v1-6 vf1)
      (if (< f1-3 v1-6)
          (vector-normalize! (-> obj ang-momentum) f0-3)
          )
      )
    (set! (-> obj force quad) (the-as uint128 0))
    (set! (-> obj torque quad) (the-as uint128 0))
    0
    0
    (none)
    )
  )

;; definition for method 13 of type rigid-body
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-method-13 rigid-body ((obj rigid-body))
  (let ((v1-0 (-> obj info)))
    (vector-float*! (-> obj lin-velocity) (-> obj lin-momentum) (-> v1-0 inv-mass))
    (matrix-3x3-triple-transpose-product (-> obj inv-i-world) (-> obj matrix) (-> v1-0 inv-inertial-tensor))
    )
  (vector-rotate*! (-> obj ang-velocity) (-> obj ang-momentum) (-> obj inv-i-world))
  0
  (none)
  )

;; definition for method 14 of type rigid-body
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-method-14 rigid-body ((obj rigid-body) (arg0 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((a1-1 (-> obj position)))
      (let ((v1-0 (-> obj position)))
        (let ((a0-1 (-> obj lin-velocity)))
          (let ((a2-0 arg0))
            (.mov vf7 a2-0)
            )
          (.lvf vf5 (&-> a0-1 quad))
          )
        (.lvf vf4 (&-> v1-0 quad))
        )
      (.add.x.vf vf6 vf0 vf0 :mask #b1000)
      (.mul.x.vf acc vf5 vf7 :mask #b111)
      (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
      (.svf (&-> a1-1 quad) vf6)
      )
    (let ((s4-0 (new 'stack-no-clear 'quaternion)))
      (set! (-> (the-as vector (&-> s4-0 x)) quad) (-> obj ang-velocity quad))
      (set! (-> s4-0 w) 0.0)
      (quaternion*! s4-0 s4-0 (-> obj rotation))
      (quaternion-float*! s4-0 s4-0 0.5)
      (+! (-> obj rotation x) (* (-> s4-0 x) arg0))
      (+! (-> obj rotation y) (* (-> s4-0 y) arg0))
      (+! (-> obj rotation z) (* (-> s4-0 z) arg0))
      (+! (-> obj rotation w) (* (-> s4-0 w) arg0))
      )
    (quaternion-normalize! (-> obj rotation))
    (rigid-body-method-24 obj)
    0
    (none)
    )
  )

;; definition for function damping-time-adjust
(defun damping-time-adjust ((arg0 float) (arg1 float))
  (let ((f0-0 0.0)
        (f1-0 1.0)
        (f2-2 (* (+ -1.0 arg0) arg1))
        (f3-2 0.016666668)
        )
    (fmax f0-0 (+ f1-0 (* f2-2 (/ 1.0 f3-2))))
    )
  )

;; definition for method 9 of type rigid-body
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-method-9 rigid-body ((obj rigid-body) (arg0 collide-shape-moving) (arg1 float))
  (rigid-body-method-12 obj arg1)
  (let ((v1-2 (-> obj info)))
    (let* ((a0-2 (-> obj lin-momentum))
           (a1-2 (-> obj lin-momentum))
           (f3-0 (-> v1-2 linear-damping))
           (f2-0 arg1)
           (f0-0 0.0)
           (f1-0 1.0)
           (f2-1 (* (+ -1.0 f3-0) f2-0))
           (f3-2 0.016666668)
           )
      (vector-float*! a0-2 a1-2 (fmax f0-0 (+ f1-0 (* f2-1 (/ 1.0 f3-2)))))
      )
    (let* ((a0-4 (-> obj ang-momentum))
           (a1-3 (-> obj ang-momentum))
           (f3-5 (-> v1-2 angular-damping))
           (f2-3 arg1)
           (f0-3 0.0)
           (f1-2 1.0)
           (f2-4 (* (+ -1.0 f3-5) f2-3))
           (f3-7 0.016666668)
           )
      (vector-float*! a0-4 a1-3 (fmax f0-3 (+ f1-2 (* f2-4 (/ 1.0 f3-7)))))
      )
    )
  (rigid-body-method-13 obj)
  (if (logtest? (-> obj flags) (rigid-body-flag enable-collision))
      (collide-shape-moving-method-63 arg0 obj arg1)
      (rigid-body-method-14 obj arg1)
      )
  0
  (none)
  )

;; definition for method 67 of type collide-shape-moving
;; ERROR: function was not converted to expressions. Cannot decompile.

;; definition for function transform-rigid-body-prims
(defun transform-rigid-body-prims ((arg0 collide-shape-prim) (arg1 matrix))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         )
    (init-vf0-vector)
    (let ((v1-0 arg0)
          (a0-1 1)
          )
      (when (= (-> v1-0 prim-core prim-type) (prim-type group))
        (let ((a0-2 (the-as collide-shape-prim-group v1-0)))
          (set! v1-0 (-> a0-2 child 0))
          (set! a0-1 (the-as int (-> a0-2 num-children)))
          )
        )
      (while (nonzero? a0-1)
        (+! a0-1 -1)
        (.lvf vf5 (&-> v1-0 local-sphere quad))
        (.lvf vf1 (&-> arg1 quad 0))
        (.lvf vf2 (&-> arg1 quad 1))
        (.lvf vf3 (&-> arg1 quad 2))
        (.lvf vf4 (&-> arg1 trans quad))
        (.mul.x.vf acc vf1 vf5)
        (.add.mul.y.vf acc vf2 vf5 acc)
        (.add.mul.z.vf acc vf3 vf5 acc)
        (.add.mul.w.vf vf5 vf4 vf0 acc :mask #b111)
        (.svf (&-> v1-0 prim-core world-sphere quad) vf5)
        (&+! v1-0 80)
        )
      )
    #f
    )
  )

;; definition for method 63 of type collide-shape-moving
;; INFO: Used lq/sq
;; ERROR: failed type prop at 118: Could not figure out load: (set! v1 (l.wu v1))
;; WARN: Return type mismatch int vs none.
(defmethod collide-shape-moving-method-63 collide-shape-moving ((a0-0 collide-shape-moving) (a1-0 rigid-body) (a2-0 float))
  (local-vars
    (v0-0 quaternion)
    (v0-1 none)
    (v0-2 pointer)
    (v0-3 quaternion)
    (v0-4 none)
    (v0-5 symbol)
    (v0-6 none)
    (v0-7 none)
    (v0-8 none)
    (v0-9 symbol)
    (v0-10 none)
    (v0-11 none)
    (v0-12 none)
    (v0-13 symbol)
    (v0-14 pointer)
    (v0-15 none)
    (v0-16 none)
    (v0-17 none)
    (v0-18 none)
    (v0-19 none)
    (v0-20 none)
    (v0-21 none)
    (v0-22 none)
    (v0-23 none)
    (v0-24 none)
    (v0-25 none)
    (v0-26 none)
    (v0-27 none)
    (v0-28 none)
    (v0-29 none)
    (v0-30 none)
    (v0-31 none)
    (v0-32 none)
    (v0-33 none)
    (v0-34 none)
    (v0-35 none)
    (v0-36 int)
    (v1-0 int)
    (v1-1 int)
    (v1-2 vector)
    (v1-3 type)
    (v1-5 vector)
    (v1-6 type)
    (v1-8 type)
    (v1-10 symbol)
    (v1-11 type)
    (v1-13 type)
    (v1-15 type)
    (v1-17 type)
    (v1-19 type)
    (v1-21 float)
    (v1-22 uint)
    (v1-23 float)
    (v1-24 none)
    (v1-25 none)
    (v1-26 none)
    (v1-27 none)
    (v1-28 none)
    (v1-29 none)
    (v1-30 none)
    (v1-31 none)
    (v1-32 none)
    (v1-33 none)
    (v1-34 none)
    (v1-37 none)
    (v1-38 none)
    (v1-39 none)
    (v1-41 none)
    (v1-42 none)
    (v1-44 none)
    (v1-46 none)
    (v1-47 none)
    (v1-48 none)
    (v1-49 none)
    (v1-50 none)
    (v1-51 none)
    (v1-52 none)
    (v1-53 none)
    (v1-54 none)
    (v1-55 none)
    (v1-56 none)
    (v1-57 none)
    (v1-58 none)
    (v1-59 none)
    (v1-60 none)
    (v1-61 none)
    (v1-62 none)
    (v1-63 none)
    (v1-64 none)
    (v1-65 none)
    (v1-68 none)
    (v1-70 none)
    (v1-71 none)
    (v1-72 none)
    (v1-74 none)
    (v1-76 none)
    (v1-77 none)
    (v1-78 none)
    (v1-79 none)
    (v1-80 none)
    (v1-81 none)
    (v1-82 none)
    (v1-83 none)
    (v1-84 none)
    (v1-87 none)
    (v1-88 none)
    (v1-89 none)
    (v1-91 none)
    (v1-93 none)
    (v1-95 none)
    (v1-97 none)
    (v1-98 none)
    (v1-99 none)
    (v1-102 none)
    (v1-103 none)
    (v1-104 none)
    (v1-105 none)
    (v1-106 none)
    (v1-107 none)
    (v1-109 none)
    (v1-110 none)
    (v1-112 none)
    (v1-114 none)
    (v1-115 none)
    (v1-116 none)
    (v1-117 none)
    (v1-118 none)
    (v1-119 none)
    (v1-120 none)
    (v1-121 none)
    (v1-122 none)
    (v1-124 none)
    (v1-125 none)
    (v1-126 none)
    (v1-127 none)
    (v1-128 none)
    (v1-129 none)
    (v1-131 none)
    (v1-132 none)
    (v1-133 none)
    (v1-134 none)
    (v1-135 none)
    (v1-136 none)
    (v1-137 none)
    (v1-138 none)
    (v1-140 none)
    (v1-142 none)
    (v1-144 none)
    (v1-147 int)
    (a0-1 vector)
    (a0-2 uint128)
    (a0-3 vector)
    (a0-4 rigid-body)
    (a0-5 vector)
    (a0-6 vector)
    (a0-7 uint128)
    (a0-8 quaternion)
    (a0-9 rigid-body)
    (a0-10 collide-shape-prim)
    (a0-11 collide-shape-moving)
    (a0-12 rigid-body)
    (a0-13 rigid-body)
    (a0-14 collide-shape-prim)
    (a0-15 touching-list)
    (a0-16 rigid-body)
    (a0-17 rigid-body)
    (a0-18 collide-shape-prim)
    (a0-19 vector)
    (a0-20 none)
    (a0-21 none)
    (a0-25 none)
    (a0-26 none)
    (a0-27 none)
    (a0-28 none)
    (a0-29 none)
    (a0-30 none)
    (a0-31 none)
    (a0-32 none)
    (a0-33 none)
    (a0-34 none)
    (a0-35 none)
    (a0-36 none)
    (a0-37 none)
    (a0-38 none)
    (a0-39 none)
    (a0-40 none)
    (a0-41 none)
    (a0-43 none)
    (a0-47 none)
    (a0-49 none)
    (a0-50 none)
    (a0-51 none)
    (a0-54 none)
    (a0-55 none)
    (a0-56 none)
    (a0-57 none)
    (a0-58 none)
    (a0-59 none)
    (a0-60 none)
    (a0-64 none)
    (a1-1 quaternion)
    (a1-2 float)
    (a1-3 matrix)
    (a1-4 vector)
    (a1-5 matrix)
    (a1-6 vector)
    (a1-7 float)
    (a1-8 matrix)
    (a1-9 float)
    (a1-10 float)
    (a1-11 matrix)
    (a1-12 matrix)
    (a1-13 none)
    (a1-14 none)
    (a1-15 none)
    (a1-16 none)
    (a1-17 none)
    (a1-18 none)
    (a1-19 none)
    (a1-20 none)
    (a1-21 none)
    (a1-22 none)
    (a1-23 none)
    (a1-24 none)
    (a1-25 none)
    (a1-26 none)
    (a1-27 none)
    (a1-28 none)
    (a1-29 none)
    (a1-30 none)
    (a1-31 none)
    (a1-32 none)
    (a1-33 none)
    (a1-34 none)
    (a1-35 none)
    (a1-36 none)
    (a1-37 none)
    (a1-38 none)
    (a1-39 none)
    (a1-42 none)
    (a1-43 none)
    (a1-44 none)
    (a1-45 none)
    (a1-46 none)
    (a1-47 none)
    (a1-48 none)
    (a1-50 none)
    (a2-1 int)
    (a2-2 vector)
    (a2-3 int)
    (a2-4 none)
    (a2-5 none)
    (a2-6 none)
    (a2-7 none)
    (a2-8 none)
    (a2-9 none)
    (a2-10 none)
    (a2-11 none)
    (a2-12 none)
    (s2-0 none)
    (s3-0 symbol)
    (s5-0 (inline-array vector))
    (t9-0 (function quaternion quaternion quaternion))
    (t9-1 (function rigid-body float none))
    (t9-2 (function pointer pointer int pointer))
    (t9-3 (function quaternion quaternion quaternion))
    (t9-4 (function rigid-body none))
    (t9-5 (function collide-shape-prim matrix symbol))
    (t9-6 (function none))
    (t9-7 (function rigid-body float none))
    (t9-8 (function rigid-body none))
    (t9-9 (function collide-shape-prim matrix symbol))
    (t9-10 (function touching-list float none))
    (t9-11 (function rigid-body float none))
    (t9-12 (function rigid-body none))
    (t9-13 (function collide-shape-prim matrix symbol))
    (t9-14 (function pointer pointer int pointer))
    (t9-15 none)
    (t9-16 none)
    (t9-17 none)
    (t9-18 none)
    (t9-19 none)
    (t9-20 none)
    (t9-21 none)
    (t9-22 none)
    (t9-23 none)
    (t9-24 none)
    (t9-25 none)
    (t9-26 none)
    (t9-27 none)
    (t9-28 none)
    (t9-29 none)
    (t9-30 none)
    (t9-31 none)
    (t9-32 none)
    (t9-33 none)
    (t9-34 none)
    (t9-35 none)
    (sp-0 none)
    (f0-0 float)
    (f0-1 float)
    (f0-2 float)
    (f0-3 float)
    (f0-4 float)
    (f0-5 float)
    (f0-6 float)
    (f0-7 float)
    (f0-8 float)
    (f0-9 float)
    (f0-10 float)
    (f0-11 float)
    (f0-12 none)
    (f0-13 none)
    (f0-14 none)
    (f0-15 none)
    (f0-16 none)
    (f0-17 none)
    (f0-18 none)
    (f0-19 none)
    (f0-20 none)
    (f0-21 none)
    (f0-22 none)
    (f0-23 none)
    (f0-24 none)
    (f0-25 none)
    (f0-26 none)
    (f0-27 none)
    (f0-28 none)
    (f0-29 none)
    (f0-30 none)
    (f0-31 none)
    (f0-32 none)
    (f0-33 none)
    (f0-34 none)
    (f0-35 none)
    (f0-36 none)
    (f0-37 none)
    (f0-38 none)
    (f0-39 none)
    (f0-40 none)
    (f0-41 none)
    (f0-42 none)
    (f0-43 none)
    (f0-44 none)
    (f0-45 float)
    (f0-46 float)
    (f0-47 float)
    (f0-48 float)
    (f1-0 float)
    (f1-1 float)
    (f1-2 float)
    (f1-3 none)
    (f1-4 none)
    (f1-5 none)
    (f1-6 none)
    (f1-7 none)
    (f1-8 none)
    (f1-9 none)
    (f1-10 none)
    (f1-11 none)
    (f1-12 none)
    (f1-13 none)
    (f1-14 none)
    (f1-15 none)
    (f1-16 none)
    (f1-17 none)
    (f1-18 none)
    (f1-19 none)
    (f1-20 none)
    (f1-21 none)
    (f1-22 none)
    (f1-23 none)
    (f1-24 float)
    (f1-25 float)
    (f1-26 float)
    (f2-0 none)
    (f2-1 none)
    (f2-2 none)
    (f2-3 none)
    (f2-4 none)
    (f2-5 none)
    (f3-0 none)
    (f30-0 float)
    (f30-1 none)
    (f30-2 none)
    (f30-3 none)
    )
  (with-pp
    (rlet ((acc :class vf)
           (Q :class vf)
           (vf0 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           (vf8 :class vf)
           (vf9 :class vf)
           )
      (init-vf0-vector)
      (set! s5-0 (new 'stack-no-clear 'inline-array 'vector 51))
      (set! f0-0 (gpr->fpr a2-0))
      (set! (-> s5-0 49 z) f0-0)
      (set! v1-0 #x3f800000)
      (set! f0-1 (the-as float (gpr->fpr v1-0)))
      (set! (-> s5-0 49 w) f0-1)
      (s.b! (+ s5-0 800) 0)
      (until (begin
               (set! v1-1 -859915232)
               (set! f0-2 (the-as float (gpr->fpr v1-1)))
               (set! (-> s5-0 7 x) f0-2)
               (set! (-> s5-0 7 z) (the-as float #f))
               (set! (-> s5-0 7 y) (the-as float #f))
               (set! v1-2 (-> s5-0 42))
               (set! a0-1 (-> a1-0 position))
               (set! a0-2 (-> a0-1 quad))
               (set! (-> v1-2 quad) a0-2)
               (set! t9-0 quaternion-copy!)
               (set! a0-3 (-> s5-0 43))
               (set! a1-1 (-> a1-0 rotation))
               (call! a0-3 a1-1)
               (set! a0-4 a1-0)
               (set! v1-3 rigid-body)
               (set! t9-1 (method-of-type v1-3 rigid-body-method-14))
               (set! f0-3 (-> s5-0 49 w))
               (set! f1-0 (-> s5-0 49 z))
               (set! f0-4 (*.s f0-3 f1-0))
               (set! a1-2 (fpr->gpr f0-4))
               (call! a0-4 a1-2)
               (set! v1-4 v0-1)
               (set! t9-2 mem-copy!)
               (set! a0-5 (-> s5-0 34))
               (set! a1-3 (-> a1-0 matrix))
               (set! a2-1 64)
               (call! a0-5 a1-3 a2-1)
               (set! v1-5 (-> a1-0 position))
               (set! a0-6 (-> s5-0 42))
               (set! a0-7 (-> a0-6 quad))
               (set! (-> v1-5 quad) a0-7)
               (set! t9-3 quaternion-copy!)
               (set! a0-8 (-> a1-0 rotation))
               (set! a1-4 (-> s5-0 43))
               (call! a0-8 a1-4)
               (set! a0-9 a1-0)
               (set! v1-6 rigid-body)
               (set! t9-4 (method-of-type v1-6 rigid-body-method-24))
               (call! a0-9)
               (set! v1-7 v0-4)
               (set! t9-5 transform-rigid-body-prims)
               (set! a0-10 (-> a0-0 root-prim))
               (set! a1-5 (-> a1-0 matrix))
               (call! a0-10 a1-5)
               (set! a0-11 a0-0)
               (set! v1-8 (-> a0-11 type))
               (set! t9-6 (method-of-type v1-8 collide-shape-moving-method-67))
               (set! a1-6 (-> s5-0 34))
               (set! a2-2 (-> s5-0 0))
               (call!)
               (set! v1-9 v0-6)
               (set! f30-0 (-> s5-0 7 x))
               (set! f0-5 (the-as float 0))
               (b! (>=.s f30-0 f0-5) L106 (set! v1-10 #f))
               (set! a0-12 a1-0)
               (set! v1-11 rigid-body)
               (set! t9-7 (method-of-type v1-11 rigid-body-method-14))
               (set! f0-6 (-> s5-0 49 w))
               (set! f1-1 (-> s5-0 49 z))
               (set! f0-7 (*.s f0-6 f1-1))
               (set! a1-7 (fpr->gpr f0-7))
               (call! a0-12 a1-7)
               (set! v1-12 v0-7)
               (set! a0-13 a1-0)
               (set! v1-13 rigid-body)
               (set! t9-8 (method-of-type v1-13 rigid-body-method-13))
               (call! a0-13)
               (set! v1-14 v0-8)
               (set! t9-9 transform-rigid-body-prims)
               (set! a0-14 (-> a0-0 root-prim))
               (set! a1-8 (-> a1-0 matrix))
               (call! a0-14 a1-8)
               (set! f0-8 (the-as float 0))
               (set! (-> s5-0 49 w) f0-8)
               ((b! #t L126 (nop!)) (nop!))
               (label cfg-3)
               (set! a0-15 *touching-list*)
               (set! v1-15 touching-list)
               (set! t9-10 (method-of-type v1-15 update-from-step-size))
               (set! a1-9 (fpr->gpr f30-0))
               (call! a0-15 a1-9)
               (set! v1-16 v0-10)
               (set! a0-16 a1-0)
               (set! v1-17 rigid-body)
               (set! t9-11 (method-of-type v1-17 rigid-body-method-14))
               (set! f0-9 (-> s5-0 49 w))
               (set! f1-2 (-> s5-0 49 z))
               (set! f0-10 (*.s f0-9 f1-2))
               (set! f0-11 (*.s f0-10 f30-0))
               (set! a1-10 (fpr->gpr f0-11))
               (call! a0-16 a1-10)
               (set! v1-18 v0-11)
               (set! a0-17 a1-0)
               (set! v1-19 rigid-body)
               (set! t9-12 (method-of-type v1-19 rigid-body-method-13))
               (call! a0-17)
               (set! v1-20 v0-12)
               (set! t9-13 transform-rigid-body-prims)
               (set! a0-18 (-> a0-0 root-prim))
               (set! a1-11 (-> a1-0 matrix))
               (call! a0-18 a1-11)
               (set! t9-14 mem-copy!)
               (set! a0-19 (-> s5-0 34))
               (set! a1-12 (-> a1-0 matrix))
               (set! a2-3 64)
               (call! a0-19 a1-12 a2-3)
               (set! s3-0 #f)
               (set! v1-21 (-> s5-0 7 y))
               ((b! (not v1-21) L110 (set! v1-22 #f)) (empty-form))
               (set! v1-23 (-> s5-0 7 y))
               (set! v1-24 (the-as none (l.wu v1-23)))
               (set! a0-20 (the-as none (l.wu (+ v1-24 136))))
               (set! v1-25 (the-as none (l.wu (+ a0-20 180))))
               ((b! (zero? v1-25) L110 (set! v1-26 #f)) (empty-form))
               (set! v1-27 (the-as none (l.wu (+ a0-20 180))))
               (set! s3-0 (the-as symbol (+ v1-27 12)))
               (set! v1-28 (the-as none (l.wu (+ s3-0 8))))
               (set! v1-29 (the-as none (logand v1-28 8)))
               ((b! (zero? v1-29) L109 (nop!)) (nop!))
               (set! v1-30 (the-as none (l.wu (+ s3-0 8))))
               (set! v1-31 (the-as none (logand v1-30 2)))
               ((b! (nonzero? v1-31) L108 (set! v1-32 #f)) (empty-form))
               (if (begin (set! a1-13 (the-as none (+ sp-0 832))) (set! v1-33 (the-as none s6-0)) v1-33)
                   (set! a2-4 (the-as none (l.wu (+ v1-33 24))))
                   )
               (s.w! (+ a1-13 8) a2-4)
               (s.w! (+ a1-13 68) 0)
               (set! v1-34 (the-as none 'enable-physics))
               (s.w! (+ a1-13 64) v1-34)
               (set! t9-15 (the-as none send-event-function))
               (call!)
               (set! v1-35 (the-as none v0-15))
               (label cfg-10)
               ((b! #t L110 (nop!)) (nop!))
               (label cfg-11)
               (set! s3-0 (the-as symbol #f))
               (set! v1-36 (the-as none s3-0))
               (label cfg-12)
               (set! v1-37 (the-as none (-> s5-0 7 z)))
               (set! a0-21 (the-as none (-> s5-0 0)))
               (.lvf vf7 (+ a0-21 48))
               (.lvf vf6 (+ v1-37 12))
               (.sub.vf vf8 vf6 vf7)
               (.mul.vf vf9 vf8 vf8 :mask #b111)
               (.mul.x.vf acc vf0 vf9 :mask #b1000)
               (.add.mul.y.vf acc vf0 vf9 acc :mask #b1000)
               (.add.mul.z.vf vf9 vf0 vf9 acc :mask #b1000)
               (.isqrt.vf Q vf0 vf9 :fsf #b11 :ftf #b11)
               (.mov.vf vf8 vf0 :mask #b1000)
               (.wait.vf)
               (.mul.vf vf8 vf8 Q :mask #b111)
               (.nop.vf)
               (.nop.vf)
               (.nop.vf)
               (.svf (&-> s5-0 39 quad) vf8)
               (.svf (&-> s5-0 38 quad) vf7)
               (set! v1-38 (the-as none (l.wu (+ v1-37 4))))
               (set! (-> s5-0 41 w) (the-as float v1-38))
               (set! a0-22 (the-as none a1-0))
               (set! v1-39 (the-as none rigid-body))
               (set! t9-16 (the-as none (l.wu (+ v1-39 104))))
               (set! a1-14 (the-as none (-> s5-0 38)))
               (set! a2-5 (the-as none (-> s5-0 40)))
               (call!)
               (set! v1-40 (the-as none v0-16))
               ((b! (not s3-0) L111 (set! v1-41 #f)) (empty-form))
               (set! a0-23 (the-as none s3-0))
               (set! v1-42 (the-as none rigid-body))
               (set! t9-17 (the-as none (l.wu (+ v1-42 68))))
               (call!)
               (set! v1-43 (the-as none v0-17))
               (set! a0-24 (the-as none s3-0))
               (set! v1-44 (the-as none rigid-body))
               (set! t9-18 (the-as none (l.wu (+ v1-44 104))))
               (set! a1-15 (the-as none (+ s5-0 608)))
               (set! a2-6 (the-as none (+ s5-0 720)))
               (call!)
               (set! v1-45 (the-as none v0-18))
               (set! a1-16 (the-as none (+ s5-0 640)))
               (set! v1-46 (the-as none (+ s5-0 640)))
               (set! a0-25 (the-as none (+ s5-0 720)))
               (set! a1-17 (the-as none (vector-!2 a1-16 v1-46 a0-25)))
               (label cfg-14)
               (set! f0-12 (the-as none 0))
               (s.f! (+ s5-0 656) f0-12)
               (set! v1-47 (the-as none -1009988403))
               (set! f0-13 (the-as none (gpr->fpr v1-47)))
               (set! a0-26 (the-as none (+ s5-0 640)))
               (set! v1-48 (the-as none (+ s5-0 624)))
               (set! f1-3 (the-as none (vec3dot a0-26 v1-48)))
               (set! v1-49 (the-as none (fpr->gpr f1-3)))
               (set! f1-4 (the-as none (gpr->fpr v1-49)))
               (set! f0-14 (the-as none (+.s f0-13 f1-4)))
               (s.f! (+ s5-0 784) f0-14)
               (set! f0-15 (the-as none 0))
               (s.f! (+ s5-0 788) f0-15)
               (set! f0-16 (the-as none (l.f (+ s5-0 784))))
               (set! f1-5 (the-as none 0))
               (b! (>=.s f0-16 f1-5) L123 (nop!))
               (if (begin
                     (when (begin
                             (when (begin
                                     (cond
                                       ((begin
                                          (set! a1-18 (the-as none (+ s5-0 736)))
                                          (set! v1-50 (the-as none (+ s5-0 608)))
                                          (set! a0-27 (the-as none (+ a1-0 32)))
                                          (set! a1-19 (the-as none (vector-!2 a1-18 v1-50 a0-27)))
                                          (set! a1-20 (the-as none (+ s5-0 752)))
                                          (set! v1-51 (the-as none (+ s5-0 736)))
                                          (set! a0-28 (the-as none (+ s5-0 624)))
                                          (set! a1-21 (the-as none (veccross a1-20 v1-51 a0-28)))
                                          (set! t9-19 (the-as none vector-rotate*!))
                                          (set! a0-29 (the-as none (+ s5-0 752)))
                                          (set! a1-22 (the-as none (+ s5-0 752)))
                                          (set! a2-7 (the-as none (+ a1-0 224)))
                                          (call!)
                                          (set! a1-23 (the-as none (+ s5-0 752)))
                                          (set! v1-52 (the-as none (+ s5-0 752)))
                                          (set! a0-30 (the-as none (+ s5-0 736)))
                                          (set! a1-24 (the-as none (veccross a1-23 v1-52 a0-30)))
                                          (set! v1-53 (the-as none (l.wu (+ a1-0 4))))
                                          (set! f0-17 (the-as none (l.f (+ v1-53 4))))
                                          (set! a0-31 (the-as none (+ s5-0 624)))
                                          (set! v1-54 (the-as none (+ s5-0 752)))
                                          (set! f1-6 (the-as none (vec3dot a0-31 v1-54)))
                                          (set! v1-55 (the-as none (fpr->gpr f1-6)))
                                          (set! f1-7 (the-as none (gpr->fpr v1-55)))
                                          (set! f0-18 (the-as none (+.s f0-17 f1-7)))
                                          (s.f! (+ s5-0 788) f0-18)
                                          (set! v1-56 (the-as none (l.wu (+ a1-0 4))))
                                          (set! f30-1 (the-as none (l.f (+ v1-56 16))))
                                          s3-0
                                          )
                                        (set! a1-25 (the-as none (+ s5-0 736)))
                                        (set! v1-57 (the-as none (+ s5-0 608)))
                                        (set! a0-32 (the-as none (+ s3-0 32)))
                                        (set! a1-26 (the-as none (vector-!2 a1-25 v1-57 a0-32)))
                                        (set! a1-27 (the-as none (+ s5-0 752)))
                                        (set! v1-58 (the-as none (+ s5-0 736)))
                                        (set! a0-33 (the-as none (+ s5-0 624)))
                                        (set! a1-28 (the-as none (veccross a1-27 v1-58 a0-33)))
                                        (set! t9-20 (the-as none vector-rotate*!))
                                        (set! a0-34 (the-as none (+ s5-0 752)))
                                        (set! a1-29 (the-as none (+ s5-0 752)))
                                        (set! a2-8 (the-as none (+ s3-0 224)))
                                        (call!)
                                        (set! a1-30 (the-as none (+ s5-0 752)))
                                        (set! v1-59 (the-as none (+ s5-0 752)))
                                        (set! a0-35 (the-as none (+ s5-0 736)))
                                        (set! a1-31 (the-as none (veccross a1-30 v1-59 a0-35)))
                                        (set! f0-19 (the-as none (l.f (+ s5-0 788))))
                                        (set! v1-60 (the-as none (l.wu (+ s3-0 4))))
                                        (set! f1-8 (the-as none (l.f (+ v1-60 4))))
                                        (set! a0-36 (the-as none (+ s5-0 624)))
                                        (set! v1-61 (the-as none (+ s5-0 752)))
                                        (set! f2-0 (the-as none (vec3dot a0-36 v1-61)))
                                        (set! v1-62 (the-as none (fpr->gpr f2-0)))
                                        (set! f2-1 (the-as none (gpr->fpr v1-62)))
                                        (set! f1-9 (the-as none (+.s f1-8 f2-1)))
                                        (set! f0-20 (the-as none (+.s f0-19 f1-9)))
                                        (s.f! (+ s5-0 788) f0-20)
                                        (set! v1-63 (the-as none (l.wu (+ s3-0 4))))
                                        (set! f0-21 (the-as none (l.f (+ v1-63 16))))
                                        (set! f0-22 (the-as none (max.s f30-1 f0-21)))
                                        (set! v1-64 (the-as none (l.wu (+ a1-0 4))))
                                        (set! f1-10 (the-as none (l.f (+ v1-64 24))))
                                        (set! v1-65 (the-as none (l.wu (+ s3-0 4))))
                                        (set! f2-2 (the-as none (l.f (+ v1-65 24))))
                                        (set! f1-11 (the-as none (*.s f1-10 f2-2)))
                                        (set! f30-1 (the-as none (max.s f0-22 f1-11)))
                                        (set! v1-66 (the-as none (fpr->gpr f30-1)))
                                        )
                                       (else
                                         )
                                       )
                                     (set! v1-68 (the-as none #x3f800000))
                                     (set! f0-23 (the-as none (gpr->fpr v1-68)))
                                     (set! f0-24 (the-as none (+.s f0-23 f30-1)))
                                     (set! f1-12 (the-as none (l.f (+ s5-0 784))))
                                     (set! f1-13 (the-as none (neg.s f1-12)))
                                     (set! f2-3 (the-as none (l.f (+ s5-0 788))))
                                     (set! f1-14 (the-as none (/.s f1-13 f2-3)))
                                     (set! f0-25 (the-as none (*.s f0-24 f1-14)))
                                     (s.f! (+ s5-0 656) f0-25)
                                     (set! v1-69 (the-as none (fpr->gpr f0-25)))
                                     (set! v1-70 (the-as none (+ s5-0 704)))
                                     (set! a0-37 (the-as none (+ s5-0 624)))
                                     (set! f0-26 (the-as none (l.f (+ s5-0 656))))
                                     (set! v1-71 (the-as none (vector-float*!2 v1-70 a0-37 f0-26)))
                                     (set! v1-72 (the-as none (l.wu (+ a1-0 4))))
                                     (set! f30-2 (the-as none (l.f v1-72)))
                                     s3-0
                                     )
                               (set! v1-74 (the-as none (l.wu (+ s3-0 4))))
                               (set! f0-27 (the-as none (l.f v1-74)))
                               (set! f30-2 (the-as none (min.s f30-2 f0-27)))
                               (set! v1-75 (the-as none (fpr->gpr f30-2)))
                               )
                             (when (begin
                                     (set! v1-76 (the-as none (+ s5-0 768)))
                                     (set! a0-38 (the-as none (+ s5-0 640)))
                                     (set! a1-32 (the-as none (+ s5-0 624)))
                                     (set! f0-28 (the-as none (l.f (+ s5-0 784))))
                                     (set! f0-29 (the-as none (neg.s f0-28)))
                                     (set! v1-77 (the-as none (vecplusfloattimes v1-76 a0-38 a1-32 f0-29)))
                                     (set! t9-21 (the-as none vector-normalize!))
                                     (set! a0-39 (the-as none (+ s5-0 768)))
                                     (set! a1-33 (the-as none #x3f800000))
                                     (call!)
                                     (set! v1-78 (the-as none -1082130432))
                                     (set! f0-30 (the-as none (gpr->fpr v1-78)))
                                     (set! a0-40 (the-as none (+ s5-0 768)))
                                     (set! v1-79 (the-as none (+ s5-0 640)))
                                     (set! f1-15 (the-as none (vec3dot a0-40 v1-79)))
                                     (set! v1-80 (the-as none (fpr->gpr f1-15)))
                                     (set! f1-16 (the-as none (gpr->fpr v1-80)))
                                     (set! f1-17 (the-as none (*.s f1-16 f30-2)))
                                     (set! v1-81 (the-as none (l.wu (+ a1-0 4))))
                                     (set! f2-4 (the-as none (l.f (+ v1-81 20))))
                                     (set! f3-0 (the-as none (l.f (+ s5-0 656))))
                                     (set! f2-5 (the-as none (*.s f2-4 f3-0)))
                                     (set! f1-18 (the-as none (min.s f1-17 f2-5)))
                                     (set! f0-31 (the-as none (*.s f0-30 f1-18)))
                                     (set! v1-82 (the-as none (+ s5-0 704)))
                                     (set! a0-41 (the-as none (+ s5-0 704)))
                                     (set! a1-34 (the-as none (+ s5-0 768)))
                                     (set! v1-83 (the-as none (vecplusfloattimes v1-82 a0-41 a1-34 f0-31)))
                                     (set! a0-42 (the-as none a1-0))
                                     (set! v1-84 (the-as none rigid-body))
                                     (set! t9-22 (the-as none (l.wu (+ v1-84 88))))
                                     (set! a1-35 (the-as none (+ s5-0 608)))
                                     (set! a2-9 (the-as none (+ s5-0 704)))
                                     (call!)
                                     (set! v1-85 (the-as none v0-22))
                                     s3-0
                                     )
                               (set! v1-87 (the-as none (+ s5-0 704)))
                               (set! a0-43 (the-as none (+ s5-0 704)))
                               (set! a1-36 (the-as none -1082130432))
                               (set! f0-32 (the-as none (gpr->fpr a1-36)))
                               (set! v1-88 (the-as none (vector-float*!2 v1-87 a0-43 f0-32)))
                               (set! a0-44 (the-as none s3-0))
                               (set! v1-89 (the-as none rigid-body))
                               (set! t9-23 (the-as none (l.wu (+ v1-89 88))))
                               (set! a1-37 (the-as none (+ s5-0 608)))
                               (set! a2-10 (the-as none (+ s5-0 704)))
                               (call!)
                               (set! v1-90 (the-as none v0-23))
                               )
                             (set! a0-45 (the-as none a1-0))
                             (set! v1-91 (the-as none rigid-body))
                             (set! t9-24 (the-as none (l.wu (+ v1-91 64))))
                             (set! a1-38 (the-as none #x3f800000))
                             (call!)
                             (set! v1-92 (the-as none v0-24))
                             (set! a0-46 (the-as none a1-0))
                             (set! v1-93 (the-as none rigid-body))
                             (set! t9-25 (the-as none (l.wu (+ v1-93 68))))
                             (call!)
                             (set! v1-94 (the-as none v0-25))
                             (set! f30-3 (the-as none (l.f (+ s5-0 112))))
                             (set! v1-95 (the-as none #x38d1b717))
                             (set! f0-33 (the-as none (gpr->fpr v1-95)))
                             (<.s f30-3 f0-33)
                             )
                       (set! v1-97 (the-as none (+ a1-0 32)))
                       (set! a0-47 (the-as none (+ a1-0 32)))
                       (set! a1-39 (the-as none (+ s5-0 624)))
                       (set! a2-11 (the-as none #x4223d70a))
                       (set! f0-34 (the-as none (gpr->fpr a2-11)))
                       (set! v1-98 (the-as none (vecplusfloattimes v1-97 a0-47 a1-39 f0-34)))
                       (set! a0-48 (the-as none a1-0))
                       (set! v1-99 (the-as none rigid-body))
                       (set! t9-26 (the-as none (l.wu (+ v1-99 112))))
                       (call!)
                       (set! v1-100 (the-as none v0-26))
                       )
                     (when (begin
                             (set! f0-35 (the-as none (l.f (+ s5-0 796))))
                             (set! f1-19 (the-as none (l.f (+ s5-0 796))))
                             (set! f1-20 (the-as none (*.s f30-3 f1-19)))
                             (set! f0-36 (the-as none (-.s f0-35 f1-20)))
                             (s.f! (+ s5-0 796) f0-36)
                             (set! v1-101 (the-as none (fpr->gpr f0-36)))
                             (set! v1-102 (the-as none (l.wu (+ s5-0 80))))
                             (s.w! (+ s5-0 660) v1-102)
                             (set! v1-103 (the-as none s6-0))
                             (set! a0-49 (the-as none (l.wu (+ s5-0 116))))
                             a0-49
                             )
                       (set! v1-104 (the-as none (l.wu a0-49)))
                       (set! v1-103 (the-as none (l.wu (+ v1-104 136))))
                       (set! a1-41 (the-as none v1-103))
                       )
                     (s.w! (+ s5-0 664) s3-0)
                     (set! a1-42 (the-as none (+ sp-0 832)))
                     v1-103
                     )
                   (set! a0-50 (the-as none (l.wu (+ v1-103 24))))
                   )
               (s.w! (+ a1-42 8) a0-50)
               (set! v1-105 (the-as none 1))
               (s.w! (+ a1-42 68) v1-105)
               (set! v1-106 (the-as none 'impact-impulse))
               (s.w! (+ a1-42 64) v1-106)
               (set! v1-107 (the-as none (+ s5-0 608)))
               (s.d! (+ a1-42 16) v1-107)
               (set! t9-27 (the-as none send-event-function))
               (set! a0-51 (the-as none (l.wu (+ a0-0 136))))
               (call!)
               (set! v1-108 (the-as none v0-27))
               ((b! (not s3-0) L120 (set! v1-109 #f)) (empty-form))
               (if (begin
                     (set! a0-52 (the-as none s3-0))
                     (set! v1-110 (the-as none rigid-body))
                     (set! t9-28 (the-as none (l.wu (+ v1-110 64))))
                     (set! a1-43 (the-as none #x3f800000))
                     (call!)
                     (set! v1-111 (the-as none v0-28))
                     (set! a0-53 (the-as none s3-0))
                     (set! v1-112 (the-as none rigid-body))
                     (set! t9-29 (the-as none (l.wu (+ v1-112 68))))
                     (call!)
                     (set! v1-113 (the-as none v0-29))
                     (set! v1-114 (the-as none (l.wu (+ s5-0 116))))
                     (set! s2-0 (the-as none (l.wu v1-114)))
                     (set! t9-30 (the-as none transform-rigid-body-prims))
                     (set! a0-54 (the-as none (l.wu (+ s2-0 156))))
                     (set! a1-44 (the-as none (+ s3-0 160)))
                     (call!)
                     (set! v1-115 (the-as none (+ s5-0 624)))
                     (set! a0-55 (the-as none (+ s5-0 624)))
                     (set! a1-45 (the-as none -1082130432))
                     (set! f0-37 (the-as none (gpr->fpr a1-45)))
                     (set! v1-116 (the-as none (vector-float*!2 v1-115 a0-55 f0-37)))
                     (set! v1-117 (the-as none (+ s5-0 640)))
                     (set! a0-56 (the-as none (+ s5-0 640)))
                     (set! a1-46 (the-as none -1082130432))
                     (set! f0-38 (the-as none (gpr->fpr a1-46)))
                     (set! v1-118 (the-as none (vector-float*!2 v1-117 a0-56 f0-38)))
                     (s.w! (+ s5-0 664) a1-0)
                     (set! a1-47 (the-as none (+ sp-0 832)))
                     (set! v1-119 (the-as none (l.wu (+ a0-0 136))))
                     v1-119
                     )
                   (set! a0-57 (the-as none (l.wu (+ v1-119 24))))
                   )
               (s.w! (+ a1-47 8) a0-57)
               (set! v1-120 (the-as none 1))
               (s.w! (+ a1-47 68) v1-120)
               (set! v1-121 (the-as none 'impact-impulse))
               (s.w! (+ a1-47 64) v1-121)
               (set! v1-122 (the-as none (+ s5-0 608)))
               (s.d! (+ a1-47 16) v1-122)
               (set! t9-31 (the-as none send-event-function))
               (set! a0-58 (the-as none (l.wu (+ s2-0 136))))
               (call!)
               (set! v1-123 (the-as none v0-31))
               (label cfg-32)
               (set! v1-124 (the-as none (l.b (+ s5-0 800))))
               (set! v1-125 (the-as none (+ v1-124 1)))
               (s.b! (+ s5-0 800) v1-125)
               (set! v1-126 (the-as none #x3d4ccccd))
               (set! f0-39 (the-as none (gpr->fpr v1-126)))
               (set! f1-21 (the-as none (l.f (+ s5-0 796))))
               (set! v1-127 (the-as none (<.s f0-39 f1-21)))
               (and v1-127 (begin
                             (set! v1-129 (the-as none (l.b (+ s5-0 800))))
                             (set! a0-59 (the-as none (l.bu (+ a0-0 140))))
                             (set! v1-128 (the-as none (<.si v1-129 a0-59)))
                             )
                    )
               (not v1-128)
               )
        (empty)
        )
      ((b! #t L125 (nop!)) (nop!))
      (label cfg-39)
      ((b! (not s3-0) L124 (set! v1-131 #f)) (empty-form))
      (set! v1-132 (the-as none (l.wu (+ s5-0 116))))
      (set! v1-133 (the-as none (l.wu v1-132)))
      (set! v1-134 (the-as none (l.wu (+ v1-133 136))))
      (s.w! (+ a1-0 16) v1-134)
      (set! v1-135 (the-as none 0))
      (label cfg-41)
      (set! v1-136 (the-as none (+ a1-0 32)))
      (set! a0-60 (the-as none (+ a1-0 32)))
      (set! a1-48 (the-as none (+ s5-0 624)))
      (set! a2-12 (the-as none #x4223d70a))
      (set! f0-40 (the-as none (gpr->fpr a2-12)))
      (set! v1-137 (the-as none (vecplusfloattimes v1-136 a0-60 a1-48 f0-40)))
      (set! a0-61 (the-as none a1-0))
      (set! v1-138 (the-as none rigid-body))
      (set! t9-32 (the-as none (l.wu (+ v1-138 112))))
      (call!)
      (set! v1-139 (the-as none v0-32))
      (set! v1-140 (the-as none 0))
      (when (begin
              (label cfg-42)
              (set! f0-41 (the-as none 0))
              (set! f1-22 (the-as none (l.f (+ s5-0 796))))
              (<.s f0-41 f1-22)
              )
        (set! a0-62 (the-as none a1-0))
        (set! v1-142 (the-as none rigid-body))
        (set! t9-33 (the-as none (l.wu (+ v1-142 72))))
        (set! f0-42 (the-as none (l.f (+ s5-0 796))))
        (set! f1-23 (the-as none (l.f (+ s5-0 792))))
        (set! f0-43 (the-as none (*.s f0-42 f1-23)))
        (set! a1-49 (the-as none (fpr->gpr f0-43)))
        (call!)
        (set! v1-143 (the-as none v0-33))
        (set! a0-63 (the-as none a1-0))
        (set! v1-144 (the-as none rigid-body))
        (set! t9-34 (the-as none (l.wu (+ v1-144 68))))
        (call!)
        (set! v1-145 (the-as none v0-34))
        (set! t9-35 (the-as none transform-rigid-body-prims))
        (set! a0-64 (the-as none (l.wu (+ a0-0 156))))
        (set! a1-50 (the-as none (+ a1-0 160)))
        (call!)
        (set! f0-44 (the-as none 0))
        (s.f! (+ s5-0 796) f0-44)
        (set! v1-146 (the-as none (fpr->gpr f0-44)))
        )
      (label cfg-44)
      (set! v1-147 #x3f800000)
      (set! f0-45 (the-as float (gpr->fpr v1-147)))
      (set! f1-24 (-> s5-0 49 w))
      (set! f0-46 (-.s f0-45 f1-24))
      (set! f1-25 (-> s5-0 49 z))
      (set! f0-47 (*.s f0-46 f1-25))
      (set! f1-26 (-> a1-0 time-remaining))
      (set! f0-48 (-.s f1-26 f0-47))
      (set! (-> a1-0 time-remaining) f0-48)
      (set! v1-148 (fpr->gpr f0-48))
      (set! v0-36 0)
      (ret-none)
      )
    )
  )

;; definition for method 15 of type rigid-body
;; INFO: Used lq/sq
;; WARN: Stack slot offset 632 signed mismatch
;; WARN: Stack slot offset 632 signed mismatch
;; WARN: Stack slot offset 632 signed mismatch
;; WARN: Stack slot offset 632 signed mismatch
;; WARN: Stack slot offset 632 signed mismatch
;; WARN: Stack slot offset 632 signed mismatch
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-method-15 rigid-body ((obj rigid-body) (arg0 collide-shape-moving) (arg1 float))
  (local-vars
    (sv-576 vector)
    (sv-624 vector)
    (sv-628 vector)
    (sv-632 float)
    (sv-704 vector)
    (sv-708 vector)
    (sv-712 vector)
    (sv-716 vector)
    )
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (-> obj work)
    (let ((s4-0 (-> obj info))
          (s3-0 (new 'stack-no-clear 'collide-query))
          (f30-0 1.0)
          (s2-0 0)
          )
      (set! (-> s3-0 start-pos quad) (-> obj position quad))
      (let ((v1-3 s3-0))
        (set! (-> v1-3 radius) (-> arg0 root-prim prim-core world-sphere w))
        (set! (-> v1-3 collide-with) (-> arg0 root-prim prim-core collide-with))
        (set! (-> v1-3 ignore-process0) #f)
        (set! (-> v1-3 ignore-process1) #f)
        (set! (-> v1-3 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
        (set! (-> v1-3 action-mask) (collide-action solid))
        )
      (until (>= s2-0 4)
        (vector-float*! (-> s3-0 move-dist) (-> obj lin-velocity) (* f30-0 arg1))
        (let ((f28-0 (probe-using-line-sphere *collide-cache* s3-0)))
          (b! (>= f28-0 0.0) cfg-3)
          (rigid-body-method-14 obj (* f30-0 arg1))
          (b! #t cfg-9 :delay (nop!))
          (label cfg-3)
          (rigid-body-method-14 obj (* f30-0 arg1 f28-0))
          (set! sv-576 (new 'stack-no-clear 'vector))
          (set! sv-624 (new 'stack-no-clear 'vector))
          (set! sv-628 (new 'stack-no-clear 'vector))
          (vector-! sv-576 (-> obj position) (-> s3-0 best-other-tri intersect))
          (vector-normalize! sv-576 1.0)
          (set! sv-632 (vector-dot sv-576 (-> obj lin-momentum)))
          (when (< sv-632 0.0)
            (vector-float*! sv-624 sv-576 sv-632)
            (vector-! sv-628 (-> obj lin-momentum) sv-624)
            (vector-float*! sv-628 sv-628 (- 1.0 (-> s4-0 friction-factor)))
            (vector-float*! sv-624 sv-624 (- (-> s4-0 bounce-factor)))
            (vector+! (-> obj lin-momentum) sv-628 sv-624)
            (vector-float*! (-> obj lin-velocity) (-> obj lin-momentum) (-> s4-0 inv-mass))
            )
          (b! (>= f28-0 0.0001) cfg-7 :delay #f)
          (vector+float*! (-> obj position) (-> obj position) sv-576 409.6)
          (label cfg-7)
          (set! sv-704 (new 'stack-no-clear 'vector))
          (set! sv-708 (new 'stack-no-clear 'vector))
          (set! sv-712 (new 'stack-no-clear 'vector))
          (set! sv-716 (new 'stack-no-clear 'vector))
          (vector-! sv-704 (-> s3-0 best-other-tri intersect) (-> obj position))
          (rigid-body-method-22 obj (-> s3-0 best-other-tri intersect) sv-708)
          (vector+float*! sv-708 sv-708 sv-576 (- (vector-dot sv-708 sv-576)))
          (vector-float*! sv-712 sv-708 (* -1.0 (-> s4-0 mass) (-> s4-0 friction-factor)))
          (vector-cross! sv-716 sv-704 sv-712)
          (let ((a1-20 (-> obj ang-momentum)))
            (let ((v1-46 (-> obj ang-momentum)))
              (let ((a0-27 sv-716))
                (let ((a2-6 1.0))
                  (.mov vf7 a2-6)
                  )
                (.lvf vf5 (&-> a0-27 quad))
                )
              (.lvf vf4 (&-> v1-46 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a1-20 quad) vf6)
            )
          (vector-rotate*! (-> obj ang-velocity) (-> obj ang-momentum) (-> obj inv-i-world))
          (set! f30-0 (* f30-0 (- 1.0 f28-0)))
          )
        (+! s2-0 1)
        )
      )
    (label cfg-9)
    0
    0
    (none)
    )
  )

;; definition for method 18 of type rigid-body
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-method-18 rigid-body ((obj rigid-body) (arg0 vector) (arg1 vector))
  (vector+! (-> obj force) (-> obj force) arg1)
  (let ((a3-1 (new 'stack-no-clear 'vector))
        (v1-1 (new 'stack-no-clear 'vector))
        )
    (vector-! a3-1 arg0 (-> obj position))
    (vector-cross! v1-1 a3-1 arg1)
    (vector+! (-> obj torque) (-> obj torque) v1-1)
    )
  0
  (none)
  )

;; definition for method 21 of type rigid-body
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-method-21 rigid-body ((obj rigid-body) (arg0 vector) (arg1 vector) (arg2 float))
  (vector+! (-> obj force) (-> obj force) arg1)
  (let* ((t0-2 (vector-! (new 'stack-no-clear 'vector) arg0 (-> obj position)))
         (v1-3 (vector-cross! (new 'stack-no-clear 'vector) t0-2 arg1))
         )
    (let ((f0-0 (vector-length t0-2)))
      (if (< arg2 f0-0)
          (vector-float*! v1-3 v1-3 (/ arg2 f0-0))
          )
      )
    (vector+! (-> obj torque) (-> obj torque) v1-3)
    )
  0
  (none)
  )

;; definition for method 19 of type rigid-body
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-method-19 rigid-body ((obj rigid-body) (arg0 vector) (arg1 vector))
  (let ((s5-0 (new 'stack-no-clear 'vector))
        (s4-0 (new 'stack-no-clear 'vector))
        )
    (-> obj work)
    (vector-rotate*! s4-0 arg1 (-> obj matrix))
    (vector-rotate*! s5-0 arg0 (-> obj matrix))
    (vector+! s5-0 s5-0 (-> obj position))
    (rigid-body-method-18 obj s5-0 s4-0)
    )
  0
  (none)
  )

;; definition for method 20 of type rigid-body
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-method-20 rigid-body ((obj rigid-body) (arg0 vector))
  (vector+! (-> obj force) (-> obj force) arg0)
  0
  (none)
  )

;; definition for method 23 of type rigid-body
(defmethod rigid-body-method-23 rigid-body ((obj rigid-body) (arg0 vector))
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    (vector-rotate*! gp-0 (-> obj info cm-offset-joint) (-> obj matrix))
    (vector-! arg0 (-> obj position) gp-0)
    )
  arg0
  )

;; definition for method 28 of type rigid-body
;; WARN: Return type mismatch int vs none.
(defmethod print-force-torque rigid-body ((obj rigid-body) (arg0 object))
  (format arg0 "  force ~M ~M ~M" (-> obj force x) (-> obj force y) (-> obj force z))
  (format arg0 "  torque ~M ~M ~M~%" (-> obj torque x) (-> obj torque y) (-> obj torque z))
  0
  (none)
  )

;; definition for method 30 of type rigid-body
;; WARN: Return type mismatch int vs none.
(defmethod print-momentum rigid-body ((obj rigid-body) (arg0 object))
  (format arg0 "  lin-mom ~M ~M ~M" (-> obj lin-momentum x) (-> obj lin-momentum y) (-> obj lin-momentum z))
  (format arg0 "  ang-mom ~M ~M ~M~%" (-> obj ang-momentum x) (-> obj ang-momentum y) (-> obj ang-momentum z))
  0
  (none)
  )

;; definition for method 31 of type rigid-body
;; WARN: Return type mismatch int vs none.
(defmethod print-velocity rigid-body ((obj rigid-body) (arg0 object))
  (format arg0 "  lin-vel ~M ~M ~M" (-> obj lin-velocity x) (-> obj lin-velocity y) (-> obj lin-velocity z))
  (format arg0 "  ang-vel ~f ~f ~f~%" (-> obj ang-velocity x) (-> obj ang-velocity y) (-> obj ang-velocity z))
  0
  (none)
  )

;; definition for method 29 of type rigid-body
;; WARN: Return type mismatch int vs none.
(defmethod print-position-rotation rigid-body ((obj rigid-body) (arg0 object))
  (format arg0 "  position ~M ~M ~M" (-> obj position x) (-> obj position y) (-> obj position z))
  (format
    arg0
    "  rotation ~f ~f ~f ~f~%"
    (-> obj rotation x)
    (-> obj rotation y)
    (-> obj rotation z)
    (-> obj rotation w)
    )
  0
  (none)
  )

;; definition for method 27 of type rigid-body
;; WARN: Return type mismatch int vs none.
(defmethod print-physics rigid-body ((obj rigid-body) (arg0 object))
  (print-force-torque obj arg0)
  (print-position-rotation obj arg0)
  (print-momentum obj arg0)
  (print-velocity obj arg0)
  0
  (none)
  )

;; definition for method 10 of type rigid-body-control
;; WARN: Return type mismatch int vs object.
(defmethod rigid-body-control-method-10 rigid-body-control ((obj rigid-body-control) (arg0 rigid-body-object) (arg1 float) (arg2 float))
  (let* ((s4-1 (max 1 (min 4 (+ (the int (* 0.9999 (/ arg1 arg2))) 1))))
         (f30-0 (/ arg1 (the float s4-1)))
         (s3-0 (-> obj state force-callback))
         )
    (while (nonzero? s4-1)
      (+! s4-1 -1)
      (s3-0 arg0 f30-0)
      (let ((v1-2 obj)
            (a1-2 (-> arg0 root-override-2))
            (f0-4 f30-0)
            )
        (rigid-body-method-9 (-> v1-2 state) a1-2 f0-4)
        )
      )
    )
  (the-as object 0)
  )

;; definition for method 11 of type rigid-body
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-method-11 rigid-body ((obj rigid-body) (arg0 collide-shape-moving))
  (quaternion-copy! (-> arg0 quat) (-> obj rotation))
  (rigid-body-method-23 obj (-> arg0 trans))
  (set! (-> arg0 transv quad) (-> obj lin-velocity quad))
  0
  (none)
  )

;; definition for method 26 of type rigid-body-object
(defmethod get-inv-mass rigid-body-object ((obj rigid-body-object))
  (-> obj info inv-mass)
  )

;; definition for method 35 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-35 rigid-body-object ((obj rigid-body-object))
  (let ((a0-1 (-> obj info name)))
    (when (nonzero? a0-1)
      (set! (-> obj info) (the-as rigid-body-object-constants (-> a0-1 value)))
      (set! (-> obj rbody state info) (the-as rigid-body-info (&-> (-> obj info) mass)))
      )
    )
  ((method-of-type rigid-body-info rigid-body-info-method-9) (the-as rigid-body-info (&-> (-> obj info) mass)))
  (set! (-> obj rbody state force-callback) (method-of-object obj rigid-body-object-method-29))
  0
  (none)
  )

;; definition for method 50 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-50 rigid-body-object ((obj rigid-body-object) (arg0 float))
  (when (logtest? (-> obj flags) (rigid-body-object-flag player-impulse-force player-contact-force))
    (when (logtest? (-> obj flags) (rigid-body-object-flag player-impulse-force))
      (logclear! (-> obj flags) (rigid-body-object-flag player-impulse-force))
      (vector-float*! (-> obj player-force) (-> obj player-force) (/ 1.0 arg0))
      )
    (let ((v1-10 (-> obj rbody))
          (a1-1 (-> obj player-force-position))
          (a2-2 (-> obj player-force))
          )
      (rigid-body-method-18 (-> v1-10 state) a1-1 a2-2)
      )
    )
  0
  (none)
  )

;; definition for method 29 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-29 rigid-body-object ((obj rigid-body-object) (arg0 float))
  (let ((a1-1 (new 'stack-no-clear 'vector)))
    (vector-reset! a1-1)
    (set! (-> a1-1 y) (* -1.0 (-> obj info gravity) (-> obj rbody state info mass)))
    (rigid-body-method-20 (-> obj rbody state) a1-1)
    )
  0
  (none)
  )

;; definition for method 30 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-30 rigid-body-object ((obj rigid-body-object))
  (with-pp
    (rigid-body-control-method-10 (-> obj rbody) obj (-> pp clock seconds-per-frame) (-> obj max-time-step))
    (logclear! (-> obj flags) (rigid-body-object-flag player-impulse-force player-contact-force))
    0
    (none)
    )
  )

;; definition for method 51 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-51 rigid-body-object ((obj rigid-body-object))
  (rigid-body-control-method-10 (-> obj rbody) obj (-> obj rbody state time-remaining) (-> obj max-time-step))
  0
  (none)
  )

;; definition for method 52 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-52 rigid-body-object ((obj rigid-body-object))
  (logclear! (-> obj flags) (rigid-body-object-flag player-impulse-force player-contact-force))
  0
  (none)
  )

;; definition for method 34 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-34 rigid-body-object ((obj rigid-body-object))
  (go (method-of-object obj idle))
  0
  (none)
  )

;; definition for method 31 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-31 rigid-body-object ((obj rigid-body-object) (arg0 rigid-body-object-constants))
  (set! (-> obj info) arg0)
  (set! (-> obj rbody) (new 'process 'rigid-body-control obj))
  (update-transforms (-> obj root-override-2))
  (rigid-body-method-25
    (-> obj rbody state)
    (the-as rigid-body-info (&-> (-> obj info) mass))
    (-> obj root-override-2 trans)
    (-> obj root-override-2 quat)
    (method-of-object obj rigid-body-object-method-29)
    )
  (rigid-body-object-method-35 obj)
  (set! (-> obj max-time-step) (-> arg0 max-time-step))
  (set! (-> obj root-override-2 max-iteration-count) (the-as uint 4))
  (let ((v1-15 (-> obj skel root-channel 0)))
    (set! (-> v1-15 num-func) num-func-identity)
    (set! (-> v1-15 frame-num) 0.0)
    )
  0
  (none)
  )

;; definition for method 32 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-32 rigid-body-object ((obj rigid-body-object))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 12288.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-16 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-16 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-16 prim-core collide-with))
      )
    (set! (-> obj root-override-2) s5-0)
    )
  0
  (none)
  )

;; definition for symbol *rigid-body-object-constants*, type rigid-body-object-constants
(define *rigid-body-object-constants* (new 'static 'rigid-body-object-constants
                                        :mass 2.0
                                        :inv-mass 0.5
                                        :cm-joint (new 'static 'vector :w 1.0)
                                        :linear-damping 1.0
                                        :angular-damping 1.0
                                        :bounce-factor 0.5
                                        :friction-factor 0.1
                                        :inertial-tensor-x (meters 4)
                                        :inertial-tensor-y (meters 4)
                                        :inertial-tensor-z (meters 4)
                                        :max-time-step 0.033333335
                                        :gravity (meters 80)
                                        :idle-distance (meters 50)
                                        :attack-force-scale 1.0
                                        :name '*rigid-body-object-constants*
                                        )
        )

;; definition for method 33 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-33 rigid-body-object ((obj rigid-body-object))
  (rigid-body-object-method-31 obj *rigid-body-object-constants*)
  0
  (none)
  )

;; definition for method 11 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod init-from-entity! rigid-body-object ((obj rigid-body-object) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (rigid-body-object-method-32 obj)
  (process-drawable-from-entity! obj arg0)
  (rigid-body-object-method-33 obj)
  (rigid-body-object-method-34 obj)
  0
  (none)
  )

;; definition for method 36 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-36 rigid-body-object ((obj rigid-body-object))
  0
  (none)
  )

;; definition for method 37 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-37 rigid-body-object ((obj rigid-body-object))
  (rigid-body-object-method-30 obj)
  (rigid-body-object-method-36 obj)
  (let ((v1-4 (-> obj rbody))
        (a1-0 (-> obj root-override-2))
        )
    (rigid-body-method-11 (-> v1-4 state) a1-0)
    )
  (transform-post)
  0
  (none)
  )

;; definition for method 40 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-40 rigid-body-object ((obj rigid-body-object))
  (logior! (-> obj flags) (rigid-body-object-flag enable-collision))
  (let ((v1-3 (-> obj root-override-2 root-prim)))
    (set! (-> v1-3 prim-core collide-as) (-> obj root-override-2 backup-collide-as))
    (set! (-> v1-3 prim-core collide-with) (-> obj root-override-2 backup-collide-with))
    )
  0
  (none)
  )

;; definition for method 41 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-41 rigid-body-object ((obj rigid-body-object))
  (logclear! (-> obj flags) (rigid-body-object-flag enable-collision))
  (let ((v1-3 (-> obj root-override-2 root-prim)))
    (set! (-> v1-3 prim-core collide-as) (collide-spec))
    (set! (-> v1-3 prim-core collide-with) (collide-spec))
    )
  0
  0
  (none)
  )

;; definition for method 38 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-38 rigid-body-object ((obj rigid-body-object))
  (when (not (logtest? (-> obj rbody state flags) (rigid-body-flag enable-physics)))
    (logior! (-> obj rbody state flags) (rigid-body-flag enable-physics))
    (rigid-body-method-26 (-> obj rbody state) (-> obj root-override-2 trans) (-> obj root-override-2 quat))
    (vector-float*! (-> obj rbody state lin-momentum) (-> obj root-override-2 transv) (-> obj info mass))
    (vector-reset! (-> obj rbody state ang-momentum))
    )
  0
  (none)
  )

;; definition for method 39 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-39 rigid-body-object ((obj rigid-body-object))
  (logclear! (-> obj rbody state flags) (rigid-body-flag enable-physics))
  0
  (none)
  )

;; definition for method 42 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-42 rigid-body-object ((obj rigid-body-object))
  (logior! (-> obj flags) (rigid-body-object-flag disturbed))
  (set! (-> obj disturbed-time) (-> self clock frame-counter))
  (if (not (logtest? (-> obj rbody state flags) (rigid-body-flag enable-physics)))
      (rigid-body-object-method-38 obj)
      )
  0
  (none)
  )

;; definition for method 43 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-43 rigid-body-object ((obj rigid-body-object))
  (go (method-of-object obj active))
  0
  (none)
  )

;; definition for method 44 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod apply-damage rigid-body-object ((obj rigid-body-object) (arg0 float) (arg1 matrix))
  0
  (none)
  )

;; definition for method 45 of type rigid-body-object
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-45 rigid-body-object ((obj rigid-body-object) (arg0 rigid-body-impact))
  0
  (none)
  )

;; definition for method 49 of type rigid-body-object
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod rigid-body-object-method-49 rigid-body-object ((obj rigid-body-object) (arg0 rigid-body-impact) (arg1 touching-shapes-entry))
  (set! (-> arg0 rbody) #f)
  (set! (-> arg0 prim-id) (the-as uint 0))
  (vector-reset! (-> arg0 normal))
  (vector-reset! (-> arg0 velocity))
  (set! (-> arg0 point quad) (-> obj root-override-2 trans quad))
  (when arg1
    (let ((s3-0 (-> arg1 head)))
      (when s3-0
        (get-intersect-point (-> arg0 point) s3-0 (-> obj root-override-2) arg1)
        (let ((s5-1 (get-touched-prim s3-0 (-> obj root-override-2) arg1)))
          (when s5-1
            (set! (-> arg0 prim-id) (-> s5-1 prim-id))
            (vector-! (-> arg0 normal) (-> arg0 point) (the-as vector (-> s5-1 prim-core)))
            (vector-normalize! (-> arg0 normal) 1.0)
            (vector+float*!
              (-> arg0 point)
              (the-as vector (-> s5-1 prim-core))
              (-> arg0 normal)
              (-> s5-1 prim-core world-sphere w)
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

;; definition for method 47 of type rigid-body-object
;; INFO: Used lq/sq
(defmethod rigid-body-object-method-47 rigid-body-object ((obj rigid-body-object)
                                                        (arg0 process-drawable)
                                                        (arg1 attack-info)
                                                        (arg2 touching-shapes-entry)
                                                        (arg3 penetrate)
                                                        )
  (local-vars (f0-2 float))
  (when arg2
    (let ((s5-0 (new 'stack-no-clear 'rigid-body-impact)))
      (rigid-body-object-method-49 obj s5-0 arg2)
      (if (logtest? (attack-info-mask attacker-velocity) (-> arg1 mask))
          (set! (-> s5-0 velocity quad) (-> arg1 attacker-velocity quad))
          (vector-! (-> s5-0 velocity) (-> s5-0 point) (-> arg0 root trans))
          )
      0.0
      0.0
      (let ((f1-0 (cond
                    ((logtest? (penetrate enemy-yellow-shot) arg3)
                     (set! f0-2 8192.0)
                     0.025
                     )
                    ((logtest? (penetrate jak-yellow-shot jak-blue-shot) arg3)
                     (set! f0-2 8192.0)
                     0.05
                     )
                    ((logtest? (penetrate jak-red-shot) arg3)
                     (set! f0-2 16384.0)
                     0.05
                     )
                    ((logtest? (penetrate explode jak-dark-shot enemy-dark-shot) arg3)
                     (set! f0-2 81920.0)
                     1.5
                     )
                    ((logtest? arg3 (penetrate punch))
                     (set! f0-2 40960.0)
                     0.1
                     )
                    ((logtest? arg3 (penetrate flop spin))
                     (set! f0-2 20480.0)
                     0.05
                     )
                    (else
                      (set! f0-2 8192.0)
                      0.01
                      )
                    )
                  )
            )
        (set! (-> s5-0 impulse) (* f0-2 (-> obj info attack-force-scale)))
        (apply-damage obj (* 0.667 f1-0) (the-as matrix s5-0))
        )
      (rigid-body-object-method-42 obj)
      (let ((s4-1 (new 'stack-no-clear 'vector)))
        (set! (-> s4-1 quad) (-> s5-0 velocity quad))
        (vector-normalize! s4-1 1.0)
        (vector-float*! s4-1 s4-1 (-> s5-0 impulse))
        (let ((v1-46 (-> obj rbody))
              (a1-6 (-> s5-0 point))
              (a2-3 s4-1)
              )
          (rigid-body-method-18 (-> v1-46 state) a1-6 a2-3)
          )
        (let ((v1-49 (-> obj rbody))
              (f0-7 1.0)
              )
          (rigid-body-method-12 (-> v1-49 state) f0-7)
          )
        (rigid-body-method-13 (-> obj rbody state))
        (when #t
          (add-debug-x #t (bucket-id debug-no-zbuf1) (-> s5-0 point) *color-blue*)
          (add-debug-vector #t (bucket-id debug-no-zbuf1) (-> s5-0 point) s4-1 (meters 0.00024414062) *color-blue*)
          )
        )
      (rigid-body-object-method-45 obj s5-0)
      )
    (if (and (-> obj next-state) (= (-> obj next-state name) 'idle))
        (rigid-body-object-method-43 obj)
        )
    #t
    )
  )

;; definition for method 48 of type rigid-body-object
;; INFO: Used lq/sq
(defmethod rigid-body-object-method-48 rigid-body-object ((obj rigid-body-object) (arg0 process-focusable) (arg1 touching-shapes-entry))
  (local-vars (v1-2 symbol))
  (b! (not (logtest? (process-mask target crate enemy) (-> arg0 mask))) cfg-5 :likely-delay (set! v1-2 #t))
  (b! (not (logtest? (-> arg0 mask) (process-mask target))) cfg-5 :likely-delay (set! v1-2 #f))
  (set! v1-2 (logtest? (focus-status dangerous pilot) (-> arg0 focus-status)))
  (label cfg-5)
  (b! v1-2 cfg-17 :delay (nop!))
  (let ((s5-0 (new 'stack-no-clear 'rigid-body-impact))
        (s4-0 (new 'stack-no-clear 'vector))
        (f30-0 (get-inv-mass arg0))
        )
    (rigid-body-object-method-49 obj s5-0 arg1)
    (cond
      ((logtest? (-> obj rbody state flags) (rigid-body-flag enable-physics))
       (let ((v1-14 (-> obj rbody))
             (a1-3 (-> s5-0 point))
             (a2-2 (-> s5-0 velocity))
             )
         (rigid-body-method-22 (-> v1-14 state) a1-3 a2-2)
         )
       )
      (else
        (set! (-> s5-0 velocity quad) (-> obj root-override-2 transv quad))
        )
      )
    (let ((v1-18 (-> arg0 root-override)))
      (set! (-> s4-0 quad) (-> v1-18 transv quad))
      (vector-! (-> s5-0 velocity) (-> v1-18 transv) (-> s5-0 velocity))
      )
    (let ((f0-1 (vector-dot (-> s5-0 velocity) (-> s5-0 normal))))
      (when (< f0-1 0.0)
        (set! (-> s5-0 impulse) (/ f0-1 (+ f30-0 (-> obj info inv-mass))))
        (vector+float*! s4-0 s4-0 (-> s5-0 normal) (* -3.1 f30-0 (-> s5-0 impulse)))
        (set! (-> s4-0 y) (fmax (* 49152.0 f30-0) (-> s4-0 y)))
        (rigid-body-object-method-42 obj)
        (let ((a2-4 (new 'stack-no-clear 'vector)))
          (vector-float*! a2-4 (-> s5-0 normal) (-> s5-0 impulse))
          (let ((v1-31 (-> obj rbody))
                (a1-8 (-> s5-0 point))
                )
            (rigid-body-method-18 (-> v1-31 state) a1-8 a2-4)
            )
          )
        (let ((v1-34 (-> obj rbody))
              (f0-10 1.0)
              )
          (rigid-body-method-12 (-> v1-34 state) f0-10)
          )
        (rigid-body-method-13 (-> obj rbody state))
        (when #f
          (add-debug-x #t (bucket-id debug-no-zbuf1) (-> s5-0 point) *color-blue*)
          (add-debug-vector
            #t
            (bucket-id debug-no-zbuf1)
            (-> s5-0 point)
            (-> s5-0 normal)
            (- (-> s5-0 impulse))
            *color-blue*
            )
          )
        (rigid-body-object-method-45 obj s5-0)
        (if (and (-> obj next-state) (= (-> obj next-state name) 'idle))
            (rigid-body-object-method-43 obj)
            )
        )
      )
    )
  (label cfg-17)
  #t
  )

;; definition for method 46 of type rigid-body-object
;; INFO: Used lq/sq
(defmethod rigid-body-object-method-46 rigid-body-object ((obj rigid-body-object) (arg0 process-drawable) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('impact-impulse)
     (let ((s5-1 (-> arg3 param 0)))
       (if (!= obj arg0)
           (rigid-body-object-method-42 obj)
           )
       (rigid-body-object-method-45 obj (the-as rigid-body-impact s5-1))
       )
     (if (and (-> obj next-state) (= (-> obj next-state name) 'idle))
         (rigid-body-object-method-43 obj)
         )
     )
    (('touched)
     (if (= obj *debug-actor*)
         (format *stdcon* "rigid-body-object got touched~%")
         )
     (when (zero? (-> arg0 rbody))
       (let ((s3-0 (if (type? arg0 process-focusable)
                       (the-as process-focusable arg0)
                       )
                   )
             )
         (when s3-0
           (when (logtest? (-> s3-0 mask) (process-mask target))
             (logior! (-> obj flags) (rigid-body-object-flag player-touching))
             (set! (-> obj player-touch-time) (-> self clock frame-counter))
             (rigid-body-object-method-42 obj)
             )
           (if (not (logtest? (-> s3-0 mask) (process-mask target)))
               (rigid-body-object-method-48 obj s3-0 (the-as touching-shapes-entry (-> arg3 param 0)))
               )
           )
         )
       )
     )
    (('attack)
     (let ((s3-1 (the-as attack-info (-> arg3 param 1)))
           (t0-1 (get-penetrate-using-from-attack-event arg0 arg3))
           )
       (when (!= (-> s3-1 id) (-> obj incoming-attack-id))
         (set! (-> obj incoming-attack-id) (-> s3-1 id))
         (rigid-body-object-method-47 obj arg0 s3-1 (the-as touching-shapes-entry (-> arg3 param 0)) t0-1)
         )
       )
     )
    (('edge-grabbed 'pilot-edge-grab)
     (let ((s5-2 (the-as object (-> arg3 param 0))))
       (when (not (logtest? (-> obj flags) (rigid-body-object-flag player-impulse-force)))
         (let ((a0-25 (if (type? arg0 process-focusable)
                          (the-as process-focusable arg0)
                          )
                      )
               )
           (when a0-25
             (let ((f0-1 (/ 163840.0 (get-inv-mass a0-25))))
               (logior! (-> obj flags) (rigid-body-object-flag player-touching player-edge-grabbing player-contact-force))
               (set! (-> obj player-force-position quad) (-> (the-as attack-info s5-2) attacker-velocity quad))
               (vector-reset! (-> obj player-force))
               (set! (-> obj player-force y) (* -1.0 f0-1))
               )
             )
           )
         )
       )
     (zero? (logand (-> obj focus-status) (focus-status dead inactive)))
     )
    (('ridden)
     (let ((v1-45 (the-as object (-> arg3 param 0))))
       (when (the-as uint v1-45)
         (let* ((s5-3 (handle->process (-> (the-as focus v1-45) handle)))
                (a0-34 (if (type? s5-3 process-focusable)
                           (the-as process-focusable s5-3)
                           )
                       )
                )
           (when (and a0-34
                      (logtest? (-> a0-34 mask) (process-mask target))
                      (zero? (logand (-> a0-34 focus-status) (focus-status on-water under-water)))
                      )
             (when (not (logtest? (-> obj flags) (rigid-body-object-flag player-impulse-force)))
               (logior! (-> obj flags) (rigid-body-object-flag player-touching player-standing-on player-contact-force))
               (set! (-> obj player-force-position quad) (-> a0-34 root-override trans quad))
               (vector-reset! (-> obj player-force))
               (let ((f0-4 (/ 163840.0 (get-inv-mass a0-34)))
                     (f1-1 1.0)
                     )
                 (set! (-> obj player-force y) (* -1.0 f0-4 f1-1))
                 )
               )
             )
           )
         )
       )
     )
    (('bonk)
     (when #t
       (let ((a0-38 (if (type? arg0 process-focusable)
                        (the-as process-focusable arg0)
                        )
                    )
             )
         (when a0-38
           (logior! (-> obj flags) (rigid-body-object-flag player-touching player-impulse-force))
           (set! (-> obj player-force-position quad) (-> a0-38 root-override trans quad))
           (let ((f30-2 (* 0.00012207031 (the-as float (-> arg3 param 1))))
                 (f0-9 (/ 163840.0 (get-inv-mass a0-38)))
                 )
             (vector-reset! (-> obj player-force))
             (set! (-> obj player-force y) (* -0.1 f0-9 f30-2))
             )
           )
         )
       )
     )
    (('enable-physics)
     (rigid-body-object-method-42 obj)
     )
    )
  (none)
  )

;; definition for function rigid-body-object-event-handler
(defbehavior rigid-body-object-event-handler rigid-body-object ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (rigid-body-object-method-46 self (the-as process-drawable arg0) arg1 arg2 arg3)
  (none)
  )

;; failed to figure out what this is:
(defstate idle (rigid-body-object)
  :virtual #t
  :trans (behavior ()
    (if (and *target* (and (>= (-> self info idle-distance)
                               (vector-vector-distance (-> self root-override-2 trans) (-> *target* control trans))
                               )
                           (zero? (logand (focus-status teleporting) (-> *target* focus-status)))
                           )
             )
        (go-virtual active)
        )
    (none)
    )
  :code (the-as (function none :behavior rigid-body-object) sleep-code)
  :post (the-as (function none :behavior rigid-body-object) ja-post)
  )

;; failed to figure out what this is:
(defstate active (rigid-body-object)
  :virtual #t
  :event (the-as
    (function process int symbol event-message-block object :behavior rigid-body-object)
    rigid-body-object-event-handler
    )
  :trans (behavior ()
    (if (or (not *target*)
            (or (< (+ 4096.0 (-> self info idle-distance))
                   (vector-vector-distance (-> self root-override-2 trans) (-> *target* control trans))
                   )
                (logtest? (focus-status teleporting) (-> *target* focus-status))
                )
            )
        (go-virtual idle)
        )
    (none)
    )
  :code (the-as (function none :behavior rigid-body-object) sleep-code)
  :post (behavior ()
    (rigid-body-object-method-37 self)
    (none)
    )
  )
