;;-*-Lisp-*-
(in-package goal)

;; definition of type fog-corrector
(deftype fog-corrector (structure)
  "The math-camera matrices are used to compute fogging values, which are a per-vertex uint8 that
tells the GS how 'foggy' the color should be. This should be proportional to how far away the vertex
is. There is a scaling factor applied so the fog intensity isn't affected by the field of view angle.

The fog-corrector stores a fog-end fog-start value that is corrected for the field of view.
The actual correction factor is computed in cam-update.gc.
Without this corrector, the fogginess of the world would change as the FOV changes
(for example, when Jak gets on the zoomer, the FOV changes slightly)."
  ((fog-end    float)
   (fog-start  float)
   )
  )

;; definition for method 3 of type fog-corrector
(defmethod inspect ((this fog-corrector))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'fog-corrector)
  (format #t "~1Tfog-end: ~f~%" (-> this fog-end))
  (format #t "~1Tfog-start: ~f~%" (-> this fog-start))
  (label cfg-4)
  this
  )

;; definition for function fog-corrector-setup
;; WARN: Return type mismatch float vs none.
(defun fog-corrector-setup ((arg0 fog-corrector) (arg1 math-camera))
  "Set the fog corrector based on the supplied math-camera."
  (set! (-> arg0 fog-end) (* (-> arg1 fog-end) (-> arg1 fov-correction-factor)))
  (set! (-> arg0 fog-start) (* (-> arg1 fog-start) (-> arg1 fov-correction-factor)))
  (none)
  )

;; definition for symbol *math-camera-fog-correction*, type fog-corrector
(define *math-camera-fog-correction* (new 'global 'fog-corrector))

;; definition for function update-math-camera
;; INFO: Used lq/sq
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Stack slot offset 16 signed mismatch
;; WARN: Stack slot offset 16 signed mismatch
;; ERROR: Failed store: (s.w! a0-43 v1-54) at op 457
;; ERROR: Failed store: (s.w! (+ a0-43 4) a1-9) at op 461
;; ERROR: Failed store: (s.w! (+ a0-43 8) a1-10) at op 463
;; ERROR: Failed store: (s.w! (+ a0-43 12) a1-11) at op 465
(defun update-math-camera ((arg0 math-camera) (arg1 symbol) (arg2 symbol) (arg3 float))
  "Compute some one-time camera constants.
   These should only change when changing aspect ratio."
  (local-vars (sv-16 float))
  (set! (-> arg0 x-ratio) (tan (/ arg3 2)))
  (if (= arg2 'aspect4x3)
      (set! (-> arg0 y-ratio) (* 0.75 (-> arg0 x-ratio)))
      (set! (-> arg0 y-ratio) (* 0.5625 (-> arg0 x-ratio)))
      )
  (let ((f1-3 (-> arg0 x-ratio))
        (f0-7 (-> arg0 y-ratio))
        (v1-6 (-> arg0 cull-info))
        )
    (/ (+ 1.0 (* 4.0 f1-3 f1-3)) (+ 1.0 (* f1-3 f1-3)))
    (let ((f2-5 (/ (+ 1.0 (* 4.0 f0-7 f0-7)) (+ 1.0 (* f0-7 f0-7)))))
      (set! (-> v1-6 x-fact) (/ (+ 1.0 (* 4.0 f1-3 f1-3)) (* f1-3 (sqrtf (+ 1.0 (* 16.0 f1-3 f1-3))))))
      (set! (-> v1-6 y-fact) (/ (+ 1.0 (* 4.0 f0-7 f0-7)) (* f0-7 (sqrtf (+ 1.0 (* 16.0 f0-7 f0-7))))))
      (set! (-> v1-6 z-fact) (sqrtf (+ (* (+ -4.0 f2-5) (+ -4.0 f2-5) f0-7 f0-7) (* (+ -1.0 f2-5) (+ -1.0 f2-5)))))
      )
    (let* ((f2-11 (* f1-3 (-> arg0 d)))
           (f1-5 (* f0-7 (-> arg0 d)))
           (f0-10 (+ (* f2-11 f2-11) (* f1-5 f1-5)))
           (f1-8 (-> arg0 d))
           )
      (set! (-> v1-6 cam-radius) (sqrtf (+ f0-10 (* f1-8 f1-8))))
      )
    (let* ((f1-12 (* (-> arg0 d) (-> arg0 x-ratio)))
           (f0-14 (-> arg0 d))
           (f2-13 (* 4.0 f1-12))
           (f3-21 (-> arg0 d))
           )
      (let ((f4-21 (/ 1.0 (sqrtf (+ (* f1-12 f1-12) (* f0-14 f0-14)))))
            (f5-11 (/ 1.0 (sqrtf (+ (* f2-13 f2-13) (* f3-21 f3-21)))))
            )
        (set! (-> v1-6 xz-dir-ax) (* f1-12 f4-21))
        (set! (-> v1-6 xz-dir-az) (* f0-14 f4-21))
        (set! (-> v1-6 xz-dir-bx) (* f2-13 f5-11))
        (set! (-> v1-6 xz-dir-bz) (* f3-21 f5-11))
        )
      (set! (-> v1-6 xz-cross-ab) (- (* f1-12 f3-21) (* f0-14 f2-13)))
      )
    (let* ((f1-15 (* (-> arg0 d) (-> arg0 y-ratio)))
           (f0-18 (-> arg0 d))
           (f2-15 (* 4.0 f1-15))
           (f3-22 (-> arg0 d))
           )
      (let ((f4-26 (/ 1.0 (sqrtf (+ (* f1-15 f1-15) (* f0-18 f0-18)))))
            (f5-16 (/ 1.0 (sqrtf (+ (* f2-15 f2-15) (* f3-22 f3-22)))))
            )
        (set! (-> v1-6 yz-dir-ay) (* f1-15 f4-26))
        (set! (-> v1-6 yz-dir-az) (* f0-18 f4-26))
        (set! (-> v1-6 yz-dir-by) (* f2-15 f5-16))
        (set! (-> v1-6 yz-dir-bz) (* f3-22 f5-16))
        )
      (set! (-> v1-6 yz-cross-ab) (- (* f1-15 f3-22) (* f0-18 f2-15)))
      )
    )
  (fog-corrector-setup *math-camera-fog-correction* arg0)
  (matrix-identity! (-> arg0 camera-rot))
  (let ((f0-21 100.0)
        (f2-16 16760631.0)
        )
    16777115.0
    (let ((f30-0 (/ (* (-> arg0 d) (- (-> arg0 fog-min) (-> arg0 fog-max)))
                    (- (-> *math-camera-fog-correction* fog-end) (-> *math-camera-fog-correction* fog-start))
                    )
                 )
          (f1-21 (* -0.5 (- f2-16 f0-21)))
          )
      (let ((f4-34 (/ f1-21 (* (-> arg0 d) (- (-> arg0 f) (-> arg0 d)))))
            (f3-30 (-> arg0 fov-correction-factor))
            )
        (set! (-> arg0 perspective vector 0 x) (* f3-30 (- (/ (-> arg0 x-pix) (* (-> arg0 x-ratio) (-> arg0 d))))))
        (set! (-> arg0 perspective vector 1 y) (* f3-30 (- (/ (-> arg0 y-pix) (* (-> arg0 y-ratio) (-> arg0 d))))))
        (set! (-> arg0 perspective vector 2 z) (* f3-30 (+ (-> arg0 f) (-> arg0 d)) f4-34))
        (set! (-> arg0 perspective vector 2 w) (* (/ f3-30 (-> arg0 d)) f30-0))
        (set! (-> arg0 perspective trans z) (* -2.0 f4-34 (-> arg0 f) (-> arg0 d) f3-30))
        )
      (let ((f24-0 2048.0)
            (f26-0 2048.0)
            (f28-0 (/ (- (* (-> *math-camera-fog-correction* fog-end) (-> arg0 fog-max))
                         (* (-> *math-camera-fog-correction* fog-start) (-> arg0 fog-min))
                         )
                      (- (-> *math-camera-fog-correction* fog-end) (-> *math-camera-fog-correction* fog-start))
                      )
                   )
            )
        (let ((f22-0 (* 0.5 (+ f2-16 f0-21))))
          (set! (-> arg0 hmge-scale x) (/ 1.0 (-> arg0 x-clip)))
          (set! (-> arg0 hmge-scale y) (/ 1.0 (-> arg0 y-clip)))
          (set! (-> arg0 hmge-scale z) (/ 1.0 f1-21))
          (set! (-> arg0 hmge-scale w) (/ 1.0 f30-0))
          (set! (-> arg0 inv-hmge-scale x) (-> arg0 x-clip))
          (set! (-> arg0 inv-hmge-scale y) (-> arg0 y-clip))
          (set! (-> arg0 inv-hmge-scale z) f1-21)
          (set! (-> arg0 inv-hmge-scale w) f30-0)
          (cond
            ((or (zero? *screen-shot-work*) (= (-> *screen-shot-work* count) -1))
             (set! (-> arg0 hvdf-off x) f24-0)
             (set! (-> arg0 hvdf-off y) f26-0)
             )
            (else
              (let* ((v1-32 (-> *screen-shot-work* count))
                     (a0-36 (-> *screen-shot-work* size))
                     (f0-34 (the float a0-36))
                     (f20-0 (/ (the float (mod v1-32 a0-36)) f0-34))
                     )
                (set! sv-16 (/ (the float (/ v1-32 a0-36)) f0-34))
                (format 0 "~f ~f~%" f20-0 sv-16)
                (set! (-> arg0 hvdf-off x) (- f24-0 f20-0))
                )
              (set! (-> arg0 hvdf-off y) (- f26-0 sv-16))
              )
            )
          (set! (-> arg0 hvdf-off z) f22-0)
          (set! (-> arg0 hvdf-off w) f28-0)
          (set! (-> arg0 guard x) (/ (-> arg0 x-clip) (-> arg0 x-pix)))
          (set! (-> arg0 guard y) (/ (-> arg0 y-clip) (-> arg0 y-pix)))
          (set! (-> arg0 guard z) 1.0)
          (set! (-> arg0 guard w) 1.0)
          (set! (-> arg0 isometric trans z) (- 16777215.0 f22-0))
          )
        (set! (-> arg0 isometric trans w) f30-0)
        (let ((f1-28 (-> arg0 perspective vector 0 x))
              (f2-19 (-> arg0 perspective vector 1 y))
              (f0-48 (* -1.9996 (-> arg0 perspective vector 0 x)))
              )
          (let ((v1-39 (-> arg0 sprite-2d)))
            (set! (-> v1-39 vector 0 x) f0-48)
            (set! (-> v1-39 vector 0 y) 0.0)
            (set! (-> v1-39 vector 0 z) 0.0)
            (set! (-> v1-39 vector 0 w) 0.0)
            )
          (set-vector! (-> arg0 sprite-2d vector 1) 0.0 (- (* (/ f2-19 f1-28) f0-48)) 0.0 0.0)
          (set-vector! (-> arg0 sprite-2d vector 2) 0.0 0.0 (- f0-48) 0.0)
          (set-vector! (-> arg0 sprite-2d trans) 0.0 0.0 (* 500000000.0 f0-48) (* 60.0 f0-48 (-> arg0 pfog0)))
          )
        (set! (-> arg0 sprite-2d-hvdf quad) (-> arg0 hvdf-off quad))
        (set! (-> arg0 sprite-2d-hvdf x) 2048.0)
        (set! (-> arg0 sprite-2d-hvdf y) 2048.0)
        (set! (-> arg0 sprite-2d-hvdf z) (-> arg0 hvdf-off z))
        (set! (-> arg0 pfog0) f30-0)
        (set! (-> arg0 pfog1) f28-0)
        )
      )
    )
  0
  (make-u128 0 (shl #x301ec000 32))
  (make-u128 0 (shl #x303ec000 32))
  (let ((v1-54 (-> arg0 pfog0)))
    (let ((a0-42 (-> arg0 vis-gifs)))
      (set! (-> a0-42 0 fog0) (the-as uint v1-54))
      (set! (-> a0-42 0 strip) (the-as uint #x301e4000))
      (set! (-> a0-42 0 regs) (the-as uint 1042))
      (set! (-> a0-42 0 fan) (the-as uint #x301ec000))
      )
    (let ((a0-43 (&-> arg0 gifgr)))
      (s.w! a0-43 v1-54)
      (let ((a1-9 (make-u128 0 (shl #x20164000 32))))
        (s.w! (+ a0-43 4) a1-9)
        )
      (let ((a1-10 65))
        (s.w! (+ a0-43 8) a1-10)
        )
      (let ((a1-11 #x301ec000))
        (s.w! (+ a0-43 12) a1-11)
        )
      )
    (let ((a0-44 (-> arg0 vis-gifs)))
      (set! (-> a0-44 0 fog0) (the-as uint v1-54))
      (set! (-> a0-44 0 strip) (the-as uint #x303e4000))
      (set! (-> a0-44 0 regs) (the-as uint 1042))
      (set! (-> a0-44 0 fan) (the-as uint #x303ec000))
      )
    (let ((a0-45 (-> arg0 vis-gifs)))
      (set! (-> a0-45 0 fog0) (the-as uint v1-54))
      (set! (-> a0-45 0 strip) (the-as uint #x303e4000))
      (set! (-> a0-45 0 regs) (the-as uint 1042))
      (set! (-> a0-45 0 fan) (the-as uint #x303ec000))
      )
    )
  (if (nonzero? sprite-distorter-generate-tables)
      (sprite-distorter-generate-tables)
      )
  arg0
  )

;; definition for method 0 of type math-camera
(defmethod new math-camera ((allocation symbol) (type-to-make type))
  (let ((gp-0 (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> gp-0 d) 1024.0)
    (set! (-> gp-0 f) 40960000.0)
    (set! (-> gp-0 fov) 11650.845)
    (set! (-> gp-0 x-pix) 256.0)
    (set! (-> gp-0 x-clip) 1024.0)
    (set! (-> gp-0 y-pix) 112.0)
    (set! (-> gp-0 y-clip) 448.0)
    (set! (-> gp-0 fog-start) 40960.0)
    (set! (-> gp-0 fog-end) 819200.0)
    (set! (-> gp-0 fog-max) 255.0)
    (set! (-> gp-0 fog-min) 150.0)
    (matrix-identity! (-> gp-0 inv-camera-rot))
    (matrix-identity! (-> gp-0 camera-rot))
    (vector-reset! (-> gp-0 trans))
    (quaternion-identity! (-> gp-0 quat-other))
    (set-vector! (-> gp-0 trans-other) 0.0 0.0 0.0 1.0)
    (matrix-identity! (-> gp-0 inv-camera-rot-other))
    (matrix-identity! (-> gp-0 camera-rot-other))
    (matrix-identity! (-> gp-0 camera-temp-other))
    (set! (-> gp-0 isometric vector 0 x) 1.0)
    (set! (-> gp-0 isometric vector 1 y) 0.5)
    (set! (-> gp-0 isometric vector 2 z) -1.0)
    (set! (-> gp-0 reset) 1)
    (set! (-> gp-0 smooth-step) 0.0)
    (set! (-> gp-0 smooth-t) 0.0)
    (update-math-camera gp-0 'ntsc 'aspect4x3 (-> gp-0 fov))
    )
  )

;; definition for symbol *math-camera*, type math-camera
(define *math-camera* (new 'global 'math-camera))

;; definition for function math-cam-start-smoothing
(defun math-cam-start-smoothing ((arg0 float) (arg1 float))
  "Unused camera smoothing."
  (set! (-> *math-camera* smooth-step) (/ 1.0 arg0))
  (set! (-> *math-camera* smooth-t) arg1)
  (matrix->quaternion (-> *math-camera* inv-camera-rot-smooth-from) (-> *math-camera* inv-camera-rot-smooth))
  )

;; definition for function move-target-from-pad
;; INFO: Used lq/sq
(defun move-target-from-pad ((arg0 transform) (arg1 int))
  "Unused function to adjust trans based on inputs from the pad.
   This function must be extremely old because it takes a non-quaternion transform,
   and all [[target]] stuff uses quaternions."
  (let ((s4-0 (new-stack-vector0)))
    (set! (-> s4-0 x) (cond
                        ((cpad-hold? arg1 circle)
                         -80.0
                         )
                        ((cpad-hold? arg1 square)
                         80.0
                         )
                        (else
                          0.0
                          )
                        )
          )
    (set! (-> s4-0 y) 0.0)
    (set! (-> s4-0 z) (cond
                        ((cpad-hold? arg1 down)
                         -80.0
                         )
                        ((cpad-hold? arg1 up)
                         80.0
                         )
                        (else
                          0.0
                          )
                        )
          )
    (set! (-> s4-0 w) 1.0)
    (let ((a0-5 (new-stack-vector0))
          (s3-0 (new-stack-matrix0))
          )
      (vector-negate! a0-5 (-> arg0 rot))
      (matrix-rotate-zyx! s3-0 (-> arg0 rot))
      (vector-matrix*! s4-0 s4-0 s3-0)
      )
    (vector+! (-> arg0 trans) (-> arg0 trans) s4-0)
    )
  (set! (-> arg0 trans w) 1.0)
  (if (cpad-hold? arg1 r1)
      (+! (-> arg0 trans y) 80.0)
      )
  (if (cpad-hold? arg1 r2)
      (+! (-> arg0 trans y) -80.0)
      )
  (if (cpad-hold? arg1 x)
      (+! (-> arg0 rot x) 546.13336)
      )
  (if (cpad-hold? arg1 triangle)
      (+! (-> arg0 rot x) -546.13336)
      )
  (if (cpad-hold? arg1 left)
      (+! (-> arg0 rot y) 546.13336)
      )
  (if (cpad-hold? arg1 right)
      (+! (-> arg0 rot y) -546.13336)
      )
  arg0
  )

;; definition for function transform-point-vector!
;; ERROR: Inline assembly instruction marked with TODO - [TODO.VCLIP]
;; ERROR: Unsupported inline assembly instruction kind - [cfc2.i v1, Clipping]
(defun transform-point-vector! ((arg0 vector) (arg1 vector))
  "Apply camera transformation to a point. Return true if it is visible or not.
   This returns the point in GS coords, but as float instead of int, so it's
   not really useful. See [[transform-point-qword!]] for more details."
  (local-vars (v1-2 int))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf23 :class vf)
         (vf24 :class vf)
         (vf25 :class vf)
         (vf26 :class vf)
         (vf27 :class vf)
         (vf28 :class vf)
         (vf29 :class vf)
         (vf30 :class vf)
         (vf31 :class vf)
         )
    (init-vf0-vector)
    0
    (let ((v1-1 *math-camera*))
      (.lvf vf24 (&-> v1-1 camera-temp quad 0))
      (.lvf vf25 (&-> v1-1 camera-temp quad 1))
      (.lvf vf26 (&-> v1-1 camera-temp quad 2))
      (.lvf vf27 (&-> v1-1 camera-temp trans quad))
      (.lvf vf29 (&-> v1-1 hmge-scale quad))
      (.lvf vf30 (&-> v1-1 hvdf-off quad))
      )
    (.lvf vf28 (&-> arg1 quad))
    (.mul.x.vf acc vf24 vf28)
    (.add.mul.y.vf acc vf25 vf28 acc)
    (.add.mul.z.vf acc vf26 vf28 acc)
    (.add.mul.w.vf vf28 vf27 vf0 acc)
    (.add.w.vf vf23 vf0 vf0)
    (.mul.vf vf31 vf28 vf29)
    (TODO.VCLIP vf31 vf31)
    (.div.vf Q vf0 vf31 :fsf #b11 :ftf #b11)
    (.wait.vf)
    (.cfc2.i v1-2 Clipping)
    (.mul.vf vf28 vf28 Q :mask #b111)
    (.mul.vf vf23 vf23 Q)
    (.add.vf vf28 vf28 vf30)
    (.max.x.vf vf28 vf28 vf0 :mask #b1000)
    (.svf (&-> arg0 quad) vf28)
    (not (logtest? v1-2 63))
    )
  )

;; definition for function transform-point-qword!
;; ERROR: Inline assembly instruction marked with TODO - [TODO.VCLIP]
;; ERROR: Unsupported inline assembly instruction kind - [cfc2.i v1, Clipping]
(defun transform-point-qword! ((arg0 vector4w) (arg1 vector))
  "Apply camera transformation to point, returning fixed point 28.4 position
   that can be given to the GS directly."
  (local-vars (v1-2 int))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf23 :class vf)
         (vf24 :class vf)
         (vf25 :class vf)
         (vf26 :class vf)
         (vf27 :class vf)
         (vf28 :class vf)
         (vf29 :class vf)
         (vf30 :class vf)
         (vf31 :class vf)
         )
    (init-vf0-vector)
    0
    (let ((v1-1 *math-camera*))
      (.lvf vf24 (&-> v1-1 camera-temp quad 0))
      (.lvf vf25 (&-> v1-1 camera-temp quad 1))
      (.lvf vf26 (&-> v1-1 camera-temp quad 2))
      (.lvf vf27 (&-> v1-1 camera-temp trans quad))
      (.lvf vf29 (&-> v1-1 hmge-scale quad))
      (.lvf vf30 (&-> v1-1 hvdf-off quad))
      )
    (.lvf vf28 (&-> arg1 quad))
    (.mul.x.vf acc vf24 vf28)
    (.add.mul.y.vf acc vf25 vf28 acc)
    (.add.mul.z.vf acc vf26 vf28 acc)
    (.add.mul.w.vf vf28 vf27 vf0 acc)
    (.add.w.vf vf23 vf0 vf0)
    (.mul.vf vf31 vf28 vf29)
    (TODO.VCLIP vf31 vf31)
    (.div.vf Q vf0 vf31 :fsf #b11 :ftf #b11)
    (.wait.vf)
    (.cfc2.i v1-2 Clipping)
    (.mul.vf vf28 vf28 Q :mask #b111)
    (.mul.vf vf23 vf23 Q)
    (.add.vf vf28 vf28 vf30)
    (.max.x.vf vf28 vf28 vf0 :mask #b1000)
    (vftoi4.xyzw vf28 vf28)
    (.svf (&-> arg0 quad) vf28)
    (not (logtest? v1-2 63))
    )
  )

;; definition for function transform-point-vector-scale!
;; ERROR: Inline assembly instruction marked with TODO - [TODO.VCLIP]
;; ERROR: Unsupported inline assembly instruction kind - [cfc2.i v1, Clipping]
(defun transform-point-vector-scale! ((arg0 vector) (arg1 vector))
  "Similar to transform-point-qword! but returns the scale factor instead."
  (local-vars (v0-0 float) (v1-2 int))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf23 :class vf)
         (vf24 :class vf)
         (vf25 :class vf)
         (vf26 :class vf)
         (vf27 :class vf)
         (vf28 :class vf)
         (vf29 :class vf)
         (vf30 :class vf)
         (vf31 :class vf)
         )
    (init-vf0-vector)
    0
    (let ((v1-1 *math-camera*))
      (.lvf vf24 (&-> v1-1 camera-temp quad 0))
      (.lvf vf25 (&-> v1-1 camera-temp quad 1))
      (.lvf vf26 (&-> v1-1 camera-temp quad 2))
      (.lvf vf27 (&-> v1-1 camera-temp trans quad))
      (.lvf vf29 (&-> v1-1 hmge-scale quad))
      (.lvf vf30 (&-> v1-1 hvdf-off quad))
      )
    (.lvf vf28 (&-> arg1 quad))
    (.mul.x.vf acc vf24 vf28)
    (.add.mul.y.vf acc vf25 vf28 acc)
    (.add.mul.z.vf acc vf26 vf28 acc)
    (.add.mul.w.vf vf28 vf27 vf0 acc)
    (.add.w.vf vf23 vf0 vf0)
    (.mul.vf vf31 vf28 vf29)
    (TODO.VCLIP vf31 vf31)
    (.div.vf Q vf0 vf31 :fsf #b11 :ftf #b11)
    (.wait.vf)
    (.cfc2.i v1-2 Clipping)
    (.mul.vf vf28 vf28 Q :mask #b111)
    (.mul.vf vf23 vf23 Q)
    (.add.vf vf28 vf28 vf30)
    (.max.x.vf vf28 vf28 vf0 :mask #b1000)
    (.svf (&-> arg0 quad) vf28)
    (not (logtest? v1-2 63))
    (.mov v0-0 vf23)
    v0-0
    )
  )

;; definition for function reverse-transform-point!
;; WARN: Return type mismatch vector vs none.
(defun reverse-transform-point! ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 vector))
  "Likely transform arg3 from screen space to world coords, using arg1/arg2 for... something."
  (let* ((v1-1 (-> *math-camera* perspective))
         (s2-0 (-> *math-camera* camera-rot))
         (f30-0 (* (/ (-> v1-1 vector 2 w) (-> v1-1 vector 0 x)) (-> *math-camera* hmge-scale w)))
         (f28-0 (* (/ (-> v1-1 vector 2 w) (-> v1-1 vector 1 y)) (-> *math-camera* hmge-scale w)))
         (s4-0 (vector-rotate*! (new 'stack-no-clear 'vector) arg2 s2-0))
         (v1-3 (vector-matrix*! (new 'stack-no-clear 'vector) arg1 s2-0))
         (f0-8 (/ (+ (* (-> s4-0 x) (-> v1-3 x)) (* (-> s4-0 y) (-> v1-3 y)) (* (-> s4-0 z) (-> v1-3 z)))
                  (+ (* (-> s4-0 x) (-> arg3 x) f30-0) (* (-> s4-0 y) (-> arg3 y) f28-0) (-> s4-0 z))
                  )
               )
         (f1-16 (* (-> arg3 x) f0-8 f30-0))
         (f2-9 (* (-> arg3 y) f0-8 f28-0))
         (t9-2 vector-matrix*!)
         (a0-5 arg0)
         (a1-3 (new 'stack-no-clear 'vector))
         )
    (set! (-> a1-3 x) f1-16)
    (set! (-> a1-3 y) f2-9)
    (set! (-> a1-3 z) f0-8)
    (set! (-> a1-3 w) 1.0)
    (t9-2 a0-5 a1-3 (-> *math-camera* inv-camera-rot))
    )
  (none)
  )

;; definition for function init-for-transform
;; INFO: Used lq/sq
;; WARN: Return type mismatch symbol vs none.
(defun init-for-transform ((arg0 matrix))
  "Sets up VU0 registers with camera info.
   This is probably a very old function and it's only used by camera debug.
   It stashes some data in vector float registers that must be there before calling transform-float-point."
  (local-vars (v1-14 float))
  (rlet ((vf1 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf2 :class vf)
         (vf23 :class vf)
         (vf24 :class vf)
         (vf25 :class vf)
         (vf26 :class vf)
         (vf27 :class vf)
         (vf28 :class vf)
         (vf29 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (let ((gp-0 (new-stack-matrix0))
          (s5-0 (new-stack-matrix0))
          (s4-0 (new 'stack 'vector4s-3))
          (s3-0 (new-stack-vector0))
          )
      (let ((s2-0 (new 'stack 'vector4s-3)))
        (matrix*! s5-0 arg0 (-> *math-camera* camera-temp))
        (matrix-3x3-inverse-transpose! gp-0 arg0)
        (set-vector! s3-0 0.4 0.4 0.4 1.0)
        (let ((v1-4 (-> s4-0 data)))
          (set! (-> v1-4 0) 1.0)
          (set! (-> v1-4 1) 1.0)
          (set! (-> v1-4 2) 1.0)
          (set! (-> v1-4 3) 1.0)
          )
        (let ((v1-5 (&-> s4-0 data 4)))
          (set! (-> v1-5 0) 0.0)
          (set! (-> v1-5 1) 0.0)
          (set! (-> v1-5 2) 0.0)
          (set! (-> v1-5 3) 1.0)
          )
        (let ((v1-6 (&-> s4-0 data 8)))
          (set! (-> v1-6 0) 0.0)
          (set! (-> v1-6 1) 0.0)
          (set! (-> v1-6 2) 0.0)
          (set! (-> v1-6 3) 1.0)
          )
        (let ((v1-7 (-> s2-0 data)))
          (set! (-> v1-7 0) 1.0)
          (set! (-> v1-7 1) 0.0)
          (set! (-> v1-7 2) 0.0)
          (set! (-> v1-7 3) 1.0)
          )
        (let ((v1-8 (&-> s2-0 data 4)))
          (set! (-> v1-8 0) 0.0)
          (set! (-> v1-8 1) 1.0)
          (set! (-> v1-8 2) 0.0)
          (set! (-> v1-8 3) 1.0)
          )
        (let ((v1-9 (&-> s2-0 data 8)))
          (set! (-> v1-9 0) 0.0)
          (set! (-> v1-9 1) 0.0)
          (set! (-> v1-9 2) 1.0)
          (set! (-> v1-9 3) 1.0)
          )
        (.lvf vf7 (&-> *math-camera* hmge-scale quad))
        (.lvf vf8 (&-> *math-camera* hvdf-off quad))
        (.lvf vf9 (&-> *math-camera* giftex))
        (let ((v1-13 255))
          (.mov vf6 v1-13)
          )
        (.mov v1-14 vf6)
        (.itof.vf vf6 vf6)
        (.lvf vf1 (&-> s5-0 quad 0))
        (.lvf vf2 (&-> s5-0 quad 1))
        (.lvf vf3 (&-> s5-0 quad 2))
        (.lvf vf4 (&-> s5-0 trans quad))
        (.lvf vf17 (&-> gp-0 quad 0))
        (.lvf vf18 (&-> gp-0 quad 1))
        (.lvf vf19 (&-> gp-0 quad 2))
        (.lvf vf23 (&-> s2-0 quad 0))
        (.lvf vf24 (&-> s2-0 quad 1))
        (.lvf vf25 (&-> s2-0 quad 2))
        )
      (.lvf vf27 (&-> s4-0 quad 0))
      (.lvf vf28 (&-> s4-0 quad 1))
      (.lvf vf29 (&-> s4-0 quad 2))
      (.lvf vf26 (&-> s3-0 quad))
      )
    (none)
    )
  )
