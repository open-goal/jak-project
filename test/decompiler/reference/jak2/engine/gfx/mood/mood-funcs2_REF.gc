;;-*-Lisp-*-
(in-package goal)

;; definition of type default-interior-states
(deftype default-interior-states (structure)
  ()
  )

;; definition for method 3 of type default-interior-states
(defmethod inspect ((this default-interior-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'default-interior-states)
  (label cfg-4)
  this
  )

;; definition for function update-mood-default-interior
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-default-interior time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (-> arg0 state)
      (set! (-> arg0 times 0 w) 1.0)
      (set! (-> arg0 times 1 w) 1.0)
      (set! (-> arg0 times 2 w) 1.0)
      (set! (-> arg0 times 3 w) 1.0)
      (set! (-> arg0 times 4 w) 1.0)
      (set! (-> arg0 times 5 w) 1.0)
      (set! (-> arg0 times 6 w) 1.0)
      (set! (-> arg0 times 7 w) 1.0)
      )
    )
  0
  (none)
  )

;; definition of type vinroom-states
(deftype vinroom-states (structure)
  ((main      float)
   (flicker1  float)
   (flicker2  float)
   (warp      float)
   )
  )

;; definition for method 3 of type vinroom-states
(defmethod inspect ((this vinroom-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'vinroom-states)
  (format #t "~1Tmain: ~f~%" (-> this main))
  (format #t "~1Tflicker1: ~f~%" (-> this flicker1))
  (format #t "~1Tflicker2: ~f~%" (-> this flicker2))
  (format #t "~1Twarp: ~f~%" (-> this warp))
  (label cfg-4)
  this
  )

;; definition for function update-vinroom-lights
;; WARN: Return type mismatch int vs none.
(defun update-vinroom-lights ((arg0 mood-context))
  (let ((v1-0 (-> arg0 light-group)))
    (set-vector! (-> arg0 current-env-color) 48.0 60.0 96.0 255.0)
    (set-vector! (-> v1-0 0 dir0 color) 0.061 0.854 1.0 1.0)
    (set-vector! (-> v1-0 0 dir1 color) 0.858 0.932 1.0 1.0)
    (let ((a0-4 (-> v1-0 0 dir1)))
      (set! (-> a0-4 direction x) -0.6499)
      (set! (-> a0-4 direction y) 0.7134)
      (set! (-> a0-4 direction z) -0.2619)
      (set! (-> a0-4 direction w) 1.0)
      )
    (set-vector! (-> v1-0 0 dir2 color) 0.858 0.932 1.0 1.0)
    (let ((a0-6 (-> v1-0 0 dir2)))
      (set! (-> a0-6 direction x) 0.4634)
      (set! (-> a0-6 direction y) 0.7718)
      (set! (-> a0-6 direction z) -0.4352)
      (set! (-> a0-6 direction w) 1.0)
      )
    (set-vector! (-> v1-0 0 ambi color) 0.282 0.42 0.637 1.0)
    (set! (-> v1-0 0 dir1 extra x) 1.0)
    (set! (-> v1-0 0 dir2 extra x) 1.0)
    )
  0
  (none)
  )

;; definition for function update-mood-vinroom
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-vinroom time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (update-vinroom-lights arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (let ((gp-0 (the-as (pointer float) (-> arg0 state))))
        (let ((s4-0 (-> arg0 light-group)))
          (set! (-> arg0 times 1 w) (+ 0.875 (* 0.175 (cos (-> gp-0 0)))))
          (set! (-> arg0 times 0 w) 1.0)
          (set! (-> s4-0 0 dir0 extra x) (-> arg0 times 1 w))
          (set! (-> arg0 times 2 w) (if (< 36408.89 (-> gp-0 1))
                                        0.475
                                        0.5
                                        )
                )
          (set! (-> s4-0 0 dir1 extra x) (-> arg0 times 2 w))
          (set! (-> arg0 times 3 w) (if (< 21845.334 (-> gp-0 2))
                                        0.475
                                        0.5
                                        )
                )
          (set! (-> s4-0 0 dir2 extra x) (-> arg0 times 3 w))
          )
        (set! (-> arg0 times 4 w) (+ 1.2 (* 0.2 (cos (-> gp-0 3)))))
        (when (not (paused?))
          (let ((f0-17 (+ (-> gp-0 0) (* 18204.445 (seconds-per-frame)))))
            (set! (-> gp-0 0) (- f0-17 (* (the float (the int (/ f0-17 65536.0))) 65536.0)))
            )
          (let ((f0-20 (+ (-> gp-0 1) (* 196608.0 (seconds-per-frame)))))
            (set! (-> gp-0 1) (- f0-20 (* (the float (the int (/ f0-20 65536.0))) 65536.0)))
            )
          (let ((f0-23 (+ (-> gp-0 2) (* 163840.0 (seconds-per-frame)))))
            (set! (-> gp-0 2) (- f0-23 (* (the float (the int (/ f0-23 65536.0))) 65536.0)))
            )
          (let ((f0-26 (+ (-> gp-0 3) (* 32768.0 (seconds-per-frame)))))
            (set! (-> gp-0 3) (- f0-26 (* (the float (the int (/ f0-26 65536.0))) 65536.0)))
            )
          )
        )
      )
    )
  0
  (none)
  )

;; definition of type hideout-states
(deftype hideout-states (structure)
  ((flame0  flames-state  :inline)
   (flame1  flames-state  :inline)
   )
  )

;; definition for method 3 of type hideout-states
(defmethod inspect ((this hideout-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'hideout-states)
  (format #t "~1Tflame0: #<flames-state @ #x~X>~%" (-> this flame0))
  (format #t "~1Tflame1: #<flames-state @ #x~X>~%" (-> this flame1))
  (label cfg-4)
  this
  )

;; definition for function update-hideout-lights
;; WARN: Return type mismatch int vs none.
(defun update-hideout-lights ((arg0 mood-context))
  (let ((a2-0 (-> arg0 light-group))
        (a1-0 (-> arg0 light-group 1))
        (v1-0 (-> arg0 light-group 2))
        )
    (set-vector! (-> a2-0 0 dir0 color) 0.0 0.0 0.0 1.0)
    (set-vector! (-> a2-0 0 ambi color) 0.22 0.219 0.35 1.0)
    (let ((a0-3 (-> a1-0 dir0)))
      (set! (-> a0-3 direction x) 0.0)
      (set! (-> a0-3 direction y) -1.0)
      (set! (-> a0-3 direction z) 0.0)
      (set! (-> a0-3 direction w) 1.0)
      )
    (set-vector! (-> a1-0 dir0 color) 1.0 0.8 0.4 1.0)
    (set! (-> a1-0 dir0 extra x) 1.0)
    (set-vector! (-> a1-0 ambi color) 0.22 0.219 0.35 1.0)
    (set! (-> a1-0 ambi extra x) 1.0)
    (let ((a0-8 (-> v1-0 dir0)))
      (set! (-> a0-8 direction x) 0.331)
      (set! (-> a0-8 direction y) 0.943)
      (set! (-> a0-8 direction z) 0.0)
      (set! (-> a0-8 direction w) 1.0)
      )
    (set-vector! (-> v1-0 dir0 color) 0.256 0.685 0.573 1.0)
    (set! (-> v1-0 dir0 extra x) 1.0)
    (let ((a0-11 (-> v1-0 dir1)))
      (set! (-> a0-11 direction x) -1.0)
      (set! (-> a0-11 direction y) 0.0)
      (set! (-> a0-11 direction z) 0.0)
      (set! (-> a0-11 direction w) 1.0)
      )
    (set-vector! (-> v1-0 dir1 color) 0.202 0.205 0.15 1.0)
    (set! (-> v1-0 dir1 extra x) 1.0)
    (set-vector! (-> v1-0 ambi color) 0.22 0.219 0.35 1.0)
    (set! (-> v1-0 ambi extra x) 1.0)
    )
  0
  (none)
  )

;; definition for function update-mood-hideout
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-hideout time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (update-hideout-lights arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (set! (-> arg0 times 0 w) 1.0)
      (cond
        ((movie?)
         (update-mood-flames arg0 1 2 0 0.333 0.0005859375 2.0)
         (update-mood-flames arg0 3 2 8 0.333 0.0005859375 3.0)
         )
        (else
          (update-mood-flames arg0 1 2 0 0.333 0.001953125 2.0)
          (update-mood-flames arg0 3 2 8 0.333 0.001953125 3.0)
          )
        )
      (let ((a0-10 (new 'stack-no-clear 'sphere))
            (a1-4 (-> *math-camera* trans))
            )
        (let ((v1-6 a0-10))
          (set! (-> v1-6 x) 4898816.0)
          (set! (-> v1-6 y) 32768.0)
          (set! (-> v1-6 z) 245760.0)
          (set! (-> v1-6 r) 1.0)
          )
        (let ((f0-5 (get-sphere-interp a0-10 a1-4 61440.0 69632.0)))
          (set-vector! (-> arg0 times 0) 1.0 1.0 1.0 1.0)
          (vector-lerp!
            (the-as vector (-> arg0 times))
            (the-as vector (-> arg0 times))
            (the-as vector (-> *level* default-level mood-context times))
            f0-5
            )
          )
        )
      )
    )
  0
  (none)
  )

;; definition for function update-mood-copy-hideout
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-copy-hideout time-of-day-proc ((arg0 mood-context))
  (let ((v1-1 (level-get *level* 'hideout)))
    (if (and v1-1 (= (-> v1-1 status) 'active))
        (mem-copy! (the-as pointer arg0) (the-as pointer (-> v1-1 mood-context)) 1968)
        )
    )
  0
  (none)
  )

;; definition of type hiphog-states
(deftype hiphog-states (structure)
  ((spec-m-on         sp-field-init-spec)
   (spec-o-on         sp-field-init-spec)
   (spec-r-on         sp-field-init-spec)
   (spec-g-on         sp-field-init-spec)
   (spec-a-on         sp-field-init-spec)
   (spec-n-on         sp-field-init-spec)
   (spec-m-off        sp-field-init-spec)
   (spec-o-off        sp-field-init-spec)
   (spec-r-off        sp-field-init-spec)
   (spec-g-off        sp-field-init-spec)
   (spec-a-off        sp-field-init-spec)
   (spec-n-off        sp-field-init-spec)
   (spec-hog-1-on     sp-field-init-spec)
   (spec-hog-2-on     sp-field-init-spec)
   (spec-hiphog-on    sp-field-init-spec)
   (spec-hiphog-off   sp-field-init-spec)
   (spec-hiphog-on2   sp-field-init-spec)
   (spec-hiphog-off2  sp-field-init-spec)
   (spec-clock-sun    sp-field-init-spec)
   (spec-clock-moon   sp-field-init-spec)
   (door              entity)
   (m-on              uint8)
   (o-on              uint8)
   (r-on              uint8)
   (g-on              uint8)
   (a-on              uint8)
   (n-on              uint8)
   (m-off             uint8)
   (o-off             uint8)
   (r-off             uint8)
   (g-off             uint8)
   (a-off             uint8)
   (n-off             uint8)
   (hog-on            uint8)
   (hiphog-on         uint8)
   (hiphog-off        uint8)
   (clock-sun         uint8)
   (clock-moon        uint8)
   )
  )

;; definition for method 3 of type hiphog-states
(defmethod inspect ((this hiphog-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'hiphog-states)
  (format #t "~1Tspec-m-on: #<sp-field-init-spec @ #x~X>~%" (-> this spec-m-on))
  (format #t "~1Tspec-o-on: #<sp-field-init-spec @ #x~X>~%" (-> this spec-o-on))
  (format #t "~1Tspec-r-on: #<sp-field-init-spec @ #x~X>~%" (-> this spec-r-on))
  (format #t "~1Tspec-g-on: #<sp-field-init-spec @ #x~X>~%" (-> this spec-g-on))
  (format #t "~1Tspec-a-on: #<sp-field-init-spec @ #x~X>~%" (-> this spec-a-on))
  (format #t "~1Tspec-n-on: #<sp-field-init-spec @ #x~X>~%" (-> this spec-n-on))
  (format #t "~1Tspec-m-off: #<sp-field-init-spec @ #x~X>~%" (-> this spec-m-off))
  (format #t "~1Tspec-o-off: #<sp-field-init-spec @ #x~X>~%" (-> this spec-o-off))
  (format #t "~1Tspec-r-off: #<sp-field-init-spec @ #x~X>~%" (-> this spec-r-off))
  (format #t "~1Tspec-g-off: #<sp-field-init-spec @ #x~X>~%" (-> this spec-g-off))
  (format #t "~1Tspec-a-off: #<sp-field-init-spec @ #x~X>~%" (-> this spec-a-off))
  (format #t "~1Tspec-n-off: #<sp-field-init-spec @ #x~X>~%" (-> this spec-n-off))
  (format #t "~1Tspec-hog-1-on: #<sp-field-init-spec @ #x~X>~%" (-> this spec-hog-1-on))
  (format #t "~1Tspec-hog-2-on: #<sp-field-init-spec @ #x~X>~%" (-> this spec-hog-2-on))
  (format #t "~1Tspec-hiphog-on: #<sp-field-init-spec @ #x~X>~%" (-> this spec-hiphog-on))
  (format #t "~1Tspec-hiphog-off: #<sp-field-init-spec @ #x~X>~%" (-> this spec-hiphog-off))
  (format #t "~1Tspec-hiphog-on2: #<sp-field-init-spec @ #x~X>~%" (-> this spec-hiphog-on2))
  (format #t "~1Tspec-hiphog-off2: #<sp-field-init-spec @ #x~X>~%" (-> this spec-hiphog-off2))
  (format #t "~1Tspec-clock-sun: #<sp-field-init-spec @ #x~X>~%" (-> this spec-clock-sun))
  (format #t "~1Tspec-clock-moon: #<sp-field-init-spec @ #x~X>~%" (-> this spec-clock-moon))
  (format #t "~1Tdoor: ~A~%" (-> this door))
  (format #t "~1Tm-on: ~D~%" (-> this m-on))
  (format #t "~1To-on: ~D~%" (-> this o-on))
  (format #t "~1Tr-on: ~D~%" (-> this r-on))
  (format #t "~1Tg-on: ~D~%" (-> this g-on))
  (format #t "~1Ta-on: ~D~%" (-> this a-on))
  (format #t "~1Tn-on: ~D~%" (-> this n-on))
  (format #t "~1Tm-off: ~D~%" (-> this m-off))
  (format #t "~1To-off: ~D~%" (-> this o-off))
  (format #t "~1Tr-off: ~D~%" (-> this r-off))
  (format #t "~1Tg-off: ~D~%" (-> this g-off))
  (format #t "~1Ta-off: ~D~%" (-> this a-off))
  (format #t "~1Tn-off: ~D~%" (-> this n-off))
  (format #t "~1Thog-on: ~D~%" (-> this hog-on))
  (format #t "~1Thiphog-on: ~D~%" (-> this hiphog-on))
  (format #t "~1Thiphog-off: ~D~%" (-> this hiphog-off))
  (format #t "~1Tclock-sun: ~D~%" (-> this clock-sun))
  (format #t "~1Tclock-moon: ~D~%" (-> this clock-moon))
  (label cfg-4)
  this
  )

;; definition for function init-mood-hiphog
;; WARN: Return type mismatch entity vs none.
(defun init-mood-hiphog ((arg0 mood-context))
  (let ((gp-0 (the-as hiphog-states (-> arg0 state))))
    (let ((a0-1 (-> *part-id-table* 19)))
      (set! (-> gp-0 spec-m-on) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-1)
          (set! (-> gp-0 spec-m-on) (get-field-spec-by-id a0-1 (sp-field-id spt-r)))
          )
      )
    (let ((a0-2 (-> *part-id-table* 20)))
      (set! (-> gp-0 spec-o-on) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-2)
          (set! (-> gp-0 spec-o-on) (get-field-spec-by-id a0-2 (sp-field-id spt-r)))
          )
      )
    (let ((a0-3 (-> *part-id-table* 21)))
      (set! (-> gp-0 spec-r-on) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-3)
          (set! (-> gp-0 spec-r-on) (get-field-spec-by-id a0-3 (sp-field-id spt-r)))
          )
      )
    (let ((a0-4 (-> *part-id-table* 22)))
      (set! (-> gp-0 spec-g-on) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-4)
          (set! (-> gp-0 spec-g-on) (get-field-spec-by-id a0-4 (sp-field-id spt-r)))
          )
      )
    (let ((a0-5 (-> *part-id-table* 23)))
      (set! (-> gp-0 spec-a-on) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-5)
          (set! (-> gp-0 spec-a-on) (get-field-spec-by-id a0-5 (sp-field-id spt-r)))
          )
      )
    (let ((a0-6 (-> *part-id-table* 24)))
      (set! (-> gp-0 spec-n-on) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-6)
          (set! (-> gp-0 spec-n-on) (get-field-spec-by-id a0-6 (sp-field-id spt-r)))
          )
      )
    (let ((a0-7 (-> *part-id-table* 25)))
      (set! (-> gp-0 spec-m-off) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-7)
          (set! (-> gp-0 spec-m-off) (get-field-spec-by-id a0-7 (sp-field-id spt-r)))
          )
      )
    (let ((a0-8 (-> *part-id-table* 26)))
      (set! (-> gp-0 spec-o-off) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-8)
          (set! (-> gp-0 spec-o-off) (get-field-spec-by-id a0-8 (sp-field-id spt-r)))
          )
      )
    (let ((a0-9 (-> *part-id-table* 27)))
      (set! (-> gp-0 spec-r-off) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-9)
          (set! (-> gp-0 spec-r-off) (get-field-spec-by-id a0-9 (sp-field-id spt-r)))
          )
      )
    (let ((a0-10 (-> *part-id-table* 28)))
      (set! (-> gp-0 spec-g-off) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-10)
          (set! (-> gp-0 spec-g-off) (get-field-spec-by-id a0-10 (sp-field-id spt-r)))
          )
      )
    (let ((a0-11 (-> *part-id-table* 29)))
      (set! (-> gp-0 spec-a-off) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-11)
          (set! (-> gp-0 spec-a-off) (get-field-spec-by-id a0-11 (sp-field-id spt-r)))
          )
      )
    (let ((a0-12 (-> *part-id-table* 30)))
      (set! (-> gp-0 spec-n-off) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-12)
          (set! (-> gp-0 spec-n-off) (get-field-spec-by-id a0-12 (sp-field-id spt-r)))
          )
      )
    (let ((a0-13 (-> *part-id-table* 31)))
      (set! (-> gp-0 spec-hog-1-on) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-13)
          (set! (-> gp-0 spec-hog-1-on) (get-field-spec-by-id a0-13 (sp-field-id spt-r)))
          )
      )
    (let ((a0-14 (-> *part-id-table* 32)))
      (set! (-> gp-0 spec-hog-2-on) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-14)
          (set! (-> gp-0 spec-hog-2-on) (get-field-spec-by-id a0-14 (sp-field-id spt-r)))
          )
      )
    (let ((a0-15 (-> *part-id-table* 33)))
      (set! (-> gp-0 spec-hiphog-on) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-15)
          (set! (-> gp-0 spec-hiphog-on) (get-field-spec-by-id a0-15 (sp-field-id spt-r)))
          )
      )
    (let ((a0-16 (-> *part-id-table* 34)))
      (set! (-> gp-0 spec-hiphog-off) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-16)
          (set! (-> gp-0 spec-hiphog-off) (get-field-spec-by-id a0-16 (sp-field-id spt-r)))
          )
      )
    (let ((a0-17 (-> *part-id-table* 35)))
      (set! (-> gp-0 spec-hiphog-on2) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-17)
          (set! (-> gp-0 spec-hiphog-on2) (get-field-spec-by-id a0-17 (sp-field-id spt-r)))
          )
      )
    (let ((a0-18 (-> *part-id-table* 36)))
      (set! (-> gp-0 spec-hiphog-off2) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-18)
          (set! (-> gp-0 spec-hiphog-off2) (get-field-spec-by-id a0-18 (sp-field-id spt-r)))
          )
      )
    (let ((a0-19 (-> *part-id-table* 37)))
      (set! (-> gp-0 spec-clock-sun) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-19)
          (set! (-> gp-0 spec-clock-sun) (get-field-spec-by-id a0-19 (sp-field-id spt-r)))
          )
      )
    (let ((a0-20 (-> *part-id-table* 38)))
      (set! (-> gp-0 spec-clock-moon) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-20)
          (set! (-> gp-0 spec-clock-moon) (get-field-spec-by-id a0-20 (sp-field-id spt-r)))
          )
      )
    (set! (-> gp-0 m-on) (the-as uint 128))
    (set! (-> gp-0 o-on) (the-as uint 128))
    (set! (-> gp-0 r-on) (the-as uint 128))
    (set! (-> gp-0 g-on) (the-as uint 128))
    (set! (-> gp-0 a-on) (the-as uint 128))
    (set! (-> gp-0 n-on) (the-as uint 128))
    (set! (-> gp-0 m-off) (the-as uint 128))
    (set! (-> gp-0 o-off) (the-as uint 128))
    (set! (-> gp-0 r-off) (the-as uint 128))
    (set! (-> gp-0 g-off) (the-as uint 128))
    (set! (-> gp-0 a-off) (the-as uint 128))
    (set! (-> gp-0 n-off) (the-as uint 128))
    (set! (-> gp-0 hog-on) (the-as uint 128))
    (set! (-> gp-0 hiphog-on) (the-as uint 128))
    (set! (-> gp-0 hiphog-off) (the-as uint 128))
    (set! (-> gp-0 clock-sun) (the-as uint 128))
    (set! (-> gp-0 clock-moon) (the-as uint 128))
    (set! (-> gp-0 door) (entity-by-name "hip-door-b-1"))
    )
  (none)
  )

;; definition for function update-hiphog-lights
;; WARN: Return type mismatch int vs none.
(defun update-hiphog-lights ((arg0 mood-context))
  (let ((t1-0 (-> arg0 light-group))
        (t0-0 (-> arg0 light-group 1))
        (a3-0 (-> arg0 light-group 2))
        (a2-0 (-> arg0 light-group 3))
        (a1-0 (-> arg0 light-group 4))
        (v1-0 (-> arg0 light-group 5))
        )
    (set-vector! (-> t1-0 0 dir0 color) 0.0 0.0 0.0 1.0)
    (set-vector! (-> t1-0 0 ambi color) 0.11 0.109 0.175 1.0)
    (set-vector! (-> t0-0 dir0 color) 0.945 0.648 0.523 1.0)
    (let ((a0-4 (-> t0-0 dir0)))
      (set! (-> a0-4 direction x) 0.0)
      (set! (-> a0-4 direction y) 1.0)
      (set! (-> a0-4 direction z) 0.0)
      (set! (-> a0-4 direction w) 1.0)
      )
    (set! (-> t0-0 dir0 extra x) 1.0)
    (set-vector! (-> t0-0 ambi color) 0.197 0.124 0.062 1.0)
    (set! (-> t0-0 ambi extra x) 1.0)
    (set-vector! (-> a3-0 dir0 color) 0.945 0.648 0.523 1.0)
    (set-vector! (-> a3-0 dir1 color) 1.0 0.237 0.386 1.0)
    (set-vector! (-> a3-0 ambi color) 0.197 0.124 0.062 1.0)
    (let ((a0-11 (-> a3-0 dir0)))
      (set! (-> a0-11 direction x) 0.0)
      (set! (-> a0-11 direction y) 1.0)
      (set! (-> a0-11 direction z) 0.0)
      (set! (-> a0-11 direction w) 1.0)
      )
    (let ((a0-12 (-> a3-0 dir1)))
      (set! (-> a0-12 direction x) 0.0)
      (set! (-> a0-12 direction y) -1.0)
      (set! (-> a0-12 direction z) 0.0)
      (set! (-> a0-12 direction w) 1.0)
      )
    (set! (-> a3-0 dir0 extra x) 1.0)
    (set! (-> a3-0 dir1 extra x) 1.0)
    (set! (-> a3-0 ambi extra x) 1.0)
    (set-vector! (-> a2-0 dir0 color) 0.945 0.648 0.523 1.0)
    (set-vector! (-> a2-0 dir1 color) 0.02 0.97 0.0 1.0)
    (set-vector! (-> a2-0 dir2 color) 1.0 0.237 0.386 1.0)
    (set-vector! (-> a2-0 ambi color) 0.197 0.124 0.062 1.0)
    (let ((a0-20 (-> a2-0 dir0)))
      (set! (-> a0-20 direction x) 0.0)
      (set! (-> a0-20 direction y) 1.0)
      (set! (-> a0-20 direction z) 0.0)
      (set! (-> a0-20 direction w) 1.0)
      )
    (let ((a0-21 (-> a2-0 dir1)))
      (set! (-> a0-21 direction x) 0.0)
      (set! (-> a0-21 direction y) -1.0)
      (set! (-> a0-21 direction z) 0.0)
      (set! (-> a0-21 direction w) 1.0)
      )
    (let ((a0-22 (-> a2-0 dir2)))
      (set! (-> a0-22 direction x) 1.0)
      (set! (-> a0-22 direction y) 0.0)
      (set! (-> a0-22 direction z) 0.0)
      (set! (-> a0-22 direction w) 1.0)
      )
    (set! (-> a2-0 dir0 extra x) 1.0)
    (set! (-> a2-0 dir1 extra x) 1.0)
    (set! (-> a2-0 dir2 extra x) 1.0)
    (set! (-> a2-0 ambi extra x) 1.0)
    (set-vector! (-> a1-0 dir0 color) 0.945 0.648 0.523 1.0)
    (set-vector! (-> a1-0 dir1 color) 0.02 0.97 0.0 1.0)
    (set-vector! (-> a1-0 dir2 color) 1.0 0.237 0.386 1.0)
    (set-vector! (-> a1-0 ambi color) 0.197 0.124 0.062 1.0)
    (let ((a0-31 (-> a1-0 dir0)))
      (set! (-> a0-31 direction x) 0.0)
      (set! (-> a0-31 direction y) 1.0)
      (set! (-> a0-31 direction z) 0.0)
      (set! (-> a0-31 direction w) 1.0)
      )
    (let ((a0-32 (-> a1-0 dir1)))
      (set! (-> a0-32 direction x) 0.0)
      (set! (-> a0-32 direction y) -1.0)
      (set! (-> a0-32 direction z) 0.0)
      (set! (-> a0-32 direction w) 1.0)
      )
    (let ((a0-33 (-> a1-0 dir2)))
      (set! (-> a0-33 direction x) -1.0)
      (set! (-> a0-33 direction y) 0.0)
      (set! (-> a0-33 direction z) 0.0)
      (set! (-> a0-33 direction w) 1.0)
      )
    (set! (-> a1-0 dir0 extra x) 1.0)
    (set! (-> a1-0 dir1 extra x) 1.0)
    (set! (-> a1-0 dir2 extra x) 1.0)
    (set! (-> a1-0 ambi extra x) 1.0)
    (set-vector! (-> v1-0 dir0 color) 0.9992 0.6868 0.7258 1.0)
    (set-vector! (-> v1-0 dir1 color) 0.9992 0.6868 0.7258 1.0)
    (set-vector! (-> v1-0 dir2 color) 0.9 0.9 0.9 1.0)
    (set-vector! (-> v1-0 ambi color) 0.197 0.124 0.062 1.0)
    (let ((a0-42 (-> v1-0 dir0)))
      (set! (-> a0-42 direction x) 0.028)
      (set! (-> a0-42 direction y) 0.731)
      (set! (-> a0-42 direction z) -0.681)
      (set! (-> a0-42 direction w) 1.0)
      )
    (let ((a0-43 (-> v1-0 dir1)))
      (set! (-> a0-43 direction x) -0.472)
      (set! (-> a0-43 direction y) 0.719)
      (set! (-> a0-43 direction z) 0.519)
      (set! (-> a0-43 direction w) 1.0)
      )
    (let ((a0-44 (-> v1-0 dir2)))
      (set! (-> a0-44 direction x) 0.242)
      (set! (-> a0-44 direction y) 0.786)
      (set! (-> a0-44 direction z) 0.567)
      (set! (-> a0-44 direction w) 1.0)
      )
    (set! (-> v1-0 dir0 extra x) 1.0)
    (set! (-> v1-0 dir1 extra x) 0.75)
    (set! (-> v1-0 dir2 extra x) 0.0)
    (set! (-> v1-0 ambi extra x) 1.0)
    )
  0
  (none)
  )

;; definition for function update-mood-hiphog
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-hiphog time-of-day-proc ((arg0 mood-context) (arg1 float))
  (update-mood-interior arg0)
  (update-hiphog-lights arg0)
  (set! (-> arg0 light-group 0 dir0 extra x) 0.0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (set! (-> arg0 times 1 w) 1.0)
      (let ((v1-5 (-> *display* part-clock frame-counter))
            (s5-0 (the-as hiphog-states (-> arg0 state)))
            )
        (let ((f6-0 (the float (-> s5-0 m-on)))
              (f5-0 (the float (-> s5-0 o-on)))
              (f3-0 (the float (-> s5-0 r-on)))
              (f2-0 (the float (-> s5-0 g-on)))
              (f1-0 (the float (-> s5-0 a-on)))
              (f0-8 (the float (-> s5-0 n-on)))
              )
          (if (nonzero? (-> s5-0 spec-m-on))
              (set! (-> s5-0 spec-hog-1-on initial-valuef) f6-0)
              )
          (if (nonzero? (-> s5-0 spec-o-on))
              (set! (-> s5-0 spec-hog-1-on initial-valuef) f5-0)
              )
          (if (nonzero? (-> s5-0 spec-r-on))
              (set! (-> s5-0 spec-hog-1-on initial-valuef) f3-0)
              )
          (if (nonzero? (-> s5-0 spec-g-on))
              (set! (-> s5-0 spec-hog-1-on initial-valuef) f2-0)
              )
          (if (nonzero? (-> s5-0 spec-a-on))
              (set! (-> s5-0 spec-hog-1-on initial-valuef) f1-0)
              )
          (if (nonzero? (-> s5-0 spec-n-on))
              (set! (-> s5-0 spec-hog-1-on initial-valuef) f0-8)
              )
          (let ((a0-37 (mod v1-5 800))
                (f4-0 0.0)
                )
            (if (or (and (>= a0-37 100) (< a0-37 400)) (>= a0-37 500))
                (+! f4-0 f6-0)
                )
            (if (or (and (>= a0-37 150) (< a0-37 400)) (>= a0-37 500))
                (+! f4-0 f5-0)
                )
            (if (or (and (>= a0-37 200) (< a0-37 400)) (>= a0-37 500))
                (+! f4-0 f3-0)
                )
            (if (or (and (>= a0-37 250) (< a0-37 400)) (>= a0-37 500))
                (+! f4-0 f2-0)
                )
            (if (or (and (>= a0-37 300) (< a0-37 400)) (>= a0-37 500))
                (+! f4-0 f1-0)
                )
            (if (or (and (>= a0-37 350) (< a0-37 400)) (>= a0-37 500))
                (+! f4-0 f0-8)
                )
            (let ((f0-10 (* 0.0006510417 f4-0)))
              (set! (-> arg0 times 2 w) f0-10)
              (set! (-> arg0 light-group 3 dir1 extra x) f0-10)
              )
            )
          )
        (let ((f5-1 (the float (-> s5-0 m-off)))
              (f4-1 (the float (-> s5-0 o-off)))
              (f3-1 (the float (-> s5-0 r-off)))
              (f2-1 (the float (-> s5-0 g-off)))
              (f1-1 (the float (-> s5-0 a-off)))
              (f0-17 (the float (-> s5-0 n-off)))
              )
          (if (nonzero? (-> s5-0 spec-m-off))
              (set! (-> s5-0 spec-hog-1-on initial-valuef) f5-1)
              )
          (if (nonzero? (-> s5-0 spec-o-off))
              (set! (-> s5-0 spec-hog-1-on initial-valuef) f4-1)
              )
          (if (nonzero? (-> s5-0 spec-r-off))
              (set! (-> s5-0 spec-hog-1-on initial-valuef) f3-1)
              )
          (if (nonzero? (-> s5-0 spec-g-off))
              (set! (-> s5-0 spec-hog-1-on initial-valuef) f2-1)
              )
          (if (nonzero? (-> s5-0 spec-a-off))
              (set! (-> s5-0 spec-hog-1-on initial-valuef) f1-1)
              )
          (if (nonzero? (-> s5-0 spec-n-off))
              (set! (-> s5-0 spec-hog-1-on initial-valuef) f0-17)
              )
          )
        (let ((f0-19 (the float (-> s5-0 hog-on))))
          (if (nonzero? (-> s5-0 spec-hog-1-on))
              (set! (-> s5-0 spec-hog-1-on initial-valuef) f0-19)
              )
          (if (nonzero? (-> s5-0 spec-hog-2-on))
              (set! (-> s5-0 spec-hog-2-on initial-valuef) f0-19)
              )
          (set! (-> arg0 times 3 w) (+ 0.5 (* 0.0009765625 f0-19)))
          )
        (set! (-> arg0 light-group 4 dir1 extra x) (-> arg0 times 3 w))
        (let ((v1-6 (mod v1-5 600)))
          (cond
            ((< 300 v1-6)
             (let ((f0-24 (the float (-> s5-0 hiphog-on))))
               (if (nonzero? (-> s5-0 spec-hiphog-on))
                   (set! (-> s5-0 spec-hiphog-on initial-valuef) f0-24)
                   )
               (if (nonzero? (-> s5-0 spec-hiphog-on2))
                   (set! (-> s5-0 spec-hiphog-on2 initial-valuef) f0-24)
                   )
               (set! (-> arg0 times 4 w) (* 0.001953125 f0-24))
               )
             )
            (else
              (let ((f0-27 (the float (-> s5-0 hiphog-off))))
                (if (nonzero? (-> s5-0 spec-hiphog-off))
                    (set! (-> s5-0 spec-hiphog-off initial-valuef) f0-27)
                    )
                (if (nonzero? (-> s5-0 spec-hiphog-off2))
                    (set! (-> s5-0 spec-hiphog-off2 initial-valuef) f0-27)
                    )
                )
              )
            )
          )
        (cond
          ((or (>= arg1 18.0) (>= 6.0 arg1))
           (let ((f0-31 (the float (-> s5-0 clock-moon))))
             (if (nonzero? (-> s5-0 spec-clock-moon))
                 (set! (-> s5-0 spec-clock-moon initial-valuef) f0-31)
                 )
             (set-vector! (-> arg0 times 5) 0.471 0.722 1.0 (+ 0.5 (* 0.001953125 f0-31)))
             )
           )
          (else
            (let ((f0-35 (the float (-> s5-0 clock-sun))))
              (if (nonzero? (-> s5-0 spec-clock-sun))
                  (set! (-> s5-0 spec-clock-sun initial-valuef) f0-35)
                  )
              (set-vector! (-> arg0 times 5) 1.0 0.99 0.54 (+ 0.5 (* 0.0009765625 f0-35)))
              )
            )
          )
        (when (not (paused?))
          (set! (-> s5-0 m-on) (the-as uint (the int (rand-vu-float-range 64.0 192.0))))
          (set! (-> s5-0 o-on) (the-as uint (the int (rand-vu-float-range 64.0 192.0))))
          (set! (-> s5-0 r-on) (the-as uint (the int (rand-vu-float-range 64.0 192.0))))
          (set! (-> s5-0 g-on) (the-as uint (the int (rand-vu-float-range 64.0 192.0))))
          (set! (-> s5-0 a-on) (the-as uint (the int (rand-vu-float-range 64.0 192.0))))
          (set! (-> s5-0 n-on) (the-as uint (the int (rand-vu-float-range 64.0 192.0))))
          (set! (-> s5-0 m-off) (the-as uint (the int (rand-vu-float-range 116.0 132.0))))
          (set! (-> s5-0 o-off) (the-as uint (the int (rand-vu-float-range 116.0 132.0))))
          (set! (-> s5-0 r-off) (the-as uint (the int (rand-vu-float-range 116.0 132.0))))
          (set! (-> s5-0 g-off) (the-as uint (the int (rand-vu-float-range 116.0 132.0))))
          (set! (-> s5-0 a-off) (the-as uint (the int (rand-vu-float-range 116.0 132.0))))
          (set! (-> s5-0 n-off) (the-as uint (the int (rand-vu-float-range 116.0 132.0))))
          (set! (-> s5-0 hog-on) (the-as uint (the int (rand-vu-float-range 64.0 192.0))))
          (set! (-> s5-0 hiphog-on) (the-as uint (the int (rand-vu-float-range 64.0 192.0))))
          (set! (-> s5-0 hiphog-off) (the-as uint (the int (rand-vu-float-range 116.0 132.0))))
          (set! (-> s5-0 clock-sun) (the-as uint (the int (rand-vu-float-range 64.0 192.0))))
          (set! (-> s5-0 clock-moon) (the-as uint (the int (rand-vu-float-range 64.0 192.0))))
          )
        (if (and (-> s5-0 door) (not (logtest? (-> s5-0 door extra perm status) (entity-perm-status subtask-complete))))
            (set! (-> arg0 times 0 quad) (-> *level* default-level mood-context times 0 quad))
            )
        )
      (let ((a0-121 (new 'stack-no-clear 'sphere))
            (a1-40 (-> *math-camera* trans))
            )
        (let ((v1-67 a0-121))
          (set! (-> v1-67 x) -364544.0)
          (set! (-> v1-67 y) 0.0)
          (set! (-> v1-67 z) 5324800.0)
          (set! (-> v1-67 r) 1.0)
          )
        (let ((f0-76 (get-sphere-interp a0-121 a1-40 139264.0 24576.0)))
          (vector-lerp!
            (the-as vector (-> arg0 times))
            (the-as vector (-> arg0 times))
            (the-as vector (-> *level* default-level mood-context times))
            f0-76
            )
          )
        )
      )
    )
  0
  (none)
  )

;; definition for function update-mood-copy-hiphog
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-copy-hiphog time-of-day-proc ((arg0 mood-context))
  (let ((v1-1 (level-get *level* 'hiphog)))
    (if (and v1-1 (= (-> v1-1 status) 'active))
        (mem-copy! (the-as pointer arg0) (the-as pointer (-> v1-1 mood-context)) 1968)
        )
    )
  0
  (none)
  )

;; definition of type sewer-states
(deftype sewer-states (structure)
  ((light-flag         symbol)
   (light-count        uint32)
   (turret-value       float)
   (spec-light-center  sp-field-init-spec)
   (spec-light         sp-field-init-spec)
   (explosion          float)
   )
  )

;; definition for method 3 of type sewer-states
(defmethod inspect ((this sewer-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'sewer-states)
  (format #t "~1Tlight-flag: ~A~%" (-> this light-flag))
  (format #t "~1Tlight-count: ~D~%" (-> this light-count))
  (format #t "~1Tturret-value: ~f~%" (-> this turret-value))
  (format #t "~1Tspec-light-center: #<sp-field-init-spec @ #x~X>~%" (-> this spec-light-center))
  (format #t "~1Tspec-light: #<sp-field-init-spec @ #x~X>~%" (-> this spec-light))
  (format #t "~1Texplosion: ~f~%" (-> this explosion))
  (label cfg-4)
  this
  )

;; definition for function update-sewer-lights
;; WARN: Return type mismatch int vs none.
(defun update-sewer-lights ((arg0 mood-context))
  (let ((v1-0 (-> arg0 light-group)))
    (set-vector! (-> v1-0 0 dir0 color) 0.822 0.694 0.613 1.0)
    (set-vector! (-> v1-0 0 ambi color) 0.083 0.139 0.157 1.0)
    )
  (let ((a3-0 (-> arg0 light-group 1))
        (a2-4 (-> arg0 light-group 2))
        (a1-5 (-> arg0 light-group 3))
        (v1-2 (-> arg0 light-group 4))
        )
    (set-vector! (-> a3-0 ambi color) 0.083 0.139 0.157 1.0)
    (set! (-> a3-0 ambi extra x) 1.0)
    (let ((a0-3 (-> a3-0 dir0)))
      (set! (-> a0-3 direction x) 0.0)
      (set! (-> a0-3 direction y) 1.0)
      (set! (-> a0-3 direction z) 0.0)
      (set! (-> a0-3 direction w) 1.0)
      )
    (set-vector! (-> a3-0 dir0 color) 0.822 0.694 0.613 1.0)
    (set! (-> a3-0 dir0 extra x) 1.0)
    (set-vector! (-> a2-4 ambi color) 0.8 0.8 0.8 1.0)
    (set! (-> a2-4 ambi extra x) 1.0)
    (let ((a0-8 (-> a2-4 dir0)))
      (set! (-> a0-8 direction x) 0.0)
      (set! (-> a0-8 direction y) 1.0)
      (set! (-> a0-8 direction z) 0.0)
      (set! (-> a0-8 direction w) 1.0)
      )
    (set-vector! (-> a2-4 dir0 color) 0.822 0.694 0.613 1.0)
    (set! (-> a2-4 dir0 extra x) 1.0)
    (let ((a0-11 (-> a2-4 dir1)))
      (set! (-> a0-11 direction x) -0.751)
      (set! (-> a0-11 direction y) 0.658)
      (set! (-> a0-11 direction z) -0.035)
      (set! (-> a0-11 direction w) 1.0)
      )
    (set-vector! (-> a2-4 dir1 color) 1.0 0.65 0.65 1.0)
    (set! (-> a2-4 dir1 extra x) 0.6)
    (set-vector! (-> a1-5 ambi color) 0.35 0.35 0.35 1.0)
    (set! (-> a1-5 ambi extra x) 1.0)
    (let ((a0-16 (-> a1-5 dir0)))
      (set! (-> a0-16 direction x) 0.0)
      (set! (-> a0-16 direction y) 1.0)
      (set! (-> a0-16 direction z) 0.0)
      (set! (-> a0-16 direction w) 1.0)
      )
    (set-vector! (-> a1-5 dir0 color) 0.822 0.694 0.613 1.0)
    (set! (-> a1-5 dir0 extra x) 1.0)
    (let ((a0-19 (-> v1-2 dir0)))
      (set! (-> a0-19 direction x) 0.0)
      (set! (-> a0-19 direction y) 1.0)
      (set! (-> a0-19 direction z) 0.0)
      (set! (-> a0-19 direction w) 1.0)
      )
    (set-vector! (-> v1-2 dir0 color) 0.725 0.924 0.982 1.0)
    (set! (-> v1-2 dir0 extra x) 0.4)
    )
  0
  (none)
  )

;; definition for function init-mood-sewer
;; WARN: Return type mismatch sp-field-init-spec vs none.
(defun init-mood-sewer ((arg0 mood-context))
  (let ((gp-0 (the-as sewer-states (-> arg0 state))))
    (let ((a0-1 (-> *part-id-table* 39)))
      (set! (-> gp-0 spec-light-center) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-1)
          (set! (-> gp-0 spec-light-center) (get-field-spec-by-id a0-1 (sp-field-id spt-a)))
          )
      )
    (let ((a0-2 (-> *part-id-table* 40)))
      (set! (-> gp-0 spec-light) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-2)
          (set! (-> gp-0 spec-light) (get-field-spec-by-id a0-2 (sp-field-id spt-a)))
          )
      )
    )
  (none)
  )

;; definition for function update-mood-sewer
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-sewer time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (update-sewer-lights arg0)
  (let ((s5-0 (-> arg0 light-group 2)))
    (set! (-> arg0 light-group 0 dir0 extra x) 0.0)
    (cond
      ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
       (palette-select-special arg0)
       )
      (else
        (set! (-> arg0 times 0 w) 1.0)
        (set! (-> arg0 times 2 w) 1.0)
        (let ((s4-0 (the-as sewer-states (-> arg0 state))))
          (when (-> s4-0 light-flag)
            (let ((v1-6 (-> s4-0 light-count)))
              (cond
                ((> v1-6 0)
                 (let ((f0-4 (+ 0.2 (* 0.0066666673 (the float v1-6))))
                       (f1-3 (+ 0.4 (* 0.013333335 (the float v1-6))))
                       )
                   (set! (-> arg0 times 1 w) (rand-vu-float-range f0-4 f1-3))
                   )
                 (+! (-> s4-0 light-count) -1)
                 (set! (-> *display* force-sync) (the-as uint 2))
                 )
                (else
                  (set! (-> arg0 times 1 w) 1.0)
                  )
                )
              )
            )
          (let ((f0-7 (-> arg0 times 1 w)))
            (if (nonzero? (-> s4-0 spec-light-center))
                (set! (-> s4-0 spec-light-center initial-valuef) (* 12.0 f0-7))
                )
            (if (nonzero? (-> s4-0 spec-light))
                (set! (-> s4-0 spec-light initial-valuef) (* 12.0 f0-7))
                )
            (if *ocean-map-sewer*
                (set! (-> *ocean-map-sewer* ocean-colors colors 1271)
                      (the-as
                        rgba
                        (logior (logand (logior (logand (logior (logand (logior (logand 0 -256) (shr (shl (the int (* 19.0 f0-7)) 56) 56)) -65281)
                                                                (shr (shl (the int (* 24.5 f0-7)) 56) 48)
                                                                )
                                                        -16711681
                                                        )
                                                (shr (shl (the int (* 16.0 f0-7)) 56) 40)
                                                )
                                        (the-as uint #xffffffff00ffffff)
                                        )
                                (shl #x8000 16)
                                )
                        )
                      )
                )
            )
          (set! (-> arg0 times 6 w) (-> s4-0 explosion))
          (set! (-> arg0 times 7 w) (-> s4-0 turret-value))
          (when (not (paused?))
            (set! (-> s4-0 turret-value) (fmax 0.0 (+ -0.2 (-> s4-0 turret-value))))
            (seek! (-> s4-0 explosion) 0.0 (* 2.5 (seconds-per-frame)))
            )
          )
        (when *ocean-map-sewer*
          (let ((f0-18 (-> *ocean-map-sewer* start-corner y)))
            (let ((f1-19 (fmax 0.0 (fmin 1.0 (- 1.0 (* 0.000020345053 (+ 314802.2 f0-18)))))))
              (set! (-> arg0 times 3 w) (fmax 0.0 (fmin 1.0 (- 1.0 (* 0.000020345053 (+ 265650.2 f0-18))))))
              (set! (-> arg0 times 4 w) f1-19)
              (set! (-> s5-0 dir0 extra x) f1-19)
              (set! (-> s5-0 ambi extra x) f1-19)
              )
            (set! (-> arg0 times 5 w) (fmax 0.0 (fmin 1.0 (- 1.0 (* 0.000018780049 (+ 368050.2 f0-18))))))
            )
          )
        )
      )
    )
  0
  (none)
  )

;; definition for function update-mood-copy-sewerb
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-copy-sewerb time-of-day-proc ((arg0 mood-context))
  (let ((v1-1 (level-get *level* 'sewerb)))
    (if (and v1-1 (= (-> v1-1 status) 'active))
        (mem-copy! (the-as pointer arg0) (the-as pointer (-> v1-1 mood-context)) 1968)
        )
    )
  0
  (none)
  )

;; definition for function update-mood-copy-sewescb
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-copy-sewescb time-of-day-proc ((arg0 mood-context))
  (let ((v1-1 (level-get *level* 'sewescb)))
    (if (and v1-1 (= (-> v1-1 status) 'active))
        (mem-copy! (the-as pointer arg0) (the-as pointer (-> v1-1 mood-context)) 1968)
        )
    )
  0
  (none)
  )

;; definition for function set-sewer-lights-flag!
(defun set-sewer-lights-flag! ((arg0 symbol))
  (let ((v1-1 (level-get *level* 'sewerb)))
    (when v1-1
      (let ((v1-2 (the-as sewer-states (-> v1-1 mood-context state))))
        (if (and (not (-> v1-2 light-flag)) arg0)
            (set! (-> v1-2 light-count) (the-as uint 30))
            )
        (set! (-> v1-2 light-flag) arg0)
        )
      arg0
      )
    )
  )

;; definition for function set-sewer-turret-flash!
(defun set-sewer-turret-flash! ()
  (let ((v1-1 (level-get *level* 'sewerb)))
    (when v1-1
      (let ((v1-2 (the-as sewer-states (-> v1-1 mood-context state))))
        (set! (-> v1-2 turret-value) 1.0)
        )
      )
    )
  )

;; definition for function set-sewesc-explosion!
(defun set-sewesc-explosion! ()
  (let ((v1-1 (level-get *level* 'sewescb)))
    (when v1-1
      (let ((v1-2 (the-as sewer-states (-> v1-1 mood-context state))))
        (set! (-> v1-2 explosion) 1.9921875)
        )
      )
    )
  )

;; definition of type onintent-states
(deftype onintent-states (structure)
  ((flame0       flames-state  :inline)
   (flame1       flames-state  :inline)
   (flame2       flames-state  :inline)
   (green-flame  flames-state  :inline)
   (totem0       flames-state  :inline)
   (totem1       flames-state  :inline)
   )
  )

;; definition for method 3 of type onintent-states
(defmethod inspect ((this onintent-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'onintent-states)
  (format #t "~1Tflame0: #<flames-state @ #x~X>~%" (-> this flame0))
  (format #t "~1Tflame1: #<flames-state @ #x~X>~%" (-> this flame1))
  (format #t "~1Tflame2: #<flames-state @ #x~X>~%" (-> this flame2))
  (format #t "~1Tgreen-flame: #<flames-state @ #x~X>~%" (-> this green-flame))
  (format #t "~1Ttotem0: #<flames-state @ #x~X>~%" (-> this totem0))
  (format #t "~1Ttotem1: #<flames-state @ #x~X>~%" (-> this totem1))
  (label cfg-4)
  this
  )

;; definition for function update-onintent-lights
;; WARN: Return type mismatch int vs none.
(defun update-onintent-lights ((arg0 mood-context))
  (let ((v1-0 (-> arg0 light-group)))
    (set-vector! (-> v1-0 0 dir0 color) 0.822 0.694 0.613 1.0)
    (set-vector! (-> v1-0 0 ambi color) 0.21 0.188 0.163 1.0)
    )
  0
  (none)
  )

;; definition for function update-mood-onintent
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-onintent time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (update-onintent-lights arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (set! (-> arg0 times 0 w) 1.0)
      (set! (-> arg0 times 1 w) 1.0)
      (update-mood-flames arg0 2 1 0 0.75 0.0009765625 2.0)
      (update-mood-flames arg0 3 1 8 0.75 0.0009765625 3.0)
      (update-mood-flames arg0 4 1 16 0.75 0.0009765625 4.0)
      (update-mood-flames arg0 5 1 24 0.75 0.0009765625 2.0)
      (update-mood-flames arg0 6 1 32 0.333 0.001953125 2.0)
      (update-mood-flames arg0 7 1 40 0.75 0.0009765625 2.0)
      )
    )
  0
  (none)
  )

;; definition of type oracle-states
(deftype oracle-states (structure)
  ((flame0        flames-state  :inline)
   (flame1        flames-state  :inline)
   (flame2        flames-state  :inline)
   (blue-flame    flames-state  :inline)
   (door-entity   entity)
   (door-current  float)
   (door-target   float)
   (purple-flag   symbol)
   (purple        float)
   (purple-noise  float)
   )
  )

;; definition for method 3 of type oracle-states
(defmethod inspect ((this oracle-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'oracle-states)
  (format #t "~1Tflame0: #<flames-state @ #x~X>~%" (-> this flame0))
  (format #t "~1Tflame1: #<flames-state @ #x~X>~%" (-> this flame1))
  (format #t "~1Tflame2: #<flames-state @ #x~X>~%" (-> this flame2))
  (format #t "~1Tblue-flame: #<flames-state @ #x~X>~%" (-> this blue-flame))
  (format #t "~1Tdoor-entity: ~A~%" (-> this door-entity))
  (format #t "~1Tdoor-current: ~f~%" (-> this door-current))
  (format #t "~1Tdoor-target: ~f~%" (-> this door-target))
  (format #t "~1Tpurple-flag: ~A~%" (-> this purple-flag))
  (format #t "~1Tpurple: ~f~%" (-> this purple))
  (format #t "~1Tpurple-noise: ~f~%" (-> this purple-noise))
  (label cfg-4)
  this
  )

;; definition for function init-mood-oracle
(defun init-mood-oracle ((arg0 mood-context))
  (let ((v1-0 (the-as oracle-states (-> arg0 state))))
    (set! (-> v1-0 door-entity) #f)
    (set! (-> v1-0 door-current) 0.0)
    (set! (-> v1-0 door-target) 0.0)
    (set! (-> v1-0 purple-flag) #f)
    )
  #f
  )

;; definition for function update-mood-oracle
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-oracle time-of-day-proc ((arg0 mood-context))
  (copy-mood-exterior-ambi arg0 #f)
  (update-mood-interior arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (let ((s5-0 (the-as oracle-states (-> arg0 state))))
        (cond
          ((-> s5-0 door-entity)
           (if (logtest? (-> s5-0 door-entity extra perm status) (entity-perm-status subtask-complete))
               (set! (-> s5-0 door-target) 1.0)
               (set! (-> s5-0 door-target) 0.0)
               )
           )
          (else
            (set! (-> s5-0 door-entity) (entity-by-name "oracle-door-1"))
            )
          )
        (when (not (paused?))
          (seek! (-> s5-0 door-current) (-> s5-0 door-target) (* 4.0 (seconds-per-frame)))
          (cond
            ((-> s5-0 purple-flag)
             (set! (-> s5-0 purple) (fmin 1.9 (+ (-> s5-0 purple) (* 2.0 (seconds-per-frame)))))
             (set! (-> s5-0 purple-noise) (rand-vu-float-range 0.0 (-> s5-0 purple)))
             )
            (else
              (set! (-> s5-0 purple) (fmax 0.0 (- (-> s5-0 purple) (* 2.0 (seconds-per-frame)))))
              (set! (-> s5-0 purple-noise) 0.0)
              )
            )
          )
        (set! (-> arg0 times 0 w) (-> s5-0 door-current))
        (set! (-> arg0 times 1 w) 1.0)
        (update-mood-flames arg0 2 1 0 0.75 0.0009765625 2.0)
        (update-mood-flames arg0 3 1 8 0.75 0.0009765625 3.0)
        (update-mood-flames arg0 4 1 16 0.75 0.0009765625 4.0)
        (update-mood-flames arg0 5 1 24 0.75 0.0009765625 2.0)
        (set! (-> arg0 times 6 w) (+ (-> s5-0 purple) (-> s5-0 purple-noise)))
        )
      )
    )
  0
  (none)
  )

;; definition for function set-oracle-purple-flag!
(defun set-oracle-purple-flag! ((arg0 symbol))
  (let ((v1-1 (level-get *level* 'oracle)))
    (when v1-1
      (set! (-> (the-as oracle-states (-> v1-1 mood-context state)) purple-flag) arg0)
      arg0
      )
    )
  )

;; definition of type tomba-states
(deftype tomba-states (structure)
  ((flame0     flames-state  :inline)
   (flame1     flames-state  :inline)
   (flame2     flames-state  :inline)
   (light      light-state   :inline)
   (gem-light  float)
   )
  )

;; definition for method 3 of type tomba-states
(defmethod inspect ((this tomba-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'tomba-states)
  (format #t "~1Tflame0: #<flames-state @ #x~X>~%" (-> this flame0))
  (format #t "~1Tflame1: #<flames-state @ #x~X>~%" (-> this flame1))
  (format #t "~1Tflame2: #<flames-state @ #x~X>~%" (-> this flame2))
  (format #t "~1Tlight: #<light-state @ #x~X>~%" (-> this light))
  (format #t "~1Tgem-light: ~f~%" (-> this gem-light))
  (label cfg-4)
  this
  )

;; definition for function update-tomba-lights
;; WARN: Return type mismatch int vs none.
(defun update-tomba-lights ((arg0 mood-context))
  (let ((v1-0 (-> arg0 current-fog)))
    (set! (-> v1-0 fog-color x) 0.0)
    (set! (-> v1-0 fog-color y) 0.0)
    (set! (-> v1-0 fog-color z) 0.0)
    (set! (-> v1-0 fog-color w) 128.0)
    )
  (let ((a1-0 (-> arg0 light-group))
        (s5-0 (-> arg0 light-group 1))
        )
    (let ((v1-1 (-> a1-0 0)))
      (set! (-> v1-1 dir0 direction x) -0.69)
      (set! (-> v1-1 dir0 direction y) 0.487)
      (set! (-> v1-1 dir0 direction z) -0.53)
      (set! (-> v1-1 dir0 direction w) 0.0)
      )
    (set-vector! (-> a1-0 0 dir0 color) 0.878 0.7656 0.6875 1.0)
    (set! (-> a1-0 0 dir0 extra x) 1.0)
    (let ((v1-4 (-> a1-0 0 dir1)))
      (set! (-> v1-4 direction x) 0.743)
      (set! (-> v1-4 direction y) 0.51)
      (set! (-> v1-4 direction z) 0.431)
      (set! (-> v1-4 direction w) 0.0)
      )
    (set-vector! (-> a1-0 0 dir1 color) 1.0 0.8046 0.648 1.0)
    (set! (-> a1-0 0 dir1 extra x) 0.8)
    (set-vector! (-> a1-0 0 ambi color) 0.3 0.2 0.1 1.0)
    (set! (-> a1-0 0 ambi extra x) 0.55)
    (mem-copy! (the-as pointer s5-0) (the-as pointer a1-0) 192)
    (set! (-> s5-0 ambi extra x) 0.35)
    )
  (cond
    ((task-node-closed? (game-task-node tomb-boss-torches))
     )
    (else
      (set-vector! (-> arg0 current-env-color) 0.0 0.0 0.0 0.0)
      )
    )
  0
  (none)
  )

;; definition for function update-mood-tomba
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-tomba time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (update-tomba-lights arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (-> arg0 state)
      (set! (-> arg0 times 0 w) 1.0)
      (set! (-> arg0 times 1 w) 1.0)
      (when (not (task-node-closed? (game-task-node tomb-boss-torches)))
        (update-mood-flames arg0 2 1 0 0.75 0.0009765625 2.0)
        (update-mood-flames arg0 3 1 8 0.75 0.0009765625 2.0)
        )
      (update-mood-flames arg0 4 2 16 0.5 0.001953125 2.0)
      (update-mood-light arg0 6 24 0.8 0.2 19.0 0.0 1.0)
      )
    )
  0
  (none)
  )

;; definition of type tombb-states
(deftype tombb-states (structure)
  ((flame0  flames-state  :inline)
   (flame1  flames-state  :inline)
   (flame2  flames-state  :inline)
   (light   light-state   :inline)
   )
  )

;; definition for method 3 of type tombb-states
(defmethod inspect ((this tombb-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'tombb-states)
  (format #t "~1Tflame0: #<flames-state @ #x~X>~%" (-> this flame0))
  (format #t "~1Tflame1: #<flames-state @ #x~X>~%" (-> this flame1))
  (format #t "~1Tflame2: #<flames-state @ #x~X>~%" (-> this flame2))
  (format #t "~1Tlight: #<light-state @ #x~X>~%" (-> this light))
  (label cfg-4)
  this
  )

;; definition for function update-tombb-lights
;; WARN: Return type mismatch int vs none.
(defun update-tombb-lights ((arg0 mood-context))
  (update-tomba-lights arg0)
  (let ((v1-0 (-> arg0 light-group 1)))
    (let ((a0-2 (-> v1-0 dir0)))
      (set! (-> a0-2 direction x) 0.0)
      (set! (-> a0-2 direction y) 0.0)
      (set! (-> a0-2 direction z) 1.0)
      (set! (-> a0-2 direction w) 0.0)
      )
    (set-vector! (-> v1-0 dir0 color) 1.6 1.07 0.725 1.0)
    (set! (-> v1-0 dir0 extra x) 0.5)
    (let ((a0-5 (-> v1-0 dir1)))
      (set! (-> a0-5 direction x) -0.473)
      (set! (-> a0-5 direction y) 0.707)
      (set! (-> a0-5 direction z) -0.523)
      (set! (-> a0-5 direction w) 0.0)
      )
    (set-vector! (-> v1-0 dir1 color) 1.4 0.9 0.5 1.0)
    (set! (-> v1-0 dir1 extra x) 0.55)
    (let ((a0-8 (-> v1-0 dir2)))
      (set! (-> a0-8 direction x) 0.473)
      (set! (-> a0-8 direction y) 0.707)
      (set! (-> a0-8 direction z) -0.523)
      (set! (-> a0-8 direction w) 0.0)
      )
    (set-vector! (-> v1-0 dir2 color) 1.4 0.9 0.7 1.0)
    (set! (-> v1-0 dir2 extra x) 0.55)
    (set-vector! (-> v1-0 ambi color) 0.4 0.2 0.2 1.0)
    (set! (-> v1-0 ambi extra x) 0.2)
    )
  0
  (none)
  )

;; definition for function update-mood-tombb
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-tombb time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (update-tombb-lights arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (set! (-> arg0 times 0 w) 1.0)
      (set! (-> arg0 times 1 w) 1.0)
      (update-mood-flames arg0 2 1 0 0.75 0.0009765625 2.0)
      (update-mood-flames arg0 3 1 8 0.75 0.0009765625 2.0)
      (update-mood-flames arg0 4 2 16 0.5 0.001953125 2.0)
      (update-mood-light arg0 6 24 0.75 0.5 19.0 0.0 1.0)
      )
    )
  0
  (none)
  )

;; definition of type tombc-states
(deftype tombc-states (structure)
  ((flame0       flames-state       :inline)
   (flame1       flames-state       :inline)
   (flame2       flames-state       :inline)
   (electricity  electricity-state  :inline)
   )
  )

;; definition for method 3 of type tombc-states
(defmethod inspect ((this tombc-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'tombc-states)
  (format #t "~1Tflame0: #<flames-state @ #x~X>~%" (-> this flame0))
  (format #t "~1Tflame1: #<flames-state @ #x~X>~%" (-> this flame1))
  (format #t "~1Tflame2: #<flames-state @ #x~X>~%" (-> this flame2))
  (format #t "~1Telectricity: #<electricity-state @ #x~X>~%" (-> this electricity))
  (label cfg-4)
  this
  )

;; definition for function init-mood-tombc
(defun init-mood-tombc ((arg0 mood-context))
  (let ((v1-0 (the-as tombc-states (-> arg0 state))))
    (set! (-> v1-0 electricity scale) 1.0)
    )
  )

;; definition for function update-mood-tombc
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-tombc time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (update-tomba-lights arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (set! (-> arg0 times 0 w) 1.0)
      (set! (-> arg0 times 1 w) 1.0)
      (update-mood-flames arg0 2 1 0 0.75 0.0009765625 2.0)
      (update-mood-flames arg0 3 1 8 0.75 0.0009765625 2.0)
      (update-mood-flames arg0 4 2 16 0.5 0.001953125 2.0)
      (update-mood-electricity arg0 6 24 0.8 1.0)
      )
    )
  0
  (none)
  )

;; definition for function set-tombc-electricity-scale!
(defun set-tombc-electricity-scale! ((arg0 float))
  (let ((v1-1 (level-get *level* 'tombc)))
    (when v1-1
      (let ((v1-2 (the-as tombc-states (-> v1-1 mood-context state))))
        (set! (-> v1-2 electricity scale) arg0)
        )
      )
    )
  )

;; definition of type tombd-states
(deftype tombd-states (structure)
  ((flame0     flames-state  :inline)
   (flame1     flames-state  :inline)
   (flame2     flames-state  :inline)
   (light      light-state   :inline)
   (gem-light  float)
   )
  )

;; definition for method 3 of type tombd-states
(defmethod inspect ((this tombd-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'tombd-states)
  (format #t "~1Tflame0: #<flames-state @ #x~X>~%" (-> this flame0))
  (format #t "~1Tflame1: #<flames-state @ #x~X>~%" (-> this flame1))
  (format #t "~1Tflame2: #<flames-state @ #x~X>~%" (-> this flame2))
  (format #t "~1Tlight: #<light-state @ #x~X>~%" (-> this light))
  (format #t "~1Tgem-light: ~f~%" (-> this gem-light))
  (label cfg-4)
  this
  )

;; definition for function update-tombd-lights
;; WARN: Return type mismatch int vs none.
(defun update-tombd-lights ((arg0 mood-context))
  (let ((v1-0 (-> arg0 current-fog)))
    (set! (-> v1-0 fog-color x) 0.0)
    (set! (-> v1-0 fog-color y) 0.0)
    (set! (-> v1-0 fog-color z) 0.0)
    (set! (-> v1-0 fog-color w) 128.0)
    )
  (let ((a1-1 (-> arg0 light-group))
        (gp-0 (-> arg0 light-group 1))
        )
    (let ((v1-1 (-> a1-1 0)))
      (set! (-> v1-1 dir0 direction x) -0.69)
      (set! (-> v1-1 dir0 direction y) 0.487)
      (set! (-> v1-1 dir0 direction z) -0.53)
      (set! (-> v1-1 dir0 direction w) 0.0)
      )
    (set-vector! (-> a1-1 0 dir0 color) 0.85 0.7656 0.6875 1.0)
    (set! (-> a1-1 0 dir0 extra x) 1.0)
    (let ((v1-4 (-> a1-1 0 dir1)))
      (set! (-> v1-4 direction x) 0.743)
      (set! (-> v1-4 direction y) 0.51)
      (set! (-> v1-4 direction z) 0.431)
      (set! (-> v1-4 direction w) 0.0)
      )
    (set-vector! (-> a1-1 0 dir1 color) 0.85 0.8046 0.7 1.0)
    (set! (-> a1-1 0 dir1 extra x) 0.8)
    (set-vector! (-> a1-1 0 ambi color) 0.3 0.2 0.1 1.0)
    (set! (-> a1-1 0 ambi extra x) 0.55)
    (mem-copy! (the-as pointer gp-0) (the-as pointer a1-1) 192)
    (set! (-> gp-0 ambi extra x) 0.35)
    )
  0
  (none)
  )

;; definition for function update-mood-tombd
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-tombd time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (update-tombd-lights arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (-> arg0 state)
      (set! (-> arg0 times 0 w) 1.0)
      (set! (-> arg0 times 1 w) 1.0)
      (when (not (task-node-closed? (game-task-node tomb-boss-torches)))
        (update-mood-flames arg0 2 1 0 0.75 0.0009765625 2.0)
        (update-mood-flames arg0 3 1 8 0.75 0.0009765625 2.0)
        )
      (update-mood-flames arg0 4 2 16 0.5 0.001953125 2.0)
      (update-mood-light arg0 6 24 0.8 0.2 19.0 0.0 1.0)
      )
    )
  0
  (none)
  )

;; definition of type tombe-states
(deftype tombe-states (structure)
  ((flame0     flames-state  :inline)
   (flame1     flames-state  :inline)
   (flame2     flames-state  :inline)
   (light      light-state   :inline)
   (gem-light  float)
   )
  )

;; definition for method 3 of type tombe-states
(defmethod inspect ((this tombe-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'tombe-states)
  (format #t "~1Tflame0: #<flames-state @ #x~X>~%" (-> this flame0))
  (format #t "~1Tflame1: #<flames-state @ #x~X>~%" (-> this flame1))
  (format #t "~1Tflame2: #<flames-state @ #x~X>~%" (-> this flame2))
  (format #t "~1Tlight: #<light-state @ #x~X>~%" (-> this light))
  (format #t "~1Tgem-light: ~f~%" (-> this gem-light))
  (label cfg-4)
  this
  )

;; definition for function update-mood-tombe
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-tombe time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (update-tomba-lights arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (-> arg0 state)
      (set! (-> arg0 times 0 w) 1.0)
      (set! (-> arg0 times 1 w) 1.0)
      (update-mood-flames arg0 2 1 0 0.75 0.0009765625 2.0)
      (update-mood-flames arg0 3 1 8 0.75 0.0009765625 2.0)
      (update-mood-flames arg0 4 2 16 0.5 0.001953125 2.0)
      (update-mood-light arg0 6 24 0.8 0.2 19.0 0.0 1.0)
      )
    )
  0
  (none)
  )

;; definition of type tombboss-states
(deftype tombboss-states (structure)
  ((flame0     flames-state  :inline)
   (flame1     flames-state  :inline)
   (flame2     flames-state  :inline)
   (light      light-state   :inline)
   (gem-light  float)
   )
  )

;; definition for method 3 of type tombboss-states
(defmethod inspect ((this tombboss-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'tombboss-states)
  (format #t "~1Tflame0: #<flames-state @ #x~X>~%" (-> this flame0))
  (format #t "~1Tflame1: #<flames-state @ #x~X>~%" (-> this flame1))
  (format #t "~1Tflame2: #<flames-state @ #x~X>~%" (-> this flame2))
  (format #t "~1Tlight: #<light-state @ #x~X>~%" (-> this light))
  (format #t "~1Tgem-light: ~f~%" (-> this gem-light))
  (label cfg-4)
  this
  )

;; definition for function update-tombboss-lights
;; WARN: Return type mismatch int vs none.
(defun update-tombboss-lights ((arg0 mood-context))
  (let ((v1-0 (-> arg0 light-group)))
    (let ((a1-0 (-> v1-0 0)))
      (set! (-> a1-0 dir0 direction x) -0.671)
      (set! (-> a1-0 dir0 direction y) 0.568)
      (set! (-> a1-0 dir0 direction z) -0.474)
      (set! (-> a1-0 dir0 direction w) 0.0)
      )
    (set-vector! (-> v1-0 0 dir0 color) 0.7 0.5 0.25 1.0)
    (set! (-> v1-0 0 dir0 extra x) 1.2)
    (let ((a1-3 (-> v1-0 0 dir1)))
      (set! (-> a1-3 direction x) 0.734)
      (set! (-> a1-3 direction y) 0.678)
      (set! (-> a1-3 direction z) -0.019)
      (set! (-> a1-3 direction w) 0.0)
      )
    (set-vector! (-> v1-0 0 dir1 color) 0.7 0.5 0.25 1.0)
    (set! (-> v1-0 0 dir1 extra x) 0.9)
    (set-vector! (-> v1-0 0 ambi color) 0.2 0.2 0.4 1.0)
    (set! (-> v1-0 0 ambi extra x) 0.8)
    )
  (let ((v1-2 (-> arg0 light-group 1)))
    (let ((a1-8 (-> v1-2 dir0)))
      (set! (-> a1-8 direction x) -0.823)
      (set! (-> a1-8 direction y) 0.491)
      (set! (-> a1-8 direction z) -0.283)
      (set! (-> a1-8 direction w) 0.0)
      )
    (set-vector! (-> v1-2 dir0 color) 0.878 0.7656 0.6875 1.0)
    (set! (-> v1-2 dir0 extra x) 1.0)
    (let ((a1-11 (-> v1-2 dir1)))
      (set! (-> a1-11 direction x) 0.661)
      (set! (-> a1-11 direction y) 0.411)
      (set! (-> a1-11 direction z) -0.626)
      (set! (-> a1-11 direction w) 0.0)
      )
    (set-vector! (-> v1-2 dir1 color) 1.0 0.8046 0.648 1.0)
    (set! (-> v1-2 dir1 extra x) 0.8)
    (set-vector! (-> v1-2 ambi color) 0.375 0.0 0.2 1.0)
    (set! (-> v1-2 ambi extra x) 0.332)
    )
  (let ((v1-4 (-> arg0 light-group 2)))
    (let ((a1-16 (-> v1-4 dir0)))
      (set! (-> a1-16 direction x) -0.671)
      (set! (-> a1-16 direction y) 0.568)
      (set! (-> a1-16 direction z) -0.474)
      (set! (-> a1-16 direction w) 0.0)
      )
    (set-vector! (-> v1-4 dir0 color) 0.7 0.5 0.25 1.0)
    (set! (-> v1-4 dir0 extra x) 1.0)
    (let ((a1-19 (-> v1-4 dir1)))
      (set! (-> a1-19 direction x) 0.734)
      (set! (-> a1-19 direction y) 0.678)
      (set! (-> a1-19 direction z) -0.019)
      (set! (-> a1-19 direction w) 0.0)
      )
    (set-vector! (-> v1-4 dir1 color) 0.7 0.5 0.25 1.0)
    (set! (-> v1-4 dir1 extra x) 0.7)
    (set-vector! (-> v1-4 ambi color) 0.2 0.2 0.4 1.0)
    (set! (-> v1-4 ambi extra x) 0.4)
    )
  (let ((v1-6 (-> arg0 light-group 3)))
    (let ((a1-24 (-> v1-6 dir0)))
      (set! (-> a1-24 direction x) -0.671)
      (set! (-> a1-24 direction y) 0.568)
      (set! (-> a1-24 direction z) -0.474)
      (set! (-> a1-24 direction w) 0.0)
      )
    (set-vector! (-> v1-6 dir0 color) 0.7 0.5 0.25 1.0)
    (set! (-> v1-6 dir0 extra x) 1.2)
    (let ((a1-27 (-> v1-6 dir1)))
      (set! (-> a1-27 direction x) 0.734)
      (set! (-> a1-27 direction y) 0.678)
      (set! (-> a1-27 direction z) -0.019)
      (set! (-> a1-27 direction w) 0.0)
      )
    (set-vector! (-> v1-6 dir1 color) 0.7 0.5 0.25 1.0)
    (set! (-> v1-6 dir1 extra x) 0.9)
    (set-vector! (-> v1-6 ambi color) 0.2 0.2 0.4 1.0)
    (set! (-> v1-6 ambi extra x) 0.8)
    )
  (let ((v1-8 (-> arg0 light-group 4)))
    (let ((a0-1 (-> v1-8 dir0)))
      (set! (-> a0-1 direction x) -0.69)
      (set! (-> a0-1 direction y) 0.487)
      (set! (-> a0-1 direction z) -0.53)
      (set! (-> a0-1 direction w) 0.0)
      )
    (set-vector! (-> v1-8 dir0 color) 0.878 0.7656 0.6875 1.0)
    (set! (-> v1-8 dir0 extra x) 1.0)
    (let ((a0-4 (-> v1-8 dir1)))
      (set! (-> a0-4 direction x) 0.743)
      (set! (-> a0-4 direction y) 0.51)
      (set! (-> a0-4 direction z) 0.431)
      (set! (-> a0-4 direction w) 0.0)
      )
    (set-vector! (-> v1-8 dir1 color) 1.0 0.8046 0.648 1.0)
    (set! (-> v1-8 dir1 extra x) 0.8)
    (set-vector! (-> v1-8 ambi color) 0.4 0.2 0.2 1.0)
    (set! (-> v1-8 ambi extra x) 0.4)
    )
  0
  (none)
  )

;; definition for function update-mood-tombboss
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-tombboss time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (update-tombboss-lights arg0)
  (let ((s5-0 (new 'static 'vector :x 790528.0 :y -262144.0 :z 6053888.0 :w 274432.0)))
    (if (< (vector-vector-distance (target-pos 0) s5-0) (-> s5-0 w))
        (mem-copy! (the-as pointer (-> arg0 light-group)) (the-as pointer (-> arg0 light-group 3)) 192)
        (mem-copy! (the-as pointer (-> arg0 light-group)) (the-as pointer (-> arg0 light-group 4)) 192)
        )
    )
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (let ((v1-4 (-> arg0 state)))
        (set! (-> arg0 times 0 w) 1.0)
        (set! (-> arg0 times 1 w) 1.0)
        (set! (-> arg0 times 7 w) (the-as float (-> v1-4 8)))
        )
      (update-mood-flames arg0 2 1 0 0.75 0.0009765625 2.0)
      (update-mood-flames arg0 3 1 8 0.75 0.0009765625 2.0)
      (update-mood-flames arg0 4 2 16 0.5 0.001953125 2.0)
      (update-mood-light arg0 6 24 0.8 0.2 19.0 0.0 1.0)
      )
    )
  0
  (none)
  )

;; definition for function set-tombboss-gem-light!
(defun set-tombboss-gem-light! ((arg0 float))
  (let ((v1-1 (level-get *level* 'tombboss)))
    (when v1-1
      (let ((v1-2 (the-as tombboss-states (-> v1-1 mood-context state))))
        (set! (-> v1-2 gem-light) arg0)
        )
      )
    )
  )

;; definition of type fortress-states
(deftype fortress-states (structure)
  ((pulse  pulse-state  :inline)
   )
  )

;; definition for method 3 of type fortress-states
(defmethod inspect ((this fortress-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'fortress-states)
  (format #t "~1Tpulse: #<pulse-state @ #x~X>~%" (-> this pulse))
  (label cfg-4)
  this
  )

;; definition for function update-fortress-lights
;; WARN: Return type mismatch int vs none.
(defun update-fortress-lights ((arg0 mood-context))
  (let ((a3-0 (-> arg0 light-group))
        (a2-0 (-> arg0 light-group 1))
        (a1-0 (-> arg0 light-group 2))
        (v1-0 (-> arg0 light-group 3))
        )
    (set-vector! (-> a3-0 0 dir0 color) 0.822 0.694 0.65 1.0)
    (set-vector! (-> a3-0 0 ambi color) 0.35 0.425 0.4 1.0)
    (set! (-> a3-0 0 ambi extra x) 0.8)
    (let ((a0-4 (-> a2-0 dir0)))
      (set! (-> a0-4 direction x) 0.0)
      (set! (-> a0-4 direction y) 1.0)
      (set! (-> a0-4 direction z) 0.0)
      (set! (-> a0-4 direction w) 0.0)
      )
    (set-vector! (-> a2-0 dir0 color) 0.822 0.694 0.65 1.0)
    (set-vector! (-> a2-0 ambi color) 0.35 0.425 0.4 1.0)
    (set! (-> a2-0 dir0 extra x) 0.7)
    (set! (-> a2-0 ambi extra x) 0.8)
    (let ((a0-9 (-> a1-0 dir0)))
      (set! (-> a0-9 direction x) 0.0)
      (set! (-> a0-9 direction y) 1.0)
      (set! (-> a0-9 direction z) 0.0)
      (set! (-> a0-9 direction w) 0.0)
      )
    (set-vector! (-> a1-0 dir0 color) 0.822 0.694 0.65 1.0)
    (set-vector! (-> a1-0 ambi color) 0.35 0.425 0.4 1.0)
    (set! (-> a1-0 dir0 extra x) 0.4)
    (set! (-> a1-0 ambi extra x) 0.4)
    (let ((a0-14 (-> v1-0 dir0)))
      (set! (-> a0-14 direction x) 0.0)
      (set! (-> a0-14 direction y) 1.0)
      (set! (-> a0-14 direction z) 0.0)
      (set! (-> a0-14 direction w) 0.0)
      )
    (set-vector! (-> v1-0 dir0 color) 0.822 0.5 0.65 1.0)
    (set-vector! (-> v1-0 ambi color) 0.35 0.425 0.4 1.0)
    (set! (-> v1-0 dir0 extra x) 0.25)
    (set! (-> v1-0 ambi extra x) 0.2)
    )
  0
  (none)
  )

;; definition for function update-mood-fortress
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-fortress time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (update-fortress-lights arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (set! (-> arg0 times 0 w) 1.0)
      (set! (-> arg0 times 1 w) 1.0)
      (update-mood-pulse arg0 7 0 0.75 0.25 (* 65536.0 (seconds-per-frame)) 0.0)
      )
    )
  0
  (none)
  )

;; definition of type fordumpa-states
(deftype fordumpa-states (structure)
  ((turret-value  float              4)
   (pulse         pulse-state        :inline)
   (electricity   electricity-state  :inline)
   )
  )

;; definition for method 3 of type fordumpa-states
(defmethod inspect ((this fordumpa-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'fordumpa-states)
  (format #t "~1Tturret-value[4] @ #x~X~%" (-> this turret-value))
  (format #t "~1Tpulse: #<pulse-state @ #x~X>~%" (-> this pulse))
  (format #t "~1Telectricity: #<electricity-state @ #x~X>~%" (-> this electricity))
  (label cfg-4)
  this
  )

;; definition for function init-mood-fordumpa
(defun init-mood-fordumpa ((arg0 mood-context))
  (let ((v1-0 (the-as fordumpa-states (-> arg0 state))))
    (set! (-> v1-0 electricity scale) 0.0)
    )
  )

;; definition for function update-mood-fordumpa
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-fordumpa time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (update-fortress-lights arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (set! (-> arg0 times 0 w) 1.0)
      (set! (-> arg0 times 1 w) 1.0)
      (update-mood-pulse arg0 7 16 0.75 0.25 (* 65536.0 (seconds-per-frame)) 0.0)
      (update-mood-electricity arg0 6 20 0.8 1.0)
      (let ((s5-0 (the-as fordumpa-states (-> arg0 state))))
        (set! (-> arg0 times 2 w) (-> s5-0 turret-value 0))
        (set! (-> arg0 times 3 w) (-> s5-0 turret-value 1))
        (set! (-> arg0 times 4 w) (-> s5-0 turret-value 2))
        (set! (-> arg0 times 5 w) (-> s5-0 turret-value 3))
        (when (not (paused?))
          (dotimes (v1-7 4)
            (set! (-> s5-0 turret-value v1-7) (fmax 0.0 (+ -0.2 (-> s5-0 turret-value v1-7))))
            )
          )
        )
      )
    )
  0
  (none)
  )

;; definition for function set-fordumpa-turret-flash!
(defun set-fordumpa-turret-flash! ((arg0 int))
  (let ((v1-1 (level-get *level* 'fordumpa)))
    (when v1-1
      (let ((v1-2 (the-as fordumpa-states (-> v1-1 mood-context state))))
        (set! (-> v1-2 turret-value arg0) 1.0)
        )
      )
    )
  )

;; definition for function set-fordumpa-electricity-scale!
(defun set-fordumpa-electricity-scale! ((arg0 float))
  (let ((v1-1 (level-get *level* 'fordumpa)))
    (when v1-1
      (let ((v1-2 (the-as fordumpa-states (-> v1-1 mood-context state))))
        (set! (-> v1-2 electricity scale) arg0)
        )
      )
    )
  )

;; definition of type fordumpc-states
(deftype fordumpc-states (structure)
  ((light-flag  symbol)
   (pulse0      pulse-state   :inline)
   (pulse1      pulse-state   :inline)
   (strobe      strobe-state  :inline)
   )
  )

;; definition for method 3 of type fordumpc-states
(defmethod inspect ((this fordumpc-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'fordumpc-states)
  (format #t "~1Tlight-flag: ~A~%" (-> this light-flag))
  (format #t "~1Tpulse0: #<pulse-state @ #x~X>~%" (-> this pulse0))
  (format #t "~1Tpulse1: #<pulse-state @ #x~X>~%" (-> this pulse1))
  (format #t "~1Tstrobe: #<strobe-state @ #x~X>~%" (-> this strobe))
  (label cfg-4)
  this
  )

;; definition for function init-mood-fordumpc
(defun init-mood-fordumpc ((arg0 mood-context))
  (set! (-> (the-as fordumpc-states (-> arg0 state)) light-flag) #f)
  #f
  )

;; definition for function update-mood-fordumpc
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-fordumpc time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (update-fortress-lights arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    ((begin
       (set! (-> arg0 times 0 w) 1.0)
       (set! (-> arg0 times 1 w) 1.0)
       (update-mood-pulse arg0 3 4 0.75 0.25 (* 65536.0 (seconds-per-frame)) 0.0)
       (-> arg0 state 0)
       )
     (set! (-> arg0 times 2 w) 0.0)
     (update-mood-pulse arg0 4 8 0.75 0.25 (* 65536.0 (seconds-per-frame)) 16384.0)
     (update-mood-strobe arg0 5 12 85 (* 16.0 (seconds-per-frame)))
     )
    (else
      (set! (-> arg0 times 2 w) 1.0)
      (set! (-> arg0 times 4 w) 0.0)
      (set! (-> arg0 times 5 w) 0.0)
      )
    )
  0
  (none)
  )

;; definition for function set-fordumpc-light-flag!
(defun set-fordumpc-light-flag! ((arg0 symbol))
  (let ((v1-1 (level-get *level* 'fordumpc)))
    (when v1-1
      (set! (-> (the-as fordumpc-states (-> v1-1 mood-context state)) light-flag) arg0)
      arg0
      )
    )
  )

;; definition of type forresca-states
(deftype forresca-states (structure)
  ((pulse        pulse-state        :inline)
   (electricity  electricity-state  2 :inline :offset   4)
   )
  )

;; definition for method 3 of type forresca-states
(defmethod inspect ((this forresca-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'forresca-states)
  (format #t "~1Tpulse: #<pulse-state @ #x~X>~%" (-> this pulse))
  (format #t "~1Telectricity[2] @ #x~X~%" (-> this electricity))
  (label cfg-4)
  this
  )

;; definition for function init-mood-forresca
(defun init-mood-forresca ((arg0 mood-context))
  (let ((v1-0 (the-as forresca-states (-> arg0 state))))
    (set! (-> v1-0 electricity 0 scale) 1.0)
    (set! (-> v1-0 electricity 1 scale) 1.0)
    )
  )

;; definition for function update-mood-forresca
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-forresca time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (update-fortress-lights arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (set! (-> arg0 times 0 w) 1.0)
      (set! (-> arg0 times 1 w) 1.0)
      (update-mood-electricity arg0 5 4 0.8 1.0)
      (update-mood-electricity arg0 6 20 0.8 1.0)
      (update-mood-pulse arg0 7 0 0.75 0.25 (* 65536.0 (seconds-per-frame)) 0.0)
      )
    )
  0
  (none)
  )

;; definition for function set-forresca-electricity-scale!
(defun set-forresca-electricity-scale! ((arg0 float) (arg1 int))
  (let ((v1-1 (level-get *level* 'forresca)))
    (when v1-1
      (let ((v1-2 (the-as object (-> v1-1 mood-context state))))
        (set! (-> (the-as forresca-states v1-2) electricity arg1 scale) arg0)
        )
      )
    )
  )

;; definition of type forrescb-states
(deftype forrescb-states (structure)
  ((electricity  electricity-state  2 :inline)
   (turret       float              4)
   )
  )

;; definition for method 3 of type forrescb-states
(defmethod inspect ((this forrescb-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'forrescb-states)
  (format #t "~1Telectricity[2] @ #x~X~%" (-> this electricity))
  (format #t "~1Tturret[4] @ #x~X~%" (-> this turret))
  (label cfg-4)
  this
  )

;; definition for function init-mood-forrescb
(defun init-mood-forrescb ((arg0 mood-context))
  (let ((v1-0 (the-as forrescb-states (-> arg0 state))))
    (set! (-> v1-0 electricity 0 scale) 1.0)
    (set! (-> v1-0 electricity 1 scale) 1.0)
    )
  )

;; definition for function update-mood-forrescb
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-forrescb time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (update-fortress-lights arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (let ((gp-0 (the-as forrescb-states (-> arg0 state))))
        (set! (-> arg0 times 0 w) 1.0)
        (set! (-> arg0 times 1 w) 1.0)
        (update-mood-electricity arg0 6 0 0.8 1.0)
        (update-mood-electricity arg0 7 16 0.8 1.0)
        (set! (-> arg0 times 2 w) (-> gp-0 turret 0))
        (set! (-> arg0 times 3 w) (-> gp-0 turret 1))
        (set! (-> arg0 times 4 w) (-> gp-0 turret 2))
        (set! (-> arg0 times 5 w) (-> gp-0 turret 3))
        (when (not (paused?))
          (dotimes (v1-5 4)
            (set! (-> gp-0 turret v1-5) (fmax 0.0 (+ -0.2 (-> gp-0 turret v1-5))))
            )
          )
        )
      )
    )
  0
  (none)
  )

;; definition for function set-forrescb-turret-flash!
(defun set-forrescb-turret-flash! ((arg0 int))
  (let ((v1-1 (level-get *level* 'forrescb)))
    (when v1-1
      (let ((v1-2 (-> v1-1 mood-context state)))
        (set! (-> (the-as forrescb-states (+ (* arg0 4) (the-as int v1-2))) turret 0) 1.0)
        )
      )
    )
  )

;; definition for function set-forrescb-electricity-scale!
(defun set-forrescb-electricity-scale! ((arg0 float) (arg1 int))
  (let ((v1-1 (level-get *level* 'forrescb)))
    (when v1-1
      (let ((v1-2 (the-as object (-> v1-1 mood-context state))))
        (set! (-> (the-as forrescb-states v1-2) electricity arg1 scale) arg0)
        )
      )
    )
  )

;; definition of type prison-states
(deftype prison-states (structure)
  ((pulse         float)
   (angle         float)
   (torture       float)
   (torture-flag  symbol)
   )
  )

;; definition for method 3 of type prison-states
(defmethod inspect ((this prison-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'prison-states)
  (format #t "~1Tpulse: ~f~%" (-> this pulse))
  (format #t "~1Tangle: ~f~%" (-> this angle))
  (format #t "~1Ttorture: ~f~%" (-> this torture))
  (format #t "~1Ttorture-flag: ~A~%" (-> this torture-flag))
  (label cfg-4)
  this
  )

;; definition for function update-prison-lights
;; WARN: Return type mismatch int vs none.
(defun update-prison-lights ((arg0 mood-context))
  (let ((v1-0 (-> arg0 light-group)))
    (set-vector! (-> v1-0 0 dir0 color) 0.0 0.0 0.0 1.0)
    (set-vector! (-> v1-0 0 ambi color) 0.2 0.2 0.2 1.0)
    )
  (set! (-> arg0 light-group 0 dir0 extra x) 0.0)
  0
  (none)
  )

;; definition for function init-mood-prison
(defun init-mood-prison ((arg0 mood-context))
  (let ((v1-0 (the-as prison-states (-> arg0 state))))
    (set! (-> v1-0 torture-flag) #f)
    (set! (-> v1-0 torture) 0.0)
    )
  )

;; definition for function update-mood-prison
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-prison time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (update-prison-lights arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (let ((gp-0 (the-as prison-states (-> arg0 state))))
        (set! (-> arg0 times 0 w) 1.0)
        (set! (-> arg0 times 1 w) 1.0)
        (set! (-> arg0 times 3 w) 1.0)
        (set! (-> arg0 times 4 w) 1.0)
        (set! (-> arg0 times 5 w) 1.0)
        (set! (-> arg0 times 6 w) (-> gp-0 pulse))
        (if (task-node-closed? (game-task-node fortress-save-friends-resolution))
            (set! (-> arg0 times 7 w) 1.0)
            (set! (-> arg0 times 7 w) 0.0)
            )
        (set! (-> arg0 times 2 w) (-> gp-0 torture))
        (when (not (paused?))
          (set! (-> gp-0 pulse) (+ 1.125 (* 0.125 (cos (-> gp-0 angle)))))
          (let ((f0-14 (+ (-> gp-0 angle) (* 32768.0 (seconds-per-frame)))))
            (set! (-> gp-0 angle) (- f0-14 (* (the float (the int (/ f0-14 65536.0))) 65536.0)))
            )
          (if (-> gp-0 torture-flag)
              (seek! (-> gp-0 torture) 1.0 (seconds-per-frame))
              (seek! (-> gp-0 torture) 0.0 (seconds-per-frame))
              )
          )
        )
      )
    )
  0
  (none)
  )

;; definition for function update-mood-copy-prison
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-copy-prison time-of-day-proc ((arg0 mood-context))
  (let ((v1-1 (level-get *level* 'prison)))
    (if (and v1-1 (= (-> v1-1 status) 'active))
        (mem-copy! (the-as pointer arg0) (the-as pointer (-> v1-1 mood-context)) 1968)
        )
    )
  0
  (none)
  )

;; definition for function set-prison-torture-flag!
(defun set-prison-torture-flag! ((arg0 symbol))
  (let ((v1-1 (level-get *level* 'prison)))
    (when v1-1
      (set! (-> (the-as prison-states (-> v1-1 mood-context state)) torture-flag) arg0)
      arg0
      )
    )
  )

;; definition of type under-states
(deftype under-states (structure)
  ((flame0      flames-state  :inline)
   (flame1      flames-state  :inline)
   (rot         float)
   (rot2        float)
   (time        float)
   (laser       float)
   (fog-interp  float)
   (flicker     float)
   )
  )

;; definition for method 3 of type under-states
(defmethod inspect ((this under-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'under-states)
  (format #t "~1Tflame0: #<flames-state @ #x~X>~%" (-> this flame0))
  (format #t "~1Tflame1: #<flames-state @ #x~X>~%" (-> this flame1))
  (format #t "~1Trot: ~f~%" (-> this rot))
  (format #t "~1Trot2: ~f~%" (-> this rot2))
  (format #t "~1Ttime: ~f~%" (-> this time))
  (format #t "~1Tlaser: ~f~%" (-> this laser))
  (format #t "~1Tfog-interp: ~f~%" (-> this fog-interp))
  (format #t "~1Tflicker: ~f~%" (-> this flicker))
  (label cfg-4)
  this
  )

;; definition for function update-under-lights
;; INFO: Used lq/sq
(defun update-under-lights ((arg0 mood-context))
  (local-vars (sv-80 vector))
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (let* ((v1-0 (the-as under-states (-> arg0 state)))
           (a2-0 (new 'stack-no-clear 'matrix))
           (a1-0 (-> arg0 current-fog))
           (f0-0 (-> v1-0 fog-interp))
           )
      (set-vector! (-> a2-0 vector 0) 0.0 40.2343 59.5468 128.0)
      (set-vector! (-> a2-0 vector 1) 0.0 524288.0 200.0 8.0)
      (set-vector! (-> a2-0 vector 2) 0.0 40.2343 59.5468 128.0)
      (set-vector! (-> a1-0 fog-color) 0.0 40.2343 59.5468 128.0)
      (set-vector! (-> a1-0 fog-dists) 524288.0 1048576.0 255.0 8.0)
      (set-vector! (-> a1-0 erase-color) 0.0 40.2343 59.5468 128.0)
      (set-vector! (-> a1-0 erase-color) 0.0 40.2343 59.5468 128.0)
      (vector4-array-lerp!
        (the-as (inline-array vector4) a1-0)
        (the-as (inline-array vector4) a1-0)
        (the-as (inline-array vector4) a2-0)
        f0-0
        3
        )
      )
    (let ((s2-0 (-> arg0 light-group))
          (s3-0 (-> arg0 light-group 1))
          (s4-0 (-> arg0 light-group 2))
          (s5-0 (-> arg0 light-group 3))
          (gp-1 (-> arg0 light-group 4))
          )
      (let ((s1-0 (new 'static 'vector :x 0.8645 :z -0.5294)))
        (set! sv-80 (new 'static 'vector :x -2.0 :z 1950.0))
        (let ((v0-1 (target-pos 0))
              (s0-0 (new 'stack-no-clear 'vector))
              )
          (let ((v1-10 s0-0))
            (.lvf vf4 (&-> v0-1 quad))
            (.lvf vf5 (&-> sv-80 quad))
            (.mov.vf vf6 vf0 :mask #b1000)
            (.sub.vf vf6 vf4 vf5 :mask #b111)
            (.svf (&-> v1-10 quad) vf6)
            )
          (vector-normalize! s0-0 1.0)
          (cond
            ((>= (vector-dot s1-0 s0-0) 0.0)
             (set-vector! (-> s2-0 0 dir0 color) 0.6 0.5 0.7 1.0)
             (set-vector! (-> s2-0 0 ambi color) 0.3 0.3 0.3 1.0)
             )
            (else
              (set-vector! (-> s2-0 0 dir0 color) 0.2 0.2 0.4 1.0)
              (set-vector! (-> s2-0 0 ambi color) 0.2 0.2 0.2 1.0)
              )
            )
          )
        )
      (let ((v1-16 (-> s3-0 dir0)))
        (set! (-> v1-16 direction x) 0.0)
        (set! (-> v1-16 direction y) 1.0)
        (set! (-> v1-16 direction z) 0.0)
        (set! (-> v1-16 direction w) 0.0)
        )
      (set-vector! (-> s3-0 dir0 color) 0.0 0.0 0.0 1.0)
      (set-vector! (-> s3-0 ambi color) 1.0 1.0 1.0 1.0)
      (set! (-> s3-0 dir0 extra x) 0.0)
      (set! (-> s3-0 dir1 extra x) 0.0)
      (set! (-> s3-0 dir2 extra x) 0.0)
      (set! (-> s3-0 ambi extra x) 1.0)
      (let ((v1-20 (-> s4-0 dir0)))
        (set! (-> v1-20 direction x) 0.0)
        (set! (-> v1-20 direction y) -1.0)
        (set! (-> v1-20 direction z) 0.0)
        (set! (-> v1-20 direction w) 0.0)
        )
      (let ((v1-21 (-> s4-0 dir1)))
        (set! (-> v1-21 direction x) 0.0)
        (set! (-> v1-21 direction y) 1.0)
        (set! (-> v1-21 direction z) 0.0)
        (set! (-> v1-21 direction w) 0.0)
        )
      (set-vector! (-> s4-0 dir0 color) 0.3 0.4 0.6 1.0)
      (set-vector! (-> s4-0 dir1 color) 0.3 0.4 0.6 1.0)
      (set-vector! (-> s4-0 ambi color) 0.15 0.3 0.6 1.0)
      (set! (-> s4-0 dir0 extra x) 1.0)
      (set! (-> s4-0 dir1 extra x) 1.0)
      (set! (-> s4-0 dir2 extra x) 0.0)
      (set! (-> s4-0 ambi extra x) 1.0)
      (let ((v1-28 (-> s5-0 dir0)))
        (set! (-> v1-28 direction x) 0.0)
        (set! (-> v1-28 direction y) 1.0)
        (set! (-> v1-28 direction z) 0.0)
        (set! (-> v1-28 direction w) 0.0)
        )
      (set-vector! (-> s5-0 dir0 color) 0.3 0.25 0.35 1.0)
      (set-vector! (-> s5-0 ambi color) 0.3 0.3 0.3 1.0)
      (set! (-> s5-0 dir0 extra x) 0.65)
      (set! (-> s5-0 dir1 extra x) 0.0)
      (set! (-> s5-0 dir2 extra x) 0.0)
      (set! (-> s5-0 ambi extra x) 1.0)
      (let ((v1-33 (-> gp-1 dir0)))
        (set! (-> v1-33 direction x) 0.0)
        (set! (-> v1-33 direction y) 1.0)
        (set! (-> v1-33 direction z) 0.0)
        (set! (-> v1-33 direction w) 0.0)
        )
      (set-vector! (-> gp-1 dir0 color) 0.3 0.25 0.45 1.0)
      (set-vector! (-> gp-1 ambi color) 0.3 0.3 0.3 1.0)
      (set! (-> gp-1 dir0 extra x) 0.5)
      (set! (-> gp-1 dir1 extra x) 0.0)
      (set! (-> gp-1 dir2 extra x) 0.0)
      (set! (-> gp-1 ambi extra x) 0.5)
      )
    )
  )

;; definition for function update-mood-under
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-under time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (update-under-lights arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (let ((gp-0 (the-as under-states (-> arg0 state))))
        (set! (-> arg0 times 0 w) 1.0)
        (set! (-> arg0 times 1 w) 1.0)
        (update-mood-caustics arg0 6 (-> gp-0 rot) 0.0 0.75 0.5)
        (update-mood-caustics arg0 7 (-> gp-0 rot) 21845.334 0.75 0.5)
        (update-mood-caustics arg0 3 (-> gp-0 rot2) 43690.668 0.75 0.25)
        (update-mood-flames arg0 2 1 0 0.75 0.0009765625 2.0)
        (let ((f0-6 (fmin 1.0 (+ (-> gp-0 flicker) (-> gp-0 laser)))))
          (set! (-> arg0 times 4 w) f0-6)
          (set! (-> arg0 times 5 w) (- 1.0 f0-6))
          )
        (when (movie?)
          (set! (-> arg0 times 4 w) 0.0)
          (set! (-> arg0 times 5 w) 0.0)
          )
        (when (not (paused?))
          (+! (-> gp-0 time) (* 300.0 (seconds-per-frame)))
          (+! (-> gp-0 rot) (* 32768.0 (seconds-per-frame)))
          (+! (-> gp-0 rot2) (* 16384.0 (seconds-per-frame)))
          (set! (-> gp-0 flicker) (rand-vu-float-range 0.0 0.1))
          )
        )
      )
    )
  0
  (none)
  )

;; definition for function update-mood-copy-underb
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-copy-underb time-of-day-proc ((arg0 mood-context))
  (let ((v1-1 (level-get *level* 'underb)))
    (if (and v1-1 (= (-> v1-1 status) 'active))
        (mem-copy! (the-as pointer arg0) (the-as pointer (-> v1-1 mood-context)) 1968)
        )
    )
  0
  (none)
  )

;; definition for function set-under-laser!
(defun set-under-laser! ((arg0 float))
  (let ((v1-1 (level-get *level* 'under)))
    (when v1-1
      (let ((v1-2 (the-as object (-> v1-1 mood-context state))))
        (set! (-> (the-as under-states v1-2) laser) arg0)
        )
      )
    )
  (let ((v1-4 (level-get *level* 'underb)))
    (when v1-4
      (let ((v1-5 (the-as object (-> v1-4 mood-context state))))
        (set! (-> (the-as under-states v1-5) laser) arg0)
        )
      )
    )
  )

;; definition for function set-under-fog-interp!
(defun set-under-fog-interp! ((arg0 float))
  (let ((v1-1 (level-get *level* 'under)))
    (when v1-1
      (let ((v1-2 (the-as object (-> v1-1 mood-context state))))
        (set! (-> (the-as under-states v1-2) fog-interp) arg0)
        )
      )
    )
  (let ((v1-4 (level-get *level* 'underb)))
    (when v1-4
      (let ((v1-5 (the-as object (-> v1-4 mood-context state))))
        (set! (-> (the-as under-states v1-5) fog-interp) arg0)
        )
      )
    )
  )

;; definition of type gungame-states
(deftype gungame-states (structure)
  ((florescent  florescent-state  :inline)
   )
  )

;; definition for method 3 of type gungame-states
(defmethod inspect ((this gungame-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'gungame-states)
  (format #t "~1Tflorescent: #<florescent-state @ #x~X>~%" (-> this florescent))
  (label cfg-4)
  this
  )

;; definition for function update-gungame-lights
;; WARN: Return type mismatch int vs none.
(defun update-gungame-lights ((arg0 mood-context))
  (let ((v1-0 (-> arg0 light-group)))
    (let ((a0-1 (-> v1-0 0)))
      (set! (-> a0-1 dir0 direction x) 0.0)
      (set! (-> a0-1 dir0 direction y) 0.955)
      (set! (-> a0-1 dir0 direction z) 0.3)
      (set! (-> a0-1 dir0 direction w) 1.0)
      )
    (set-vector! (-> v1-0 0 dir0 color) 1.0 1.0 0.7 1.0)
    (set-vector! (-> v1-0 0 ambi color) 0.65 0.589 0.406 1.0)
    )
  0
  (none)
  )

;; definition for function update-mood-gungame
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-gungame time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (update-gungame-lights arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (set! (-> arg0 times 0 w) 1.0)
      (set! (-> arg0 times 1 w) 1.0)
      )
    )
  0
  (none)
  )

;; definition of type dig1-states
(deftype dig1-states (structure)
  ((pulse0     pulse-state  :inline)
   (pulse1     pulse-state  :inline)
   (explosion  float)
   (drillbit   float)
   )
  )

;; definition for method 3 of type dig1-states
(defmethod inspect ((this dig1-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'dig1-states)
  (format #t "~1Tpulse0: #<pulse-state @ #x~X>~%" (-> this pulse0))
  (format #t "~1Tpulse1: #<pulse-state @ #x~X>~%" (-> this pulse1))
  (format #t "~1Texplosion: ~f~%" (-> this explosion))
  (format #t "~1Tdrillbit: ~f~%" (-> this drillbit))
  (label cfg-4)
  this
  )

;; definition for function init-mood-dig1
(defun init-mood-dig1 ((arg0 mood-context))
  (let ((v1-0 (the-as object (-> arg0 state))))
    (set! (-> (the-as dig1-states v1-0) explosion) 0.0)
    )
  )

;; definition for function update-dig1-lights
;; WARN: Return type mismatch int vs none.
(defun update-dig1-lights ((arg0 mood-context))
  (let ((v1-0 (-> arg0 current-fog)))
    (set-vector! (-> v1-0 fog-color) 205.0 90.0 90.0 128.0)
    (set-vector! (-> v1-0 fog-dists) 294912.0 1802240.0 255.0 187.5)
    (set-vector! (-> v1-0 erase-color) 54.2635 23.823 23.823 128.0)
    )
  (set-vector! (-> arg0 current-env-color) 0.0 0.0 0.0 0.0)
  (let ((t2-0 (-> arg0 light-group))
        (t1-0 (-> arg0 light-group 1))
        (t0-0 (-> arg0 light-group 2))
        (a3-0 (-> arg0 light-group 3))
        (a2-8 (-> arg0 light-group 4))
        (a1-6 (-> arg0 light-group 5))
        (v1-3 (-> arg0 light-group 6))
        )
    (let ((a0-1 (-> t2-0 0)))
      (set! (-> a0-1 dir0 direction x) 0.0)
      (set! (-> a0-1 dir0 direction y) 0.955)
      (set! (-> a0-1 dir0 direction z) 0.3)
      (set! (-> a0-1 dir0 direction w) 1.0)
      )
    (set-vector! (-> t2-0 0 dir0 color) 0.9 0.6 0.6 1.0)
    (let ((a0-3 (-> t2-0 0 dir1)))
      (set! (-> a0-3 direction x) 0.0)
      (set! (-> a0-3 direction y) -1.0)
      (set! (-> a0-3 direction z) 0.0)
      (set! (-> a0-3 direction w) 1.0)
      )
    (set-vector! (-> t2-0 0 dir1 color) 0.9 0.3 0.3 1.0)
    (set-vector! (-> t2-0 0 ambi color) 0.65 0.589 0.406 1.0)
    (set! (-> t2-0 0 dir0 extra x) 0.9)
    (set! (-> t2-0 0 dir1 extra x) 0.3)
    (set! (-> t2-0 0 ambi extra x) 0.45)
    (let ((a0-9 (-> t1-0 dir0)))
      (set! (-> a0-9 direction x) 0.0)
      (set! (-> a0-9 direction y) 0.955)
      (set! (-> a0-9 direction z) 0.3)
      (set! (-> a0-9 direction w) 1.0)
      )
    (set-vector! (-> t1-0 dir0 color) 1.0 0.6 0.6 1.0)
    (let ((a0-11 (-> t1-0 dir1)))
      (set! (-> a0-11 direction x) 0.0)
      (set! (-> a0-11 direction y) -0.955)
      (set! (-> a0-11 direction z) -0.3)
      (set! (-> a0-11 direction w) 1.0)
      )
    (set-vector! (-> t1-0 dir1 color) 0.9 0.4 0.3 1.0)
    (set-vector! (-> t1-0 ambi color) 0.65 0.55 0.25 1.0)
    (set! (-> t1-0 dir0 extra x) 0.2)
    (set! (-> t1-0 dir1 extra x) 0.85)
    (set! (-> t1-0 ambi extra x) 0.5)
    (let ((a0-17 (-> t0-0 dir0)))
      (set! (-> a0-17 direction x) 0.0)
      (set! (-> a0-17 direction y) 0.955)
      (set! (-> a0-17 direction z) 0.3)
      (set! (-> a0-17 direction w) 1.0)
      )
    (set-vector! (-> t0-0 dir0 color) 0.8 0.5 0.4 1.0)
    (set-vector! (-> t0-0 ambi color) 0.6 0.4 0.3 1.0)
    (set! (-> t0-0 dir0 extra x) 0.5)
    (set! (-> t0-0 ambi extra x) 0.4)
    (let ((a0-22 (-> a3-0 dir0)))
      (set! (-> a0-22 direction x) 0.5299)
      (set! (-> a0-22 direction y) 0.8479)
      (set! (-> a0-22 direction z) 0.0)
      (set! (-> a0-22 direction w) 1.0)
      )
    (set-vector! (-> a3-0 dir0 color) 1.0 1.0 1.0 1.0)
    (let ((a0-24 (-> a3-0 dir1)))
      (set! (-> a0-24 direction x) 0.0)
      (set! (-> a0-24 direction y) -1.0)
      (set! (-> a0-24 direction z) 0.0)
      (set! (-> a0-24 direction w) 1.0)
      )
    (set-vector! (-> a3-0 dir1 color) 0.9 0.3 0.3 1.0)
    (set-vector! (-> a3-0 ambi color) 0.5 0.5 0.5 1.0)
    (set! (-> a3-0 dir0 extra x) 1.0)
    (set! (-> a3-0 dir1 extra x) 0.5)
    (set! (-> a3-0 ambi extra x) 0.6)
    (let ((a0-30 (-> a2-8 dir0)))
      (set! (-> a0-30 direction x) 0.3)
      (set! (-> a0-30 direction y) 0.955)
      (set! (-> a0-30 direction z) 0.0)
      (set! (-> a0-30 direction w) 1.0)
      )
    (set-vector! (-> a2-8 dir0 color) 1.0 1.0 1.0 1.0)
    (let ((a0-32 (-> a2-8 dir1)))
      (set! (-> a0-32 direction x) 0.0)
      (set! (-> a0-32 direction y) -1.0)
      (set! (-> a0-32 direction z) 0.0)
      (set! (-> a0-32 direction w) 1.0)
      )
    (set-vector! (-> a2-8 dir1 color) 0.9 0.3 0.3 1.0)
    (set-vector! (-> a2-8 ambi color) 0.5 0.5 0.5 1.0)
    (set! (-> a2-8 dir0 extra x) 1.0)
    (set! (-> a2-8 dir1 extra x) 0.5)
    (set! (-> a2-8 ambi extra x) 0.6)
    (let ((a0-38 (-> a1-6 dir0)))
      (set! (-> a0-38 direction x) 0.3)
      (set! (-> a0-38 direction y) 0.955)
      (set! (-> a0-38 direction z) 0.0)
      (set! (-> a0-38 direction w) 1.0)
      )
    (set-vector! (-> a1-6 dir0 color) 1.0 1.0 1.0 1.0)
    (let ((a0-40 (-> a1-6 dir1)))
      (set! (-> a0-40 direction x) 0.0)
      (set! (-> a0-40 direction y) -1.0)
      (set! (-> a0-40 direction z) 0.0)
      (set! (-> a0-40 direction w) 1.0)
      )
    (set-vector! (-> a1-6 dir1 color) 0.8 0.5 0.3 1.0)
    (set-vector! (-> a1-6 ambi color) 0.5 0.4 0.4 1.0)
    (set! (-> a1-6 dir0 extra x) 1.0)
    (set! (-> a1-6 dir1 extra x) 1.4)
    (set! (-> a1-6 ambi extra x) 0.6)
    (let ((a0-46 (-> v1-3 dir0)))
      (set! (-> a0-46 direction x) 0.3)
      (set! (-> a0-46 direction y) 0.955)
      (set! (-> a0-46 direction z) 0.0)
      (set! (-> a0-46 direction w) 1.0)
      )
    (set-vector! (-> v1-3 dir0 color) 0.8 0.9 0.5 1.0)
    (let ((a0-48 (-> v1-3 dir1)))
      (set! (-> a0-48 direction x) 0.5299)
      (set! (-> a0-48 direction y) 0.8479)
      (set! (-> a0-48 direction z) 0.0)
      (set! (-> a0-48 direction w) 1.0)
      )
    (set-vector! (-> v1-3 dir1 color) 0.6 0.4 0.3 1.0)
    (set-vector! (-> v1-3 ambi color) 0.6 0.5 0.4 1.0)
    (set! (-> v1-3 dir0 extra x) 0.6)
    (set! (-> v1-3 dir1 extra x) 0.55)
    (set! (-> v1-3 ambi extra x) 0.5)
    )
  0
  (none)
  )

;; definition for function update-mood-dig1
;; INFO: Used lq/sq
;; ERROR: Stack slot load at 16 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 32 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 16 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 32 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 16 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 32 mismatch: defined as size 4, got size 16
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-dig1 time-of-day-proc ((arg0 mood-context))
  (local-vars (sv-16 float) (sv-32 float))
  (update-mood-interior arg0)
  (update-dig1-lights arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (let ((gp-0 (the-as dig1-states (-> arg0 state))))
        (set! (-> arg0 times 0 w) 1.0)
        (set! (-> arg0 times 1 w) 1.0)
        (let ((s4-0 update-mood-pulse)
              (s3-0 arg0)
              (s2-0 2)
              (s1-0 0)
              (s0-0 0.85)
              )
          (set! sv-16 0.15)
          (let ((t1-0 (* 182.04445 (seconds-per-frame) (rand-vu-float-range 60.0 200.0)))
                (t2-0 0.0)
                )
            (s4-0 s3-0 s2-0 s1-0 s0-0 sv-16 t1-0 t2-0)
            )
          )
        (let ((s4-1 update-mood-pulse)
              (s3-1 arg0)
              (s2-1 3)
              (s1-1 4)
              (s0-1 0.85)
              )
          (set! sv-32 0.15)
          (let ((t1-1 (* 182.04445 (seconds-per-frame) (rand-vu-float-range 120.0 180.0)))
                (t2-1 16384.0)
                )
            (s4-1 s3-1 s2-1 s1-1 s0-1 sv-32 t1-1 t2-1)
            )
          )
        (set! (-> arg0 times 6 w) 1.0)
        (if (not (task-node-closed? (game-task-node dig-knock-down-resolution)))
            (set! (-> arg0 times 5 w) (-> gp-0 drillbit))
            )
        (when (!= (-> gp-0 explosion) 0.0)
          (set! (-> arg0 times 7 w) (-> gp-0 explosion))
          (let ((f0-15 (- 1.0 (* 0.5 (-> gp-0 explosion)))))
            (set! (-> arg0 times 2 w) (* (-> arg0 times 2 w) f0-15))
            (set! (-> arg0 times 3 w) (* (-> arg0 times 3 w) f0-15))
            (set! (-> arg0 times 0 w) (* (-> arg0 times 0 w) f0-15))
            (set! (-> arg0 times 1 w) (* (-> arg0 times 1 w) f0-15))
            )
          )
        (when (not (paused?))
          (set! (-> gp-0 drillbit) (rand-vu-float-range 0.5 1.0))
          (seek! (-> gp-0 explosion) 0.0 (* 2.5 (seconds-per-frame)))
          )
        )
      )
    )
  0
  (none)
  )

;; definition for function set-dig1-explosion!
(defun set-dig1-explosion! ((arg0 float))
  (let ((v1-1 (level-get *level* 'dig1)))
    (when v1-1
      (let ((v1-2 (the-as object (-> v1-1 mood-context state))))
        (set! (-> (the-as dig1-states v1-2) explosion) 1.9921875)
        )
      )
    )
  )

;; definition of type vortex-states
(deftype vortex-states (structure)
  ((time         float)
   (level        float)
   (delta        float)
   (scale        float)
   (flash        float)
   (num          int32)
   (white        symbol)
   (white-count  float)
   (pos          vector  :inline)
   (dir          vector  :inline)
   )
  )

;; definition for method 3 of type vortex-states
(defmethod inspect ((this vortex-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'vortex-states)
  (format #t "~1Ttime: ~f~%" (-> this time))
  (format #t "~1Tlevel: ~f~%" (-> this level))
  (format #t "~1Tdelta: ~f~%" (-> this delta))
  (format #t "~1Tscale: ~f~%" (-> this scale))
  (format #t "~1Tflash: ~f~%" (-> this flash))
  (format #t "~1Tnum: ~D~%" (-> this num))
  (format #t "~1Twhite: ~A~%" (-> this white))
  (format #t "~1Twhite-count: ~f~%" (-> this white-count))
  (format #t "~1Tpos: #<vector @ #x~X>~%" (-> this pos))
  (format #t "~1Tdir: #<vector @ #x~X>~%" (-> this dir))
  (label cfg-4)
  this
  )

;; definition for function update-vortex-lights
;; WARN: Return type mismatch int vs none.
(defun update-vortex-lights ((arg0 mood-context))
  (set-vector! (-> arg0 current-env-color) 96.0 48.0 196.0 255.0)
  0
  (none)
  )

;; definition for function update-mood-vortex
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-vortex time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (update-vortex-lights arg0)
  (let ((a1-0 (-> arg0 light-group))
        (s5-0 (-> arg0 light-group 1))
        (gp-1 (the-as vortex-states (-> arg0 state)))
        )
    (set-vector! (-> a1-0 0 ambi color) 0.2 0.2 0.5 1.0)
    (set! (-> a1-0 0 ambi extra x) 1.0)
    (set-vector! (-> a1-0 0 dir0 color) 0.5 0.4 0.8 1.0)
    (set! (-> a1-0 0 dir0 direction quad) (-> gp-1 dir quad))
    (set! (-> a1-0 0 dir0 extra x) (-> gp-1 level))
    (set-vector! (-> a1-0 0 dir1 color) 0.0 0.0 0.0 0.0)
    (let ((v1-5 (-> a1-0 0 dir1)))
      (set! (-> v1-5 direction x) 0.0)
      (set! (-> v1-5 direction y) 0.0)
      (set! (-> v1-5 direction z) 1.0)
      (set! (-> v1-5 direction w) 0.0)
      )
    (set! (-> a1-0 0 dir1 extra x) 0.0)
    (set! (-> a1-0 0 dir2 extra x) 0.0)
    (mem-copy! (the-as pointer s5-0) (the-as pointer a1-0) 192)
    (cond
      ((-> gp-1 white)
       (set-vector! (-> s5-0 dir1 color) 1.0 1.0 1.0 1.0)
       (set-vector! (-> s5-0 dir2 color) 1.0 1.0 1.0 1.0)
       (let ((v1-9 (-> s5-0 dir1)))
         (set! (-> v1-9 direction x) 0.0)
         (set! (-> v1-9 direction y) -0.707)
         (set! (-> v1-9 direction z) 0.707)
         (set! (-> v1-9 direction w) 0.0)
         )
       (let ((v1-10 (-> s5-0 dir2)))
         (set! (-> v1-10 direction x) 0.0)
         (set! (-> v1-10 direction y) 0.707)
         (set! (-> v1-10 direction z) 0.707)
         (set! (-> v1-10 direction w) 0.0)
         )
       (set! (-> s5-0 dir1 extra x) (fmin 1.0 (* 0.21739131 (-> gp-1 white-count))))
       (set! (-> s5-0 dir2 extra x) (-> s5-0 dir1 extra x))
       )
      (else
        (set-vector! (-> s5-0 dir1 color) 0.1 0.3 0.5 1.0)
        (let ((v1-15 (-> s5-0 dir1)))
          (set! (-> v1-15 direction x) 0.0)
          (set! (-> v1-15 direction y) -0.177)
          (set! (-> v1-15 direction z) 0.984)
          (set! (-> v1-15 direction w) 0.0)
          )
        (set! (-> s5-0 dir1 extra x) 1.0)
        )
      )
    (when (not (paused?))
      (if (-> gp-1 white)
          (+! (-> gp-1 white-count) (-> *display* base-clock seconds-per-frame))
          )
      (cond
        ((< 0.0 (-> gp-1 flash))
         (set! (-> gp-1 level) (-> gp-1 flash))
         (set-vector! (-> gp-1 dir) 0.0 0.0 1.0 0.0)
         (set! (-> gp-1 flash) (- (-> gp-1 flash) (* 0.5 (-> *display* base-clock seconds-per-frame))))
         (set! (-> gp-1 time) 0.0)
         )
        (else
          (when (>= 0.0 (-> gp-1 time))
            (set! (-> gp-1 num) (the int (rand-vu-float-range 0.0 4.0)))
            (set! (-> gp-1 scale) (rand-vu-float-range 0.75 1.5))
            (if (< (-> gp-1 num) 3)
                (set! (-> gp-1 time) (rand-vu-float-range 0.25 0.5))
                (set! (-> gp-1 time) (rand-vu-float-range 0.0 0.5))
                )
            (set-vector!
              (-> gp-1 pos)
              (rand-vu-float-range -8192.0 8192.0)
              (rand-vu-float-range -8192.0 8192.0)
              102400.0
              0.0
              )
            (set! (-> gp-1 delta) (/ 204800.0 (-> gp-1 time)))
            )
          (when (< (-> gp-1 num) 3)
            (let ((f30-0 (vector-length (-> gp-1 pos))))
              (set! (-> gp-1 dir quad) (-> gp-1 pos quad))
              (vector-normalize! (-> gp-1 dir) 1.0)
              (set! (-> gp-1 level) (* (-> gp-1 scale) (- 1.0 (fmin 1.0 (* 0.000009765625 f30-0)))))
              )
            (set! (-> gp-1 pos z) (- (-> gp-1 pos z) (* (-> gp-1 delta) (-> *display* base-clock seconds-per-frame))))
            )
          (set! (-> gp-1 time) (- (-> gp-1 time) (-> *display* base-clock seconds-per-frame)))
          )
        )
      )
    )
  0
  (none)
  )

;; definition for function set-vortex-flash!
(defun set-vortex-flash! ((arg0 float))
  (let ((v1-1 (level-get *level* 'introcst)))
    (when v1-1
      (let ((v1-2 (the-as object (-> v1-1 mood-context state))))
        (set! (-> (the-as vortex-states v1-2) flash) 1.0)
        )
      )
    )
  (let ((v1-4 (level-get *level* 'lintcstb)))
    (when v1-4
      (let ((v1-5 (the-as object (-> v1-4 mood-context state))))
        (set! (-> (the-as vortex-states v1-5) flash) 1.0)
        )
      )
    )
  )

;; definition for function set-vortex-white!
(defun set-vortex-white! ((arg0 symbol))
  (let ((v1-1 (level-get *level* 'introcst)))
    (when v1-1
      (let ((v1-2 (the-as vortex-states (-> v1-1 mood-context state))))
        (set! (-> v1-2 white) arg0)
        (set! (-> v1-2 white-count) 0.0)
        )
      )
    )
  (let ((v1-4 (level-get *level* 'lintcstb)))
    (when v1-4
      (let ((v1-5 (the-as vortex-states (-> v1-4 mood-context state))))
        (set! (-> v1-5 white) arg0)
        (set! (-> v1-5 white-count) 0.0)
        )
      )
    )
  )

;; definition of type nestb-states
(deftype nestb-states (structure)
  ((pulse         pulse-state  :inline)
   (rot           float)
   (purple        float)
   (purple-noise  float)
   )
  )

;; definition for method 3 of type nestb-states
(defmethod inspect ((this nestb-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'nestb-states)
  (format #t "~1Tpulse: #<pulse-state @ #x~X>~%" (-> this pulse))
  (format #t "~1Trot: ~f~%" (-> this rot))
  (format #t "~1Tpurple: ~f~%" (-> this purple))
  (format #t "~1Tpurple-noise: ~f~%" (-> this purple-noise))
  (label cfg-4)
  this
  )

;; definition for function update-nestb-lights
;; WARN: Return type mismatch pointer vs none.
(defun update-nestb-lights ((arg0 mood-context))
  (let ((gp-0 (-> arg0 light-group 1)))
    (let ((v1-0 (-> arg0 current-fog)))
      (set! (-> v1-0 fog-color x) 37.5625)
      (set! (-> v1-0 fog-color y) 18.875)
      (set! (-> v1-0 fog-color z) 70.0)
      (set! (-> v1-0 fog-color w) 128.0)
      )
    (set-vector! (-> arg0 current-fog fog-dists) 0.0 819200.0 255.0 16.0)
    (set-vector! (-> arg0 current-fog erase-color) 33.806248 16.9875 63.0 128.0)
    (let ((v1-4 (level-get *level* 'nest)))
      (if v1-4
          (mem-copy! (the-as pointer gp-0) (the-as pointer (-> v1-4 mood-context light-group)) 192)
          (mem-copy! (the-as pointer gp-0) (the-as pointer (-> *level* default-level mood-context light-group)) 192)
          )
      )
    )
  (none)
  )

;; definition for function update-mood-nestb
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-nestb time-of-day-proc ((arg0 mood-context) (arg1 object) (arg2 int))
  (copy-mood-exterior-ambi arg0 #f)
  (update-mood-interior arg0)
  (update-nestb-lights arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((gp-1 (the-as nestb-states (-> arg0 state))))
      (set! (-> arg0 times 1 w) 1.0)
      (update-mood-caustics arg0 2 (-> gp-1 rot) 10922.667 0.75 0.25)
      (update-mood-caustics arg0 3 (-> gp-1 rot) 0.0 0.75 0.25)
      (update-mood-pulse arg0 4 0 0.875 0.125 (* 196608.0 (seconds-per-frame)) 0.0)
      (set! (-> arg0 times 5 w) (+ (-> gp-1 purple) (-> gp-1 purple-noise)))
      (when (not (paused?))
        (seek! (-> gp-1 purple) 0.0 (* 4.0 (seconds-per-frame)))
        (set! (-> gp-1 purple-noise) (rand-vu-float-range 0.0 (* 0.2 (-> gp-1 purple))))
        (+! (-> gp-1 rot) (* 16384.0 (seconds-per-frame)))
        )
      )
    )
  0
  (none)
  )

;; definition for function set-nestb-purple!
(defun set-nestb-purple! ((arg0 float))
  (let ((v1-1 (level-get *level* 'nestb)))
    (when v1-1
      (let ((v1-2 (the-as object (-> v1-1 mood-context state))))
        (set! (-> (the-as nestb-states v1-2) purple) arg0)
        )
      )
    )
  )

;; definition for function get-nestb-purple
(defun get-nestb-purple ()
  (let ((v1-1 (level-get *level* 'nestb)))
    (if v1-1
        (-> (the-as nestb-states (-> v1-1 mood-context state)) purple)
        0.0
        )
    )
  )

;; definition of type consiteb-states
(deftype consiteb-states (structure)
  ((flicker        float)
   (flicker-count  float)
   (flicker-state  int32)
   )
  )

;; definition for method 3 of type consiteb-states
(defmethod inspect ((this consiteb-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'consiteb-states)
  (format #t "~1Tflicker: ~f~%" (-> this flicker))
  (format #t "~1Tflicker-count: ~f~%" (-> this flicker-count))
  (format #t "~1Tflicker-state: ~D~%" (-> this flicker-state))
  (label cfg-4)
  this
  )

;; definition for function init-mood-consiteb
;; WARN: Return type mismatch int vs none.
(defun init-mood-consiteb ((arg0 mood-context))
  (let ((v1-0 (the-as consiteb-states (-> arg0 state))))
    (set! (-> v1-0 flicker) 1.0)
    (set! (-> v1-0 flicker-state) 0)
    )
  0
  (none)
  )

;; definition for function update-mood-consiteb
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-consiteb time-of-day-proc ((arg0 mood-context) (arg1 object) (arg2 int))
  (copy-mood-exterior-ambi arg0 #f)
  (update-mood-interior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((gp-1 (the-as consiteb-states (-> arg0 state))))
      (set! (-> arg0 times 0 w) 0.0)
      (set! (-> arg0 times 1 w) 1.0)
      (set! (-> arg0 times 2 w) (-> gp-1 flicker))
      (when (not (paused?))
        (let ((v1-9 (-> gp-1 flicker-state)))
          (cond
            ((zero? v1-9)
             (set! (-> gp-1 flicker) (rand-vu-float-range 0.2 0.4))
             (set! (-> gp-1 flicker-count) (- (-> gp-1 flicker-count) (seconds-per-frame)))
             (when (>= 0.0 (-> gp-1 flicker-count))
               (set! (-> gp-1 flicker-count) (rand-vu-float-range 0.25 1.0))
               (set! (-> gp-1 flicker-state) 1)
               )
             )
            ((= v1-9 1)
             (set! (-> gp-1 flicker-count) (- (-> gp-1 flicker-count) (seconds-per-frame)))
             (when (>= 0.0 (-> gp-1 flicker-count))
               (set! (-> gp-1 flicker-count) (rand-vu-float-range 0.1 0.5))
               (set! (-> gp-1 flicker-state) 2)
               )
             )
            ((= v1-9 2)
             (set! (-> gp-1 flicker) (rand-vu-float-range 0.25 0.75))
             (set! (-> gp-1 flicker-count) (- (-> gp-1 flicker-count) (seconds-per-frame)))
             (when (>= 0.0 (-> gp-1 flicker-count))
               (set! (-> gp-1 flicker-count) (rand-vu-float-range 0.25 1.0))
               (set! (-> gp-1 flicker-state) 3)
               )
             )
            (else
              (set! (-> gp-1 flicker-count) (- (-> gp-1 flicker-count) (seconds-per-frame)))
              (when (>= 0.0 (-> gp-1 flicker-count))
                (set! (-> gp-1 flicker-count) (rand-vu-float-range 0.1 0.5))
                (set! (-> gp-1 flicker-state) 0)
                0
                )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

;; definition of type castle-states
(deftype castle-states (structure)
  ((electricity  electricity-state  :inline)
   (pulse        pulse-state        2 :inline)
   (rot          float)
   (robot-rot    float)
   )
  )

;; definition for method 3 of type castle-states
(defmethod inspect ((this castle-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'castle-states)
  (format #t "~1Telectricity: #<electricity-state @ #x~X>~%" (-> this electricity))
  (format #t "~1Tpulse[2] @ #x~X~%" (-> this pulse))
  (format #t "~1Trot: ~f~%" (-> this rot))
  (format #t "~1Trobot-rot: ~f~%" (-> this robot-rot))
  (label cfg-4)
  this
  )

;; definition for function update-castle-lights
;; WARN: Return type mismatch int vs none.
(defun update-castle-lights ((arg0 mood-context))
  (let ((a2-0 (-> arg0 light-group))
        (a1-0 (-> arg0 light-group 1))
        (v1-0 (-> arg0 light-group 2))
        )
    (let ((a3-0 (-> arg0 current-fog)))
      (set! (-> a3-0 fog-color x) 95.625)
      (set! (-> a3-0 fog-color y) 135.4687)
      (set! (-> a3-0 fog-color z) 69.0625)
      (set! (-> a3-0 fog-color w) 1.0)
      )
    (set-vector! (-> arg0 current-fog fog-dists) 253952.0 901120.0 255.0 147.0)
    (set-vector! (-> arg0 current-fog erase-color) 0.0 0.0 0.0 128.0)
    (set-vector! (-> arg0 current-env-color) 96.0 96.0 96.0 255.0)
    (let ((a3-4 (-> a2-0 0)))
      (set! (-> a3-4 dir0 direction x) 0.6499)
      (set! (-> a3-4 dir0 direction y) 0.7134)
      (set! (-> a3-4 dir0 direction z) 0.2619)
      (set! (-> a3-4 dir0 direction w) 1.0)
      )
    (set-vector! (-> a2-0 0 dir0 color) 0.65 0.575 0.575 1.0)
    (let ((a3-6 (-> a2-0 0 dir1)))
      (set! (-> a3-6 direction x) -0.6499)
      (set! (-> a3-6 direction y) 0.7134)
      (set! (-> a3-6 direction z) -0.2619)
      (set! (-> a3-6 direction w) 1.0)
      )
    (set-vector! (-> a2-0 0 dir1 color) 0.75 0.6 0.5 1.0)
    (set-vector! (-> a2-0 0 ambi color) 0.2 0.2 0.25 1.0)
    (set! (-> a2-0 0 dir0 extra x) 0.65)
    (set! (-> a2-0 0 dir1 extra x) 1.0)
    (set! (-> a2-0 0 ambi extra x) 0.7)
    (let ((a2-1 (-> a1-0 dir0)))
      (set! (-> a2-1 direction x) 0.0)
      (set! (-> a2-1 direction y) 1.0)
      (set! (-> a2-1 direction z) 0.0)
      (set! (-> a2-1 direction w) 1.0)
      )
    (set-vector! (-> a1-0 dir0 color) 0.7 0.8 0.5 1.0)
    (let ((a2-3 (-> a1-0 dir1)))
      (set! (-> a2-3 direction x) 0.5299)
      (set! (-> a2-3 direction y) -0.8479)
      (set! (-> a2-3 direction z) 0.0)
      (set! (-> a2-3 direction w) 1.0)
      )
    (set-vector! (-> a1-0 dir1 color) 0.5 0.6 0.0 1.0)
    (let ((a2-5 (-> a1-0 dir2)))
      (set! (-> a2-5 direction x) -0.5299)
      (set! (-> a2-5 direction y) -0.8479)
      (set! (-> a2-5 direction z) 0.0)
      (set! (-> a2-5 direction w) 1.0)
      )
    (set-vector! (-> a1-0 dir2 color) 0.5 0.6 0.0 1.0)
    (set-vector! (-> a1-0 ambi color) 0.2 0.2 0.25 1.0)
    (set! (-> a1-0 dir0 extra x) 0.7)
    (set! (-> a1-0 dir1 extra x) 0.8)
    (set! (-> a1-0 dir2 extra x) 0.8)
    (set! (-> a1-0 ambi extra x) 0.7)
    (let ((a1-1 (-> v1-0 dir0)))
      (set! (-> a1-1 direction x) 0.0)
      (set! (-> a1-1 direction y) 0.717)
      (set! (-> a1-1 direction z) 0.717)
      (set! (-> a1-1 direction w) 1.0)
      )
    (set-vector! (-> v1-0 dir0 color) 0.5 0.5 0.7 1.0)
    (let ((a1-3 (-> v1-0 dir1)))
      (set! (-> a1-3 direction x) 0.0)
      (set! (-> a1-3 direction y) 0.717)
      (set! (-> a1-3 direction z) -0.717)
      (set! (-> a1-3 direction w) 1.0)
      )
    (set-vector! (-> v1-0 dir1 color) 0.5 0.5 0.8 1.0)
    (set-vector! (-> v1-0 ambi color) 0.2 0.2 0.25 1.0)
    (set! (-> v1-0 dir0 extra x) (-> arg0 times 4 w))
    (set! (-> v1-0 dir1 extra x) (-> arg0 times 5 w))
    (set! (-> v1-0 ambi extra x) 0.75)
    )
  0
  (none)
  )

;; definition for function init-mood-castle
(defun init-mood-castle ((arg0 mood-context))
  (let ((v1-0 (the-as object (-> arg0 state))))
    (set! (-> (the-as castle-states v1-0) electricity scale) 1.0)
    )
  )

;; definition for function update-mood-castle
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-castle time-of-day-proc ((arg0 mood-context))
  (update-mood-interior arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (let ((s5-0 (the-as castle-states (-> arg0 state))))
        (set! (-> arg0 times 0 w) 1.0)
        (set! (-> arg0 times 1 w) 1.0)
        (update-mood-caustics arg0 2 (-> s5-0 rot) 0.0 0.8 0.5)
        (update-mood-caustics arg0 3 (-> s5-0 rot) 32768.0 0.8 0.5)
        (let ((f0-7 (+ 0.75 (* 0.25 (sin (-> s5-0 robot-rot))))))
          (set! (-> arg0 times 6 x) f0-7)
          (set! (-> arg0 times 6 y) f0-7)
          )
        (set! (-> arg0 times 6 w) 1.0)
        (update-mood-pulse arg0 4 8 1.15 0.15 (* 43690.668 (seconds-per-frame)) 0.0)
        (update-mood-pulse arg0 5 24 1.3 0.2 (* 54613.332 (seconds-per-frame)) 0.0)
        (update-mood-electricity arg0 7 0 0.9 1.0)
        (when (not (paused?))
          (+! (-> s5-0 rot) (* 13107.2 (seconds-per-frame)))
          (+! (-> s5-0 robot-rot) (* 32768.0 (seconds-per-frame)))
          )
        )
      )
    )
  (update-castle-lights arg0)
  0
  (none)
  )

;; definition for function set-castle-electricity-scale!
(defun set-castle-electricity-scale! ((arg0 float))
  (let ((v1-1 (level-get *level* 'castle)))
    (when v1-1
      (let ((v1-2 (the-as object (-> v1-1 mood-context state))))
        (set! (-> (the-as castle-states v1-2) electricity scale) arg0)
        )
      )
    )
  )

;; definition of type garage-states
(deftype garage-states (structure)
  ()
  )

;; definition for method 3 of type garage-states
(defmethod inspect ((this garage-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'garage-states)
  (label cfg-4)
  this
  )

;; definition for function init-mood-garage
(defun init-mood-garage ((arg0 mood-context))
  (-> arg0 state)
  #f
  )

;; definition for function update-garage-lights
;; WARN: Return type mismatch int vs none.
(defun update-garage-lights ((arg0 mood-context))
  (let ((a1-0 (-> *level* default-level mood-context))
        (a0-1 (-> arg0 current-fog))
        )
    (mem-copy! (the-as pointer a0-1) (the-as pointer a1-0) 48)
    )
  (let ((s4-0 (-> *level* default-level mood-context light-group))
        (a1-1 (-> arg0 light-group))
        (s5-0 (-> arg0 light-group 1))
        (gp-1 (-> arg0 light-group 2))
        )
    (mem-copy! (the-as pointer s5-0) (the-as pointer a1-1) 192)
    (set! (-> s5-0 dir0 extra x) 0.5)
    (set! (-> s5-0 ambi extra x) 0.0)
    (mem-copy! (the-as pointer gp-1) (the-as pointer s4-0) 192)
    (set! (-> gp-1 dir0 extra x) 0.0)
    (set! (-> gp-1 dir1 extra x) 0.0)
    (set! (-> gp-1 dir2 extra x) 0.0)
    )
  0
  (none)
  )

;; definition for function update-mood-garage
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-garage time-of-day-proc ((arg0 mood-context) (arg1 object) (arg2 int))
  (copy-mood-exterior-ambi arg0 #f)
  (update-mood-interior arg0)
  (update-garage-lights arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (-> arg0 state)
    (set! (-> arg0 times 6 w) 0.75)
    (set! (-> arg0 times 1 w) 1.0)
    (set! (-> arg0 times 7 w) 1.0)
    )
  0
  (none)
  )

;; definition for function update-mood-copy-garage
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-copy-garage time-of-day-proc ((arg0 mood-context))
  (let ((v1-1 (level-get *level* 'garage)))
    (if (and v1-1 (= (-> v1-1 status) 'active))
        (mem-copy! (the-as pointer arg0) (the-as pointer (-> v1-1 mood-context)) 1968)
        )
    )
  0
  (none)
  )

;; definition of type palshaft-states
(deftype palshaft-states (structure)
  ()
  )

;; definition for method 3 of type palshaft-states
(defmethod inspect ((this palshaft-states))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" this 'palshaft-states)
  (label cfg-4)
  this
  )

;; definition for function update-mood-palshaft
;; WARN: Return type mismatch int vs none.
(defbehavior update-mood-palshaft time-of-day-proc ((arg0 mood-context))
  (copy-mood-exterior-ambi arg0 #f)
  (update-mood-interior arg0)
  (if (< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
      (palette-select-special arg0)
      (set! (-> arg0 times 1 w) 1.0)
      )
  0
  (none)
  )
