#include "ssound.h"

#include <array>

#include "common/util/Assert.h"

#include "game/overlord/jak3/iso.h"
#include "game/overlord/jak3/overlord.h"
#include "game/overlord/jak3/spustreams.h"
#include "game/overlord/jak3/streamlist.h"
#include "game/overlord/jak3/vag.h"
#include "game/sce/iop.h"
#include "game/sound/sdshim.h"
#include "game/sound/sndshim.h"

namespace jak3 {

struct Curve {
  s32 a, b, c, d;
};

constexpr int kNumSounds = 0x40;

using namespace iop;
s32 g_n989Semaphore = -1;
s32 g_EarTransSema = -1;
bool g_bSoundEnable = true;
u32 g_anStreamVoice[6];
VolumePair g_aPanTable[361];
SoundInfo gSounds[kNumSounds];
s32 gEarTrans[6];
s32 gCamTrans[3];
s32 gCamForward[3];
s32 gCamLeft[3];
s32 gCamScale;
Curve gCurves[0x29];
std::array<u8, 1024> unktable;
bool g_CameraInvert = false;
u32 gLastTick = 0;

static s32 sqrt_table[256] = {
    0,     4096,  5793,  7094,  8192,  9159,  10033, 10837, 11585, 12288, 12953, 13585, 14189,
    14768, 15326, 15864, 16384, 16888, 17378, 17854, 18318, 18770, 19212, 19644, 20066, 20480,
    20886, 21283, 21674, 22058, 22435, 22806, 23170, 23530, 23884, 24232, 24576, 24915, 25249,
    25580, 25905, 26227, 26545, 26859, 27170, 27477, 27780, 28081, 28378, 28672, 28963, 29251,
    29537, 29819, 30099, 30377, 30652, 30924, 31194, 31462, 31727, 31991, 32252, 32511, 32768,
    33023, 33276, 33527, 33776, 34024, 34270, 34514, 34756, 34996, 35235, 35472, 35708, 35942,
    36175, 36406, 36636, 36864, 37091, 37316, 37540, 37763, 37985, 38205, 38424, 38642, 38858,
    39073, 39287, 39500, 39712, 39923, 40132, 40341, 40548, 40755, 40960, 41164, 41368, 41570,
    41771, 41972, 42171, 42369, 42567, 42763, 42959, 43154, 43348, 43541, 43733, 43925, 44115,
    44305, 44494, 44682, 44869, 45056, 45242, 45427, 45611, 45795, 45977, 46160, 46341, 46522,
    46702, 46881, 47059, 47237, 47415, 47591, 47767, 47942, 48117, 48291, 48465, 48637, 48809,
    48981, 49152, 49322, 49492, 49661, 49830, 49998, 50166, 50332, 50499, 50665, 50830, 50995,
    51159, 51323, 51486, 51649, 51811, 51972, 52134, 52294, 52454, 52614, 52773, 52932, 53090,
    53248, 53405, 53562, 53719, 53874, 54030, 54185, 54340, 54494, 54647, 54801, 54954, 55106,
    55258, 55410, 55561, 55712, 55862, 56012, 56162, 56311, 56459, 56608, 56756, 56903, 57051,
    57198, 57344, 57490, 57636, 57781, 57926, 58071, 58215, 58359, 58503, 58646, 58789, 58931,
    59073, 59215, 59357, 59498, 59639, 59779, 59919, 60059, 60199, 60338, 60477, 60615, 60753,
    60891, 61029, 61166, 61303, 61440, 61576, 61712, 61848, 61984, 62119, 62254, 62388, 62523,
    62657, 62790, 62924, 63057, 63190, 63323, 63455, 63587, 63719, 63850, 63982, 64113, 64243,
    64374, 64504, 64634, 64763, 64893, 65022, 65151, 65279, 65408,
};

void jak3_overlord_init_globals_ssound() {
  g_bSoundEnable = true;
  g_n989Semaphore = -1;
  g_EarTransSema = -1;
  for (auto& x : g_anStreamVoice) {
    x = 0;
  }
  for (auto& x : gSounds) {
    x = {};
  }
  unktable.fill(0);
  g_CameraInvert = false;
  gLastTick = 0;
}
void InitSound() {
  for (auto& sound : gSounds) {
    sound.id = 0;
  }

  int j = 0;
  do {
    unktable[j] = 0;
    unktable[j + 0x2c] = 0;
    unktable[j + 0x58] = 0;
    unktable[j + 0x84] = 0;
    unktable[j + 0xb0] = 0;
    j = j + 1;
  } while (j < 0x29);

  SetCurve(0, 0, 0, 1, 0, 0, 0, 0);
  SetCurve(1, 0, 0, 0, 0, 0, 1, 0);
  SetCurve(2, 0, 0, 1, 0, 0, 0, 0);
  SetCurve(3, 0x1000, 0, 1, 0, 0, 0, 0);
  SetCurve(4, 0, 0x1000, 1, 0, 0, 0, 0);
  SetCurve(5, 0x800, 0, 1, 0, 0, 0, 0);
  SetCurve(6, 0x800, 0x800, 1, 0, 0, 0, 0);
  SetCurve(7, 0xfffff000, 0, 1, 0, 0, 0, 0);
  SetCurve(8, 0xfffff800, 0, 1, 0, 0, 0, 0);
  SetCurve(9, 0, 0, 1, 0, 0, 0, 0);
  SetCurve(10, 0, 0, 0, 0, 0, 0, 0);
  SetCurve(0xb, 0, 0, 1, 0, 0, 0, 0);
  SetCurve(0xc, 0, 0, 1, 0, 1, 0, 0);
  SetCurve(0xd, 0x1000, 0, 1, 0, 1, 0, 0);
  SetCurve(0xe, 0, 0x1000, 1, 0, 1, 0, 0);
  SetCurve(0xf, 0x800, 0, 1, 0, 1, 0, 0);
  SetCurve(0x10, 0x800, 0x800, 1, 0, 1, 0, 0);
  SetCurve(0x11, 0xfffff000, 0, 1, 0, 1, 0, 0);
  SetCurve(0x12, 0xfffff800, 0, 1, 0, 1, 0, 0);
  SetCurve(0x13, 0, 0, 0, 0, 1, 0, 0);
  SetCurve(0x14, 0, 0, 0, 0, 0, 1, 1);
  SetCurve(0x15, 0, 0, 1, 0, 0, 0, 1);
  SetCurve(0x16, 0x1000, 0, 1, 0, 0, 0, 1);
  SetCurve(0x17, 0, 0x1000, 1, 0, 0, 0, 1);
  SetCurve(0x18, 0x800, 0, 1, 0, 0, 0, 1);
  SetCurve(0x19, 0x800, 0x800, 1, 0, 0, 0, 1);
  SetCurve(0x1a, 0xfffff000, 0, 1, 0, 0, 0, 1);
  SetCurve(0x1b, 0xfffff800, 0, 1, 0, 0, 0, 1);
  SetCurve(0x1c, 0, 0, 1, 0, 0, 0, 1);
  SetCurve(0x1d, 0, 0, 0, 0, 0, 0, 1);
  SetCurve(0x1e, 0, 0, 1, 0, 0, 0, 1);
  SetCurve(0x1f, 0, 0, 1, 0, 1, 0, 1);
  SetCurve(0x20, 0x1000, 0, 1, 0, 1, 0, 1);
  SetCurve(0x21, 0, 0x1000, 1, 0, 1, 0, 1);
  SetCurve(0x22, 0x800, 0, 1, 0, 1, 0, 1);
  SetCurve(0x23, 0x800, 0x800, 1, 0, 1, 0, 1);
  SetCurve(0x24, 0xfffff000, 0, 1, 0, 1, 0, 1);
  SetCurve(0x25, 0xfffff800, 0, 1, 0, 1, 0, 1);
  SetCurve(0x26, 0, 0, 0, 0, 1, 0, 1);
  SetCurve(0x27, 0, 0, 1, 1, 0, 1, 0);
  SetCurve(0x28, 0, 0, 1, 1, 0, 1, 1);

  // changed
  // snd_StartSoundSystemEx(2);
  snd_StartSoundSystem();

  // iVar4 = 5;
  // snd_RegisterIOPMemAllocator(FUN_0000dc7c,FUN_0000de84);
  // snd_LockVoiceAllocatorEx(1,0x12345678);
  //  piVar1 = g_anStreamVoice;
  //  do {
  //    iVar2 = snd_ExternVoiceAlloc(2,0x7f);
  //    iVar4 = iVar4 + -1;
  //    *piVar1 = iVar2 * 2 + ((iVar2 / 6 + (iVar2 >> 0x1f) >> 2) - (iVar2 >> 0x1f)) * -0x2f;
  //    piVar1 = piVar1 + 1;
  //  } while (-1 < iVar4);

  g_anStreamVoice[0] = SD_VOICE(0, 0);
  g_anStreamVoice[1] = SD_VOICE(0, 1);
  g_anStreamVoice[2] = SD_VOICE(0, 2);
  g_anStreamVoice[3] = SD_VOICE(0, 3);
  g_anStreamVoice[4] = SD_VOICE(0, 4);
  g_anStreamVoice[5] = SD_VOICE(0, 5);

  // snd_UnlockVoiceAllocator();
  //  snd_SetMixerMode(0,0);
  //  iVar4 = 0;
  //  do {
  //    iVar2 = iVar4 + 1;
  //    snd_SetGroupVoiceRange(iVar4,6,0x2f);
  //    iVar4 = iVar2;
  //  } while (iVar2 < 0xe);
  //  snd_SetGroupVoiceRange(2,0,5);

  // what is this even doing.
  //  sceSdGetAddr(0x1c00);
  //  sceSdGetAddr(0x1d00);
  //  sceSdGetAddr(0x1c01);
  //  sceSdGetAddr(0x1d01);
  //  CpuSuspendIntr(local_18);
  //  sceSdSetAddr(0,0);
  //  sceSdSetAddr(1,0);
  //  sceSdSetAddr(0,0xff);
  //  sceSdSetAddr(1,0xff);
  //  CpuResumeIntr(local_18[0]);

  //  uVar3 = sceSdGetAddr(0x1c01);
  //  snd_SRAMMarkUsed(uVar3,0x7000);
  //  uVar3 = sceSdGetAddr(0x1c00);
  //  snd_SRAMMarkUsed(uVar3,0x7000);
  //  local_3c = 0x104;
  //  local_36 = 0xa7b;
  //  local_38 = 0xa7b;
  //  g_nCore1ReverbMode = 4;
  //  g_nCore0ReverbMode = 4;
  //  local_34 = 0;
  //  local_30 = 0;
  //  local_40 = 0;
  //  sceSdSetEffectAttr(0, &local_40);
  //  local_40 = 1;
  //  sceSdSetEffectAttr(1, &local_40);
  //  maybe_sceSdSetCoreAttr(2, 1);
  //  maybe_sceSdSetCoreAttr(3, 1);

  // TODO: this is possibly very wrong:
  // g_aPanTable = snd_GetPanTable();
  for (int i = 0; i < 91; i++) {
    s16 opposing_front = static_cast<s16>(((i * 0x33ff) / 90) + 0xc00);

    s16 rear_right = static_cast<s16>(((i * -0x2800) / 90) + 0x3400);
    s16 rear_left = static_cast<s16>(((i * -0xbff) / 90) + 0x3fff);

    g_aPanTable[90 - i].left = 0x3FFF;
    g_aPanTable[180 - i].left = opposing_front;
    g_aPanTable[270 - i].left = rear_right;
    g_aPanTable[360 - i].left = rear_left;

    g_aPanTable[i].right = opposing_front;
    g_aPanTable[90 + i].right = 0x3FFF;
    g_aPanTable[180 + i].right = rear_left;
    g_aPanTable[270 + i].right = rear_right;
  }

  SetPlaybackMode(2);

  SemaParam param;
  param.attr = 1;
  param.init_count = 1;
  param.max_count = 1;
  param.option = 0;
  g_nMusicSemaphore = CreateSema(&param);
  ASSERT(g_nMusicSemaphore >= 0);
  param.attr = 1;
  param.init_count = 1;
  param.max_count = 1;
  param.option = 0;
  g_n989Semaphore = CreateSema(&param);
  ASSERT(g_n989Semaphore >= 0);

  param.max_count = 1;
  param.attr = 1;
  param.init_count = 1;
  param.option = 0;
  g_EarTransSema = CreateSema(&param);
  ASSERT(g_EarTransSema >= 0);

  // Init989Plugins();
  // InitStreamLfoHandler();
  // InitVagStreamList((List*)&g_PluginStreamsList, 4, s_plugin_00015918);
  InitVagStreamList(&g_EEStreamsList, 4, "ee");
  InitVagStreamList(&g_EEPlayList, 8, "play");
  InitVagStreamList(&g_RequestedStreamsList, 8, "streams");
  InitVagStreamList(&g_NewStreamsList, 4, "new");
}

void PrintSounds() {
  for (auto& sound : gSounds) {
    printf("SOUND %d %s\n", sound.id, sound.name.data);
    printf(" still playing? %d\n", snd_SoundIsStillPlaying(sound.sound_handle));
  }
}

SoundInfo* LookupSound(int id) {
  if (id == 0) {
    return nullptr;
  }

  for (auto& sound : gSounds) {
    if (sound.id == id) {
      s32 handle = snd_SoundIsStillPlaying(sound.sound_handle);
      sound.sound_handle = handle;
      if (handle) {
        return &sound;
      } else {
        sound.id = 0;
        return nullptr;
      }
    }
  }

  return nullptr;
}

void CleanSounds() {
  for (auto& sound : gSounds) {
    if (sound.id) {
      s32 handle = snd_SoundIsStillPlaying(sound.sound_handle);
      sound.sound_handle = handle;
      if (handle == 0) {
        sound.id = 0;
      }
    }
  }
}

void KillSoundsInGroup(u32 group) {
  for (auto& sound : gSounds) {
    if (sound.id) {
      s32 handle = snd_SoundIsStillPlaying(sound.sound_handle);
      sound.sound_handle = handle;
      if (handle) {
        if (sound.params.group & group) {
          snd_StopSound(handle);
          sound.id = 0;
        }
      } else {
        sound.id = 0;
      }
    }
  }
}

void KillLeastUsefulSound() {
  int unique_sounds = 0;
  struct Entry {
    u32 id;
    u32 count;
    SoundInfo* info;
  };
  Entry entries[kNumSounds];
  Entry* best_entry = nullptr;

  for (auto& sound : gSounds) {
    if (sound.id) {
      Entry* existing_entry = nullptr;
      u32 uid = snd_GetSoundID(sound.sound_handle);

      // look for entry:
      for (int i = 0; i < unique_sounds; i++) {
        if (entries[i].id == uid) {
          existing_entry = &entries[i];
          break;
        }
      }

      // if none found, create
      if (!existing_entry) {
        existing_entry = &entries[unique_sounds];
        unique_sounds++;
        existing_entry->id = uid;
        existing_entry->count = 0;
        existing_entry->info = &sound;
      }

      // update
      existing_entry->count++;

      // se if we're best
      if (!best_entry) {
        best_entry = existing_entry;
      } else {
        if (best_entry->count < existing_entry->count) {
          best_entry = existing_entry;
        }
      }

      // update entry:

      // update best:
    }
  }

  if (best_entry) {
    snd_StopSound(best_entry->info->sound_handle);
    best_entry->info->id = 0;
  }
}

SoundInfo* AllocateSound() {
  for (auto& sound : gSounds) {
    if (!sound.id) {
      return &sound;
    }
  }

  CleanSounds();
  for (auto& sound : gSounds) {
    if (!sound.id) {
      return &sound;
    }
  }

  KillLeastUsefulSound();

  for (auto& sound : gSounds) {
    if (!sound.id) {
      return &sound;
    }
  }

  ASSERT_NOT_REACHED();
  return nullptr;
}

u32 CalculateFalloffVolume(s32* trans,
                           u32 vol,
                           u32 fo_curve,
                           u32 fo_min,
                           u32 fo_max,
                           u32* outa,
                           u32* outb) {
  ASSERT(fo_curve < 0x29);
  // undefined4 uVar1;
  u32 uVar2;
  int iVar3;
  int iVar4;
  u32 uVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  u32 uVar9;
  u32 uVar10;

  uVar10 = 0;
  WaitSema(g_EarTransSema);
  if (outa) {
    *outa = 0;
  }
  if (outb) {
    *outb = 0;
  }
  if (unktable[fo_curve + 0x84] != 0) {
    SignalSema(g_EarTransSema);
    return vol;
  }
  if (unktable[fo_curve + 0x58] != 0) {
    trans = gEarTrans + 3;
  }
  switch (fo_curve) {
    case 9:
    case 0xb:
    case 0x1c:
    case 0x1e:
      iVar8 = gEarTrans[3] - *trans;
      iVar3 = gEarTrans[4] - trans[1];
      iVar7 = gEarTrans[5] - trans[2];
      uVar2 = 3;
      if (outa) {
      LAB_0000d094:
        *outa = uVar2;
      }
      break;
    case 10:
    case 0x13:
    case 0x1d:
    case 0x26:
      iVar8 = 0;
      iVar3 = gEarTrans[1] - trans[1];
      iVar7 = 0;
      if (outa) {
        *outa = 2;
      }
      goto LAB_0000d0a4;
    default:
      iVar8 = gEarTrans[0] - *trans;
      iVar7 = gEarTrans[2] - trans[2];
      iVar3 = gEarTrans[1] - trans[1];
      if (outa) {
        uVar2 = 1;
        goto LAB_0000d094;
      }
  }
  if (iVar8 < 0) {
    iVar8 = -iVar8;
  }
LAB_0000d0a4:
  if (iVar3 < 0) {
    iVar3 = -iVar3;
  }
  if (iVar7 < 0) {
    iVar7 = -iVar7;
  }
  fo_min = fo_min << 8;
  fo_max = fo_max << 8;
  uVar9 = 0;
  iVar6 = iVar3;
  if (iVar3 < iVar7) {
    iVar6 = iVar7;
  }
  iVar4 = fo_max;
  if (fo_max < iVar8) {
    iVar4 = iVar8;
  }
  if (iVar4 < iVar6) {
    iVar4 = iVar6;
  }
  while (0x7fff < iVar4) {
    fo_max = fo_max >> 1;
    fo_min = fo_min >> 1;
    iVar8 = iVar8 >> 1;
    iVar3 = iVar3 >> 1;
    iVar7 = iVar7 >> 1;
    uVar9 = uVar9 + 1;
    iVar4 = iVar4 >> 1;
  }
  if (gCamScale != 0x10000) {
    iVar8 = iVar8 * gCamScale >> 0x10;
    iVar3 = iVar3 * gCamScale >> 0x10;
    iVar7 = iVar7 * gCamScale >> 0x10;
    if (0x10000 < gCamScale) {
      iVar6 = iVar3;
      if (iVar3 < iVar7) {
        iVar6 = iVar7;
      }
      iVar4 = fo_max;
      if (fo_max < iVar8) {
        iVar4 = iVar8;
      }
      if (iVar4 < iVar6) {
        iVar4 = iVar6;
      }
      while (0x7fff < iVar4) {
        fo_max = fo_max >> 1;
        fo_min = fo_min >> 1;
        iVar8 = iVar8 >> 1;
        iVar3 = iVar3 >> 1;
        iVar7 = iVar7 >> 1;
        uVar9 = uVar9 + 1;
        iVar4 = iVar4 >> 1;
      }
    }
  }
  if ((outb) || (((iVar8 <= fo_max && (iVar3 <= fo_max)) && (iVar7 <= fo_max)))) {
    uVar10 = iVar8 * iVar8 + iVar3 * iVar3 + iVar7 * iVar7;
    iVar8 = 0;
    if (uVar10 != 0) {
      uVar5 = 0;
      while ((uVar10 & 0xc0000000) == 0) {
        uVar10 = uVar10 << 2;
        uVar5 = uVar5 + 1;
      }
      iVar8 = (int)(u32)sqrt_table[uVar10 >> 0x18] >> (uVar5 & 0x1f);
    }
    if (outb) {
      *outb = iVar8 << (uVar9 & 0x1f);
    }
    uVar10 = vol;
    if ((fo_min < iVar8) && (uVar10 = 0, iVar8 < fo_max)) {
      uVar10 = iVar8 - fo_min;
      uVar9 = fo_max - fo_min;
      while (0xffff < uVar10) {
        uVar10 = uVar10 >> 1;
        uVar9 = (int)uVar9 >> 1;
      }
      uVar5 = (uVar10 << 0x10) / uVar9;
      if (uVar9 == 0) {
        ASSERT_NOT_REACHED();
      }
      uVar10 = vol;
      if (uVar5 != 0x10000) {
        uVar10 = uVar5 * uVar5 >> 0x10;
        uVar10 = gCurves[fo_curve].c * uVar5 + gCurves[fo_curve].b * uVar10 +
                     gCurves[fo_curve].d * 0x10000 +
                     gCurves[fo_curve].a * (uVar10 * uVar5 >> 0x10) >>
                 0xc;
        if ((int)uVar10 < 0) {
          uVar10 = 0;
        } else {
          if (0x10000 < uVar10) {
            uVar10 = 0x10000;
          }
        }
        uVar10 = (int)(uVar10 * vol) >> 0x10;
      }
    }
  }
  if ((fo_curve == 0xb) && (uVar10 < 0x180)) {
    uVar10 = 0x180;
  }
  SignalSema(g_EarTransSema);
  return uVar10;
}

constexpr s16 unk_table_2[2056] = {
    0xB4,  0x0,   0xB4,  0x0,   0x5A,  0x5A,  0x10E, 0x10E, 0xB4,  0x0,   0xB4,  0x0,   0x5A,
    0x5A,  0x10E, 0x10E, 0xB4,  0x0,   0xB4,  0x0,   0x5A,  0x5A,  0x10E, 0x10E, 0xB4,  0x0,
    0xB4,  0x0,   0x5A,  0x5A,  0x10E, 0x10E, 0xB4,  0x0,   0xB4,  0x0,   0x5A,  0x5A,  0x10E,
    0x10E, 0xB3,  0x1,   0xB5,  0x167, 0x5B,  0x59,  0x10D, 0x10F, 0xB3,  0x1,   0xB5,  0x167,
    0x5B,  0x59,  0x10D, 0x10F, 0xB3,  0x1,   0xB5,  0x167, 0x5B,  0x59,  0x10D, 0x10F, 0xB3,
    0x1,   0xB5,  0x167, 0x5B,  0x59,  0x10D, 0x10F, 0xB2,  0x2,   0xB6,  0x166, 0x5C,  0x58,
    0x10C, 0x110, 0xB2,  0x2,   0xB6,  0x166, 0x5C,  0x58,  0x10C, 0x110, 0xB2,  0x2,   0xB6,
    0x166, 0x5C,  0x58,  0x10C, 0x110, 0xB2,  0x2,   0xB6,  0x166, 0x5C,  0x58,  0x10C, 0x110,
    0xB2,  0x2,   0xB6,  0x166, 0x5C,  0x58,  0x10C, 0x110, 0xB1,  0x3,   0xB7,  0x165, 0x5D,
    0x57,  0x10B, 0x111, 0xB1,  0x3,   0xB7,  0x165, 0x5D,  0x57,  0x10B, 0x111, 0xB1,  0x3,
    0xB7,  0x165, 0x5D,  0x57,  0x10B, 0x111, 0xB1,  0x3,   0xB7,  0x165, 0x5D,  0x57,  0x10B,
    0x111, 0xB0,  0x4,   0xB8,  0x164, 0x5E,  0x56,  0x10A, 0x112, 0xB0,  0x4,   0xB8,  0x164,
    0x5E,  0x56,  0x10A, 0x112, 0xB0,  0x4,   0xB8,  0x164, 0x5E,  0x56,  0x10A, 0x112, 0xB0,
    0x4,   0xB8,  0x164, 0x5E,  0x56,  0x10A, 0x112, 0xB0,  0x4,   0xB8,  0x164, 0x5E,  0x56,
    0x10A, 0x112, 0xAF,  0x5,   0xB9,  0x163, 0x5F,  0x55,  0x109, 0x113, 0xAF,  0x5,   0xB9,
    0x163, 0x5F,  0x55,  0x109, 0x113, 0xAF,  0x5,   0xB9,  0x163, 0x5F,  0x55,  0x109, 0x113,
    0xAF,  0x5,   0xB9,  0x163, 0x5F,  0x55,  0x109, 0x113, 0xAE,  0x6,   0xBA,  0x162, 0x60,
    0x54,  0x108, 0x114, 0xAE,  0x6,   0xBA,  0x162, 0x60,  0x54,  0x108, 0x114, 0xAE,  0x6,
    0xBA,  0x162, 0x60,  0x54,  0x108, 0x114, 0xAE,  0x6,   0xBA,  0x162, 0x60,  0x54,  0x108,
    0x114, 0xAE,  0x6,   0xBA,  0x162, 0x60,  0x54,  0x108, 0x114, 0xAD,  0x7,   0xBB,  0x161,
    0x61,  0x53,  0x107, 0x115, 0xAD,  0x7,   0xBB,  0x161, 0x61,  0x53,  0x107, 0x115, 0xAD,
    0x7,   0xBB,  0x161, 0x61,  0x53,  0x107, 0x115, 0xAD,  0x7,   0xBB,  0x161, 0x61,  0x53,
    0x107, 0x115, 0xAC,  0x8,   0xBC,  0x160, 0x62,  0x52,  0x106, 0x116, 0xAC,  0x8,   0xBC,
    0x160, 0x62,  0x52,  0x106, 0x116, 0xAC,  0x8,   0xBC,  0x160, 0x62,  0x52,  0x106, 0x116,
    0xAC,  0x8,   0xBC,  0x160, 0x62,  0x52,  0x106, 0x116, 0xAC,  0x8,   0xBC,  0x160, 0x62,
    0x52,  0x106, 0x116, 0xAB,  0x9,   0xBD,  0x15F, 0x63,  0x51,  0x105, 0x117, 0xAB,  0x9,
    0xBD,  0x15F, 0x63,  0x51,  0x105, 0x117, 0xAB,  0x9,   0xBD,  0x15F, 0x63,  0x51,  0x105,
    0x117, 0xAB,  0x9,   0xBD,  0x15F, 0x63,  0x51,  0x105, 0x117, 0xAB,  0x9,   0xBD,  0x15F,
    0x63,  0x51,  0x105, 0x117, 0xAA,  0xA,   0xBE,  0x15E, 0x64,  0x50,  0x104, 0x118, 0xAA,
    0xA,   0xBE,  0x15E, 0x64,  0x50,  0x104, 0x118, 0xAA,  0xA,   0xBE,  0x15E, 0x64,  0x50,
    0x104, 0x118, 0xAA,  0xA,   0xBE,  0x15E, 0x64,  0x50,  0x104, 0x118, 0xA9,  0xB,   0xBF,
    0x15D, 0x65,  0x4F,  0x103, 0x119, 0xA9,  0xB,   0xBF,  0x15D, 0x65,  0x4F,  0x103, 0x119,
    0xA9,  0xB,   0xBF,  0x15D, 0x65,  0x4F,  0x103, 0x119, 0xA9,  0xB,   0xBF,  0x15D, 0x65,
    0x4F,  0x103, 0x119, 0xA9,  0xB,   0xBF,  0x15D, 0x65,  0x4F,  0x103, 0x119, 0xA8,  0xC,
    0xC0,  0x15C, 0x66,  0x4E,  0x102, 0x11A, 0xA8,  0xC,   0xC0,  0x15C, 0x66,  0x4E,  0x102,
    0x11A, 0xA8,  0xC,   0xC0,  0x15C, 0x66,  0x4E,  0x102, 0x11A, 0xA8,  0xC,   0xC0,  0x15C,
    0x66,  0x4E,  0x102, 0x11A, 0xA8,  0xC,   0xC0,  0x15C, 0x66,  0x4E,  0x102, 0x11A, 0xA7,
    0xD,   0xC1,  0x15B, 0x67,  0x4D,  0x101, 0x11B, 0xA7,  0xD,   0xC1,  0x15B, 0x67,  0x4D,
    0x101, 0x11B, 0xA7,  0xD,   0xC1,  0x15B, 0x67,  0x4D,  0x101, 0x11B, 0xA7,  0xD,   0xC1,
    0x15B, 0x67,  0x4D,  0x101, 0x11B, 0xA6,  0xE,   0xC2,  0x15A, 0x68,  0x4C,  0x100, 0x11C,
    0xA6,  0xE,   0xC2,  0x15A, 0x68,  0x4C,  0x100, 0x11C, 0xA6,  0xE,   0xC2,  0x15A, 0x68,
    0x4C,  0x100, 0x11C, 0xA6,  0xE,   0xC2,  0x15A, 0x68,  0x4C,  0x100, 0x11C, 0xA6,  0xE,
    0xC2,  0x15A, 0x68,  0x4C,  0x100, 0x11C, 0xA5,  0xF,   0xC3,  0x159, 0x69,  0x4B,  0xFF,
    0x11D, 0xA5,  0xF,   0xC3,  0x159, 0x69,  0x4B,  0xFF,  0x11D, 0xA5,  0xF,   0xC3,  0x159,
    0x69,  0x4B,  0xFF,  0x11D, 0xA5,  0xF,   0xC3,  0x159, 0x69,  0x4B,  0xFF,  0x11D, 0xA5,
    0xF,   0xC3,  0x159, 0x69,  0x4B,  0xFF,  0x11D, 0xA4,  0x10,  0xC4,  0x158, 0x6A,  0x4A,
    0xFE,  0x11E, 0xA4,  0x10,  0xC4,  0x158, 0x6A,  0x4A,  0xFE,  0x11E, 0xA4,  0x10,  0xC4,
    0x158, 0x6A,  0x4A,  0xFE,  0x11E, 0xA4,  0x10,  0xC4,  0x158, 0x6A,  0x4A,  0xFE,  0x11E,
    0xA4,  0x10,  0xC4,  0x158, 0x6A,  0x4A,  0xFE,  0x11E, 0xA3,  0x11,  0xC5,  0x157, 0x6B,
    0x49,  0xFD,  0x11F, 0xA3,  0x11,  0xC5,  0x157, 0x6B,  0x49,  0xFD,  0x11F, 0xA3,  0x11,
    0xC5,  0x157, 0x6B,  0x49,  0xFD,  0x11F, 0xA3,  0x11,  0xC5,  0x157, 0x6B,  0x49,  0xFD,
    0x11F, 0xA3,  0x11,  0xC5,  0x157, 0x6B,  0x49,  0xFD,  0x11F, 0xA2,  0x12,  0xC6,  0x156,
    0x6C,  0x48,  0xFC,  0x120, 0xA2,  0x12,  0xC6,  0x156, 0x6C,  0x48,  0xFC,  0x120, 0xA2,
    0x12,  0xC6,  0x156, 0x6C,  0x48,  0xFC,  0x120, 0xA2,  0x12,  0xC6,  0x156, 0x6C,  0x48,
    0xFC,  0x120, 0xA2,  0x12,  0xC6,  0x156, 0x6C,  0x48,  0xFC,  0x120, 0xA1,  0x13,  0xC7,
    0x155, 0x6D,  0x47,  0xFB,  0x121, 0xA1,  0x13,  0xC7,  0x155, 0x6D,  0x47,  0xFB,  0x121,
    0xA1,  0x13,  0xC7,  0x155, 0x6D,  0x47,  0xFB,  0x121, 0xA1,  0x13,  0xC7,  0x155, 0x6D,
    0x47,  0xFB,  0x121, 0xA1,  0x13,  0xC7,  0x155, 0x6D,  0x47,  0xFB,  0x121, 0xA0,  0x14,
    0xC8,  0x154, 0x6E,  0x46,  0xFA,  0x122, 0xA0,  0x14,  0xC8,  0x154, 0x6E,  0x46,  0xFA,
    0x122, 0xA0,  0x14,  0xC8,  0x154, 0x6E,  0x46,  0xFA,  0x122, 0xA0,  0x14,  0xC8,  0x154,
    0x6E,  0x46,  0xFA,  0x122, 0xA0,  0x14,  0xC8,  0x154, 0x6E,  0x46,  0xFA,  0x122, 0x9F,
    0x15,  0xC9,  0x153, 0x6F,  0x45,  0xF9,  0x123, 0x9F,  0x15,  0xC9,  0x153, 0x6F,  0x45,
    0xF9,  0x123, 0x9F,  0x15,  0xC9,  0x153, 0x6F,  0x45,  0xF9,  0x123, 0x9F,  0x15,  0xC9,
    0x153, 0x6F,  0x45,  0xF9,  0x123, 0x9F,  0x15,  0xC9,  0x153, 0x6F,  0x45,  0xF9,  0x123,
    0x9E,  0x16,  0xCA,  0x152, 0x70,  0x44,  0xF8,  0x124, 0x9E,  0x16,  0xCA,  0x152, 0x70,
    0x44,  0xF8,  0x124, 0x9E,  0x16,  0xCA,  0x152, 0x70,  0x44,  0xF8,  0x124, 0x9E,  0x16,
    0xCA,  0x152, 0x70,  0x44,  0xF8,  0x124, 0x9E,  0x16,  0xCA,  0x152, 0x70,  0x44,  0xF8,
    0x124, 0x9D,  0x17,  0xCB,  0x151, 0x71,  0x43,  0xF7,  0x125, 0x9D,  0x17,  0xCB,  0x151,
    0x71,  0x43,  0xF7,  0x125, 0x9D,  0x17,  0xCB,  0x151, 0x71,  0x43,  0xF7,  0x125, 0x9D,
    0x17,  0xCB,  0x151, 0x71,  0x43,  0xF7,  0x125, 0x9D,  0x17,  0xCB,  0x151, 0x71,  0x43,
    0xF7,  0x125, 0x9D,  0x17,  0xCB,  0x151, 0x71,  0x43,  0xF7,  0x125, 0x9C,  0x18,  0xCC,
    0x150, 0x72,  0x42,  0xF6,  0x126, 0x9C,  0x18,  0xCC,  0x150, 0x72,  0x42,  0xF6,  0x126,
    0x9C,  0x18,  0xCC,  0x150, 0x72,  0x42,  0xF6,  0x126, 0x9C,  0x18,  0xCC,  0x150, 0x72,
    0x42,  0xF6,  0x126, 0x9C,  0x18,  0xCC,  0x150, 0x72,  0x42,  0xF6,  0x126, 0x9B,  0x19,
    0xCD,  0x14F, 0x73,  0x41,  0xF5,  0x127, 0x9B,  0x19,  0xCD,  0x14F, 0x73,  0x41,  0xF5,
    0x127, 0x9B,  0x19,  0xCD,  0x14F, 0x73,  0x41,  0xF5,  0x127, 0x9B,  0x19,  0xCD,  0x14F,
    0x73,  0x41,  0xF5,  0x127, 0x9B,  0x19,  0xCD,  0x14F, 0x73,  0x41,  0xF5,  0x127, 0x9A,
    0x1A,  0xCE,  0x14E, 0x74,  0x40,  0xF4,  0x128, 0x9A,  0x1A,  0xCE,  0x14E, 0x74,  0x40,
    0xF4,  0x128, 0x9A,  0x1A,  0xCE,  0x14E, 0x74,  0x40,  0xF4,  0x128, 0x9A,  0x1A,  0xCE,
    0x14E, 0x74,  0x40,  0xF4,  0x128, 0x9A,  0x1A,  0xCE,  0x14E, 0x74,  0x40,  0xF4,  0x128,
    0x9A,  0x1A,  0xCE,  0x14E, 0x74,  0x40,  0xF4,  0x128, 0x99,  0x1B,  0xCF,  0x14D, 0x75,
    0x3F,  0xF3,  0x129, 0x99,  0x1B,  0xCF,  0x14D, 0x75,  0x3F,  0xF3,  0x129, 0x99,  0x1B,
    0xCF,  0x14D, 0x75,  0x3F,  0xF3,  0x129, 0x99,  0x1B,  0xCF,  0x14D, 0x75,  0x3F,  0xF3,
    0x129, 0x99,  0x1B,  0xCF,  0x14D, 0x75,  0x3F,  0xF3,  0x129, 0x99,  0x1B,  0xCF,  0x14D,
    0x75,  0x3F,  0xF3,  0x129, 0x98,  0x1C,  0xD0,  0x14C, 0x76,  0x3E,  0xF2,  0x12A, 0x98,
    0x1C,  0xD0,  0x14C, 0x76,  0x3E,  0xF2,  0x12A, 0x98,  0x1C,  0xD0,  0x14C, 0x76,  0x3E,
    0xF2,  0x12A, 0x98,  0x1C,  0xD0,  0x14C, 0x76,  0x3E,  0xF2,  0x12A, 0x98,  0x1C,  0xD0,
    0x14C, 0x76,  0x3E,  0xF2,  0x12A, 0x97,  0x1D,  0xD1,  0x14B, 0x77,  0x3D,  0xF1,  0x12B,
    0x97,  0x1D,  0xD1,  0x14B, 0x77,  0x3D,  0xF1,  0x12B, 0x97,  0x1D,  0xD1,  0x14B, 0x77,
    0x3D,  0xF1,  0x12B, 0x97,  0x1D,  0xD1,  0x14B, 0x77,  0x3D,  0xF1,  0x12B, 0x97,  0x1D,
    0xD1,  0x14B, 0x77,  0x3D,  0xF1,  0x12B, 0x97,  0x1D,  0xD1,  0x14B, 0x77,  0x3D,  0xF1,
    0x12B, 0x96,  0x1E,  0xD2,  0x14A, 0x78,  0x3C,  0xF0,  0x12C, 0x96,  0x1E,  0xD2,  0x14A,
    0x78,  0x3C,  0xF0,  0x12C, 0x96,  0x1E,  0xD2,  0x14A, 0x78,  0x3C,  0xF0,  0x12C, 0x96,
    0x1E,  0xD2,  0x14A, 0x78,  0x3C,  0xF0,  0x12C, 0x96,  0x1E,  0xD2,  0x14A, 0x78,  0x3C,
    0xF0,  0x12C, 0x96,  0x1E,  0xD2,  0x14A, 0x78,  0x3C,  0xF0,  0x12C, 0x95,  0x1F,  0xD3,
    0x149, 0x79,  0x3B,  0xEF,  0x12D, 0x95,  0x1F,  0xD3,  0x149, 0x79,  0x3B,  0xEF,  0x12D,
    0x95,  0x1F,  0xD3,  0x149, 0x79,  0x3B,  0xEF,  0x12D, 0x95,  0x1F,  0xD3,  0x149, 0x79,
    0x3B,  0xEF,  0x12D, 0x95,  0x1F,  0xD3,  0x149, 0x79,  0x3B,  0xEF,  0x12D, 0x95,  0x1F,
    0xD3,  0x149, 0x79,  0x3B,  0xEF,  0x12D, 0x94,  0x20,  0xD4,  0x148, 0x7A,  0x3A,  0xEE,
    0x12E, 0x94,  0x20,  0xD4,  0x148, 0x7A,  0x3A,  0xEE,  0x12E, 0x94,  0x20,  0xD4,  0x148,
    0x7A,  0x3A,  0xEE,  0x12E, 0x94,  0x20,  0xD4,  0x148, 0x7A,  0x3A,  0xEE,  0x12E, 0x94,
    0x20,  0xD4,  0x148, 0x7A,  0x3A,  0xEE,  0x12E, 0x94,  0x20,  0xD4,  0x148, 0x7A,  0x3A,
    0xEE,  0x12E, 0x94,  0x20,  0xD4,  0x148, 0x7A,  0x3A,  0xEE,  0x12E, 0x93,  0x21,  0xD5,
    0x147, 0x7B,  0x39,  0xED,  0x12F, 0x93,  0x21,  0xD5,  0x147, 0x7B,  0x39,  0xED,  0x12F,
    0x93,  0x21,  0xD5,  0x147, 0x7B,  0x39,  0xED,  0x12F, 0x93,  0x21,  0xD5,  0x147, 0x7B,
    0x39,  0xED,  0x12F, 0x93,  0x21,  0xD5,  0x147, 0x7B,  0x39,  0xED,  0x12F, 0x93,  0x21,
    0xD5,  0x147, 0x7B,  0x39,  0xED,  0x12F, 0x92,  0x22,  0xD6,  0x146, 0x7C,  0x38,  0xEC,
    0x130, 0x92,  0x22,  0xD6,  0x146, 0x7C,  0x38,  0xEC,  0x130, 0x92,  0x22,  0xD6,  0x146,
    0x7C,  0x38,  0xEC,  0x130, 0x92,  0x22,  0xD6,  0x146, 0x7C,  0x38,  0xEC,  0x130, 0x92,
    0x22,  0xD6,  0x146, 0x7C,  0x38,  0xEC,  0x130, 0x92,  0x22,  0xD6,  0x146, 0x7C,  0x38,
    0xEC,  0x130, 0x92,  0x22,  0xD6,  0x146, 0x7C,  0x38,  0xEC,  0x130, 0x91,  0x23,  0xD7,
    0x145, 0x7D,  0x37,  0xEB,  0x131, 0x91,  0x23,  0xD7,  0x145, 0x7D,  0x37,  0xEB,  0x131,
    0x91,  0x23,  0xD7,  0x145, 0x7D,  0x37,  0xEB,  0x131, 0x91,  0x23,  0xD7,  0x145, 0x7D,
    0x37,  0xEB,  0x131, 0x91,  0x23,  0xD7,  0x145, 0x7D,  0x37,  0xEB,  0x131, 0x91,  0x23,
    0xD7,  0x145, 0x7D,  0x37,  0xEB,  0x131, 0x91,  0x23,  0xD7,  0x145, 0x7D,  0x37,  0xEB,
    0x131, 0x90,  0x24,  0xD8,  0x144, 0x7E,  0x36,  0xEA,  0x132, 0x90,  0x24,  0xD8,  0x144,
    0x7E,  0x36,  0xEA,  0x132, 0x90,  0x24,  0xD8,  0x144, 0x7E,  0x36,  0xEA,  0x132, 0x90,
    0x24,  0xD8,  0x144, 0x7E,  0x36,  0xEA,  0x132, 0x90,  0x24,  0xD8,  0x144, 0x7E,  0x36,
    0xEA,  0x132, 0x90,  0x24,  0xD8,  0x144, 0x7E,  0x36,  0xEA,  0x132, 0x8F,  0x25,  0xD9,
    0x143, 0x7F,  0x35,  0xE9,  0x133, 0x8F,  0x25,  0xD9,  0x143, 0x7F,  0x35,  0xE9,  0x133,
    0x8F,  0x25,  0xD9,  0x143, 0x7F,  0x35,  0xE9,  0x133, 0x8F,  0x25,  0xD9,  0x143, 0x7F,
    0x35,  0xE9,  0x133, 0x8F,  0x25,  0xD9,  0x143, 0x7F,  0x35,  0xE9,  0x133, 0x8F,  0x25,
    0xD9,  0x143, 0x7F,  0x35,  0xE9,  0x133, 0x8F,  0x25,  0xD9,  0x143, 0x7F,  0x35,  0xE9,
    0x133, 0x8F,  0x25,  0xD9,  0x143, 0x7F,  0x35,  0xE9,  0x133, 0x8E,  0x26,  0xDA,  0x142,
    0x80,  0x34,  0xE8,  0x134, 0x8E,  0x26,  0xDA,  0x142, 0x80,  0x34,  0xE8,  0x134, 0x8E,
    0x26,  0xDA,  0x142, 0x80,  0x34,  0xE8,  0x134, 0x8E,  0x26,  0xDA,  0x142, 0x80,  0x34,
    0xE8,  0x134, 0x8E,  0x26,  0xDA,  0x142, 0x80,  0x34,  0xE8,  0x134, 0x8E,  0x26,  0xDA,
    0x142, 0x80,  0x34,  0xE8,  0x134, 0x8E,  0x26,  0xDA,  0x142, 0x80,  0x34,  0xE8,  0x134,
    0x8D,  0x27,  0xDB,  0x141, 0x81,  0x33,  0xE7,  0x135, 0x8D,  0x27,  0xDB,  0x141, 0x81,
    0x33,  0xE7,  0x135, 0x8D,  0x27,  0xDB,  0x141, 0x81,  0x33,  0xE7,  0x135, 0x8D,  0x27,
    0xDB,  0x141, 0x81,  0x33,  0xE7,  0x135, 0x8D,  0x27,  0xDB,  0x141, 0x81,  0x33,  0xE7,
    0x135, 0x8D,  0x27,  0xDB,  0x141, 0x81,  0x33,  0xE7,  0x135, 0x8D,  0x27,  0xDB,  0x141,
    0x81,  0x33,  0xE7,  0x135, 0x8C,  0x28,  0xDC,  0x140, 0x82,  0x32,  0xE6,  0x136, 0x8C,
    0x28,  0xDC,  0x140, 0x82,  0x32,  0xE6,  0x136, 0x8C,  0x28,  0xDC,  0x140, 0x82,  0x32,
    0xE6,  0x136, 0x8C,  0x28,  0xDC,  0x140, 0x82,  0x32,  0xE6,  0x136, 0x8C,  0x28,  0xDC,
    0x140, 0x82,  0x32,  0xE6,  0x136, 0x8C,  0x28,  0xDC,  0x140, 0x82,  0x32,  0xE6,  0x136,
    0x8C,  0x28,  0xDC,  0x140, 0x82,  0x32,  0xE6,  0x136, 0x8C,  0x28,  0xDC,  0x140, 0x82,
    0x32,  0xE6,  0x136, 0x8B,  0x29,  0xDD,  0x13F, 0x83,  0x31,  0xE5,  0x137, 0x8B,  0x29,
    0xDD,  0x13F, 0x83,  0x31,  0xE5,  0x137, 0x8B,  0x29,  0xDD,  0x13F, 0x83,  0x31,  0xE5,
    0x137, 0x8B,  0x29,  0xDD,  0x13F, 0x83,  0x31,  0xE5,  0x137, 0x8B,  0x29,  0xDD,  0x13F,
    0x83,  0x31,  0xE5,  0x137, 0x8B,  0x29,  0xDD,  0x13F, 0x83,  0x31,  0xE5,  0x137, 0x8B,
    0x29,  0xDD,  0x13F, 0x83,  0x31,  0xE5,  0x137, 0x8B,  0x29,  0xDD,  0x13F, 0x83,  0x31,
    0xE5,  0x137, 0x8A,  0x2A,  0xDE,  0x13E, 0x84,  0x30,  0xE4,  0x138, 0x8A,  0x2A,  0xDE,
    0x13E, 0x84,  0x30,  0xE4,  0x138, 0x8A,  0x2A,  0xDE,  0x13E, 0x84,  0x30,  0xE4,  0x138,
    0x8A,  0x2A,  0xDE,  0x13E, 0x84,  0x30,  0xE4,  0x138, 0x8A,  0x2A,  0xDE,  0x13E, 0x84,
    0x30,  0xE4,  0x138, 0x8A,  0x2A,  0xDE,  0x13E, 0x84,  0x30,  0xE4,  0x138, 0x8A,  0x2A,
    0xDE,  0x13E, 0x84,  0x30,  0xE4,  0x138, 0x8A,  0x2A,  0xDE,  0x13E, 0x84,  0x30,  0xE4,
    0x138, 0x89,  0x2B,  0xDF,  0x13D, 0x85,  0x2F,  0xE3,  0x139, 0x89,  0x2B,  0xDF,  0x13D,
    0x85,  0x2F,  0xE3,  0x139, 0x89,  0x2B,  0xDF,  0x13D, 0x85,  0x2F,  0xE3,  0x139, 0x89,
    0x2B,  0xDF,  0x13D, 0x85,  0x2F,  0xE3,  0x139, 0x89,  0x2B,  0xDF,  0x13D, 0x85,  0x2F,
    0xE3,  0x139, 0x89,  0x2B,  0xDF,  0x13D, 0x85,  0x2F,  0xE3,  0x139, 0x89,  0x2B,  0xDF,
    0x13D, 0x85,  0x2F,  0xE3,  0x139, 0x89,  0x2B,  0xDF,  0x13D, 0x85,  0x2F,  0xE3,  0x139,
    0x89,  0x2B,  0xDF,  0x13D, 0x85,  0x2F,  0xE3,  0x139, 0x88,  0x2C,  0xE0,  0x13C, 0x86,
    0x2E,  0xE2,  0x13A, 0x88,  0x2C,  0xE0,  0x13C, 0x86,  0x2E,  0xE2,  0x13A, 0x88,  0x2C,
    0xE0,  0x13C, 0x86,  0x2E,  0xE2,  0x13A, 0x88,  0x2C,  0xE0,  0x13C, 0x86,  0x2E,  0xE2,
    0x13A, 0x88,  0x2C,  0xE0,  0x13C, 0x86,  0x2E,  0xE2,  0x13A, 0x88,  0x2C,  0xE0,  0x13C,
    0x86,  0x2E,  0xE2,  0x13A, 0x88,  0x2C,  0xE0,  0x13C, 0x86,  0x2E,  0xE2,  0x13A, 0x88,
    0x2C,  0xE0,  0x13C, 0x86,  0x2E,  0xE2,  0x13A, 0x87,  0x2D,  0xE1,  0x13B, 0x87,  0x2D,
    0xE1,  0x13B,
};

s32 CalculateAngle(s32* trans, u32 fo_curve, u32 param_3) {
  u32 uVar2;
  int iVar3;
  u32 uVar4;
  u32 uVar5;
  int iVar6;
  int iVar7;
  u32 uVar8;
  ASSERT(fo_curve < 0x29);
  WaitSema(g_EarTransSema);
  if (unktable[fo_curve] != 0) {
    if (unktable[fo_curve + 0x2c] == 0) {
      if (unktable[fo_curve + 0x58] != 0) {
        trans = gEarTrans + 3;
      }
      iVar6 = trans[1];
      iVar3 = gCamTrans[0] - *trans;
      iVar7 = gCamTrans[2] - trans[2];
    } else {
      iVar7 = gCamForward[0] - gCamTrans[0];
      iVar3 = gCamTrans[2] - gCamForward[2];
      iVar6 = gCamForward[1];
    }
    iVar6 = gCamTrans[1] - iVar6;
    if (((iVar3 + 0x200168U | iVar6 + 0x200168U | iVar7 + 0x200168U) & 0xffc00000) != 0) {
      if (iVar3 < 0) {
        iVar3 = iVar3 + 0x3ff;
      }
      iVar3 = iVar3 >> 10;
      if (iVar6 < 0) {
        iVar6 = iVar6 + 0x3ff;
      }
      iVar6 = iVar6 >> 10;
      if (iVar7 < 0) {
        iVar7 = iVar7 + 0x3ff;
      }
      iVar7 = iVar7 >> 10;
    }
    uVar8 = iVar3 * gCamLeft[0] + iVar6 * gCamLeft[1] + iVar7 * gCamLeft[2];
    uVar5 = uVar8;
    if ((int)uVar8 < 0) {
      uVar5 = -uVar8;
    }
    uVar2 = iVar3 * gCamForward[0] + iVar6 * gCamForward[1] + iVar7 * gCamForward[2];
    uVar4 = uVar2;
    if ((int)uVar2 < 0) {
      uVar4 = -uVar2;
    }
    if ((0x1ffff < (int)uVar5) || (0x1ffff < (int)uVar4)) {
      uVar4 = (int)uVar4 >> 8;
      uVar5 = (int)uVar5 >> 8;
    }
    if ((uVar4 != 0) || (uVar5 != 0)) {
      uVar8 = (uVar8 & 0x80000000) >> 0x1e | uVar2 >> 0x1f;
      if ((int)uVar4 < (int)uVar5) {
        if (uVar5 == 0) {
          ASSERT_NOT_REACHED();
        }
        uVar8 = uVar8 | (int)(uVar4 << 8) / (int)uVar5 << 3 | 4;
      } else {
        if (uVar4 == 0) {
          ASSERT_NOT_REACHED();
        }
        uVar8 = uVar8 | (int)(uVar5 << 8) / (int)uVar4 << 3;
      }
      ASSERT(uVar8 < 2056);
      iVar3 = (int)(short)unk_table_2[uVar8];
      iVar6 = iVar3;
      if (((param_3 != 0) && (iVar6 = iVar3, g_CameraInvert != 0)) && (iVar6 = 0, iVar3 != 0)) {
        iVar6 = 0x168 - iVar3;
      }
      SignalSema(g_EarTransSema);
      return iVar6;
    }
  }
  SignalSema(g_EarTransSema);
  return 0;
}

s32 GetVolume(SoundInfo* sound) {
  return CalculateFalloffVolume(sound->params.trans, sound->params.volume, sound->params.fo_curve,
                                sound->params.fo_min, sound->params.fo_max, nullptr, nullptr);
}

s32 GetPan(SoundInfo* sound) {
  return CalculateAngle(sound->params.trans, sound->params.fo_curve, 1);
}

void UpdateLocation(SoundInfo* sound) {
  auto handle = snd_SoundIsStillPlaying(sound->sound_handle);
  sound->sound_handle = handle;
  if (handle == 0) {
    sound->id = 0;
  } else {
    auto vol = GetVolume(sound);
    if (vol == 0 && unktable[(int)(sound->params).fo_curve + 0xb0] == 0) {
      snd_StopSound(sound->sound_handle);
    } else {
      auto pan = GetPan(sound);
      // ovrld_log(LogCategory::WARN, "HACK: falling back to old version of setting vol/pan");
      snd_SetSoundVolPan(handle, vol, pan);

      //      FUN_00013e0c(handle,4,0,pan,0,0);
      //      if ((short)(sound->params).mask < 0) {
      //        FUN_00013d6c(handle,vol,0x40);
      //      }
      //      else {
      //        snd_SetSoundVolPan(handle,vol,0xfffffffe,4);
      //      }
    }
  }
}

void UpdateAutoVol(SoundInfo* snd, int time) {
  bool bVar1;
  auto iVar6 = snd->auto_time;
  auto iVar4 = snd->new_volume;
  if (time < iVar6) {
    auto iVar5 = iVar4;
    if (iVar4 == -4) {
      iVar5 = 0;
    }
    auto vol = (snd->params).volume;
    int new_vol;
    if (iVar6 == 0) {
      ASSERT_NOT_REACHED();
    }
    iVar5 = ((iVar5 - vol) * time) / iVar6;
    if (iVar5 < 0) {
      new_vol = vol + iVar5;
      bVar1 = new_vol < iVar4;
    } else {
      new_vol = vol + iVar5;
      if (iVar5 < 1) {
        new_vol = vol + 1;
      }
      bVar1 = iVar4 < new_vol;
    }
    (snd->params).volume = new_vol;
    if (bVar1) {
      (snd->params).volume = iVar4;
    }
    snd->auto_time = iVar6 - time;
  } else {
    if (iVar4 == -4) {
      snd_StopSound(snd->sound_handle);
      snd->id = 0;
    } else {
      (snd->params).volume = iVar4;
    }
    snd->auto_time = 0;
  }
}

void UpdateVolume(SoundInfo* sound) {
  auto handle = snd_SoundIsStillPlaying(sound->sound_handle);
  sound->sound_handle = handle;
  if (handle == 0) {
    sound->id = 0;
  } else {
    if ((s16)(sound->params).mask < 0) {
      // idk
      snd_SetSoundVolPan(handle, GetVolume(sound), -2);

      // FUN_00013d6c(handle, GetVolume(sound), 0x40, 4);
    } else {
      snd_SetSoundVolPan(handle, GetVolume(sound), -2);
    }
  }
}

void SetEarTrans(const s32* ear_trans0,
                 const s32* ear_trans1,
                 const s32* cam_trans,
                 const s32* cam_fwd,
                 const s32* cam_left,
                 s32 cam_scale,
                 bool cam_inverted) {
  auto tick = snd_GetTick();
  auto time = tick - gLastTick;
  gLastTick = tick;
  WaitSema(g_EarTransSema);
  gEarTrans[0] = *ear_trans0;
  g_CameraInvert = cam_inverted;
  gEarTrans[1] = ear_trans0[1];
  gEarTrans[2] = ear_trans0[2];
  gEarTrans[3] = *ear_trans1;
  gEarTrans[4] = ear_trans1[1];
  gEarTrans[5] = ear_trans1[2];
  gCamTrans[0] = *cam_trans;
  gCamTrans[1] = cam_trans[1];
  gCamTrans[2] = cam_trans[2];
  gCamForward[0] = *cam_fwd;
  gCamForward[1] = cam_fwd[1];
  gCamForward[2] = cam_fwd[2];
  gCamLeft[0] = *cam_left;
  gCamLeft[1] = cam_left[1];
  gCamLeft[2] = cam_left[2];
  gCamScale = cam_scale;
  SignalSema(g_EarTransSema);

  for (auto& sound : gSounds) {
    if (sound.id) {
      if (sound.auto_time) {
        UpdateAutoVol(&sound, time);
      }
      UpdateLocation(&sound);
    }
  }

  auto* cmd = g_aVagCmds;
  s32 iVar2 = 5;
  do {
    if ((cmd->music_flag == 0) && (cmd->maybe_sound_handler != 0)) {
      if ((cmd->flags.scanned == 0) || (cmd->flags.bit8 != 0)) {
        if (cmd->flags.bit20 == 0) {
          if ((u32)cmd->play_volume < 0x11) {
            cmd->play_volume = 0;
          } else {
            cmd->play_volume = cmd->play_volume - 0x10;
          }
          SetVAGVol(cmd);
          if (cmd->play_volume != 0)
            goto LAB_0000db94;
        }
      LAB_0000db78:
        StopVagStream(cmd);
      } else {
        time = snd_SoundIsStillPlaying(cmd->id);
        if (time != 0)
          goto LAB_0000db88;
        if (cmd->flags.bit20 != 0)
          goto LAB_0000db78;
        // CpuSuspendIntr(local_28);
        cmd->flags.bit8 = 1;
        // CpuResumeIntr(local_28[0]);
      }
    } else {
    LAB_0000db88:
      SetVAGVol(cmd);
    }
  LAB_0000db94:
    iVar2 = iVar2 + -1;
    cmd = cmd + 1;
    if (iVar2 < 0) {
      return;
    }
  } while (true);
}

void SetCurve(int param_1,
              u32 param_2,
              u32 param_3,
              uint8_t param_4,
              uint8_t param_5,
              uint8_t param_6,
              uint8_t param_7,
              uint8_t param_8) {
  gCurves[param_1].c = (param_3 - param_2) + -0x1000;
  gCurves[param_1].d = 0x1000;
  unktable[param_1 + 0xb0] = param_8;
  gCurves[param_1].b = param_2 + param_3 * -3;
  unktable[param_1] = param_4;
  unktable[param_1 + 0x2c] = param_5;
  unktable[param_1 + 0x58] = param_6;
  unktable[param_1 + 0x84] = param_7;
  gCurves[param_1].a = param_3 * 2;
}

void SetPlaybackMode(s32 mode) {
  g_nPlaybackMode = mode;
  snd_SetPlayBackMode(mode);
}

}  // namespace jak3